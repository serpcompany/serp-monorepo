[
  {
    "owner": "aws",
    "repo": "aws-cdk",
    "content": "TITLE: Configuring DynamoDB TableV2 Encryption with AWS Managed Key in TypeScript\nDESCRIPTION: This snippet demonstrates configuring a DynamoDB TableV2 instance to use an AWS managed KMS key for encryption. The `encryption` property is set to `dynamodb.TableEncryptionV2.awsManagedKey()`. These keys are stored in the user's account but managed by AWS KMS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryptionV2.awsManagedKey(),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing a CDK Project\nDESCRIPTION: Shell commands to create a new directory, navigate into it, and initialize a new CDK project using the sample app template with TypeScript.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmkdir hello-cdk\ncd hello-cdk\ncdk init sample-app --language=typescript\n```\n\n----------------------------------------\n\nTITLE: Deploying a CDK Stack\nDESCRIPTION: Command to deploy the defined CDK stack to an AWS account using the CDK CLI.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ncdk deploy\n```\n\n----------------------------------------\n\nTITLE: Granting Write Permissions to DynamoDB for Lambda - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to grant a Lambda function write-level permissions (Put, Update, Delete) to a DynamoDB table using the AWS CDK grantWriteData method. It requires lambda.Function and dynamodb.Table constructs, and the grantWriteData method is used to scope permissions strictly to write operations on the table. Inputs are the Lambda function and DynamoDB table, and the output is a permission assignment that allows Lambda to modify table records.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\ndeclare const table: dynamodb.Table;\n\ntable.grantWriteData(fn);\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Secret by Attributes with AWS CDK - TypeScript\nDESCRIPTION: Shows how to import a pre-existing secret (optionally KMS-encrypted) into your AWS CDK stack using Secret.fromSecretAttributes. The secret's ARN and an optional encryption key are specified. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-kms. Required parameters: secretArn (ARN of secret), encryptionKey (KMS key object). Used for referencing secrets provisioned outside the CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const encryptionKey: kms.Key;\nconst secret = secretsmanager.Secret.fromSecretAttributes(this, 'ImportedSecret', {\n  secretArn: 'arn:aws:secretsmanager:<region>:<account-id-number>:secret:<secret-name>-<random-6-characters>',\n  // If the secret is encrypted using a KMS-hosted CMK, either import or reference that key:\n  encryptionKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Table Keys with TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to define the schema for a DynamoDB table using the TableV2 construct, including both partition and sort keys.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic SQS Queue in TypeScript\nDESCRIPTION: Demonstrates the fundamental creation of a standard SQS queue using the AWS CDK. This instantiates a new `sqs.Queue` within the current CDK scope (`this`) with default configurations, including SSE-SQS encryption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew sqs.Queue(this, 'Queue');\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Stages with Custom Permissions Boundaries (TypeScript)\nDESCRIPTION: Demonstrates how to create multiple deployment stages in a CDK application, each with a unique permissions boundary using the `permissionsBoundary` property. This supports scenarios where different stages/environments require distinct boundaries (e.g., dev, beta, prod). Requires the AWS CDK Stage and PermissionsBoundary constructs. The main input is the app instance and outputs are multiple Stage constructs with boundaries applied.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const app: App;\\n\\nnew Stage(app, 'DevStage');\\n\\nnew Stage(app, 'BetaStage', {\\n  permissionsBoundary: PermissionsBoundary.fromName('beta-permissions-boundary'),\\n});\\n\\nnew Stage(app, 'GammaStage', {\\n  permissionsBoundary: PermissionsBoundary.fromName('prod-permissions-boundary'),\\n});\\n\\nnew Stage(app, 'ProdStage', {\\n  permissionsBoundary: PermissionsBoundary.fromName('prod-permissions-boundary'),\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster in TypeScript\nDESCRIPTION: Demonstrates the minimal example of defining an AWS EKS cluster using the new eks-v2-alpha module. It specifies the Kubernetes version as the only required property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from SSM Parameter using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to instantiate an AWS AppConfig `SourcedConfiguration` using an SSM Parameter Store parameter as the source. It requires an `appconfig.Application` instance and an `ssm.StringParameter` instance. The `location` is set via `appconfig.ConfigurationSource.fromParameter()`, and a specific `versionNumber` ('1' in this case) is also provided.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const parameter: ssm.StringParameter;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromParameter(parameter),\n  versionNumber: '1',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Schedule-Based Auto-Scaling to ApplicationLoadBalancedFargateService (TypeScript)\nDESCRIPTION: Shows how to configure schedule-based auto-scaling for ApplicationLoadBalancedFargateService by setting up scalable target and adding scaleOnSchedule policies for various time ranges. This allows dynamic scaling of ECS tasks based on time-of-day schedules (using cron expressions) for operational efficiency. Prerequisites are an ECS cluster and Application Auto Scaling module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  desiredCount: 1,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n});\n\nconst scalableTarget = loadBalancedFargateService.service.autoScaleTaskCount({\n  minCapacity: 5,\n  maxCapacity: 20,\n});\n\nscalableTarget.scaleOnSchedule('DaytimeScaleDown', {\n  schedule: appscaling.Schedule.cron({ hour: '8', minute: '0'}),\n  minCapacity: 1,\n});\n\nscalableTarget.scaleOnSchedule('EveningRushScaleUp', {\n  schedule: appscaling.Schedule.cron({ hour: '20', minute: '0'}),\n  minCapacity: 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Configured EFS File System in TypeScript\nDESCRIPTION: Instantiates a new Amazon EFS file system within a specified VPC using the AWS CDK. This example configures the file system with encryption at rest, General Purpose performance mode, Bursting throughput mode, a 14-day lifecycle policy before transitioning to Infrequent Access (IA) and Archive storage, a policy to move files back from IA after 1 access, and enables replication overwrite protection.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fileSystem = new efs.FileSystem(this, 'MyEfsFileSystem', {\n  vpc: new ec2.Vpc(this, 'VPC'),\n  lifecyclePolicy: efs.LifecyclePolicy.AFTER_14_DAYS, // files are not transitioned to infrequent access (IA) storage by default\n  performanceMode: efs.PerformanceMode.GENERAL_PURPOSE, // default\n  outOfInfrequentAccessPolicy: efs.OutOfInfrequentAccessPolicy.AFTER_1_ACCESS, // files are not transitioned back from (infrequent access) IA to primary storage by default\n  transitionToArchivePolicy: efs.LifecyclePolicy.AFTER_14_DAYS, // files are not transitioned to Archive by default\n  replicationOverwriteProtection: efs.ReplicationOverwriteProtection.ENABLED, // Set to `DISABLED` if you want to create a read-only file system for use as a replication destination\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling CORS for API Gateway v2 HTTP API using AWS CDK (TypeScript)\nDESCRIPTION: This example configures CORS behavior in an API Gateway v2 HTTP API using the corsPreflight option. It allows various HTTP methods, specifies the Authorization header, accepts requests from any origin (*), and sets the CORS maxAge using a Duration. Dependencies: aws-cdk-lib/aws-apigatewayv2, Duration from aws-cdk-lib. Inputs: CORS headers, allowed methods and origins, maxAge. Outputs: HttpApi with automated CORS support for browser-based apps.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew apigwv2.HttpApi(this, 'HttpProxyApi', {\n  corsPreflight: {\n    allowHeaders: ['Authorization'],\n    allowMethods: [\n      apigwv2.CorsHttpMethod.GET,\n      apigwv2.CorsHttpMethod.HEAD,\n      apigwv2.CorsHttpMethod.OPTIONS,\n      apigwv2.CorsHttpMethod.POST,\n    ],\n    allowOrigins: ['*'],\n    maxAge: Duration.days(10),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking API Gateway REST API with EventBridge Rule in TypeScript\nDESCRIPTION: This snippet creates an API Gateway REST API that is invoked every hour using an EventBridge rule. It demonstrates how to set up the rule, create a Lambda function, and configure the API Gateway target with various parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as api from 'aws-cdk-lib/aws-apigateway';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(Duration.minutes(1)),\n});\n\nconst fn = new lambda.Function( this, 'MyFunc', {\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  code: lambda.Code.fromInline( 'exports.handler = e => {}' ),\n} );\n\nconst restApi = new api.LambdaRestApi( this, 'MyRestAPI', { handler: fn } );\n\nconst dlq = new sqs.Queue(this, 'DeadLetterQueue');\n\nrule.addTarget(\n  new targets.ApiGateway( restApi, {\n    path: '/*/test',\n    method: 'GET',\n    stage:  'prod',\n    pathParameterValues: ['path-value'],\n    headerParameters: {\n      Header1: 'header1',\n    },\n    queryStringParameters: {\n      QueryParam1: 'query-param-1',\n    },\n    deadLetterQueue: dlq\n  } ),\n)\n```\n\n----------------------------------------\n\nTITLE: Attaching and Managing Permissions Boundaries to IAM Roles with CDK (TypeScript)\nDESCRIPTION: Shows several ways to create, import, apply, and remove permissions boundaries to IAM Roles in a CDK construct tree. Demonstrates importing an existing managed policy, creating a new managed boundary, applying boundaries at individual role or stack level, and clearing inherited boundaries. Requires `aws-cdk-lib/aws-iam` and optionally AWS Lambda. Inputs vary between policy ARNs, policy statements, and resource references. Outputs are roles with managed boundaries.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\n// This imports an existing policy.\\nconst boundary = iam.ManagedPolicy.fromManagedPolicyArn(this, 'Boundary', 'arn:aws:iam::123456789012:policy/boundary');\\n\\n// This creates a new boundary\\nconst boundary2 = new iam.ManagedPolicy(this, 'Boundary2', {\\n  statements: [\\n    new iam.PolicyStatement({\\n      effect: iam.Effect.DENY,\\n      actions: ['iam:*'],\\n      resources: ['*'],\\n    }),\\n  ],\\n});\\n\\n// Directly apply the boundary to a Role you create\\ndeclare const role: iam.Role;\\niam.PermissionsBoundary.of(role).apply(boundary);\\n\\n// Apply the boundary to an Role that was implicitly created for you\\ndeclare const fn: lambda.Function;\\niam.PermissionsBoundary.of(fn).apply(boundary);\\n\\n// Apply the boundary to all Roles in a stack\\niam.PermissionsBoundary.of(this).apply(boundary);\\n\\n// Remove a Permissions Boundary that is inherited, for example from the Stack level\\ndeclare const customResource: CustomResource;\\niam.PermissionsBoundary.of(customResource).clear();\n```\n\n----------------------------------------\n\nTITLE: Creating a CodeCommit Source Action in CodePipeline\nDESCRIPTION: This example demonstrates how to create a CodePipeline using a CodeCommit repository as the source. It shows the setup of the repository, pipeline, and source action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst repo = new codecommit.Repository(this, 'Repo', {\n  repositoryName: 'MyRepo',\n});\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline', {\n  pipelineName: 'MyPipeline',\n});\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository: repo,\n  output: sourceOutput,\n});\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Lambda Authorizer for WebSocket API with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Lambda function as an authorizer for a WebSocket API's $connect route using AWS CDK. It creates a WebSocketLambdaAuthorizer with a Lambda handler, launches the WebSocket API, and attaches both the authorizer and a Lambda integration to manage incoming WebSocket connections. Required dependencies include aws-cdk-lib/aws-apigatewayv2-authorizers, aws-cdk-lib/aws-apigatewayv2-integrations, and Lambda handler functions for both authorization and business logic. Expected input involves two Lambda functions; output is a WebSocket API where access is enforced at connection time via the custom authorizer.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketLambdaAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\n// This function handles your auth logic\ndeclare const authHandler: lambda.Function;\n\n// This function handles your WebSocket requests\ndeclare const handler: lambda.Function;\n\nconst authorizer = new WebSocketLambdaAuthorizer('Authorizer', authHandler);\n\nconst integration = new WebSocketLambdaIntegration(\n  'Integration',\n  handler,\n);\n\nnew apigwv2.WebSocketApi(this, 'WebSocketApi', {\n  connectRouteOptions: {\n    integration,\n    authorizer,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB Stream as Lambda Event Source in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a DynamoDB Stream as an event source to a Lambda function using the AWS CDK. It includes configuration for starting position, batch size, error handling, and a dead-letter queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport { DynamoEventSource, SqsDlq } from 'aws-cdk-lib/aws-lambda-event-sources';\n\ndeclare const table: dynamodb.Table;\n\nconst deadLetterQueue = new sqs.Queue(this, 'deadLetterQueue');\n\ndeclare const fn: lambda.Function;\nfn.addEventSource(new DynamoEventSource(table, {\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n  batchSize: 5,\n  bisectBatchOnError: true,\n  onFailure: new SqsDlq(deadLetterQueue),\n  retryAttempts: 10,\n}));\n```\n\n----------------------------------------\n\nTITLE: Automatic Entry File Lookup for NodejsFunction\nDESCRIPTION: Demonstrates how NodejsFunction automatically looks up the entry file based on the construct's ID and the defining file name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// automatic entry look up\nconst apiHandler = new nodejs.NodejsFunction(this, 'api');\nconst authHandler = new nodejs.NodejsFunction(this, 'auth');\n```\n\n----------------------------------------\n\nTITLE: Configuring Lambda Deployment Rollback with CloudWatch Alarms in TypeScript\nDESCRIPTION: Demonstrates how to configure automatic rollbacks for AWS Lambda deployments managed by CodeDeploy using AWS CDK. It creates a CloudWatch alarm that monitors the error metric of a Lambda alias and associates this alarm with a LambdaDeploymentGroup. If the alarm enters a failed state (errors exceed the threshold), CodeDeploy will initiate a rollback. The example shows adding alarms both during deployment group creation and to an existing group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const alias: lambda.Alias;\nconst alarm = new cloudwatch.Alarm(this, 'Errors', {\n  comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,\n  threshold: 1,\n  evaluationPeriods: 1,\n  metric: alias.metricErrors(),\n});\nconst deploymentGroup = new codedeploy.LambdaDeploymentGroup(this, 'BlueGreenDeployment', {\n  alias,\n  deploymentConfig: codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE,\n  alarms: [\n    // pass some alarms when constructing the deployment group\n    alarm,\n  ],\n});\n\n// or add alarms to an existing group\ndeclare const blueGreenAlias: lambda.Alias;\ndeploymentGroup.addAlarm(new cloudwatch.Alarm(this, 'BlueGreenErrors', {\n  comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,\n  threshold: 1,\n  evaluationPeriods: 1,\n  metric: blueGreenAlias.metricErrors(),\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating Kinesis Stream with Shard Count and Retention - AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates how to configure a new Kinesis stream with a specific number of shards and a custom retention period using AWS CDK. It requires the Duration module for setting retention. Inputs are shardCount and retentionPeriod properties; the output is a Stream resource with the specified configuration. Dependencies include aws-cdk-lib, constructs, and kinesis modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kinesis.Stream(this, 'MyFirstStream', {\n  streamName: 'my-awesome-stream',\n  shardCount: 3,\n  retentionPeriod: Duration.hours(48),\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Lambda Authorizer to HTTP API with AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to use a Lambda function as an authorizer for HTTP APIs in AWS CDK. The snippet sets up an HttpLambdaAuthorizer referencing a Lambda handler, specifies the response type (SIMPLE or IAM), and applies the authorizer to an API route. Dependencies involve aws-cdk-lib/aws-apigatewayv2-authorizers, aws-cdk-lib/aws-apigatewayv2-integrations, and an existing Lambda function for auth logic. The example configures routing and integration, with expected input being a Lambda handler for token validation. The response shape of the Lambda determines permissions granted.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpLambdaAuthorizer, HttpLambdaResponseType } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\n// This function handles your auth logic\ndeclare const authHandler: lambda.Function;\n\nconst authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', authHandler, {\n  responseTypes: [HttpLambdaResponseType.SIMPLE], // Define if returns simple and/or iam response\n});\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi');\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  authorizer,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Event Rule for CodeCommit and Triggering CodeBuild Project - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates creating an EventBridge rule using the AWS CDK to trigger a CodeBuild project when a commit is pushed to the master branch of a CodeCommit repository. Requires 'aws-cdk-lib/aws-codecommit', 'aws-cdk-lib/aws-codebuild', and 'aws-cdk-lib/aws-events-targets' dependencies. The snippet expects 'repo' and 'project' to be defined CodeCommit and CodeBuild resources; main inputs are branch names and the target CodeBuild project. The output is a Rule resource that integrates repository commits with automated builds.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const repo: codecommit.Repository;\ndeclare const project: codebuild.Project;\n\nconst onCommitRule = repo.onCommit('OnCommit', {\n  target: new targets.CodeBuildProject(project),\n  branches: ['master']\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CodeBuild Project with CodeCommit Source in TypeScript\nDESCRIPTION: Demonstrates how to create a CodeBuild project using an AWS CodeCommit repository as the source. It creates a new CodeCommit repository and uses it as the source for the CodeBuild project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\n\nconst repository = new codecommit.Repository(this, 'MyRepo', { repositoryName: 'foo' });\nnew codebuild.Project(this, 'MyFirstCodeCommitProject', {\n  source: codebuild.Source.codeCommit({ repository }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Default JWT Authorization with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates setting up a default JWT authorizer for all routes in an HTTP API using AWS CDK. It initializes a JWT authorizer with a specified issuer and audience, and attaches it as the default authorizer to the HttpApi construct, enforcing a specific authorization scope for every route. Dependencies include aws-cdk-lib/aws-apigatewayv2-authorizers and aws-cdk-lib/aws-apigatewayv2. Expected input is a valid issuer URL and audience; routes inherit the defined authorization automatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpJwtAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\n\nconst issuer = 'https://test.us.auth0.com';\nconst authorizer = new HttpJwtAuthorizer('DefaultAuthorizer', issuer, {\n  jwtAudience: ['3131231'],\n});\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi', {\n  defaultAuthorizer: authorizer,\n  defaultAuthorizationScopes: ['manage:books'],\n});\n```\n\n----------------------------------------\n\nTITLE: Allowing Network Access to a Hosted Rotation Lambda - AWS CDK TypeScript\nDESCRIPTION: Enables network permissions for the hosted rotation Lambda in a VPC context. Demonstrates integration of hosted rotation into a VPC and necessary security group permissions for the rotation Lambda to communicate with the DB. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-ec2. Expects VPC, DB connections, and Secret resources. Involves use of Connections.allowDefaultPortFrom for firewall configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myVpc: ec2.IVpc;\ndeclare const dbConnections: ec2.Connections;\ndeclare const secret: secretsmanager.Secret;\n\nconst myHostedRotation = secretsmanager.HostedRotation.mysqlSingleUser({ vpc: myVpc });\nsecret.addRotationSchedule('RotationSchedule', { hostedRotation: myHostedRotation });\ndbConnections.allowDefaultPortFrom(myHostedRotation);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic AppSync Channel Namespaces in TypeScript with AWS CDK\nDESCRIPTION: This snippet demonstrates two ways to create a basic AWS AppSync Channel Namespace using the AWS CDK. The first method uses the `ChannelNamespace` constructor, associating it with an existing `EventApi`. The second method uses the `addChannelNamespace` helper method available on the `EventApi` instance. Both methods require an `EventApi` instance as a prerequisite.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.EventApi;\n\n// create a channel namespace\nnew appsync.ChannelNamespace(this, 'Namespace', {\n  api,\n});\n\n// You can also create a namespace through the addChannelNamespace method\napi.addChannelNamespace('AnotherNameSpace', {});\n```\n\n----------------------------------------\n\nTITLE: Creating API Gateway V2 Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to an API Gateway V2 domain name using regional domain properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as apigwv2 from 'aws-cdk-lib/aws-apigatewayv2';\n\ndeclare const zone: route53.HostedZone;\ndeclare const domainName: apigwv2.DomainName;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.ApiGatewayv2DomainProperties(domainName.regionalDomainName, domainName.regionalHostedZoneId)),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFront Distribution with S3 Origin using TypeScript\nDESCRIPTION: Demonstrates initializing a CloudFront `Distribution` with an S3 bucket as the origin, configured using `S3BucketOrigin.withOriginAccessControl`. This method automatically creates an `S3OriginAccessControl` construct for secure access to the S3 bucket, replacing the older Origin Access Identity (OAI). Requires an existing S3 bucket instance (`myBucket`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// Creates a distribution from an S3 bucket with origin access control\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket) // Automatically creates a S3OriginAccessControl construct\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Registering and Using a CustomResourceProvider (AWS CDK, TypeScript)\nDESCRIPTION: This snippet demonstrates registering a custom resource provider using CustomResourceProvider.getOrCreate with a Lambda function handler directory and specifying the Node.js runtime. It then instantiates a new CustomResource using the generated service token. The directory must contain an index.js exporting an async handler function, and cannot use imports outside its directory. The created handler runs within Lambda and is limited to a 15-minute execution window; it also does not support asynchronous waiting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst serviceToken = CustomResourceProvider.getOrCreate(this, 'Custom::MyCustomResourceType', {\n  codeDirectory: `${__dirname}/my-handler`,\n  runtime: CustomResourceProviderRuntime.NODEJS_18_X,\n  description: \"Lambda function created by the custom resource provider\",\n});\n\nnew CustomResource(this, 'MyResource', {\n  resourceType: 'Custom::MyCustomResourceType',\n  serviceToken: serviceToken\n});\n```\n\n----------------------------------------\n\nTITLE: Emitting Dynamic Variables from LambdaInvokeAction and Consuming in CodeBuild (TypeScript)\nDESCRIPTION: Explains how to emit dynamic variables from a LambdaInvokeAction using a Lambda function that calls PutJobSuccessResult with the outputVariables map, and how to consume these emitted variables in a subsequent CodeBuildAction in an AWS CDK CodePipeline (TypeScript). This enables dynamic transfer of computed values across pipeline actions. Requires aws-cdk-lib, codepipeline, codebuild, lambda; input and output artifacts are defined and variablesNamespace is optionally set.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst lambdaInvokeAction = new codepipeline_actions.LambdaInvokeAction({\n  actionName: 'Lambda',\n  lambda: new lambda.Function(this, 'Func', {\n    runtime: lambda.Runtime.NODEJS_LATEST,\n    handler: 'index.handler',\n    code: lambda.Code.fromInline(`\n        const { CodePipeline } = require('@aws-sdk/client-codepipeline');\n\n        exports.handler = async function(event, context) {\n            const codepipeline = new AWS.CodePipeline();\n            await codepipeline.putJobSuccessResult({\n                jobId: event['CodePipeline.job'].id,\n                outputVariables: {\n                    MY_VAR: \"some value\",\n                },\n            });\n        }\n    `),\n  }),\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\ndeclare const project: codebuild.PipelineProject;\nconst sourceOutput = new codepipeline.Artifact();\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    MyVar: {\n      value: lambdaInvokeAction.variable('MY_VAR'),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining AppSync API with DynamoDB Backend using AWS CDK (TypeScript/GraphQL)\nDESCRIPTION: This example demonstrates defining a GraphQL schema and implementing an AWS AppSync API using AWS CDK that interacts with a DynamoDB table. It covers creating the API (`GraphqlApi`) from a schema file, configuring IAM authorization, adding a DynamoDB data source (`addDynamoDbDataSource`), and creating resolvers (`createResolver`) for query (`getDemos`, `getDemosConsistent`) and mutation (`addDemo`) operations using built-in DynamoDB mapping templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype demo {\n  id: String!\n  version: String!\n}\ntype Query {\n  getDemos: [ demo! ]\n  getDemosConsistent: [demo!]\n}\ninput DemoInput {\n  version: String!\n}\ntype Mutation {\n  addDemo(input: DemoInput!): demo\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'Api', {\n  name: 'demo',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'schema.graphql')),\n  authorizationConfig: {\n    defaultAuthorization: {\n      authorizationType: appsync.AuthorizationType.IAM,\n    },\n  },\n  xrayEnabled: true,\n});\n\nconst demoTable = new dynamodb.Table(this, 'DemoTable', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n});\n\nconst demoDS = api.addDynamoDbDataSource('demoDataSource', demoTable);\n\n// Resolver for the Query \"getDemos\" that scans the DynamoDb table and returns the entire list.\n// Resolver Mapping Template Reference:\n// https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html\ndemoDS.createResolver('QueryGetDemosResolver', {\n  typeName: 'Query',\n  fieldName: 'getDemos',\n  requestMappingTemplate: appsync.MappingTemplate.dynamoDbScanTable(),\n  responseMappingTemplate: appsync.MappingTemplate.dynamoDbResultList(),\n});\n\n// Resolver for the Mutation \"addDemo\" that puts the item into the DynamoDb table.\ndemoDS.createResolver('MutationAddDemoResolver', {\n  typeName: 'Mutation',\n  fieldName: 'addDemo',\n  requestMappingTemplate: appsync.MappingTemplate.dynamoDbPutItem(\n    appsync.PrimaryKey.partition('id').auto(),\n    appsync.Values.projecting('input'),\n  ),\n  responseMappingTemplate: appsync.MappingTemplate.dynamoDbResultItem(),\n});\n\n//To enable DynamoDB read consistency with the `MappingTemplate`:\ndemoDS.createResolver('QueryGetDemosConsistentResolver', {\n  typeName: 'Query',\n  fieldName: 'getDemosConsistent',\n  requestMappingTemplate: appsync.MappingTemplate.dynamoDbScanTable(true),\n  responseMappingTemplate: appsync.MappingTemplate.dynamoDbResultList(),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Action with Multiple Inputs/Outputs in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a CodeBuildAction in CodePipeline to consume multiple input artifacts and produce multiple output artifacts. It uses the `extraInputs` property to specify additional input artifacts (beyond the primary `input`) and the `outputs` property to define multiple named output artifacts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const repository1: codecommit.Repository;\nconst sourceOutput1 = new codepipeline.Artifact();\nconst sourceAction1 = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'Source1',\n  repository: repository1,\n  output: sourceOutput1,\n});\ndeclare const repository2: codecommit.Repository;\nconst sourceOutput2 = new codepipeline.Artifact('source2');\nconst sourceAction2 = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'Source2',\n  repository: repository2,\n  output: sourceOutput2,\n});\n\ndeclare const project: codebuild.PipelineProject;\nconst buildAction = new codepipeline_actions.CodeBuildAction({\n  actionName: 'Build',\n  project,\n  input: sourceOutput1,\n  extraInputs: [\n    sourceOutput2, // this is where 'source2' comes from\n  ],\n  outputs: [\n    new codepipeline.Artifact('artifact1'), // for better buildspec readability - see below\n    new codepipeline.Artifact('artifact2'),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Write Permissions from CodeBuild Project to Report Group (TypeScript)\nDESCRIPTION: This snippet shows how to explicitly grant permissions for an AWS CodeBuild project's role to write reports to a specified `ReportGroup`. The `reportGroup.grantWrite(project)` method attaches the necessary IAM policy actions to the project's execution role, adjusted based on the `ReportGroup`'s type (test or code coverage).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const project: codebuild.Project;\ndeclare const reportGroup: codebuild.ReportGroup;\n\nreportGroup.grantWrite(project);\n```\n\n----------------------------------------\n\nTITLE: Creating an App Client for an Imported User Pool in TypeScript\nDESCRIPTION: This snippet shows how to import an existing Cognito User Pool using its ID and then create a new App Client associated with that imported pool using the `UserPoolClient` constructor in AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst importedPool = cognito.UserPool.fromUserPoolId(this, 'imported-pool', 'us-east-1_oiuR12Abd');\nnew cognito.UserPoolClient(this, 'customer-app-client', {\n  userPool: importedPool,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Auto Scaling Group with a Custom Security Group in TypeScript\nDESCRIPTION: This snippet shows how to create an Auto Scaling Group (ASG) and associate it with a pre-existing custom EC2 Security Group, instead of allowing the ASG construct to create a default one. This provides more control over network access rules. The `allowAllOutbound` property defaults to true on the ASG's created security group, but using a custom one allows explicit configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst mySecurityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', { vpc });\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n  securityGroup: mySecurityGroup,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Verified Email Identity for Hosted Zone - AWS CDK - TypeScript\nDESCRIPTION: This example establishes an SES verified email identity using a public hosted zone in Route 53, with an optional MAIL FROM domain. CNAME records for DKIM and MX/TXT for MAIL FROM are created automatically by CDK. Required input includes the IPublicHostedZone and the mailFromDomain string. Used to verify domain ownership for sending/receiving email via SES.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myHostedZone: route53.IPublicHostedZone;\n\nconst identity = new ses.EmailIdentity(this, 'Identity', {\n  identity: ses.Identity.publicHostedZone(myHostedZone),\n  mailFromDomain: 'mail.cdk.dev',\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Docker Bundling for NodejsFunction in TypeScript\nDESCRIPTION: This snippet shows various ways to customize Docker bundling for a NodejsFunction, including setting environment variables, passing build arguments, and using a custom Docker image.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    environment: {\n      NODE_ENV: 'production',\n    },\n  },\n});\n\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    buildArgs: {\n      HTTPS_PROXY: 'https://127.0.0.1:3001',\n    },\n  }\n});\n\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    dockerImage: DockerImage.fromBuild('/path/to/Dockerfile'),\n  },\n});\n\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n      network: 'host',\n      securityOpt: 'no-new-privileges',\n      user: 'user:group',\n      volumesFrom: ['777f7dc92da7'],\n      volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK CLI with npm\nDESCRIPTION: Command to install or update the AWS CDK CLI globally using npm. Requires Node.js version 14.15.0 or later.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i -g aws-cdk\n```\n\n----------------------------------------\n\nTITLE: Configuring Sign-In Aliases for Cognito User Pool in TypeScript\nDESCRIPTION: This snippet demonstrates how to instantiate an AWS Cognito User Pool using AWS CDK, configuring it to allow users to sign in using either their chosen username or their email address. This is achieved by setting the `username` and `email` keys to `true` within the `signInAliases` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  // ...\n  signInAliases: {\n    username: true,\n    email: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Replicating Secrets to Multiple Regions with AWS CDK\nDESCRIPTION: This example shows how to create a secret that's replicated to multiple AWS regions. It demonstrates specifying regions directly in the constructor with optional encryption keys for the replicated secrets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myKey: kms.Key;\nnew secretsmanager.Secret(this, 'Secret', {\n  replicaRegions: [\n    {\n      region: 'eu-west-1',\n    },\n    {\n      region: 'eu-central-1',\n      encryptionKey: myKey,\n    }\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Mounting an EFS File System on EC2 Launch using User Data (TypeScript/Shell)\nDESCRIPTION: This snippet shows how to use EC2 User Data within an AWS CDK application to automatically mount an EFS file system during instance launch. It first allows the instance to connect to the EFS, then adds shell commands to the instance's User Data to update packages, install necessary utilities (`amazon-efs-utils`, `nfs-utils`), retrieve the file system ID, create a mount point, add an entry to `/etc/fstab` for persistent mounting using either EFS mount helper or standard NFS, and finally mounts all file systems defined in fstab. It requires existing `fileSystem` and `instance` CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=with-filesystem-instance\nfileSystem.connections.allowDefaultPortFrom(instance);\n\ninstance.userData.addCommands(\"yum check-update -y\",    // Ubuntu: apt-get -y update\n  \"yum upgrade -y\",                                 // Ubuntu: apt-get -y upgrade\n  \"yum install -y amazon-efs-utils\",                // Ubuntu: apt-get -y install amazon-efs-utils\n  \"yum install -y nfs-utils\",                       // Ubuntu: apt-get -y install nfs-common\n  \"file_system_id_1=\" + fileSystem.fileSystemId,\n  \"efs_mount_point_1=/mnt/efs/fs1\",\n  \"mkdir -p \\\"${efs_mount_point_1}\\\"\",\n  \"test -f \\\"/sbin/mount.efs\\\" && echo \\\"${file_system_id_1}:/ ${efs_mount_point_1} efs defaults,_netdev\\\" >> /etc/fstab || \" +\n  \"echo \\\"${file_system_id_1}.efs.\" + Stack.of(this).region + \".amazonaws.com:/ ${efs_mount_point_1} nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport,_netdev 0 0\\\" >> /etc/fstab\",\n  \"mount -a -t efs,nfs4 defaults\");\n```\n```\n\n----------------------------------------\n\nTITLE: Authoring a Custom Resource Lambda Handler (Node.js, JavaScript)\nDESCRIPTION: This code defines the required Lambda handler for a low-level AWS CDK custom resource. It exports an async handler function in CommonJS format, receives a CloudFormation event with properties such as RequestType and ResourceProperties, and must return an object with output fields like PhysicalResourceId, Data, Reason, and NoEcho. The handler must be self-contained in its directory and cannot import external dependencies. Error handling can fail the custom resource creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nexports.handler = async function(event) {\n  const id = event.PhysicalResourceId; // only for \"Update\" and \"Delete\"\n  const props = event.ResourceProperties;\n  const oldProps = event.OldResourceProperties; // only for \"Update\"s\n\n  switch (event.RequestType) {\n    case \"Create\":\n      // ...\n\n    case \"Update\":\n      // ...\n\n      // if an error is thrown, a FAILED response will be submitted to CFN\n      throw new Error('Failed!');\n\n    case \"Delete\":\n      // ...\n  }\n\n  return {\n    // (optional) the value resolved from `resource.ref`\n    // defaults to \"event.PhysicalResourceId\" or \"event.RequestId\"\n    PhysicalResourceId: \"REF\",\n\n    // (optional) calling `resource.getAtt(\"Att1\")` on the custom resource in the CDK app\n    // will return the value \"BAR\".\n    Data: {\n      Att1: \"BAR\",\n      Att2: \"BAZ\"\n    },\n\n    // (optional) user-visible message\n    Reason: \"User-visible message\",\n\n    // (optional) hides values from the console\n    NoEcho: true\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Container Health Checks for Fargate Service\nDESCRIPTION: Demonstrates configuration of container-level health checks including command, interval, retries, and timeouts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const securityGroup: ec2.SecurityGroup;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  vpc,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  healthCheck: {\n    command: [ \"CMD-SHELL\", \"curl -f http://localhost/ || exit 1\" ],\n    // the properties below are optional\n    interval: Duration.minutes(30),\n    retries: 123,\n    startPeriod: Duration.minutes(30),\n    timeout: Duration.minutes(30),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Global DynamoDB Table with Replicas\nDESCRIPTION: Example of creating a global DynamoDB table with replicas in multiple regions using TableV2.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for EventBridge Integration\nDESCRIPTION: GraphQL schema definition for integrating AppSync with EventBridge, including query and mutation types for event handling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nschema {\n    query: Query\n    mutation: Mutation\n}\n\ntype Query {\n    event(id:ID!): Event\n}\n\ntype Mutation {\n    emitEvent(id: ID!, name: String): PutEventsResult!\n}\n\ntype Event {\n    id: ID!\n    name: String!\n}\n\ntype Entry {\n    ErrorCode: String\n    ErrorMessage: String\n    EventId: String\n}\n\ntype PutEventsResult {\n    Entries: [Entry!]\n    FailedEntry: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Database Secret JSON Format for Rotation - JSON\nDESCRIPTION: Defines the required JSON schema for secrets compatible with Secrets Manager rotation applications. Fields include engine, host, username, password, with optional dbname, port, and masterarn (the last required for multi-user rotation). Used as input for rotation automation and validation. Limitations: must supply all required keys for successful rotation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"engine\": \"<required: database engine>\",\n  \"host\": \"<required: instance host name>\",\n  \"username\": \"<required: username>\",\n  \"password\": \"<required: password>\",\n  \"dbname\": \"<optional: database name>\",\n  \"port\": \"<optional: if not specified, default port will be used>\",\n  \"masterarn\": \"<required for multi user rotation: the arn of the master secret which will be used to create users/change passwords>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cognito-Authenticated ELBv2 Listener with AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates end-to-end setup of an AWS Application Load Balancer (ALB) that enforces authentication using Amazon Cognito. It creates a user pool, an OAuth-configured user pool client, sets overrides using CloudFormation properties, and provisions a user pool domain. The snippet configures an ALB listener on port 443 and applies an AuthenticateCognitoAction for secure access, with dependencies on aws-cdk-lib (specifically the aws-elasticloadbalancingv2, aws-certificatemanager, and aws-cognito modules). Inputs include the VPC, certificate, and user pool configuration, while outputs include the load balancer's DNS name. Limitations: requires prior setup of environment and VPC, assumes required context imports, and specific OAuth flows and providers must be enabled as shown.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticloadbalancingv2-actions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { aws_certificatemanager as acm } from 'aws-cdk-lib';\n\ndeclare const vpc: ec2.Vpc;\ndeclare const certificate: acm.Certificate;\n\nconst lb = new elbv2.ApplicationLoadBalancer(this, 'LB', {\n  vpc,\n  internetFacing: true,\n});\n\nconst userPool = new cognito.UserPool(this, 'UserPool');\nconst userPoolClient = new cognito.UserPoolClient(this, 'Client', {\n  userPool,\n\n  // Required minimal configuration for use with an ELB\n  generateSecret: true,\n  authFlows: {\n    userPassword: true,\n  },\n  oAuth: {\n    flows: {\n      authorizationCodeGrant: true,\n    },\n    scopes: [cognito.OAuthScope.EMAIL],\n    callbackUrls: [\n      `https://${lb.loadBalancerDnsName}/oauth2/idpresponse`,\n    ],\n  },\n});\nconst cfnClient = userPoolClient.node.defaultChild as cognito.CfnUserPoolClient;\ncfnClient.addPropertyOverride('RefreshTokenValidity', 1);\ncfnClient.addPropertyOverride('SupportedIdentityProviders', ['COGNITO']);\n\nconst userPoolDomain = new cognito.UserPoolDomain(this, 'Domain', {\n  userPool,\n  cognitoDomain: {\n    domainPrefix: 'test-cdk-prefix',\n  },\n});\n\nlb.addListener('Listener', {\n  port: 443,\n  certificates: [certificate],\n  defaultAction: new actions.AuthenticateCognitoAction({\n    userPool,\n    userPoolClient,\n    userPoolDomain,\n    next: elbv2.ListenerAction.fixedResponse(200, {\n      contentType: 'text/plain',\n      messageBody: 'Authenticated',\n    }),\n  }),\n});\n\nnew CfnOutput(this, 'DNS', {\n  value: lb.loadBalancerDnsName,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Granting Application Principal PutRecords Permission on Firehose Delivery Stream with AWS CDK - TypeScript\nDESCRIPTION: This snippet illustrates how to grant a Lambda execution role permission to write to a Firehose delivery stream using the AWS CDK in TypeScript. It shows creation of an IAM role for use by a Lambda function, then grants that role 'firehose:PutRecord' and 'firehose:PutRecordBatch' permissions via the delivery stream's 'grantPutRecords' method. Dependencies: AWS CDK ('aws-cdk-lib/aws-iam', 'aws-cdk-lib/aws-kinesisfirehose'). The main input is the Lambda role; the output is an augmented role with Firehose write access. This is applicable to any principal implementing the IGrantable interface.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst lambdaRole = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n});\n\n// Give the role permissions to write data to the delivery stream\ndeclare const deliveryStream: firehose.DeliveryStream;\ndeliveryStream.grantPutRecords(lambdaRole);\n```\n\n----------------------------------------\n\nTITLE: Configuring Required Multi-Factor Authentication (MFA) for UserPool - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to enforce required MFA on an AWS Cognito UserPool, allowing both SMS and TOTP as second factors. Dependencies: AWS CDK and Cognito module. Key properties set 'mfa' to 'REQUIRED', and 'mfaSecondFactor' object specifies which MFA methods are permitted (SMS, OTP, email). Input is a configuration object, output is a UserPool with enforced MFA. 'email' is disabled here; to enable email MFA, see documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  mfa: cognito.Mfa.REQUIRED,\n  mfaSecondFactor: {\n    sms: true,\n    otp: true,\n    email: false, // email-based MFA\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing and Granting Access to an Existing Backup Vault - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates importing an existing backup vault by name and granting an IAM Role permissions (such as backup:StartBackupJob) using the AWS CDK in TypeScript. Dependencies are BackupVault and iam modules, along with prepared vault names and role principals. This facilitates management of pre-existing cloud resources in CDK stacks.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst importedVault = backup.BackupVault.fromBackupVaultName(this, 'Vault', 'myVaultName');\n\nconst role = new iam.Role(this, 'Access Role', { assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com') });\n\nimportedVault.grant(role, 'backup:StartBackupJob');\n```\n\n----------------------------------------\n\nTITLE: Implementing Fargate Queue Processing Service Example\nDESCRIPTION: Example showing how to create a Fargate-based queue processing service with VPC, cluster, and SQS queue configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-autoscaling-queue-worker.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(stack, 'Vpc', { maxAzs: 2 });\nconst cluster = new ecs.Cluster(stack, 'FargateCluster', { vpc });\nconst queue = new sqs.Queue(stack, 'ProcessingQueue', {\n  QueueName: 'FargateEventQueue'\n});\n\nnew QueueProcessingFargateService(stack, 'QueueProcessingFargateService', {\n  cluster,\n  image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  desiredTaskCount: 2,\n  maxScalingCapacity: 5,\n  queue\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Private AppSync GraphQL API in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an AWS AppSync GraphQL API with private visibility using the AWS CDK. Setting `visibility` to `appsync.Visibility.PRIVATE` restricts access to the API from within a VPC. The API definition is loaded from a local GraphQL schema file.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'MyPrivateAPI',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.schema.graphql')),\n  visibility: appsync.Visibility.PRIVATE,\n});\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Updating Instance Type Suffixes\nDESCRIPTION: Demonstrates how to update instance type suffixes from .elasticsearch to .search when migrating to OpenSearch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nnew es.Domain(this, 'Domain', {\n  capacity: {\n    masterNodeInstanceType: 'r5.large.elasticsearch',\n  },\n  version: elasticsearchVersion,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nnew opensearch.Domain(this, 'Domain', {\n  capacity: {\n    masterNodeInstanceType: 'r5.large.search',\n  },\n  version: openSearchVersion,\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking an AWS Lambda Function with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure an AWS Lambda function as a target for an EventBridge Scheduler schedule using the AWS CDK. It defines a Lambda function, an SQS dead-letter queue (DLQ), and then creates a `LambdaInvoke` target with custom input, retry policy, max event age, and the DLQ. Finally, it sets up a schedule to trigger this target hourly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst fn = new lambda.Function(this, 'MyFunc', {\n    runtime: lambda.Runtime.NODEJS_LATEST,\n    handler: 'index.handler',\n    code: lambda.Code.fromInline(`exports.handler = handler.toString()`),\n});\n\nconst dlq = new sqs.Queue(this, \"DLQ\", {\n    queueName: 'MyDLQ',\n});\n\nconst target = new targets.LambdaInvoke(fn, {\n    deadLetterQueue: dlq,\n    maxEventAge: Duration.minutes(1),\n    retryAttempts: 3,\n    input: ScheduleTargetInput.fromObject({\n        'payload': 'useful'\n    }),\n});\n\nconst schedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.hours(1)),\n    target\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating CodeCommit Source and CodeBuild Action in TypeScript Pipeline\nDESCRIPTION: This snippet demonstrates creating a complete two-stage CodePipeline pipeline using AWS CDK. The first stage uses a CodeCommit repository as the source, and the second stage uses a CodeBuild project for building. It shows how to define the `CodeCommitSourceAction` and `CodeBuildAction`, passing the artifact from source to build. Optional parameters like `executeBatchBuild` and `combineBatchBuildArtifacts` for the build action are also shown.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const project: codebuild.PipelineProject;\nconst repository = new codecommit.Repository(this, 'MyRepository', {\n  repositoryName: 'MyRepository',\n});\nconst project = new codebuild.PipelineProject(this, 'MyProject');\n\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository,\n  output: sourceOutput,\n});\nconst buildAction = new codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  outputs: [new codepipeline.Artifact()], // optional\n  executeBatchBuild: true, // optional, defaults to false\n  combineBatchBuildArtifacts: true, // optional, defaults to false\n});\n\nnew codepipeline.Pipeline(this, 'MyPipeline', {\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a New IAM User with AWS CDK (TypeScript)\nDESCRIPTION: Instantiates an IAM user as a resource within a CDK stack. This user can then be assigned policies, groups, and other IAM properties. Requires `aws-cdk-lib/aws-iam`. No additional input except resource scope and ID; outputs a new user resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = new iam.User(this, 'MyUser');\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP API Routes with Proxy and Lambda Integrations using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to set up HTTP routes for an API Gateway v2 HTTP API in the AWS CDK, mapping GET requests on '/books' to an HTTP proxy integration and all other methods to a Lambda function. Dependencies include aws-cdk-lib/aws-apigatewayv2-integrations, aws-cdk-lib/aws-apigatewayv2, and an existing Lambda function declaration. Route configuration is achieved via addRoutes with appropriate methods and integration objects. Inputs: route paths, HTTP methods, integration constructs. Outputs: routes attached to the specified HttpApi instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpUrlIntegration, HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst getBooksIntegration = new HttpUrlIntegration('GetBooksIntegration', 'https://get-books-proxy.example.com');\n\ndeclare const bookStoreDefaultFn: lambda.Function;\nconst bookStoreDefaultIntegration = new HttpLambdaIntegration('BooksIntegration', bookStoreDefaultFn);\n\nconst httpApi = new apigwv2.HttpApi(this, 'HttpApi');\n\nhttpApi.addRoutes({\n  path: '/books',\n  methods: [ apigwv2.HttpMethod.GET ],\n  integration: getBooksIntegration,\n});\nhttpApi.addRoutes({\n  path: '/books',\n  methods: [ apigwv2.HttpMethod.ANY ],\n  integration: bookStoreDefaultIntegration,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AppSync Pipeline Resolver in TypeScript\nDESCRIPTION: This TypeScript CDK code defines an AppSync Pipeline Resolver. It attaches the resolver to a specific type and field in the GraphQL schema, specifies 'before' and 'after' VTL mapping templates loaded from files, and includes an AppSync Function (`appsyncFunction`) in its execution pipeline via the `pipelineConfig` array.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.GraphqlApi;\ndeclare const appsyncFunction: appsync.AppsyncFunction;\n\nconst pipelineResolver = new appsync.Resolver(this, 'pipeline', {\n  api,\n  dataSource: api.addNoneDataSource('none'),\n  typeName: 'typeName',\n  fieldName: 'fieldName',\n  requestMappingTemplate: appsync.MappingTemplate.fromFile('beforeRequest.vtl'),\n  pipelineConfig: [appsyncFunction],\n  responseMappingTemplate: appsync.MappingTemplate.fromFile('afterResponse.vtl'),\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with an HTTP Endpoint using AWS CDK in TypeScript\nDESCRIPTION: Shows how to create a `HttpUrlIntegration` pointing to a public HTTP URL (`https://get-books-proxy.example.com`) and associate it with an HTTP API route (`/books` with GET method) using AWS CDK. Requires the target URL and the `aws-apigatewayv2` and `aws-apigatewayv2-integrations` CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst booksIntegration = new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com');\n\nconst httpApi = new apigwv2.HttpApi(this, 'HttpApi');\n\nhttpApi.addRoutes({\n  path: '/books',\n  methods: [ apigwv2.HttpMethod.GET ],\n  integration: booksIntegration,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Prune to Retain Existing Files on S3 Bucket Deployment (TypeScript)\nDESCRIPTION: This code demonstrates using the prune: false option in a BucketDeployment so that existing files in the destination bucket that are not part of the deployment are retained. This is useful when you want to preserve untouched files alongside newly deployed assets. Requires AWS CDK's s3 and s3-deployment modules, and the target destination bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\nnew s3deploy.BucketDeployment(this, 'DeployMeWithoutDeletingFilesOnDestination', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket,\n  prune: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Resources Across Different Stacks in TypeScript\nDESCRIPTION: Demonstrates how to reference a resource (an S3 bucket) created in one stack (`stack1`) from another stack (`stack2`) within the same CDK application, account, and region. The bucket instance from `stack1` is passed as a property to `stack2` during instantiation. The CDK handles the cross-stack reference using CloudFormation Exports and ImportValue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst prod = { account: '123456789012', region: 'us-east-1' };\n\nconst stack1 = new StackThatProvidesABucket(app, 'Stack1' , { env: prod });\n\n// stack2 will take a property { bucket: IBucket }\nconst stack2 = new StackThatExpectsABucket(app, 'Stack2', {\n  bucket: stack1.bucket,\n  env: prod\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Stream as Lambda Event Source in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a Kinesis Stream as an event source to a Lambda function using the AWS CDK. It includes configuration for batch size and starting position.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\nimport { KinesisEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\nconst stream = new kinesis.Stream(this, 'MyStream');\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new KinesisEventSource(stream, {\n  batchSize: 100, // default\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n}));\n```\n\n----------------------------------------\n\nTITLE: Custom Build Script for NodejsFunction in JavaScript\nDESCRIPTION: This snippet shows a custom build script (build.mjs) that uses esbuild to bundle a TypeScript file for use with NodejsFunction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport esbuild from \"esbuild\";\nimport { cache } from \"esbuild-plugin-cache\";\nimport time from \"esbuild-plugin-time\";\n\nconst __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\nconst __dirname = path.dirname(__filename); // get the name of the directory\n\nawait esbuild\n  .build({\n    entryPoints: [path.join(__dirname, 'handler', 'index.ts')],\n    outfile: path.join(__dirname, 'build-output', 'index.js'),\n    external: ['@aws-sdk/*', 'aws-sdk'],\n    format: 'cjs',\n    platform: 'node',\n    target: 'node18',\n    bundle: true,\n    minify: true,\n    plugins: [time(), cache({ directory: \".cache\" })],\n  })\n  .catch((error) => {\n    console.log(error);\n    process.exit(1)\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Flink Application in TypeScript\nDESCRIPTION: Demonstrates how to create a basic Flink application using the Application construct with code loaded from a local asset.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-kinesisanalytics-flink-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n[simple flink application](test/integ.application.lit.ts)\n```\n\n----------------------------------------\n\nTITLE: Implementing Text Pattern Filters in CloudWatch Logs\nDESCRIPTION: Demonstrates how to create text-based log filters to search for specific terms in log events. Shows examples of using allTerms and anyTermGroup patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Search for lines that contain both \"ERROR\" and \"MainThread\"\nconst pattern1 = logs.FilterPattern.allTerms('ERROR', 'MainThread');\n\n// Search for lines that either contain both \"ERROR\" and \"MainThread\", or\n// both \"WARN\" and \"Deadlock\".\nconst pattern2 = logs.FilterPattern.anyTermGroup(\n  ['ERROR', 'MainThread'],\n  ['WARN', 'Deadlock'],\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an AWS CDK Stack in TypeScript\nDESCRIPTION: Example TypeScript code showing how to define a CDK stack with an SQS queue and an SNS topic. The topic is subscribed to the queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class HelloCdkStack extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const queue = new sqs.Queue(this, 'HelloCdkQueue', {\n      visibilityTimeout: cdk.Duration.seconds(300)\n    });\n\n    const topic = new sns.Topic(this, 'HelloCdkTopic');\n\n    topic.addSubscription(new subs.SqsSubscription(queue));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Lambda from CodeBuild State Change Event (TypeScript)\nDESCRIPTION: This snippet shows how to define an Amazon CloudWatch event rule that triggers an AWS Lambda function whenever the state of an AWS CodeBuild project changes. It uses the `project.onStateChange` method to create the rule and specifies the Lambda function as the target using `aws-events-targets.LambdaFunction`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\ndeclare const fn: lambda.Function;\ndeclare const project: codebuild.Project;\n\nconst rule = project.onStateChange('BuildStateChange', {\n  target: new targets.LambdaFunction(fn)\n});\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Custom CloudWatch Metric with Custom Namespace (TypeScript)\nDESCRIPTION: Illustrates the creation of a `cloudwatch.Metric` object for a custom metric residing in a user-defined namespace ('MyNamespace') and metric name ('MyMetric'). It includes specifying dimensions to filter the metric data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst metric = new cloudwatch.Metric({\n  namespace: 'MyNamespace',\n  metricName: 'MyMetric',\n  dimensionsMap: {\n    ProcessingStep: 'Download'\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Basic DynamoDB Table with TableV2\nDESCRIPTION: Minimal example of creating a DynamoDB table using TableV2 construct with a string partition key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Labels in CloudWatch Metrics (TypeScript)\nDESCRIPTION: Illustrates how to use dynamic labels in CloudWatch metric definitions within CDK. The example configures the Lambda error metric (`fn.metricErrors`) with a label '[max: ${MAX}] Lambda failure rate'. This tells CloudWatch to display the maximum value observed within the visible time range directly in the graph legend next to the label. Requires `lambda.Function`, `cloudwatch.Stats`, and `Duration`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nconst minuteErrorRate = fn.metricErrors({\n  statistic: cloudwatch.Stats.SUM,\n  period: Duration.hours(1),\n\n  // Show the maximum hourly error count in the legend\n  label: '[max: ${MAX}] Lambda failure rate',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Origins in CloudFront Distribution\nDESCRIPTION: Demonstrates how to configure multiple origins and behaviors in a CloudFront distribution, including both S3 and custom origins with specific path patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\ndeclare const oai: cloudfront.OriginAccessIdentity;\n\nnew cloudfront.CloudFrontWebDistribution(this, 'MyCfWebDistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n        originAccessIdentity: oai,\n      },\n      behaviors: [ {isDefaultBehavior: true}],\n    },\n    {\n      customOriginSource: {\n        domainName: 'MYALIAS',\n      },\n      behaviors: [{ pathPattern: '/somewhere' }]\n    }\n  ],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\n\nconst distribution = new cloudfront.Distribution(this, 'MyCfWebDistribution', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(sourceBucket) // This class automatically creates an Origin Access Identity\n  },\n  additionalBehaviors: {\n    '/somewhere': {\n      origin: new origins.HttpOrigin('MYALIAS'),\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining Values from CloudFormation Parameters (AWS CDK, TypeScript)\nDESCRIPTION: This code illustrates how to retrieve parameter values from a CfnParameter instance, using valueAsString, valueAsNumber, or valueAsList depending on parameter type. As the values are tokens, they represent CloudFormation placeholders at synthesis and resolve at deployment. Dependencies are CfnParameter and Token from aws-cdk-lib.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst param = new CfnParameter(this, 'ParameterName', { /* config */ });\n\n// If the parameter is a String\nparam.valueAsString;\n\n// If the parameter is a Number\nparam.valueAsNumber;\n\n// If the parameter is a List\nparam.valueAsList;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Stack Singleton Pattern for SNS Topic in TypeScript\nDESCRIPTION: Provides a function `getOrCreate` demonstrating a common pattern for creating stack singletons in AWS CDK. It ensures that only one instance of an `sns.Topic` (identified by a unique ID) is created per stack by checking if a child with that ID already exists using `stack.node.tryFindChild`. This pattern is often used for custom resource provider infrastructure to avoid duplication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction getOrCreate(scope: Construct): sns.Topic {\n  const stack = Stack.of(scope);\n  const uniqueid = 'GloballyUniqueIdForSingleton'; // For example, a UUID from `uuidgen`\n  const existing = stack.node.tryFindChild(uniqueid);\n  if (existing) {\n    return existing as sns.Topic;\n  }\n  return new sns.Topic(stack, uniqueid);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Sending S3 Object Creation Events to SNS Topic using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates configuring an AWS S3 bucket using the AWS CDK to trigger a notification to an SNS topic whenever a new object is created via PUT. It requires the `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-sns`, and `aws-cdk-lib/aws-s3-notifications` modules. The `bucket.addEventNotification` method is used with `s3.EventType.OBJECT_CREATED_PUT` and an instance of `s3n.SnsDestination` pointing to the created SNS topic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-notifications/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as sns from 'aws-cdk-lib/aws-sns';\n\nconst bucket = new s3.Bucket(this, 'Bucket');\nconst topic = new sns.Topic(this, 'Topic');\n\nbucket.addEventNotification(s3.EventType.OBJECT_CREATED_PUT, new s3n.SnsDestination(topic));\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Read Access to DynamoDB Global Table Using AWS CDK - TypeScript\nDESCRIPTION: Demonstrates granting read access to a primary global DynamoDB table and its associated primary key using AWS CDK in TypeScript. Assumes the use of 'TableV2', KMS-managed encryption keys, cross-region setup with main and replica key ARNs, and a user from AWS IAM. The 'grantReadData' operation only applies permissions to the primary table and the primary encryption key, not replicas. Requires 'aws-cdk-lib', 'aws-cdk-lib/aws-kms', and a declared IAM user as dependencies. Inputs include the replication configuration, KMS keys, and the user; output is the policy attached to the user.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\ndeclare const user: iam.User;\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst tableKey = new kms.Key(stack, 'Key');\nconst replicaKeyArns = {\n  'us-east-1': 'arn:aws:kms:us-east-1:123456789012:key/g24efbna-az9b-42ro-m3bp-cq249l94fca6',\n  'us-east-2': 'arn:aws:kms:us-east-2:123456789012:key/g24efbna-az9b-42ro-m3bp-cq249l94fca6',\n};\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryptionV2.customerManagedKey(tableKey, replicaKeyArns),\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n\n// grantReadData only applies to the table in us-west-2 and the tableKey\nglobalTable.grantReadData(user);\n```\n\n----------------------------------------\n\nTITLE: Allowing CloudFront Traffic to ALB via Dynamic VPC Origin Security Group using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates retrieving the dynamically created CloudFront VPC origins service security group (`CloudFront-VPCOrigins-Service-SG`) ID using an AWS CDK Custom Resource and allowing traffic from this group to an ALB. It uses `cr.AwsCustomResource` to call the `ec2:DescribeSecurityGroups` API, retrieves the GroupId, imports it using `ec2.SecurityGroup.fromSecurityGroupId`, and then adds an ingress rule to the ALB. Requires `aws-cdk-lib/custom-resources`, `aws-cdk-lib/aws-ec2`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-elasticloadbalancingv2` modules. A dependency is added to ensure the custom resource runs after the distribution is deployed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n``` ts\nimport * as cr from 'aws-cdk-lib/custom-resources';\n\ndeclare const vpc: ec2.Vpc;\ndeclare const distribution: cloudfront.Distribution;\ndeclare const alb: elbv2.ApplicationLoadBalancer;\n\n// Call ec2:DescribeSecurityGroups API to retrieve the VPC origins security group.\nconst getSg = new cr.AwsCustomResource(this, 'GetSecurityGroup', {\n  onCreate: {\n    service: 'ec2',\n    action: 'describeSecurityGroups',\n    parameters: {\n      Filters: [\n        { Name: 'vpc-id', Values: [vpc.vpcId] },\n        { Name: 'group-name', Values: ['CloudFront-VPCOrigins-Service-SG'] },\n      ],\n    },\n    physicalResourceId: cr.PhysicalResourceId.of('CloudFront-VPCOrigins-Service-SG'),\n  },\n  policy: cr.AwsCustomResourcePolicy.fromSdkCalls({ resources: ['*'] }),\n});\n// The security group may be available after the distributon is deployed\ngetSg.node.addDependency(distribution);\nconst sgVpcOrigins = ec2.SecurityGroup.fromSecurityGroupId(\n  this,\n  'VpcOriginsSecurityGroup',\n  getSg.getResponseField('SecurityGroups.0.GroupId'),\n);\n// Allow connections from the security group\nalb.connections.allowFrom(sgVpcOrigins, ec2.Port.HTTP);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Property Variable for Region Selection in AWS CDK\nDESCRIPTION: This snippet demonstrates how to create a property variable for toggling the region in a CloudWatch dashboard. It uses a radio input type and defines values for two regions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cw from 'aws-cdk-lib/aws-cloudwatch';\n\nconst dashboard = new cw.Dashboard(this, 'Dash', {\n  defaultInterval: Duration.days(7),\n  variables: [new cw.DashboardVariable({\n    id: 'region',\n    type: cw.VariableType.PROPERTY,\n    label: 'Region',\n    inputType: cw.VariableInputType.RADIO,\n    value: 'region',\n    values: cw.Values.fromValues({ label: 'IAD', value: 'us-east-1' }, { label: 'DUB', value: 'us-west-2' }),\n    defaultValue: cw.DefaultValue.value('us-east-1'),\n    visible: true,\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Pipelines via CloudWatch Events - AWS CodePipeline - TypeScript\nDESCRIPTION: Illustrates how to use a CodePipeline as a target for a CloudWatch Events rule using constructs from '@aws-cdk/aws-events' and '@aws-cdk/aws-events-targets'. Sets up a scheduled rule to trigger the pipeline daily and automatically grants the appropriate execution permissions. The pipeline must be pre-declared; the code demonstrates event rule creation and pipeline target addition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// A pipeline being used as a target for a CloudWatch event rule.\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\nimport * as events from 'aws-cdk-lib/aws-events';\n\n// kick off the pipeline every day\nconst rule = new events.Rule(this, 'Daily', {\n  schedule: events.Schedule.rate(Duration.days(1)),\n});\n\ndeclare const pipeline: codepipeline.Pipeline;\nrule.addTarget(new targets.CodePipeline(pipeline));\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB Streams with TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a DynamoDB table with a stream and replicas using the TableV2 construct. It configures the stream view type and creates replicas in different regions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(this, 'GlobalTable', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  dynamoStream: dynamodb.StreamViewType.OLD_IMAGE,\n  // tables in us-west-2, us-east-1, and us-east-2 all have dynamo stream type of OLD_IMAGES\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Applying an IAM File System Policy at Creation in TypeScript\nDESCRIPTION: Creates an EFS file system and attaches a custom IAM resource policy during instantiation. The policy grants 'ClientWrite' and 'ClientMount' actions to the account root principal, conditioned on access being made via an EFS mount target. This policy is defined using `iam.PolicyDocument` and passed via the `fileSystemPolicy` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst myFileSystemPolicy = new iam.PolicyDocument({\n  statements: [new iam.PolicyStatement({\n    actions: [\n      'elasticfilesystem:ClientWrite',\n      'elasticfilesystem:ClientMount',\n    ],\n    principals: [new iam.AccountRootPrincipal()],\n    resources: ['*'],\n    conditions: {\n      Bool: {\n        'elasticfilesystem:AccessedViaMountTarget': 'true',\n      },\n    },\n  })],\n});\n\nconst fileSystem = new efs.FileSystem(this, 'MyEfsFileSystem', {\n  vpc: new ec2.Vpc(this, 'VPC'),\n  fileSystemPolicy: myFileSystemPolicy,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Capacity Provider Strategies for ApplicationLoadBalancedFargateService (TypeScript)\nDESCRIPTION: Demonstrates enabling Fargate Capacity Providers and specifying multiple strategies for ApplicationLoadBalancedFargateService, allowing control over how ECS schedules tasks across spot and standard Fargate. The example shows assigning different weights and base values to capacity providers. Dependencies are an ECS cluster and appropriate CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\ncluster.enableFargateCapacityProviders();\n\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n  capacityProviderStrategies: [\n    {\n      capacityProvider: 'FARGATE_SPOT',\n      weight: 2,\n      base: 0,\n    },\n    {\n      capacityProvider: 'FARGATE',\n      weight: 1,\n      base: 1,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Scheduled Scaling Actions in TypeScript\nDESCRIPTION: This snippet illustrates how to set up scheduled scaling actions using `scaleOnSchedule`. It defines two schedules using cron expressions: one to increase the minimum capacity at 8:00 AM ('PrescaleInTheMorning') and another to reset the minimum capacity back to a lower value at 8:00 PM ('AllowDownscalingAtNight') in the America/Denver timezone. This allows for proactive scaling based on expected traffic patterns while potentially allowing metric-based scaling within the adjusted min/max range.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { TimeZone } from 'aws-cdk-lib';\ndeclare const resource: SomeScalableResource;\n\nconst capacity = resource.autoScaleCapacity({\n  minCapacity: 1,\n  maxCapacity: 50,\n});\n\ncapacity.scaleOnSchedule('PrescaleInTheMorning', {\n  schedule: appscaling.Schedule.cron({ hour: '8', minute: '0' }),\n  minCapacity: 20,\n  timeZone: TimeZone.AMERICA_DENVER,\n});\n\ncapacity.scaleOnSchedule('AllowDownscalingAtNight', {\n  schedule: appscaling.Schedule.cron({ hour: '20', minute: '0' }),\n  minCapacity: 1,\n  timeZone: TimeZone.AMERICA_DENVER,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing ECR Build and Publish Action in AWS CodePipeline\nDESCRIPTION: Sets up an ECR build and publish action that automatically builds Docker images and pushes them to ECR when source changes are detected. This example shows integration with a CodeStar connection source and configures the build settings for the Docker image.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\n\ndeclare const pipeline: codepipeline.Pipeline;\ndeclare const repository: ecr.IRepository;\n\nconst sourceOutput = new codepipeline.Artifact();\n// your source repository\nconst sourceAction = new codepipeline_actions.CodeStarConnectionsSourceAction({\n  actionName: 'CodeStarConnectionsSourceAction',\n  output: sourceOutput,\n  connectionArn: 'your-connection-arn',\n  owner: 'your-owner',\n  repo: 'your-repo',\n});\n\nconst buildAction = new codepipeline_actions.EcrBuildAndPublishAction({\n  actionName: 'EcrBuildAndPublishAction',\n  repositoryName: repository.repositoryName,\n  registryType: codepipeline_actions.RegistryType.PRIVATE,\n  dockerfileDirectoryPath: './my-dir', // The path indicates ./my-dir/Dockerfile in the source repository\n  imageTags: ['my-tag-1', 'my-tag-2'],\n  input: sourceOutput,\n});\n\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\npipeline.addStage({\n  stageName: 'Build',\n  actions: [buildAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTPS for ApplicationLoadBalancedFargateService in aws-cdk (TypeScript)\nDESCRIPTION: Configures HTTPS on ApplicationLoadBalancedFargateService using Route53 hosted zone, ACM certificate, and ALB SSL policy for secure traffic. The example includes domain binding, firewall settings, certificate assignment, HTTP redirection, and container image configuration. Prerequisites are a VPC, ECS cluster, domain certificate, hosted zone, and proper CDK module imports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HostedZone } from 'aws-cdk-lib/aws-route53';\nimport { Certificate } from 'aws-cdk-lib/aws-certificatemanager';\nimport { SslPolicy } from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\nconst domainZone = HostedZone.fromLookup(this, 'Zone', { domainName: 'example.com' });\nconst certificate = Certificate.fromCertificateArn(this, 'Cert', 'arn:aws:acm:us-east-1:123456:certificate/abcdefg');\n\ndeclare const vpc: ec2.Vpc;\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  vpc,\n  cluster,\n  minHealthyPercent: 100,\n  certificate,\n  sslPolicy: SslPolicy.RECOMMENDED,\n  domainName: 'api.example.com',\n  domainZone,\n  redirectHTTP: true,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Copying Recovery Points to Another Backup Vault with Retention and Cold Storage - AWS CDK - TypeScript\nDESCRIPTION: Shows how to configure a backup plan rule to copy recovery points to a secondary backup vault, with additional copy actions specifying cold storage and deletion windows. Uses the copyActions property of BackupPlanRule, requiring a destination backup vault and optional moveToColdStorageAfter and deleteAfter durations. Dependencies are Backup and Duration constructs from the CDK, and properly initialized vault instances. Inputs are the destinationVault, timing parameters; output is a plan with extended backup copy management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\ndeclare const secondaryVault: backup.BackupVault;\nplan.addRule(new backup.BackupPlanRule({\n  copyActions: [{\n    destinationBackupVault: secondaryVault,\n    moveToColdStorageAfter: Duration.days(30),\n    deleteAfter: Duration.days(120),\n  }]\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Nested Stacks in TypeScript\nDESCRIPTION: Shows how to define and use AWS CloudFormation Nested Stacks within a CDK application. It defines a `MyNestedStack` class extending `cfn.NestedStack` which contains an S3 bucket. A parent stack class `MyParentStack` then instantiates `MyNestedStack` twice, creating two nested stacks within the parent.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nclass MyNestedStack extends cfn.NestedStack {\n  constructor(scope: Construct, id: string, props?: cfn.NestedStackProps) {\n    super(scope, id, props);\n\n    new s3.Bucket(this, 'NestedBucket');\n  }\n}\n\nclass MyParentStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    new MyNestedStack(this, 'Nested1');\n    new MyNestedStack(this, 'Nested2');\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate with DNS Validation - AWS CDK - TypeScript\nDESCRIPTION: This snippet provisions an ACM certificate for a subdomain using DNS validation through Route 53 in AWS CDK. It creates a new hosted zone and associates the certificate validation with it. Dependencies include aws-cdk-lib/aws-certificatemanager and aws-cdk-lib/aws-route53. Required parameters are the domain name, and optionally a user-defined certificate name. Inputs are the hosted zone and certificate configuration; output is a DNS-validated ACM certificate resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myHostedZone = new route53.HostedZone(this, 'HostedZone', {\n  zoneName: 'example.com',\n});\nnew acm.Certificate(this, 'Certificate', {\n  domainName: 'hello.example.com',\n  certificateName: 'Hello World Service', // Optionally provide an certificate name\n  validation: acm.CertificateValidation.fromDns(myHostedZone),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Pipeline Type V2 in AWS CDK TypeScript\nDESCRIPTION: Demonstrates how to set up a CodePipeline with V2 type by setting the pipelineType property. This configuration can be used when migrating from V1 to V2 pipeline types and doesn't cause pipeline replacement during deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2, // here\n});\n```\n\n----------------------------------------\n\nTITLE: Capturing Values in AWS CDK Template Testing\nDESCRIPTION: Shows how to use the Capture class to extract and assert values from matching entries in CDK templates, including nested pattern matching and handling multiple matches.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": [\"Flob\", \"Cat\"],\n//         \"Waldo\": [\"Qix\", \"Qux\"],\n//       }\n//     }\n//   }\n// }\n\nconst fredCapture = new Capture();\nconst waldoCapture = new Capture();\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: fredCapture,\n  Waldo: [\"Qix\", waldoCapture] as any[],\n});\n\nfredCapture.asArray(); // returns [\"Flob\", \"Cat\"]\nwaldoCapture.asString(); // returns \"Qux\"\n```\n\n----------------------------------------\n\nTITLE: Obtaining Default Error Metric from Lambda Function (TypeScript)\nDESCRIPTION: Demonstrates retrieving a default CloudWatch Metric object representing the error count for a given Lambda function using the `metricErrors()` convenience method. This method returns a Metric object pre-configured with sensible defaults (typically Sum over 300 seconds). Requires an existing `lambda.Function` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nconst errors = fn.metricErrors();\n```\n```\n\n----------------------------------------\n\nTITLE: Enforcing SSL/TLS for SQS Queue Connections in TypeScript\nDESCRIPTION: Shows how to enforce encrypted data transmission over HTTPS (TLS) for an SQS queue. Setting the `enforceSSL` property to `true` automatically adds a resource policy to the queue that denies non-encrypted connections.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew sqs.Queue(this, 'Queue', {\n  enforceSSL: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Load Balanced Fargate Service in AWS CDK\nDESCRIPTION: Creates an ECS service running on Fargate behind an Application Load Balancer. Configures CPU, memory limits, and custom health check path.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n    command: ['command'],\n    entryPoint: ['entry', 'point'],\n  },\n  containerCpu: 256,\n  containerMemoryLimitMiB: 512,\n  minHealthyPercent: 100,\n});\n\nloadBalancedFargateService.targetGroup.configureHealthCheck({\n  path: \"/custom-health-path\",\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Build Script in CDK Stack for NodejsFunction in TypeScript\nDESCRIPTION: This snippet demonstrates how to use a custom build script in a CDK stack to create a NodejsFunction with custom bundling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport class ExampleStack extends Stack {\n  public constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const pathToBuildFile = path.join(__dirname, 'build.mjs');\n\n    // assuming the `handler` property is specified as 'index.handler' (as in this example), then \n    // this 'build-output' directory must contain an index.js file with an exported `handler` function.\n    const pathToOutputFile = path.join(__dirname, 'build-output'); \n    const handler = 'index.handler';\n\n    const commandThatIsRanDuringCdkSynth = ['node', pathToBuildFile];\n    const code = lambda.Code.fromCustomCommand(\n      pathToOutputFile,\n      commandThatIsRanDuringCdkSynth,\n    );\n\n    new nodejs.NodejsFunction(this, 'NodejsFunctionBuild', {\n      code,\n      handler,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing CloudFront Traffic to ALB via Managed Prefix List using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to allow inbound traffic from CloudFront to an Application Load Balancer (ALB) by referencing the AWS-managed prefix list `com.amazonaws.global.cloudfront.origin-facing`. It looks up the prefix list using `ec2.PrefixList.fromLookup` and then adds an ingress rule to the ALB's connections object using `alb.connections.allowFrom` for HTTP traffic. Requires `aws-cdk-lib/aws-ec2` and `aws-cdk-lib/aws-elasticloadbalancingv2` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n``` ts\ndeclare const alb: elbv2.ApplicationLoadBalancer;\n\nconst cfOriginFacing = ec2.PrefixList.fromLookup(this, 'CloudFrontOriginFacing', {\n  prefixListName: 'com.amazonaws.global.cloudfront.origin-facing',\n});\nalb.connections.allowFrom(ec2.Peer.prefixList(cfOriginFacing.prefixListId), ec2.Port.HTTP);\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Different Aggregation Statistics for Custom Metrics (TypeScript)\nDESCRIPTION: Provides examples of instantiating `cloudwatch.Metric` objects with various aggregation statistics applied to the 'AWS/Route53' 'DNSQueries' metric. It demonstrates using predefined statistics like `Stats.SAMPLE_COUNT`, percentile functions like `Stats.p(99)`, and custom statistic strings like 'TS(7.5%:90%)'. Requires `route53.HostedZone`, `cloudwatch.Metric`, `cloudwatch.Stats`, and `Duration`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const hostedZone: route53.HostedZone;\n\nnew cloudwatch.Metric({\n  namespace: 'AWS/Route53',\n  metricName: 'DNSQueries',\n  dimensionsMap: {\n    HostedZoneId: hostedZone.hostedZoneId\n  },\n  statistic: cloudwatch.Stats.SAMPLE_COUNT,\n  period: Duration.minutes(5)\n});\n\nnew cloudwatch.Metric({\n  namespace: 'AWS/Route53',\n  metricName: 'DNSQueries',\n  dimensionsMap: {\n    HostedZoneId: hostedZone.hostedZoneId\n  },\n  statistic: cloudwatch.Stats.p(99),\n  period: Duration.minutes(5)\n});\n\nnew cloudwatch.Metric({\n  namespace: 'AWS/Route53',\n  metricName: 'DNSQueries',\n  dimensionsMap: {\n    HostedZoneId: hostedZone.hostedZoneId\n  },\n  statistic: 'TS(7.5%:90%)',\n  period: Duration.minutes(5)\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using Custom Event for CodeCommit Source Action\nDESCRIPTION: This example demonstrates how to use a custom event for the CodeCommit source action by specifying an event pattern and a rule target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst eventPattern = {\n  'detail-type': ['CodeCommit Repository State Change'],\n  'resources': ['foo'],\n  'source': ['aws.codecommit'],\n  'detail': {\n    referenceType: ['branch'],\n    event: ['referenceCreated', 'referenceUpdated'],\n    referenceName: ['master'],\n  },\n};\ndeclare const repo: codecommit.Repository;\ndeclare const lambdaFunction: lambda.Function;\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository: repo,\n  output: sourceOutput,\n  customEventRule: {\n    eventPattern,\n    target: new targets.LambdaFunction(lambdaFunction),\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Git Tags using AWS CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure a CodePipeline in AWS CDK (TypeScript) to trigger on Git tag push events using the pushFilter property. Filters can include and exclude specific tag patterns using 'tagsIncludes' and 'tagsExcludes' arrays, where excludes take priority. It requires the codepipeline and codepipeline_actions modules, a defined sourceAction and buildAction, and the usage of pipelineType V2. The pipeline will only execute when a tag matching 'tagsIncludes' (and not 'tagsExcludes') is pushed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pushFilter: [{\n        tagsExcludes: ['exclude1', 'exclude2'],\n        tagsIncludes: ['include*'],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Scheduled EC2 Task with aws-cdk ECS Patterns (TypeScript)\nDESCRIPTION: Creates a ScheduledEc2Task that runs containerized workloads periodically on ECS EC2 instances using a CloudWatch Events schedule. The example configures task image, memory, task environment, schedule expression, and custom rule name. Necessary dependencies include an ECS cluster and aws-cdk modules for ECS and Application AutoScaling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// Instantiate an Amazon EC2 Task to run at a scheduled interval\ndeclare const cluster: ecs.Cluster;\nconst ecsScheduledTask = new ecsPatterns.ScheduledEc2Task(this, 'ScheduledTask', {\n  cluster,\n  scheduledEc2TaskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    memoryLimitMiB: 256,\n    environment: { name: 'TRIGGER', value: 'CloudWatch Events' },\n  },\n  schedule: appscaling.Schedule.expression('rate(1 minute)'),\n  enabled: true,\n  ruleName: 'sample-scheduled-task-rule',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Chatbot Slack Channel and Adding Policies with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to set up an AWS Chatbot Slack channel configuration using the AWS CDK in TypeScript. It shows how to create a Slack channel integration, attach an IAM policy for specific permissions (e.g., s3:GetObject), and link an SNS topic for notifications. Dependencies include the aws-cdk-lib/aws-chatbot, aws-cdk-lib/aws-sns, and aws-cdk-lib/aws-iam modules. Required parameters include Slack workspace ID, channel ID, and channel configuration name. The input is CDK construct parameters; the expected behavior is creation of a Slack channel integration with proper IAM and notification topic associations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-chatbot/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\\nimport * as sns from 'aws-cdk-lib/aws-sns';\\nimport * as iam from 'aws-cdk-lib/aws-iam';\\n\\nconst slackChannel = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\\n});\\n\\nslackChannel.addToRolePolicy(new iam.PolicyStatement({\\n  effect: iam.Effect.ALLOW,\\n  actions: [\\n    's3:GetObject',\\n  ],\\n  resources: ['arn:aws:s3:::abc/xyz/123.txt'],\\n}));\\n\\nslackChannel.addNotificationTopic(new sns.Topic(this, 'MyTopic'));\n```\n\n----------------------------------------\n\nTITLE: Integrating AWS Secrets Manager with AWS Batch Job Definitions\nDESCRIPTION: Demonstrates how to inject secrets from AWS Secrets Manager into a container as environment variables. This approach allows secure access to sensitive information without hardcoding values in the job definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mySecret: secretsmanager.ISecret;\n\nconst jobDefn = new batch.EcsJobDefinition(this, 'JobDefn', {\n  container: new batch.EcsEc2ContainerDefinition(this, 'containerDefn', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n    secrets: {\n      MY_SECRET_ENV_VAR: batch.Secret.fromSecretsManager(mySecret),\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Message Archiving with Archive Policy on a FIFO SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to enable message archiving for a FIFO SNS topic, specifying the period in days for message retention. The property messageRetentionPeriodInDays is available only for FIFO topics. Requires sns construct and enables regulatory or operational retention of published messages for audit or replay scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'MyTopic', {\n  fifo: true,\n  messageRetentionPeriodInDays: 7,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating CloudWatch Metric for Replica DynamoDB Table with Stack Composition - AWS CDK - TypeScript\nDESCRIPTION: Presents a custom stack composition for cross-stack metric creation on a DynamoDB replica table using AWS CDK in TypeScript. FooStack creates the global table; BarStack receives the replica table (via BarStackProps interface) and sets up a CloudWatch alarm on the replica's ConsumedReadCapacityUnits metric. This structure illustrates best practices for stack reusability, parameter passing, and monitoring of regional resources. Input assumptions are two stacks and a replica table reference; output is the alarm in the replica's region.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\nclass FooStack extends cdk.Stack {\n  public readonly globalTable: dynamodb.TableV2;\n\n  public constructor(scope: Construct, id: string, props: cdk.StackProps) {\n    super(scope, id, props);\n\n    this.globalTable = new dynamodb.TableV2(this, 'GlobalTable', {\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      replicas: [\n        { region: 'us-east-1' },\n        { region: 'us-east-2' },\n      ],\n    });\n  }\n}\n\ninterface BarStackProps extends cdk.StackProps {\n  readonly replicaTable: dynamodb.ITableV2;\n}\n\nclass BarStack extends cdk.Stack {\n  public constructor(scope: Construct, id: string, props: BarStackProps) {\n    super(scope, id, props);\n\n    // metric is only for the table in us-east-1\n    const metric = props.replicaTable.metricConsumedReadCapacityUnits();\n\n    new cloudwatch.Alarm(this, 'Alarm', {\n      metric: metric,\n      evaluationPeriods: 1,\n      threshold: 1,\n    });\n  }\n}\n\nconst app = new cdk.App();\nconst fooStack = new FooStack(app, 'FooStack', { env: { region: 'us-west-2' } });\nconst barStack = new BarStack(app, 'BarStack', {\n  replicaTable: fooStack.globalTable.replica('us-east-1'),\n  env: { region: 'us-east-1' },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding SNS Topic Target to EventBridge Rule with Input Transformer - AWS CDK - TypeScript\nDESCRIPTION: Shows how to add an SNS topic as a target to an existing EventBridge rule using the AWS CDK, and customizes the message sent to the topic via RuleTargetInput.fromText. Assumes the existence of 'onCommitRule' (an EventBridge Rule) and 'topic' (an SNS Topic). This allows human-readable message customization upon matching events. Requires 'aws-cdk-lib/aws-events', 'aws-cdk-lib/aws-events-targets', and 'aws-cdk-lib/aws-sns'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const onCommitRule: events.Rule;\ndeclare const topic: sns.Topic;\n\nonCommitRule.addTarget(new targets.SnsTopic(topic, {\n  message: events.RuleTargetInput.fromText(\n    `A commit was pushed to the repository ${codecommit.ReferenceEvent.repositoryName} on branch ${codecommit.ReferenceEvent.referenceName}`\n  )\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding a SingleValueWidget for Latest Values (TypeScript)\nDESCRIPTION: Demonstrates the use of SingleValueWidget to show the latest value for multiple metrics rather than a time-series graph. Requires Dashboard and Metric objects from aws-cdk-lib/aws-cloudwatch. Metrics are provided as an array, and the widget reflects only their most recent values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const visitorCount: cloudwatch.Metric;\ndeclare const purchaseCount: cloudwatch.Metric;\n\ndashboard.addWidgets(new cloudwatch.SingleValueWidget({\n  metrics: [visitorCount, purchaseCount],\n}));\n```\n\n----------------------------------------\n\nTITLE: Granting Specific DynamoDB API Permissions to Lambda - AWS CDK - TypeScript\nDESCRIPTION: This snippet displays the use of the grant method to give a Lambda function explicit 'dynamodb:PutItem' permissions on a DynamoDB table resource in AWS CDK. It depends on lambda.Function and dynamodb.Table constructs, accepting the grantee and specific permission strings as parameters. The result is a targeted permission assignment, rather than granting broad access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\ndeclare const table: dynamodb.Table;\n\ntable.grant(fn, 'dynamodb:PutItem');\n```\n\n----------------------------------------\n\nTITLE: Integrating AppSync with Aurora Serverless V2 using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code configures an AWS AppSync API integration with an Aurora Serverless V2 cluster using AWS CDK. It shows creating a database secret, VPC, the V2 cluster (`rds.DatabaseCluster` with `serverlessV2` instances and `enableDataApi: true`), adding the cluster as an RDS data source (`api.addRdsDataSourceV2`), and setting up resolvers with custom VTL mapping templates for executing SQL queries and mutations via the Data API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Create username and password secret for DB Cluster\nconst secret = new rds.DatabaseSecret(this, 'AuroraSecret', {\n  username: 'clusteradmin',\n});\n\n// The VPC to place the cluster in\nconst vpc = new ec2.Vpc(this, 'AuroraVpc');\n\n// Create the serverless cluster, provide all values needed to customise the database.\nconst cluster = new rds.DatabaseCluster(this, 'AuroraClusterV2', {\n    engine: rds.DatabaseClusterEngine.auroraPostgres({ version: rds.AuroraPostgresEngineVersion.VER_15_5 }),\n    credentials: { username: 'clusteradmin' },\n    clusterIdentifier: 'db-endpoint-test',\n    writer: rds.ClusterInstance.serverlessV2('writer'),\n    serverlessV2MinCapacity: 2,\n    serverlessV2MaxCapacity: 10,\n    vpc,\n    defaultDatabaseName: 'demos',\n    enableDataApi: true,  // has to be set to true to enable Data API as not enable by default\n  });\n\n// Build a data source for AppSync to access the database.\ndeclare const api: appsync.GraphqlApi;\nconst rdsDS = api.addRdsDataSourceV2('rds', cluster, secret, 'demos');\n\n// Set up a resolver for an RDS query.\nrdsDS.createResolver('QueryGetDemosRdsResolver', {\n  typeName: 'Query',\n  fieldName: 'getDemosRds',\n  requestMappingTemplate: appsync.MappingTemplate.fromString(`\n  {\n    \"version\": \"2018-05-29\",\n    \"statements\": [\n      \"SELECT * FROM demos\"\n    ]\n  }\n  `),\n  responseMappingTemplate: appsync.MappingTemplate.fromString(`\n    $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])\n  `),\n});\n\n// Set up a resolver for an RDS mutation.\nrdsDS.createResolver('MutationAddDemoRdsResolver', {\n  typeName: 'Mutation',\n  fieldName: 'addDemoRds',\n  requestMappingTemplate: appsync.MappingTemplate.fromString(`\n  {\n    \"version\": \"2018-05-29\",\n    \"statements\": [\n      \"INSERT INTO demos VALUES (:id, :version)\",\n      \"SELECT * WHERE id = :id\"\n    ],\n    \"variableMap\": {\n      \":id\": $util.toJson($util.autoId()),\n      \":version\": $util.toJson($ctx.args.version)\n    }\n  }\n  `),\n  responseMappingTemplate: appsync.MappingTemplate.fromString(`\n    $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])\n  `),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling SSM Session Manager Permissions for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet shows how to grant instances in an AWS Auto Scaling Group the necessary permissions to be managed via SSM Session Manager, using the AWS CDK. It initializes an `AutoScalingGroup` using an Amazon Linux 2 image (which includes the SSM agent) and sets the `ssmSessionPermissions` property to `true`. Dependencies include a declared `vpc` variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.MICRO),\n\n  // Amazon Linux 2 comes with SSM Agent by default\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n\n  // Turn on SSM\n  ssmSessionPermissions: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding SNS Topic Target Using Input Object for EventBridge Rule - AWS CDK - TypeScript\nDESCRIPTION: Illustrates adding an SNS topic as a target for an EventBridge rule with the message constructed using RuleTargetInput.fromObject for structured input. This allows creating structured notifications for downstream systems. The example assumes 'onCommitRule' and 'topic' are instantiated. Dependencies include 'aws-cdk-lib/aws-events', 'aws-cdk-lib/aws-events-targets', and 'aws-cdk-lib/aws-sns'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const onCommitRule: events.Rule;\ndeclare const topic: sns.Topic;\n\nonCommitRule.addTarget(new targets.SnsTopic(topic, {\n  message: events.RuleTargetInput.fromObject(\n    {\n      DataType: `custom_${events.EventField.fromPath('$.detail-type')}`\n    }\n  )\n}));\n```\n\n----------------------------------------\n\nTITLE: Constructing an Empty Pipeline in TypeScript\nDESCRIPTION: Creates a basic empty CodePipeline using the AWS CDK. This is the simplest form of pipeline creation with default settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Construct an empty Pipeline\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline');\n```\n\n----------------------------------------\n\nTITLE: Adding a Lambda Subscription with Filter Policy to an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure an SNS topic subscription for a Lambda function with advanced message attribute filtering. Requires sns, lambda, and subscriptions from AWS CDK. The filterPolicy object defines criteria such as allowed attribute values, denied values, numeric ranges, and existence checks, controlling which messages trigger the Lambda. Useful for selective event processing in serverless architectures.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst myTopic = new sns.Topic(this, 'MyTopic');\ndeclare const fn: lambda.Function;\n\n// Lambda should receive only message matching the following conditions on attributes:\n// color: 'red' or 'orange' or begins with 'bl'\n// size: anything but 'small' or 'medium'\n// price: between 100 and 200 or greater than 300\n// store: attribute must be present\nmyTopic.addSubscription(new subscriptions.LambdaSubscription(fn, {\n  filterPolicy: {\n    color: sns.SubscriptionFilter.stringFilter({\n      allowlist: ['red', 'orange'],\n      matchPrefixes: ['bl'],\n      matchSuffixes: ['ue'],\n    }),\n    size: sns.SubscriptionFilter.stringFilter({\n      denylist: ['small', 'medium'],\n    }),\n    price: sns.SubscriptionFilter.numericFilter({\n      between: { start: 100, stop: 200 },\n      greaterThan: 300,\n    }),\n    store: sns.SubscriptionFilter.existsFilter(),\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Account CloudFormation Action\nDESCRIPTION: Demonstrates how to set up a CloudFormation action that deploys to a different AWS account by specifying the target account ID directly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Actions that don't accept a resource objet accept an explicit `account` parameter\ndeclare const stage: codepipeline.IStage;\ndeclare const templatePath: codepipeline.ArtifactPath;\nstage.addAction(new codepipeline_actions.CloudFormationCreateUpdateStackAction({\n  account: '123456789012',\n  templatePath,\n  adminPermissions: false,\n  stackName: Stack.of(this).stackName,\n  actionName: 'cloudformation-create-update',\n  // ...\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding an SQS Queue Subscription to an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: This code demonstrates subscribing an SQS queue to an SNS topic in AWS CDK. It needs the sns construct and an sqs.Queue reference. The subscriptions.SqsSubscription class establishes the integration, allowing queued processing of messages published to the SNS topic. This pattern decouples message publishers and consumers, commonly used in event-driven architectures.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const queue: sqs.Queue;\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.addSubscription(new subscriptions.SqsSubscription(queue));\n```\n\n----------------------------------------\n\nTITLE: Defining KMS Keys with Rotation Using AWS CDK in TypeScript\nDESCRIPTION: Creates a new AWS KMS key with key rotation enabled by default and sets a custom rotation period using the AWS CDK. Requires 'aws-cdk-lib/aws-kms' and utilizes the CDK Duration utility. Key rotation secures data by automatically changing the cryptographic material. The snippet defaults the rotation to 365 days unless specified; here, it is set to 180 days.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kms.Key(this, 'MyKey', {\n  enableKeyRotation: true,\n  rotationPeriod: Duration.days(180), // Default is 365 days\n});\n```\n\n----------------------------------------\n\nTITLE: Using Managed Response Headers Policy for CloudFront Distribution\nDESCRIPTION: This snippet demonstrates how to use a pre-defined (managed) response headers policy for a CloudFront distribution. It applies the CORS_ALLOW_ALL_ORIGINS policy to the default behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Using an existing managed response headers policy\ndeclare const bucketOrigin: origins.S3Origin;\nnew cloudfront.Distribution(this, 'myDistManagedPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    responseHeadersPolicy: cloudfront.ResponseHeadersPolicy.CORS_ALLOW_ALL_ORIGINS,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from EC2 Instance using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an AWS CloudFront distribution where the origin is an EC2 instance located within a VPC, potentially in a private subnet. It initializes an EC2 instance with specific properties (VPC, instance type, machine image, subnet type) and then uses `origins.VpcOrigin.withEc2Instance` to configure it as the default origin for a new CloudFront distribution. Requires `aws-cdk-lib/aws-ec2` and `aws-cdk-lib/aws-cloudfront` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n``` ts\n// Creates a distribution from an EC2 instance\ndeclare const vpc: ec2.Vpc;\n// Create an EC2 instance in a VPC. 'subnetType' can be private.\nconst instance = new ec2.Instance(this, 'Instance', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE3, ec2.InstanceSize.MICRO),\n  machineImage: ec2.MachineImage.latestAmazonLinux2023(),\n  vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS },\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: origins.VpcOrigin.withEc2Instance(instance) },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Region HTTPS Redirects with Feature Flags in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates configuring an HTTPS redirect using the HttpsRedirect construct along with cross-region certificate management. It declares an AWS CDK App and creates a Stack with \\'crossRegionReferences: true\\' and environment set to \\'region: us-east-2\\', meeting requirements when the ACM certificate must be provisioned in \\'us-east-1\\' but resources are deployed in other regions. This approach additionally enables feature flags for propagating certificate resource types; key parameters mirror the prior snippet, but feature flag setup and cross-region support are highlighted for advanced CDK deployment scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-patterns/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const app: App;\nconst stack = new Stack(app, 'Stack', {\n  crossRegionReferences: true,\n  env: {\n    region: 'us-east-2',\n  },\n});\n\nnew patterns.HttpsRedirect(this, 'Redirect', {\n  recordNames: ['foo.example.com'],\n  targetDomain: 'bar.example.com',\n  zone: route53.HostedZone.fromHostedZoneAttributes(this, 'HostedZone', {\n    hostedZoneId: 'ID',\n    zoneName: 'example.com',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Cognito Hosted UI Sign-In URLs using AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to generate a fully qualified sign-in URL for the Cognito Hosted UI using the signInUrl method on a user pool domain instance. Dependencies include a configured Cognito UserPool, a related client with appropriate OAuth settings (including callback URLs), and an added domain. Inputs are the client and redirect URI; the output is a sign-in URL string for use in applications. All URLs used must be registered with the client.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'UserPool', {\n  // ...\n});\nconst client = userpool.addClient('Client', {\n  // ...\n  oAuth: {\n    flows: {\n      implicitCodeGrant: true,\n    },\n    callbackUrls: [\n      'https://myapp.com/home',\n      'https://myapp.com/users',\n    ],\n  },\n});\nconst domain = userpool.addDomain('Domain', {\n  // ...\n});\nconst signInUrl = domain.signInUrl(client, {\n  redirectUri: 'https://myapp.com/home', // must be a URL configured under 'callbackUrls' with the client\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SimpleDB Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS SimpleDB construct library module from the core `aws-cdk-lib` package. Aliasing the module as `sdb` allows access to its components, primarily the lower-level (L1) constructs that map directly to CloudFormation resources for SimpleDB, as higher-level (L2) constructs are not yet available for this service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sdb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sdb from 'aws-cdk-lib/aws-sdb';\n```\n\n----------------------------------------\n\nTITLE: Creating a FIFO SNS Topic with Content-Based Deduplication in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a FIFO (First-In-First-Out) SNS topic with content-based deduplication enabled in AWS CDK. It requires the sns construct from aws-cdk-lib and shows the usage of the fifo and contentBasedDeduplication properties. The display name is also specified. FIFO topics ensure message ordering and guarantee exactly-once delivery; enabling content-based deduplication eliminates duplicate messages based on their content. Used in scenarios requiring strict message ordering and duplicate prevention.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic', {\n  contentBasedDeduplication: true,\n  displayName: 'Customer subscription topic',\n  fifo: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Queueing Batch Job with EventBridge and Custom Retry Policy - TypeScript\nDESCRIPTION: This code demonstrates how to configure an AWS Batch job as the target of an EventBridge rule triggered hourly, including setting up a Fargate compute environment, job queue, job definition, and dead-letter queue. It also customizes the event payload and sets retryAttempts and maxEventAge for the retry policy. Required dependencies are aws-cdk-lib/aws-batch, aws-cdk-lib/aws-ecs, aws-cdk-lib/aws-ec2, aws-cdk-lib/aws-events, aws-cdk-lib/aws-sqs, ContainerImage, and cdk.Size.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\nimport * as batch from 'aws-cdk-lib/aws-batch';\nimport { ContainerImage } from 'aws-cdk-lib/aws-ecs';\n\ndeclare const vpc: ec2.Vpc;\n\nconst computeEnvironment = new batch.FargateComputeEnvironment(this, 'ComputeEnv', {\n  vpc,\n});\n\nconst jobQueue = new batch.JobQueue(this, 'JobQueue', {\n  priority: 1,\n  computeEnvironments: [\n    {\n      computeEnvironment,\n      order: 1,\n    },\n  ],\n});\n\nconst jobDefinition = new batch.EcsJobDefinition(this, 'MyJob', {\n  container: new batch.EcsEc2ContainerDefinition(this, 'Container', {\n    image: ecs.ContainerImage.fromRegistry('test-repo'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n  }),\n});\n\nconst queue = new sqs.Queue(this, 'Queue');\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(Duration.hours(1)),\n});\n\nrule.addTarget(new targets.BatchJob(\n  jobQueue.jobQueueArn,\n  jobQueue,\n  jobDefinition.jobDefinitionArn,\n  jobDefinition,\n  {\n    deadLetterQueue: queue,\n    event: events.RuleTargetInput.fromObject({ SomeParam: 'SomeValue' }),\n    retryAttempts: 2,\n    maxEventAge: Duration.hours(2),\n  },\n));\n```\n\n----------------------------------------\n\nTITLE: Configuring ECS Deployment Rollbacks with CloudWatch Alarms in AWS CDK\nDESCRIPTION: Sets up CodeDeploy to monitor CloudWatch alarms for unhealthy ECS tasks and HTTP 5xx errors in blue/green target groups, automatically rolling back if alarms trigger. The configuration uses both unhealthy host count and HTTP 5xx response metrics with specified thresholds and evaluation periods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const service: ecs.FargateService;\ndeclare const blueTargetGroup: elbv2.ApplicationTargetGroup;\ndeclare const greenTargetGroup: elbv2.ApplicationTargetGroup;\ndeclare const listener: elbv2.IApplicationListener;\n\n// Alarm on the number of unhealthy ECS tasks in each target group\nconst blueUnhealthyHosts = new cloudwatch.Alarm(this, 'BlueUnhealthyHosts', {\n  alarmName: Stack.of(this).stackName + '-Unhealthy-Hosts-Blue',\n  metric: blueTargetGroup.metricUnhealthyHostCount(),\n  threshold: 1,\n  evaluationPeriods: 2,\n});\n\nconst greenUnhealthyHosts = new cloudwatch.Alarm(this, 'GreenUnhealthyHosts', {\n  alarmName: Stack.of(this).stackName + '-Unhealthy-Hosts-Green',\n  metric: greenTargetGroup.metricUnhealthyHostCount(),\n  threshold: 1,\n  evaluationPeriods: 2,\n});\n\n// Alarm on the number of HTTP 5xx responses returned by each target group\nconst blueApiFailure = new cloudwatch.Alarm(this, 'Blue5xx', {\n  alarmName: Stack.of(this).stackName + '-Http-5xx-Blue',\n  metric: blueTargetGroup.metricHttpCodeTarget(\n    elbv2.HttpCodeTarget.TARGET_5XX_COUNT,\n    { period: Duration.minutes(1) },\n  ),\n  threshold: 1,\n  evaluationPeriods: 1,\n});\n\nconst greenApiFailure = new cloudwatch.Alarm(this, 'Green5xx', {\n  alarmName: Stack.of(this).stackName + '-Http-5xx-Green',\n  metric: greenTargetGroup.metricHttpCodeTarget(\n    elbv2.HttpCodeTarget.TARGET_5XX_COUNT,\n    { period: Duration.minutes(1) },\n  ),\n  threshold: 1,\n  evaluationPeriods: 1,\n});\n\nnew codedeploy.EcsDeploymentGroup(this, 'BlueGreenDG', {\n  // CodeDeploy will monitor these alarms during a deployment and automatically roll back\n  alarms: [blueUnhealthyHosts, greenUnhealthyHosts, blueApiFailure, greenApiFailure],\n  autoRollback: {\n    // CodeDeploy will automatically roll back if a deployment is stopped\n    stoppedDeployment: true,\n  },\n  service,\n  blueGreenDeploymentConfig: {\n    blueTargetGroup,\n    greenTargetGroup,\n    listener,\n  },\n  deploymentConfig: codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Enrichment for EventBridge Pipe in TypeScript\nDESCRIPTION: Demonstrates how to add a Lambda function as enrichment to an EventBridge Pipe. It shows input transformation, pipe creation, and explains the processing of input events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\ndeclare const enrichmentLambda: lambda.Function;\n\nconst enrichmentInputTransformation = pipes.InputTransformation.fromObject({\n  staticField: 'static value',\n  dynamicField: pipes.DynamicInput.fromEventPath('$.body.payload'),\n  pipeVariable: pipes.DynamicInput.pipeName,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue),\n  enrichment: new LambdaEnrichment(enrichmentLambda, {\n    inputTransformation: enrichmentInputTransformation,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Secrets and RDS Instances with Generated or Templated Credentials - AWS CDK TypeScript\nDESCRIPTION: Demonstrates how to create a new RDS Postgres instance with credentials managed via AWS Secrets Manager, using both CDK-native secret generation and explicit templated secret values. Shows usage of templated secrets as credentials, and integration with VPC resources. Dependencies: aws-cdk-lib/aws-rds, aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-ec2; requires a VPC and RDS instance configuration. Expects valid VPC, correct engine specification, and optionally, configuration of excluded characters in password generation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nconst instance1 = new rds.DatabaseInstance(this, \"PostgresInstance1\", {\n  engine: rds.DatabaseInstanceEngine.POSTGRES,\n  // Generate the secret with admin username `postgres` and random password\n  credentials: rds.Credentials.fromGeneratedSecret('postgres'),\n  vpc\n});\n// Templated secret with username and password fields\nconst templatedSecret = new secretsmanager.Secret(this, 'TemplatedSecret', {\n  generateSecretString: {\n    secretStringTemplate: JSON.stringify({ username: 'postgres' }),\n    generateStringKey: 'password',\n    excludeCharacters: '/@\"',\n  },\n});\n// Using the templated secret as credentials\nconst instance2 = new rds.DatabaseInstance(this, \"PostgresInstance2\", {\n  engine: rds.DatabaseInstanceEngine.POSTGRES,\n  credentials: {\n    username: templatedSecret.secretValueFromJson('username').toString(),\n    password: templatedSecret.secretValueFromJson('password')\n  },\n  vpc\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom EC2 Compliance Rules with AWS Config in TypeScript CDK\nDESCRIPTION: Demonstrates a complete example of creating a custom AWS Config rule for EC2 instances with compliance evaluation. Includes Lambda function creation, rule configuration, and compliance notification setup using SNS topics.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Lambda function containing logic that evaluates compliance with the rule.\nconst evalComplianceFn = new lambda.Function(this, 'CustomFunction', {\n  code: lambda.AssetCode.fromInline('exports.handler = (event) => console.log(event);'),\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_18_X,\n});\n\n// A custom rule that runs on configuration changes of EC2 instances\nconst customRule = new config.CustomRule(this, 'Custom', {\n  configurationChanges: true,\n  lambdaFunction: evalComplianceFn,\n  ruleScope: config.RuleScope.fromResource(config.ResourceType.EC2_INSTANCE),\n});\n\n// A rule to detect stack drifts\nconst driftRule = new config.CloudFormationStackDriftDetectionCheck(this, 'Drift');\n\n// Topic to which compliance notification events will be published\nconst complianceTopic = new sns.Topic(this, 'ComplianceTopic');\n\n// Send notification on compliance change events\ndriftRule.onComplianceChange('ComplianceChange', {\n  target: new targets.SnsTopic(complianceTopic),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront Origin Fallback (TypeScript)\nDESCRIPTION: Creates an AWS CloudFront distribution with origin fallback using AWS CDK. It configures a primary S3 origin and a fallback S3 origin, specifying that fallback should occur on HTTP 5xx status codes (specifically INTERNAL_SERVER_ERROR). Includes configuration for origin paths, headers, and Origin Shield regions for both origins. Requires `@aws-cdk/aws-cloudfront`, `@aws-cdk/aws-s3`, and `@aws-cdk/core` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_44\n\nLANGUAGE: ts\nCODE:\n```\n// Configuring origin fallback options for the CloudFrontWebDistribution\nnew cloudfront.CloudFrontWebDistribution(this, 'ADistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: s3.Bucket.fromBucketName(this, 'aBucket', 'amzn-s3-demo-bucket'),\n        originPath: '/',\n        originHeaders: {\n          'myHeader': '42',\n        },\n        originShieldRegion: 'us-west-2',\n      },\n      failoverS3OriginSource: {\n        s3BucketSource: s3.Bucket.fromBucketName(this, 'aBucketFallback', 'amzn-s3-demo-bucket1'),\n        originPath: '/somewhere',\n        originHeaders: {\n          'myHeader2': '21',\n        },\n        originShieldRegion: 'us-east-1',\n      },\n      failoverCriteriaStatusCodes: [cloudfront.FailoverStatusCode.INTERNAL_SERVER_ERROR],\n      behaviors: [\n        {\n          isDefaultBehavior: true,\n        },\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Generating an IAM Policy Report without Preventing Synthesis - AWS CDK - TypeScript\nDESCRIPTION: This example configures the customizeRoles method to generate an iam-policy-report.txt report without blocking the synthesis or deployment of IAM roles and policies. Setting preventSynthesis to false allows deployment to proceed, enabling a hybrid workflow for audit or compliance. Requires an instance of Stack and the iam library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stack: Stack;\niam.Role.customizeRoles(this, {\n  preventSynthesis: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Backup Vault with KMS Encryption and SNS Notifications - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates the creation of a custom backup vault with a specific KMS encryption key and SNS topic for notifications using the AWS CDK in TypeScript. Requires initialized KMS Key and SNS Topic objects along with the backup CDK module. Inputs are encryptionKey and notificationTopic; output is a configured BackupVault granting fine-grained control for security and alerts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst myKey = kms.Key.fromKeyArn(this, 'MyKey', 'aaa');\nconst myTopic = sns.Topic.fromTopicArn(this, 'MyTopic', 'bbb');\n\nconst vault = new backup.BackupVault(this, 'Vault', {\n  encryptionKey: myKey, // Custom encryption key\n  notificationTopic: myTopic, // Send all vault events to this SNS topic\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Deletion Protection with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to enable deletion protection for a DynamoDB table using the TableV2 construct, which prevents the table from being deleted by any user or process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  deletionProtection: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SES Receipt Rule Set with S3 and SNS Actions - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to define an SES receipt rule set in AWS CDK. It configures rules that store incoming emails in an S3 bucket, set custom headers, and forward notifications to an SNS topic using SES actions. Dependencies include 'aws-cdk-lib/aws-s3', 'aws-cdk-lib/aws-ses-actions', and an existing SNS topic or S3 bucket. Key parameters involve rule recipients and the action configuration for each rule. Input consists of incoming emails; expected outputs are S3 objects (emails) and SNS notifications. Actions are extensible and can be chained or extended with further integrations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as actions from 'aws-cdk-lib/aws-ses-actions';\n\nconst bucket = new s3.Bucket(this, 'Bucket');\nconst topic = new sns.Topic(this, 'Topic');\n\nnew ses.ReceiptRuleSet(this, 'RuleSet', {\n  rules: [\n    {\n      recipients: ['hello@aws.com'],\n      actions: [\n        new actions.AddHeader({\n          name: 'X-Special-Header',\n          value: 'aws',\n        }),\n        new actions.S3({\n          bucket,\n          objectKeyPrefix: 'emails/',\n          topic,\n        }),\n      ],\n    },\n    {\n      recipients: ['aws.com'],\n      actions: [\n        new actions.Sns({\n          topic,\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Multiple S3 BucketDeployments with Prune False for Differential Cache Control (TypeScript)\nDESCRIPTION: This snippet exemplifies the use of two sequential BucketDeployment constructs with prune set to false, allowing for custom cache-control headers applied to different file sets within the same bucket. This supports advanced deployment scenarios, such as setting long-term caching for static files and minimal caching for HTML. Needs AWS CDK's s3, s3-deployment, and Duration utility.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\nnew s3deploy.BucketDeployment(this, 'BucketDeployment', {\n  sources: [s3deploy.Source.asset('./website', { exclude: ['index.html'] })],\n  destinationBucket,\n  cacheControl: [\n    s3deploy.CacheControl.maxAge(Duration.days(365)),\n    s3deploy.CacheControl.immutable(),\n  ],\n  prune: false,\n});\n\nnew s3deploy.BucketDeployment(this, 'HTMLBucketDeployment', {\n  sources: [s3deploy.Source.asset('./website', { exclude: ['*', '!index.html'] })],\n  destinationBucket,\n  cacheControl: [\n    s3deploy.CacheControl.maxAge(Duration.seconds(0)),\n  ],\n  prune: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from API Gateway REST API (Default Path) using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to configure an AWS CloudFront distribution to use an API Gateway REST API as its origin. It uses `origins.RestApiOrigin`, which automatically sets the origin path to the API's stage name. It assumes a regional API Gateway endpoint. Requires `aws-cdk-lib/aws-apigateway`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const api: apigateway.RestApi;\nnew cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: new origins.RestApiOrigin(api) },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Same-Account/Cross-Region VPC Peering with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates setting up VPC peering between VPCs in different regions within the same AWS account using AWS CDK. It involves defining VPCs (`VpcA`, `VpcB`) in separate stacks (`stackA`, `stackB`) with different region configurations. The acceptor VPC (`vpcB`) attributes are imported into the requestor stack (`stackA`) using `VpcV2.fromVpcV2Attributes`, providing necessary details like VPC ID, CIDR, region, and owner account ID. Finally, `vpcA.createPeeringConnection` is called with the imported acceptor VPC. Dependencies include `@aws-cdk/core` (App, Stack) and implicitly `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst app = new App();\n\nconst stackA = new Stack(app, 'VpcStackA', { env: { account: '000000000000', region: 'us-east-1' } });\nconst stackB = new Stack(app, 'VpcStackB', { env: { account: '000000000000', region: 'us-west-2' } });\n\nconst vpcA = new VpcV2(stackA, 'VpcA', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/16'),\n});\n\nnew VpcV2(stackB, 'VpcB', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n});\n\nconst vpcB = VpcV2.fromVpcV2Attributes(stackA, 'ImportedVpcB', {\n      vpcId: 'MockVpcBid',\n      vpcCidrBlock: '10.1.0.0/16',\n      region: 'us-west-2',\n      ownerAccountId: '000000000000',\n    });\n\n\nconst peeringConnection = vpcA.createPeeringConnection('sameAccountCrossRegionPeering', {\n  acceptorVpc: vpcB,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Pull Request Branches and File Paths using AWS CDK (TypeScript)\nDESCRIPTION: This snippet expands pull request filtering in AWS CDK (TypeScript) to include both branch and file path conditions using pullRequestFilter. You can specify arrays for 'branchesIncludes', 'branchesExcludes', 'filePathsIncludes', and 'filePathsExcludes', with excludes prioritized. Requires codepipeline and codepipeline_actions, a sourceAction and buildAction, and applies to V2 pipelines. The pipeline is triggered by pull request events matching these filters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pullRequestFilter: [{\n        branchesExcludes: ['exclude1', 'exclude2'],\n        branchesIncludes: ['include1', 'include2'],\n        filePathsExcludes: ['/path/to/exclude1', '/path/to/exclude2'],\n        filePathsIncludes: ['/path/to/include1', '/path/to/include1'],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Source for CodeBuild Project in TypeScript\nDESCRIPTION: Illustrates how to set up a GitHub repository as the source for a CodeBuild project. It includes options for webhook configuration, branch filtering, and commit message filtering.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst gitHubSource = codebuild.Source.gitHub({\n  owner: 'awslabs',\n  repo: 'aws-cdk', // optional, default: undefined if unspecified will create organization webhook\n  webhook: true, // optional, default: true if `webhookFilters` were provided, false otherwise\n  webhookTriggersBatchBuild: true, // optional, default is false\n  webhookFilters: [\n    codebuild.FilterGroup\n      .inEventOf(codebuild.EventAction.PUSH)\n      .andBranchIs('main')\n      .andCommitMessageIs('the commit message'),\n    codebuild.FilterGroup\n      .inEventOf(codebuild.EventAction.RELEASED)\n      .andBranchIs('main')\n  ], // optional, by default all pushes and Pull Requests will trigger a build\n});\n```\n\n----------------------------------------\n\nTITLE: Formatting Amazon Resource Names (ARNs) with stack.formatArn (TypeScript)\nDESCRIPTION: Demonstrates using the stack.formatArn method to programmatically construct an ARN from its components with proper format and current stack region/account substitution. Requires an instance of Stack from AWS CDK and appropriate ArnFormat enumeration. Inputs are component properties (service, resource, resourceName, arnFormat); output is a constructed ARN string. Use for generating ARNs in custom resources or when needing to reference resource ARNs explicitly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const stack: Stack;\n\n// Builds \"arn:<PARTITION>:lambda:<REGION>:<ACCOUNT>:function:MyFunction\"\nstack.formatArn({\n  service: 'lambda',\n  resource: 'function',\n  arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n  resourceName: 'MyFunction'\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Database Secret Rotation Using SecretRotation Construct - AWS CDK TypeScript\nDESCRIPTION: Shows creation of a SecretRotation construct for database credentials (e.g., MySQL, single user scheme) with custom password exclusion and full specification of target DB and VPC. Parameters: application (rotation template), secret, target (Connectable), vpc, excludeCharacters. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-ec2. Expects referenced secret and network objects. Useful for scheduled, automated credential rotation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mySecret: secretsmanager.Secret;\ndeclare const myDatabase: ec2.IConnectable;\ndeclare const myVpc: ec2.Vpc;\n\nnew secretsmanager.SecretRotation(this, 'SecretRotation', {\n  application: secretsmanager.SecretRotationApplication.MYSQL_ROTATION_SINGLE_USER, // MySQL single user scheme\n  secret: mySecret,\n  target: myDatabase, // a Connectable\n  vpc: myVpc, // The VPC where the secret rotation application will be deployed\n  excludeCharacters: ' %+:;{}', // characters to never use when generating new passwords;\n                                // by default, no characters are excluded,\n                                // which might cause problems with some services, like DMS\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Processing Fargate Service with aws-cdk ECS Patterns (TypeScript)\nDESCRIPTION: Instantiates a QueueProcessingFargateService to deploy a queue-processing microservice on AWS Fargate within an ECS cluster. The construct sets up an SQS queue and configures container, environment, scaling, and logging options. Prerequisites include an ECS cluster and appropriate CDK modules. Parameters cover memory, logging, scaling boundaries, and health check settings. When a queue is not specified, a default primary and dead letter queue are provisioned with related IAM permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  command: [\"-c\", \"4\", \"amazon.com\"],\n  enableLogging: false,\n  desiredTaskCount: 2,\n  environment: {\n    TEST_ENVIRONMENT_VARIABLE1: \"test environment variable 1 value\",\n    TEST_ENVIRONMENT_VARIABLE2: \"test environment variable 2 value\",\n  },\n  maxScalingCapacity: 5,\n  containerName: 'test',\n  minHealthyPercent: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual Deployment Approval in AWS CDK\nDESCRIPTION: Configures a CodeDeploy deployment group with manual approval requirements, setting an 8-hour window for manual approval before the deployment is stopped and rolled back. This pattern allows for additional validation steps to be performed before routing production traffic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const service: ecs.FargateService;\ndeclare const blueTargetGroup: elbv2.ITargetGroup;\ndeclare const greenTargetGroup: elbv2.ITargetGroup;\ndeclare const listener: elbv2.IApplicationListener;\ndeclare const testListener: elbv2.IApplicationListener;\n\nnew codedeploy.EcsDeploymentGroup(this, 'BlueGreenDG', {\n  autoRollback: {\n    // CodeDeploy will automatically roll back if the 8-hour approval period times out and the deployment stops\n    stoppedDeployment: true,\n  },\n  service,\n  blueGreenDeploymentConfig: {\n    // The deployment will wait for approval for up to 8 hours before stopping the deployment\n    deploymentApprovalWaitTime: Duration.hours(8),\n    blueTargetGroup,\n    greenTargetGroup,\n    listener,\n    testListener,\n  },\n  deploymentConfig: codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES,\n});\n```\n\n----------------------------------------\n\nTITLE: Using an Existing Report Group ARN in CodeBuild BuildSpec (TypeScript)\nDESCRIPTION: This snippet shows how to configure a CodeBuild project to use a pre-existing report group. It first creates a `codebuild.ReportGroup` instance and then references its ARN (`reportGroup.reportGroupArn`) as the key within the `reports` section of the `BuildSpec`. This associates the build's reports with the specified, externally managed report group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const source: codebuild.Source;\n\n// create a new ReportGroup\nconst reportGroup = new codebuild.ReportGroup(this, 'ReportGroup');\n\nconst project = new codebuild.Project(this, 'Project', {\n  source,\n  buildSpec: codebuild.BuildSpec.fromObject({\n    // ...\n    reports: {\n      [reportGroup.reportGroupArn]: {\n        files: '**/*',\n        'base-directory': 'build/test-results',\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing HTTP Authorizer in AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import an existing HTTP Authorizer into an AWS CDK stack by supplying its authorizer ID and type via CloudFormation imports. It uses the 'fromHttpAuthorizerAttributes' static method for resource referencing. Required dependencies are aws-cdk-lib and its API Gateway modules. Both string parameters and their correct values from previous outputs are essential. The constructed authorizer instance can then be used with HTTP APIs in the stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2';\nimport { Fn } from 'aws-cdk-lib'\n\nconst authorizerId = Fn.importValue('authorizerId');\nconst authorizerType = Fn.importValue('authorizerType');\n\nconst authorizer = HttpAuthorizer.fromHttpAuthorizerAttributes(this, 'HttpAuthorizer', {\n    authorizerId,\n    authorizerType\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering CodePipeline Pipeline via EventBridge Rule - TypeScript\nDESCRIPTION: This snippet demonstrates how to create a CodePipeline pipeline and configure an EventBridge rule to trigger it on a defined schedule (every hour) using AWS CDK in TypeScript. The pipeline is attached as an EventBridge target. Dependencies are aws-cdk-lib/aws-codepipeline and aws-cdk-lib/aws-events. The schedule uses a cron expression.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codepipeline from 'aws-cdk-lib/aws-codepipeline';\n\nconst pipeline = new codepipeline.Pipeline(this, 'Pipeline');\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.expression('rate(1 hour)'),\n});\n\nrule.addTarget(new targets.CodePipeline(pipeline));\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB Table Properties\nDESCRIPTION: Example showing how to configure additional table properties like contributor insights, table class, and point-in-time recovery.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  contributorInsights: true,\n  tableClass: dynamodb.TableClass.STANDARD_INFREQUENT_ACCESS,\n  pointInTimeRecoverySpecification: {\n    pointInTimeRecoveryEnabled: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a VirtualNode with CloudMap service discovery in AWS App Mesh\nDESCRIPTION: Creates a VirtualNode with CloudMap service discovery, HTTP listener, health check configuration, and standard access logging. The example sets up basic infrastructure including VPC and CloudMap namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'vpc');\nconst namespace = new cloudmap.PrivateDnsNamespace(this, 'test-namespace', {\n    vpc,\n    name: 'domain.local',\n});\nconst service = namespace.createService('Svc');\n\ndeclare const mesh: appmesh.Mesh;\nconst node = mesh.addVirtualNode('virtual-node', {\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service),\n  listeners: [appmesh.VirtualNodeListener.http({\n    port: 8081,\n    healthCheck: appmesh.HealthCheck.http({\n      healthyThreshold: 3,\n      interval: Duration.seconds(5), // minimum\n      path: '/health-check-path',\n      timeout: Duration.seconds(2), // minimum\n      unhealthyThreshold: 2,\n    }),\n  })],\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Customer-Managed Encryption for DynamoDB in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a DynamoDB table with customer-managed encryption using a custom KMS key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst encryptionKey = new kms.Key(this, 'Key', {\n  enableKeyRotation: true,\n});\nconst table = new dynamodb.Table(this, 'MyTable', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryption.CUSTOMER_MANAGED,\n  encryptionKey, // This will be exposed as table.encryptionKey\n});\n```\n\n----------------------------------------\n\nTITLE: Defining EventBridge Schedule with Lambda Target (AWS CDK, TypeScript)\nDESCRIPTION: Demonstrates how to create a recurring EventBridge Scheduler schedule that invokes an AWS Lambda function every 10 minutes. Requires constructs such as lambda.Function, Schedule, ScheduleExpression, and LambdaInvoke from AWS CDK modules. The code sets a target with a custom JSON payload using ScheduleTargetInput and provides a human-friendly description. Inputs are the Lambda function and scheduling interval, output is a scheduled invocation of the Lambda function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nconst target = new targets.LambdaInvoke(fn, {\n    input: ScheduleTargetInput.fromObject({\n        \"payload\": \"useful\",\n    }),\n});\n\nconst schedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(10)),\n    target,\n    description: 'This is a test schedule that invokes a lambda function every 10 minutes.',\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Service Principals to Role Trust Policy\nDESCRIPTION: Shows how to add service and account principals to a role's trust policy using assumeRolePolicy.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'role', {\n  assumedBy: new iam.AccountPrincipal(this.account),\n});\n\nrole.assumeRolePolicy?.addStatements(new iam.PolicyStatement({\n  actions: ['sts:AssumeRole'],\n  principals: [\n    new iam.AccountPrincipal('123456789'),\n    new iam.ServicePrincipal('beep-boop.amazonaws.com')\n    ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding a Global Secondary Index to DynamoDB TableV2 using Method in TypeScript\nDESCRIPTION: This snippet demonstrates adding a Global Secondary Index (GSI) to an existing DynamoDB TableV2 instance using the `addGlobalSecondaryIndex` method. This allows adding indexes after the initial table definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  globalSecondaryIndexes: [\n    {\n      indexName: 'gsi1',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n    },\n  ],\n});\n\ntable.addGlobalSecondaryIndex({\n  indexName: 'gsi2',\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Advanced Custom Resource Provider (AWS CDK, TypeScript)\nDESCRIPTION: This code creates an advanced custom resource provider using @aws-cdk/custom-resources.Provider, supporting both synchronous and asynchronous handlers (onEventHandler, isCompleteHandler). It then instantiates a CustomResource using the provider's serviceToken for event bridging. Handlers are AWS Lambda functions and can be implemented in any Lambda-supported runtime. It is suitable for long-running custom resources as it supports polling via isCompleteHandler.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst provider = new customresources.Provider(this, 'MyProvider', {\n  onEventHandler,\n  isCompleteHandler, // optional async waiter\n});\n\nnew CustomResource(this, 'MyResource', {\n  serviceToken: provider.serviceToken\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Time-Based Canary Lambda Deployment Configuration in TypeScript\nDESCRIPTION: Illustrates how to create a custom CodeDeploy deployment configuration for AWS Lambda using AWS CDK. This example defines a time-based canary strategy where 5% of traffic is shifted every 15 minutes. This provides fine-grained control over the deployment rollout speed compared to predefined configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = new codedeploy.LambdaDeploymentConfig(this, 'CustomConfig', {\n  trafficRouting: new codedeploy.TimeBasedCanaryTrafficRouting({\n    interval: Duration.minutes(15),\n    percentage: 5,\n  }),\n});\n\ndeclare const application: codedeploy.LambdaApplication;\ndeclare const alias: lambda.Alias;\nconst deploymentGroup = new codedeploy.LambdaDeploymentGroup(this, 'BlueGreenDeployment', {\n  application,\n  alias,\n  deploymentConfig: config,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudWatch Logs for AWS AppSync Event API in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure CloudWatch Logs for an AWS AppSync Event API. It sets the log retention period and log level for the API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst apiKeyProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.API_KEY,\n};\n\nconst api = new appsync.EventApi(this, 'api', {\n  apiName: 'Api',\n  ownerContact: 'OwnerContact',\n  authorizationConfig: {\n    authProviders: [\n      apiKeyProvider,\n    ],\n    connectionAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultPublishAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultSubscribeAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n  },\n  logConfig: {\n    fieldLogLevel: appsync.AppSyncFieldLogLevel.INFO,\n    retention: logs.RetentionDays.ONE_WEEK,\n  },\n});\n\napi.addChannelNamespace('default');\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT Authorizer for Specific Route with AWS CDK - TypeScript\nDESCRIPTION: Shows how to configure a JWT authorizer for a specific HTTP API route using AWS CDK in TypeScript. The snippet demonstrates authorizer creation with issuer and audience, binding it to particular routes via addRoutes, and integrating with an HTTP endpoint. Requires aws-cdk-lib/aws-apigatewayv2-authorizers and -integrations as dependencies. Expects valid JWT parameters and endpoint; only specified routes are protected by this authorizer. Invalid or missing tokens return appropriate HTTP errors.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpJwtAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst issuer = 'https://test.us.auth0.com';\nconst authorizer = new HttpJwtAuthorizer('BooksAuthorizer', issuer, {\n  jwtAudience: ['3131231'],\n});\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi');\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  authorizer,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Event Filtering to Kafka Event Source\nDESCRIPTION: Demonstrates how to add event filtering criteria to Kafka event sources using CDK, allowing for selective processing of Kafka messages based on filter rules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ManagedKafkaEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\n// Your MSK cluster arn\nconst clusterArn = 'arn:aws:kafka:us-east-1:0123456789019:cluster/SalesCluster/abcd1234-abcd-cafe-abab-9876543210ab-4';\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new ManagedKafkaEventSource({\n  clusterArn,\n  topic,\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n  filters: [\n    lambda.FilterCriteria.filter({\n      stringEquals: lambda.FilterRule.isEqual('test'),\n    }),\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Load Balanced EC2 Service in AWS CDK\nDESCRIPTION: Creates an ECS service running on EC2 behind an Application Load Balancer. Configures memory limits, container image, environment variables, and health check settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedEcsService = new ecsPatterns.ApplicationLoadBalancedEc2Service(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('test'),\n    environment: {\n      TEST_ENVIRONMENT_VARIABLE1: \"test environment variable 1 value\",\n      TEST_ENVIRONMENT_VARIABLE2: \"test environment variable 2 value\",\n    },\n    command: ['command'],\n    entryPoint: ['entry', 'point'],\n  },\n  desiredCount: 2,\n  minHealthyPercent: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Queue Processing Fargate Service with Custom Parameters\nDESCRIPTION: Demonstrates how to create a QueueProcessingFargateService with custom queue parameters including memory limits, health checks, and queue settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  vpc,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  maxReceiveCount: 42,\n  retentionPeriod: Duration.days(7),\n  visibilityTimeout: Duration.minutes(5),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Read and Write Permissions to a Secret - AWS CDK TypeScript\nDESCRIPTION: Shows how to grant an IAM role both read and write access to a Secrets Manager secret using grantRead and grantWrite. Demonstrates role creation and resource-policy attachment. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-iam. Expects an initialized Secret and Role. Can be used for automating secret access control in applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'SomeRole', { assumedBy: new iam.AccountRootPrincipal() });\nconst secret = new secretsmanager.Secret(this, 'Secret');\nsecret.grantRead(role);\nsecret.grantWrite(role);\n```\n\n----------------------------------------\n\nTITLE: Custom Route-Level Authorization with AWS CDK - TypeScript\nDESCRIPTION: This example demonstrates both default and per-route authorization strategies for an HTTP API using JWT authorizers in AWS CDK. It shows initializing a default JWT authorizer for the API, then overriding or disabling authorization on specific routes using custom scopes or a None authorizer. Dependencies include aws-cdk-lib/aws-apigatewayv2-authorizers and aws-cdk-lib/aws-apigatewayv2-integrations. Examples cover GET and POST methods, route integration, and scope customization; input requires issuer details and integration endpoints. Removing authorization from a route is accomplished via HttpNoneAuthorizer.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpJwtAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst issuer = 'https://test.us.auth0.com';\nconst authorizer = new HttpJwtAuthorizer('DefaultAuthorizer', issuer, {\n  jwtAudience: ['3131231'],\n});\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi', {\n  defaultAuthorizer: authorizer,\n  defaultAuthorizationScopes: ['read:books'],\n});\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  methods: [apigwv2.HttpMethod.GET],\n});\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIdIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books/{id}',\n  methods: [apigwv2.HttpMethod.GET],\n});\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  methods: [apigwv2.HttpMethod.POST],\n  authorizationScopes: ['write:books']\n});\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('LoginIntegration', 'https://get-books-proxy.example.com'),\n  path: '/login',\n  methods: [apigwv2.HttpMethod.POST],\n  authorizer: new apigwv2.HttpNoneAuthorizer(),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing proxy-from-env Package using npm\nDESCRIPTION: This command installs the `proxy-from-env` Node.js package using the Node Package Manager (npm). This package is required to use the `getProxyForUrl` function in a Node.js project. Running this command downloads the package and adds it to the project's dependencies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/proxy-from-env/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install proxy-from-env\n```\n\n----------------------------------------\n\nTITLE: Enabling Encryption on an OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: Shows how to configure an AWS CDK `es.Domain` with both node-to-node encryption and encryption-at-rest enabled. This enhances security by encrypting data in transit between nodes and data stored on disk within the cluster. EBS volume details are also configured.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_4,\n  ebs: {\n    volumeSize: 100,\n    volumeType: ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD,\n  },\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting an Access Policy to Restrict Deletion in a Backup Vault - AWS CDK - TypeScript\nDESCRIPTION: Shows how to apply an access policy to a backup vault that denies all DeleteRecoveryPoint actions except for users with specific user IDs, using the AWS CDK backup and iam modules in TypeScript. The accessPolicy property takes a PolicyDocument with one or more PolicyStatements. This configuration helps restrict destructive operations in backup vaults for regulatory or security reasons.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst vault = new backup.BackupVault(this, 'Vault', {\n  accessPolicy: new iam.PolicyDocument({\n    statements: [\n      new iam.PolicyStatement({\n        effect: iam.Effect.DENY,\n        principals: [new iam.AnyPrincipal()],\n        actions: ['backup:DeleteRecoveryPoint'],\n        resources: ['*'],\n        conditions: {\n          StringNotLike: {\n            'aws:userId': [\n              'user1',\n              'user2',\n            ],\n          },\n        },\n      }),\n    ],\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using CloudFormation Init with Auto Scaling Group in TypeScript\nDESCRIPTION: Creates an AWS Auto Scaling Group configured to use CloudFormation Init for instance setup. It uses `ec2.CloudFormationInit.fromElements` to define initialization tasks (like writing a file) and specifies `autoscaling.Signals.waitForAll` to make CloudFormation wait for instances to signal successful startup before proceeding. The `timeout` for waiting is set to 10 minutes. Dependencies include `ec2.Vpc`, `ec2.InstanceType`, `ec2.IMachineImage`, `Duration`, `ec2` and `autoscaling` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  init: ec2.CloudFormationInit.fromElements(\n    ec2.InitFile.fromString('/etc/my_instance', 'This got written during instance startup'),\n  ),\n  signals: autoscaling.Signals.waitForAll({\n    timeout: Duration.minutes(10),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating AppRunner Service with ECR Public\nDESCRIPTION: Creates an AppRunner service using a public ECR repository as the source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using 'Anything But' Matchers for Exclusion Logic in Event Patterns - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates excluding specific AWS regions, bucket name prefixes, object key suffixes, and requesters using the 'anything but' matchers in an EventBridge rule event pattern. Enables complex filtering via negation and pattern arrays. Utilizes the 'aws-cdk-lib/aws-events' module. Main inputs are lists of excluded regions, prefixes, suffixes, or wildcards.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst rule = new events.Rule(this, 'rule', {\n  eventPattern: {\n    region: events.Match.anythingBut('us-east-1', 'us-east-2', 'us-west-1', 'us-west-2'),\n\n    detail: {\n      bucket: {\n        name: events.Match.anythingButPrefix('foo', 'bar', 'baz'),\n      },\n\n      object: {\n        key: events.Match.anythingButSuffix('.gif', '.png', '.jpg'),\n      },\n\n      requester: events.Match.anythingButWildcard('*.amazonaws.com', '123456789012'),\n    },\n    detailType: events.Match.anythingButEqualsIgnoreCase('object created', 'object deleted'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Response Headers Policy for CloudFront Distribution\nDESCRIPTION: This example demonstrates how to create a custom response headers policy and apply it to a CloudFront distribution. It configures various aspects of response headers behavior including CORS, custom headers, security headers, and server timing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a custom response headers policy -- all parameters optional\nconst myResponseHeadersPolicy = new cloudfront.ResponseHeadersPolicy(this, 'ResponseHeadersPolicy', {\n  responseHeadersPolicyName: 'MyPolicy',\n  comment: 'A default policy',\n  corsBehavior: {\n    accessControlAllowCredentials: false,\n    accessControlAllowHeaders: ['X-Custom-Header-1', 'X-Custom-Header-2'],\n    accessControlAllowMethods: ['GET', 'POST'],\n    accessControlAllowOrigins: ['*'],\n    accessControlExposeHeaders: ['X-Custom-Header-1', 'X-Custom-Header-2'],\n    accessControlMaxAge: Duration.seconds(600),\n    originOverride: true,\n  },\n  customHeadersBehavior: {\n    customHeaders: [\n      { header: 'X-Amz-Date', value: 'some-value', override: true },\n      { header: 'X-Amz-Security-Token', value: 'some-value', override: false },\n    ],\n  },\n  securityHeadersBehavior: {\n    contentSecurityPolicy: { contentSecurityPolicy: 'default-src https:;', override: true },\n    contentTypeOptions: { override: true },\n    frameOptions: { frameOption: cloudfront.HeadersFrameOption.DENY, override: true },\n    referrerPolicy: { referrerPolicy: cloudfront.HeadersReferrerPolicy.NO_REFERRER, override: true },\n    strictTransportSecurity: { accessControlMaxAge: Duration.seconds(600), includeSubdomains: true, override: true },\n    xssProtection: { protection: true, modeBlock: false, reportUri: 'https://example.com/csp-report', override: true },\n  },\n  removeHeaders: ['Server'],\n  serverTimingSamplingRate: 50,\n});\nnew cloudfront.Distribution(this, 'myDistCustomPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    responseHeadersPolicy: myResponseHeadersPolicy,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Synthetics Canary in AWS CDK (TypeScript)\nDESCRIPTION: Defines a CloudWatch Synthetics Canary using the AWS CDK. It configures the canary to run every 5 minutes, specifies the test code location using `Code.fromAsset`, defines the handler function within the code, selects the Node.js Puppeteer runtime, and sets an environment variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  environmentVariables: {\n    stage: 'prod',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project with Predefined Lambda Image in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS CodeBuild project configured for Lambda compute using a predefined image. It uses a constant from `LinuxLambdaBuildImage` representing an Amazon Linux 2 image with Node.js 18.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    buildImage: codebuild.LinuxLambdaBuildImage.AMAZON_LINUX_2_NODE_18,\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Archiving and Replaying EventBridge Events via Event Bus - AWS CDK - TypeScript\nDESCRIPTION: Shows how to enable archiving for events sent to a custom EventBridge event bus using the AWS CDK, allowing for future replaying of those events. Configures archive name, description, event pattern, and retention period. Uses 'aws-cdk-lib/aws-events' and 'aws-cdk-lib'. Inputs include bus name, archive properties, and pattern filters. The output is an archived event bus resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bus = new events.EventBus(this, 'bus', {\n  eventBusName: 'MyCustomEventBus',\n  description: 'MyCustomEventBus',\n});\n\nbus.archive('MyArchive', {\n  archiveName: 'MyCustomEventBusArchive',\n  description: 'MyCustomerEventBus Archive',\n  eventPattern: {\n    account: [Stack.of(this).account],\n  },\n  retention: Duration.days(365),\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Git Branches using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure a pipeline trigger in AWS CDK (TypeScript) based on branch pushes using the pushFilter property. The filter uses 'branchesIncludes' and 'branchesExcludes' to define which branches start the pipeline; excludes take precedence. It requires codepipeline and codepipeline_actions, a sourceAction and buildAction, and sets pipelineType to V2. Only pushes to branches matching 'branchesIncludes' and not matching 'branchesExcludes' will trigger the pipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pushFilter: [{\n        branchesExcludes: ['exclude1', 'exclude2'],\n        branchesIncludes: ['include*'],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Auto Scaling Lambda Provisioned Concurrency in TypeScript\nDESCRIPTION: This example demonstrates configuring autoscaling for AWS Lambda provisioned concurrency. It defines a Lambda function, retrieves its specific version, and then creates a `ScalableTarget` referencing this function version. Finally, it applies target tracking scaling using `scaleToTrackMetric` to maintain the `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION` metric at 90%.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const code: lambda.Code;\n\nconst handler = new lambda.Function(this, 'MyFunction', {\n  runtime: lambda.Runtime.PYTHON_3_12,\n  handler: 'index.handler',\n  code,\n\n  reservedConcurrentExecutions: 2,\n});\n\nconst fnVer = handler.currentVersion;\n\nconst target = new appscaling.ScalableTarget(this, 'ScalableTarget', {\n  serviceNamespace: appscaling.ServiceNamespace.LAMBDA,\n  maxCapacity: 100,\n  minCapacity: 10,\n  resourceId: `function:${handler.functionName}:${fnVer.version}`,\n  scalableDimension: 'lambda:function:ProvisionedConcurrency',\n})\n\ntarget.scaleToTrackMetric('PceTracking', {\n  targetValue: 0.9,\n  predefinedMetric: appscaling.PredefinedMetric.LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling AWS Backup Vault Lock with Minimum Retention - AWS CDK - TypeScript\nDESCRIPTION: Shows how to enable AWS Backup Vault Lock with a minimum retention period, using the lockConfiguration property of BackupVault in the AWS CDK in TypeScript. The value minRetention: Duration.days(30) ensures that recovery points cannot be deleted for at least 30 days. Useful for regulatory compliance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew backup.BackupVault(this, 'Vault', {\n  lockConfiguration: {\n    minRetention: Duration.days(30),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset Bundling with Exclude Filters in S3 Bucket Deployment\nDESCRIPTION: Demonstrates how to exclude files during the asset bundling process using the exclude property of AssetOptions when defining a source for S3 bucket deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\nnew s3deploy.BucketDeployment(this, 'HTMLBucketDeployment', {\n  sources: [s3deploy.Source.asset('./website', { exclude: ['*', '!index.html'] })],\n  destinationBucket,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling VPC Access for CodeBuild Project and Granting Network Permissions (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure an AWS CodeBuild project to run within a specified VPC using the AWS CDK. It assigns the `vpc` property during project creation. Additionally, it shows how to grant the CodeBuild project's security group network access to another resource (an Application Load Balancer in this case) on a specific port (TCP 443) using the `project.connections.allowTo` method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const loadBalancer: elbv2.ApplicationLoadBalancer;\n\nconst vpc = new ec2.Vpc(this, 'MyVPC');\nconst project = new codebuild.Project(this, 'MyProject', {\n  vpc: vpc,\n  buildSpec: codebuild.BuildSpec.fromObject({\n    // ...\n  }),\n});\n\nproject.connections.allowTo(loadBalancer, ec2.Port.tcp(443));\n```\n\n----------------------------------------\n\nTITLE: Scaling Auto Scaling Group based on CPU Utilization in TypeScript\nDESCRIPTION: Configures target tracking scaling for an AWS Auto Scaling Group to maintain an average CPU utilization across all instances around a specified percentage. This policy automatically adjusts the number of instances to keep the average CPU close to the `targetUtilizationPercent`. Requires an existing `autoscaling.AutoScalingGroup` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.scaleOnCpuUtilization('KeepSpareCPU', {\n  targetUtilizationPercent: 50\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Scheduled Fargate Task with aws-cdk ECS Patterns (TypeScript)\nDESCRIPTION: Shows creating a ScheduledFargateTask construct to run periodic container tasks on AWS Fargate using an ECS cluster. Parameters configure the task image, memory, scheduling frequency, and Fargate platform version. Requires aws-cdk ECS Patterns and Application Auto Scaling libraries.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst scheduledFargateTask = new ecsPatterns.ScheduledFargateTask(this, 'ScheduledFargateTask', {\n  cluster,\n  scheduledFargateTaskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    memoryLimitMiB: 512,\n  },\n  schedule: appscaling.Schedule.expression('rate(1 minute)'),\n  platformVersion: ecs.FargatePlatformVersion.LATEST,\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching a Lambda@Edge Function to CloudFront Default Behavior using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to create a Lambda@Edge function using the `cloudfront.experimental.EdgeFunction` construct and attach it to the default behavior of a CloudFront distribution. The example specifies the Node.js runtime, handler, code location, and associates the function's current version with the `VIEWER_REQUEST` event type for an S3 origin. The `EdgeFunction` construct automatically creates the Lambda in the required `us-east-1` region.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// A Lambda@Edge function added to default behavior of a Distribution\n// and triggered on every request\nconst myFunc = new cloudfront.experimental.EdgeFunction(this, 'MyFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n});\n\ndeclare const myBucket: s3.Bucket;\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(myBucket),\n    edgeLambdas: [\n      {\n        functionVersion: myFunc.currentVersion,\n        eventType: cloudfront.LambdaEdgeEventType.VIEWER_REQUEST,\n      }\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking a Lambda Function via a CloudWatch Alarm Action (TypeScript)\nDESCRIPTION: This snippet illustrates how to trigger an AWS Lambda function, alias, or specific version when a CloudWatch alarm enters the ALARM state. It utilizes the `LambdaAction` class from the `aws-cdk-lib/aws-cloudwatch-actions` module, passing a reference to a `lambda.Function`, `lambda.Alias`, or `lambda.Version` object. The action is attached to the `cloudwatch.Alarm` using `addAlarmAction`. Dependencies include `aws-cdk-lib/aws-lambda` and `aws-cdk-lib/aws-cloudwatch`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch-actions/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda'\ndeclare const alarm: cloudwatch.Alarm;\ndeclare const fn: lambda.Function;\ndeclare const alias: lambda.Alias;\ndeclare const version: lambda.Version;\n\n// Attach a Lambda Function when alarm triggers\nalarm.addAlarmAction(\n  new actions.LambdaAction(fn)\n);\n\n// Attach a Lambda Function Alias when alarm triggers\nalarm.addAlarmAction(\n  new actions.LambdaAction(alias)\n);\n\n// Attach a Lambda Function version when alarm triggers\nalarm.addAlarmAction(\n  new actions.LambdaAction(version)\n);\n\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon MSK Event Source for Lambda\nDESCRIPTION: Sets up Amazon MSK as an event source for a Lambda function using CDK. Includes authentication via Secrets Manager and basic configuration options like batch size and starting position.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Secret } from 'aws-cdk-lib/aws-secretsmanager';\nimport { ManagedKafkaEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\n// Your MSK cluster arn\nconst clusterArn = 'arn:aws:kafka:us-east-1:0123456789019:cluster/SalesCluster/abcd1234-abcd-cafe-abab-9876543210ab-4';\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\n// The secret that allows access to your MSK cluster\n// You still have to make sure that it is associated with your cluster as described in the documentation\nconst secret = new Secret(this, 'Secret', { secretName: 'AmazonMSK_KafkaSecret' });\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new ManagedKafkaEventSource({\n  clusterArn,\n  topic: topic,\n  secret: secret,\n  batchSize: 100, // default\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n}));\n```\n\n----------------------------------------\n\nTITLE: Importing DynamoDB Table Data from S3 in DynamoDB JSON Format Using AWS CDK - TypeScript\nDESCRIPTION: Describes importing data into a DynamoDB table from S3 when the data is in DynamoDB JSON format using AWS CDK in TypeScript. The code specifies 'inputFormat' as 'dynamoDBJson()', with no additional options, and configures the table for import at creation. Requires S3 bucket reference, partition key configuration, gzip compression, and prefix for locating import files. Output is a DynamoDB table with the given import behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_39\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack');\n\ndeclare const bucket: s3.IBucket;\n\nnew dynamodb.Table(stack, 'Table', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n  importSource: {\n    compressionType: dynamodb.InputCompressionType.GZIP,\n    inputFormat: dynamodb.InputFormat.dynamoDBJson(),\n    bucket,\n    keyPrefix: 'prefix',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Origin Request Policy for CloudFront Distribution\nDESCRIPTION: This example shows how to create a custom origin request policy and apply it to a CloudFront distribution. It configures various aspects of origin request behavior including cookie forwarding, header forwarding, and query string forwarding.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a custom origin request policy for a Distribution -- all parameters optional\ndeclare const bucketOrigin: origins.S3Origin;\nconst myOriginRequestPolicy = new cloudfront.OriginRequestPolicy(this, 'OriginRequestPolicy', {\n  originRequestPolicyName: 'MyPolicy',\n  comment: 'A default policy',\n  cookieBehavior: cloudfront.OriginRequestCookieBehavior.none(),\n  headerBehavior: cloudfront.OriginRequestHeaderBehavior.all('CloudFront-Is-Android-Viewer'),\n  queryStringBehavior: cloudfront.OriginRequestQueryStringBehavior.allowList('username'),\n});\n\nnew cloudfront.Distribution(this, 'myDistCustomPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    originRequestPolicy: myOriginRequestPolicy,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB TableV2 Encryption with Customer Managed Keys in TypeScript\nDESCRIPTION: This snippet illustrates configuring a DynamoDB Global TableV2 instance with customer managed KMS keys. It requires creating a primary KMS key (`tableKey`) and providing a map (`replicaKeyArns`) of pre-existing KMS key ARNs for each replica region. The `encryption` property uses `dynamodb.TableEncryptionV2.customerManagedKey()` with the primary key and replica key map. Dependencies include `aws-cdk-lib` and `aws-cdk-lib/aws-kms`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst tableKey = new kms.Key(stack, 'Key');\nconst replicaKeyArns = {\n  'us-east-1': 'arn:aws:kms:us-east-1:123456789012:key/g24efbna-az9b-42ro-m3bp-cq249l94fca6',\n  'us-east-2': 'arn:aws:kms:us-east-2:123456789012:key/h90bkasj-bs1j-92wp-s2ka-bh857d60bkj8',\n};\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryptionV2.customerManagedKey(tableKey, replicaKeyArns),\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Custom Local Asset Bundler in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to implement a custom local bundler by defining a class that implements the ILocalBundling interface, providing the tryBundle method to attempt local asset packaging. If local bundling is not possible, CDK falls back to Docker bundling using a specified container image and command. The Asset construct is configured with both options for maximum flexibility and performance. Required dependencies include aws-cdk-lib, properly configured Docker or local build tools, and a valid asset source path. Main parameters are path (asset location) and bundling (configuration for local/Docker bundler). The construct can fall back to Docker-based bundling if tryBundle returns false.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-assets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nclass MyBundle implements cdk.ILocalBundling {\n  public tryBundle(outputDir: string, options: cdk.BundlingOptions) {\n    const canRunLocally = true // replace with actual logic\n    if (canRunLocally) {\n      // perform local bundling here\n      return true;\n    }\n    return false; \n  }\n}\n\nnew Asset(this, 'BundledAsset', {\n  path: '/path/to/asset',\n  bundling: {\n    local: new MyBundle(),\n    // Docker bundling fallback\n    image: cdk.DockerImage.fromRegistry('alpine'),\n    entrypoint: ['/bin/sh', '-c'],\n    command: ['bundle'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Amazon Data Firehose Delivery Stream to S3 using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a new S3 bucket and a Firehose delivery stream that uses the S3 bucket as its destination. The Firehose delivery stream has Direct PUT as its source and has CloudWatch error logging enabled by default. The CDK automatically creates the requisite IAM role for permissions. Required dependencies: aws-cdk-lib, @aws-cdk/aws-s3, and @aws-cdk/aws-kinesisfirehose. Inputs: implicitly provides a newly created S3 bucket. Outputs: a Firehose stream with S3 destination. No additional configuration (e.g., custom prefix, encryption) is included in this example.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bucket = new s3.Bucket(this, 'Bucket');\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: new firehose.S3Bucket(bucket),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SQS Queue Event Source for Lambda Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Lambda function with an SQS queue as an event source. It shows the basic configuration and how to access the event source mapping ID and ARN after creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SqsEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\ndeclare const fn: lambda.Function;\nconst queue = new sqs.Queue(this, 'MyQueue');\nconst eventSource = new SqsEventSource(queue);\nfn.addEventSource(eventSource);\n\nconst eventSourceId = eventSource.eventSourceMappingId;\nconst eventSourceMappingArn = eventSource.eventSourceMappingArn;\n```\n\n----------------------------------------\n\nTITLE: Enabling VPN Gateway for VPC using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable a VPN gateway for a VPC using AWS CDK. It creates a VPC, enables a VPN gateway with route propagation, and sets up a route table with a route targeting the VPN gateway.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\nconst vpnGateway = myVpc.enableVpnGatewayV2({\n  vpnRoutePropagation: [{ subnetType: SubnetType.PUBLIC }],\n  type: VpnConnectionType.IPSEC_1,\n});\n\nconst routeTable = new RouteTable(stack, 'routeTable', { \n  vpc: myVpc \n  } );\n\nnew Route(stack, 'route', {\n  destination: '172.31.0.0/24',\n  target: { gateway: vpnGateway },\n  routeTable: routeTable,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up S3 Bucket Event Source for Lambda in TypeScript\nDESCRIPTION: This code demonstrates how to configure an S3 bucket to trigger a Lambda function when objects are created or removed. It includes filtering options to only process events from a specific directory prefix.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport { S3EventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\nconst bucket = new s3.Bucket(this, 'mybucket');\ndeclare const fn: lambda.Function;\n\nfn.addEventSource(new S3EventSource(bucket, {\n  events: [ s3.EventType.OBJECT_CREATED, s3.EventType.OBJECT_REMOVED ],\n  filters: [ { prefix: 'subdir/' } ], // optional\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding an AlarmStatusWidget for Alarm State Aggregation (TypeScript)\nDESCRIPTION: Shows how to add an AlarmStatusWidget to a dashboard to display the state of one or more alarms. Requires Dashboard and Alarm objects. Aggregates alarms in a compact surface for fast at-a-glance status visibility.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const errorAlarm: cloudwatch.Alarm;\n\ndashboard.addWidgets(\n  new cloudwatch.AlarmStatusWidget({\n    alarms: [errorAlarm],\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Case-Insensitive Event Match Patterns for Object Events - AWS CDK - TypeScript\nDESCRIPTION: Shows use of case-insensitive matchers to filter events based on bucket name, object key patterns, and requester domain, as well as on the event type text. This allows for comprehensive event pattern definitions using prefix/suffix and wildcards with case insensitivity. Relies on 'aws-cdk-lib/aws-events'. The rule is constructed for fine-grained filtering of S3 object creation events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst rule = new events.Rule(this, 'rule', {\n  eventPattern: {\n    detail: {\n      bucket: {\n        name: events.Match.prefixEqualsIgnoreCase('raw-'),\n      },\n\n      object: {\n        key: events.Match.wildcard('path/to/object/*.txt'),\n      },\n\n      requester: events.Match.suffixEqualsIgnoreCase('.AMAZONAWS.COM'),\n    },\n    detailType: events.Match.equalsIgnoreCase('object created'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Release Version and Type in JSON\nDESCRIPTION: This JSON structure in release.json defines the major version and release type for the current branch. It's used to determine how releases are cut and manage version lines.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/release.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"majorVersion\": 1 | 2,\n  \"releaseType\": \"stable\" | \"alpha\" | \"rc\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 OAC Access Levels for CloudFront Origins - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to apply specific access levels (read, read versioned, write, delete) to a CloudFront S3 origin when using OAC with the AWS CDK. The originAccessLevels property customizes access granted to the Distribution. Requires proper imports of aws-cdk-lib, s3, cloudfront, and origins modules. Ensure both READ and READ_VERSIONED are set for versioned read permissions. Output is a customized S3 origin object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst s3Origin = origins.S3BucketOrigin.withOriginAccessControl(myBucket, { originAccessLevels: [cloudfront.AccessLevel.READ, cloudfront.AccessLevel.READ_VERSIONED, cloudfront.AccessLevel.WRITE, cloudfront.AccessLevel.DELETE],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Dynamic Prefixes for S3 Firehose Destination (TypeScript)\nDESCRIPTION: This snippet illustrates how to customize the output and error prefixes for a Firehose delivery stream's S3 bucket destination using dataOutputPrefix and errorOutputPrefix options. This enables dynamic partitioning and organization of output (such as by year or error type). Dependencies: @aws-cdk/aws-kinesisfirehose, @aws-cdk/aws-s3. Inputs: S3 bucket, specified prefix patterns. Output: Firehose with an S3 destination writing files with custom prefixes. Requires familiarity with S3 object key syntax used by Firehose.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst s3Destination = new firehose.S3Bucket(bucket, {\n  dataOutputPrefix: 'myFirehose/DeliveredYear=!{timestamp:yyyy}/anyMonth/rand=!{firehose:random-string}',\n  errorOutputPrefix: 'myFirehoseFailures/!{firehose:error-output-type}/!{timestamp:yyyy}/anyMonth/!{timestamp:dd}',\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Amazon SES for UserPool Email Delivery - AWS CDK - TypeScript\nDESCRIPTION: Enables sending Cognito UserPool emails using Amazon SES for higher deliverability, custom 'from' and 'replyTo' addresses, and sender name. Prerequisites: SES must be verified and out of sandbox, Cognito authorized for SES. Key input parameters are 'fromEmail', 'fromName', and 'replyTo'. Output is customized email delivery for UserPool via SES.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  email: cognito.UserPoolEmail.withSES({\n    fromEmail: 'noreply@myawesomeapp.com',\n    fromName: 'Awesome App',\n    replyTo: 'support@myawesomeapp.com',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up CloudWatch Event Rules\nDESCRIPTION: Configures CloudWatch event rules for repository events with Lambda function target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst repo = new ecr.Repository(this, 'Repo');\nconst lambdaHandler = new lambda.Function(this, 'LambdaFunction', {\n  runtime: lambda.Runtime.PYTHON_3_12,\n  code: lambda.Code.fromInline('# dummy func'),\n  handler: 'index.handler',\n});\n\nrepo.onEvent('OnEventTargetLambda', {\n  target: new LambdaFunction(lambdaHandler),\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning SSM String and StringList Parameters with Access Control - AWS CDK - TypeScript\nDESCRIPTION: This code creates both a StringParameter and a StringListParameter in AWS SSM using CDK. It also demonstrates granting read access to an IAM role for the StringParameter. The snippet requires the ssm and iam modules and proper permissions. Inputs are string/lists of values, parameter names, and/or descriptions, and the code outputs provisioned SSM parameter resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a new SSM Parameter holding a String\nconst param = new ssm.StringParameter(this, 'StringParameter', {\n  // description: 'Some user-friendly description',\n  // name: 'ParameterName',\n  stringValue: 'Initial parameter value',\n  // allowedPattern: '.*',\n});\n\n// Grant read access to some Role\ndeclare const role: iam.IRole;\nparam.grantRead(role);\n\n// Create a new SSM Parameter holding a StringList\nconst listParameter = new ssm.StringListParameter(this, 'StringListParameter', {\n  // description: 'Some user-friendly description',\n  // name: 'ParameterName',\n  stringListValue: ['Initial parameter value A', 'Initial parameter value B'],\n  // allowedPattern: '.*',\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking Lambda Function with EventBridge - TypeScript\nDESCRIPTION: This snippet creates an AWS Lambda function and sets it as an Amazon EventBridge rule target using the AWS CDK in TypeScript. It optionally attaches an SQS dead-letter queue and configures retry policies, such as maxEventAge and retryAttempts. Required dependencies include aws-cdk-lib/aws-lambda (for the function), aws-cdk-lib/aws-events (for the rule), aws-cdk-lib/aws-sqs (for the queue), and cdk.Duration. The EventBridge rule triggers the Lambda for events with a source of 'aws.ec2'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst fn = new lambda.Function(this, 'MyFunc', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromInline(`exports.handler = handler.toString()`),\n});\n\nconst rule = new events.Rule(this, 'rule', {\n  eventPattern: {\n    source: [\"aws.ec2\"],\n  },\n});\n\nconst queue = new sqs.Queue(this, 'Queue');\n\nrule.addTarget(new targets.LambdaFunction(fn, {\n  deadLetterQueue: queue, // Optional: add a dead letter queue\n  maxEventAge: Duration.hours(2), // Optional: set the maxEventAge retry policy\n  retryAttempts: 2, // Optional: set the max number of retry attempts\n}));\n```\n\n----------------------------------------\n\nTITLE: Installing Helm Charts using AWS CDK EKS Module (TypeScript)\nDESCRIPTION: Illustrates installing the NGINX Ingress Controller Helm chart onto an EKS cluster using AWS CDK. It presents two equivalent approaches: instantiating `eks.HelmChart` directly or using the `cluster.addHelmChart` method. Both require specifying the cluster, chart name, repository URL, and target namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n// option 1: use a construct\nnew eks.HelmChart(this, 'NginxIngress', {\n  cluster,\n  chart: 'nginx-ingress',\n  repository: 'https://helm.nginx.com/stable',\n  namespace: 'kube-system',\n});\n\n// or, option2: use `addHelmChart`\ncluster.addHelmChart('NginxIngress', {\n  chart: 'nginx-ingress',\n  repository: 'https://helm.nginx.com/stable',\n  namespace: 'kube-system',\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Policy to TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a resource policy to a DynamoDB table using the TableV2 construct, including creating a policy document and applying it to the table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n    // resource policy document\n    const policy = new iam.PolicyDocument({\n      statements: [\n        new iam.PolicyStatement({\n          actions: ['dynamodb:GetItem'],\n          principals: [new iam.AccountRootPrincipal()],\n          resources: ['*'],\n        }),\n      ],\n    });\n\n    // table with resource policy\n    new dynamodb.TableV2(this, 'TableTestV2-1', {\n      partitionKey: {\n        name: 'id',\n        type: dynamodb.AttributeType.STRING,\n      },\n      removalPolicy: RemovalPolicy.DESTROY,\n      resourcePolicy: policy,\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual-Stack Network Load Balancers for ECS Services in TypeScript\nDESCRIPTION: This TypeScript code shows how to set up AWS Network Load Balancers (NLBs) with dual-stack IP addressing for ECS Fargate and EC2 services via the AWS CDK `ecsPatterns`. It necessitates a VPC configured with `ec2.IpProtocol.DUAL_STACK` and explicitly sets the `ipAddressType` parameter to `elbv2.IpAddressType.DUAL_STACK` when defining the `NetworkLoadBalancedFargateService` and `NetworkLoadBalancedEc2Service`. Dependencies include `aws-cdk-lib/aws-ec2`, `aws-cdk-lib/aws-ecs`, `aws-cdk-lib/aws-ecs-patterns`, and `aws-cdk-lib/aws-elasticloadbalancingv2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_32\n\nLANGUAGE: ts\nCODE:\n```\nimport * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\n// The VPC and subnet must have associated IPv6 CIDR blocks.\nconst vpc = new ec2.Vpc(this, 'Vpc', {\n  ipProtocol: ec2.IpProtocol.DUAL_STACK,\n});\nconst cluster = new ecs.Cluster(this, 'EcsCluster', { vpc });\n\nconst networkLoadbalancedFargateService = new ecsPatterns.NetworkLoadBalancedFargateService(this, 'NlbFargateService', {\n  cluster,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  },\n  minHealthyPercent: 100,\n  ipAddressType: elbv2.IpAddressType.DUAL_STACK,\n});\n\nconst networkLoadbalancedEc2Service = new ecsPatterns.NetworkLoadBalancedEc2Service(this, 'NlbEc2Service', {\n  cluster,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  },\n  minHealthyPercent: 100,\n  ipAddressType: elbv2.IpAddressType.DUAL_STACK,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom 'From' Address for Cognito UserPool Emails with Cognito Provider - AWS CDK - TypeScript\nDESCRIPTION: Configures the UserPool to use a custom sender email address for outgoing messages, leveraging Cognito's built-in email capability. Requires Cognito CDK module. Uses 'UserPoolEmail.withCognito' to specify a custom 'from' address. Input is the email address string; output is a configured UserPool email sender.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  email: cognito.UserPoolEmail.withCognito('support@myawesomeapp.com'),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Resource Policy to a DynamoDB Table in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to attach a resource-based policy to an AWS DynamoDB table using AWS CDK. It defines an `iam.PolicyDocument` allowing `dynamodb:GetItem` actions for the account root principal and assigns it to the `resourcePolicy` property of the table. Note that global table replicas do not support resource policies. Dependencies include `@aws-cdk/aws-dynamodb`, `@aws-cdk/aws-iam`, and `@aws-cdk/core` (for `RemovalPolicy`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst policy = new iam.PolicyDocument({\n  statements: [\n    new iam.PolicyStatement({\n      actions: ['dynamodb:GetItem'],\n      principals: [new iam.AccountRootPrincipal()],\n      resources: ['*'],\n    }),\n  ],\n});\n\nnew dynamodb.Table(this, 'MyTable', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n  removalPolicy: RemovalPolicy.DESTROY,\n  resourcePolicy: policy,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Generic IAM Permissions for AppSync Operations in TypeScript\nDESCRIPTION: This TypeScript CDK snippet illustrates alternative ways to grant IAM permissions using generic helper methods. `api.grantMutation` grants access to a specific mutation field (`updateExample`). `api.grant` with `IamResource.ofType` achieves the same granular permission for the 'Mutation' type's 'updateExample' field.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.IGraphqlApi;\ndeclare const role: iam.Role;\n\n// For generic types\napi.grantMutation(role, 'updateExample');\n\n// For custom types and granular design\napi.grant(role, appsync.IamResource.ofType('Mutation', 'updateExample'), 'appsync:GraphQL');\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Replica Properties\nDESCRIPTION: Shows how to configure different properties for each replica in a global DynamoDB table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  contributorInsights: true,\n  pointInTimeRecoverySpecification: {\n      pointInTimeRecoveryEnabled: true,\n  },\n  replicas: [\n    {\n      region: 'us-east-1',\n      tableClass: dynamodb.TableClass.STANDARD_INFREQUENT_ACCESS,\n      pointInTimeRecoverySpecification: {\n        pointInTimeRecoveryEnabled: false,\n      },\n    },\n    {\n      region: 'us-east-2',\n      contributorInsights: false,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Opting Out of CDK Automatic Role Policy Updates - AWS CDK - TypeScript\nDESCRIPTION: This snippet outlines how to prevent AWS CDK constructs from automatically updating an IAM Role's policy. It shows constructing a role and passing an immutable version of that role (via withoutPolicyUpdates) to another CDK construct (codepipeline.Pipeline). Developers must then manually manage policies using addToPolicy. It requires the iam and codepipeline modules and is especially useful for gaining fine-grained control over permissions or reducing policy size.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('codepipeline.amazonaws.com'),\n  // custom description if desired\n  description: 'This is a custom role...',\n});\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  // Give the Pipeline an immutable view of the Role\n  role: role.withoutPolicyUpdates(),\n});\n\n// You now have to manage the Role policies yourself\nrole.addToPolicy(new iam.PolicyStatement({\n  actions: [/* whatever actions you want */],\n  resources: [/* whatever resources you intend to touch */],\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from Lambda Function URL with Default OAC using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates setting up a CloudFront distribution with a Lambda Function URL origin secured by Origin Access Control (OAC). The Lambda Function URL is configured with IAM authentication (`authType: lambda.FunctionUrlAuthType.AWS_IAM`). The `origins.FunctionUrlOrigin.withOriginAccessControl` helper method is used to automatically create and configure the necessary OAC settings for SigV4 signing. Requires `aws-cdk-lib/aws-lambda`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\ndeclare const fn: lambda.Function;\n\nconst fnUrl = fn.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.AWS_IAM,\n});\n\nnew cloudfront.Distribution(this, 'MyDistribution', {\n  defaultBehavior: {\n    origin: origins.FunctionUrlOrigin.withOriginAccessControl(fnUrl),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Firewall Rule Groups in TypeScript\nDESCRIPTION: Shows how to create a firewall rule group with initial rules, add rules to an existing group, and associate a rule group with a VPC. It demonstrates various actions including blocking and custom DNS responses.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-route53resolver-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew route53resolver.FirewallRuleGroup(this, 'RuleGroup', {\n  rules: [\n    {\n      priority: 10,\n      firewallDomainList: myBlockList,\n      // block and reply with NODATA\n      action: route53resolver.FirewallRuleAction.block(),\n    },\n  ],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nruleGroup.addRule({\n  priority: 10,\n  firewallDomainList: myBlockList,\n  // block and reply with NXDOMAIN\n  action: route53resolver.FirewallRuleAction.block(route53resolver.DnsBlockResponse.nxDomain()),\n});\n\nruleGroup.addRule({\n  priority: 20,\n  firewallDomainList: myBlockList,\n  // block and override DNS response with a custom domain\n  action: route53resolver.FirewallRuleAction.block(route53resolver.DnsBlockResponse.override('amazon.com')),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\nruleGroup.associate('Association', {\n  priority: 101,\n  vpc: myVpc,\n})\n```\n\n----------------------------------------\n\nTITLE: Splitting HTTP Route Traffic Between Targets - AWS App Mesh - TypeScript\nDESCRIPTION: This code demonstrates splitting traffic evenly between two virtual nodes on an HTTP route using weightedTargets. Each node is set to weight 50, distributing requests in a 50/50 ratio. The route matches based on a specific path prefix. Dependencies include AWS CDK and AWS App Mesh libraries, as well as declared router and node objects. Inputs are the list of weighted targets and the path to match. Output is an HTTP route with balanced traffic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-http', {\n  routeSpec: appmesh.RouteSpec.http({\n    weightedTargets: [\n      {\n        virtualNode: node,\n        weight: 50,\n      },\n      {\n        virtualNode: node,\n        weight: 50,\n      },\n    ],\n    match: {\n      path: appmesh.HttpRoutePathMatch.startsWith('/path-to-app'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering CodeBuild Project via EventBridge Rule - TypeScript\nDESCRIPTION: This code sets up a CodeCommit repository and CodeBuild project, then creates an EventBridge rule to trigger a build when a commit occurs on the 'master' branch, using AWS CDK in TypeScript. The rule attaches the CodeBuildProject as the target and optionally configures a dead-letter queue for failures. Requires aws-cdk-lib/aws-codebuild, aws-cdk-lib/aws-codecommit, aws-cdk-lib/aws-sqs, and aws-cdk-lib/aws-events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codebuild from 'aws-cdk-lib/aws-codebuild';\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\n\nconst repo = new codecommit.Repository(this, 'MyRepo', {\n  repositoryName: 'aws-cdk-codebuild-events',\n});\n\nconst project = new codebuild.Project(this, 'MyProject', {\n  source: codebuild.Source.codeCommit({ repository: repo }),\n});\n\nconst deadLetterQueue = new sqs.Queue(this, 'DeadLetterQueue');\n\n// trigger a build when a commit is pushed to the repo\nconst onCommitRule = repo.onCommit('OnCommit', {\n  target: new targets.CodeBuildProject(project, {\n    deadLetterQueue: deadLetterQueue,\n  }),\n  branches: ['master'],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Pipeline-level Variables - AWS CodePipeline - TypeScript\nDESCRIPTION: Exemplifies the definition and usage of pipeline-level variables in CodePipeline V2 pipelines. These variables are configured at pipeline creation, can provide default values and descriptions, and are resolved at runtime. Restrictions apply: pipeline-level variables cannot be referenced from Source actions, and only V2 pipeline types support this feature. Key parameters include the variables array and pipeline type declaration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.S3SourceAction;\ndeclare const sourceOutput: codepipeline.Artifact;\ndeclare const deployBucket: s3.Bucket;\n\n// Pipeline-level variable\nconst variable = new codepipeline.Variable({\n  variableName: 'bucket-var',\n  description: 'description',\n  defaultValue: 'sample',\n});\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  variables: [variable],\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Deploy',\n      actions: [\n        new codepipeline_actions.S3DeployAction({\n          actionName: 'DeployAction',\n          // can reference the variables\n          objectKey: `${variable.reference()}.txt`,\n          input: sourceOutput,\n          bucket: deployBucket,\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring esbuild Options for NodejsFunction in TypeScript\nDESCRIPTION: This snippet demonstrates how to set various esbuild options for a NodejsFunction, including minification, source maps, target environment, loaders, and more.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    minify: true, // minify code, defaults to false\n    sourceMap: true, // include source map, defaults to false\n    sourceMapMode: nodejs.SourceMapMode.INLINE, // defaults to SourceMapMode.DEFAULT\n    sourcesContent: false, // do not include original source into source map, defaults to true\n    target: 'es2020', // target environment for the generated JavaScript code\n    loader: { // Use the 'dataurl' loader for '.png' files\n      '.png': 'dataurl',\n    },\n    define: { // Replace strings during build time\n      'process.env.API_KEY': JSON.stringify('xxx-xxxx-xxx'),\n      'process.env.PRODUCTION': JSON.stringify(true),\n      'process.env.NUMBER': JSON.stringify(123),\n    },\n    logLevel: nodejs.LogLevel.ERROR, // defaults to LogLevel.WARNING\n    keepNames: true, // defaults to false\n    tsconfig: 'custom-tsconfig.json', // use custom-tsconfig.json instead of default,\n    metafile: true, // include meta file, defaults to false\n    banner: '/* comments */', // requires esbuild >= 0.9.0, defaults to none\n    footer: '/* comments */', // requires esbuild >= 0.9.0, defaults to none\n    charset: nodejs.Charset.UTF8, // do not escape non-ASCII characters, defaults to Charset.ASCII\n    format: nodejs.OutputFormat.ESM, // ECMAScript module output format, defaults to OutputFormat.CJS (OutputFormat.ESM requires Node.js >= 14)\n    mainFields: ['module', 'main'], // prefer ECMAScript versions of dependencies\n    inject: ['./my-shim.js', './other-shim.js'], // allows to automatically replace a global variable with an import from another file\n    esbuildArgs: { // Pass additional arguments to esbuild\n      \"--log-limit\": \"0\",\n      \"--splitting\": true,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Resource Policies using addToResourcePolicy in AWS CDK\nDESCRIPTION: This snippet demonstrates how to create resource policies for a Kinesis stream and a stream consumer using the addToResourcePolicy method. It shows how to grant permissions for specific actions to any principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = new kinesis.Stream(this, 'MyStream');\nconst streamConsumer = new kinesis.StreamConsumer(this, 'MyStreamConsumer', {\n  streamConsumerName: 'MyStreamConsumer',\n  stream,\n});\n\n// create a stream resource policy via addToResourcePolicy method\nstream.addToResourcePolicy(new iam.PolicyStatement({\n  resources: [stream.streamArn],\n  actions: ['kinesis:GetRecords'],\n  principals: [new iam.AnyPrincipal()],\n}));\n\n// create a stream consumer resource policy via addToResourcePolicy method\nstreamConsumer.addToResourcePolicy(new iam.PolicyStatement({\n  resources: [stream.streamArn],\n  actions: ['kinesis:DescribeStreamConsumer'],\n  principals: [new iam.AnyPrincipal()],\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining an OpenID Connect Provider in AWS CDK (TypeScript)\nDESCRIPTION: Creates an OpenID Connect provider (OIDC IdP) using AWS CDK's `iam.OpenIdConnectProvider` construct. This is typically used to trust external OIDC-compatible identity providers for authentication, for example in web or mobile applications. Requires the AWS CDK IAM module. Key parameters include the OIDC issuer URL and an array of client IDs (audiences); outputs an OIDC provider resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst provider = new iam.OpenIdConnectProvider(this, 'MyProvider', {\\n  url: 'https://openid/connect',\\n  clientIds: [ 'myclient1', 'myclient2' ],\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring OAuth 2.0 Settings for a Cognito App Client in TypeScript\nDESCRIPTION: This snippet configures OAuth 2.0 for an AWS Cognito App Client using AWS CDK. It enables the Authorization Code Grant flow, specifies the 'openid' scope, and defines callback and logout URLs required for the OAuth flow.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  oAuth: {\n    flows: {\n      authorizationCodeGrant: true,\n    },\n    scopes: [ cognito.OAuthScope.OPENID ],\n    callbackUrls: [ 'https://my-app-domain.com/welcome' ],\n    logoutUrls: [ 'https://my-app-domain.com/signin' ],\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding File Extension and S3 Compression for Firehose Delivery (TypeScript)\nDESCRIPTION: This code shows how to set the compression type for S3 output and override the default file extension for a Firehose S3 destination using the AWS CDK. Compression is set to GZIP, and files are saved with a '.json.gz' extension. Dependencies: @aws-cdk/aws-kinesisfirehose, @aws-cdk/aws-s3. Inputs: S3 bucket and optional parameters for compression and file extension. Output: Firehose that delivers compressed files with a defined extension.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst s3Destination = new firehose.S3Bucket(bucket, {\n  compression: firehose.Compression.GZIP,\n  fileExtension: '.json.gz',\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate with Multi-Zone DNS Validation - AWS CDK - TypeScript\nDESCRIPTION: This snippet provisions an ACM certificate for multiple domains validated via DNS across multiple Route 53 hosted zones using CDK. It demonstrates how to use CertificateValidation.fromDnsMultiZone for complex domain setups. Inputs include domain names, SANs, and a mapping of domains to hosted zones; outputs are a multi-domain, multi-zone DNS-validated certificate. Dependencies: aws-cdk-lib/aws-certificatemanager, aws-cdk-lib/aws-route53.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst exampleCom = new route53.HostedZone(this, 'ExampleCom', {\n  zoneName: 'example.com',\n});\nconst exampleNet = new route53.HostedZone(this, 'ExampleNet', {\n  zoneName: 'example.net',\n});\n\nconst cert = new acm.Certificate(this, 'Certificate', {\n  domainName: 'test.example.com',\n  subjectAlternativeNames: ['cool.example.com', 'test.example.net'],\n  validation: acm.CertificateValidation.fromDnsMultiZone({\n    'test.example.com': exampleCom,\n    'cool.example.com': exampleCom,\n    'test.example.net': exampleNet,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Authorization Types for AWS AppSync Event API in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure multiple authorization types (IAM, API Key, and Lambda) for an AWS AppSync Event API. It sets different authorization modes for connection, publishing, and subscribing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\ndeclare const handler: lambda.Function;\n\nconst iamProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.IAM,\n};\n\nconst apiKeyProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.API_KEY,\n};\n\nconst lambdaProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.LAMBDA,\n  lambdaAuthorizerConfig: {\n    handler,\n    resultsCacheTtl: Duration.minutes(6),\n    validationRegex: 'test',\n  },\n};\n\nconst api = new appsync.EventApi(this, 'api', {\n  apiName: 'api',\n  authorizationConfig: {\n    // set auth providers\n    authProviders: [\n      iamProvider,\n      apiKeyProvider,\n      lambdaProvider,\n    ],\n    connectionAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.IAM,  // IAM authorization to connect\n    ],\n    defaultPublishAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,  // API key authorization to publish\n    ],\n    defaultSubscribeAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.LAMBDA,  // Lambda authorization to subscribe\n    ],\n  }\n});\n\napi.addChannelNamespace('default');\n```\n\n----------------------------------------\n\nTITLE: Configuring Passkey Sign-In with Custom Domain Relying Party ID in TypeScript\nDESCRIPTION: This AWS CDK snippet shows how to configure passkey (WebAuthn) sign-in for a Cognito User Pool using a custom domain name as the relying party ID. Both password and passkey authentication methods are enabled via `signInPolicy`, and the `passkeyRelyingPartyId` is set to the specified custom domain (e.g., 'auth.example.com').\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Use the custom domain as the relying party ID\nnew cognito.UserPool(this, 'myuserpool', {\n  signInPolicy: {\n    allowedFirstAuthFactors: { password: true, passkey: true },\n  },\n  passkeyRelyingPartyId: 'auth.example.com',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Scheduled EC2 Task with ScheduledEc2Task Construct\nDESCRIPTION: This code snippet demonstrates how to use the ScheduledEc2Task construct to create a task that runs every minute. It includes setting up a VPC and ECS cluster, and then configuring the scheduled task with various parameters such as image, desired task count, memory limit, CPU, environment variables, and schedule expression.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-scheduled-ecs-task-construct.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(stack, 'Vpc', { maxAzs: 1 });\nconst cluster = new ecs.Cluster(stack, 'EcsCluster', { vpc });\ncluster.addCapacity('DefaultAutoScalingGroup', {\n  instanceType: new ec2.InstanceType('t2.micro')\n});\n\nnew ScheduledEc2Task(stack, 'ScheduledEc2Task', {\n  cluster,\n  image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  desiredTaskCount: 2,\n  memoryLimitMiB: 512,\n  cpu: 1,\n  environment: { name: 'TRIGGER', value: 'CloudWatch Events' },\n  scheduleExpression: 'rate(1 minute)'\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Network Load Balanced EC2 Service in AWS CDK\nDESCRIPTION: Creates an ECS service on EC2 with multiple Network Load Balancers, each with dedicated listeners and target groups.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedEc2Service = new ecsPatterns.NetworkMultipleTargetGroupsEc2Service(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 256,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  loadBalancers: [\n    {\n      name: 'lb1',\n      listeners: [\n        {\n          name: 'listener1',\n        },\n      ],\n    },\n    {\n      name: 'lb2',\n      listeners: [\n        {\n          name: 'listener2',\n        },\n      ],\n    },\n  ],\n  targetGroups: [\n    {\n      containerPort: 80,\n      listener: 'listener1',\n    },\n    {\n      containerPort: 90,\n      listener: 'listener2',\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring High-Throughput Mode for SNS FIFO Topic in AWS CDK (TypeScript)\nDESCRIPTION: Example demonstrating how to create a FIFO (First-In-First-Out) SNS topic with high-throughput mode enabled. This configuration improves message throughput while maintaining strict message ordering, which is useful for applications requiring both high performance and sequential message processing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'MyTopic', {\n  fifo: true,\n  fifoThroughputScope: sns.FifoThroughputScope.TOPIC,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Local Secondary Index to DynamoDB TableV2 using Method in TypeScript\nDESCRIPTION: This snippet demonstrates adding a Local Secondary Index (LSI) to an existing DynamoDB TableV2 instance using the `addLocalSecondaryIndex` method. This requires the table to have a `sortKey` defined and allows adding indexes after the initial table definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n  localSecondaryIndexes: [\n    {\n      indexName: 'lsi1',\n      sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n    },\n  ],\n});\n\ntable.addLocalSecondaryIndex({\n  indexName: 'lsi2',\n  sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n});\n```\n\n----------------------------------------\n\nTITLE: OpenSearch Integration with AppSync\nDESCRIPTION: TypeScript code demonstrating AppSync integration with Amazon OpenSearch Service, including domain setup and resolver configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opensearch from 'aws-cdk-lib/aws-opensearchservice';\n\nconst user = new iam.User(this, 'User');\nconst domain = new opensearch.Domain(this, 'Domain', {\n  version: opensearch.EngineVersion.OPENSEARCH_2_3,\n  removalPolicy: RemovalPolicy.DESTROY,\n  fineGrainedAccessControl: { masterUserArn: user.userArn },\n  encryptionAtRest: { enabled: true },\n  nodeToNodeEncryption: true,\n  enforceHttps: true,\n});\n\ndeclare const api: appsync.GraphqlApi;\nconst ds = api.addOpenSearchDataSource('ds', domain);\n\nds.createResolver('QueryGetTestsResolver', {\n  typeName: 'Query',\n  fieldName: 'getTests',\n  requestMappingTemplate: appsync.MappingTemplate.fromString(JSON.stringify({\n    version: '2017-02-28',\n    operation: 'GET',\n    path: '/id/post/_search',\n    params: {\n      headers: {},\n      queryString: {},\n      body: { from: 0, size: 50 },\n    },\n  })),\n  responseMappingTemplate: appsync.MappingTemplate.fromString(`[\n    #foreach($entry in $context.result.hits.hits)\n    #if( $velocityCount > 1 ) , #end\n    $utils.toJson($entry.get(\"_source\"))\n    #end\n  ]`),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Retry Limit in CodeBuild Project\nDESCRIPTION: Demonstrates how to set up automatic build retries for failed builds by configuring the auto-retry limit.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  autoRetryLimit: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Lambda Triggers for Cognito User Pool in TypeScript\nDESCRIPTION: This snippet demonstrates how to add Lambda triggers to a Cognito User Pool during initialization and afterwards. It shows setting up an authentication challenge function and a user migration function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst authChallengeFn = new lambda.Function(this, 'authChallengeFn', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'path/to/asset')),\n});\n\nconst userpool = new cognito.UserPool(this, 'myuserpool', {\n  // ...\n  lambdaTriggers: {\n    createAuthChallenge: authChallengeFn,\n    // ...\n  },\n});\n\nuserpool.addTrigger(cognito.UserPoolOperation.USER_MIGRATION, new lambda.Function(this, 'userMigrationFn', {\n    runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'path/to/asset')),\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Processing EC2 Service with aws-cdk ECS Patterns (TypeScript)\nDESCRIPTION: Instantiates a QueueProcessingEc2Service to create an SQS queue and processes messages from the queue using EC2 instances within an ECS cluster. Requires an existing cluster, the aws-cdk-lib/aws-ecs and aws-cdk-lib/aws-ecs-patterns modules, and an image repository. Key parameters include compute configuration, container command, environment variables, scaling limits, and health checks. Outputs a managed ECS service with automatic queue creation if none is provided.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst queueProcessingEc2Service = new ecsPatterns.QueueProcessingEc2Service(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  command: [\"-c\", \"4\", \"amazon.com\"],\n  enableLogging: false,\n  desiredTaskCount: 2,\n  environment: {\n    TEST_ENVIRONMENT_VARIABLE1: \"test environment variable 1 value\",\n    TEST_ENVIRONMENT_VARIABLE2: \"test environment variable 2 value\",\n  },\n  maxScalingCapacity: 5,\n  containerName: 'test',\n  minHealthyPercent: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Pull Request Branches using AWS CDK (TypeScript)\nDESCRIPTION: This example details how to use the pullRequestFilter property in AWS CDK (TypeScript) so that a pipeline triggers only for certain pull request branches as defined by 'branchesIncludes' and 'branchesExcludes'. The priority is given to excludes. It requires codepipeline and codepipeline_actions, a sourceAction and buildAction, and applies to pipelineType V2. The pipeline is triggered by pull request events on specified branches.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pullRequestFilter: [{\n        branchesExcludes: ['exclude1', 'exclude2'],\n        branchesIncludes: ['include*'],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Distribution with Custom HTTP Methods and Viewer Protocol Policy\nDESCRIPTION: This snippet demonstrates how to create a CloudFront distribution with configured HTTP methods and viewer protocol policy for the default cache behavior. It uses an S3 bucket as the origin and sets the allowed methods to ALL and the viewer protocol policy to REDIRECT_TO_HTTPS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a Distribution with configured HTTP methods and viewer protocol policy of the cache.\ndeclare const myBucket: s3.Bucket;\nconst myWebDistribution = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(myBucket),\n    allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,\n    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Deletion Protection for Replicas with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to configure deletion protection on a per-replica basis for a TableV2 instance, demonstrating how it interacts with the removal policy during stack deletion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  removalPolicy: cdk.RemovalPolicy.DESTROY,\n  deletionProtection: true,\n  // only the replica in us-east-1 will be deleted during stack deletion\n  replicas: [\n    {\n      region: 'us-east-1',\n      deletionProtection: false,\n    },\n    {\n      region: 'us-east-2',\n      deletionProtection: true,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an AAAA Record for CloudFront Distribution in Route53 using AWS CDK\nDESCRIPTION: Demonstrates how to add an AAAA record pointing to a CloudFront distribution in a Route53 hosted zone. It uses the CloudFrontTarget to create an alias record for the distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudfront from 'aws-cdk-lib/aws-cloudfront';\n\ndeclare const myZone: route53.HostedZone;\ndeclare const distribution: cloudfront.CloudFrontWebDistribution;\nnew route53.AaaaRecord(this, 'Alias', {\n  zone: myZone,\n  target: route53.RecordTarget.fromAlias(new targets.CloudFrontTarget(distribution)),\n});\n```\n\n----------------------------------------\n\nTITLE: Controlling Trigger Execution Order in AWS CDK\nDESCRIPTION: Demonstrates how to control the order of execution for triggers using executeAfter and executeBefore methods. This example defines an execution order where the trigger runs after certain constructs and before others.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/triggers/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as triggers from 'aws-cdk-lib/triggers';\n\ndeclare const myTrigger: triggers.Trigger;\ndeclare const hello: Construct;\ndeclare const world: Construct;\ndeclare const goodbye: Construct;\n\nmyTrigger.executeAfter(hello, world);\nmyTrigger.executeBefore(goodbye);\n```\n\n----------------------------------------\n\nTITLE: Validating CloudFront Signed URLs/Cookies with Trusted Key Groups using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a CloudFront distribution to validate signed URLs or signed cookies using Trusted Key Groups. It involves creating a PublicKey from a PEM-formatted key, grouping it into a KeyGroup, and associating the KeyGroup with the default behavior of the distribution. This ensures that requests matching the behavior require signing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// Validating signed URLs or signed cookies with Trusted Key Groups\n\n// public key in PEM format\ndeclare const publicKey: string;\nconst pubKey = new cloudfront.PublicKey(this, 'MyPubKey', {\n  encodedKey: publicKey,\n});\n\nconst keyGroup = new cloudfront.KeyGroup(this, 'MyKeyGroup', {\n  items: [\n    pubKey,\n  ],\n});\n\nnew cloudfront.Distribution(this, 'Dist', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('www.example.com'),\n    trustedKeyGroups: [\n      keyGroup,\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom KMS Key Policy Document Using AWS CDK in TypeScript\nDESCRIPTION: Replaces or appends to the default KMS key policy by defining a custom policy document in CDK, thus tailoring key management and operational permissions. The example grants a set of KMS privileges to the account root using explicit IAM policy statements. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'. The policy attachment behavior depends on the CDK feature flag and the 'trustedAccountIdentities' setting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTrustedAdminRole = iam.Role.fromRoleArn(this, 'TrustedRole', 'arn:aws:iam:....');\n// Creates a limited admin policy and assigns to the account root.\nconst myCustomPolicy = new iam.PolicyDocument({\n  statements: [new iam.PolicyStatement({\n    actions: [\n      'kms:Create*',\n      'kms:Describe*',\n      'kms:Enable*',\n      'kms:List*',\n      'kms:Put*',\n    ],\n    principals: [new iam.AccountRootPrincipal()],\n    resources: ['*'],\n  })],\n});\nconst key = new kms.Key(this, 'MyKey', {\n  policy: myCustomPolicy,\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching WAF Web ACL to CloudFront Distribution\nDESCRIPTION: This snippet shows how to attach an AWS WAF web ACL to a CloudFront distribution during creation. It uses the Web ACL ARN for WAFv2 or ACL ID for WAF Classic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucketOrigin: origins.S3Origin;\ndeclare const webAcl: wafv2.CfnWebACL;\nconst distribution = new cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: bucketOrigin },\n  webAclId: webAcl.attrArn,\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Instance Requirements in an Auto Scaling Group's Mixed Instances Policy in TypeScript\nDESCRIPTION: This snippet demonstrates defining specific instance requirements (like vCPU count, memory, and CPU manufacturer) within a launch template override as part of a Mixed Instances Policy. Instead of listing specific instance types, this allows AWS Auto Scaling to automatically select appropriate instance types that meet the defined criteria, simplifying configuration and potentially improving instance availability.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const launchTemplate1: ec2.LaunchTemplate;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  mixedInstancesPolicy: {\n    launchTemplate: launchTemplate1,\n    launchTemplateOverrides: [\n      {\n        instanceRequirements: {\n          vCpuCount: { min: 4, max: 8 },\n          memoryMiB: { min: 16384 },\n          cpuManufacturers: ['intel'],\n        },\n      }\n    ],\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a gRPC Route with Retry Policy - AWS App Mesh - TypeScript\nDESCRIPTION: This code adds a gRPC route with an advanced retry policy, handling TCP, HTTP, and gRPC-specific retry events (e.g., CANCELLED, RESOURCE_EXHAUSTED, UNAVAILABLE). It uses appmesh.RouteSpec.grpc, matches based on serviceName, and limits retries to five with a one-second timeout. Requirements: AWS CDK and App Mesh modules, predefined virtual router and node. Takes arrays for different event types and retry configs as input. Outputs a fault-tolerant gRPC route. Limitations: only specified events and retries handled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-grpc-retry', {\n  routeSpec: appmesh.RouteSpec.grpc({\n    weightedTargets: [{ virtualNode: node }],\n    match: { serviceName: 'servicename' },\n    retryPolicy: {\n      tcpRetryEvents: [appmesh.TcpRetryEvent.CONNECTION_ERROR],\n      httpRetryEvents: [appmesh.HttpRetryEvent.GATEWAY_ERROR],\n      // Retry if gRPC responds that the request was cancelled, a resource\n      // was exhausted, or if the service is unavailable\n      grpcRetryEvents: [\n        appmesh.GrpcRetryEvent.CANCELLED,\n        appmesh.GrpcRetryEvent.RESOURCE_EXHAUSTED,\n        appmesh.GrpcRetryEvent.UNAVAILABLE,\n      ],\n      retryAttempts: 5,\n      retryTimeout: Duration.seconds(1),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Target Groups Fargate Service in AWS CDK\nDESCRIPTION: Creates an ECS service on Fargate with multiple target groups behind an Application Load Balancer. Configures CPU and memory limits with different container ports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationMultipleTargetGroupsFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  targetGroups: [\n    {\n      containerPort: 80,\n    },\n    {\n      containerPort: 90,\n      pathPattern: 'a/b/c',\n      priority: 10,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppRunner Service with Local Docker Asset\nDESCRIPTION: Creates an AppRunner service using a local Docker image asset that gets built and pushed to ECR.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assets from 'aws-cdk-lib/aws-ecr-assets';\n\nconst imageAsset = new assets.DockerImageAsset(this, 'ImageAssets', {\n  directory: path.join(__dirname, 'docker.assets'),\n});\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromAsset({\n    imageConfiguration: { port: 8000 },\n    asset: imageAsset,\n  }),\n  autoDeploymentsEnabled: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Public S3 Website Hosting and Deployment with AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to create a public S3 bucket configured for static website hosting and then populate it with files from a local directory using the AWS CDK. The BucketDeployment construct is used to upload contents from the specified local directory to the bucket, with an optional prefix for organized storage. Dependencies required are AWS CDK modules for S3 and s3-deployment. The main parameters are the local source directory and destination bucket. The expected result is that the contents of './website-dist' are deployed to the S3 bucket under the 'web/static' prefix.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst websiteBucket = new s3.Bucket(this, 'WebsiteBucket', {\n  websiteIndexDocument: 'index.html',\n  publicReadAccess: true,\n});\n\nnew s3deploy.BucketDeployment(this, 'DeployWebsite', {\n  sources: [s3deploy.Source.asset('./website-dist')],\n  destinationBucket: websiteBucket,\n  destinationKeyPrefix: 'web/static', // optional prefix in destination bucket\n});\n```\n\n----------------------------------------\n\nTITLE: Scanning ECR Images for Vulnerabilities with InspectorEcrImageScanAction (TypeScript)\nDESCRIPTION: Demonstrates usage of InspectorEcrImageScanAction to perform vulnerability scanning on ECR container images within an AWS CodePipeline using AWS CDK TypeScript. Requires an ECR repository and a pipeline instance; outputs an artifact with the scan results. Inputs are the ECR repository and a destination artifact; dependencies include aws-cdk-lib's ecr, codepipeline, and codepipeline_actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\n\ndeclare const pipeline: codepipeline.Pipeline;\ndeclare const repository: ecr.IRepository;\n\nconst scanOutput = new codepipeline.Artifact();\nconst scanAction = new codepipeline_actions.InspectorEcrImageScanAction({\n  actionName: 'InspectorEcrImageScanAction',\n  output: scanOutput,\n  repository: repository,\n});\n\npipeline.addStage({\n  stageName: 'Scan',\n  actions: [scanAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up CloudFront OAI (Legacy) with Default Identity in AWS CDK (TypeScript)\nDESCRIPTION: Provides a simple AWS CDK TypeScript example for creating a CloudFront distribution with an S3 origin configured to use the legacy Origin Access Identity (OAI). Calling `origins.S3BucketOrigin.withOriginAccessIdentity(myBucket)` automatically provisions a new OAI and grants it read permissions on the specified S3 bucket (`myBucket`). Dependencies include `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withOriginAccessIdentity(myBucket) // Automatically creates an OAI\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Resources to Shared AWS App Mesh in CDK\nDESCRIPTION: Demonstrates how to add resources to a shared AWS App Mesh from a different AWS account. This allows resources created by different accounts to communicate within the same mesh.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\n// This is the ARN for the mesh from different AWS IAM account ID.\n// Ensure mesh is properly shared with your account. For more details, see: https://github.com/aws/aws-cdk/issues/15404\nconst arn = 'arn:aws:appmesh:us-east-1:123456789012:mesh/testMesh';\nconst sharedMesh = appmesh.Mesh.fromMeshArn(this, 'imported-mesh', arn);\n\n// This VirtualNode resource can communicate with the resources in the mesh from different AWS IAM account ID.\nnew appmesh.VirtualNode(this, 'test-node', {\n  mesh: sharedMesh,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Nested CloudWatch Math Expression for Percentage (TypeScript)\nDESCRIPTION: Shows how to use a previously defined `cloudwatch.MathExpression` ('allProblems') within another math expression. This example calculates a percentage '(problems / invocations) * 100', using the 'allProblems' expression and the Lambda invocation metric. Requires existing `lambda.Function` and `cloudwatch.MathExpression` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\ndeclare const allProblems: cloudwatch.MathExpression;\n\nconst problemPercentage = new cloudwatch.MathExpression({\n  expression: \"(problems / invocations) * 100\",\n  usingMetrics: {\n    problems: allProblems,\n    invocations: fn.metricInvocations()\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Read Permissions to IAM Role on Kinesis Stream Consumer - AWS CDK - TypeScript\nDESCRIPTION: This snippet grants read permissions on a Kinesis stream consumer (and its stream) to an IAM role using the grantRead method. It demonstrates associating enhanced consumer permissions and covers both stream and stream consumer actions. Requires aws-cdk-lib, kinesis, iam modules. Inputs are the IAM role, stream, and stream consumer; output is the necessary permissions for role-based Lambda consumption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst lambdaRole = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n  description: 'Example role...',\n});\n\nconst stream = new kinesis.Stream(this, 'MyEncryptedStream', {\n  encryption: kinesis.StreamEncryption.KMS,\n});\nconst streamConsumer = new kinesis.StreamConsumer(this, 'MyStreamConsumer', {\n  streamConsumerName: 'MyStreamConsumer',\n  stream,\n});\n\n// give lambda permissions to read stream via the stream consumer\nstreamConsumer.grantRead(lambdaRole);\n```\n\n----------------------------------------\n\nTITLE: Creating a Multi-Node Job Definition in AWS Batch for MPI Workloads\nDESCRIPTION: Shows how to create a multi-node job definition for running distributed MPI workloads. This example defines node ranges and assigns containers to specific nodes with appropriate CPU and memory configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst multiNodeJob = new batch.MultiNodeJobDefinition(this, 'JobDefinition', {\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.R4, ec2.InstanceSize.LARGE), // optional, omit to let Batch choose the type for you\n  containers: [{\n    container: new batch.EcsEc2ContainerDefinition(this, 'mainMPIContainer', {\n      image: ecs.ContainerImage.fromRegistry('yourregsitry.com/yourMPIImage:latest'),\n      cpu: 256,\n      memory: cdk.Size.mebibytes(2048),\n    }),\n    startNode: 0,\n    endNode: 5,\n  }],\n});\n// convenience method\nmultiNodeJob.addContainer({\n  startNode: 6,\n  endNode: 10,\n  container: new batch.EcsEc2ContainerDefinition(this, 'multiContainer', {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    cpu: 256,\n    memory: cdk.Size.mebibytes(2048),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying SES Region for Cross-Region Email Delivery - AWS CDK - TypeScript\nDESCRIPTION: Illustrates configuring the region for SES when it's different from the UserPool region. Requires SES setup in specified region. 'sesRegion', 'fromEmail', 'fromName', and 'replyTo' are key input parameters. The code outputs a UserPool configured to send emails through SES in 'us-east-1' or another specified region.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  email: cognito.UserPoolEmail.withSES({\n    sesRegion: 'us-east-1',\n    fromEmail: 'noreply@myawesomeapp.com',\n    fromName: 'Awesome App',\n    replyTo: 'support@myawesomeapp.com',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing AWS Lambda Function to SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: This code attaches an AWS Lambda function to an SNS topic using the LambdaSubscription construct from aws-sns-subscriptions. Requires aws-cdk-lib/aws-lambda and initialized SNS and Lambda resources. Messages published to the SNS topic are delivered to the Lambda function as event triggers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst myTopic = new sns.Topic(this, 'myTopic');\ndeclare const myFunction: lambda.Function;\nmyTopic.addSubscription(new subscriptions.LambdaSubscription(myFunction));\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront Origin Connection Behaviors (TypeScript)\nDESCRIPTION: Defines an AWS CloudFront distribution using AWS CDK, specifying custom origin connection settings. It sets the number of connection attempts to 3 and the connection timeout to 10 seconds for the default behavior. Requires the `@aws-cdk/aws-cloudfront` and `@aws-cdk/core` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_43\n\nLANGUAGE: ts\nCODE:\n```\n// Configuring connection behaviors between Cloudfront and your origin\nconst distribution = new cloudfront.CloudFrontWebDistribution(this, 'MyDistribution', {\n  originConfigs: [\n    {\n      connectionAttempts: 3,\n      connectionTimeout: Duration.seconds(10),\n      behaviors: [\n        {\n          isDefaultBehavior: true,\n        },\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Domain for API Gateway v2 with TypeScript\nDESCRIPTION: Sets up a custom domain name for API Gateway and maps it to the default stage with a specific mapping key. Uses ACM certificate and Lambda integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\nimport { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst certArn = 'arn:aws:acm:us-east-1:111111111111:certificate';\nconst domainName = 'example.com';\n\nconst dn = new apigwv2.DomainName(this, 'DN', {\n  domainName: domainName,\n  certificate: acm.Certificate.fromCertificateArn(this, 'cert', certArn),\n});\n\ndeclare const handler: lambda.Function;\nconst api = new apigwv2.HttpApi(this, 'HttpProxyProdApi', {\n  defaultIntegration: new HttpLambdaIntegration('DefaultIntegration', handler),\n  defaultDomainMapping: {\n    domainName: dn,\n    mappingKey: 'foo',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Lambda Function on S3 Object Creation using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates configuring an AWS S3 bucket using the AWS CDK to invoke a Lambda function when a new object is created. It requires the `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-lambda`, and `aws-cdk-lib/aws-s3-notifications` modules, as well as the Node.js `path` module for asset handling. The `bucket.addEventNotification` method sets up the event trigger for `s3.EventType.OBJECT_CREATED` using an `s3n.LambdaDestination` that points to the defined Lambda function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-notifications/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst bucket = new s3.Bucket(this, 'Bucket');\nconst fn = new lambda.Function(this, 'MyFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n});\n\nbucket.addEventNotification(s3.EventType.OBJECT_CREATED, new s3n.LambdaDestination(fn));\n```\n```\n\n----------------------------------------\n\nTITLE: Example Canary Handler Script (JavaScript)\nDESCRIPTION: Provides an example implementation for the canary script (`index.js`). It uses the Synthetics library and Puppeteer (via the runtime) to navigate to a URL constructed from an environment variable, waits for the page to load, takes a screenshot, logs the page title, and checks the HTTP response status. The script exports the required `handler` function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst synthetics = require('Synthetics');\nconst log = require('SyntheticsLogger');\n\nconst pageLoadBlueprint = async function () {\n  // Configure the stage of the API using environment variables\n  const url = `https://api.example.com/${process.env.stage}/user/books/topbook/`;\n\n  const page = await synthetics.getPage();\n  const response = await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });\n  // Wait for page to render. Increase or decrease wait time based on endpoint being monitored.\n  await page.waitFor(15000);\n  // This will take a screenshot that will be included in test output artifacts.\n  await synthetics.takeScreenshot('loaded', 'loaded');\n  const pageTitle = await page.title();\n  log.info('Page title: ' + pageTitle);\n  if (response.status() !== 200) {\n    throw 'Failed to load page!';\n  }\n};\n\nexports.handler = async () => {\n  return await pageLoadBlueprint();\n};\n```\n\n----------------------------------------\n\nTITLE: Appointing KMS Key Admin via Role and grantAdmin Using AWS CDK in TypeScript\nDESCRIPTION: Assigns administrative privileges on a KMS key to a specified IAM role during key creation (via the 'admins' property) and post-creation (via 'grantAdmin'). Admins can manage permissions, revoke, and delete the key. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTrustedAdminRole = iam.Role.fromRoleArn(this, 'TrustedRole', 'arn:aws:iam:....');\nconst key = new kms.Key(this, 'MyKey', {\n  admins: [myTrustedAdminRole],\n});\n\nconst secondKey = new kms.Key(this, 'MyKey2');\nsecondKey.grantAdmin(myTrustedAdminRole);\n```\n\n----------------------------------------\n\nTITLE: Implementing AWS Config Compliance Change Notifications in TypeScript CDK\nDESCRIPTION: Sets up an AWS Config rule for CloudFormation stack drift detection and configures SNS notifications for compliance changes. Creates a compliance topic and attaches it as a target for compliance change events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Topic to which compliance notification events will be published\nconst complianceTopic = new sns.Topic(this, 'ComplianceTopic');\n\nconst rule = new config.CloudFormationStackDriftDetectionCheck(this, 'Drift');\nrule.onComplianceChange('TopicEvent', {\n  target: new targets.SnsTopic(complianceTopic),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Token Revocation for Cognito App Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to explicitly enable token revocation for an AWS Cognito App Client using AWS CDK. Setting `enableTokenRevocation` to `true` allows refresh tokens issued to this client to be revoked. While enabled by default for new pools, this property can explicitly control the setting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  // ...\n  enableTokenRevocation: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes Manifests using AWS CDK EKS Module (TypeScript)\nDESCRIPTION: Demonstrates deploying a 'hello-kubernetes' application using Kubernetes Deployment and Service manifests defined as TypeScript objects. It shows two equivalent methods: using the `eks.KubernetesManifest` construct directly or using the `cluster.addManifest` helper method. Both require an existing `eks.Cluster` instance and apply the provided manifests to it.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst appLabel = { app: \"hello-kubernetes\" };\n\nconst deployment = {\n  apiVersion: \"apps/v1\",\n  kind: \"Deployment\",\n  metadata: { name: \"hello-kubernetes\" },\n  spec: {\n    replicas: 3,\n    selector: { matchLabels: appLabel },\n    template: {\n      metadata: { labels: appLabel },\n      spec: {\n        containers: [\n          {\n            name: \"hello-kubernetes\",\n            image: \"paulbouwer/hello-kubernetes:1.5\",\n            ports: [ { containerPort: 8080 } ],\n          },\n        ],\n      },\n    },\n  },\n};\n\nconst service = {\n  apiVersion: \"v1\",\n  kind: \"Service\",\n  metadata: { name: \"hello-kubernetes\" },\n  spec: {\n    type: \"LoadBalancer\",\n    ports: [ { port: 80, targetPort: 8080 } ],\n    selector: appLabel,\n  }\n};\n\n// option 1: use a construct\nnew eks.KubernetesManifest(this, 'hello-kub', {\n  cluster,\n  manifest: [ deployment, service ],\n});\n\n// or, option2: use `addManifest`\ncluster.addManifest('hello-kub', service, deployment);\n```\n\n----------------------------------------\n\nTITLE: Enabling DNSSEC for a Route53 Hosted Zone in TypeScript\nDESCRIPTION: Configures DNSSEC signing for a Route53 hosted zone using a KMS Customer-Managed Key with ECC_NIST_P256 key spec. The KMS key must be in us-east-1 region as required by AWS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst kmsKey = new kms.Key(this, 'KmsCMK', {\n  keySpec: kms.KeySpec.ECC_NIST_P256,\n  keyUsage: kms.KeyUsage.SIGN_VERIFY,\n});\nconst hostedZone = new route53.HostedZone(this, 'HostedZone', {\n  zoneName: 'example.com',\n});\n// Enable DNSSEC signing for the zone\nhostedZone.enableDnssec({ kmsKey });\n```\n\n----------------------------------------\n\nTITLE: Configuring Attribute Read/Write Permissions for Cognito App Client (TypeScript)\nDESCRIPTION: This snippet shows how to define fine-grained read and write permissions for user attributes for an AWS Cognito App Client using the `ClientAttributes` helper class in AWS CDK. It specifies which standard and custom attributes the client is allowed to read and write, overriding the default behavior which allows access to all attributes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\n\nconst clientWriteAttributes = (new cognito.ClientAttributes())\n  .withStandardAttributes({fullname: true, email: true})\n  .withCustomAttributes('favoritePizza', 'favoriteBeverage');\n\nconst clientReadAttributes = clientWriteAttributes\n  .withStandardAttributes({emailVerified: true})\n  .withCustomAttributes('pointsEarned');\n\npool.addClient('app-client', {\n  // ...\n  readAttributes: clientReadAttributes,\n  writeAttributes: clientWriteAttributes,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing CDK Constructs using Barrel Import Style (TypeScript)\nDESCRIPTION: Demonstrates the barrel import method in TypeScript for AWS CDK. Core classes like `App` and `Stack` are imported from the main `aws-cdk-lib` package, while specific resource classes like `Bucket` are imported from their service-specific sub-paths (`aws-cdk-lib/aws-s3`). It then instantiates an App, a Stack, and an S3 Bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport { App, Stack } from 'aws-cdk-lib';\nimport { Bucket } from 'aws-cdk-lib/aws-s3';\n\nconst app = new App();\nconst stack = new Stack(app, 'TestStack');\n\nnew Bucket(stack, 'TestBucket');\n```\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS ImageBuilder Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS ImageBuilder module from the `aws-cdk-lib` package. This import is necessary to access the low-level (L1) constructs representing AWS ImageBuilder resources within an AWS CDK application. Using these constructs allows for defining ImageBuilder infrastructure programmatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-imagebuilder/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as imagebuilder from 'aws-cdk-lib/aws-imagebuilder';\n```\n\n----------------------------------------\n\nTITLE: Configuring Sign-In Aliases and Auto-Verification in TypeScript\nDESCRIPTION: This code snippet shows how to configure a Cognito User Pool to allow sign-in via username and email, while also enabling automatic verification for both email and phone numbers. The `signInAliases` property defines allowed login identifiers, and `autoVerify` specifies which attributes should be automatically marked as verified upon confirmation. CDK enables auto-verification by default if email/phone are sign-in aliases, but this example shows explicit configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  // ...\n  signInAliases: { username: true, email: true },\n  autoVerify: { email: true, phone: true },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Neptune Serverless Cluster\nDESCRIPTION: Shows how to configure a Neptune Serverless cluster by using the SERVERLESS instance type along with serverlessScalingConfiguration to define capacity limits.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'ServerlessDatabase', {\n  vpc,\n  instanceType: neptune.InstanceType.SERVERLESS,\n  serverlessScalingConfiguration: {\n    minCapacity: 1,\n    maxCapacity: 5,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding OpenSearch Domain Access Policies using Helper Method in TypeScript\nDESCRIPTION: This snippet shows how to add complex access policies to an existing OpenSearch domain instance using the `addAccessPolicies` helper method. This approach allows referencing the domain's ARN dynamically, suitable for scenarios like cross-account data ingestion from Amazon Data Firehose. It defines two policy statements granting different sets of permissions (POST/PUT and GET) to a specific account principal on resources tied to the domain's ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n});\ndomain.addAccessPolicies(\n  new iam.PolicyStatement({\n    actions: ['es:ESHttpPost', 'es:ESHttpPut'],\n    effect: iam.Effect.ALLOW,\n    principals: [new iam.AccountPrincipal('123456789012')],\n    resources: [domain.domainArn, `${domain.domainArn}/*`],\n  }),\n  new iam.PolicyStatement({\n    actions: ['es:ESHttpGet'],\n    effect: iam.Effect.ALLOW,\n    principals: [new iam.AccountPrincipal('123456789012')],\n    resources: [\n      `${domain.domainArn}/_all/_settings`,\n      `${domain.domainArn}/_cluster/stats`,\n      `${domain.domainArn}/index-name*/_mapping/type-name`,\n      `${domain.domainArn}/roletest*/_mapping/roletest`,\n      `${domain.domainArn}/_nodes`,\n      `${domain.domainArn}/_nodes/stats`,\n      `${domain.domainArn}/_nodes/*/stats`,\n      `${domain.domainArn}/_stats`,\n      `${domain.domainArn}/index-name*/_stats`,\n      `${domain.domainArn}/roletest*/_stat`,\n    ],\n  }),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Cache Policy for CloudFront Distribution\nDESCRIPTION: This example demonstrates how to create a custom cache policy and apply it to a CloudFront distribution. It configures various aspects of caching behavior including TTL, cookie handling, header forwarding, and query string forwarding.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// Creating a custom cache policy for a Distribution -- all parameters optional\ndeclare const bucketOrigin: origins.S3Origin;\nconst myCachePolicy = new cloudfront.CachePolicy(this, 'myCachePolicy', {\n  cachePolicyName: 'MyPolicy',\n  comment: 'A default policy',\n  defaultTtl: Duration.days(2),\n  minTtl: Duration.minutes(1),\n  maxTtl: Duration.days(10),\n  cookieBehavior: cloudfront.CacheCookieBehavior.all(),\n  headerBehavior: cloudfront.CacheHeaderBehavior.allowList('X-CustomHeader'),\n  queryStringBehavior: cloudfront.CacheQueryStringBehavior.denyList('username'),\n  enableAcceptEncodingGzip: true,\n  enableAcceptEncodingBrotli: true,\n});\nnew cloudfront.Distribution(this, 'myDistCustomPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    cachePolicy: myCachePolicy,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an IAM Policy for AppSync Field Access in JSON\nDESCRIPTION: This JSON snippet shows an AWS IAM policy statement that grants permission to invoke a specific AppSync GraphQL mutation field (`updateExample`). The `Resource` ARN targets the specific field within the AppSync API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"appsync:GraphQL\"\n      ],\n      \"Resource\": [\n        \"arn:aws:appsync:REGION:ACCOUNT_ID:apis/GRAPHQL_ID/types/Mutation/fields/updateExample\"\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Monorepo Structure for NodejsFunction\nDESCRIPTION: Shows the recommended file and package organization for using NodejsFunction in a monorepo project with multiple packages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n packages\n    cool-package\n       lib\n          cool-construct.api.ts\n          cool-construct.auth.ts\n          cool-construct.ts\n       package.json # CDK and runtime dependencies for cool-package\n       tsconfig.json\n    super-package\n        lib\n           super-construct.handler.ts\n           super-construct.ts\n        package.json # CDK and runtime dependencies for super-package\n        tsconfig.json\n package-lock.json # single lock file\n package.json # root dependencies\n tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Importing AWS RoboMaker module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS RoboMaker module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-robomaker/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as robomaker from 'aws-cdk-lib/aws-robomaker';\n```\n\n----------------------------------------\n\nTITLE: Granting Repository Push Access\nDESCRIPTION: Grants an IAM role permission to push images to an ECR repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('codebuild.amazonaws.com'),\n});\nrepository.grantPush(role);\n```\n\n----------------------------------------\n\nTITLE: Connecting AppSync to HTTP Endpoint (Step Functions) using AWS CDK (TypeScript/GraphQL/VTL)\nDESCRIPTION: This example shows how to configure an AWS AppSync API to invoke an AWS Step Functions state machine via an HTTP data source using AWS CDK. It includes the GraphQL schema definition, VTL request/response mapping templates (`request.vtl`, `response.vtl`) for the Step Functions `StartExecution` API call, and the TypeScript CDK code to create the AppSync API, the HTTP data source (`addHttpDataSource`) configured for signed requests to the Step Functions service, and the resolver (`createResolver`) linking the mutation field to the HTTP data source using the VTL templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\ntype job {\n  id: String!\n  version: String!\n}\n\ninput DemoInput {\n  version: String!\n}\n\ntype Mutation {\n  callStepFunction(input: DemoInput!): job\n}\n\ntype Query {\n  _placeholder: String\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": \"2018-05-29\",\n  \"method\": \"POST\",\n  \"resourcePath\": \"/\",\n  \"params\": {\n    \"headers\": {\n      \"content-type\": \"application/x-amz-json-1.0\",\n      \"x-amz-target\":\"AWSStepFunctions.StartExecution\"\n    },\n    \"body\": {\n      \"stateMachineArn\": \"<your step functions arn>\",\n      \"input\": \"{ \\\"id\\\": \\\"$context.arguments.id\\\" }\"\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"${context.result.id}\"\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'api',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'schema.graphql')),\n});\n\nconst httpDs = api.addHttpDataSource(\n  'ds',\n  'https://states.amazonaws.com',\n  {\n    name: 'httpDsWithStepF',\n    description: 'from appsync to StepFunctions Workflow',\n    authorizationConfig: {\n      signingRegion: 'us-east-1',\n      signingServiceName: 'states',\n    },\n  },\n);\n\nhttpDs.createResolver('MutationCallStepFunctionResolver', {\n  typeName: 'Mutation',\n  fieldName: 'callStepFunction',\n  requestMappingTemplate: appsync.MappingTemplate.fromFile('request.vtl'),\n  responseMappingTemplate: appsync.MappingTemplate.fromFile('response.vtl'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Tracking Scaling for DynamoDB Read Capacity in TypeScript\nDESCRIPTION: This example demonstrates target tracking scaling for a DynamoDB table's read capacity. After setting the min/max capacity using `autoScaleReadCapacity`, it uses `scaleOnUtilization` to configure the scaling policy to automatically adjust capacity to keep the average read utilization around 60%.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\n\ndeclare const table: dynamodb.Table;\n\nconst readCapacity = table.autoScaleReadCapacity({\n  minCapacity: 10,\n  maxCapacity: 1000\n});\nreadCapacity.scaleOnUtilization({\n  targetUtilizationPercent: 60\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Extension with Lambda Destination and Parameters using AWS CDK in TypeScript\nDESCRIPTION: This example shows creating an AWS AppConfig `Extension` with a Lambda event destination, similar to the previous snippet, but also includes extension parameters. It defines one required parameter ('testParam') and one optional parameter ('testNotRequiredParam') using `appconfig.Parameter`. Requires a `lambda.Function` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nnew appconfig.Extension(this, 'MyExtension', {\n  actions: [\n    new appconfig.Action({\n      actionPoints: [appconfig.ActionPoint.ON_DEPLOYMENT_START],\n      eventDestination: new appconfig.LambdaDestination(fn),\n    }),\n  ],\n  parameters: [\n    appconfig.Parameter.required('testParam', 'true'),\n    appconfig.Parameter.notRequired('testNotRequiredParam'),\n  ]\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Step Scaling for an Auto Scaling Group based on a Custom Metric in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure step scaling on an Auto Scaling Group (ASG) using the `scaleOnMetric` method. It defines scaling adjustments based on the value of a custom CloudWatch metric (`WorkerUtilization`). Specific steps trigger adding or removing instances (`CHANGE_IN_CAPACITY`) when the metric crosses defined thresholds (`lower`, `upper`). It also configures `evaluationPeriods` and `datapointsToAlarm` for the underlying CloudWatch Alarms.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nconst workerUtilizationMetric = new cloudwatch.Metric({\n    namespace: 'MyService',\n    metricName: 'WorkerUtilization'\n});\n\nautoScalingGroup.scaleOnMetric('ScaleToCPU', {\n  metric: workerUtilizationMetric,\n  scalingSteps: [\n    { upper: 10, change: -1 },\n    { lower: 50, change: +1 },\n    { lower: 70, change: +3 },\n  ],\n  evaluationPeriods: 10,\n  datapointsToAlarm: 5,\n\n  // Change this to AdjustmentType.PERCENT_CHANGE_IN_CAPACITY to interpret the\n  // 'change' numbers before as percentages instead of capacity counts.\n  adjustmentType: autoscaling.AdjustmentType.CHANGE_IN_CAPACITY,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a User Pool in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a new Amazon Cognito User Pool using the CDK. It sets the user pool name and configures case-insensitive sign-in.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  userPoolName: 'myawesomeapp-userpool',\n  signInCaseSensitive: false, // case insensitive is preferred in most situations\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Rate-based and Cron-based Schedules (AWS CDK, TypeScript)\nDESCRIPTION: Illustrates how to define both rate-based and cron-based recurring schedules for EventBridge Scheduler using AWS CDK. The snippets show usage of ScheduleExpression.rate and ScheduleExpression.cron to schedule tasks at regular intervals or specific times/dates with timezone support. Inputs include scheduling details and the LambdaInvoke target, outputs are periodic schedule triggers. Requires TimeZone, Schedule, and LambdaInvoke.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nconst rateBasedSchedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(10)),\n    target,\n    description: 'This is a test rate-based schedule',\n});\n\nconst cronBasedSchedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.cron({ \n        minute: '0',\n        hour: '23',\n        day: '20',\n        month: '11',\n        timeZone: TimeZone.AMERICA_NEW_YORK,\n    }),\n    target,\n    description: 'This is a test cron-based schedule that will run at 11:00 PM, on day 20 of the month, only in November in New York timezone',\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing ECR Source Action Variables in TypeScript\nDESCRIPTION: This snippet illustrates how to access output variables from an EcrSourceAction (like the image URI) in a subsequent CodeBuildAction. It defines an optional `variablesNamespace` in the source action and retrieves the variable value using `sourceAction.variables.imageUri` for use in the build action's environment variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\n\nconst sourceOutput = new codepipeline.Artifact();\ndeclare const ecrRepository: ecr.Repository;\nconst sourceAction = new codepipeline_actions.EcrSourceAction({\n  actionName: 'Source',\n  output: sourceOutput,\n  repository: ecrRepository,\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\ndeclare const project: codebuild.PipelineProject;\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    IMAGE_URI: {\n      value: sourceAction.variables.imageUri,\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring EFS Replication in TypeScript\nDESCRIPTION: Demonstrates different methods for configuring EFS replication using AWS CDK. It shows how to automatically generate a regional replication destination, automatically generate a One Zone replication destination in a specific AZ, and how to specify a pre-existing EFS file system as the replication destination. The destination file system needs `replicationOverwriteProtection` set to `DISABLED`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\n// auto generate a regional replication destination file system\nnew efs.FileSystem(this, 'RegionalReplicationFileSystem', {\n  vpc,\n  replicationConfiguration: efs.ReplicationConfiguration.regionalFileSystem('us-west-2'),\n});\n\n// auto generate a one zone replication destination file system\nnew efs.FileSystem(this, 'OneZoneReplicationFileSystem', {\n  vpc,\n  replicationConfiguration: efs.ReplicationConfiguration.oneZoneFileSystem('us-east-1', 'us-east-1a'),\n});\n\nconst destinationFileSystem = new efs.FileSystem(this, 'DestinationFileSystem', {\n  vpc,\n  // set as the read-only file system for use as a replication destination\n  replicationOverwriteProtection: efs.ReplicationOverwriteProtection.DISABLED,\n});\n// specify the replication destination file system\nnew efs.FileSystem(this, 'ReplicationFileSystem', {\n  vpc,\n  replicationConfiguration: efs.ReplicationConfiguration.existingFileSystem(destinationFileSystem),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Object Metadata in Bucket Deployment\nDESCRIPTION: Illustrates how to specify both user-defined and system-defined metadata for objects in an S3 bucket deployment, including cache control, content type, and storage class configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst websiteBucket = new s3.Bucket(this, 'WebsiteBucket', {\n  websiteIndexDocument: 'index.html',\n  publicReadAccess: true,\n});\n\nnew s3deploy.BucketDeployment(this, 'DeployWebsite', {\n  sources: [s3deploy.Source.asset('./website-dist')],\n  destinationBucket: websiteBucket,\n  destinationKeyPrefix: 'web/static', // optional prefix in destination bucket\n  metadata: { A: \"1\", b: \"2\" }, // user-defined metadata\n\n  // system-defined metadata\n  contentType: \"text/html\",\n  contentLanguage: \"en\",\n  storageClass: s3deploy.StorageClass.INTELLIGENT_TIERING,\n  serverSideEncryption: s3deploy.ServerSideEncryption.AES_256,\n  cacheControl: [\n    s3deploy.CacheControl.setPublic(),\n    s3deploy.CacheControl.maxAge(Duration.hours(1)),\n  ],\n  accessControl: s3.BucketAccessControl.BUCKET_OWNER_FULL_CONTROL,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutual TLS Authentication in AWS App Mesh\nDESCRIPTION: Demonstrates how to enable mutual TLS authentication for App Mesh virtual nodes using both file-based certificates and SDS-provided certificates. Shows configuration for both server-side validation and client-side certificate provision.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\n\nconst node1 = new appmesh.VirtualNode(this, 'node1', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('node'),\n  listeners: [appmesh.VirtualNodeListener.grpc({\n    port: 80,\n    tls: {\n      mode: appmesh.TlsMode.STRICT,\n      certificate: appmesh.TlsCertificate.file('path/to/certChain', 'path/to/privateKey'),\n      // Validate a file client certificates to enable mutual TLS authentication when a client provides a certificate.\n      mutualTlsValidation: {\n        trust: appmesh.TlsValidationTrust.file('path-to-certificate'),\n      },\n    },\n  })],\n});\n\nconst certificateAuthorityArn = 'arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/12345678-1234-1234-1234-123456789012';\nconst node2 = new appmesh.VirtualNode(this, 'node2', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('node2'),\n  backendDefaults: {\n    tlsClientPolicy: {\n      ports: [8080, 8081],\n      validation: {\n        subjectAlternativeNames: appmesh.SubjectAlternativeNames.matchingExactly('mesh-endpoint.apps.local'),\n        trust: appmesh.TlsValidationTrust.acm([\n          acmpca.CertificateAuthority.fromCertificateAuthorityArn(this, 'certificate', certificateAuthorityArn)]),\n      },\n      // Provide a SDS client certificate when a server requests it and enable mutual TLS authentication.\n      mutualTlsCertificate: appmesh.TlsCertificate.sds('secret_certificate'),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SAML Identity Provider for Cognito User Pool in TypeScript\nDESCRIPTION: This snippet shows how to set up a SAML identity provider for a Cognito User Pool using either a SAML metadata file content or a metadata URL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'Pool');\n\n// specify the metadata as a file content\nnew cognito.UserPoolIdentityProviderSaml(this, 'userpoolIdpFile', {\n  userPool: userpool,\n  metadata: cognito.UserPoolIdentityProviderSamlMetadata.file('my-file-contents'),\n  // Whether to require encrypted SAML assertions from IdP\n  encryptedResponses: true,\n  // The signing algorithm for the SAML requests\n  requestSigningAlgorithm: cognito.SigningAlgorithm.RSA_SHA256,\n  // Enable IdP initiated SAML auth flow\n  idpInitiated: true,\n});\n\n// specify the metadata as a URL\nnew cognito.UserPoolIdentityProviderSaml(this, 'userpoolidpUrl', {\n  userPool: userpool,\n  metadata: cognito.UserPoolIdentityProviderSamlMetadata.url('https://my-metadata-url.com'),\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Metric Units in TableWidget Labels (TypeScript)\nDESCRIPTION: Shows how to enable display of units in metric labels for TableWidget via the showUnitsInLabel property. Dashboard and TableWidget constructs are required. Setting this property to true appends the metric unit to its label.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  // ...\n\n  showUnitsInLabel: true,\n}));\n```\n\n----------------------------------------\n\nTITLE: Enabling Audit Logs for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet configures an OpenSearch domain with various logging options enabled, including audit logs, slow search logs, application logs, and slow index logs. It also enforces HTTPS, enables node-to-node encryption, encryption at rest, and fine-grained access control with a specified master user name, which is a prerequisite for enabling audit logs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n  },\n  logging: {\n    auditLogEnabled: true,\n    slowSearchLogEnabled: true,\n    appLogEnabled: true,\n    slowIndexLogEnabled: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Auto Scaling Group in TypeScript\nDESCRIPTION: This snippet demonstrates the basic creation of an EC2 Auto Scaling Group (ASG) using AWS CDK. It specifies the VPC, instance type (t2.micro), and the machine image (latest Amazon Linux 2). Note that ASGs created this way might implicitly use a Launch Template instead of a Launch Configuration depending on the CDK version and feature flags, due to Launch Configuration deprecation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n\n  // The latest Amazon Linux 2 image\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n});\n```\n\n----------------------------------------\n\nTITLE: General Pattern for Defining Auto Scaling Group Scaling Policies in TypeScript\nDESCRIPTION: This snippet outlines the basic structure for defining an Auto Scaling Group with minimum and maximum capacity, and indicates where various scaling methods would be invoked. It shows the setup of an ASG and includes commented-out calls representing different scaling strategies: `scaleOnMetric` (step scaling), `scaleOnCpuUtilization`/`scaleToTrackMetric` (target tracking), and `scaleOnSchedule` (scheduled scaling).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nconst autoScalingGroup = new autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  minCapacity: 5,\n  maxCapacity: 100\n  // ...\n});\n\n// Then call one of the scaling methods (explained below)\n//\n// autoScalingGroup.scaleOnMetric(...);\n//\n// autoScalingGroup.scaleOnCpuUtilization(...);\n// autoScalingGroup.scaleOnIncomingBytes(...);\n// autoScalingGroup.scaleOnOutgoingBytes(...);\n// autoScalingGroup.scaleOnRequestCount(...);\n// autoScalingGroup.scaleToTrackMetric(...);\n//\n// autoScalingGroup.scaleOnSchedule(...);\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Instance Warmup in AWS CDK Auto Scaling Group\nDESCRIPTION: Sets up Default Instance Warming for an Auto Scaling group to improve CloudWatch metrics used for dynamic scaling. This allows instances to finish warming up before contributing usage data, optimizing performance of scaling policies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  defaultInstanceWarmup: Duration.seconds(5),\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate for Manual DNS Validation - AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates creating an ACM certificate validated via DNS, but without automatic DNS zone management (non-Route53 DNS). The stack will wait for manual DNS record creation. Key parameters: domain name, validation method. Dependencies: aws-cdk-lib/aws-certificatemanager. Input is the domain name and optional validation details; the output is an ACM certificate resource pending manual validation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew acm.Certificate(this, 'Certificate', {\n  domainName: 'hello.example.com',\n  validation: acm.CertificateValidation.fromDns(), // Records must be added manually\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Metric-Based Auto-Scaling to ApplicationLoadBalancedFargateService (TypeScript)\nDESCRIPTION: Configures metric-based auto-scaling for ApplicationLoadBalancedFargateService by adding scaleOnCpuUtilization and scaleOnMemoryUtilization policies to the auto scaling target. This enables the ECS service to scale in and out based on CPU and memory usage thresholds. Prerequisites are an ECS cluster and Application AutoScaling integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  desiredCount: 1,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n});\n\nconst scalableTarget = loadBalancedFargateService.service.autoScaleTaskCount({\n  minCapacity: 1,\n  maxCapacity: 20,\n});\n\nscalableTarget.scaleOnCpuUtilization('CpuScaling', {\n  targetUtilizationPercent: 50,\n});\n\nscalableTarget.scaleOnMemoryUtilization('MemoryScaling', {\n  targetUtilizationPercent: 50,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Fargate-only EKS Cluster\nDESCRIPTION: Creates an EKS cluster that exclusively uses Fargate capacity for running pods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.FargateCluster(this, 'MyCluster', {\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring vCPU Allocation for Managed EC2 Compute Environment in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a managed EC2 ECS Compute Environment for AWS Batch using AWS CDK. It specifies the minimum (minvCpus) and maximum (maxvCpus) number of vCPUs that Batch should maintain and scale up to, respectively. It requires an existing VPC (vpc) and specifies R4 instance class.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.IVpc;\n\nnew batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  instanceClasses: [ec2.InstanceClass.R4],\n  minvCpus: 10,\n  maxvCpus: 100,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Production Grade OpenSearch Domain\nDESCRIPTION: Sets up a production-grade OpenSearch domain with multiple master and data nodes, zone awareness, and logging configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst prodDomain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  capacity: {\n    masterNodes: 5,\n    dataNodes: 20,\n  },\n  ebs: {\n    volumeSize: 20,\n  },\n  zoneAwareness: {\n    availabilityZoneCount: 3,\n  },\n  logging: {\n    slowSearchLogEnabled: true,\n    appLogEnabled: true,\n    slowIndexLogEnabled: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard S3 Origin for CloudFront - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates setting up a CloudFront Distribution with a standard S3 bucket origin using the AWS CDK in TypeScript. It uses the S3BucketOrigin.withOriginAccessControl() helper, which configures Origin Access Control (OAC) automatically for secure access. Requires the aws-cdk-lib libraries and proper instantiation of s3 and cloudfront modules. Parameters: the S3 bucket to use as origin; output is a new Distribution with defaultBehavior. No special constraints, other than recommended use of OAC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket) },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SSM Parameters with Token-Based Names - AWS CDK - TypeScript\nDESCRIPTION: Illustrates how to provision SSM parameters in CDK with parameter names constructed from Tokens, showing the importance of the 'simpleName' property to avoid malformed ARNs. When parameter names contain slashes ('/'), 'simpleName' must be set to false; otherwise, set to true. Required dependencies include aws-cdk-lib/aws-lambda and ssm. Inputs are the parameter name (with or without slash), value, and the 'simpleName' boolean.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst simpleParameter = new ssm.StringParameter(this, 'StringParameter', {\n  // the parameter name doesn't contain any '/'\n  parameterName: 'parameter',\n  stringValue: 'SOME_VALUE',\n  simpleName: true, // set `simpleName` to true\n});\n\ndeclare const func: lambda.IFunction;\nconst nonSimpleParameter = new ssm.StringParameter(this, 'StringParameter', {\n  // the parameter name contains '/'\n  parameterName: `/${func.functionName}/my/app/param`,\n  stringValue: 'SOME_VALUE',\n  simpleName: false, // set `simpleName` to false\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Alarm Using Metric Method in AWS CDK\nDESCRIPTION: Shows an alternative approach to create a CloudWatch Alarm using the metric.createAlarm() method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nfn.metricErrors().createAlarm(this, 'Alarm', {\n  threshold: 100,\n  evaluationPeriods: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring OAuth Resource Servers with Cognito using AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to define custom OAuth scopes via a Cognito resource server, attach them to user pool app clients, and configure client-side usage of these scopes using AWS CDK. Dependencies include the AWS CDK libraries for Cognito. Required parameters are resource server identifier, scope definitions, and proper app client OAuth settings. The code expects that CDK and Cognito libraries are available, and each client is associated with the appropriate scope(s); outputs are the instantiated pool, resource server, and clients with attached scopes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nconst pool = new cognito.UserPool(this, 'Pool');\n\nconst readOnlyScope = new cognito.ResourceServerScope({ scopeName: 'read', scopeDescription: 'Read-only access' });\nconst fullAccessScope = new cognito.ResourceServerScope({ scopeName: '*', scopeDescription: 'Full access' });\n\nconst userServer = pool.addResourceServer('ResourceServer', {\n  identifier: 'users',\n  scopes: [ readOnlyScope, fullAccessScope ],\n});\n\nconst readOnlyClient = pool.addClient('read-only-client', {\n  // ...\n  oAuth: {\n    // ...\n    scopes: [ cognito.OAuthScope.resourceServer(userServer, readOnlyScope) ],\n  },\n});\n\nconst fullAccessClient = pool.addClient('full-access-client', {\n  // ...\n  oAuth: {\n    // ...\n    scopes: [ cognito.OAuthScope.resourceServer(userServer, fullAccessScope) ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting a Metric from CloudWatch Logs in TypeScript\nDESCRIPTION: Helper function that extracts values from JSON-structured log records and emits them as CloudWatch Metrics under a specific namespace and metric name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logGroup: logs.LogGroup;\nlogGroup.extractMetric('$.jsonField', 'Namespace', 'MetricName');\n```\n\n----------------------------------------\n\nTITLE: Putting a Record to an Amazon Data Firehose with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates putting a record into an Amazon Data Firehose delivery stream using EventBridge Scheduler configured with AWS CDK. It assumes an existing `IDeliveryStream`, defines a payload object, creates a `FirehosePutRecord` target with this payload, and sets up a schedule to trigger the target every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as firehose from 'aws-cdk-lib/aws-kinesisfirehose';\ndeclare const deliveryStream: firehose.IDeliveryStream;\n\nconst payload = {\n  Data: \"record\",\n};\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.FirehosePutRecord(deliveryStream, {\n    input: ScheduleTargetInput.fromObject(payload),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Alarm for ACM Certificate DaysToExpiry Metric - AWS CDK - TypeScript\nDESCRIPTION: This code configures an AWS CloudWatch alarm to monitor the DaysToExpiry metric for an ACM certificate using AWS CDK. It provisions a certificate with DNS validation, retrieves the metric, and creates an alarm if the certificate is within 45 days of expiration. Inputs: domain name, hosted zone, certificate config, alarm threshold. Dependencies: aws-cdk-lib/aws-certificatemanager, aws-cdk-lib/aws-cloudwatch, aws-cdk-lib/aws-route53. Output is a CloudWatch alarm resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const myHostedZone: route53.HostedZone;\nconst certificate = new acm.Certificate(this, 'Certificate', {\n  domainName: 'hello.example.com',\n  validation: acm.CertificateValidation.fromDns(myHostedZone),\n});\ncertificate.metricDaysToExpiry().createAlarm(this, 'Alarm', {\n  comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n  evaluationPeriods: 1,\n  threshold: 45, // Automatic rotation happens between 60 and 45 days before expiry\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing Shared SSM Parameters Across Accounts - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to access an SSM parameter shared across AWS accounts using its ARN via the 'fromStringParameterArn()' CDK method. Intended for cross-account environments configured via AWS RAM, the snippet retrieves the shared parameter resource and makes its value available to the consuming account. Dependencies include the AWS CDK ssm module and knowledge of the shared parameter's ARN. Main input is the ARN; output is a StringParameter instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst sharingParameterArn = 'arn:aws:ssm:us-east-1:1234567890:parameter/dummyName';\nconst sharedParam = ssm.StringParameter.fromStringParameterArn(this, 'SharedParam', sharingParameterArn);\n// the value can be accessed via sharedParam.stringValue\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Origin with Origin Access Control (OAC) - AWS CDK - TypeScript\nDESCRIPTION: This example shows how to configure a standard S3 origin with Origin Access Control (OAC) in an AWS CDK CloudFront Distribution. The S3BucketOrigin.withOriginAccessControl() method augments security by creating an S3OriginAccessControl construct with required signing setup. Requires aws-cdk-lib and constructs. Key parameter is the S3 bucket to use as origin. Output is a Distribution with enhanced security via OAC; websites endpoints are not supported for OAC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket) // Automatically creates a S3OriginAccessControl construct\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Looking Up KMS Key by Alias Using AWS CDK in TypeScript\nDESCRIPTION: Performs a context-based lookup of a KMS key using its alias, allowing access to the underlying key's ID and expanded privileges (e.g., calling grant methods). Lookup requires access to the 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam' libraries and writes context info to 'cdk.context.json'. Used when a full key reference (not just the alias) is required.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myKeyLookup = kms.Key.fromLookup(this, 'MyKeyLookup', {\n  aliasName: 'alias/KeyAlias',\n});\n\nconst role = new iam.Role(this, 'MyRole', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n});\nmyKeyLookup.grantEncryptDecrypt(role);\n```\n\n----------------------------------------\n\nTITLE: Adding Internet Gateway to VPC for Private Subnets with Egress using AWS CDK in TypeScript\nDESCRIPTION: This code example shows how to add an internet gateway to a VPC for private subnets with egress using AWS CDK. It creates a VPC and adds an internet gateway with a custom IPv4 destination for subnets of type PRIVATE_WITH_EGRESS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\n\nmyVpc.addInternetGateway({\n  ipv4Destination: '192.168.0.0/16',\n  subnets: [{subnetType: SubnetType.PRIVATE_WITH_EGRESS}],\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with Lambda using AWS CDK in TypeScript\nDESCRIPTION: Demonstrates creating a `HttpLambdaIntegration` for a specified Lambda function (`booksDefaultFn`) and attaching it to an HTTP API route (`/books` with GET method) using AWS CDK. Requires an existing `lambda.Function` instance and the `aws-apigatewayv2` and `aws-apigatewayv2-integrations` CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const booksDefaultFn: lambda.Function;\nconst booksIntegration = new HttpLambdaIntegration('BooksIntegration', booksDefaultFn);\n\nconst httpApi = new apigwv2.HttpApi(this, 'HttpApi');\n\nhttpApi.addRoutes({\n  path: '/books',\n  methods: [ apigwv2.HttpMethod.GET ],\n  integration: booksIntegration,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFront Distribution with ELBv2 Origin using TypeScript\nDESCRIPTION: Shows how to create a CloudFront `Distribution` using an internet-facing Elastic Load Balancing v2 (ELBv2) load balancer as the origin. It initializes an `ApplicationLoadBalancer` within a VPC, ensuring `internetFacing` is true, and then uses this load balancer with `LoadBalancerV2Origin`. Requires existing `ec2.Vpc` (`vpc`) and `elbv2.ApplicationLoadBalancer` (`lb`) instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Creates a distribution from an ELBv2 load balancer\ndeclare const vpc: ec2.Vpc;\n// Create an application load balancer in a VPC. 'internetFacing' must be 'true'\n// for CloudFront to access the load balancer and use it as an origin.\nconst lb = new elbv2.ApplicationLoadBalancer(this, 'LB', {\n  vpc,\n  internetFacing: true,\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.LoadBalancerV2Origin(lb) },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross Account Zone Delegation - Parent Zone Setup in TypeScript\nDESCRIPTION: Sets up the parent hosted zone and creates an IAM role with necessary permissions to allow a different AWS account to manage the subdomain records. This snippet creates the parent zone and the delegation role that will be assumed by the child account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst parentZone = new route53.PublicHostedZone(this, 'HostedZone', {\n  zoneName: 'someexample.com',\n});\nconst crossAccountRole = new iam.Role(this, 'CrossAccountRole', {\n  // The role name must be predictable\n  roleName: 'MyDelegationRole',\n  // The other account\n  assumedBy: new iam.AccountPrincipal('12345678901'),\n  // You can scope down this role policy to be least privileged.\n  // If you want the other account to be able to manage specific records,\n  // you can scope down by resource and/or normalized record names\n  inlinePolicies: {\n    crossAccountPolicy: new iam.PolicyDocument({\n      statements: [\n        new iam.PolicyStatement({\n          sid: 'ListHostedZonesByName',\n          effect: iam.Effect.ALLOW,\n          actions: ['route53:ListHostedZonesByName'],\n          resources: ['*'],\n        }),\n        new iam.PolicyStatement({\n          sid: 'GetHostedZoneAndChangeResourceRecordSets',\n          effect: iam.Effect.ALLOW,\n          actions: ['route53:GetHostedZone', 'route53:ChangeResourceRecordSets'],\n          // This example assumes the RecordSet subdomain.somexample.com\n          // is contained in the HostedZone\n          resources: ['arn:aws:route53:::hostedzone/HZID00000000000000000'],\n          conditions: {\n            'ForAllValues:StringLike': {\n              'route53:ChangeResourceRecordSetsNormalizedRecordNames': [\n                'subdomain.someexample.com',\n              ],\n            },\n          },\n        }),\n      ],\n    }),\n  },\n});\nparentZone.grantDelegation(crossAccountRole);\n```\n\n----------------------------------------\n\nTITLE: Adding a Virtual Gateway Directly to the Mesh - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet adds a virtual gateway directly to an App Mesh mesh resource using the mesh.addVirtualGateway method. It configures an HTTP listener on port 443 with a health check, access log, and assigns a virtual gateway name. Prerequisites: AWS CDK, @aws-cdk/aws-appmesh, and a predeclared mesh. Inputs: health check interval, listener port, access log path, and virtual gateway name. The output is a newly attached virtual gateway resource within the mesh. The listeners property is optional; defaults are provided if omitted.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\n\nconst gateway = mesh.addVirtualGateway('gateway', {\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout'),\n  virtualGatewayName: 'virtualGateway',\n    listeners: [appmesh.VirtualGatewayListener.http({\n      port: 443,\n      healthCheck: appmesh.HealthCheck.http({\n        interval: Duration.seconds(10),\n      }),\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Event Handlers for AppSync Channel Namespaces in TypeScript with AWS CDK\nDESCRIPTION: This snippet demonstrates how to define event handlers for AWS AppSync Channel Namespaces using AWS CDK. Event handlers run custom logic on AWS AppSync's JavaScript runtime. The examples show two ways to specify the handler code: using `Code.fromInline` for embedding code directly within the CDK application, and using `Code.fromAsset` to reference JavaScript code stored in a local file or directory. Both methods require an existing `EventApi` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.EventApi;\n\nnew appsync.ChannelNamespace(this, 'Namespace', {\n  api,\n  // set a handler from inline code\n  code: appsync.Code.fromInline('/* event handler code here.*/'),\n});\n\nnew appsync.ChannelNamespace(this, 'Namespace', {\n  api,\n  // set a handler from an asset\n  code: appsync.Code.fromAsset('directory/function_code.js'),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Scheduled AWS Backup Rule to a Backup Plan - AWS CDK - TypeScript\nDESCRIPTION: Shows how to add a custom backup rule with defined completion and start windows, scheduled using a cron expression, and cold storage migration using the AWS CDK in TypeScript. Requires events and backup CDK modules, as well as a Duration utility. The addRule() method attaches the constructed BackupPlanRule to the plan. Parameters include time windows, scheduleExpression, and moveToColdStorageAfter. Output is an updated backup plan with the rule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\nplan.addRule(new backup.BackupPlanRule({\n  completionWindow: Duration.hours(2),\n  startWindow: Duration.hours(1),\n  scheduleExpression: events.Schedule.cron({ // Only cron expressions are supported\n    day: '15',\n    hour: '3',\n    minute: '30',\n  }),\n  moveToColdStorageAfter: Duration.days(30),\n}));\n```\n\n----------------------------------------\n\nTITLE: DynamoDB Event Source Implementation\nDESCRIPTION: Example implementation of an event source for DynamoDB, showing the bind method implementation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nclass DynamoEventSource implements IEventSource {\n  constructor(table: dynamodb.ITable, options?: DynamoEventSourceOptions) { ... }\n\n  public bind(fn: IFunction) {\n    // ...do your magic\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing Email Address to SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: Demonstrates subscribing a plain email address to an SNS topic using the EmailSubscription class from aws-cdk-lib/aws-sns-subscriptions. The email recipient must confirm the subscription via a verification email before notifications are received. Requires a valid email address and an existing SNS topic instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\nmyTopic.addSubscription(new subscriptions.EmailSubscription('foo@bar.com'));\n```\n\n----------------------------------------\n\nTITLE: EKS Cluster Encryption Using AWS KMS - AWS CDK - TypeScript\nDESCRIPTION: Enables and configures envelope encryption for Kubernetes secrets on EKS using a customer master key (CMK) in AWS KMS. It's only settable at cluster creation time. Both classic Cluster and FargateCluster constructs are demonstrated. Requires @aws-cdk/aws-kms and compatible eks.KubernetesVersion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst secretsKey = new kms.Key(this, 'SecretsKey');\nconst cluster = new eks.Cluster(this, 'MyCluster', {\n  secretsEncryptionKey: secretsKey,\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst secretsKey = new kms.Key(this, 'SecretsKey');\nconst cluster = new eks.FargateCluster(this, 'MyFargateCluster', {\n  secretsEncryptionKey: secretsKey,\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking AWS API with Universal Target in EventBridge Scheduler\nDESCRIPTION: Creates an EventBridge Scheduler that invokes an AWS API (in this case, stopping an RDS cluster) at midnight daily. The schedule uses a cron expression to define the timing and the Universal target to specify the AWS service, action, and input parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.cron({\n    minute: '0',\n    hour: '0',\n  }),\n  target: new targets.Universal({\n    service: 'rds',\n    action: 'stopDBCluster',\n    input: ScheduleTargetInput.fromObject({\n      DbClusterIdentifier: 'my-db',\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Default Parameter Mappings for SQS HTTP API Integration in AWS CDK TypeScript\nDESCRIPTION: Provides examples of the default `apigwv2.ParameterMapping` configurations used implicitly by `HttpSqsIntegration` for different SQS subtypes (SEND_MESSAGE, RECEIVE_MESSAGE, DELETE_MESSAGE, PURGE_QUEUE) in AWS CDK. These mappings define how request data maps to SQS API parameters like QueueUrl, MessageBody, and ReceiptHandle. Requires an `sqs.IQueue` instance and the `aws-apigatewayv2` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\ndeclare const queue: sqs.IQueue;\n\n// SQS_SEND_MESSAGE\nnew apigwv2.ParameterMapping()\n  .custom('QueueUrl', queue.queueUrl)\n  // The `MessageBody` is expected to be in the request body.\n  .custom('MessageBody', '$request.body.MessageBody');\n\n// SQS_RECEIVE_MESSAGE\nnew apigwv2.ParameterMapping()\n  .custom('QueueUrl', queue.queueUrl);\n\n// SQS_DELETE_MESSAGE\nnew apigwv2.ParameterMapping()\n  .custom('QueueUrl', queue.queueUrl)\n  // The `ReceiptHandle` is expected to be in the request body.\n  .custom('ReceiptHandle', '$request.body.ReceiptHandle');\n\n// SQS_PURGE_QUEUE\nnew apigwv2.ParameterMapping()\n  .custom('QueueUrl', queue.queueUrl);\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Multi-AZ with Standby for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure an OpenSearch domain for high availability using Multi-AZ with Standby. It involves enabling zone awareness with a specified availability zone count (3), configuring EBS volume details, and setting `multiAzWithStandbyEnabled` to true within the `capacity` property, along with specifying the number of master and data nodes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_3,\n  ebs: {\n    volumeSize: 10,\n    volumeType: ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3,\n  },\n  zoneAwareness: {\n    enabled: true,\n    availabilityZoneCount: 3,\n  },\n  capacity: {\n    multiAzWithStandbyEnabled: true,\n    masterNodes: 3,\n    dataNodes: 3,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Scaling Auto Scaling Group based on Request Count in TypeScript\nDESCRIPTION: Configures target tracking scaling for an AWS Auto Scaling Group based on the average number of requests per second per instance. This is typically used when the Auto Scaling Group is attached to an Application Load Balancer. The policy adjusts the instance count to keep the request rate near the `targetRequestsPerSecond`. Requires an existing `autoscaling.AutoScalingGroup` attached to an ALB.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.scaleOnRequestCount('LimitRPS', {\n    targetRequestsPerSecond: 1000\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Scheduled Scaling for Auto Scaling Group in TypeScript\nDESCRIPTION: Demonstrates how to configure scheduled scaling actions for an AWS Auto Scaling Group using cron expressions via `autoscaling.Schedule.cron`. This allows changing the `minCapacity`, `maxCapacity`, and `desiredCapacity` at specific times. The examples show scaling out (increasing `minCapacity`) in the morning and allowing scale-in (resetting `minCapacity`) at night. Requires an existing `autoscaling.AutoScalingGroup` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.scaleOnSchedule('PrescaleInTheMorning', {\n  schedule: autoscaling.Schedule.cron({ hour: '8', minute: '0' }),\n  minCapacity: 20,\n});\n\nautoScalingGroup.scaleOnSchedule('AllowDownscalingAtNight', {\n  schedule: autoscaling.Schedule.cron({ hour: '20', minute: '0' }),\n  minCapacity: 1\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Scheduling ECS EC2 Task Run with EventBridge Scheduler in AWS CDK\nDESCRIPTION: Creates an EventBridge Scheduler that runs an EC2 task in an ECS cluster every 60 minutes. The schedule uses a rate expression to define the frequency and targets a specific EC2 task definition within the provided cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.Ec2TaskDefinition;\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(cdk.Duration.minutes(60)),\n  target: new targets.EcsRunEc2Task(cluster, {\n    taskDefinition,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching a Dead Letter Queue to an SNS Subscription in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to attach a provided SQS queue as a dead letter queue (DLQ) to an SNS subscription, improving reliability by capturing unprocessable messages. It creates a queue with specified name and retention period, then passes it as deadLetterQueue to sns.Subscription. Dependencies include sns and sqs constructs as well as Duration from aws-cdk-lib.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic');\nconst dlQueue = new sqs.Queue(this, 'DeadLetterQueue', {\n  queueName: 'MySubscription_DLQ',\n  retentionPeriod: Duration.days(14),\n});\n\nnew sns.Subscription(this, 'Subscription', {\n  endpoint: 'endpoint',\n  protocol: sns.SubscriptionProtocol.LAMBDA,\n  topic,\n  deadLetterQueue: dlQueue,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing IAM Role by ARN - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to use Role.fromRoleArn to import an existing IAM role into an AWS CDK application, with an optional 'mutable' parameter to restrict modifications. This is useful when reusing pre-created roles or integrating with roles managed outside of the CDK. Requires iam module and a valid role ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = iam.Role.fromRoleArn(this, 'Role', 'arn:aws:iam::123456789012:role/MyExistingRole', {\n  // Set 'mutable' to 'false' to use the role as-is and prevent adding new\n  // policies to it. The default is 'true', which means the role may be\n  // modified as part of the deployment.\n  mutable: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppRunner Service with GitHub Source\nDESCRIPTION: Creates an AppRunner service using a GitHub repository as the source with repository-based configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromGitHub({\n    repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n    branch: 'main',\n    configurationSource: apprunner.ConfigurationSourceType.REPOSITORY,\n    connection: apprunner.GitHubConnection.fromConnectionArn('CONNECTION_ARN'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring an Amazon Data Firehose Delivery Stream with Kinesis Data Stream Source (TypeScript)\nDESCRIPTION: This code sample shows how to set up a Firehose delivery stream in the AWS CDK that reads directly from a Kinesis Data Stream using KinesisStreamSource, and delivers the data to a specified destination. Dependencies: @aws-cdk/aws-kinesisfirehose, @aws-cdk/aws-kinesis. Inputs: a newly created Kinesis Stream and a Firehose destination. Outputs: a delivery stream sourced by Kinesis. The snippet assumes proper instantiation of any referenced variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const destination: firehose.IDestination;\nconst sourceStream = new kinesis.Stream(this, 'Source Stream');\n\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  source: new firehose.KinesisStreamSource(sourceStream),\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding SNS Event Destination to SES Configuration Set - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to configure an SES configuration set to publish sending events to an SNS topic using AWS CDK. The addEventDestination method associates a named destination with an SNS Topic for specified email event types. Dependencies include an initialized ConfigurationSet and SNS Topic. This allows external systems to process SES send results.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myConfigurationSet: ses.ConfigurationSet;\ndeclare const myTopic: sns.Topic;\n\nmyConfigurationSet.addEventDestination('ToSns', {\n  destination: ses.EventDestination.snsTopic(myTopic),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Deployment Strategy with Custom Linear Rollout using CDK in TypeScript\nDESCRIPTION: Demonstrates creating an AWS AppConfig Deployment Strategy with a custom linear rollout strategy. It specifies the `growthFactor` (percentage), `deploymentDuration`, and `finalBakeTime` using the `appconfig.RolloutStrategy.linear` factory method and the CDK `Duration` class. Requires the `Duration` class to be imported (e.g., from `aws-cdk-lib`). Assumes `this` is a CDK `Construct`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew appconfig.DeploymentStrategy(this, 'MyDeploymentStrategy', {\n  rolloutStrategy: appconfig.RolloutStrategy.linear({\n    growthFactor: 20,\n    deploymentDuration: Duration.minutes(30),\n    finalBakeTime: Duration.minutes(30),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing a TypeScript Resource Wrapper for Sum (AWS CDK, TypeScript)\nDESCRIPTION: This TypeScript snippet defines a strongly-typed CDK construct, Sum, which uses a custom resource provider to compute the sum of two numbers. The construct prepares the Lambda resource type, code directory, and runtime, then registers a CustomResource with property values for lhs and rhs. It finally exposes the calculated result using Token.asNumber to handle CloudFormation unresolved values. The snippet requires dependencies on constructs, aws-cdk-lib, and assumes a compatible Lambda handler is present at the specified path.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Construct } from 'constructs';\nimport {\n  CustomResource,\n  CustomResourceProvider,\n  CustomResourceProviderRuntime,\n  Token,\n} from 'aws-cdk-lib';\n\nexport interface SumProps {\n  readonly lhs: number;\n  readonly rhs: number;\n}\n\nexport class Sum extends Construct {\n  public readonly result: number;\n\n  constructor(scope: Construct, id: string, props: SumProps) {\n    super(scope, id);\n\n    const resourceType = 'Custom::Sum';\n    const serviceToken = CustomResourceProvider.getOrCreate(this, resourceType, {\n      codeDirectory: `${__dirname}/sum-handler`,\n      runtime: CustomResourceProviderRuntime.NODEJS_18_X,\n    });\n\n    const resource = new CustomResource(this, 'Resource', {\n      resourceType: resourceType,\n      serviceToken: serviceToken,\n      properties: {\n        lhs: props.lhs,\n        rhs: props.rhs\n      }\n    });\n\n    this.result = Token.asNumber(resource.getAtt('Result'));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Repository Pull Access\nDESCRIPTION: Grants an IAM role permission to pull images from an ECR repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('codebuild.amazonaws.com'),\n});\nrepository.grantPull(role);\n```\n\n----------------------------------------\n\nTITLE: Enforcing SSL for SNS Topic Policies in AWS CDK (TypeScript)\nDESCRIPTION: This code example demonstrates how to enforce encryption in transit (SSL/TLS) for SNS topic publishing by setting the enforceSSL property in a TopicPolicy. It assigns publish permissions to an AWS Service Principal and blocks unencrypted connections. Dependencies are sns and iam constructs, with an explicit policy document crafted and assigned.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic');\nconst policyDocument = new iam.PolicyDocument({\n  assignSids: true,\n  statements: [\n    new iam.PolicyStatement({\n      actions: [\"sns:Publish\"],\n      principals: [new iam.ServicePrincipal('s3.amazonaws.com')],\n      resources: [topic.topicArn],\n    }),\n  ],\n});\n\nconst topicPolicy = new sns.TopicPolicy(this, 'Policy', {\n  topics: [topic],\n  policyDocument,\n  enforceSSL: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Bucket as CodePipeline Source (Polling) in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a versioned S3 bucket and configure it as a source stage in an AWS CodePipeline pipeline using the AWS CDK. It defines an S3SourceAction that polls the specified bucket and key for changes, placing the output artifact (`sourceOutput`) for subsequent stages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst sourceBucket = new s3.Bucket(this, 'MyBucket', {\n  versioned: true, // a Bucket used as a source in CodePipeline must be versioned\n});\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.S3SourceAction({\n  actionName: 'S3Source',\n  bucket: sourceBucket,\n  bucketKey: 'path/to/file.zip',\n  output: sourceOutput,\n});\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Mounting FSx Lustre File System to EC2 Instance with User Data in TypeScript\nDESCRIPTION: This extended example demonstrates provisioning an FSx Lustre file system and EC2 instance, then mounting the file system during instance startup using shell User Data. Dependencies include the EC2, FSx, and IAM modules, and an existing VPC. Key parameters involve instance type, machine image version, network settings, and the User Data command sequence that configures Lustre client software, sets permissions, and updates /etc/fstab for persistent mounts. Ensures the EC2 instance can discover and mount the FSx file system automatically on boot.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\ndeclare const vpc: ec2.Vpc;\nconst lustreConfiguration = {\n  deploymentType: fsx.LustreDeploymentType.SCRATCH_2,\n};\n\nconst fs = new fsx.LustreFileSystem(this, 'FsxLustreFileSystem', {\n  lustreConfiguration,\n  storageCapacityGiB: 1200,\n  vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n});\n\nconst inst = new ec2.Instance(this, 'inst', {\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.LARGE),\n  machineImage: new ec2.AmazonLinuxImage({\n    generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,\n  }),\n  vpc,\n  vpcSubnets: {\n    subnetType: ec2.SubnetType.PUBLIC,\n  },\n});\nfs.connections.allowDefaultPortFrom(inst);\n\n// Need to give the instance access to read information about FSx to determine the file system's mount name.\ninst.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonFSxReadOnlyAccess'));\n\nconst mountPath = '/mnt/fsx';\nconst dnsName = fs.dnsName;\nconst mountName = fs.mountName;\n\ninst.userData.addCommands(\n  'set -eux',\n  'yum update -y',\n  'amazon-linux-extras install -y lustre2.10',\n  // Set up the directory to mount the file system to and change the owner to the AL2 default ec2-user.\n  `mkdir -p ${mountPath}`,\n  `chmod 777 ${mountPath}`,\n  `chown ec2-user:ec2-user ${mountPath}`,\n  // Set the file system up to mount automatically on start up and mount it.\n  `echo \"${dnsName}@tcp:/${mountName} ${mountPath} lustre defaults,noatime,flock,_netdev 0 0\" >> /etc/fstab`,\n  'mount -a',\n);\n```\n\n----------------------------------------\n\nTITLE: Cross-Account and Cross-Region EventBridge Rule Setup - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to configure cross-account and cross-region event delivery using the AWS CDK by wiring together repository and project resources across separate stacks and environments. Automatically connects the rule, event buses, and permission stacks between accounts. Requires 'aws-cdk-lib', 'aws-cdk-lib/aws-codecommit', 'aws-cdk-lib/aws-codebuild', and 'aws-cdk-lib/aws-events-targets'. Inputs are AWS account IDs, regions, and CDK stack/app instances for multidomain event integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { App, Stack } from 'aws-cdk-lib';\nimport * as codebuild from 'aws-cdk-lib/aws-codebuild';\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\n\nconst app = new App();\n\nconst account1 = '11111111111';\nconst account2 = '22222222222';\n\nconst stack1 = new Stack(app, 'Stack1', { env: { account: account1, region: 'us-west-1' } });\nconst repo = new codecommit.Repository(stack1, 'Repository', {\n  repositoryName: 'myrepository',\n});\n\nconst stack2 = new Stack(app, 'Stack2', { env: { account: account2, region: 'us-east-1' } });\nconst project = new codebuild.Project(stack2, 'Project', {\n  // ...\n});\n\nrepo.onCommit('OnCommit', {\n  target: new targets.CodeBuildProject(project),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudWatch Alarms for EventBridge Schedule Groups in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to set up CloudWatch alarms for errors specific to a given EventBridge ScheduleGroup using AWS CDK in TypeScript. It includes creating a new ScheduleGroup, configuring an alarm for target errors, and an example for setting an alarm using the default schedule group. Dependencies: aws-cdk-lib/aws-events-scheduler, aws-cdk-lib/aws-cloudwatch. Key parameters include schedule group names, metrics for target errors, and standard CloudWatch alarm thresholds. Inputs are schedule group instances; outputs are CloudWatch Alarm resources for monitoring group-specific failures.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst scheduleGroup = new ScheduleGroup(this, \"ScheduleGroup\", {\n    scheduleGroupName: \"MyScheduleGroup\",\n});\n\nnew cloudwatch.Alarm(this, 'MyGroupErrorAlarm', {\n    metric: scheduleGroup.metricTargetErrors(),\n    evaluationPeriods: 1,\n    threshold: 0\n});\n\n// Or use default group\nconst defaultScheduleGroup = ScheduleGroup.fromDefaultScheduleGroup(this, \"DefaultScheduleGroup\");\nnew cloudwatch.Alarm(this, 'DefaultScheduleGroupErrorAlarm', {\n    metric: defaultScheduleGroup.metricTargetErrors(),\n    evaluationPeriods: 1,\n    threshold: 0\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Source with CloudWatch Events Trigger in TypeScript\nDESCRIPTION: This snippet demonstrates setting up an S3 source action in CodePipeline to trigger via CloudWatch Events instead of polling. It involves creating a CloudTrail Trail to monitor write events for a specific object prefix in the source bucket and configuring the S3SourceAction with `trigger: S3Trigger.EVENTS`. This requires the `aws-cdk-lib/aws-cloudtrail` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as cloudtrail from 'aws-cdk-lib/aws-cloudtrail';\n\ndeclare const sourceBucket: s3.Bucket;\nconst sourceOutput = new codepipeline.Artifact();\nconst key = 'some/key.zip';\nconst trail = new cloudtrail.Trail(this, 'CloudTrail');\ntrail.addS3EventSelector([{\n  bucket: sourceBucket,\n  objectPrefix: key,\n}], {\n  readWriteType: cloudtrail.ReadWriteType.WRITE_ONLY,\n});\nconst sourceAction = new codepipeline_actions.S3SourceAction({\n  actionName: 'S3Source',\n  bucketKey: key,\n  bucket: sourceBucket,\n  output: sourceOutput,\n  trigger: codepipeline_actions.S3Trigger.EVENTS, // default: S3Trigger.POLL\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Detector Model with States and Transitions in TypeScript\nDESCRIPTION: This code demonstrates how to create an AWS IoT Events detector model with input, states, and conditional transitions. It shows how to define warm and cold states with enter/exit actions, set up transitions based on temperature thresholds, and invoke Lambda functions as actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\nimport * as actions from '@aws-cdk/aws-iotevents-actions-alpha';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const func: lambda.IFunction;\n\nconst input = new iotevents.Input(this, 'MyInput', {\n  inputName: 'my_input', // optional\n  attributeJsonPaths: ['payload.deviceId', 'payload.temperature'],\n});\n\nconst warmState = new iotevents.State({\n  stateName: 'warm',\n  onEnter: [{\n    eventName: 'test-enter-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [new actions.LambdaInvokeAction(func)], // optional\n  }],\n  onInput: [{ // optional\n    eventName: 'test-input-event',\n    actions: [new actions.LambdaInvokeAction(func)],\n  }],\n  onExit: [{ // optional\n    eventName: 'test-exit-event',\n    actions: [new actions.LambdaInvokeAction(func)],\n  }],\n});\nconst coldState = new iotevents.State({\n  stateName: 'cold',\n});\n\n// transit to coldState when temperature is less than 15\nwarmState.transitionTo(coldState, {\n  eventName: 'to_coldState', // optional property, default by combining the names of the States\n  when: iotevents.Expression.lt(\n    iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n    iotevents.Expression.fromString('15'),\n  ),\n  executing: [new actions.LambdaInvokeAction(func)], // optional\n});\n// transit to warmState when temperature is greater than or equal to 15\ncoldState.transitionTo(warmState, {\n  when: iotevents.Expression.gte(\n    iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n    iotevents.Expression.fromString('15'),\n  ),\n});\n\nnew iotevents.DetectorModel(this, 'MyDetectorModel', {\n  detectorModelName: 'test-detector-model', // optional\n  description: 'test-detector-model-description', // optional property, default is none\n  evaluationMethod: iotevents.EventEvaluation.SERIAL, // optional property, default is iotevents.EventEvaluation.BATCH\n  detectorKey: 'payload.deviceId', // optional property, default is none and single detector instance will be created and all inputs will be routed to it\n  initialState: warmState,\n});\n```\n\n----------------------------------------\n\nTITLE: KMS Default Key Policy JSON Representation\nDESCRIPTION: Shows the default key policy JSON for a newly created KMS key that allows full access to the root account. This policy is essential for key management and can be set by default using CDK or directly in the AWS Console. The policy permits the root principal to perform all KMS actions on all resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"Effect\": \"Allow\",\n  \"Principal\": {\"AWS\": \"arn:aws:iam::111122223333:root\"},\n  \"Action\": \"kms:*\",\n  \"Resource\": \"*\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Link for Private Integration\nDESCRIPTION: Sets up a VPC Link to enable private integration with resources in a VPC, such as Application Load Balancers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as elb from 'aws-cdk-lib/aws-elasticloadbalancingv2';\nimport { HttpAlbIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst vpc = new ec2.Vpc(this, 'VPC');\nconst alb = new elb.ApplicationLoadBalancer(this, 'AppLoadBalancer', { vpc });\n\nconst vpcLink = new apigwv2.VpcLink(this, 'VpcLink', { vpc });\n\nconst albIntegration = new HttpAlbIntegration('ALBIntegration', alb.listeners[0], {});\n```\n\n----------------------------------------\n\nTITLE: Creating an Encrypted CloudWatch Log Group with KMS in TypeScript\nDESCRIPTION: Creates a CloudWatch Log Group encrypted with a custom KMS key instead of the default AWS encryption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nnew logs.LogGroup(this, 'LogGroup', {\n  encryptionKey: new kms.Key(this, 'Key'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring a Lambda Target with DLQ and Retry Policy in AWS CDK (TypeScript)\nDESCRIPTION: This code defines a Lambda function target for an EventBridge Scheduler with error handling via an SQS dead-letter queue (DLQ) and custom retry policy using AWS CDK in TypeScript. It creates an SQS queue to serve as the DLQ and configures the Lambda target to retry failed invocations up to three times with a maximum event age of 1 minute before sending failed events to the DLQ. Dependencies: aws-cdk-lib/aws-lambda, aws-cdk-lib/aws-sqs, aws-cdk-lib/aws-events-targets, and aws-cdk-lib/core. Inputs include the Lambda function and DLQ settings; output is the configured LambdaInvoke target. Ensure the DLQ and Lambda permissions are set appropriately.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nconst dlq = new sqs.Queue(this, \"DLQ\", {\n    queueName: 'MyDLQ',\n});\n\nconst target = new targets.LambdaInvoke(fn, {\n    deadLetterQueue: dlq,\n    maxEventAge: Duration.minutes(1),\n    retryAttempts: 3\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Basic EventBridge Pipe with SQS Source and Target\nDESCRIPTION: Demonstrates how to create a basic pipe that connects a source SQS queue to a target SQS queue using the Pipe construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an A Record to a Route53 Hosted Zone using AWS CDK\nDESCRIPTION: Shows how to add an A record to a Route53 hosted zone. It specifies the zone and target IP addresses.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecord', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4', '5.6.7.8'),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Ready-Made Daily and Weekly Backup Rules to an AWS Backup Plan - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to add predefined daily and weekly backup rules to a backup plan using the AWS CDK's static BackupPlanRule helpers in TypeScript. No extra configuration is needed; these helpers create rules with standard schedules. Allows quick setup of common backup frequencies for a plan.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\nplan.addRule(backup.BackupPlanRule.daily());\nplan.addRule(backup.BackupPlanRule.weekly());\n```\n\n----------------------------------------\n\nTITLE: Importing IAM Instance Profiles with Associated Roles in AWS CDK\nDESCRIPTION: Imports an existing IAM instance profile with its associated role. This allows you to reference both the instance profile and its role in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n});\n\nconst instanceProfile = iam.InstanceProfile.fromInstanceProfileAttributes(this, 'ImportedInstanceProfile', {\n  instanceProfileArn: 'arn:aws:iam::account-id:instance-profile/MyInstanceProfile',\n  role,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining OpenSearch Domain Access Policy via Constructor in TypeScript\nDESCRIPTION: This snippet demonstrates how to define a custom access policy for an AWS OpenSearch Service domain directly within the CDK `Domain` construct's properties. It grants specific `es:*ESHttpPost` and `es:ESHttpPut*` actions to a specified AWS account principal on all resources within the domain.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  accessPolicies: [\n    new iam.PolicyStatement({\n      actions: ['es:*ESHttpPost', 'es:ESHttpPut*'],\n      effect: iam.Effect.ALLOW,\n      principals: [new iam.AccountPrincipal('123456789012')],\n      resources: ['*'],\n    }),\n  ]\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Flink Application Properties in TypeScript\nDESCRIPTION: Illustrates how to set runtime properties for a Flink application using the propertyGroups option. These properties can be accessed at runtime using the aws-kinesisanalytics-runtime library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-kinesisanalytics-flink-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst flinkApp = new flink.Application(this, 'Application', {\n  propertyGroups: {\n    FlinkApplicationProperties: {\n      inputStreamName: 'my-input-kinesis-stream',\n      outputStreamName: 'my-output-kinesis-stream',\n    },\n  },\n  // ...\n  runtime: flink.Runtime.FLINK_1_20,\n  code: flink.ApplicationCode.fromBucket(bucket, 'my-app.jar'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront Origin Group for Failover using AWS CDK in TypeScript\nDESCRIPTION: This snippet illustrates setting up a CloudFront Origin Group for high availability. It defines a primary origin (S3 bucket with OAC) and a fallback origin (an HTTP endpoint). CloudFront will automatically switch to the fallback origin if the primary is unavailable or returns specific status codes (customized here to 404, defaults are 500, 502, 503, 504). Requires `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: new origins.OriginGroup({\n      primaryOrigin: origins.S3BucketOrigin.withOriginAccessControl(myBucket),\n      fallbackOrigin: new origins.HttpOrigin('www.example.com'),\n      // optional, defaults to: 500, 502, 503 and 504\n      fallbackStatusCodes: [404],\n    }),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Read Permissions to Lambda via Precreated Roles - AWS CDK - TypeScript\nDESCRIPTION: This example demonstrates the workflow of customizing roles, creating a Lambda and S3 bucket, and granting read permissions, in an environment where role and policy creation must be performed manually. Developers use customizeRoles to trigger generation of a report for all required policies, which are then to be implemented out-of-band. Prerequisites include imports from App, Stack, lambda, s3, and iam.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const app: App;\nconst stack = new Stack(app, 'MyStack');\niam.Role.customizeRoles(stack);\n\nconst fn = new lambda.Function(this, 'MyLambda', {\n  code: new lambda.InlineCode('foo'),\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n});\n\nconst bucket = new s3.Bucket(this, 'Bucket');\nbucket.grantRead(fn);\n```\n\n----------------------------------------\n\nTITLE: Creating AppRunner Service with GitHub and API Configuration\nDESCRIPTION: Creates an AppRunner service using a GitHub repository with API-based configuration values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromGitHub({\n    repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n    branch: 'main',\n    configurationSource: apprunner.ConfigurationSourceType.API,\n    codeConfigurationValues: {\n      runtime: apprunner.Runtime.PYTHON_3,\n      port: '8000',\n      startCommand: 'python app.py',\n      buildCommand: 'yum install -y pycairo && pip install -r requirements.txt',\n    },\n    connection: apprunner.GitHubConnection.fromConnectionArn('CONNECTION_ARN'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudWatch Metrics for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up CloudWatch metrics and alarms for an Amazon Data Firehose delivery stream. It creates an alarm that triggers when the incoming bytes exceed 90% of the service limit.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const deliveryStream: firehose.DeliveryStream;\n\n// Alarm that triggers when the per-second average of incoming bytes exceeds 90% of the current service limit\nconst incomingBytesPercentOfLimit = new cloudwatch.MathExpression({\n  expression: 'incomingBytes / 300 / bytePerSecLimit',\n  usingMetrics: {\n    incomingBytes: deliveryStream.metricIncomingBytes({ statistic: cloudwatch.Statistic.SUM }),\n    bytePerSecLimit: deliveryStream.metric('BytesPerSecondLimit'),\n  },\n});\n\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: incomingBytesPercentOfLimit,\n  threshold: 0.9,\n  evaluationPeriods: 3,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Topic Policy and Adding Policy Statements in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to manually create a TopicPolicy for an SNS topic and add policy statements to it via the PolicyDocument. It uses sns and iam constructs, demonstrating granting SNS Subscribe permissions to any principal. Supports advanced scenarios where custom SNS resource policy management is required.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic');\nconst topicPolicy = new sns.TopicPolicy(this, 'TopicPolicy', {\n  topics: [topic],\n});\n\ntopicPolicy.document.addStatements(new iam.PolicyStatement({\n  actions: [\"sns:Subscribe\"],\n  principals: [new iam.AnyPrincipal()],\n  resources: [topic.topicArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Lambda Action with Multiple Inputs and Outputs in CodePipeline (TypeScript)\nDESCRIPTION: Shows how to configure a LambdaInvokeAction with multiple input and output artifacts in an AWS CodePipeline using AWS CDK (TypeScript). Up to 5 inputs and outputs can be specified, allowing for complex data flows through the pipeline. The code expects pre-created Artifact objects and a Lambda function, with outputs being additional Artifact results after Lambda execution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\nconst sourceOutput = new codepipeline.Artifact();\nconst buildOutput = new codepipeline.Artifact();\nconst lambdaAction = new codepipeline_actions.LambdaInvokeAction({\n  actionName: 'Lambda',\n  inputs: [\n    sourceOutput,\n    buildOutput,\n  ],\n  outputs: [\n    new codepipeline.Artifact('Out1'),\n    new codepipeline.Artifact('Out2'),\n  ],\n  lambda: fn,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Queue Encryption Options in TypeScript\nDESCRIPTION: Illustrates how to configure different server-side encryption options for an SQS queue using the `encryption` property. Examples include using an AWS-managed KMS key (`KMS_MANAGED`), a customer-managed KMS key (`KMS` with `encryptionMasterKey`), SQS-managed encryption (`SQS_MANAGED`, the default), and disabling encryption (`UNENCRYPTED`). Requires the `aws-cdk-lib/aws-kms` module if using a custom key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Use managed key\nnew sqs.Queue(this, 'Queue', {\n  encryption: sqs.QueueEncryption.KMS_MANAGED,\n});\n\n// Use custom key\nconst myKey = new kms.Key(this, 'Key');\n\nnew sqs.Queue(this, 'Queue', {\n  encryption: sqs.QueueEncryption.KMS,\n  encryptionMasterKey: myKey,\n});\n\n// Use SQS managed server side encryption (SSE-SQS)\nnew sqs.Queue(this, 'Queue', {\n  encryption: sqs.QueueEncryption.SQS_MANAGED,\n});\n\n// Unencrypted queue\nnew sqs.Queue(this, 'Queue', {\n  encryption: sqs.QueueEncryption.UNENCRYPTED,\n});\n```\n\n----------------------------------------\n\nTITLE: Manually Creating Resource Policies with Custom Policy Documents in AWS CDK\nDESCRIPTION: This snippet shows how to manually create resource policies for a Kinesis stream and a stream consumer using the ResourcePolicy construct. It demonstrates creating a custom policy document and applying it to both stream and stream consumer resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst stream = new kinesis.Stream(this, 'MyStream');\nconst streamConsumer = new kinesis.StreamConsumer(this, 'MyStreamConsumer', {\n  streamConsumerName: 'MyStreamConsumer',\n  stream,\n});\n\n// create a custom policy document\nconst policyDocument = new iam.PolicyDocument({\n  assignSids: true,\n  statements: [\n    new iam.PolicyStatement({\n      actions: ['kinesis:GetRecords'],\n      resources: [stream.streamArn],\n      principals: [new iam.AnyPrincipal()],\n    }),\n  ],\n});\n\n// create a stream resource policy manually\nnew kinesis.ResourcePolicy(this, 'ResourcePolicy', {\n  stream,\n  policyDocument,\n});\n\n// create a stream consumer resource policy manually\nnew kinesis.ResourcePolicy(this, 'ResourcePolicy', {\n  streamConsumer,\n  policyDocument,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Replica Instances to a Neptune Cluster\nDESCRIPTION: Shows two methods to add read replicas to a Neptune cluster: specifying the instance count during cluster creation or adding replicas to an existing cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  instances: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking AWS Step Functions in CodePipeline using AWS CDK (TypeScript)\nDESCRIPTION: Illustrates integration of AWS Step Functions via a StepFunctionInvokeAction in a CodePipeline using AWS CDK TypeScript. The action executes a state machine in response to a pipeline stage, using literal input. The example requires aws-cdk-lib's stepfunctions, codepipeline, and codepipeline_actions modules, and a defined state machine; output is a pipeline stage that triggers the state machine.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as stepfunctions from 'aws-cdk-lib/aws-stepfunctions';\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst startState = new stepfunctions.Pass(this, 'StartState');\nconst simpleStateMachine  = new stepfunctions.StateMachine(this, 'SimpleStateMachine', {\n  definition: startState,\n});\nconst stepFunctionAction = new codepipeline_actions.StepFunctionInvokeAction({\n  actionName: 'Invoke',\n  stateMachine: simpleStateMachine,\n  stateMachineInput: codepipeline_actions.StateMachineInput.literal({ IsHelloWorldExample: true }),\n});\npipeline.addStage({\n  stageName: 'StepFunctions',\n  actions: [stepFunctionAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutual TLS (mTLS) for API Gateway\nDESCRIPTION: Sets up mutual TLS authentication for API Gateway using client certificates stored in S3.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\n\nconst certArn = 'arn:aws:acm:us-east-1:111111111111:certificate';\nconst domainName = 'example.com';\ndeclare const bucket: s3.Bucket;\n\nnew apigwv2.DomainName(this, 'DomainName', {\n  domainName,\n  certificate: acm.Certificate.fromCertificateArn(this, 'cert', certArn),\n  mtls: {\n    bucket,\n    key: 'someca.pem',\n    version: 'version',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Kinesis Firehose Subscription to an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to subscribe a Kinesis Firehose delivery stream to an SNS topic. Requires firehose and sns constructs and a subscriptionRoleArn to grant necessary permissions. This snippet uses sns.Subscription with protocol set to FIREHOSE and configures the endpoint with the deliveryStreamArn. Appropriate for integrating SNS events with streaming analytics pipelines.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as firehose from 'aws-cdk-lib/aws-kinesisfirehose';\n\nconst topic = new sns.Topic(this, 'Topic');\ndeclare const stream: firehose.DeliveryStream;\n\nnew sns.Subscription(this, 'Subscription', {\n  topic,\n  endpoint: stream.deliveryStreamArn,\n  protocol: sns.SubscriptionProtocol.FIREHOSE,\n  subscriptionRoleArn: \"SAMPLE_ARN\", //role with permissions to send messages to a firehose delivery stream\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Organization CloudTrail Trail using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to create a CloudTrail trail that applies to all accounts within an AWS Organization. This is achieved by setting the `isOrganizationTrail` property to `true`. Deployment requires the CDK stack to be deployed in the organization's management account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew cloudtrail.Trail(this, 'OrganizationTrail', {\n  isOrganizationTrail: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the Athena Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import the AWS Athena module from the `aws-cdk-lib`. This import makes the L1 constructs for Athena available under the `athena` namespace for use in defining infrastructure as code. It requires the `aws-cdk-lib` package to be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-athena/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as athena from 'aws-cdk-lib/aws-athena';\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross Account Zone Delegation - Child Zone Setup in TypeScript\nDESCRIPTION: Sets up the subdomain hosted zone in a different AWS account and creates a delegation record in the parent zone. This snippet shows how to import the delegation role from the parent account and set up the cross-account zone delegation record.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst subZone = new route53.PublicHostedZone(this, 'SubZone', {\n  zoneName: 'sub.someexample.com',\n});\n\n// import the delegation role by constructing the roleArn\nconst delegationRoleArn = Stack.of(this).formatArn({\n  region: '', // IAM is global in each partition\n  service: 'iam',\n  account: 'parent-account-id',\n  resource: 'role',\n  resourceName: 'MyDelegationRole',\n});\nconst delegationRole = iam.Role.fromRoleArn(this, 'DelegationRole', delegationRoleArn);\n\n// create the record\nnew route53.CrossAccountZoneDelegationRecord(this, 'delegate', {\n  delegatedZone: subZone,\n  parentHostedZoneName: 'someexample.com', // or you can use parentHostedZoneId\n  delegationRole,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Instance Maintenance Policy for Auto Scaling Group in TypeScript\nDESCRIPTION: Creates an AWS Auto Scaling Group with an instance maintenance policy defined by `minHealthyPercentage` and `maxHealthyPercentage`. This policy controls the capacity range during instance replacement events (like health check failures or instance refresh) to minimize disruption. Dependencies include `ec2.Vpc`, `ec2.InstanceType`, `ec2.MachineImage`, and `autoscaling` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n  maxHealthyPercentage: 200,\n  minHealthyPercentage: 100,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Branches and File Paths using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to use the pushFilter in AWS CDK (TypeScript) to trigger pipeline execution based on both branch and file path filters. Arrays for branches and file paths can include or exclude patterns, with excludes taking priority. Required modules are codepipeline and codepipeline_actions, and pipelineType must be V2. The pipeline starts only for pushes to specified branches and matching file paths.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pushFilter: [{\n        branchesExcludes: ['exclude1', 'exclude2'],\n        branchesIncludes: ['include1', 'include2'],\n        filePathsExcludes: ['/path/to/exclude1', '/path/to/exclude2'],\n        filePathsIncludes: ['/path/to/include1', '/path/to/include1'],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a SAML Provider with AWS CDK (TypeScript)\nDESCRIPTION: Defines a SAML 2.0 identity provider in AWS using the CDK IAM module. This sets up federated access between a SAML-compliant IdP and AWS. Metadata is sourced from a file using `SamlMetadataDocument.fromFile`. Requires saml metadata XML; outputs a SAML provider construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew iam.SamlProvider(this, 'Provider', {\\n  metadataDocument: iam.SamlMetadataDocument.fromFile('/path/to/saml-metadata-document.xml'),\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Capacity for Global Secondary Indexes in DynamoDB TableV2 (Provisioned Billing) in TypeScript\nDESCRIPTION: This snippet illustrates how to configure specific read and write capacities for Global Secondary Indexes (GSIs) when the DynamoDB TableV2 is set up with provisioned billing (`dynamodb.Billing.provisioned`). If capacity is not specified for a GSI, it inherits the settings from the main table's billing configuration. It uses `dynamodb.Capacity.fixed` and `dynamodb.Capacity.autoscaled`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.provisioned({\n    readCapacity: dynamodb.Capacity.fixed(10),\n    writeCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 10 }),\n  }),\n  globalSecondaryIndexes: [\n    {\n      indexName: 'gsi1',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      readCapacity: dynamodb.Capacity.fixed(15),\n      // write capacity inherited from billing - dynamodb.Capacity.autoscaled({ maxCapacity: 10 })\n    },\n    {\n      indexName: 'gsi2',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      writeCapacity: dynamodb.Capacity.autoscaled({ minCapacity: 5, maxCapacity: 20 }),\n      // read capacity inherited from billing - dynamodb.Capacity.fixed(10)\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an HTTPS Redirect with AWS CDK Route 53 Patterns in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of the AWS CDK Route 53 patterns library to set up an HTTPS redirect from one domain (\\'foo.example.com\\') to another (\\'bar.example.com\\'). The construct programmatically provisions an S3 bucket, CloudFront distribution, Route 53 alias records, and an ACM certificate, all orchestrated by the CDK. Key parameters include \\'recordNames\\' for the domains to redirect, \\'targetDomain\\' as the redirect destination, and \\'zone\\' referencing the hosted zone; all resources are provisioned according to the CDK input, and the certificate is created in the US East (N. Virginia) region unless provided, with no manual resource setup required.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-patterns/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew patterns.HttpsRedirect(this, 'Redirect', {\n  recordNames: ['foo.example.com'],\n  targetDomain: 'bar.example.com',\n  zone: route53.HostedZone.fromHostedZoneAttributes(this, 'HostedZone', {\n    hostedZoneId: 'ID',\n    zoneName: 'example.com',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Geolocation Routing in Route53 using AWS CDK\nDESCRIPTION: Shows how to enable geolocation routing for A records in Route53. It demonstrates setting up records for continent, country, subdivision, and a default record.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\n// continent\nnew route53.ARecord(this, 'ARecordGeoLocationContinent', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.0', '5.6.7.0'),\n  geoLocation: route53.GeoLocation.continent(route53.Continent.EUROPE),\n});\n\n// country\nnew route53.ARecord(this, 'ARecordGeoLocationCountry', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.1', '5.6.7.1'),\n  geoLocation: route53.GeoLocation.country('DE'), // Germany\n});\n\n// subdivision\nnew route53.ARecord(this, 'ARecordGeoLocationSubDividion', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.2', '5.6.7.2'),\n  geoLocation: route53.GeoLocation.subdivision('WA'), // Washington\n});\n\n// default (wildcard record if no specific record is found)\nnew route53.ARecord(this, 'ARecordGeoLocationDefault', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.3', '5.6.7.3'),\n  geoLocation: route53.GeoLocation.default(),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding NAT Gateway Route with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates creating a `NatGateway` associated with a specific subnet and VPC, configuring its connectivity type to PRIVATE and assigning a specific private IP address. It then adds a default IPv4 route (`0.0.0.0/0`) to a `RouteTable` targeting the NAT Gateway using the `Route` construct, enabling instances in private subnets to initiate outbound traffic. Dependencies implicitly include `@aws-cdk/aws-ec2` constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst myVpc = new VpcV2(this, 'Vpc');\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {\n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PRIVATE_ISOLATED });\n\nconst natgw = new NatGateway(this, 'NatGW', {\n  subnet: subnet,\n  vpc: myVpc,\n  connectivityType: NatConnectivityType.PRIVATE,\n  privateIpAddress: '10.0.0.42',\n});\nnew Route(this, 'NatGwRoute', {\n  routeTable,\n  destination: '0.0.0.0/0',\n  target: { gateway: natgw },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Sending CloudTrail Events to CloudWatch Logs using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to configure a CloudTrail trail to send events to an Amazon CloudWatch Logs LogGroup using the AWS CDK. It enables the integration via `sendToCloudWatchLogs: true` and sets a specific log retention period using `cloudWatchLogsRetention` with a value from `logs.RetentionDays`. A new LogGroup is created by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst trail = new cloudtrail.Trail(this, 'CloudTrail', {\n  sendToCloudWatchLogs: true,\n  cloudWatchLogsRetention: logs.RetentionDays.FOUR_MONTHS,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring KMS-Managed Encryption for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet demonstrates configuring server-side encryption with an AWS-managed KMS key (SSE-KMS) for an AWS Glue S3 Table using AWS CDK. This is done by setting the `encryption` property to `glue.TableEncryption.KMS_MANAGED`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.KMS_MANAGED,\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with Auto Mode Implicitly Enabled in TypeScript\nDESCRIPTION: Shows how to create an EKS cluster with Auto Mode implicitly enabled, which is the default behavior when no capacity-related properties are specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksAutoCluster', {\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Aliases to a KMS Key Using AWS CDK in TypeScript\nDESCRIPTION: Demonstrates how to associate multiple aliases with a single KMS key resource using AWS CDK. The example creates a key and then adds two aliases, 'alias/foo' and 'alias/bar', for easier reference within AWS services. Aliases are useful for logical naming and updating key references without altering the key's ARN. Requires the kms module from aws-cdk-lib.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\nkey.addAlias('alias/foo');\nkey.addAlias('alias/bar');\n```\n\n----------------------------------------\n\nTITLE: Configuring Step Scaling with Multiple Datapoints Evaluation in TypeScript\nDESCRIPTION: This snippet shows how to refine step scaling by requiring multiple metric datapoints to breach a threshold before triggering a scaling action. It uses `evaluationPeriods` to define the time window and `datapointsToAlarm` to specify the number of breaching datapoints within that window needed to initiate scaling, helping to smooth out temporary metric fluctuations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const capacity: ScalableAttribute;\ndeclare const cpuUtilization: cloudwatch.Metric;\n\ncapacity.scaleOnMetric('ScaleToCPUWithMultipleDatapoints', {\n  metric: cpuUtilization,\n  scalingSteps: [\n    { upper: 10, change: -1 },\n    { lower: 50, change: +1 },\n    { lower: 70, change: +3 },\n  ],\n\n  // if the cpuUtilization metric has a period of 1 minute, then data points\n  // in the last 10 minutes will be evaluated\n  evaluationPeriods: 10,\n\n  // Only trigger a scaling action when 6 datapoints out of the last 10 are\n  // breaching. If this is left unspecified, then ALL datapoints in the \n  // evaluation period must be breaching to trigger a scaling action\n  datapointsToAlarm: 6\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding an EC2 Instance Endpoint in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates adding an EC2 instance as an endpoint to a Global Accelerator Listener's Endpoint Group using the AWS CDK. It configures the endpoint with a weight of 128 and enables client IP preservation. It assumes that `listener` (a `globalaccelerator.Listener`) and `instance` (an `ec2.Instance`) CDK constructs are already defined. Requires the `aws-globalaccelerator`, `aws-ec2`, and `aws-globalaccelerator-endpoints` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const listener: globalaccelerator.Listener;\ndeclare const instance: ec2.Instance;\n\nlistener.addEndpointGroup('Group', {\n  endpoints: [\n    new ga_endpoints.InstanceEndpoint(instance, {\n      weight: 128,\n      preserveClientIp: true,\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Egress-Only Internet Gateway to VPC using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to add an egress-only internet gateway to a VPC using the AWS CDK. It creates a VPC with IPv6 support, a route table, and a subnet, then adds the egress-only internet gateway with a specific destination and subnet filter.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc',{\n      primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n      secondaryAddressBlocks: [IpAddresses.amazonProvidedIpv6({\n      cidrBlockName: 'AmazonProvided',\n    })]\n    });\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  ipv6CidrBlock: new IpCidr('2001:db8:1::/64'),\n  subnetType: SubnetType.PRIVATE });\n\nmyVpc.addEgressOnlyInternetGateway({\n  subnets: [{subnetType: SubnetType.PRIVATE}],\n  destination: '::/60',\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Stage for API Gateway v2 HTTP API using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to create a custom stage for an existing HttpApi using the HttpStage construct, assigning the name 'beta' and setting a description. Required dependencies: aws-cdk-lib/aws-apigatewayv2. Inputs: reference to an existing HttpApi, stageName, description. Outputs: new stage available at a specific API URL suffix. Omitting stageName will result in the creation of the $default stage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: apigwv2.HttpApi;\n\nnew apigwv2.HttpStage(this, 'Stage', {\n  httpApi: api,\n  stageName: 'beta',\n  description: 'My Stage',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing IAM Instance Profiles by ARN in AWS CDK\nDESCRIPTION: Imports an existing IAM instance profile using its Amazon Resource Name (ARN). This allows you to reference and use an existing instance profile in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nconst instanceProfile = iam.InstanceProfile.fromInstanceProfileArn(this, 'ImportedInstanceProfile', 'arn:aws:iam::account-id:instance-profile/MyInstanceProfile');\n```\n\n----------------------------------------\n\nTITLE: Enabling Spam Dropping in SES Receipt Rule Set - AWS CDK - TypeScript\nDESCRIPTION: This snippet configures an SES receipt rule set to automatically drop emails detected as spam by setting the dropSpam property to true. The construct adds a Lambda action that halts further processing for such messages. Dependencies include AWS CDK's SES module. The feature prevents spam emails from being delivered or processed further.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.ReceiptRuleSet(this, 'RuleSet', {\n  dropSpam: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Protecting New Instances from Scale-In for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet shows how to protect newly launched instances within an AWS Auto Scaling Group from being terminated during scale-in events using the AWS CDK. It initializes an `AutoScalingGroup` and sets the `newInstancesProtectedFromScaleIn` property to `true`. Dependencies include declared variables for `vpc`, `instanceType`, and `machineImage`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  newInstancesProtectedFromScaleIn: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Associating Lambda@Edge with Additional CloudFront Behaviors using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to associate a Lambda@Edge function with specific cache behaviors (not just the default). This example demonstrates adding a Lambda@Edge function to an `additionalBehaviors` entry during distribution creation (for `ORIGIN_REQUEST` event, including the request body) and adding another association after creation using `addBehavior` (for `VIEWER_RESPONSE` event).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// Associating a Lambda@Edge function with additional behaviors.\n\ndeclare const myFunc: cloudfront.experimental.EdgeFunction;\n// assigning at Distribution creation\ndeclare const myBucket: s3.Bucket;\nconst myOrigin = new origins.S3Origin(myBucket);\nconst myDistribution = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: myOrigin },\n  additionalBehaviors: {\n    'images/*': {\n      origin: myOrigin,\n      edgeLambdas: [\n        {\n          functionVersion: myFunc.currentVersion,\n          eventType: cloudfront.LambdaEdgeEventType.ORIGIN_REQUEST,\n          includeBody: true, // Optional - defaults to false\n        },\n      ],\n    },\n  },\n});\n\n// assigning after creation\nmyDistribution.addBehavior('images/*', myOrigin, {\n  edgeLambdas: [\n    {\n      functionVersion: myFunc.currentVersion,\n      eventType: cloudfront.LambdaEdgeEventType.VIEWER_RESPONSE,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Initiating Cross-Account/Cross-Region VPC Peering (TypeScript)\nDESCRIPTION: Demonstrates how the requestor VPC initiates a peering connection with an acceptor VPC in a different AWS account (and potentially a different region). It requires importing the acceptor VPC's attributes using `VpcV2.fromVpcV2Attributes`, including its VPC ID, CIDR block, region, and owner account ID. Crucially, the ARN of the IAM role created in the acceptor account (`acceptorRoleArn`) must be provided in the `peerRoleArn` property when calling `requestorVpc.createPeeringConnection`. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\n\nconst acceptorVpc = VpcV2.fromVpcV2Attributes(this, 'acceptorVpc', {\n      vpcId: 'vpc-XXXX',\n      vpcCidrBlock: '10.0.0.0/16',\n      region: 'us-east-2',\n      ownerAccountId: '111111111111',\n    });\n\nconst acceptorRoleArn = 'arn:aws:iam::111111111111:role/VpcPeeringRole';\n\nconst requestorVpc = new VpcV2(this, 'VpcB', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n});\n\nconst peeringConnection = requestorVpc.createPeeringConnection('crossAccountCrossRegionPeering', {\n  acceptorVpc: acceptorVpc,\n  peerRoleArn: acceptorRoleArn,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enforcing IMDSv2 on an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet demonstrates how to enforce the use of Instance Metadata Service Version 2 (IMDSv2) for instances within a specific AWS Auto Scaling Group using the AWS CDK. It initializes an `AutoScalingGroup` and sets the `requireImdsv2` property to `true`. Dependencies include declared variables for `vpc`, `instanceType`, and `machineImage`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  requireImdsv2: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTP2 Route with Detailed Match Criteria - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet adds an HTTP2 route to a virtual router with granular matching based on exact path, HTTP method, protocol, multiple headers, and query parameters. It uses appmesh.RouteSpec.http2 and supports complex match specifications, such as required headers (must both match), and query parameter matches. Dependencies are AWS CDK, the appropriate App Mesh modules, and virtual router and node declarations. Inputs include path, method, protocol, headers, and query parameters; the output is a highly-specific HTTP2 route in the mesh. Limitations: All specified fields must match for the route to be selected.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-http2', {\n  routeSpec: appmesh.RouteSpec.http2({\n    weightedTargets: [\n      {\n        virtualNode: node,\n      },\n    ],\n    match: {\n      path: appmesh.HttpRoutePathMatch.exactly('/exact'),\n      method: appmesh.HttpRouteMethod.POST,\n      protocol: appmesh.HttpRouteProtocol.HTTPS,\n      headers: [\n        // All specified headers must match for the route to match.\n        appmesh.HeaderMatch.valueIs('Content-Type', 'application/json'),\n        appmesh.HeaderMatch.valueIsNot('Content-Type', 'application/json'),\n      ],\n      queryParameters: [\n        // All specified query parameters must match for the route to match.\n        appmesh.QueryParameterMatch.valueIs('query-field', 'value')\n      ],\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting and Consuming CodeBuild Variables in TypeScript Pipeline\nDESCRIPTION: This snippet demonstrates how a CodeBuild action can export variables defined within its build process for consumption by subsequent actions in the pipeline. The buildspec defines `exported-variables` under `env` and sets their values during the build phase (e.g., `export MY_VAR=\"some value\"`). A subsequent CodeBuildAction accesses this variable using `buildAction.variable('MY_VAR')`, referencing the variable name and the producing action. An optional `variablesNamespace` can be defined on the producing action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst sourceOutput = new codepipeline.Artifact();\nconst buildAction = new codepipeline_actions.CodeBuildAction({\n  actionName: 'Build1',\n  input: sourceOutput,\n  project: new codebuild.PipelineProject(this, 'Project', {\n    buildSpec: codebuild.BuildSpec.fromObject({\n      version: '0.2',\n      env: {\n        'exported-variables': [\n          'MY_VAR',\n        ],\n      },\n      phases: {\n        build: {\n          commands: 'export MY_VAR=\"some value\"',\n        },\n      },\n    }),\n  }),\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\ndeclare const project: codebuild.PipelineProject;\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    MyVar: {\n      value: buildAction.variable('MY_VAR'),\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudTrail S3 Data Event Logging using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to configure a CloudTrail trail to log specific S3 data events (data plane operations) using the `addS3EventSelector` method. It adds an event selector for a specific S3 bucket (`bucket`) and object prefix (`bar/`). Requires `aws-s3` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst trail = new cloudtrail.Trail(this, 'MyAmazingCloudTrail');\ndeclare const bucket: s3.Bucket;\n\n// Adds an event selector to the bucket foo\ntrail.addS3EventSelector([{\n  bucket,\n  objectPrefix: 'bar/',\n}]);\n```\n\n----------------------------------------\n\nTITLE: Running ECS Task with EventBridge Rule and Task Tagging in TypeScript\nDESCRIPTION: This snippet creates a scheduled event rule that runs an ECS task every hour. It demonstrates how to set up the EcsTask target, propagate tags from the task definition, and add custom tags to the triggered task.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(\n  new targets.EcsTask({\n    cluster: cluster,\n    taskDefinition: taskDefinition,\n    propagateTags: ecs.PropagatedTagSource.TASK_DEFINITION,\n    tags: [\n      {\n        key: 'my-tag',\n        value: 'my-tag-value',\n      },\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling Cold Storage for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet shows how to enable Cold Storage for an OpenSearch domain by setting the `coldStorageEnabled` property to `true`. Enabling Cold Storage requires UltraWarm storage to be configured first, as demonstrated by the inclusion of `warmNodes` and `warmInstanceType` in the `capacity` configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  capacity: {\n    masterNodes: 2,\n    warmNodes: 2,\n    warmInstanceType: 'ultrawarm1.medium.search',\n  },\n  coldStorageEnabled: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudTrail Lambda Data Event Logging using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a CloudTrail trail to log data events for specific AWS Lambda functions using the `addLambdaEventSelector` method. It creates a sample Lambda function and then adds it to the trail's event selectors. Requires `aws-lambda` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst trail = new cloudtrail.Trail(this, 'MyAmazingCloudTrail');\nconst amazingFunction = new lambda.Function(this, 'AnAmazingFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: \"hello.handler\",\n  code: lambda.Code.fromAsset(\"lambda\"),\n});\n\n// Add an event selector to log data events for the provided Lambda functions.\ntrail.addLambdaEventSelector([ amazingFunction ]);\n```\n\n----------------------------------------\n\nTITLE: Creating and Specifying IAM Roles for AWS Firehose with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to create IAM service roles for a Firehose delivery stream and its destination using AWS CDK in TypeScript. Both roles are configured to allow Amazon Data Firehose to assume them (via trust policy on 'firehose.amazonaws.com'), and then are explicitly assigned to the destination and the delivery stream. Dependencies: AWS CDK (aws-cdk-lib), modules such as 'aws-cdk-lib/aws-iam', 'aws-cdk-lib/aws-s3', and 'aws-cdk-lib/aws-kinesisfirehose'. Inputs include S3 bucket and role constructs; outputs are the configured delivery stream and destination resources. Roles must have proper trust policies; without them, creation will fail. This snippet is limited to delivery streams using the S3 destination and roles but can be generalized.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Create service roles for the delivery stream and destination.\n// These can be used for other purposes and granted access to different resources.\n// They must include the Amazon Data Firehose service principal in their trust policies.\n// Two separate roles are shown below, but the same role can be used for both purposes.\nconst deliveryStreamRole = new iam.Role(this, 'Delivery Stream Role', {\n  assumedBy: new iam.ServicePrincipal('firehose.amazonaws.com'),\n});\nconst destinationRole = new iam.Role(this, 'Destination Role', {\n  assumedBy: new iam.ServicePrincipal('firehose.amazonaws.com'),\n});\n\n// Specify the roles created above when defining the destination and delivery stream.\ndeclare const bucket: s3.Bucket;\nconst destination = new firehose.S3Bucket(bucket, { role: destinationRole });\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: destination,\n  role: deliveryStreamRole,\n});\n```\n\n----------------------------------------\n\nTITLE: CloudFront Cache Invalidation with S3 Deployment\nDESCRIPTION: Implements a CloudFront cache invalidation step after S3 deployment using CodeBuild. Creates a build project that uses AWS CLI to invalidate the CloudFront distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n// Create the build project that will invalidate the cache\nconst invalidateBuildProject = new codebuild.PipelineProject(this, `InvalidateProject`, {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands:[\n          'aws cloudfront create-invalidation --distribution-id ${CLOUDFRONT_ID} --paths \"/*\"',\n          // Choose whatever files or paths you'd like, or all files as specified here\n        ],\n      },\n    },\n  }),\n  environmentVariables: {\n    CLOUDFRONT_ID: { value: distribution.distributionId },\n  },\n});\n\n// Add Cloudfront invalidation permissions to the project\nconst distributionArn = `arn:aws:cloudfront::${this.account}:distribution/${distribution.distributionId}`;\ninvalidateBuildProject.addToRolePolicy(new iam.PolicyStatement({\n  resources: [distributionArn],\n  actions: [\n    'cloudfront:CreateInvalidation',\n  ],\n}));\n\n// Create the pipeline (here only the S3 deploy and Invalidate cache build)\nconst deployBucket = new s3.Bucket(this, 'DeployBucket');\nconst deployInput = new codepipeline.Artifact();\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  stages: [\n    // ...\n    {\n      stageName: 'Deploy',\n      actions: [\n        new codepipeline_actions.S3DeployAction({\n          actionName: 'S3Deploy',\n          bucket: deployBucket,\n          input: deployInput,\n          runOrder: 1,\n        }),\n        new codepipeline_actions.CodeBuildAction({\n          actionName: 'InvalidateCache',\n          project: invalidateBuildProject,\n          input: deployInput,\n          runOrder: 2,\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting SES Verified Domain for Cognito UserPool Email - AWS CDK - TypeScript\nDESCRIPTION: Configures the SES email integration to use a verified sending domain, sparing the need for individual email address verification. Dependencies include SES domain verification and Cognito CDK. Key parameters: 'sesVerifiedDomain', 'sesRegion', 'fromEmail', 'fromName', and 'replyTo'. Output is a UserPool using a verified domain for email identity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  email: cognito.UserPoolEmail.withSES({\n    sesRegion: 'us-east-1',\n    fromEmail: 'noreply@myawesomeapp.com',\n    fromName: 'Awesome App',\n    replyTo: 'support@myawesomeapp.com',\n    sesVerifiedDomain: 'myawesomeapp.com',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront Distribution Logging using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to enable access logging for a CloudFront distribution. The first example demonstrates the simplest configuration where CDK creates a new S3 bucket automatically. The second example shows more detailed configuration: logging to a specific existing S3 bucket (requiring `OBJECT_WRITER` ownership), setting a log file prefix, and enabling cookie logging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n// Configure logging for Distributions\n\n// Simplest form - creates a new bucket and logs to it.\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n  enableLogging: true,\n});\n\n// You can optionally log to a specific bucket, configure whether cookies are logged, and give the log files a prefix.\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n  enableLogging: true, // Optional, this is implied if logBucket is specified\n  logBucket: new s3.Bucket(this, 'LogBucket', {\n    objectOwnership: s3.ObjectOwnership.OBJECT_WRITER,\n  }),\n  logFilePrefix: 'distribution-access-logs/',\n  logIncludesCookies: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning Private Certificates with ACM PCA - AWS CDK - TypeScript\nDESCRIPTION: This code requests a private SSL/TLS certificate from ACM using a Private Certificate Authority (PCA) in AWS CDK. Inputs include domain name, optional SANs, reference to a PCA ARN, and optionally a key algorithm. Outputs a validated, private ACM certificate. Dependencies: aws-cdk-lib/aws-certificatemanager, aws-cdk-lib/aws-acmpca. No validation (DNS/email) is required for private certificates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as acmpca from 'aws-cdk-lib/aws-acmpca';\n\nnew acm.PrivateCertificate(this, 'PrivateCertificate', {\n  domainName: 'test.example.com',\n  subjectAlternativeNames: ['cool.example.com', 'test.example.net'], // optional\n  certificateAuthority: acmpca.CertificateAuthority.fromCertificateAuthorityArn(this, 'CA',\n    'arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/023077d8-2bfa-4eb0-8f22-05c96deade77'),\n  keyAlgorithm: acm.KeyAlgorithm.RSA_2048, // optional, default algorithm is RSA_2048\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTPS Subscription to an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to subscribe an HTTPS endpoint to an SNS topic using the addSubscription method. It requires the sns and subscriptions constructs from aws-cdk-lib/aws-sns and aws-cdk-lib/aws-sns-subscriptions, respectively. The UrlSubscription class is used to specify the HTTPS endpoint URL. The example expects a topic instance and results in HTTP notifications to the provided URL when SNS messages are published.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.addSubscription(new subscriptions.UrlSubscription('https://foobar.com/'));\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Transit Gateway in TypeScript\nDESCRIPTION: Shows how to create a minimal deployable Transit Gateway using the TransitGateway construct. By default, it creates a Transit Gateway with a default route table and automatic associations and propagations enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront Origin Group for Media Quality Based Failover using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates configuring a CloudFront Origin Group specifically for media quality-based failover using AWS Elemental MediaPackageV2 endpoints. It sets up primary and fallback origins using `origins.HttpOrigin` pointing to MediaPackageV2 URLs and specifies `cloudfront.OriginSelectionCriteria.MEDIA_QUALITY_BASED` as the selection criteria. Requires `aws-cdk-lib/aws-cloudfront` and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: new origins.OriginGroup({\n      primaryOrigin: new origins.HttpOrigin(\"<AWS Elemental MediaPackageV2 origin 1>\"),\n      fallbackOrigin: new origins.HttpOrigin(\"<AWS Elemental MediaPackageV2 origin 2>\"),\n      fallbackStatusCodes: [404],\n      selectionCriteria: cloudfront.OriginSelectionCriteria.MEDIA_QUALITY_BASED,\n    }),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule with Event Matchers for S3 Events - AWS CDK - TypeScript\nDESCRIPTION: Defines an EventBridge rule that matches S3 events based on object size, storage class, event source region, and uses advanced matchers like prefix, exact string, and exclusion. This showcases use of the Match class in event patterns for precise filtering. Dependencies are 'aws-cdk-lib/aws-events'. Key properties include size, source-storage-class, source, and region. Inputs are event property values; output is an EventBridge Rule resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst rule = new events.Rule(this, 'rule', {\n  eventPattern: {\n    detail: {\n      object: {\n        // Matchers may appear at any level\n        size: events.Match.greaterThan(1024),\n      },\n\n      // 'OR' condition\n      'source-storage-class': events.Match.anyOf(\n        events.Match.prefix('GLACIER'),\n        events.Match.exactString('DEEP_ARCHIVE'),\n      ),\n    },\n\n    // If you prefer, you can use a low level array of strings, as directly consumed by EventBridge\n    source: ['aws.s3'],\n\n    region: events.Match.anythingButPrefix('us-gov'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Composite Alarm in AWS CDK\nDESCRIPTION: Shows how to create a composite alarm combining multiple alarms using logical operators and rules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alarm1: cloudwatch.Alarm;\ndeclare const alarm2: cloudwatch.Alarm;\ndeclare const alarm3: cloudwatch.Alarm;\ndeclare const alarm4: cloudwatch.Alarm;\n\nconst alarmRule = cloudwatch.AlarmRule.anyOf(\n  cloudwatch.AlarmRule.allOf(\n    cloudwatch.AlarmRule.anyOf(\n      alarm1,\n      cloudwatch.AlarmRule.fromAlarm(alarm2, cloudwatch.AlarmState.OK),\n      alarm3,\n    ),\n    cloudwatch.AlarmRule.not(cloudwatch.AlarmRule.fromAlarm(alarm4, cloudwatch.AlarmState.INSUFFICIENT_DATA)),\n  ),\n  cloudwatch.AlarmRule.fromBoolean(false),\n);\n\nnew cloudwatch.CompositeAlarm(this, 'MyAwesomeCompositeAlarm', {\n  alarmRule,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: This snippet initializes a new Amazon SNS topic using the AWS CDK in TypeScript. It requires the aws-cdk-lib/aws-sns package and expects a CDK construct (such as a Stack or Construct) as the context for instantiation. The resulting topic can be used for adding subscriptions or publishing messages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\n```\n\n----------------------------------------\n\nTITLE: Enabling Cognito User Pool Deletion Protection using AWS CDK - TypeScript\nDESCRIPTION: This snippet enables deletion protection on a Cognito user pool to prevent accidental resource deletion. Dependencies include AWS CDK Cognito libraries. The only parameter is deletionProtection set to true; output is a user pool resource with deletion protection enabled (disabled by default).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'UserPool', {\n  // ...\n  deletionProtection: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Role with SAML Console Access Principal (TypeScript)\nDESCRIPTION: Defines a role in AWS IAM that enables SAML SSO for both API and Management Console access. Uses `SamlConsolePrincipal` for the `assumedBy` property. Requires a SAML provider construct. Input is the provider, output is a new IAM Role configured for SAML Console assumption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst provider = new iam.SamlProvider(this, 'Provider', {\\n  metadataDocument: iam.SamlMetadataDocument.fromFile('/path/to/saml-metadata-document.xml'),\\n});\\nnew iam.Role(this, 'Role', {\\n  assumedBy: new iam.SamlConsolePrincipal(provider),\\n});\n```\n\n----------------------------------------\n\nTITLE: Monitoring GameLift FlexMatch with CloudWatch Alarms in TypeScript\nDESCRIPTION: This snippet shows how to set up CloudWatch monitoring for GameLift FlexMatch. It creates an alarm based on the ratio of failed to passed rule evaluations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const matchmakingRuleSet: gamelift.MatchmakingRuleSet;\n// Alarm that triggers when the per-second average of not placed matches exceed 10%\nconst ruleEvaluationRatio = new cloudwatch.MathExpression({\n  expression: '1 - (ruleEvaluationsPassed / ruleEvaluationsFailed)',\n  usingMetrics: {\n    ruleEvaluationsPassed: matchmakingRuleSet.metricRuleEvaluationsPassed({ statistic: cloudwatch.Statistic.SUM }),\n    ruleEvaluationsFailed: matchmakingRuleSet.metric('ruleEvaluationsFailed'),\n  },\n});\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: ruleEvaluationRatio,\n  threshold: 0.1,\n  evaluationPeriods: 3,\n});\n```\n\n----------------------------------------\n\nTITLE: Asserting Annotations in AWS CDK Template Testing\nDESCRIPTION: Demonstrates how to use the Annotations class to assert the presence of errors, warnings, and info messages in CDK stacks, including support for Matchers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// import { Annotations } from '@aws-cdk/assertions';\n\nAnnotations.fromStack(stack).hasError(\n  '/Default/Foo',\n  'we do not want a Foo::Bar resource',\n);\n\nAnnotations.fromStack(stack).hasError(\n  '/Default/Foo',\n  Match.stringLikeRegexp('.*Foo::Bar.*'),\n);\n```\n\n----------------------------------------\n\nTITLE: Asserting Definitions for All Resources of a Type in TypeScript\nDESCRIPTION: Illustrates using `allResources()` to assert that *all* resources of a specified type match the provided resource definition (including `Properties`, `DependsOn`, etc.). It performs deep partial matching by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.allResources('Foo::Bar', {\n  Properties: { Lorem: 'Ipsum' },\n  DependsOn: [ 'Waldo', 'Fred' ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Route for VPC Peering Connection with AWS CDK (TypeScript)\nDESCRIPTION: Illustrates configuring routing after establishing a VPC peering connection using AWS CDK. It creates two VPCs, establishes a peering connection, creates a `RouteTable` in the requestor VPC, and then uses `routeTable.addRoute` to add a route. The route's destination is the CIDR block of the acceptor VPC (`10.0.0.0/16`), and the target gateway is the `peeringConnection` object, enabling traffic from the requestor to the acceptor VPC. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\n\nconst acceptorVpc = new VpcV2(this, 'VpcA', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/16'),\n});\n\nconst requestorVpc = new VpcV2(this, 'VpcB', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n});\n\nconst peeringConnection = requestorVpc.createPeeringConnection('peeringConnection', {\n  acceptorVpc: acceptorVpc,\n});\n\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: requestorVpc,\n});\n\nrouteTable.addRoute('vpcPeeringRoute', '10.0.0.0/16', { gateway: peeringConnection });\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Cross-Account Access to KMS-encrypted Secret - AWS CDK TypeScript\nDESCRIPTION: Provides an example of giving another AWS account permission to read a secret encrypted with a KMS CMK. Shows AccountPrincipal usage and automatic updating of both Secret and KMS Key resource policies to permit cross-account access. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-iam, aws-cdk-lib/aws-kms. Expects valid AWS account ID and initialized encryptionKey.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst otherAccount = new iam.AccountPrincipal('1234');\nconst key = new kms.Key(this, 'KMS');\nconst secret = new secretsmanager.Secret(this, 'Secret', { encryptionKey: key });\nsecret.grantRead(otherAccount);\n```\n\n----------------------------------------\n\nTITLE: Assigning Public IP Addresses to ECS Tasks in TypeScript\nDESCRIPTION: This snippet shows how to assign public IP addresses to ECS tasks when using the EcsTask target. It demonstrates setting the assignPublicIp flag and specifying the subnet type for Fargate tasks.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(\n  new targets.EcsTask({\n    cluster,\n    taskDefinition,\n    assignPublicIp: true,\n    subnetSelection: { subnetType: ec2.SubnetType.PUBLIC },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Lambda Blue-Green Deployments with CodeDeploy\nDESCRIPTION: Sets up a Lambda function with CodeDeploy for blue-green deployments using aliases and versions. Configures linear deployment with 10% traffic shift every minute.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst lambdaCode = lambda.Code.fromCfnParameters();\nconst func = new lambda.Function(this, 'Lambda', {\n  code: lambdaCode,\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n});\n// used to make sure each CDK synthesis produces a different Version\nconst version = func.currentVersion;\nconst alias = new lambda.Alias(this, 'LambdaAlias', {\n  aliasName: 'Prod',\n  version,\n});\n\nnew codedeploy.LambdaDeploymentGroup(this, 'DeploymentGroup', {\n  alias,\n  deploymentConfig: codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE,\n});\n```\n\n----------------------------------------\n\nTITLE: Auto Scaling ElastiCache Redis Shards (Node Groups) in TypeScript\nDESCRIPTION: This snippet shows how to configure autoscaling for the number of node groups (shards) in an ElastiCache Redis replication group. It creates a `ScalableTarget` specifying the `ELASTICACHE` service namespace, the `elasticache:replication-group:NodeGroups` dimension, and the resource ID of the replication group. Target tracking scaling is then applied to keep the `ELASTICACHE_PRIMARY_ENGINE_CPU_UTILIZATION` metric at 20%.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst shardsScalableTarget = new appscaling.ScalableTarget(this, 'ElastiCacheRedisShardsScalableTarget', {\n  serviceNamespace: appscaling.ServiceNamespace.ELASTICACHE,\n  scalableDimension: 'elasticache:replication-group:NodeGroups',\n  minCapacity: 2,\n  maxCapacity: 10,\n  resourceId: 'replication-group/main-cluster',\n});\n\nshardsScalableTarget.scaleToTrackMetric('ElastiCacheRedisShardsCPUUtilization', {\n  targetValue: 20,\n  predefinedMetric: appscaling.PredefinedMetric.ELASTICACHE_PRIMARY_ENGINE_CPU_UTILIZATION,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Running a Canary on a VPC in AWS CDK\nDESCRIPTION: Demonstrates how to configure a Synthetics canary to run within a VPC. This allows monitoring of services that may be internal to a specific VPC by specifying the vpc property with the desired VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const vpc: ec2.IVpc;\nnew synthetics.Canary(this, 'Vpc Canary', {\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  vpc,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Kinesis Stream with External KMS Key - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates providing a custom KMS key for stream encryption. It creates a kms.Key construct and ties it to the stream, specifying both encryption as kinesis.StreamEncryption.KMS and encryptionKey. Requires aws-cdk-lib, kinesis, kms modules. Inputs are the KMS key and encryption properties; output is an encrypted Stream using the specified external key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\n\nnew kinesis.Stream(this, 'MyEncryptedStream', {\n  encryption: kinesis.StreamEncryption.KMS,\n  encryptionKey: key,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AWS Managed Config Rule for Access Key Rotation in TypeScript\nDESCRIPTION: Demonstrates how to create an AWS managed Config rule that checks if access keys are rotated within a specified number of days. It uses the ACCESS_KEYS_ROTATED identifier and sets custom input parameters and execution frequency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// https://docs.aws.amazon.com/config/latest/developerguide/access-keys-rotated.html\nnew config.ManagedRule(this, 'AccessKeysRotated', {\n  identifier: config.ManagedRuleIdentifiers.ACCESS_KEYS_ROTATED,\n  inputParameters: {\n    maxAccessKeyAge: 60, // default is 90 days\n  },\n\n  // default is 24 hours\n  maximumExecutionFrequency: config.MaximumExecutionFrequency.TWELVE_HOURS,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic AutoScaling Capacity Configuration in TypeScript\nDESCRIPTION: This snippet shows the initial step for enabling autoscaling on a resource. It retrieves a `ScalableAttribute` object by calling `autoScaleCapacity` on a scalable resource and specifies the minimum and maximum capacity limits. Subsequent calls like `scaleOnMetric`, `scaleToTrackMetric`, or `scaleOnSchedule` would be made on the `capacity` object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const resource: SomeScalableResource;\n\nconst capacity = resource.autoScaleCapacity({\n  minCapacity: 5,\n  maxCapacity: 100\n});\n\n// Then call a method to enable metric scaling and/or schedule scaling\n// (explained below):\n//\n// capacity.scaleOnMetric(...);\n// capacity.scaleToTrackMetric(...);\n// capacity.scaleOnSchedule(...);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating VPC-enabled OpenSearch Domain\nDESCRIPTION: Configures an OpenSearch domain within a VPC with zone awareness and specific capacity settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'Vpc');\nconst domainProps: DomainProps = {\n  version: EngineVersion.OPENSEARCH_1_0,\n  removalPolicy: RemovalPolicy.DESTROY,\n  vpc,\n  zoneAwareness: {\n    enabled: true,\n  },\n  capacity: {\n    dataNodes: 2,\n  },\n};\nnew Domain(this, 'Domain', domainProps);\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication Flows for a Cognito App Client in TypeScript\nDESCRIPTION: This snippet demonstrates configuring an AWS Cognito App Client to support specific authentication flows. It enables both Secure Remote Password (SRP) and standard username-and-password authentication by setting the `userSrp` and `userPassword` properties within the `authFlows` configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'pool');\npool.addClient('app-client', {\n  authFlows: {\n    userPassword: true,\n    userSrp: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a LogQueryWidget for Logs Insights Results (TypeScript)\nDESCRIPTION: Demonstrates creating a LogQueryWidget that displays the results of a Logs Insights query using log group names and custom query lines. Requires Dashboard and LogQueryWidget from aws-cdk-lib/aws-cloudwatch. Query lines are combined automatically for the widget, and view can be set to TABLE for tabular display.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.LogQueryWidget({\n  logGroupNames: ['my-log-group'],\n  view: cloudwatch.LogQueryVisualizationType.TABLE,\n  // The lines will be automatically combined using '\\n|'.\n  queryLines: [\n    'fields @message',\n    'filter @message like /Error/',\n  ]\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Batch Job Permissions with CDK\nDESCRIPTION: TypeScript code demonstrating how to set up an ECS job definition, job queue, and grant submission permissions using AWS CDK. Includes compute environment configuration and IAM user permission setup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nconst ecsJob = new batch.EcsJobDefinition(this, 'JobDefn', {\n  container: new batch.EcsEc2ContainerDefinition(this, 'containerDefn', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n  }),\n});\n\nconst queue = new batch.JobQueue(this, 'JobQueue', {\n  computeEnvironments: [{\n    computeEnvironment: new batch.ManagedEc2EcsComputeEnvironment(this, 'managedEc2CE', {\n      vpc,\n    }),\n    order: 1,\n  }],\n  priority: 10,\n});\n\nconst user = new iam.User(this, 'MyUser');\necsJob.grantSubmitJob(user, queue);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Security Groups and Subnets for QueueProcessingFargateService (TypeScript)\nDESCRIPTION: Shows how to specify custom securityGroups and taskSubnets when deploying a QueueProcessingFargateService, allowing fine-grained control over networking and security. The example assigns a private, isolated subnet type and a security group, which are required to be defined in advance. Prerequisites include a VPC, security group, and ECS cluster using the aws-cdk ECS constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const securityGroup: ec2.SecurityGroup;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  vpc,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  securityGroups: [securityGroup],\n  taskSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Network Load Balanced Fargate Service in AWS CDK\nDESCRIPTION: Creates an ECS service on Fargate with multiple Network Load Balancers, each with dedicated listeners and target groups.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.NetworkMultipleTargetGroupsFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  loadBalancers: [\n    {\n      name: 'lb1',\n      listeners: [\n        {\n          name: 'listener1',\n        },\n      ],\n    },\n    {\n      name: 'lb2',\n      listeners: [\n        {\n          name: 'listener2',\n        },\n      ],\n    },\n  ],\n  targetGroups: [\n    {\n      containerPort: 80,\n      listener: 'listener1',\n    },\n    {\n      containerPort: 90,\n      listener: 'listener2',\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting Amplify App to CodeCommit Source in TypeScript\nDESCRIPTION: Creates an Amplify application with AWS CodeCommit as the source code provider. This example shows how to set up a CodeCommit repository and connect it to an Amplify app with necessary IAM permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\n\nconst repository = new codecommit.Repository(this, 'Repo', {\n  repositoryName: 'my-repo',\n});\n\nconst amplifyApp = new amplify.App(this, 'App', {\n  sourceCodeProvider: new amplify.CodeCommitSourceCodeProvider({ repository }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Pre-Token Generation Lambda Trigger with Version Specification in TypeScript\nDESCRIPTION: This code snippet shows how to add a pre-token generation Lambda trigger to a Cognito User Pool with a specific Lambda version (V2.0).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const userpool: cognito.UserPool;\ndeclare const preTokenGenerationFn: lambda.Function;\n\nuserpool.addTrigger(cognito.UserPoolOperation.PRE_TOKEN_GENERATION_CONFIG, preTokenGenerationFn, cognito.LambdaVersion.V2_0);\n```\n\n----------------------------------------\n\nTITLE: Using Cross-Region ACM Certificate for CloudFront Distribution using TypeScript\nDESCRIPTION: Shows an experimental feature allowing the use of an ACM certificate created in a different region (`us-east-1`) for a CloudFront distribution deployed in another region (`us-east-2`). This requires enabling the `crossRegionReferences` property (set to `true`) on both the stack containing the certificate (`stack1`) and the stack containing the distribution (`stack2`). It involves creating the certificate in `stack1` and referencing it in the `Distribution` definition in `stack2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\nimport * as route53 from 'aws-cdk-lib/aws-route53';\n\ndeclare const app: App;\n\nconst stack1 = new Stack(app, 'Stack1', {\n  env: {\n    region: 'us-east-1',\n  },\n  crossRegionReferences: true,\n});\nconst cert = new acm.Certificate(stack1, 'Cert', {\n  domainName: '*.example.com',\n  validation: acm.CertificateValidation.fromDns(route53.PublicHostedZone.fromHostedZoneId(stack1, 'Zone', 'Z0329774B51CGXTDQV3X')),\n});\n\nconst stack2 = new Stack(app, 'Stack2', {\n  env: {\n    region: 'us-east-2',\n  },\n  crossRegionReferences: true,\n});\nnew cloudfront.Distribution(stack2, 'Distribution', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('example.com'),\n  },\n  domainNames: ['dev.example.com'],\n  certificate: cert,\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Certificate for Domain in Amplify in TypeScript\nDESCRIPTION: Shows how to specify a custom ACM certificate when configuring a custom domain for an Amplify application. This allows using a certificate that may have been created outside of Amplify.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const customCertificate: acm.Certificate;\ndeclare const amplifyApp: amplify.App;\n\nconst domain = amplifyApp.addDomain('example.com', {\n  customCertificate, // set your custom certificate\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Signals on ECS with CloudWatch Agent in Replica Mode\nDESCRIPTION: A TypeScript implementation that demonstrates how to set up AWS CloudWatch Application Signals for ECS services. The code creates a CloudWatch Agent as a separate replica service and configures application services to connect to it using service connect endpoints. It includes the necessary security group rules, port mappings, and environment variable overrides required for Application Signals functionality.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-applicationsignals-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Construct } from 'constructs';\nimport * as appsignals from '@aws-cdk/aws-applicationsignals-alpha';\nimport * as cdk from 'aws-cdk-lib';\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\nimport { PrivateDnsNamespace } from 'aws-cdk-lib/aws-servicediscovery';\n\nclass MyStack extends cdk.Stack {\n  public constructor(scope?: Construct, id?: string, props: cdk.StackProps = {}) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'TestVpc', {});\n    const cluster = new ecs.Cluster(this, 'TestCluster', { vpc });\n    const dnsNamespace = new PrivateDnsNamespace(this, 'Namespace', {\n      vpc,\n      name: 'local',\n    });\n    const securityGroup = new ec2.SecurityGroup(this, 'ECSSG', { vpc });\n    securityGroup.addIngressRule(securityGroup, ec2.Port.tcpRange(0, 65535));\n\n    // Define Task Definition for CloudWatch agent (Replica)\n    const cwAgentTaskDefinition = new ecs.FargateTaskDefinition(this, 'CloudWatchAgentTaskDefinition', {});\n\n    new appsignals.CloudWatchAgentIntegration(this, 'CloudWatchAgentIntegration', {\n      taskDefinition: cwAgentTaskDefinition,\n      containerName: 'ecs-cwagent',\n      enableLogging: false,\n      cpu: 128,\n      memoryLimitMiB: 64,\n      portMappings: [\n        {\n          name: 'cwagent-4316',\n          containerPort: 4316,\n          hostPort: 4316,\n        },\n        {\n          name: 'cwagent-2000',\n          containerPort: 2000,\n          hostPort: 2000,\n        },\n      ],\n    });\n\n    // Create the CloudWatch Agent replica service with service connect\n    new ecs.FargateService(this, 'CloudWatchAgentService', {\n      cluster: cluster,\n      taskDefinition: cwAgentTaskDefinition,\n      securityGroups: [securityGroup],\n      serviceConnectConfiguration: {\n        namespace: dnsNamespace.namespaceArn,\n        services: [\n          {\n            portMappingName: 'cwagent-4316',\n            dnsName: 'cwagent-4316-http',\n            port: 4316,\n          },\n          {\n            portMappingName: 'cwagent-2000',\n            dnsName: 'cwagent-2000-http',\n            port: 2000,\n          },\n        ],\n      },\n      desiredCount: 1,\n    });\n\n    // Define Task Definition for user application\n    const sampleAppTaskDefinition = new ecs.FargateTaskDefinition(this, 'SampleAppTaskDefinition', {});\n\n    sampleAppTaskDefinition.addContainer('app', {\n      image: ecs.ContainerImage.fromRegistry('test/sample-app'),\n      cpu: 0,\n      memoryLimitMiB: 512,\n    });\n\n    // Overwrite environment variables to connect to the CloudWatch Agent service just created\n    new appsignals.ApplicationSignalsIntegration(this, 'ApplicationSignalsIntegration', {\n      taskDefinition: sampleAppTaskDefinition,\n      instrumentation: {\n        sdkVersion: appsignals.PythonInstrumentationVersion.V0_8_0,\n      },\n      serviceName: 'sample-app',\n      overrideEnvironments: [\n        {\n          name: appsignals.CommonExporting.OTEL_AWS_APPLICATION_SIGNALS_EXPORTER_ENDPOINT,\n          value: 'http://cwagent-4316-http:4316/v1/metrics',\n        },\n        {\n          name: appsignals.TraceExporting.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT,\n          value: 'http://cwagent-4316-http:4316/v1/traces',\n        },\n        {\n          name: appsignals.TraceExporting.OTEL_TRACES_SAMPLER_ARG,\n          value: 'endpoint=http://cwagent-2000-http:2000',\n        },\n      ],\n    });\n\n    // Create ECS Service with service connect configuration\n    new ecs.FargateService(this, 'MySampleApp', {\n      cluster: cluster,\n      taskDefinition: sampleAppTaskDefinition,\n      serviceConnectConfiguration: {\n        namespace: dnsNamespace.namespaceArn,\n      },\n      desiredCount: 1,\n    });\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Associating and Propagating AWS Transit Gateway Route Tables (AWS CDK TypeScript)\nDESCRIPTION: Shows how to associate and propagate AWS Transit Gateway route tables when attaching a VPC using AWS CDK in TypeScript. Uses associationRouteTable and propagationRouteTables parameters to automatically create associations and route propagations. Users must provide references to TransitGatewayRouteTable constructs; inputs include VPCs, subnets, and route tables. Outputs are attachments wired with the specified route association and propagations for comprehensive network routing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst myVpc = new VpcV2(this, 'Vpc');\nconst subnet1 = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\n\nconst subnet2 = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.1.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\n\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\nconst associationRouteTable = transitGateway.addRouteTable('AssociationRouteTable');\nconst propagationRouteTable1 = transitGateway.addRouteTable('PropagationRouteTable1');\nconst propagationRouteTable2 = transitGateway.addRouteTable('PropagationRouteTable2');\n\n// Create an attachment with automatically created association + propagations\nconst attachmentWithRoutes = transitGateway.attachVpc('VpcAttachment', {\n  vpc: myVpc, \n  subnets: [subnet1, subnet2],\n  associationRouteTable: associationRouteTable,\n  propagationRouteTables: [propagationRouteTable1, propagationRouteTable2],\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling IAM Authentication for Neptune\nDESCRIPTION: Shows how to create a Neptune cluster with IAM authentication enabled and grant specific Neptune database permissions to an IAM role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'Cluster', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  iamAuthentication: true, // Optional - will be automatically set if you call grantConnect() or grant().\n});\nconst role = new iam.Role(this, 'DBRole', { assumedBy: new iam.AccountPrincipal(this.account) });\n// Use one of the following statements to grant the role the necessary permissions\ncluster.grantConnect(role); // Grant the role neptune-db:* access to the DB\ncluster.grant(role, 'neptune-db:ReadDataViaQuery', 'neptune-db:WriteDataViaQuery'); // Grant the role the specified actions to the DB\n```\n\n----------------------------------------\n\nTITLE: Adding Internet Gateway to VPC with Custom Destination using AWS CDK in TypeScript\nDESCRIPTION: This code example shows how to add an internet gateway to a VPC with a custom outbound destination IP range using AWS CDK. It creates a VPC, a public subnet, and adds an internet gateway with a specific IPv4 destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\n\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC });\n\nmyVpc.addInternetGateway({\n  ipv4Destination: '192.168.0.0/16',\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Typed SSM String Parameters - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to retrieve a strongly-typed SSM parameter using AWS-specific parameter types (e.g., AWS EC2 AMI IDs) in a CDK application. It uses 'valueForTypedStringParameterV2' to access an SSM parameter with a specific type for downstream type validation or conversion. Dependencies include the AWS CDK ssm module and ParameterValueType enum. The main inputs are the scope, parameter name, and required AWS parameter type; output is the value associated with the parameter, validated as the requested type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nssm.StringParameter.valueForTypedStringParameterV2(this, '/My/Public/Parameter', ssm.ParameterValueType.AWS_EC2_IMAGE_ID);\n```\n\n----------------------------------------\n\nTITLE: Using a Custom IAM Role for Cross-Account Actions\nDESCRIPTION: Shows how to use a custom IAM role for cross-account pipeline actions instead of the automatically generated role. This provides more control over the permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// Explicitly pass in a `role` when creating an action.\ndeclare const stage: codepipeline.IStage;\ndeclare const templatePath: codepipeline.ArtifactPath;\nstage.addAction(new codepipeline_actions.CloudFormationCreateUpdateStackAction({\n  templatePath,\n  adminPermissions: false,\n  stackName: Stack.of(this).stackName,\n  actionName: 'cloudformation-create-update',\n  // ...\n  role: iam.Role.fromRoleArn(this, 'ActionRole', '...'),\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Classic Load Balancer with AutoScalingGroup - AWS CDK - TypeScript\nDESCRIPTION: This snippet initializes a classic Elastic Load Balancer in the specified VPC, enables internet-facing mode, defines a health check, attaches an AutoScalingGroup as the target, and configures a listener for external traffic. Dependencies include ec2, elb, and autoscaling constructs from aws-cdk-lib. Inputs include VPC, AutoScalingGroup, and configuration parameters; outputs are the created load balancer and its attached resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticloadbalancing/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\nconst lb = new elb.LoadBalancer(this, 'LB', {\n  vpc,\n  internetFacing: true,\n  healthCheck: {\n    port: 80,\n  },\n});\n\ndeclare const myAutoScalingGroup: autoscaling.AutoScalingGroup;\nlb.addTarget(myAutoScalingGroup);\nlb.addListener({\n  externalPort: 80,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Glue S3 Table with Partition Keys in TypeScript\nDESCRIPTION: This snippet demonstrates how to define partition keys for an AWS Glue S3 Table using AWS CDK to improve query performance. It specifies partition keys (`year`, `month`) with their respective data types (`glue.Schema.SMALL_INT`) using the `partitionKeys` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  partitionKeys: [{\n    name: 'year',\n    type: glue.Schema.SMALL_INT,\n  }, {\n    name: 'month',\n    type: glue.Schema.SMALL_INT,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Firewall Domain Lists in TypeScript\nDESCRIPTION: Demonstrates three methods of creating firewall domain lists: from a list of strings, from an S3 URL, and from a local asset file. It also shows how to import an existing or AWS managed domain list.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-route53resolver-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst blockList = new route53resolver.FirewallDomainList(this, 'BlockList', {\n  domains: route53resolver.FirewallDomains.fromList(['bad-domain.com', 'bot-domain.net']),\n});\n\nconst s3List = new route53resolver.FirewallDomainList(this, 'S3List', {\n  domains: route53resolver.FirewallDomains.fromS3Url('s3://bucket/prefix/object'),\n});\n\nconst assetList = new route53resolver.FirewallDomainList(this, 'AssetList', {\n  domains: route53resolver.FirewallDomains.fromAsset('/path/to/domains.txt'),\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// AWSManagedDomainsMalwareDomainList in us-east-1\nconst malwareList = route53resolver.FirewallDomainList.fromFirewallDomainListId(\n  this,\n  'Malware',\n  'rslvr-fdl-2c46f2ecbfec4dcc',\n);\n```\n\n----------------------------------------\n\nTITLE: Handling Dummy Lookup Values for SSM Parameter References - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates logic for handling cases where a looked-up SSM parameter yields a dummy value due to the parameter not being found at synthesis time. It checks the output for the stub ('dummy-value'), formats a fallback ARN if dummy, and otherwise uses the looked-up value directly. This is critical for resources like SNS topics requiring valid ARNs. The code requires ssm and sns modules, and takes parameter name as input, adjusting outputs as needed for downstream CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst arnLookup = ssm.StringParameter.valueFromLookup(this, '/my/topic/arn');\nlet arnLookupValue: string;\nif (arnLookup.includes('dummy-value')) {\n\tarnLookupValue = this.formatArn({\n\tservice: 'sns',\n\tresource: 'topic',\n\tresourceName: arnLookup,\n\t});\n\n} else {\n\tarnLookupValue = arnLookup;\n}\n\nsns.Topic.fromTopicArn(this, 'Topic', arnLookupValue);\n```\n\n----------------------------------------\n\nTITLE: Enabling Capacity Rebalancing for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable Capacity Rebalancing for an AWS Auto Scaling Group using the AWS CDK. When enabled, Auto Scaling attempts to replace Spot Instances at high risk of interruption with new ones. It initializes an `AutoScalingGroup` and sets the `capacityRebalance` property to `true`. Dependencies include declared variables for `vpc`, `instanceType`, and `machineImage`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  capacityRebalance: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Preventing IAM Role Creation via customizeRoles - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to prevent the AWS CDK from creating any IAM roles or policies within a given stack scope by using iam.Role.customizeRoles. Instead, CDK will generate a policy report for manual creation. Needs an instance of Stack and the iam library. It is suited for environments with external compliance requirements or restricted role creation permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stack: Stack;\niam.Role.customizeRoles(stack);\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Load Balanced EC2 Service in AWS CDK\nDESCRIPTION: Creates an ECS service on EC2 behind a Network Load Balancer. Configures memory limits and environment variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedEcsService = new ecsPatterns.NetworkLoadBalancedEc2Service(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('test'),\n    environment: {\n      TEST_ENVIRONMENT_VARIABLE1: \"test environment variable 1 value\",\n      TEST_ENVIRONMENT_VARIABLE2: \"test environment variable 2 value\",\n    },\n  },\n  desiredCount: 2,\n  minHealthyPercent: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a CodeBuild Fleet with Attribute-Based Compute in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS CodeBuild fleet configured with attribute-based compute. Instead of selecting a specific instance type, it specifies desired attributes like vCPUs, memory, disk space, and machine type. CodeBuild will then choose the most cost-effective instance type that meets these criteria.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Size } from 'aws-cdk-lib';\n\nconst fleet = new codebuild.Fleet(this, 'MyFleet', {\n  baseCapacity: 1,\n  computeType: codebuild.FleetComputeType.ATTRIBUTE_BASED,\n  environmentType: codebuild.EnvironmentType.LINUX_CONTAINER,\n  computeConfiguration: {\n    vCpu: 2,\n    memory: Size.gibibytes(4),\n    disk: Size.gibibytes(10),\n    machineType: codebuild.MachineType.GENERAL,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking API Destination with EventBridge Rule in TypeScript\nDESCRIPTION: This snippet creates an external API destination that is invoked every hour using an EventBridge rule. It demonstrates how to set up a connection with API key authorization and create an API destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = new events.Connection(this, 'Connection', {\n  authorization: events.Authorization.apiKey('x-api-key', SecretValue.secretsManager('ApiSecretName')),\n  description: 'Connection with API Key x-api-key',\n});\n\nconst destination = new events.ApiDestination(this, 'Destination', {\n  connection,\n  endpoint: 'https://example.com',\n  description: 'Calling example.com with API key x-api-key',\n});\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(Duration.minutes(1)),\n  targets: [new targets.ApiDestination(destination)],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset Hash for NodejsFunction in TypeScript\nDESCRIPTION: This snippet demonstrates how to set a custom asset hash for a NodejsFunction, which can be useful for controlling asset invalidation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    assetHash: 'my-custom-hash',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom RouteTable and SubnetV2 with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates initializing a `VpcV2`, creating a custom `RouteTable` associated with it, and then creating a `SubnetV2` that uses this custom route table within an AWS CDK application. It specifies the subnet's availability zone, IPv4 CIDR block, and sets its type to PRIVATE_ISOLATED. Dependencies include implicitly importing necessary constructs from AWS CDK libraries like `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst myVpc = new VpcV2(this, 'Vpc');\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {\n  vpc: myVpc,\n  routeTable,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PRIVATE_ISOLATED,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual Approval Action in AWS CodePipeline with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a manual approval action within a CodePipeline stage using AWS CDK in TypeScript. This snippet shows specifying notification topics, notification emails, additional information, and timeout options for the action, and indicates how to retrieve the underlying SNS topic after adding the action. Requires aws-cdk-lib, in particular codepipeline, codepipeline_actions, and aws-sns modules. Inputs allow user customization of notifications; output is a pipeline stage with an approval gate that blocks until manual review.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sns from 'aws-cdk-lib/aws-sns';\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst approveStage = pipeline.addStage({ stageName: 'Approve' });\nconst manualApprovalAction = new codepipeline_actions.ManualApprovalAction({\n  actionName: 'Approve',\n  notificationTopic: new sns.Topic(this, 'Topic'), // optional\n  notifyEmails: [\n    'some_email@example.com',\n  ], // optional\n  additionalInformation: 'additional info', // optional\n  timeout: Duration.minutes(10), // optional\n});\napproveStage.addAction(manualApprovalAction);\n// `manualApprovalAction.notificationTopic` can be used to access the Topic\n// after the Action has been added to a Pipeline\n```\n\n----------------------------------------\n\nTITLE: Blocking Recovery Point Deletion in a Backup Vault - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates using the blockRecoveryPointDeletion property and blockRecoveryPointDeletion() method to add policy statements preventing recovery point deletions in a backup vault. Available at creation or on an existing vault, via the AWS CDK backup module in TypeScript. The input is a boolean flag or call; output is a vault with enhanced immutability for backups.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nnew backup.BackupVault(this, 'Vault', {\n  blockRecoveryPointDeletion: true,\n});\n\ndeclare const backupVault: backup.BackupVault;\nbackupVault.blockRecoveryPointDeletion();\n```\n\n----------------------------------------\n\nTITLE: Invoking AppSync GraphQL API with Existing Role in TypeScript\nDESCRIPTION: This snippet demonstrates how to use an existing IAM role with the proper permissions for the AppSync target when the EventBridge rule is triggered. It shows how to import an existing GraphQL API and grant permissions for the 'publish' mutation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as appsync from 'aws-cdk-lib/aws-appsync';\n\nconst api = appsync.GraphqlApi.fromGraphqlApiAttributes(this, 'ImportedAPI', {\n  graphqlApiId: '<api-id>',\n  graphqlApiArn: '<api-arn>',\n  graphQLEndpointArn: '<api-endpoint-arn>',\n  visibility: appsync.Visibility.GLOBAL,\n  modes: [appsync.AuthorizationType.IAM],\n});\n\nconst rule = new events.Rule(this, 'Rule', { schedule: events.Schedule.rate(cdk.Duration.minutes(1)), });\nconst role = new iam.Role(this, 'Role', { assumedBy: new iam.ServicePrincipal('events.amazonaws.com') });\n\n// allow EventBridge to use the `publish` mutation\napi.grantMutation(role, 'publish');\n\nrule.addTarget(new targets.AppSync(api, {\n  graphQLOperation: 'mutation Publish($message: String!){ publish(message: $message) { message } }',\n  variables: events.RuleTargetInput.fromObject({\n    message: 'hello world',\n  }),\n  eventRole: role\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Policy to CloudWatch Log Group in TypeScript\nDESCRIPTION: Creates a CloudWatch Log Group and adds a resource policy allowing logs:CreateLogStream and logs:PutLogEvents actions from the Elasticsearch service principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst logGroup = new logs.LogGroup(this, 'LogGroup');\nlogGroup.addToResourcePolicy(new iam.PolicyStatement({\n    actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],\n    principals: [new iam.ServicePrincipal('es.amazonaws.com')],\n    resources: [logGroup.logGroupArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Setting up an Amplify App with GitHub Source Provider in TypeScript\nDESCRIPTION: Creates an Amplify application connected to a GitHub repository with build specifications. This snippet demonstrates how to configure the source code provider with GitHub credentials and define the build process using BuildSpec.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codebuild from 'aws-cdk-lib/aws-codebuild';\n\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-github-token'),\n  }),\n  buildSpec: codebuild.BuildSpec.fromObjectToYaml({\n    // Alternatively add a `amplify.yml` to the repo\n    version: '1.0',\n    frontend: {\n      phases: {\n        preBuild: {\n          commands: [\n            'yarn',\n          ],\n        },\n        build: {\n          commands: [\n            'yarn build',\n          ],\n        },\n      },\n      artifacts: {\n        baseDirectory: 'public',\n        files:\n        - '**/*',\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFront Distribution with HTTP Origin using TypeScript\nDESCRIPTION: Illustrates creating a CloudFront `Distribution` with a custom HTTP endpoint (`www.example.com`) as the origin using `HttpOrigin`. This is suitable for origins hosted outside of AWS or any publicly accessible HTTP server specified by its domain name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// Creates a distribution from an HTTP endpoint\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Encrypted Kinesis Stream (Default KMS Key) - AWS CDK - TypeScript\nDESCRIPTION: This snippet creates a Kinesis stream with server-side encryption enabled, utilizing the default Kinesis-managed AWS KMS key. This requires no encryption property in the construct and is supported in regions where default Kinesis encryption is available. The code requires aws-cdk-lib and kinesis modules. No key parameters required; outputs an encrypted Stream resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kinesis.Stream(this, 'MyEncryptedStream');\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing SSM Parameters - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to reference existing SSM Parameter Store values in a CDK application using both non-secret (StringParameter) and secret (SecureString) types. It covers retrieving the latest value, referencing by parameter version, including versions provided by Token, and accessing SecureString parameters with different versioning modes. Dependencies include AWS CDK's ssm module and the use of Token for dynamic value resolution. Provided parameters include 'parameterName' and optionally 'version', with outputs being the SSM parameter value as a string or SecureString object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst parameterVersion = Token.asNumber({ Ref: 'MyParameter' });\n\n// Retrieve the latest value of the non-secret parameter\n// with name \"/My/String/Parameter\".\nconst stringValue = ssm.StringParameter.fromStringParameterAttributes(this, 'MyValue', {\n  parameterName: '/My/Public/Parameter',\n  // 'version' can be specified but is optional.\n}).stringValue;\nconst stringValueVersionFromToken = ssm.StringParameter.fromStringParameterAttributes(this, 'MyValueVersionFromToken', {\n  parameterName: '/My/Public/Parameter',\n  // parameter version from token\n  version: parameterVersion,\n}).stringValue;\n\n// Retrieve a specific version of the secret (SecureString) parameter.\n// 'version' is always required.\nconst secretValue = ssm.StringParameter.fromSecureStringParameterAttributes(this, 'MySecureValue', {\n  parameterName: '/My/Secret/Parameter',\n  version: 5,\n});\nconst secretValueVersionFromToken = ssm.StringParameter.fromSecureStringParameterAttributes(this, 'MySecureValueVersionFromToken', {\n  parameterName: '/My/Secret/Parameter',\n  // parameter version from token\n  version: parameterVersion,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CodeBuild PipelineProject for CodePipeline Integration\nDESCRIPTION: Shows how to create a CodeBuild project specifically for use in an AWS CodePipeline. The PipelineProject class is used instead of the standard Project class.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.PipelineProject(this, 'Project', {\n  // properties as above...\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Exposing a Metric on a CloudWatch Metric Filter in TypeScript\nDESCRIPTION: Creates a metric filter that extracts latency values from logs and exposes them as a CloudWatch metric, which can then be used to create an alarm.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const logGroup: logs.LogGroup;\nconst mf = new logs.MetricFilter(this, 'MetricFilter', {\n  logGroup,\n  metricNamespace: 'MyApp',\n  metricName: 'Latency',\n  filterPattern: logs.FilterPattern.exists('$.latency'),\n  metricValue: '$.latency',\n  dimensions: {\n    ErrorCode: '$.errorCode',\n  },\n  unit: cloudwatch.Unit.MILLISECONDS,\n});\n\n//expose a metric from the metric filter\nconst metric = mf.metric();\n\n//you can use the metric to create a new alarm\nnew cloudwatch.Alarm(this, 'alarm from metric filter', {\n  metric,\n  threshold: 100,\n  evaluationPeriods: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Granting PutEvents Permission to an Imported EventBus\nDESCRIPTION: Demonstrates how to import an existing EventBus using its ARN and grant PutEvents permission to a Lambda function. This allows the Lambda function to publish events to the imported EventBus.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const lambdaFunction: lambda.Function;\n\nconst eventBus = events.EventBus.fromEventBusArn(this, 'ImportedEventBus', 'arn:aws:events:us-east-1:111111111:event-bus/my-event-bus');\n\n// now you can just call methods on the eventbus\neventBus.grantPutEventsTo(lambdaFunction);\n```\n\n----------------------------------------\n\nTITLE: Configuring Canary Scripts with Different Code Sources in AWS CDK\nDESCRIPTION: Demonstrates three ways to supply code to a Synthetics canary: inline code, local filesystem asset, and S3 bucket. Each example creates a canary with the appropriate code source and specifies the required handler and runtime.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// To supply the code inline:\nnew synthetics.Canary(this, 'Inline Canary', {\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    handler: 'index.handler', // must be 'index.handler'\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n});\n\n// To supply the code from your local filesystem:\nnew synthetics.Canary(this, 'Asset Canary', {\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler', // must end with '.handler'\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n});\n\n// To supply the code from a S3 bucket:\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nconst bucket = new s3.Bucket(this, 'Code Bucket');\nnew synthetics.Canary(this, 'Bucket Canary', {\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromBucket(bucket, 'canary.zip'),\n    handler: 'index.handler', // must end with '.handler'\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from API Gateway REST API (Custom Path) using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates configuring a CloudFront distribution with an API Gateway REST API origin, but specifying a custom origin path instead of the default stage name. The `originPath` property is set within the `origins.RestApiOrigin` constructor. Requires `aws-cdk-lib/aws-apigateway`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const api: apigateway.RestApi;\nnew cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: new origins.RestApiOrigin(api, { originPath: '/custom-origin-path' }) },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing a CodeCommit Repository with Initial Commit\nDESCRIPTION: Creates a CodeCommit repository and initializes it with code from a local directory, optionally specifying a branch name (defaults to 'develop' if not specified).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst repo = new codecommit.Repository(this, 'Repository', {\n  repositoryName: 'MyRepositoryName',\n  code: codecommit.Code.fromDirectory(path.join(__dirname, 'directory/'), 'develop'), // optional property, branch parameter can be omitted\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with SQS using AWS CDK in TypeScript\nDESCRIPTION: Demonstrates configuring `HttpSqsIntegration` to perform various SQS actions (send message, receive message, delete message, purge queue) triggered by different HTTP API routes. Requires an `sqs.IQueue` instance and the `aws-apigatewayv2`, `aws-apigatewayv2-integrations`, and `aws-sqs` CDK modules. Different subtypes are specified for each SQS action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\nimport { HttpSqsIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const queue: sqs.IQueue;\ndeclare const httpApi: apigwv2.HttpApi;\n\n// default integration (send message)\nhttpApi.addRoutes({\n  path: '/default',\n  methods: [apigwv2.HttpMethod.POST],\n  integration: new HttpSqsIntegration('defaultIntegration', {\n    queue,\n  }),\n});\n// send message integration\nhttpApi.addRoutes({\n  path: '/send-message',\n  methods: [apigwv2.HttpMethod.POST],\n  integration: new HttpSqsIntegration('sendMessageIntegration', {\n    queue,\n    subtype: apigwv2.HttpIntegrationSubtype.SQS_SEND_MESSAGE,\n  }),\n});\n// receive message integration\nhttpApi.addRoutes({\n  path: '/receive-message',\n  methods: [apigwv2.HttpMethod.POST],\n  integration: new HttpSqsIntegration('receiveMessageIntegration', {\n    queue,\n    subtype: apigwv2.HttpIntegrationSubtype.SQS_RECEIVE_MESSAGE,\n  }),\n});\n// delete message integration\nhttpApi.addRoutes({\n  path: '/delete-message',\n  methods: [apigwv2.HttpMethod.POST],\n  integration: new HttpSqsIntegration('deleteMessageIntegration', {\n    queue,\n    subtype: apigwv2.HttpIntegrationSubtype.SQS_DELETE_MESSAGE,\n  }),\n});\n// purge queue integration\nhttpApi.addRoutes({\n  path: '/purge-queue',\n  methods: [apigwv2.HttpMethod.POST],\n  integration: new HttpSqsIntegration('purgeQueueIntegration', {\n    queue,\n    subtype: apigwv2.HttpIntegrationSubtype.SQS_PURGE_QUEUE,\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding User Pool Authentication After Identity Pool Creation in TypeScript\nDESCRIPTION: This code demonstrates how to add a User Pool authentication provider to an existing Identity Pool and retrieve the created User Pool Client.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const identityPool: IdentityPool;\nconst userPool = new cognito.UserPool(this, 'Pool');\nconst userPoolClient = identityPool.addUserPoolAuthentication(new UserPoolAuthenticationProvider({\n  userPool,\n}));\n```\n\n----------------------------------------\n\nTITLE: Granting Encryption Permissions on KMS Key to IAM User Using AWS CDK in TypeScript\nDESCRIPTION: Demonstrates granting encryption (kms:Encrypt) rights to an IAM user for a previously defined KMS key. Uses CDK's grant helper method, which attaches permissions directly to the user's IAM policy, leaving the key policy unchanged. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\nconst user = new iam.User(this, 'MyUser');\nkey.grantEncrypt(user); // Adds encrypt permissions to user policy; key policy is unmodified.\n```\n\n----------------------------------------\n\nTITLE: Querying Kubernetes Resources with KubernetesObjectValue in TypeScript\nDESCRIPTION: This snippet demonstrates how to query information from Kubernetes objects using the KubernetesObjectValue construct. It shows fetching a LoadBalancer service address and using it in a Lambda function environment variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n// query the load balancer address\nconst myServiceAddress = new eks.KubernetesObjectValue(this, 'LoadBalancerAttribute', {\n  cluster: cluster,\n  objectType: 'service',\n  objectName: 'my-service',\n  jsonPath: '.status.loadBalancer.ingress[0].hostname', // https://kubernetes.io/docs/reference/kubectl/jsonpath/\n});\n\n// pass the address to a lambda function\nconst proxyFunction = new lambda.Function(this, 'ProxyFunction', {\n  handler: 'index.handler',\n  code: lambda.Code.fromInline('my-code'),\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  environment: {\n    myServiceAddress: myServiceAddress.value,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Firehose Subscription Filter for CloudWatch Logs in TypeScript\nDESCRIPTION: Creates a Subscription Filter that sends all log events to a Kinesis Firehose Delivery Stream destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as destinations from 'aws-cdk-lib/aws-logs-destinations';\nimport * as firehose from 'aws-cdk-lib/aws-kinesisfirehose';\n\ndeclare const deliveryStream: firehose.IDeliveryStream;\ndeclare const logGroup: logs.LogGroup;\n\nnew logs.SubscriptionFilter(this, 'Subscription', {\n  logGroup,\n  destination: new destinations.FirehoseDestination(deliveryStream),\n  filterPattern: logs.FilterPattern.allEvents(),\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering StepFunctions State Machine with Dead Letter Queue via EventBridge - TypeScript\nDESCRIPTION: This code sets up a StepFunctions state machine and configures an EventBridge rule to trigger the state machine every minute with a dummy object as input, using AWS CDK in TypeScript. It also demonstrates attaching a dead letter queue and custom IAM role for the target. Required dependencies include aws-cdk-lib/aws-stepfunctions, aws-cdk-lib/aws-iam, aws-cdk-lib/aws-sqs, aws-cdk-lib/aws-events, and cdk.Duration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as sfn from 'aws-cdk-lib/aws-stepfunctions';\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(Duration.minutes(1)),\n});\n\nconst dlq = new sqs.Queue(this, 'DeadLetterQueue');\n\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('events.amazonaws.com'),\n});\nconst stateMachine = new sfn.StateMachine(this, 'SM', {\n  definition: new sfn.Wait(this, 'Hello', { time: sfn.WaitTime.duration(Duration.seconds(10)) })\n});\n\nrule.addTarget(new targets.SfnStateMachine(stateMachine, {\n  input: events.RuleTargetInput.fromObject({ SomeParam: 'SomeValue' }),\n  deadLetterQueue: dlq,\n  role: role\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding Egress-Only Internet Gateway Route with AWS CDK (TypeScript)\nDESCRIPTION: Illustrates creating a `VpcV2` with both IPv4 and Amazon-provided IPv6 CIDR blocks, setting up an `EgressOnlyInternetGateway` (for IPv6 outbound traffic), associating it with a `RouteTable`, and adding an IPv6 default route (`::/0`) using the `routeTable.addRoute` method. Note that EgressOnlyInternetGateways only handle IPv6 traffic. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2` constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc',{\n      primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n      secondaryAddressBlocks: [IpAddresses.amazonProvidedIpv6({\n      cidrBlockName: 'AmazonProvided',\n    })]\n    });\n\nconst eigw = new EgressOnlyInternetGateway(this, 'EIGW', {\n  vpc: myVpc,\n});\n\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\n\nrouteTable.addRoute('EIGW', '::/0', { gateway: eigw });\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a CodeBuild Fleet in TypeScript\nDESCRIPTION: This snippet demonstrates creating a CodeBuild reserved capacity fleet using AWS CDK, specifying compute type, environment type, and base capacity. It then shows how to associate a new CodeBuild project with this fleet to utilize reserved instances, potentially reducing build start times.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fleet = new codebuild.Fleet(this, 'Fleet', {\n    computeType: codebuild.FleetComputeType.MEDIUM,\n    environmentType: codebuild.EnvironmentType.LINUX_CONTAINER,\n    baseCapacity: 1,\n});\n\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    fleet,\n    buildImage: codebuild.LinuxBuildImage.STANDARD_7_0,\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a TextWidget with Markdown to AWS CloudWatch Dashboard (TypeScript)\nDESCRIPTION: Demonstrates adding a TextWidget with Markdown content to provide explanatory text on a dashboard. Needs a Dashboard object and uses markdown string parameter. Text is rendered as Markdown.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TextWidget({\n  markdown: '# Key Performance Indicators'\n}));\n```\n\n----------------------------------------\n\nTITLE: Sending S3 Object Creation Events to SQS Queue using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates how to set up an AWS S3 bucket with the AWS CDK to send a notification to an SQS queue upon new object creation (via PUT). It depends on the `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-sqs`, and `aws-cdk-lib/aws-s3-notifications` modules. The `bucket.addEventNotification` method configures the trigger using `s3.EventType.OBJECT_CREATED_PUT` and an `s3n.SqsDestination` targeting the created SQS queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-notifications/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\n\nconst bucket = new s3.Bucket(this, 'Bucket');\nconst queue = new sqs.Queue(this, 'Queue');\n\nbucket.addEventNotification(s3.EventType.OBJECT_CREATED_PUT, new s3n.SqsDestination(queue));\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Auto Scaling Group from a Launch Template in TypeScript\nDESCRIPTION: This snippet demonstrates creating an Auto Scaling Group (ASG) by referencing a pre-defined EC2 Launch Template. Using Launch Templates is the recommended approach for configuring ASG instances, offering more features and flexibility compared to the deprecated Launch Configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const launchTemplate: ec2.LaunchTemplate;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  launchTemplate: launchTemplate\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Cognito User Pool Domains using AWS CDK - TypeScript\nDESCRIPTION: This code example shows how to set up both a Cognito-hosted domain (with a specified prefix) and a custom domain secured with an ACM certificate for a user pool. Dependencies are AWS CDK libraries for Cognito and Certificate Manager. Required parameters include the domain prefix, custom domain name, and the ARN of a validated ACM certificate for custom domains. Inputs are user-defined names and certificate ARNs; outputs are domain configurations attached to the Cognito user pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nconst pool = new cognito.UserPool(this, 'Pool');\n\npool.addDomain('CognitoDomain', {\n  cognitoDomain: {\n    domainPrefix: 'my-awesome-app',\n  },\n});\n\nconst certificateArn = 'arn:aws:acm:us-east-1:123456789012:certificate/11-3336f1-44483d-adc7-9cd375c5169d';\n\nconst domainCert = certificatemanager.Certificate.fromCertificateArn(this, 'domainCert', certificateArn);\npool.addDomain('CustomDomain', {\n  customDomain: {\n    domainName: 'user.myapp.com',\n    certificate: domainCert,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Instance Class and Creating Managed EC2 Compute Environment with AWS Batch (TypeScript)\nDESCRIPTION: This TypeScript snippet provides two usage patterns for managing allowed EC2 instance classes in an AWS Batch compute environment: (a) adding an instance class to an existing environment using the '.addInstanceClass' method, and (b) specifying 'instanceClasses' property at construction. Requires '@aws-cdk/aws-ec2', '@aws-cdk/aws-batch', and an existing VPC. Both patterns ensure the compute environment considers only specified instance classes during allocation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'VPC');\n\ndeclare const computeEnv: batch.IManagedEc2EcsComputeEnvironment\ncomputeEnv.addInstanceClass(ec2.InstanceClass.M5AD);\n// Or, specify it on the constructor:\nnew batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  instanceClasses: [ec2.InstanceClass.R4],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Metrics with AWS CDK - TypeScript\nDESCRIPTION: This snippet illustrates how to create CloudWatch metrics for a Kinesis stream using both base and predefined CDK metric methods. It covers stream.metric for arbitrary metrics and metricGetRecordsSuccess for frequently used ones. Inputs are the stream and optional metric properties; outputs are metric objects for dashboards/alarms. Dependencies: aws-cdk-lib, kinesis, cloudwatch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst stream = new kinesis.Stream(this, 'MyStream');\n\n// Using base metric method passing the metric name\nstream.metric('GetRecords.Success');\n\n// using pre-defined metric method\nstream.metricGetRecordsSuccess();\n\n// using pre-defined and overriding the statistic\nstream.metricGetRecordsSuccess({ statistic: 'Maximum' });\n```\n\n----------------------------------------\n\nTITLE: Enabling Propagation of Additional User Context Data (TypeScript)\nDESCRIPTION: This snippet demonstrates how to enable the propagation of additional user context data for advanced security features in AWS Cognito. Setting `enablePropagateAdditionalUserContextData: true` on the User Pool Client allows session information (like IP address, device details) to be collected and sent to Cognito during sign-up, sign-in, and password reset API calls.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const importedPool: cognito.UserPool;\n\nconst userPoolClient = new cognito.UserPoolClient(this, 'UserPoolClient', {\n  userPool: importedPool,\n  generateSecret: true,\n  enablePropagateAdditionalUserContextData: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Job Retry Policies in AWS Batch with CDK\nDESCRIPTION: Demonstrates how to define retry policies for AWS Batch jobs that respond to different failure scenarios. This example shows how to handle container pull failures, spot instance reclamation, and custom exit code patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst jobDefn = new batch.EcsJobDefinition(this, 'JobDefn', {\n   container: new batch.EcsEc2ContainerDefinition(this, 'containerDefn', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n  }),\n  retryAttempts: 5,\n  retryStrategies: [\n    batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.CANNOT_PULL_CONTAINER),\n  ],\n});\njobDefn.addRetryStrategy(\n  batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.SPOT_INSTANCE_RECLAIMED),\n);\njobDefn.addRetryStrategy(\n  batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.CANNOT_PULL_CONTAINER),\n);\njobDefn.addRetryStrategy(\n  batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.custom({\n    onExitCode: '40*',\n    onReason: 'some reason',\n  })),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Cognito User Pool App Client in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a new Cognito User Pool and add an App Client to it using the AWS CDK. It then retrieves the auto-generated client ID for the newly created app client.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'pool');\nconst client = pool.addClient('customer-app-client');\nconst clientId = client.userPoolClientId;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Artifacts for CodeBuild Project in TypeScript\nDESCRIPTION: Illustrates how to configure a CodeBuild project to produce artifacts and upload them to an S3 bucket. It includes options for packaging, path specification, and artifact naming.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\n\nconst project = new codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n  }),\n  artifacts: codebuild.Artifacts.s3({\n      bucket,\n      includeBuildId: false,\n      packageZip: true,\n      path: 'another/path',\n      identifier: 'AddArtifact1',\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding SNS Action to CloudWatch Alarm\nDESCRIPTION: Example of adding an SNS topic action to a CloudWatch Alarm when it breaches the threshold.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cw_actions from 'aws-cdk-lib/aws-cloudwatch-actions';\ndeclare const alarm: cloudwatch.Alarm;\n\nconst topic = new sns.Topic(this, 'Topic');\nalarm.addAlarmAction(new cw_actions.SnsAction(topic));\n```\n\n----------------------------------------\n\nTITLE: Defining CodeStar Notification Rules for Pipelines - AWS CodePipeline - TypeScript\nDESCRIPTION: Demonstrates the use of CodeStar Notification rules for AWS CodePipeline, integrating pipeline execution state changes with Slack channels managed by AWS Chatbot. Shows how to create a SlackChannelConfiguration and attach a notification rule to the pipeline via the 'notifyOnExecutionStateChange' method. Prerequisites include '@aws-cdk/aws-chatbot' and a properly configured Slack integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n// Define CodeStar Notification rules for Pipelines\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\nconst target = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\n});\n\ndeclare const pipeline: codepipeline.Pipeline;\nconst rule = pipeline.notifyOnExecutionStateChange('NotifyOnExecutionStateChange', target);\n```\n\n----------------------------------------\n\nTITLE: Enabling Deletion Protection on AppConfig Environment with CDK in TypeScript\nDESCRIPTION: Shows how to create an AWS AppConfig Environment with deletion protection enabled by setting the `deletionProtectionCheck` property to `appconfig.DeletionProtectionCheck.APPLY`. This forces the deletion protection check to run, even if deletion protection is disabled at the account level. Requires the `application` variable (of type `appconfig.Application`) to be previously declared or imported in the scope. Assumes `this` is a CDK `Construct`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const alarm: cloudwatch.Alarm;\ndeclare const compositeAlarm: cloudwatch.CompositeAlarm;\n\nnew appconfig.Environment(this, 'MyEnvironment', {\n  application,\n  deletionProtectionCheck: appconfig.DeletionProtectionCheck.APPLY,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Basic OpenSearch Development Domain\nDESCRIPTION: Creates a basic development OpenSearch domain by specifying the engine version.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst devDomain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Entry File and Handler for NodejsFunction\nDESCRIPTION: Shows how to manually specify the entry file path and handler function name for a NodejsFunction instead of using automatic lookup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'MyFunction', {\n  entry: '/path/to/my/file.ts', // accepts .js, .jsx, .cjs, .mjs, .ts, .tsx, .cts and .mts files\n  handler: 'myExportedFunc', // defaults to 'handler'\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Connection and Destination for EventBridge Rule in TypeScript\nDESCRIPTION: This snippet demonstrates how to import an existing connection and destination to create additional EventBridge rules. It uses the fromEventBusArn and fromApiDestinationAttributes methods to reference existing resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = events.Connection.fromEventBusArn(\n  this,\n  'Connection',\n  'arn:aws:events:us-east-1:123456789012:event-bus/EventBusName',\n  'arn:aws:secretsmanager:us-east-1:123456789012:secret:SecretName-f3gDy9',\n);\n\nconst apiDestinationArn = 'arn:aws:events:us-east-1:123456789012:api-destination/DestinationName';\nconst destination = events.ApiDestination.fromApiDestinationAttributes(\n  this,\n  'Destination',\n  { apiDestinationArn, connection },\n);\n\nconst rule = new events.Rule(this, 'OtherRule', {\n  schedule: events.Schedule.rate(Duration.minutes(10)),\n  targets: [new targets.ApiDestination(destination)],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Internet Gateway to VPC for Specific Subnet using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to add an internet gateway to a VPC for a specific subnet using AWS CDK. It creates a VPC, a public subnet, and adds an internet gateway with a custom IPv4 destination for the specified subnet.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\n\nconst mySubnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC });\n\nmyVpc.addInternetGateway({\n  ipv4Destination: '192.168.0.0/16',\n  subnets: [mySubnet],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Target CPU Utilization for QueueProcessingFargateService (TypeScript)\nDESCRIPTION: Illustrates setting the cpuTargetUtilizationPercent property in QueueProcessingFargateService to control desired average CPU utilization for scaling. This customizes how automatic scaling policies respond to workload. Requires an ECS cluster and the aws-cdk ECS patterns construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  command: [\"-c\", \"4\", \"amazon.com\"],\n  enableLogging: false,\n  desiredTaskCount: 2,\n  environment: {},\n  maxScalingCapacity: 5,\n  containerName: 'test',\n  minHealthyPercent: 100,\n  cpuTargetUtilizationPercent: 90,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Virtual Gateway with TLS and Health Check - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet demonstrates how to instantiate an App Mesh Virtual Gateway resource with the AWS CDK, specifying an HTTP listener on port 443, a health check, backend TLS policy, logging, and gateway name. The backend TLS validation uses an ACM PCA certificate authority. Dependencies include AWS CDK, @aws-cdk/aws-appmesh, and ACM PCA libraries. Inputs: mesh, certificate authority ARN, health check interval, port, and access log path. Output is a virtual gateway resource. Caution: all resources referenced (mesh, certificate, etc.) must exist prior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\nconst certificateAuthorityArn = 'arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/12345678-1234-1234-1234-123456789012';\n\nconst gateway = new appmesh.VirtualGateway(this, 'gateway', {\n  mesh: mesh,\n  listeners: [appmesh.VirtualGatewayListener.http({\n    port: 443,\n    healthCheck: appmesh.HealthCheck.http({\n      interval: Duration.seconds(10),\n    }),\n  })],\n  backendDefaults: {\n    tlsClientPolicy: {\n      ports: [8080, 8081],\n      validation: {\n        trust: appmesh.TlsValidationTrust.acm([\n          acmpca.CertificateAuthority.fromCertificateAuthorityArn(this, 'certificate', certificateAuthorityArn)]),\n      },\n    },\n  },\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout'),\n  virtualGatewayName: 'virtualGateway',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing a Cross-Account/Region VPC in TypeScript\nDESCRIPTION: Shows how to import a VPC from a different AWS account or region by specifying the owner account ID and region. This is important for correct ARN generation and VPC peering.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\n\n//Importing a cross account or cross region VPC\nconst importedVpc = VpcV2.fromVpcV2Attributes(stack, 'ImportedVpc', {\n      vpcId: 'mockVpcID',\n      vpcCidrBlock: '10.0.0.0/16',\n      ownerAccountId: '123456789012',\n      region: 'us-west-2',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Public Hosted Zone in Route53 using AWS CDK\nDESCRIPTION: Demonstrates how to create a public hosted zone in Amazon Route53 using the AWS CDK. The zoneName parameter specifies the fully qualified domain name for the hosted zone.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew route53.PublicHostedZone(this, 'HostedZone', {\n  zoneName: 'fully.qualified.domain.com',\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Axios Interceptors with Synchronous and Conditional Execution - JavaScript\nDESCRIPTION: Illustrates how to make request interceptors synchronous by passing the `synchronous: true` flag in the options object, and how to use a `runWhen` function to conditionally execute an interceptor based on request config. Useful for optimizing timing and controlling interceptor behavior for specific request types. Dependencies: `axios` package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction onGetCall(config) {\n  return config.method === 'get';\n}\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'special get headers';\n  return config;\n}, null, { runWhen: onGetCall });\n```\n\n----------------------------------------\n\nTITLE: Enabling Specific Group Metrics for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet shows how to enable monitoring for a specific subset of group metrics (MinSize and MaxSize) on an AWS Auto Scaling Group using the AWS CDK. It initializes an `AutoScalingGroup` and sets the `groupMetrics` property to a new `GroupMetrics` instance containing the desired metrics (`autoscaling.GroupMetric.MIN_SIZE`, `autoscaling.GroupMetric.MAX_SIZE`). Dependencies include declared variables for `vpc`, `instanceType`, and `machineImage`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Enable monitoring for a subset of group metrics\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  groupMetrics: [new autoscaling.GroupMetrics(autoscaling.GroupMetric.MIN_SIZE, autoscaling.GroupMetric.MAX_SIZE)],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Flexible Time Windows for Schedules (AWS CDK, TypeScript)\nDESCRIPTION: Enables and configures flexible time windows so that scheduled targets can be triggered within a specified time buffer, improving execution flexibility. Default is disabled; here, a 10-hour flexible window is set on a 12-hour recurring schedule. Inputs are scheduling details, flexible window duration, and target; output is a schedule that can invoke within the window. Dependencies: Schedule, LambdaInvoke, TimeWindow.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nconst schedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.hours(12)),\n    target,\n    timeWindow: TimeWindow.flexible(Duration.hours(10)),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Audit Logs for an OpenSearch/Elasticsearch Domain\nDESCRIPTION: Shows how to enable audit logging for an `es.Domain` using AWS CDK. This requires Fine-Grained Access Control (FGAC) to be enabled first. The `logging.auditLogEnabled` property is set to `true` alongside other logging and FGAC configurations. Audit logs provide detailed records of user activity and access attempts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n  },\n  logging: {\n    auditLogEnabled: true,\n    slowSearchLogEnabled: true,\n    appLogEnabled: true,\n    slowIndexLogEnabled: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-User Database Credential Rotation - AWS CDK TypeScript\nDESCRIPTION: Sets up rotation for a user secret with a separate master secret for managing multi-user scenarios (like RDS database users). Specifies both secrets, the target DB connectable, associated VPC, and chooses the multi-user rotation application template. All necessary CDK constructs must be instantiated; expects proper cross-reference of related secrets. Adaptable to multiple engines and user workflows.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myUserSecret: secretsmanager.Secret;\ndeclare const myMasterSecret: secretsmanager.Secret;\ndeclare const myDatabase: ec2.IConnectable;\ndeclare const myVpc: ec2.Vpc;\n\nnew secretsmanager.SecretRotation(this, 'SecretRotation', {\n  application: secretsmanager.SecretRotationApplication.MYSQL_ROTATION_MULTI_USER,\n  secret: myUserSecret, // The secret that will be rotated\n  masterSecret: myMasterSecret, // The secret used for the rotation\n  target: myDatabase,\n  vpc: myVpc,\n});\n```\n\n----------------------------------------\n\nTITLE: Instantiating OpenIdConnectPrincipal from Provider (TypeScript)\nDESCRIPTION: Creates an IAM principal using the OpenID connect provider, enabling its use in trust relationships or policies in AWS. Useful for specifying federated identities as trusted callers. Requires a valid OIDC provider instantiated with AWS CDK. Input is the provider resource; output is an OpenIdConnectPrincipal object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst provider = new iam.OpenIdConnectProvider(this, 'MyProvider', {\\n  url: 'https://openid/connect',\\n  clientIds: [ 'myclient1', 'myclient2' ],\\n});\\nconst principal = new iam.OpenIdConnectPrincipal(provider);\n```\n\n----------------------------------------\n\nTITLE: Attaching WAF Web ACL to Existing CloudFront Distribution\nDESCRIPTION: This example demonstrates how to attach a WAF web ACL to an existing CloudFront distribution using the attachWebAclId method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucketOrigin: origins.S3Origin;\ndeclare const webAcl: wafv2.CfnWebACL;\nconst distribution = new cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: bucketOrigin },\n});\n\ndistribution.attachWebAclId(webAcl.attrArn);\n```\n\n----------------------------------------\n\nTITLE: Sending Events to an EventBridge Event Bus with Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to send events to an Amazon EventBridge event bus using EventBridge Scheduler and AWS CDK. It defines an Event Bus, creates an `EventBridgePutEventsEntry` specifying the bus, source, detail (payload), and detail type. This entry is used to configure an `EventBridgePutEvents` target, which is then triggered hourly by a schedule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as events from 'aws-cdk-lib/aws-events';\n\nconst eventBus = new events.EventBus(this, 'EventBus', {\n  eventBusName: 'DomainEvents',\n});\n\nconst eventEntry: targets.EventBridgePutEventsEntry = {\n  eventBus,\n  source: 'PetService',\n  detail: ScheduleTargetInput.fromObject({ Name: 'Fluffy' }),\n  detailType: '',\n};\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.hours(1)),\n  target: new targets.EventBridgePutEvents(eventEntry),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Manual Approval Permission for CodePipeline Action with AWS CDK (TypeScript)\nDESCRIPTION: Shows how to grant a specific IAM principal the ability to approve a manual approval action in CodePipeline using AWS CDK TypeScript. The snippet demonstrates retrieving a role from its ARN and granting approval permissions to it. Dependencies include aws-cdk-lib's codepipeline, codepipeline_actions, and iam. Inputs are the pipeline, approval action, and the role; the action outputs a pipeline step that only authorized users can approve.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst approveStage = pipeline.addStage({ stageName: 'Approve' });\nconst manualApprovalAction = new codepipeline_actions.ManualApprovalAction({\n  actionName: 'Approve',\n});\napproveStage.addAction(manualApprovalAction);\n\nconst role = iam.Role.fromRoleArn(this, 'Admin', Arn.format({ service: 'iam', resource: 'role', resourceName: 'Admin' }, this));\nmanualApprovalAction.grantManualApproval(role);\n```\n\n----------------------------------------\n\nTITLE: Deploying CloudFormation StackSets with AWS CodePipeline\nDESCRIPTION: Demonstrates deploying CloudFormation StackSets to multiple AWS accounts using CodePipeline. This example shows updating the StackSet template and then deploying stack instances to specified accounts and regions in a sequential process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const pipeline: codepipeline.Pipeline;\ndeclare const sourceOutput: codepipeline.Artifact;\n\npipeline.addStage({\n  stageName: 'DeployStackSets',\n  actions: [\n    // First, update the StackSet itself with the newest template\n    new codepipeline_actions.CloudFormationDeployStackSetAction({\n      actionName: 'UpdateStackSet',\n      runOrder: 1,\n      stackSetName: 'MyStackSet',\n      template: codepipeline_actions.StackSetTemplate.fromArtifactPath(sourceOutput.atPath('template.yaml')),\n\n      // Change this to 'StackSetDeploymentModel.organizations()' if you want to deploy to OUs\n      deploymentModel: codepipeline_actions.StackSetDeploymentModel.selfManaged(),\n      // This deploys to a set of accounts\n      stackInstances: codepipeline_actions.StackInstances.inAccounts(['111111111111'], ['us-east-1', 'eu-west-1']),\n    }),\n\n    // Afterwards, update/create additional instances in other accounts\n    new codepipeline_actions.CloudFormationDeployStackInstancesAction({\n      actionName: 'AddMoreInstances',\n      runOrder: 2,\n      stackSetName: 'MyStackSet',\n      stackInstances: codepipeline_actions.StackInstances.inAccounts(\n        ['222222222222', '333333333333'],\n        ['us-east-1', 'eu-west-1']\n      ),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing Existing Record Sets in Route53 using AWS CDK\nDESCRIPTION: Shows how to replace existing record sets in Route53 using the deleteExisting property. This is useful for minimizing downtime when deploying a stack with a record set that already exists. Caution is advised when using this feature.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecord', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4', '5.6.7.8'),\n  deleteExisting: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Construct Dependencies with DependencyGroup in TypeScript\nDESCRIPTION: Demonstrates using the `DependencyGroup` class to establish an ordering dependency where `constructA` depends on the completion of both `constructB` and `constructC`. This is useful when multiple constructs, potentially not in the same scope, need to be grouped for dependency management. The `addDependency` method on the node of `constructA` applies this grouped dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Declare the dependable object\nconst bAndC = new DependencyGroup();\nbAndC.add(constructB);\nbAndC.add(constructC);\n\n// Take the dependency\nconstructA.node.addDependency(bAndC);\n```\n```\n\n----------------------------------------\n\nTITLE: Using Precreated Roles with customizeRoles - AWS CDK - TypeScript\nDESCRIPTION: This snippet illustrates assigning already created IAM role names to CDK constructs using usePrecreatedRoles with customizeRoles. After manually creating the necessary roles and policies as per the generated report, developers can map CDK logical role IDs to precreated physical role names. This ensures CDK resources use only approved pre-existing roles. Requires iam, App, and Stack from the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const app: App;\nconst stack = new Stack(app, 'MyStack');\niam.Role.customizeRoles(this, {\n  usePrecreatedRoles: {\n    'MyStack/MyRole': 'my-precreated-role-name',\n  },\n});\n\nnew iam.Role(this, 'MyRole', {\n  assumedBy: new iam.ServicePrincipal('sns.amazonaws.com'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB TableV2 Encryption with AWS Owned Key in TypeScript\nDESCRIPTION: This snippet shows how to configure a DynamoDB TableV2 instance with the default encryption type using an AWS owned key. The `encryption` property is set using `dynamodb.TableEncryptionV2.dynamoOwnedKey()`. This key management is handled entirely by DynamoDB.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryptionV2.dynamoOwnedKey(),\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Explicit Dependency between App Client and Identity Provider (TypeScript)\nDESCRIPTION: This snippet shows how to ensure an identity provider exists before an app client that depends on it is created within the same AWS CDK stack. It defines an Amazon identity provider and an app client configured to use it, then explicitly adds a dependency from the client to the provider using `client.node.addDependency(provider)`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\nconst provider = new cognito.UserPoolIdentityProviderAmazon(this, 'Amazon', {\n  userPool: pool,\n  clientId: 'amzn-client-id',\n  clientSecret: 'amzn-client-secret',\n});\n\nconst client = pool.addClient('app-client', {\n  // ...\n  supportedIdentityProviders: [\n    cognito.UserPoolClientIdentityProvider.AMAZON,\n  ],\n});\n\nclient.node.addDependency(provider);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Alarms for Canary Metrics in AWS CDK\nDESCRIPTION: Shows how to configure a CloudWatch Alarm on a canary metric. The example creates an alarm that tracks the canary's success percentage, alerting when it falls below 90% for two evaluation periods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const canary: synthetics.Canary;\nnew cloudwatch.Alarm(this, 'CanaryAlarm', {\n  metric: canary.metricSuccessPercent(),\n  evaluationPeriods: 2,\n  threshold: 90,\n  comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Lambda Subscription with Message Body Filter Policy in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to use filterPolicyWithMessageBody to enable payload-based filtering for SNS-to-Lambda subscriptions. This allows fine-grained filtering on nested attributes in the message body. Dependencies are sns, lambda, and subscriptions, and the example filters for messages where the body.background.color is either 'red' or 'orange'. Supports use cases requiring contextual content filtering beyond message headers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst myTopic = new sns.Topic(this, 'MyTopic');\ndeclare const fn: lambda.Function;\n\n// Lambda should receive only message matching the following conditions on message body:\n// color: 'red' or 'orange'\nmyTopic.addSubscription(new subscriptions.LambdaSubscription(fn, {\n  filterPolicyWithMessageBody: {\n    background: sns.FilterOrPolicy.policy({\n      color: sns.FilterOrPolicy.filter(sns.SubscriptionFilter.stringFilter({\n        allowlist: ['red', 'orange'],\n      })),\n    }),\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Alarm for GameLift Fleet Metrics with AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a CloudWatch alarm based on metrics from a GameLift Fleet using the AWS CDK in TypeScript. It computes the ratio of unused fleet instances via a MathExpression and triggers an alarm if idle instance utilization surpasses a defined threshold. Dependencies include AWS CDK modules for GameLift and CloudWatch; key parameters are metric statistics, threshold value, and evaluation periods. Input assumes declared fleet resource, and output is a CloudWatch alarm construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fleet: gamelift.BuildFleet;\n// Alarm that triggers when the per-second average of not used instances exceed 10%\nconst instancesUsedRatio = new cloudwatch.MathExpression({\n  expression: '1 - (activeInstances / idleInstances)',\n  usingMetrics: {\n    activeInstances: fleet.metric('ActiveInstances', { statistic: cloudwatch.Statistic.SUM }),\n    idleInstances: fleet.metricIdleInstances(),\n  },\n});\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: instancesUsedRatio,\n  threshold: 0.1,\n  evaluationPeriods: 3,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling User Role Requirement in AWS Chatbot Slack Channel - TypeScript\nDESCRIPTION: This snippet illustrates enabling the user role requirement when configuring an AWS Chatbot Slack channel using AWS CDK in TypeScript. By setting the userRoleRequired property to true, all channel members are required to use a specific IAM role when interacting with Chatbot. The example uses the aws-cdk-lib/aws-chatbot module and expects valid Slack workspace and channel identifiers. This helps enforce security policies within Slack-integrated AWS workflows.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-chatbot/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\\n\\nconst slackChannel = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\\n  userRoleRequired: true,\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Secondary Sources and Artifacts for CodeBuild Project (TypeScript)\nDESCRIPTION: This snippet illustrates how to define secondary sources (e.g., from CodeCommit) and secondary artifacts (e.g., to S3) for an AWS CodeBuild project using the AWS CDK. Both `secondarySources` and `secondaryArtifacts` arrays require elements with unique `identifier` properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\ndeclare const repo: codecommit.Repository;\ndeclare const bucket: s3.Bucket;\n\nconst project = new codebuild.Project(this, 'MyProject', {\n  secondarySources: [\n    codebuild.Source.codeCommit({\n      identifier: 'source2',\n      repository: repo,\n    }),\n  ],\n  secondaryArtifacts: [\n    codebuild.Artifacts.s3({\n      identifier: 'artifact2',\n      bucket: bucket,\n      path: 'some/path',\n      name: 'file.zip',\n    }),\n  ],\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Assigning a Custom IAM Role to Backup Selection and Disabling Default Backup Policy - AWS CDK - TypeScript\nDESCRIPTION: Illustrates how to assign a custom IAM Role to an AWS Backup selection and disable the default AWSBackupServiceRolePolicyForBackup policy using the AWS CDK in TypeScript. The example shows how to grant a role only S3 backup permissions by attaching AWSBackupServiceRolePolicyForS3Backup, and how to use role and disableDefaultBackupPolicy properties in addSelection(). Dependencies include the iam and backup CDK modules. Expects a prepared role and an AWS Backup plan; output is a backup selection using the custom role and permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\n\nconst role = new iam.Role(this, 'BackupRole', {\n  assumedBy: new iam.ServicePrincipal('backup.amazonaws.com'),\n});\n// Assign S3-specific backup policy\nrole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AWSBackupServiceRolePolicyForS3Backup'));\n\nplan.addSelection('Selection', {\n  resources: [\n    backup.BackupResource.fromTag('stage', 'prod'),\n  ],\n  role,\n  disableDefaultBackupPolicy: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom CloudWatch Metric for Route 53 DNS Queries (TypeScript)\nDESCRIPTION: Shows how to instantiate a new `cloudwatch.Metric` object to represent a specific metric (DNSQueries) from a namespace (AWS/Route53) that might not have a direct convenience method. It uses dimensions, specifically the `HostedZoneId` obtained from a `route53.HostedZone` resource, to target the metric precisely.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst hostedZone = new route53.HostedZone(this, 'MyHostedZone', { zoneName: \"example.org\" });\nconst metric = new cloudwatch.Metric({\n  namespace: 'AWS/Route53',\n  metricName: 'DNSQueries',\n  dimensionsMap: {\n    HostedZoneId: hostedZone.hostedZoneId\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Account S3 Deployment Action\nDESCRIPTION: Sets up an S3 deployment action that targets a bucket in a different AWS account. The pipeline will automatically create the necessary IAM roles for cross-account access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Deploy an imported S3 bucket from a different account\ndeclare const stage: codepipeline.IStage;\ndeclare const input: codepipeline.Artifact;\nstage.addAction(new codepipeline_actions.S3DeployAction({\n  bucket: s3.Bucket.fromBucketAttributes(this, 'Bucket', {\n    account: '123456789012',\n    // ...\n  }),\n  input: input,\n  actionName: 's3-deploy-action',\n  // ...\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating Lambda@Edge Functions with Specific Stack IDs using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates creating multiple Lambda@Edge functions using the `EdgeFunction` construct while assigning specific `stackId` properties. This is useful when the main stack is not in `us-east-1` and you need to reference these Lambda@Edge functions from different applications within the same AWS account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// Setting stackIds for EdgeFunctions that can be referenced from different applications\n// on the same account.\nconst myFunc1 = new cloudfront.experimental.EdgeFunction(this, 'MyFunction1', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler1')),\n  stackId: 'edge-lambda-stack-id-1',\n});\n\nconst myFunc2 = new cloudfront.experimental.EdgeFunction(this, 'MyFunction2', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler2')),\n  stackId: 'edge-lambda-stack-id-2',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an SQS Source for EventBridge Pipe in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe with an Amazon SQS queue as the source and another SQS queue as the target. This basic implementation connects the source queue to the pipe which will forward messages to the target queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-sources-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeSource = new sources.SqsSource(sourceQueue);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: pipeSource,\n  target: new SqsTarget(targetQueue)\n});\n```\n\n----------------------------------------\n\nTITLE: Working with Service Catalog Rules in CDK\nDESCRIPTION: Shows how to access and modify Service Catalog template rules through CfnInclude. This enables adding assertions and other rule conditions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst rule: core.CfnRule = cfnTemplate.getRule('MyRule');\n\n// mutating the rule\ndeclare const myParameter: core.CfnParameter;\nrule.addAssertion(core.Fn.conditionContains(['m1.small'], myParameter.valueAsString),\n  'MyParameter has to be m1.small');\n```\n\n----------------------------------------\n\nTITLE: Managing User Pool Groups and IAM Roles using AWS CDK - TypeScript\nDESCRIPTION: This snippet illustrates the creation of Cognito user pool groups with optional IAM role assignment using the UserPoolGroup construct and the addGroup method. Prerequisites include CDK libraries for Cognito and IAM, and an existing user pool and IAM role instance. Required parameters are group name and (optionally) group precedence and IAM role. Outputs are group entities within the user pool, managed through CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const userPool: cognito.UserPool;\ndeclare const role: iam.Role;\n\nnew cognito.UserPoolGroup(this, 'UserPoolGroup', {\n  userPool,\n  groupName: 'my-group-name',\n  precedence: 1,\n  role,  // assign IAM Role\n});\n\n// You can also add a group by using addGroup method.\nuserPool.addGroup('AnotherUserPoolGroup', {\n  groupName: 'another-group-name'\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up AWS CDK Repository\nDESCRIPTION: Commands to clone the forked AWS CDK repository and install dependencies. This is the first step in setting up the development environment for contributing to the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ git clone https://github.com/{your-account}/aws-cdk.git\n$ cd aws-cdk\n$ yarn install\n```\n\n----------------------------------------\n\nTITLE: Enabling Active X-Ray Tracing for a Canary in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to enable active AWS X-Ray tracing for a Synthetics Canary by setting the `activeTracing` property to `true`. This requires using a compatible runtime (`syn-nodejs-2.0` or later, like the specified `SYNTHETICS_NODEJS_PUPPETEER_6_2`). Tracing allows detailed analysis of the canary's execution path.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  activeTracing: true, // active tracing enabled\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Subscribe Permissions to an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: This snippet adds permissions to an SNS topic's resource policy, allowing a specified AWS principal to perform the sns:Subscribe action. It uses the grantSubscribe method on a Topic construct, typically with an iam.AccountPrincipal, separating permission management from actual subscription creation. Useful for delegated or cross-account access patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const accountPrincipal: iam.AccountPrincipal;\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.grantSubscribe(accountPrincipal);\n```\n\n----------------------------------------\n\nTITLE: Creating an Access Keys Rotated Config Rule in TypeScript\nDESCRIPTION: Shows how to create a higher-level construct for the Access Keys Rotated managed rule. This rule checks if access keys have been rotated within the last 90 days.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// compliant if access keys have been rotated within the last 90 days\nnew config.AccessKeysRotated(this, 'AccessKeyRotated');\n```\n\n----------------------------------------\n\nTITLE: Referencing AWS Secrets Manager in SecretValue (TypeScript)\nDESCRIPTION: Shows the recommended way to retrieve a secret value from AWS Secrets Manager using the SecretValue.secretsManager factory method, with optional parameters for JSON field extraction, version, and version stage. Requires AWS CDK SecretValue type and an existing Secrets Manager secret. Input is the secret's identifier and, optionally, a JSON field name, version ID, or stage; output is a SecretValue instance that can be used as a property in compatible CDK constructs. Always prefer this pattern to avoid insecure plain text secrets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst secret = SecretValue.secretsManager('secretId', {\n  jsonField: 'password', // optional: key of a JSON field to retrieve (defaults to all content),\n  versionId: 'id',       // optional: id of the version (default AWSCURRENT)\n  versionStage: 'stage', // optional: version stage name (default AWSCURRENT)\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Domain with Branch Mappings in TypeScript\nDESCRIPTION: Demonstrates how to configure a custom domain for an Amplify app and map different branches to subdomains. Includes auto-subdomain creation for branches matching specific patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const amplifyApp: amplify.App;\ndeclare const main: amplify.Branch;\ndeclare const dev: amplify.Branch;\n\nconst domain = amplifyApp.addDomain('example.com', {\n  enableAutoSubdomain: true, // in case subdomains should be auto registered for branches\n  autoSubdomainCreationPatterns: ['*', 'pr*'], // regex for branches that should auto register subdomains\n});\ndomain.mapRoot(main); // map main branch to domain root\ndomain.mapSubDomain(main, 'www');\ndomain.mapSubDomain(dev); // sub domain prefix defaults to branch name\n```\n\n----------------------------------------\n\nTITLE: Putting a Record to a Kinesis Data Stream with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to put a record into an Amazon Kinesis Data Stream using EventBridge Scheduler and AWS CDK. It defines a Kinesis stream and configures a `KinesisStreamPutRecord` target, specifying the required `partitionKey`. A schedule is then created to trigger this target every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\nconst stream = new kinesis.Stream(this, 'MyStream');\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.KinesisStreamPutRecord(stream, {\n    partitionKey: 'key',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a TXT Record to a Route53 Hosted Zone using AWS CDK\nDESCRIPTION: Demonstrates how to add a TXT record to a Route53 hosted zone. It specifies the zone, record name, values, and TTL. The values are automatically quoted and escaped as needed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.TxtRecord(this, 'TXTRecord', {\n  zone: myZone,\n  recordName: '_foo',  // If the name ends with a \".\", it will be used as-is;\n                       // if it ends with a \".\" followed by the zone name, a trailing \".\" will be added automatically;\n                       // otherwise, a \".\", the zone name, and a trailing \".\" will be added automatically.\n                       // Defaults to zone root if not specified.\n  values: [            // Will be quoted for you, and \" will be escaped automatically.\n    'Bar!',\n    'Baz?',\n  ],\n  ttl: Duration.minutes(90),       // Optional - default is 30 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Overwriting LogGroup Message with Static Value in EventBridge - TypeScript\nDESCRIPTION: This snippet demonstrates how to overwrite the 'message' field in a CloudWatch LogGroup event target by assigning it a custom stringified value within an EventBridge rule. It uses LogGroupTargetInput.fromObjectV2 and JSON.stringify to define the desired message payload, ensuring that static custom fields are logged. Assumes aws-cdk-lib/aws-logs and aws-cdk-lib/aws-events as dependencies and that the LogGroup and EventBridge rule are already declared.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\ndeclare const logGroup: logs.LogGroup;\ndeclare const rule: events.Rule;\n\nrule.addTarget(new targets.CloudWatchLogGroup(logGroup, {\n  logEvent: targets.LogGroupTargetInput.fromObjectV2({\n    message: JSON.stringify({\n      CustomField: 'CustomValue',\n    }),\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating an AppRegistry Application in TypeScript\nDESCRIPTION: Shows how to create a new AppRegistry application with a name and optional description. The application name must be unique at the account level and is immutable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = new appreg.Application(this, 'MyFirstApplication', {\n  applicationName: 'MyFirstApplicationName',\n  description: 'description for my application', // the description is optional\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning Cross-Region ACM Certificates for CloudFront - AWS CDK - TypeScript\nDESCRIPTION: This example manages ACM certificate deployment in us-east-1 for CloudFront distributions located in another region, utilizing CDK's crossRegionReferences. It imports relevant modules, creates two stacks (one per region), provisions a certificate in us-east-1, and assigns it to a CloudFront distribution in us-east-2. Key parameters: region, crossRegionReferences, certificate config, CloudFront distribution settings. Dependencies: aws-cdk-lib/aws-certificatemanager, aws-cdk-lib/aws-route53, aws-cdk-lib/aws-cloudfront, aws-cdk-lib/aws-cloudfront-origins. Outputs: certificate resource and associated CloudFront distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { aws_cloudfront as cloudfront, aws_cloudfront_origins as origins } from 'aws-cdk-lib';\ndeclare const app: App;\n\nconst stack1 = new Stack(app, 'Stack1', {\n  env: {\n    region: 'us-east-1',\n  },\n  crossRegionReferences: true,\n});\nconst cert = new acm.Certificate(stack1, 'Cert', {\n  domainName: '*.example.com',\n  validation: acm.CertificateValidation.fromDns(PublicHostedZone.fromHostedZoneId(stack1, 'Zone', 'ZONE_ID')),\n});\n\nconst stack2 = new Stack(app, 'Stack2', {\n  env: {\n    region: 'us-east-2',\n  },\n  crossRegionReferences: true,\n});\n\nnew cloudfront.Distribution(stack2, 'Distribution', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('example.com'),\n  },\n  domainNames: ['dev.example.com'],\n  certificate: cert,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing DocumentDB Cluster in TypeScript\nDESCRIPTION: Creates a new DocumentDB cluster with specified master user, instance type and VPC configuration. Includes optional tag copying to snapshots.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new docdb.DatabaseCluster(this, 'Database', {\n  masterUser: {\n    username: 'myuser', // NOTE: 'admin' is reserved by DocumentDB\n    excludeCharacters: '\\\"@/:', // optional, defaults to the set \"\\\"@/\" and is also used for eventually created rotations\n    secretName: '/myapp/mydocdb/masteruser', // optional, if you prefer to specify the secret name\n  },\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n  vpcSubnets: {\n    subnetType: ec2.SubnetType.PUBLIC,\n  },\n  vpc,\n  copyTagsToSnapshot: true  // whether to save the cluster tags when creating the snapshot.\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Password Policy for UserPool including History and Validity - AWS CDK - TypeScript\nDESCRIPTION: Configures advanced password policy settings for a Cognito UserPool, such as minimum length, character requirements, and password history size. The 'tempPasswordValidity' sets the duration (in whole days) users have to reset temporary passwords. Requires AWS CDK and Duration utility. Input is a policy configuration object; output is an enforceable password policy on the UserPool. 'tempPasswordValidity' must be an integer number of days.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  passwordPolicy: {\n    minLength: 12,\n    requireLowercase: true,\n    requireUppercase: true,\n    requireDigits: true,\n    requireSymbols: true,\n    tempPasswordValidity: Duration.days(3),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Delivery Status Logging to Existing SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to augment an existing SNS topic by calling addLoggingConfig to append delivery status logging for SQS endpoints. Role assignment and protocol type are specified, and valid sample rates are in the 0-100 range. Useful for updating or expanding existing monitoring configurations post-creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\nconst topic = new sns.Topic(this, 'MyTopic');\n\ntopic.addLoggingConfig({\n  protocol: sns.LoggingProtocol.SQS,\n  failureFeedbackRole: role,\n  successFeedbackRole: role,\n  successFeedbackSampleRate: 50,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AppSync Construct Library in TypeScript\nDESCRIPTION: This snippet imports the necessary AWS AppSync construct library module from `aws-cdk-lib` for use within an AWS CDK application written in TypeScript.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appsync from 'aws-cdk-lib/aws-appsync';\n```\n\n----------------------------------------\n\nTITLE: Using an SNS Topic as a CloudWatch Event Rule Target in AWS CDK (TypeScript)\nDESCRIPTION: This example demonstrates how to configure an SNS topic as a target for a CodeCommit onCommit event using EventBridge (CloudWatch Events) with AWS CDK. It shows usage of codecommit and targets modules and how to reference SnsTopic as the event rule target. Also, it notes modifying the SNS topic resource policy for publishing permissions. Useful for event-driven notifications upon repository changes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\n\ndeclare const repo: codecommit.Repository;\nconst myTopic = new sns.Topic(this, 'Topic');\n\nrepo.onCommit('OnCommit', {\n  target: new targets.SnsTopic(myTopic),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Access Key for an IAM User (TypeScript)\nDESCRIPTION: Creates a new access key pair for an IAM user, granting them programmatic access to AWS services via CLI or SDK. Requires an existing user resource; inputs are the scope, ID, and user reference; output is a new access key resource. The generated secret is returned as a CloudFormation secret value.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = new iam.User(this, 'MyUser');\\nconst accessKey = new iam.AccessKey(this, 'MyAccessKey', { user: user });\n```\n\n----------------------------------------\n\nTITLE: Granting Combined Sign and Verify Permissions Using grantSignVerify in AWS CDK TypeScript\nDESCRIPTION: Provides a single method to grant both 'kms:Sign' and 'kms:Verify' permissions to an IAM user on a KMS key. This is a convenience utility for cryptographic workloads requiring both permissions. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\nconst user = new iam.User(this, 'MyUser');\nkey.grantSignVerify(user); // Adds 'kms:Sign' and 'kms:Verify' to the principal's policy\n```\n\n----------------------------------------\n\nTITLE: Configuring BitBucket Source for CodeBuild Project in TypeScript\nDESCRIPTION: Shows how to use a BitBucket repository as the source for a CodeBuild project. It specifies the owner and repository name for the BitBucket source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst bbSource = codebuild.Source.bitBucket({\n  owner: 'owner',\n  repo: 'repo',\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing an OIDC Provider ARN in Cognito Identity Pool (TypeScript)\nDESCRIPTION: Shows how to supply an OpenID Connect provider ARN, created previously in CDK, to a Cognito Identity Pool resource for federated authentication. This links AWS Cognito to an external OIDC provider. Requires `aws-cdk-lib/aws-cognito` and a valid OIDC provider resource. Inputs include the provider ARN and pool configuration; output is a new Cognito identity pool with OIDC federation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cognito from 'aws-cdk-lib/aws-cognito';\\n\\ndeclare const myProvider: iam.OpenIdConnectProvider;\\nnew cognito.CfnIdentityPool(this, 'IdentityPool', {\\n  openIdConnectProviderArns: [myProvider.openIdConnectProviderArn],\\n  // And the other properties for your identity pool\\n  allowUnauthenticatedIdentities: false,\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Lambda Authorization for AppSync API in TypeScript\nDESCRIPTION: This TypeScript code shows how to configure an AppSync GraphQL API to use AWS Lambda for authorization. It sets the `defaultAuthorization` mode to `LAMBDA` and specifies the `handler` Lambda function within `lambdaAuthorizerConfig`. Optional parameters like `resultsCacheTtl` and `validationRegex` can also be configured here.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\ndeclare const authFunction: lambda.Function;\n\nnew appsync.GraphqlApi(this, 'api', {\n  name: 'api',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.test.graphql')),\n  authorizationConfig: {\n    defaultAuthorization: {\n      authorizationType: appsync.AuthorizationType.LAMBDA,\n      lambdaAuthorizerConfig: {\n        handler: authFunction,\n        // can also specify `resultsCacheTtl` and `validationRegex`.\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching an EC2 Reboot Action to a CloudWatch Alarm (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add an EC2 action, specifically rebooting an instance, to an existing CloudWatch alarm using the AWS CDK. It requires an initialized `cloudwatch.Alarm` object (presumably configured with an EC2 per-instance metric) and utilizes the `Ec2Action` class from the `aws-cdk-lib/aws-cloudwatch-actions` module, specifying `Ec2InstanceAction.REBOOT`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch-actions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Alarm must be configured with an EC2 per-instance metric\ndeclare const alarm: cloudwatch.Alarm;\n// Attach a reboot when alarm triggers\nalarm.addAlarmAction(\n  new actions.Ec2Action(actions.Ec2InstanceAction.REBOOT),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CustomerProfiles Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS CustomerProfiles module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-customerprofiles/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as customerprofiles from 'aws-cdk-lib/aws-customerprofiles';\n```\n\n----------------------------------------\n\nTITLE: Adding Delivery Status Logging for SNS Messages to SQS in AWS CDK (TypeScript)\nDESCRIPTION: This code demonstrates configuring delivery status logging for an SNS topic, specifically for messages sent to an SQS endpoint. It defines loggingConfigs with success and failure roles as well as a sampling rate for reporting. Required dependency is the iam.Role construct for permissioning. Evaluates status delivery for better operational monitoring.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\nconst topic = new sns.Topic(this, 'MyTopic', {\n  loggingConfigs: [\n    {\n      protocol: sns.LoggingProtocol.SQS,\n      failureFeedbackRole: role,\n      successFeedbackRole: role,\n      successFeedbackSampleRate: 50,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Pattern Filters for CloudWatch Logs\nDESCRIPTION: Shows how to create complex JSON-based log filters with multiple conditions using AND/OR combinations and various comparison operators.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst pattern = logs.FilterPattern.all(\n  logs.FilterPattern.stringValue('$.component', '=', 'HttpServer'),\n  logs.FilterPattern.any(\n    logs.FilterPattern.booleanValue('$.error', true),\n    logs.FilterPattern.numberValue('$.latency', '>', 1000),\n  ),\n  logs.FilterPattern.regexValue('$.message', '=', 'bind address already in use'),\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Realtime Log Config for CloudFront Distribution in TypeScript\nDESCRIPTION: This code demonstrates how to set up realtime log delivery from a CloudFront distribution to a Kinesis stream, including specifying endpoints, fields, and sampling rate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n// Adding realtime logs config to a Cloudfront Distribution on default behavior.\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\ndeclare const stream: kinesis.Stream;\n\nconst realTimeConfig = new cloudfront.RealtimeLogConfig(this, 'realtimeLog', {\n  endPoints: [\n    cloudfront.Endpoint.fromKinesisStream(stream),\n  ],\n  fields: [\n    'timestamp',\n    'c-ip',\n    'time-to-first-byte',\n    'sc-status',\n  ],\n  realtimeLogConfigName: 'my-delivery-stream',\n  samplingRate: 100,\n});\n\nnew cloudfront.Distribution(this, 'myCdn', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('www.example.com'),\n    realtimeLogConfig: realTimeConfig,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: S3 Deployment with KMS Encryption\nDESCRIPTION: Configures an S3 deployment action in CodePipeline with KMS encryption. Sets up a target bucket and encryption key for secure deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst sourceOutput = new codepipeline.Artifact();\nconst targetBucket = new s3.Bucket(this, 'MyBucket');\nconst key: kms.IKey = new kms.Key(this, 'EnvVarEncryptKey', {\n  description: 'sample key',\n});\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst deployAction = new codepipeline_actions.S3DeployAction({\n  actionName: 'S3Deploy',\n  bucket: targetBucket,\n  input: sourceOutput,\n  encryptionKey: key,\n});\nconst deployStage = pipeline.addStage({\n  stageName: 'Deploy',\n  actions: [deployAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Resource Properties in TypeScript\nDESCRIPTION: Illustrates using `hasResourceProperties()` to assert that at least one resource of the specified type exists and its `Properties` section contains the provided properties. This performs a deep partial match by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.hasResourceProperties('Foo::Bar', {\n  Lorem: 'Ipsum',\n  Baz: 5,\n  Qux: [ 'Waldo', 'Fred' ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring DocumentDB Cluster Access\nDESCRIPTION: Demonstrates how to configure access to the DocumentDB cluster by allowing connections from any IPv4 address and accessing cluster endpoints.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: docdb.DatabaseCluster;\ncluster.connections.allowDefaultPortFromAnyIpv4('Open to the world');\n\nconst writeAddress = cluster.clusterEndpoint.socketAddress;   // \"HOSTNAME:PORT\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Cross-Account Stack Associations in ApplicationAssociator\nDESCRIPTION: Shows how to enable cross-account stack associations with ApplicationAssociator. This requires all accounts to be in the same organization and have resource sharing enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.createApplicationStack({\n    associateCrossAccountStacks: true,\n    applicationName: 'MyAssociatedApplication',\n    env: { account: '123456789012', region: 'us-east-1' },\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Basic AppConfig Hosted Configuration with CDK in TypeScript\nDESCRIPTION: Demonstrates the creation of an AWS AppConfig Application and Environment using the AWS CDK. It then defines a `HostedConfiguration` with inline text content and deploys it automatically to the created Environment. Assumes `this` refers to the current CDK scope (Construct) and `appconfig` is the imported module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst app = new appconfig.Application(this, 'MyApp');\nconst env = new appconfig.Environment(this, 'MyEnv', {\n  application: app,\n});\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfig', {\n  application: app,\n  deployTo: [env],\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SNS Topic as Success Destination for Lambda Function in TypeScript\nDESCRIPTION: Example showing how to configure an SNS topic as a destination for successful invocations of a Lambda function. This snippet demonstrates importing the required dependencies and creating a Lambda function with an onSuccess destination pointing to an SNS topic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-destinations/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// An sns topic for successful invocations of a lambda function\nimport * as sns from 'aws-cdk-lib/aws-sns';\n\nconst myTopic = new sns.Topic(this, 'Topic');\n\nconst myFn = new lambda.Function(this, 'Fn', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n  // sns topic for successful invocations\n  onSuccess: new destinations.SnsDestination(myTopic),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an App Mesh Virtual Service with Virtual Node Provider in TypeScript\nDESCRIPTION: Instantiates an `appmesh.VirtualService` using the CDK construct within the current scope (`this`). It configures the service with an optional `virtualServiceName` and specifies an existing `appmesh.VirtualNode` instance (`node`) as its provider using `appmesh.VirtualServiceProvider.virtualNode()`. This configuration routes traffic for the virtual service directly to the specified virtual node. Requires a `node` variable (of type `appmesh.VirtualNode`) declared in the scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const node: appmesh.VirtualNode;\n\nnew appmesh.VirtualService(this, 'virtual-service', {\n  virtualServiceName: `my-service.default.svc.cluster.local`, // optional\n  virtualServiceProvider: appmesh.VirtualServiceProvider.virtualNode(node),\n});\n```\n\n----------------------------------------\n\nTITLE: Associating Observability Configuration with AWS App Runner Service using AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to connect a custom observability configuration to an AWS App Runner service via AWS CDK in TypeScript. It creates an 'ObservabilityConfiguration' resource, specifying properties like configuration name and tracing vendor, and then attaches it to the service through the 'observabilityConfiguration' property. Dependencies include the 'apprunner' module. Inputs are the observability settings object and the service configuration; the output is a service resource with the designated observability features enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst observabilityConfiguration = new apprunner.ObservabilityConfiguration(this, 'ObservabilityConfiguration', {\n  observabilityConfigurationName: 'MyObservabilityConfiguration',\n  traceConfigurationVendor: apprunner.TraceConfigurationVendor.AWSXRAY,\n});\n\nnew apprunner.Service(this, 'DemoService', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  observabilityConfiguration,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from Lambda Function URL with Custom OAC using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows configuring a CloudFront distribution with a Lambda Function URL origin using a custom-defined Origin Access Control (OAC). A new `cloudfront.FunctionUrlOriginAccessControl` is explicitly created with specific settings (e.g., name, signing behavior). This custom OAC is then passed to the `origins.FunctionUrlOrigin.withOriginAccessControl` method when defining the distribution's origin. The Lambda Function URL uses IAM authentication. Requires `aws-cdk-lib/aws-lambda`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\ndeclare const fn: lambda.Function;\n\nconst fnUrl = fn.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.AWS_IAM,\n});\n\n// Define a custom OAC\nconst oac = new cloudfront.FunctionUrlOriginAccessControl(this, 'MyOAC', {\n  originAccessControlName: 'CustomLambdaOAC',\n  signing: cloudfront.Signing.SIGV4_ALWAYS,\n});\n\n// Set up Lambda Function URL with OAC in CloudFront Distribution\nnew cloudfront.Distribution(this, 'MyDistribution', {\n  defaultBehavior: {\n    origin: origins.FunctionUrlOrigin.withOriginAccessControl(fnUrl, {\n      originAccessControl: oac,\n    }),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Task Definition Values for ECS Task Target in TypeScript\nDESCRIPTION: This snippet shows how to override values in the task definition when using the EcsTask target. It demonstrates overriding CPU and memory values specified in the EcsTaskProps.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(new targets.EcsTask({\n  cluster,\n  taskDefinition,\n  taskCount: 1,\n\n  // Overrides the cpu and memory values in the task definition\n  cpu: '512',\n  memory: '512',\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding a CustomWidget for Lambda-Backed Visualizations (TypeScript)\nDESCRIPTION: Illustrates how to add a CustomWidget that runs an AWS Lambda function to produce custom dashboard content. Requires Dashboard and Lambda constructs (lambda.Function.fromFunctionArn) from aws-cdk-lib. The functionArn identifies the Lambda that backs the widget.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\n// Import or create a lambda function\nconst fn = lambda.Function.fromFunctionArn(\n  dashboard,\n  'Function',\n  'arn:aws:lambda:us-east-1:123456789012:function:MyFn',\n);\n\ndashboard.addWidgets(new cloudwatch.CustomWidget({\n  functionArn: fn.functionArn,\n  title: 'My lambda baked widget',\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Single-Container ECS Workflow with EFS Volume in AWS Batch\nDESCRIPTION: Shows how to define an ECS job definition that runs a single container with an Amazon EFS volume mount. The example demonstrates setting up memory, CPU requirements, and file system access through IAM roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myFileSystem: efs.IFileSystem;\ndeclare const myJobRole: iam.Role;\nmyFileSystem.grantRead(myJobRole);\n\nconst jobDefn = new batch.EcsJobDefinition(this, 'JobDefn', {\n  container: new batch.EcsEc2ContainerDefinition(this, 'containerDefn', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n    volumes: [batch.EcsVolume.efs({\n      name: 'myVolume',\n      fileSystem: myFileSystem,\n      containerPath: '/Volumes/myVolume',\n      useJobRole: true,\n    })],\n    jobRole: myJobRole,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using filePath StateMachineInput with StepFunctionInvokeAction in CodePipeline (TypeScript)\nDESCRIPTION: Demonstrates configuring a StepFunctionInvokeAction to use a file from an input artifact as its state machine input via filePath. This allows pipeline-driven, dynamic input for Step Functions. The example expects artifacts and state machines to be defined; requires aws-cdk-lib's stepfunctions, codepipeline, and codepipeline_actions modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as stepfunctions from 'aws-cdk-lib/aws-stepfunctions';\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst inputArtifact = new codepipeline.Artifact();\nconst startState = new stepfunctions.Pass(this, 'StartState');\nconst simpleStateMachine  = new stepfunctions.StateMachine(this, 'SimpleStateMachine', {\n  definition: startState,\n});\nconst stepFunctionAction = new codepipeline_actions.StepFunctionInvokeAction({\n  actionName: 'Invoke',\n  stateMachine: simpleStateMachine,\n  stateMachineInput: codepipeline_actions.StateMachineInput.filePath(inputArtifact.atPath('assets/input.json')),\n});\npipeline.addStage({\n  stageName: 'StepFunctions',\n  actions: [stepFunctionAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Associating AWS WAF with AppSync Event API in TypeScript\nDESCRIPTION: This example shows how to associate an AWS WAF Web ACL with an AWS AppSync Event API to protect it from common web exploits. It uses the WebACLAssociation construct to link the WAF and the API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.EventApi;\ndeclare const webAcl: wafv2.CfnWebACL;\n\n// Associate waf with Event API\nnew wafv2.CfnWebACLAssociation(this, 'WafAssociation', {\n  resourceArn: api.apiArn,\n  webAclArn: webAcl.attrArn,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Stage-Specific Domain Mapping in API Gateway v2\nDESCRIPTION: Creates a new stage with a custom domain mapping, allowing different paths to route to different stages of the API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: apigwv2.HttpApi;\ndeclare const dn: apigwv2.DomainName;\n\napi.addStage('beta', {\n  stageName: 'beta',\n  autoDeploy: true,\n  domainMapping: {\n    domainName: dn,\n    mappingKey: 'bar',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Endpoint for Elasticsearch Domain\nDESCRIPTION: Creates an Elasticsearch domain with a custom endpoint using a specific domain name. This allows users to access the Elasticsearch service via a custom domain name instead of the default AWS endpoint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nnew es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_7,\n  customEndpoint: {\n    domainName: 'search.example.com',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting a Default Redirect URI in OAuth Configuration (TypeScript)\nDESCRIPTION: This snippet shows how to configure OAuth 2.0 settings for a Cognito App Client, specifically setting a `defaultRedirectUri`. This URI must be one of the URLs listed in the `callbackUrls` array. It enables the authorization code grant flow and sets the 'openid' scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  oAuth: {\n    flows: {\n      authorizationCodeGrant: true,\n    },\n    scopes: [ cognito.OAuthScope.OPENID ],\n    defaultRedirectUri: 'https://my-app-domain.com/welcome',\n    callbackUrls: [ 'https://my-app-domain.com/welcome', 'https://my-app-domain.com/hello' ],\n    logoutUrls: [ 'https://my-app-domain.com/signin' ],\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket API with Default Routes in TypeScript (CDK)\nDESCRIPTION: This snippet demonstrates how to create a new WebSocket API using AWS CDK, configuring the default routes (`$connect`, `$disconnect`, `$default`) with Lambda function integrations. It imports `WebSocketLambdaIntegration` and uses it within the `WebSocketApi` constructor's `connectRouteOptions`, `disconnectRouteOptions`, and `defaultRouteOptions`. It also shows how to create and deploy a `WebSocketStage` associated with the API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const connectHandler: lambda.Function;\ndeclare const disconnectHandler: lambda.Function;\ndeclare const defaultHandler: lambda.Function;\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi', {\n  connectRouteOptions: { integration: new WebSocketLambdaIntegration('ConnectIntegration', connectHandler) },\n  disconnectRouteOptions: { integration: new WebSocketLambdaIntegration('DisconnectIntegration',disconnectHandler) },\n  defaultRouteOptions: { integration: new WebSocketLambdaIntegration('DefaultIntegration', defaultHandler) },\n});\n\nnew apigwv2.WebSocketStage(this, 'mystage', {\n  webSocketApi,\n  stageName: 'dev',\n  description: 'My Stage',\n  autoDeploy: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Looking Up SSM String Parameters During Synthesis - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates the 'valueFromLookup' CDK method for looking up an SSM StringParameter by name during synthesis, returning a placeholder return value before the actual value is discovered through AWS API calls. It is typically used for bringing external configuration into CloudFormation stacks but may yield dummy values ('dummy-value-for-...') if the parameter has not yet been discovered. Dependencies include the ssm module; the main input is the parameter name, with a string output.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringValue = ssm.StringParameter.valueFromLookup(this, '/My/Public/Parameter');\n```\n\n----------------------------------------\n\nTITLE: Defining Stack with Parameterized Permissions Boundary in CDK (TypeScript)\nDESCRIPTION: Illustrates how to apply a permissions boundary with placeholders (such as qualifier, account, and region) to a production stage and then instantiate a stack within that stage with a custom stack synthesizer qualifier. Ensures fine-grained control over boundary naming and stack deployment. Requires the AWS CDK app, Stage, Stack, and DefaultStackSynthesizer constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const app: App;\\n\\nconst prodStage = new Stage(app, 'ProdStage', {\\n  permissionsBoundary: PermissionsBoundary.fromName('cdk-${Qualifier}-PermissionsBoundary-${AWS::AccountId}-${AWS::Region}'),\\n});\\n\\nnew Stack(prodStage, 'ProdStack', {\\n  synthesizer: new DefaultStackSynthesizer({\\n    qualifier: 'custom',\\n  }),\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an SES Receipt Filter - AWS CDK - TypeScript\nDESCRIPTION: This example creates a receipt filter in AWS SES using CDK, configured to block (or allow) email from a specified IP range. The ip parameter determines the range to block. The construct ensures emails from unwanted sources are blocked at receipt. Supported for both IPv4 and IPv6 ranges.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.ReceiptFilter(this, 'Filter', {\n  ip: '1.2.3.4/16', // Will be blocked\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies Between Helm Charts in AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to establish an installation order between multiple Helm charts managed by AWS CDK. It adds two charts using `cluster.addHelmChart` and then uses `chart2.node.addDependency(chart1)` to ensure that `chart1` is deployed before `chart2`, preventing potential race conditions or dependency issues.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst chart1 = cluster.addHelmChart('MyChart', {\n  chart: 'foo',\n});\nconst chart2 = cluster.addHelmChart('MyChart', {\n  chart: 'bar',\n});\n\nchart2.node.addDependency(chart1);\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Queue as Failure Destination for Lambda Function in TypeScript\nDESCRIPTION: Example demonstrating how to set up an SQS queue to receive records of failed Lambda invocations. This pattern is useful for handling errors asynchronously by routing failed invocations to a dead letter queue for further processing or analysis.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-destinations/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// An sqs queue for unsuccessful invocations of a lambda function\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\n\nconst deadLetterQueue = new sqs.Queue(this, 'DeadLetterQueue');\n\nconst myFn = new lambda.Function(this, 'Fn', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromInline('// your code'),\n  // sqs queue for unsuccessful invocations\n  onFailure: new destinations.SqsDestination(deadLetterQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Access Policies at Domain Creation in TypeScript\nDESCRIPTION: Illustrates how to attach custom IAM-based access policies to an `es.Domain` directly during instantiation using the `accessPolicies` constructor property in AWS CDK. This allows defining permissions for specific AWS principals (e.g., an AWS account) to perform actions on the domain.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n  accessPolicies: [\n    new iam.PolicyStatement({\n      actions: ['es:*ESHttpPost', 'es:ESHttpPut*'],\n      effect: iam.Effect.ALLOW,\n      principals: [new iam.AccountPrincipal('123456789012')],\n      resources: ['*'],\n    }),\n  ]\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Firehose Destination Logging in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the updated method for configuring logging in the experimental 'kinesisfirehose-destinations' module of AWS CDK. It illustrates the usage of the new 'loggingConfig' property with the 'EnableLogging' and 'DisableLogging' classes, replacing the deprecated 'logging' and 'logGroup' properties. The examples show enabling logging with an automatically created log group, enabling logging with a specified existing log group, and explicitly disabling logging. Requires 'aws-cdk-lib/aws-logs' for LogGroup, 'aws-cdk-lib/aws-s3' for Bucket, and the relevant 'kinesisfirehose-destinations-alpha' module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CHANGELOG.v2.alpha.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst logGroup = new logs.LogGroup(this, 'Log Group');\ndeclare const bucket: s3.Bucket;\n\n// 1. Enable logging with no parameters - a log group will be created for you\nconst destinationWithLogging = new destinations.S3Bucket(bucket, {\n  loggingConfig: new destinations.EnableLogging(),\n});\n\n// 2. Enable a logging and pass in a logGroup to be used\nconst destinationWithLoggingAndMyLogGroup = new destinations.S3Bucket(bucket, {\n  loggingConfig: new destinations.EnableLogging(logGroup),\n});\n\n// 3. Disable logging (does not accept any parameters so it is now impossible to provide a logGroup in this case)\nconst destinationWithoutLogging = new destinations.S3Bucket(bucket, {\n  loggingConfig: new destinations.DisableLogging(),\n});\n\n```\n```\n\n----------------------------------------\n\nTITLE: Sharing Fargate Compute Environment Between Multiple Job Queues in TypeScript\nDESCRIPTION: This snippet demonstrates creating two AWS Batch Job Queues (`lowPriorityQueue` and `highPriorityQueue`) with different priorities (1 and 10) that share a single Fargate Compute Environment (`sharedComputeEnv`). Jobs from the higher priority queue (priority 10) will be favored by Batch when submitting to the shared environment. The compute environment is configured to use Spot instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.IVpc;\nconst sharedComputeEnv = new batch.FargateComputeEnvironment(this, 'spotEnv', {\n  vpc,\n  spot: true,\n});\nconst lowPriorityQueue = new batch.JobQueue(this, 'JobQueue', {\n   priority: 1,\n});\nconst highPriorityQueue = new batch.JobQueue(this, 'JobQueue', {\n   priority: 10,\n});\nlowPriorityQueue.addComputeEnvironment(sharedComputeEnv, 1);\nhighPriorityQueue.addComputeEnvironment(sharedComputeEnv, 1);\n```\n```\n\n----------------------------------------\n\nTITLE: Using Deploy-Time Values with S3 Bucket Deployment\nDESCRIPTION: Demonstrates how to use references in JSON data that will be resolved during deployment, supporting CloudFormation functions like Ref, Fn::GetAtt, Fn::Join, and Fn::Select.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sns from 'aws-cdk-lib/aws-sns';\nimport * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\ndeclare const destinationBucket: s3.Bucket;\ndeclare const topic: sns.Topic;\ndeclare const tg: elbv2.ApplicationTargetGroup;\n\nconst appConfig = {\n  topic_arn: topic.topicArn,\n  base_url: 'https://my-endpoint',\n  lb_name: tg.firstLoadBalancerFullName,\n};\n\nnew s3deploy.BucketDeployment(this, 'BucketDeployment', {\n  sources: [s3deploy.Source.jsonData('config.json', appConfig)],\n  destinationBucket,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a custom EC2 Deployment Configuration in TypeScript\nDESCRIPTION: Creates a custom deployment configuration for EC2/on-premise instances with specified minimum healthy hosts requirement.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentConfig = new codedeploy.ServerDeploymentConfig(this, 'DeploymentConfiguration', {\n  deploymentConfigName: 'MyDeploymentConfiguration', // optional property\n  // one of these is required, but both cannot be specified at the same time\n  minimumHealthyHosts: codedeploy.MinimumHealthyHosts.count(2),\n  // minimumHealthyHosts: codedeploy.MinimumHealthyHosts.percentage(75),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing CDK App with Permissions Boundary Context (TypeScript)\nDESCRIPTION: Configures a CDK App to use a specific permissions boundary by supplying a context object to the `App` constructor. The permissions boundary name can be parameterized. This pattern is necessary when the organization enforces permissions boundaries and wants to ensure all IAM resources respect the boundary. Requires the CDK core library and proper context key definition. Input is a configuration object; output is a configured CDK App instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew App({\\n  context: {\\n    [PERMISSIONS_BOUNDARY_CONTEXT_KEY]: {\\n      name: 'cdk-${Qualifier}-PermissionsBoundary',\\n    },\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an MSK Serverless Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an MSK Serverless Cluster, which allows running Apache Kafka without managing cluster capacity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst serverlessCluster = new msk.ServerlessCluster(this, 'ServerlessCluster', {\n  clusterName: 'MyServerlessCluster',\n  vpcConfigs: [\n    { vpc },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Read Access to a Specific Replica DynamoDB Table Using AWS CDK - TypeScript\nDESCRIPTION: Shows how to grant permissions to a specific replica of a DynamoDB global table in AWS CDK, using the 'replica' method for regional specificity. The example uses 'grantReadData' to provide read access just to the replica in 'us-east-2' and its encryption key. Requires 'aws-cdk-lib', 'aws-cdk-lib/aws-kms', and a declared IAM user for correct execution. Inputs are similar to the previous snippet, but focused on the replica; expected output is an IAM policy scoped to the designated region's resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\ndeclare const user: iam.User;\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst tableKey = new kms.Key(stack, 'Key');\nconst replicaKeyArns = {\n  'us-east-1': 'arn:aws:kms:us-east-1:123456789012:key/g24efbna-az9b-42ro-m3bp-cq249l94fca6',\n  'us-east-2': 'arn:aws:kms:us-east-2:123456789012:key/g24efbna-az9b-42ro-m3bp-cq249l94fca6',\n};\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  encryption: dynamodb.TableEncryptionV2.customerManagedKey(tableKey, replicaKeyArns),\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n\n// grantReadData applies to the table in us-east-2 and the key arn for the key in us-east-2\nglobalTable.replica('us-east-2').grantReadData(user);\n```\n\n----------------------------------------\n\nTITLE: Specifying ECS Fargate Platform Version for Scheduled Tasks - AWS CDK - TypeScript\nDESCRIPTION: Shows how to set a specific Fargate platform version when scheduling an ECS task as a target for an EventBridge rule, using the 'platformVersion' property in EcsTask props. Dependencies: 'aws-cdk-lib/aws-ecs', 'aws-cdk-lib/aws-iam', 'aws-cdk-lib/aws-events-targets'. Input resources are cluster, taskDefinition, and role; output is an ECSTask target with version control.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\ndeclare const role: iam.Role;\n\nconst platformVersion = ecs.FargatePlatformVersion.VERSION1_4;\nconst ecsTaskTarget = new targets.EcsTask({ cluster, taskDefinition, role, platformVersion });\n```\n\n----------------------------------------\n\nTITLE: Configuring multiple load balancers for CodeDeploy in TypeScript\nDESCRIPTION: Provides multiple Elastic Load Balancers (Classic, Application, and Network) as target groups for a CodeDeploy Deployment Group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elb from 'aws-cdk-lib/aws-elasticloadbalancing';\nimport * as elb2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\ndeclare const clb: elb.LoadBalancer;\ndeclare const alb: elb2.ApplicationLoadBalancer;\ndeclare const nlb: elb2.NetworkLoadBalancer;\n\nconst albListener = alb.addListener('ALBListener', { port: 80 });\nconst albTargetGroup = albListener.addTargets('ALBFleet', { port: 80 });\n\nconst nlbListener = nlb.addListener('NLBListener', { port: 80 });\nconst nlbTargetGroup = nlbListener.addTargets('NLBFleet', { port: 80 });\n\nconst deploymentGroup = new codedeploy.ServerDeploymentGroup(this, 'DeploymentGroup', {\n  loadBalancers: [\n    codedeploy.LoadBalancer.classic(clb),\n    codedeploy.LoadBalancer.application(albTargetGroup),\n    codedeploy.LoadBalancer.network(nlbTargetGroup),\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing Global Tables with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to reference an existing DynamoDB table in a CDK application using the TableV2 construct, and how to grant permissions to the referenced table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const user: iam.User;\n\nconst table = dynamodb.TableV2.fromTableArn(this, 'ImportedTable', 'arn:aws:dynamodb:us-east-1:123456789012:table/my-table');\n// now you can call methods on the referenced table\ntable.grantReadWriteData(user);\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Environment with CloudWatch Monitors using CDK in TypeScript\nDESCRIPTION: Illustrates how to create an AWS AppConfig Environment associated with a given Application. It configures CloudWatch monitors using existing `cloudwatch.Alarm` and `cloudwatch.CompositeAlarm` instances via the `appconfig.Monitor.fromCloudWatchAlarm` helper method. Requires `application`, `alarm`, and `compositeAlarm` variables (of types `appconfig.Application`, `cloudwatch.Alarm`, and `cloudwatch.CompositeAlarm` respectively) to be previously declared or imported in the scope. Assumes `this` is a CDK `Construct`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const alarm: cloudwatch.Alarm;\ndeclare const compositeAlarm: cloudwatch.CompositeAlarm;\n\nnew appconfig.Environment(this, 'MyEnvironment', {\n  application,\n  monitors: [\n    appconfig.Monitor.fromCloudWatchAlarm(alarm),\n    appconfig.Monitor.fromCloudWatchAlarm(compositeAlarm),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a New SSM StringParameter - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to define a new SSM StringParameter resource in a CDK stack with advanced configuration such as allowed regular expression pattern, custom description, name, and tier level. This snippet provisions a string parameter directly via the ssm module and requires granting the necessary permissions. Inputs include allowedPattern, description, parameterName, stringValue, and tier; output is a parameter resource in Parameter Store.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew ssm.StringParameter(this, 'Parameter', {\n  allowedPattern: '.*',\n  description: 'The value Foo',\n  parameterName: 'FooParameter',\n  stringValue: 'Foo',\n  tier: ssm.ParameterTier.ADVANCED,\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing an ECR Image for SageMaker Container Image with TypeScript\nDESCRIPTION: This snippet demonstrates how to reference an image available in Amazon ECR for use as a SageMaker container image using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\nconst repository = ecr.Repository.fromRepositoryName(this, 'Repository', 'repo');\nconst image = sagemaker.ContainerImage.fromEcrRepository(repository, 'tag');\n```\n\n----------------------------------------\n\nTITLE: Scheduling an ECS Task with EventBridge Rule - AWS CDK - TypeScript\nDESCRIPTION: Illustrates configuring an EventBridge rule to schedule an ECS task execution daily at 4am, using the AWS CDK. Uses the 'Schedule.cron' utility and an ECSTask target. Requires 'aws-cdk-lib/aws-events', 'aws-cdk-lib/aws-events-targets', 'aws-cdk-lib/aws-ecs', and 'aws-cdk-lib/aws-iam' as dependencies. Inputs are ECS cluster, task definition, and IAM role instances; the output is a scheduled rule resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Rule, Schedule } from 'aws-cdk-lib/aws-events';\nimport { EcsTask } from 'aws-cdk-lib/aws-events-targets';\nimport { Cluster, TaskDefinition } from 'aws-cdk-lib/aws-ecs';\nimport { Role } from 'aws-cdk-lib/aws-iam';\n\ndeclare const cluster: Cluster;\ndeclare const taskDefinition: TaskDefinition;\ndeclare const role: Role;\n\nconst ecsTaskTarget = new EcsTask({ cluster, taskDefinition, role });\n\nnew Rule(this, 'ScheduleRule', {\n schedule: Schedule.cron({ minute: '0', hour: '4' }),\n targets: [ecsTaskTarget],\n});\n```\n\n----------------------------------------\n\nTITLE: Asserting Resource Count with Properties in TypeScript\nDESCRIPTION: Shows how to use `resourcePropertiesCountIs()` to assert the number of resources of a specific type that also contain a specific set of properties. It takes the resource type, a property object for matching, and the expected count.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.resourcePropertiesCountIs('Foo::Bar', {\n  Foo: 'Bar',\n  Baz: 5,\n  Qux: [ 'Waldo', 'Fred' ],\n}, 1);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring a CloudFront Distribution with Custom Domain and ACM Certificate using TypeScript\nDESCRIPTION: Explains how to associate a custom domain name (`www.example.com`) and an AWS Certificate Manager (ACM) certificate with a CloudFront `Distribution`. It requires creating or referencing an `acm.Certificate` validated via DNS (using a `route53.HostedZone`) and specifying both the certificate and the domain name(s) in the distribution properties. The certificate must be in the `us-east-1` region. Assumes an existing S3 bucket (`myBucket`) and Route 53 hosted zone (`hostedZone`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// To use your own domain name in a Distribution, you must associate a certificate\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\nimport * as route53 from 'aws-cdk-lib/aws-route53';\n\ndeclare const hostedZone: route53.HostedZone;\nconst myCertificate = new acm.Certificate(this, 'mySiteCert', {\n  domainName: 'www.example.com',\n  validation: acm.CertificateValidation.fromDns(hostedZone),\n});\n\ndeclare const myBucket: s3.Bucket;\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.S3Origin(myBucket) },\n  domainNames: ['www.example.com'],\n  certificate: myCertificate,\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Missing KMS Key with Dummy Key Fallback Using AWS CDK in TypeScript\nDESCRIPTION: Looks up a KMS key by alias, and if the target is missing, returns a dummy key to prevent failures in non-critical or CI/CD environments. The dummy key uses a well-known keyId and can be detected via 'Key.isLookupDummy()'. Requires 'aws-cdk-lib/aws-kms'. This pattern helps maintain stack deployability when cross-account or cross-environment resources are unavailable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst dummy = kms.Key.fromLookup(this, 'MyKeyLookup', {\n  aliasName: 'alias/NonExistentAlias',\n  returnDummyKeyOnMissing: true,\n});\n\nif (kms.Key.isLookupDummy(dummy)) {\n  // alternative process\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Docker Options for Asset Bundling in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates providing additional docker run options when performing asset bundling with AWS CDK. Using BundlingOptions, it specifies the docker image, build command, security options, and network configuration for the containerized bundler. The example uses a Python Lambda runtime's default bundling image and installs dependencies before copying all files. Dependencies are aws-cdk-lib and aws-cdk-lib/aws-lambda, and a working Docker environment. Key parameters include image, command, securityOpt, and network. This setup is suitable for environments needing specific container runtime configuration for bundling assets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-assets/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\nconst asset = new Asset(this, 'BundledAsset', {\n  path: '/path/to/asset',\n  bundling: {\n    image: lambda.Runtime.PYTHON_3_9.bundlingImage,\n    command: [\n      'bash', '-c',\n      'pip install -r requirements.txt -t /asset-output && cp -au . /asset-output'\n    ],\n    securityOpt: 'no-new-privileges:true', // https://docs.docker.com/engine/reference/commandline/run/#optional-security-options---security-opt\n    network: 'host', //https://docs.docker.com/engine/reference/commandline/run/#connect-a-container-to-a-network---network\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling CloudTrail Insights using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable CloudTrail Insights for a trail using the AWS CDK. It specifies the types of insights to enable (`ApiCallRateInsight` and `ApiErrorRateInsight`) using the `insightTypes` property with values from `cloudtrail.InsightType`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nnew cloudtrail.Trail(this, 'Insights', {\n    insightTypes: [\n      cloudtrail.InsightType.API_CALL_RATE,\n      cloudtrail.InsightType.API_ERROR_RATE,\n    ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining BuildSpec for Multi-Input/Output CodeBuild Action in TypeScript\nDESCRIPTION: This snippet provides an example `BuildSpec` definition (using `codebuild.BuildSpec.fromObject`) for a CodeBuild project that handles multiple inputs and outputs within a CodePipeline action. It shows how to access the secondary input source directory using the `CODEBUILD_SRC_DIR_source2` environment variable and how to define multiple output artifacts under the `secondary-artifacts` section, corresponding to the names provided in the `CodeBuildAction`'s `outputs` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst project = new codebuild.PipelineProject(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands: [\n          // By default, you're in a directory with the contents of the repository from sourceAction1.\n          // Use the CODEBUILD_SRC_DIR_source2 environment variable\n          // to get a path to the directory with the contents of the second input repository.\n        ],\n      },\n    },\n    artifacts: {\n      'secondary-artifacts': {\n        'artifact1': {\n          // primary Action output artifact,\n          // available as buildAction.outputArtifact\n        },\n        'artifact2': {\n          // additional output artifact,\n          // available as buildAction.additionalOutputArtifact('artifact2')\n        },\n      },\n    },\n  }),\n  // ...\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Flink Application Parameters in TypeScript\nDESCRIPTION: Shows how to configure various Flink application parameters including checkpointing, logging, metrics, auto-scaling, and parallelism settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-kinesisanalytics-flink-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst flinkApp = new flink.Application(this, 'Application', {\n  code: flink.ApplicationCode.fromBucket(bucket, 'my-app.jar'),\n  runtime: flink.Runtime.FLINK_1_20,\n  checkpointingEnabled: true, // default is true\n  checkpointInterval: Duration.seconds(30), // default is 1 minute\n  minPauseBetweenCheckpoints: Duration.seconds(10), // default is 5 seconds\n  logLevel: flink.LogLevel.ERROR, // default is INFO\n  metricsLevel: flink.MetricsLevel.PARALLELISM, // default is APPLICATION\n  autoScalingEnabled: false, // default is true\n  parallelism: 32, // default is 1\n  parallelismPerKpu: 2, // default is 1\n  snapshotsEnabled: false, // default is true\n  logGroup: new logs.LogGroup(this, 'LogGroup'), // by default, a new LogGroup will be created\n});\n```\n\n----------------------------------------\n\nTITLE: Using CloudFormation Intrinsic Functions\nDESCRIPTION: Demonstrates usage of CloudFormation intrinsic functions through the Fn class.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myObjectOrArray: any;\ndeclare const myArray: any;\n\n// To use Fn::Base64\nFn.base64('SGVsbG8gQ0RLIQo=');\n\n// To compose condition expressions:\nconst environmentParameter = new CfnParameter(this, 'Environment');\nFn.conditionAnd(\n  // The \"Environment\" CloudFormation template parameter evaluates to \"Production\"\n  Fn.conditionEquals('Production', environmentParameter),\n  // The AWS::Region pseudo-parameter value is NOT equal to \"us-east-1\"\n  Fn.conditionNot(Fn.conditionEquals('us-east-1', Aws.REGION)),\n);\n\n// To use Fn::ToJsonString\nFn.toJsonString(myObjectOrArray);\n\n// To use Fn::Length\nFn.len(Fn.split(',', myArray));\n```\n\n----------------------------------------\n\nTITLE: Importing Existing S3 Origin Access Control by ID - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import an existing S3OriginAccessControl resource into an AWS CDK application using the fromOriginAccessControlId method. This is essential for cases where OAC resources were created outside the current CDK stack. Precondition: supply the OAC ID. The result is a reference to an imported OAC instance for further use.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst importedOAC = cloudfront.S3OriginAccessControl.fromOriginAccessControlId(this, 'myImportedOAC', 'ABC123ABC123AB');\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront KeyGroup and PublicKey (TypeScript)\nDESCRIPTION: Demonstrates creating AWS CloudFront `PublicKey` and `KeyGroup` resources using AWS CDK. A `PublicKey` is instantiated with the PEM-encoded public key string (obtained from the `public_key.pem` file generated by OpenSSL). This key is then added to a `KeyGroup`, which can be associated with a CloudFront distribution for validating signed URLs or cookies. Requires `@aws-cdk/aws-cloudfront` and `@aws-cdk/core` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_47\n\nLANGUAGE: ts\nCODE:\n```\n// Create a key group to use with CloudFront signed URLs and signed cookies.\nnew cloudfront.KeyGroup(this, 'MyKeyGroup', {\n  items: [\n    new cloudfront.PublicKey(this, 'MyPublicKey', {\n      encodedKey: '...', // contents of public_key.pem file\n      // comment: 'Key is expiring on ...',\n    }),\n  ],\n  // comment: 'Key group containing public keys ...',\n});\n```\n\n----------------------------------------\n\nTITLE: Package Structure URL References\nDESCRIPTION: Markdown links referencing key files in the package structure with their relative paths.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/example-construct-library/README.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* [`lib/example-resource.ts`](lib/example-resource.ts)\n* [`lib/private/example-resource-common.ts`](lib/private/example-resource-common.ts)\n* [`test/example-resource.test.ts`](test/example-resource.test.ts)\n* [`test/integ.example-resource.ts`](test/integ.example-resource.ts)\n* [`test/integ.example-resource.expected.json`](test/integ.example-resource.expected.json)\n```\n\n----------------------------------------\n\nTITLE: Creating a Cross-Account CloudFormation Action with Explicit Role in AWS CodePipeline\nDESCRIPTION: Configures a CloudFormation action with an explicitly provided IAM role for cross-account deployment. This approach allows more fine-grained control over the permissions used when deploying across account boundaries.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PhysicalName } from 'aws-cdk-lib';\n\n// in stack for account 123456789012...\ndeclare const otherAccountStack: Stack;\nconst actionRole = new iam.Role(otherAccountStack, 'ActionRole', {\n  assumedBy: new iam.AccountPrincipal('123456789012'),\n  // the role has to have a physical name set\n  roleName: PhysicalName.GENERATE_IF_NEEDED,\n});\n\n// in the pipeline stack...\nconst sourceOutput = new codepipeline.Artifact();\nnew codepipeline_actions.CloudFormationCreateUpdateStackAction({\n  actionName: 'CloudFormationCreateUpdate',\n  stackName: 'MyStackName',\n  adminPermissions: true,\n  templatePath: sourceOutput.atPath('template.yaml'),\n  role: actionRole, // this action will be cross-account as well\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Provisioned Pollers for Kafka Event Source\nDESCRIPTION: Shows how to configure provisioned pollers that read from the Kafka event source, including minimum and maximum poller settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ManagedKafkaEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\n// Your MSK cluster arn\ndeclare const clusterArn: string\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new ManagedKafkaEventSource({\n  clusterArn,\n  topic,\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n  provisionedPollerConfig: {\n    minimumPollers: 1,\n    maximumPollers: 3,\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a CodeDeploy Deployment Group for EC2/on-premise instances in TypeScript\nDESCRIPTION: Creates a new CodeDeploy Deployment Group for EC2/on-premise instances with various configuration options including auto-scaling groups, EC2 instance tags, on-premise instance tags, alarms, and auto-rollback settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as autoscaling from 'aws-cdk-lib/aws-autoscaling';\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\ndeclare const application: codedeploy.ServerApplication;\ndeclare const asg: autoscaling.AutoScalingGroup;\ndeclare const alarm: cloudwatch.Alarm;\nconst deploymentGroup = new codedeploy.ServerDeploymentGroup(this, 'CodeDeployDeploymentGroup', {\n  application,\n  deploymentGroupName: 'MyDeploymentGroup',\n  autoScalingGroups: [asg],\n  // adds User Data that installs the CodeDeploy agent on your auto-scaling groups hosts\n  // default: true\n  installAgent: true,\n  // adds EC2 instances matching tags\n  ec2InstanceTags: new codedeploy.InstanceTagSet(\n    {\n      // any instance with tags satisfying\n      // key1=v1 or key1=v2 or key2 (any value) or value v3 (any key)\n      // will match this group\n      'key1': ['v1', 'v2'],\n      'key2': [],\n      '': ['v3'],\n    },\n  ),\n  // adds on-premise instances matching tags\n  onPremiseInstanceTags: new codedeploy.InstanceTagSet(\n    // only instances with tags (key1=v1 or key1=v2) AND key2=v3 will match this set\n    {\n      'key1': ['v1', 'v2'],\n    },\n    {\n      'key2': ['v3'],\n    },\n  ),\n  // CloudWatch alarms\n  alarms: [alarm],\n  // whether to ignore failure to fetch the status of alarms from CloudWatch\n  // default: false\n  ignorePollAlarmsFailure: false,\n  // whether to skip the step of checking CloudWatch alarms during the deployment process\n  // default: false\n  ignoreAlarmConfiguration: false,\n  // auto-rollback configuration\n  autoRollback: {\n    failedDeployment: true, // default: true\n    stoppedDeployment: true, // default: false\n    deploymentInAlarm: true, // default: true if you provided any alarms, false otherwise\n  },\n  // whether the deployment group was configured to have CodeDeploy install a termination hook into an Auto Scaling group\n  // default: false\n  terminationHook: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Lambda Layer in AWS CDK\nDESCRIPTION: Defines a Python Lambda layer with dependencies automatically included if requirements.txt, Pipfile, or poetry.lock is detected at the entry path.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonLayerVersion(this, 'MyLayer', {\n  entry: '/path/to/my/layer', // point this to your library's directory\n})\n```\n\n----------------------------------------\n\nTITLE: Granting Read Permissions to IAM Role on Kinesis Stream - AWS CDK - TypeScript\nDESCRIPTION: This example grants read access to a Kinesis stream for a specific IAM role using the grantRead method. If the stream is encrypted, it also grants decryption on the associated KMS key. The code requires aws-cdk-lib, iam, kinesis, and constructs modules. Inputs include an IAM role and the relevant stream; outputs are permission assignments for read access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst lambdaRole = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n  description: 'Example role...',\n});\n\nconst stream = new kinesis.Stream(this, 'MyEncryptedStream', {\n  encryption: kinesis.StreamEncryption.KMS,\n});\n\n// give lambda permissions to read stream\nstream.grantRead(lambdaRole);\n```\n\n----------------------------------------\n\nTITLE: Creating IAM Instance Profiles with Roles in AWS CDK\nDESCRIPTION: Creates an IAM instance profile with an associated role. Instance profiles are containers for IAM roles that can be used to pass role information to EC2 instances when they start.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n});\n\nconst instanceProfile = new iam.InstanceProfile(this, 'InstanceProfile', {\n  role,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring FSx for Lustre with HDD Storage in AWS CDK\nDESCRIPTION: Creates an FSx for Lustre file system with HDD storage type, which is only supported for PERSISTENT_1 deployment types. This code defines a file system with 1200 GiB capacity deployed in a private subnet of a VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst fileSystem = new fsx.LustreFileSystem(this, 'FsxLustreFileSystem', {\n  lustreConfiguration: { deploymentType: fsx.LustreDeploymentType.PERSISTENT_1 },\n  storageCapacityGiB: 1200,\n  vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n  storageType: fsx.StorageType.HDD,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for AWS CDK Integration Tests\nDESCRIPTION: Terminal commands for setting up required environment variables before running integration tests. These variables configure the hosted zone ID, zone name, domain name, and certificate ARN required for DNS and certificate-based tests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nexport HOSTED_ZONE_ID=your_hosted_zone_id\nexport HOSTED_ZONE_NAME=your_hosted_zone_name\nexport DOMAIN_NAME=your_domain_name\nexport CERT_ARN=your_certificate_arn\n```\n\n----------------------------------------\n\nTITLE: Creating AWS AppSync Event API with API Key Authorization in TypeScript\nDESCRIPTION: This example shows how to create an AWS AppSync Event API with API Key authorization. It sets up the API with a channel namespace and configures authorization for connection, publishing, and subscribing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst apiKeyProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.API_KEY,\n};\n\nconst api = new appsync.EventApi(this, 'api', {\n  apiName: 'Api',\n  ownerContact: 'OwnerContact',\n  authorizationConfig: {\n    authProviders: [\n      apiKeyProvider,\n    ],\n    connectionAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultPublishAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultSubscribeAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n  },\n});\n\napi.addChannelNamespace('default');\n```\n\n----------------------------------------\n\nTITLE: Subscribing Amazon SQS Queue to SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: This snippet adds a subscription between an SNS topic and an SQS queue in TypeScript using AWS CDK. It requires the aws-cdk-lib/aws-sqs and aws-cdk-lib/aws-sns-subscriptions packages. When the queue is encrypted, permissions are automatically granted for SNS to send messages. Input parameters include initialized SNS and SQS resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myQueue = new sqs.Queue(this, 'MyQueue');\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.addSubscription(new subscriptions.SqsSubscription(myQueue));\n```\n\n----------------------------------------\n\nTITLE: Creating a VirtualNode with backend virtual service\nDESCRIPTION: Demonstrates how to create a VirtualNode and add a backend virtual service to allow egress traffic to other nodes. The virtual service is configured with a virtual router provider.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\ndeclare const router: appmesh.VirtualRouter;\ndeclare const service: cloudmap.Service;\n\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service),\n  listeners: [appmesh.VirtualNodeListener.http({\n    port: 8080,\n    healthCheck: appmesh.HealthCheck.http({\n      healthyThreshold: 3,\n      interval: Duration.seconds(5),\n      path: '/ping',\n      timeout: Duration.seconds(2),\n      unhealthyThreshold: 2,\n    }),\n    timeout: {\n      idle: Duration.seconds(5),\n    },\n  })],\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout'),\n});\n\nconst virtualService = new appmesh.VirtualService(this, 'service-1', {\n  virtualServiceProvider: appmesh.VirtualServiceProvider.virtualRouter(router),\n  virtualServiceName: 'service1.domain.local',\n});\n\nnode.addBackend(appmesh.Backend.virtualService(virtualService));\n```\n\n----------------------------------------\n\nTITLE: Configuring Transit Gateway with Custom Route Table Settings in TypeScript\nDESCRIPTION: Demonstrates how to create a Transit Gateway with custom settings for the default route table, disabling automatic association and propagation while still creating a default route table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway', {\n  defaultRouteTableAssociation: false,\n  defaultRouteTablePropagation: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Composite IAM Principal\nDESCRIPTION: Shows how to create a composite principal that combines multiple principal types for role assumption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'MyRole', {\n  assumedBy: new iam.CompositePrincipal(\n    new iam.ServicePrincipal('ec2.amazonaws.com'),\n    new iam.AccountPrincipal('1818188181818187272')\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying an Execution Role for Schedule Target (AWS CDK, TypeScript)\nDESCRIPTION: Creates and uses a custom IAM role for EventBridge Scheduler to assume when invoking a Lambda function. Ensures the role has appropriate permissions. Inputs are the Lambda function and IAM role configuration; outputs are a target with a specified execution role. Dependencies: lambda.Function, iam.Role, LambdaInvoke, ScheduleTargetInput.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nconst role = new iam.Role(this, 'Role', {\n    assumedBy: new iam.ServicePrincipal('scheduler.amazonaws.com'),\n});\n\nconst target = new targets.LambdaInvoke(fn, {\n    input: ScheduleTargetInput.fromObject({\n        \"payload\": \"useful\"\n    }),\n    role,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Enhanced VPC Routing for Redshift Cluster using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates creating an AWS Redshift cluster with Enhanced VPC Routing enabled using AWS CDK. Setting `enhancedVpcRouting` to `true` forces all COPY and UNLOAD traffic between the cluster and data repositories through the specified VPC, enabling the use of VPC security features like security groups and network ACLs. Requires an existing VPC instance (`vpc`) and master user configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nnew Cluster(this, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n    enhancedVpcRouting: true,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Subscribing to CodePipeline State Change Events - AWS CDK - TypeScript\nDESCRIPTION: Shows how to define CloudWatch event rules tied to pipeline, stage, or action state changes using the 'onStateChange' methods of each respective construct. Requires '@aws-cdk/aws-events' module and assumes instances of pipeline, stage, action, and target are pre-declared. Useful for automating downstream workflows or notifications based on pipeline activity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// Define event rules for events emitted by the pipeline\nimport * as events from 'aws-cdk-lib/aws-events';\n\ndeclare const myPipeline: codepipeline.Pipeline;\ndeclare const myStage: codepipeline.IStage;\ndeclare const myAction: codepipeline.Action;\ndeclare const target: events.IRuleTarget;\nmyPipeline.onStateChange('MyPipelineStateChange', { target: target } );\nmyStage.onStateChange('MyStageStateChange', target);\nmyAction.onStateChange('MyActionStateChange', target);\n```\n\n----------------------------------------\n\nTITLE: Creating Amazon FSx for Lustre File System with Basic Properties in TypeScript\nDESCRIPTION: This snippet shows how to define and instantiate an Amazon FSx for Lustre file system in a VPC using AWS CDK. It requires an existing VPC object and specifies Lustre deployment type, storage capacity (in GiB), and the target VPC subnet. Input parameters include the VPC, storage capacity, and Lustre deployment configuration. Outputs a fully managed FSx Lustre file system resource within your AWS environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst fileSystem = new fsx.LustreFileSystem(this, 'FsxLustreFileSystem', {\n  lustreConfiguration: { deploymentType: fsx.LustreDeploymentType.SCRATCH_2 },\n  storageCapacityGiB: 1200,\n  vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Function with Comprehensive Configuration in TypeScript\nDESCRIPTION: An example demonstrating a Lambda function with numerous properties configured for thorough integration testing. This approach tests multiple configuration options in a single test case.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'Handler', {\n  code,\n  handler,\n  runtime,\n  architecture,\n  description,\n  environment,\n  environmentEncryption,\n  functionName,\n  initialPolicy,\n  insightsVersion,\n  layers,\n  maxEventAge,\n  memorySize,\n  reservedConcurrentExecutions,\n  retryAttempts,\n  role,\n  timeout,\n  tracing,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Compression in FSx for Lustre Configuration in TypeScript\nDESCRIPTION: This snippet shows how to activate transparent data compression in FSx for Lustre via the dataCompressionType property. It presumes the existance of a Lustre configuration object. Setting this property ensures that all files written after the feature is enabled are compressed using the specified algorithm (LZ4). Existing files remain uncompressed; see AWS documentation for migration steps.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst lustreConfiguration = {\n  // ...\n  dataCompressionType: fsx.LustreDataCompressionType.LZ4,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ACM Certificates in CloudFront Distribution\nDESCRIPTION: Shows how to configure ACM certificates and domain aliases in CloudFront distributions using both legacy and modern APIs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\ndeclare const certificate: acm.Certificate;\ndeclare const sourceBucket: s3.Bucket;\n\nconst viewerCertificate = cloudfront.ViewerCertificate.fromAcmCertificate(certificate, {\n  aliases: ['MYALIAS'],\n});\n\nnew cloudfront.CloudFrontWebDistribution(this, 'MyCfWebDistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n      },\n      behaviors : [ {isDefaultBehavior: true} ],\n    },\n  ],\n  viewerCertificate: viewerCertificate,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\ndeclare const certificate: acm.Certificate;\ndeclare const sourceBucket: s3.Bucket;\n\nconst distribution = new cloudfront.Distribution(this, 'MyCfWebDistribution', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(sourceBucket),\n  },\n  domainNames: ['MYALIAS'],\n  certificate: certificate,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project Logging to CloudWatch Logs in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure an AWS CodeBuild project to send its build logs to a specific AWS CloudWatch Log Group using the AWS CDK. A new Log Group is created and assigned to the project's logging configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  logging: {\n    cloudWatch: {\n      logGroup: new logs.LogGroup(this, `MyLogGroup`),\n    }\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an SSM OpsItem via a CloudWatch Alarm Action (TypeScript)\nDESCRIPTION: This snippet shows how to configure a CloudWatch alarm to create an SSM OpsCenter OpsItem when triggered. It uses the `SsmAction` class from the `aws-cdk-lib/aws-cloudwatch-actions` module, allowing specification of the OpsItem's severity (e.g., `OpsItemSeverity.CRITICAL`) and optionally its category (e.g., `OpsItemCategory.PERFORMANCE`). This action is attached to a declared `cloudwatch.Alarm` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch-actions/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const alarm: cloudwatch.Alarm;\n// Create an OpsItem with specific severity and category when alarm triggers\nalarm.addAlarmAction(\n  new actions.SsmAction(\n    actions.OpsItemSeverity.CRITICAL,\n    actions.OpsItemCategory.PERFORMANCE // category is optional\n  )\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Tagging Recovery Points in AWS Backup Rules - AWS CDK - TypeScript\nDESCRIPTION: Illustrates the use of recoveryPointTags in a BackupPlanRule to assign custom metadata (key-value pairs) to resources restored from backup, using the AWS CDK backup module in TypeScript. Only recoveryPointTags is set in the rule. Expects a valid tags object; result is that all recovery points created by the rule will have the specified tags when restored.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\nplan.addRule(new backup.BackupPlanRule({\n  recoveryPointTags: {\n    key: 'value',\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudWatch Math Expression Summing Two Metrics (TypeScript)\nDESCRIPTION: Demonstrates creating a `cloudwatch.MathExpression` to perform calculations on other metrics. This example defines an expression 'errors + throttles' and maps these variable names to corresponding `Metric` objects obtained from a Lambda function (`fn.metricErrors()` and `fn.metricThrottles()`). Requires an existing `lambda.Function` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nconst allProblems = new cloudwatch.MathExpression({\n  expression: \"errors + throttles\",\n  usingMetrics: {\n    errors: fn.metricErrors(),\n    throttles: fn.metricThrottles(),\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Organizing Widgets Horizontally with Row Widget (TypeScript)\nDESCRIPTION: Explains how to arrange widgets side by side in a horizontal layout by using the Row construct. Requires cloudwatch.IWidget-compatible objects and Row from aws-cdk-lib/aws-cloudwatch. Widgets exceeding grid width wrap to a new line.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const widgetA: cloudwatch.IWidget;\ndeclare const widgetB: cloudwatch.IWidget;\n\nnew cloudwatch.Row(widgetA, widgetB);\n```\n\n----------------------------------------\n\nTITLE: Enabling Deployment Circuit Breaker and Rollback for ApplicationLoadBalancedFargateService (TypeScript)\nDESCRIPTION: Enables Amazon ECS deployment circuit breaker with automatic rollback in ApplicationLoadBalancedFargateService. This feature detects unhealthy service deployments and rolls back to the last stable state, reducing manual intervention. Requires specifying circuitBreaker: { rollback: true } along with other service and task properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst service = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  desiredCount: 1,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n  circuitBreaker: { rollback: true },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Logs Insights Query Definitions\nDESCRIPTION: Shows how to create a Logs Insights query definition with custom parsing statements, filters, and sorting options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nnew logs.QueryDefinition(this, 'QueryDefinition', {\n  queryDefinitionName: 'MyQuery',\n  queryString: new logs.QueryString({\n    fields: ['@timestamp', '@message'],\n    parseStatements: [\n      '@message \"[*] *\" as loggingType, loggingMessage',\n      '@message \"<*>: *\" as differentLoggingType, differentLoggingMessage',\n    ],\n    filterStatements: [\n      'loggingType = \"ERROR\"',\n      'loggingMessage = \"A very strange error occurred!\"',\n    ],\n    sort: '@timestamp desc',\n    limit: 20,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an API Destination Target for EventBridge Pipe in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe with an API Destination as the target. The pipe will send events from an SQS queue source to the API destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const dest: events.ApiDestination;\n\nconst apiTarget = new targets.ApiDestinationTarget(dest);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: apiTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a GameLift Build Fleet with Custom Game Server in TypeScript\nDESCRIPTION: Configures a GameLift fleet for hosting custom game servers. The fleet uses the specified computing resources and deploys a game server build that's loaded from a local asset directory.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: gamelift.Build.fromAsset(this, 'Build', path.join(__dirname, 'CustomerGameServer')),\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: 'test-launch-path',\n    }],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront S3 Origin with SSE-KMS Encryption - AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates how to set up a CloudFront Distribution aligned with an S3 bucket that uses server-side encryption with AWS KMS (SSE-KMS). It requires importing the AWS KMS module and ensures the Origin Access Control receives required key permissions automatically. Key parameters include the KMS key, the S3 bucket (with KMS encryption and enforced object ownership), and use of the S3BucketOrigin.withOriginAccessControl helper. Outputs a Distribution with secure, encrypted S3 access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst myKmsKey = new kms.Key(this, 'myKMSKey');\nconst myBucket = new s3.Bucket(this, 'mySSEKMSEncryptedBucket', {\n  encryption: s3.BucketEncryption.KMS,\n  encryptionKey: myKmsKey,\n  objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_ENFORCED,\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket) // Automatically grants Distribution access to `myKmsKey`\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Appending a Trigger to an Existing Pipeline using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add a new trigger to an already created CodePipeline instance using the addTrigger method in AWS CDK (TypeScript). It configures a pushFilter based on Git tags for the pipeline and requires codepipeline and codepipeline_actions modules with an existing pipeline and sourceAction. This enables dynamic updates to pipeline event triggers post-creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeline: codepipeline.Pipeline;\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\n\npipeline.addTrigger({\n  providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n  gitConfiguration: {\n    sourceAction,\n    pushFilter: [{\n      tagsExcludes: ['exclude1', 'exclude2'],\n      tagsIncludes: ['include*'],\n    }],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EventBridge Event Bus Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an EventBridge event bus as the target. The pipe will send events from an SQS queue source to the event bus.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetEventBus: events.EventBus;\n\nconst eventBusTarget = new targets.EventBridgeTarget(targetEventBus);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: eventBusTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Deployment Strategy with Predefined Rollout using CDK in TypeScript\nDESCRIPTION: Instantiates an AWS AppConfig Deployment Strategy using one of the predefined rollout strategies provided by the CDK (`appconfig.RolloutStrategy.CANARY_10_PERCENT_20_MINUTES`). This simplifies configuration for common deployment patterns. Assumes `this` is a CDK `Construct` and `appconfig` is the imported module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew appconfig.DeploymentStrategy(this, 'MyDeploymentStrategy', {\n  rolloutStrategy: appconfig.RolloutStrategy.CANARY_10_PERCENT_20_MINUTES,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Repository Lifecycle Rules\nDESCRIPTION: Configures lifecycle rules to automatically clean up old images from the repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nrepository.addLifecycleRule({ tagPrefixList: ['prod'], maxImageCount: 9999 });\nrepository.addLifecycleRule({ maxImageAge: Duration.days(30) });\n```\n\n----------------------------------------\n\nTITLE: Adding an Existing Lambda@Edge Function to CloudFront using AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to attach a pre-existing Lambda@Edge function (potentially created in a different stack or region) to a CloudFront distribution's default behavior. It uses `lambda.Version.fromVersionArn` to reference the specific function version by its ARN and associates it with the `VIEWER_REQUEST` event type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// Adding an existing Lambda@Edge function created in a different stack\n// to a CloudFront distribution.\ndeclare const s3Bucket: s3.Bucket;\nconst functionVersion = lambda.Version.fromVersionArn(this, 'Version', 'arn:aws:lambda:us-east-1:123456789012:function:functionName:1');\n\nnew cloudfront.Distribution(this, 'distro', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(s3Bucket),\n    edgeLambdas: [\n      {\n        functionVersion,\n        eventType: cloudfront.LambdaEdgeEventType.VIEWER_REQUEST,\n      },\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving IPv6 Pool ID for BYOIP CIDR using AWS CLI\nDESCRIPTION: This command demonstrates how to retrieve the IPv6 pool ID for a provisioned BYOIP CIDR block using the AWS CLI. The pool ID is used when declaring a VPC with BYOIP addresses.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\naws ec2 describe-byoip-cidr --region <region>\n```\n\n----------------------------------------\n\nTITLE: Granting Write Permissions to IAM Role on Kinesis Stream - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates granting write access to an IAM role for a Kinesis stream using the grantWrite method. If the stream has an encryption key, permissions to encrypt are also granted. Requires aws-cdk-lib, iam, kinesis, and constructs modules. Main parameters are the IAM role and the stream; output is the ability for the role to write records to the stream.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst lambdaRole = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n  description: 'Example role...',\n});\n\nconst stream = new kinesis.Stream(this, 'MyEncryptedStream', {\n  encryption: kinesis.StreamEncryption.KMS,\n});\n\n// give lambda permissions to write to stream\nstream.grantWrite(lambdaRole);\n```\n\n----------------------------------------\n\nTITLE: Allowing EC2 Instance Access to EFS File System with AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure network connectivity for an EFS file system using the `connections` attribute in AWS CDK. The `allowDefaultPortFrom` method is used to grant network access from a specified EC2 instance (`instance`) to the EFS file system (`fileSystem`) on the default NFS port (2049).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=with-filesystem-instance\nfileSystem.connections.allowDefaultPortFrom(instance);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Target Input with Context Attributes (AWS CDK, TypeScript)\nDESCRIPTION: Demonstrates how to craft a text-based input payload using context attributes, which EventBridge Scheduler interpolates at runtime (e.g., attempt number). Useful for dynamic, templated payloads. Input is a string or template; output is schedule target input with runtime values. Dependency: ScheduleTargetInput, ContextAttribute.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst text = `Attempt number: ${ContextAttribute.attemptNumber}`;\nconst input = ScheduleTargetInput.fromText(text);\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration with Custom Content in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration with user-specified content. The content type defaults to 'application/octet-stream' unless specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInline('This is my configuration content.'),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining BitBucket Source Credentials for CodeBuild in TypeScript\nDESCRIPTION: This snippet demonstrates creating BitBucket source credentials for AWS CodeBuild using the AWS CDK. It fetches the username and password from a single secret stored in AWS Secrets Manager by specifying the `jsonField` within `SecretValue.secretsManager`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.BitBucketSourceCredentials(this, 'CodeBuildBitBucketCreds', {\n  username: SecretValue.secretsManager('my-bitbucket-creds', { jsonField: 'username' }),\n  password: SecretValue.secretsManager('my-bitbucket-creds', { jsonField: 'password' }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Build Timeout in CodeBuild Project\nDESCRIPTION: Demonstrates how to set a custom build timeout duration for a CodeBuild project, overriding the default 60-minute timeout.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  timeout: Duration.minutes(90)\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AppSync Function with Lambda Batching in TypeScript\nDESCRIPTION: This TypeScript CDK snippet demonstrates creating an AppSync Function that uses a Lambda data source. It specifically configures the `maxBatchSize` property to control the maximum number of resolver request inputs sent to the Lambda function in a single `BatchInvoke` operation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.GraphqlApi;\ndeclare const lambdaDataSource: appsync.LambdaDataSource;\n\nconst appsyncFunction = new appsync.AppsyncFunction(this, 'function', {\n  name: 'appsync_function',\n  api,\n  dataSource: lambdaDataSource,\n  maxBatchSize: 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Glue Table Schema with Complex Types in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Glue S3 Table using the AWS CDK, defining columns with various data types including primitive, array, map, and struct types. It showcases the flexibility of the glue.Schema class for creating complex column definitions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  columns: [{\n    name: 'primitive_column',\n    type: glue.Schema.STRING,\n  }, {\n    name: 'array_column',\n    type: glue.Schema.array(glue.Schema.INTEGER),\n    comment: 'array<integer>',\n  }, {\n    name: 'map_column',\n    type: glue.Schema.map(\n      glue.Schema.STRING,\n      glue.Schema.TIMESTAMP),\n    comment: 'map<string,string>',\n  }, {\n    name: 'struct_column',\n    type: glue.Schema.struct([{\n      name: 'nested_column',\n      type: glue.Schema.DATE,\n      comment: 'nested comment',\n    }]),\n    comment: \"struct<nested_column:date COMMENT 'nested comment'>\",\n  }],\n  // ...\n  database: myDatabase,\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Enforcing IMDSv2 on All AutoScalingGroups in a Stack using an Aspect in TypeScript\nDESCRIPTION: This snippet shows how to enforce IMDSv2 for all Auto Scaling Groups within an AWS CDK stack using the `AutoScalingGroupRequireImdsv2Aspect`. An instance of the aspect is created and added to the stack using `Aspects.of(this).add()`. This ensures that any `AutoScalingGroup` defined in the scope will have IMDSv2 enforced.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst aspect = new autoscaling.AutoScalingGroupRequireImdsv2Aspect();\n\nAspects.of(this).add(aspect);\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating AppSync with Aurora Serverless V1 using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates configuring AWS CDK resources to connect an AppSync API with an Aurora Serverless V1 cluster. It includes creating a database secret (`rds.DatabaseSecret`), a VPC (`ec2.Vpc`), the Serverless V1 cluster (`rds.ServerlessCluster`), adding the cluster as an RDS data source to the AppSync API (`api.addRdsDataSource`), and defining resolvers (`rdsDS.createResolver`) for query and mutation operations using custom VTL mapping templates (`appsync.MappingTemplate.fromString`) to interact with the RDS Data API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Create username and password secret for DB Cluster\nconst secret = new rds.DatabaseSecret(this, 'AuroraSecret', {\n  username: 'clusteradmin',\n});\n\n// The VPC to place the cluster in\nconst vpc = new ec2.Vpc(this, 'AuroraVpc');\n\n// Create the serverless cluster, provide all values needed to customise the database.\nconst cluster = new rds.ServerlessCluster(this, 'AuroraCluster', {\n  engine: rds.DatabaseClusterEngine.AURORA_MYSQL,\n  vpc,\n  credentials: { username: 'clusteradmin' },\n  clusterIdentifier: 'db-endpoint-test',\n  defaultDatabaseName: 'demos',\n});\n\n// Build a data source for AppSync to access the database.\ndeclare const api: appsync.GraphqlApi;\nconst rdsDS = api.addRdsDataSource('rds', cluster, secret, 'demos');\n\n// Set up a resolver for an RDS query.\nrdsDS.createResolver('QueryGetDemosRdsResolver', {\n  typeName: 'Query',\n  fieldName: 'getDemosRds',\n  requestMappingTemplate: appsync.MappingTemplate.fromString(`\n  {\n    \"version\": \"2018-05-29\",\n    \"statements\": [\n      \"SELECT * FROM demos\"\n    ]\n  }\n  `),\n  responseMappingTemplate: appsync.MappingTemplate.fromString(`\n    $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])\n  `),\n});\n\n// Set up a resolver for an RDS mutation.\nrdsDS.createResolver('MutationAddDemoRdsResolver', {\n  typeName: 'Mutation',\n  fieldName: 'addDemoRds',\n  requestMappingTemplate: appsync.MappingTemplate.fromString(`\n  {\n    \"version\": \"2018-05-29\",\n    \"statements\": [\n      \"INSERT INTO demos VALUES (:id, :version)\",\n      \"SELECT * WHERE id = :id\"\n    ],\n    \"variableMap\": {\n      \":id\": $util.toJson($util.autoId()),\n      \":version\": $util.toJson($ctx.args.version)\n    }\n  }\n  `),\n  responseMappingTemplate: appsync.MappingTemplate.fromString(`\n    $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])\n  `),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Output Variables Between Actions in CodePipeline\nDESCRIPTION: This snippet demonstrates how to export environment variables from a Commands action and use them in subsequent pipeline actions. It shows setting custom variables and using predefined CodeBuild variables that can be referenced in later actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceArtifact: codepipeline.Artifact;\ndeclare const outputArtifact: codepipeline.Artifact;\n\nconst commandsAction = new codepipeline_actions.CommandsAction({\n  actionName: 'Commands',\n  commands: [\n    'export MY_OUTPUT=my-key',\n  ],\n  input: sourceArtifact,\n  output: outputArtifact,\n  outputVariables: ['MY_OUTPUT', 'CODEBUILD_BUILD_ID'], // CODEBUILD_BUILD_ID is a variable defined by CodeBuild\n});\n\n// Deploy action\nconst deployAction = new codepipeline_actions.S3DeployAction({\n  actionName: 'DeployAction',\n  extract: true,\n  input: outputArtifact,\n  bucket: new s3.Bucket(this, 'DeployBucket'),\n  objectKey: commandsAction.variable('MY_OUTPUT'), // the variable emitted by the Commands action\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Fargate Spot Compute Environment with AWS Batch using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet uses AWS CDK to create a new AWS Batch Fargate compute environment in a specified VPC with spot pricing enabled by setting the 'spot' parameter to true. It requires the '@aws-cdk/aws-ec2' and '@aws-cdk/aws-batch' packages and an instantiated VPC object. No special properties for update configuration are applicable to Fargate environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'VPC');\nnew batch.FargateComputeEnvironment(this, 'myFargateComputeEnv', {\n  vpc,\n  spot: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing OCI Helm Charts using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to install a Helm chart hosted in an OCI (Open Container Initiative) compliant registry, such as AWS ECR. This is done using the `eks.HelmChart` construct, specifying the repository URL with the `oci://` prefix and providing necessary details like account ID, region, repository name, chart name, and version. Placeholder variables need to be replaced with actual values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n// option 1: use a construct\nnew eks.HelmChart(this, 'MyOCIChart', {\n  cluster,\n  chart: 'some-chart',\n  repository: 'oci://${ACCOUNT_ID}.dkr.ecr.${ACCOUNT_REGION}.amazonaws.com/${REPO_NAME}',\n  namespace: 'oci',\n  version: '0.0.1'\n});\n```\n\n----------------------------------------\n\nTITLE: Delaying Secret Rotation on Stack Update - AWS CDK TypeScript\nDESCRIPTION: Demonstrates configuring SecretRotation so that secret is not immediately rotated on stack update, but instead waits for the next scheduled rotation window. Uses rotateImmediatelyOnUpdate: false and sets rotation interval to 7 days. Relies on fully defined secret, master secret, database, and VPC resources. Prevents unnecessary credentials changes during deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myUserSecret: secretsmanager.Secret;\ndeclare const myMasterSecret: secretsmanager.Secret;\ndeclare const myDatabase: ec2.IConnectable;\ndeclare const myVpc: ec2.Vpc;\n\nnew secretsmanager.SecretRotation(this, 'SecretRotation', {\n  application: secretsmanager.SecretRotationApplication.MYSQL_ROTATION_MULTI_USER,\n  secret: myUserSecret, // The secret that will be rotated\n  masterSecret: myMasterSecret, // The secret used for the rotation\n  target: myDatabase,\n  vpc: myVpc,\n  automaticallyAfter: Duration.days(7),\n  rotateImmediatelyOnUpdate: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Commands Action with Source and Output Artifacts in CodePipeline\nDESCRIPTION: This snippet demonstrates how to create a basic pipeline with a source action from S3 and a Commands action that executes shell commands. The Commands action takes an input artifact from the source action and produces an output artifact.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\n// Source action\nconst bucket = new s3.Bucket(this, 'SourceBucket', {\n  versioned: true,\n});\nconst sourceArtifact = new codepipeline.Artifact('SourceArtifact');\nconst sourceAction = new codepipeline_actions.S3SourceAction({\n  actionName: 'Source',\n  output: sourceArtifact,\n  bucket,\n  bucketKey: 'my.zip',\n});\n\n// Commands action\nconst outputArtifact = new codepipeline.Artifact('OutputArtifact');\nconst commandsAction = new codepipeline_actions.CommandsAction({\n  actionName: 'Commands',\n  commands: [\n    'echo \"some commands\"',\n  ],\n  input: sourceArtifact,\n  output: outputArtifact,\n});\n\nconst pipeline = new codepipeline.Pipeline(this, 'Pipeline', {\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Commands',\n      actions: [commandsAction],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Lambda Config Rule in TypeScript\nDESCRIPTION: Demonstrates how to create a custom Config rule using a Lambda function. The rule runs on configuration changes of EC2 instances and uses a simple Lambda function for evaluation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Lambda function containing logic that evaluates compliance with the rule.\nconst evalComplianceFn = new lambda.Function(this, \"CustomFunction\", {\n  code: lambda.AssetCode.fromInline(\n    \"exports.handler = (event) => console.log(event);\"\n  ),\n  handler: \"index.handler\",\n  runtime: lambda.Runtime.NODEJS_18_X,\n});\n\n// A custom rule that runs on configuration changes of EC2 instances\nconst customRule = new config.CustomRule(this, \"Custom\", {\n  configurationChanges: true,\n  lambdaFunction: evalComplianceFn,\n  ruleScope: config.RuleScope.fromResource(config.ResourceType.EC2_INSTANCE),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SES Email Identity for Custom Domain (Manual DNS) - AWS CDK - TypeScript\nDESCRIPTION: This snippet creates an SES email identity for a custom domain where required DNS records (CNAME for DKIM, etc.) must be created manually. After instantiating the identity, it exposes a dkimRecords array containing name/value pairs to be used for manual DNS provisioning. Essential when the hosted zone is managed outside AWS or not accessible to CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst identity = new ses.EmailIdentity(this, 'Identity', {\n  identity: ses.Identity.domain('cdk.dev'),\n});\n\nfor (const record of identity.dkimRecords) {\n  // create CNAME records using `record.name` and `record.value`\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to add tags to a DynamoDB table using the TableV2 construct, both for the primary table and for replica tables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  tags: [{key: 'primaryTableTagKey', value: 'primaryTableTagValue'}],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  replicas: [\n    {\n      region: 'us-west-1',\n      tags: [{key: 'replicaTableTagKey', value: 'replicaTableTagValue'}]\n    }\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTP Route with Path Prefix Match - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet shows how to add an HTTP route to an App Mesh virtual router using AWS CDK in TypeScript. It demonstrates matching requests based on a URL path prefix (using startsWith) and associating them with a target virtual node. Prerequisites include AWS CDK, the @aws-cdk/aws-appmesh package, and a declared virtual router and node. The routeSpec leverages appmesh.RouteSpec.http, and the path match uses appmesh.HttpRoutePathMatch.startsWith. All requests with the specified prefix will be routed to the node. Inputs include the path prefix, and output is the configured route in AWS App Mesh.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-http', {\n  routeSpec: appmesh.RouteSpec.http({\n    weightedTargets: [\n      {\n        virtualNode: node,\n      },\n    ],\n    match: {\n      // Path that is passed to this method must start with '/'.\n      path: appmesh.HttpRoutePathMatch.startsWith('/path-to-app'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining CodeStar Notification Rule for CodeBuild Success (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure AWS CodeStar Notifications to send a message to an AWS Chatbot Slack channel when an AWS CodeBuild project build succeeds. It uses the `project.notifyOnBuildSucceeded` method, passing an instantiated `chatbot.SlackChannelConfiguration` as the target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\n\ndeclare const project: codebuild.Project;\n\nconst target = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\n});\n\nconst rule = project.notifyOnBuildSucceeded('NotifyOnBuildSucceeded', target);\n```\n\n----------------------------------------\n\nTITLE: Performing Resource Actions (Pause, Resume, Failover) on Redshift Clusters\nDESCRIPTION: Demonstrates how to trigger specific actions on a Redshift cluster during deployment using the `resourceAction` property. Examples include pausing a cluster (`ResourceAction.PAUSE`), resuming it (`ResourceAction.RESUME`), and initiating failover for a Multi-AZ cluster (`ResourceAction.FAILOVER_PRIMARY_COMPUTE`). Failover requires a Multi-AZ configuration (`multiAz: true`) and a VPC spanning at least 3 AZs. Requires `Cluster`, `ec2.IVpc`, `ResourceAction`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport { ResourceAction } from '@aws-cdk/aws-redshift-alpha';\n\ndeclare const vpc: ec2.IVpc;\n\n// Pause the cluster\nnew Cluster(this, 'PausedCluster', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  resourceAction: ResourceAction.PAUSE,\n});\n\n// Resume the cluster\nnew Cluster(this, 'ResumedCluster', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  resourceAction: ResourceAction.RESUME,\n});\n\n// Failover the cluster\nnew Cluster(this, 'FailOverCluster', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  // VPC must have 3 AZs for the cluster which executes failover action\n  vpc,\n  // Must be a multi-AZ cluster to failover\n  multiAz: true,\n  resourceAction: ResourceAction.FAILOVER_PRIMARY_COMPUTE,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Log Event Input for CloudWatch LogGroup with EventBridge - TypeScript\nDESCRIPTION: This example demonstrates modifying the event input sent to a CloudWatch LogGroup target within an EventBridge rule using AWS CDK in TypeScript. It uses LogGroupTargetInput.fromObjectV2 to customize the log event, extracting properties from the event (such as timestamp and detail-type) using EventField.fromPath. Dependencies include aws-cdk-lib/aws-logs and aws-cdk-lib/aws-events, and the rule and LogGroup are assumed to be declared elsewhere.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\ndeclare const logGroup: logs.LogGroup;\ndeclare const rule: events.Rule;\n\nrule.addTarget(new targets.CloudWatchLogGroup(logGroup, {\n  logEvent: targets.LogGroupTargetInput.fromObjectV2({\n    timestamp: events.EventField.fromPath('$.time'),\n    message: events.EventField.fromPath('$.detail-type'),\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Organizing Widgets Vertically with Column Widget (TypeScript)\nDESCRIPTION: Demonstrates use of the Column widget to arrange other dashboard widgets vertically in a stack. Requires widget instances implementing cloudwatch.IWidget and Column from aws-cdk-lib/aws-cloudwatch. Widgets are listed in top-to-bottom order.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const widgetA: cloudwatch.IWidget;\ndeclare const widgetB: cloudwatch.IWidget;\n\nnew cloudwatch.Column(widgetA, widgetB);\n```\n\n----------------------------------------\n\nTITLE: Importing KMS Alias by Name and Encrypting CloudTrail Using AWS CDK in TypeScript\nDESCRIPTION: Shows how to import a KMS Alias (not a Key) using its alias name and use it to encrypt AWS CloudTrail logs. The imported alias can perform encryption operations but cannot alter resource policy or grant further privileges. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-cloudtrail'. The alias object can be passed wherever an IKey reference is accepted.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cloudtrail from 'aws-cdk-lib/aws-cloudtrail';\n\nconst myKeyAlias = kms.Alias.fromAliasName(this, 'myKey', 'alias/aws/s3');\nconst trail = new cloudtrail.Trail(this, 'myCloudTrail', {\n  sendToCloudWatchLogs: true,\n  encryptionKey: myKeyAlias,\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Sign and Verify Permissions on KMS Key Using AWS CDK in TypeScript\nDESCRIPTION: Grants 'kms:Sign' and 'kms:Verify' permissions to an IAM user on a KMS key through dedicated grant methods. These are essential for applications performing cryptographic signing and verification using AWS KMS. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\nconst user = new iam.User(this, 'MyUser');\nkey.grantSign(user); // Adds 'kms:Sign' to the principal's policy\nkey.grantVerify(user); // Adds 'kms:Verify' to the principal's policy\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration from Inline YAML in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration from inline YAML. The content type is automatically set to 'application/x-yaml'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineYaml('MyConfig: This is my content.'),\n});\n```\n\n----------------------------------------\n\nTITLE: Looking up a Bedrock Base Foundation Model in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to obtain a reference to a standard Amazon Bedrock foundation model within an AWS CDK stack using the `FoundationModel.fromFoundationModelId` method. It requires importing the `aws-cdk-lib/aws-bedrock` module. The method takes the CDK scope (`this`), a logical ID for the construct (`'Model'`), and a predefined `FoundationModelIdentifier` (e.g., `ANTHROPIC_CLAUDE_V2`) as arguments. The returned object represents the specified foundation model, allowing integration with other CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-bedrock/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bedrock from 'aws-cdk-lib/aws-bedrock';\n\nbedrock.FoundationModel.fromFoundationModelId(\n  this,\n  'Model',\n  bedrock.FoundationModelIdentifier.ANTHROPIC_CLAUDE_V2,\n);\n```\n\n----------------------------------------\n\nTITLE: Using Managed Cache Policy for CloudFront Distribution\nDESCRIPTION: This snippet shows how to use a pre-defined (managed) cache policy for a CloudFront distribution. It applies the CACHING_OPTIMIZED policy to the default behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Using an existing cache policy for a Distribution\ndeclare const bucketOrigin: origins.S3Origin;\nnew cloudfront.Distribution(this, 'myDistManagedPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    cachePolicy: cloudfront.CachePolicy.CACHING_OPTIMIZED,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with Kubectl Handler in TypeScript\nDESCRIPTION: Demonstrates how to create an EKS cluster with a Kubectl Handler, which is not created by default in the new version. It uses the kubectlProviderOptions property to specify the Kubectl layer.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nnew eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an SES Allow List Receipt Filter - AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates creating an 'allow list' receipt filter in SES, specifying multiple IP ranges permitted to deliver mail. The ips parameter is an array of allowed CIDR ranges. Internally, a block-all filter is created first, then explicit allows are set up for each provided IP address. This provides granular control over mail acceptance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.AllowListReceiptFilter(this, 'AllowList', {\n  ips: [\n    '10.0.0.0/16',\n    '1.2.3.4/16',\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using a Customer Managed Encryption Key (AWS CDK, TypeScript)\nDESCRIPTION: Shows how to pass a customer managed AWS KMS key to encrypt schedule payloads delivered to targets. Target classes grant 'kms:Decrypt' permission to the execution role as needed. Inputs include a kms.Key, Lambda function, and schedule parameters; output is an encrypted event delivery. Dependencies: kms.Key, lambda.Function, Schedule, LambdaInvoke, ScheduleTargetInput.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const key: kms.Key;\ndeclare const fn: lambda.Function;\n\nconst target = new targets.LambdaInvoke(fn, {\n    input: ScheduleTargetInput.fromObject({\n        payload: 'useful',\n    }),\n});\n\nconst schedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(10)),\n    target,\n    key,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring EFS File System Deletion on Stack Removal with AWS CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure an EFS FileSystem resource in AWS CDK to be automatically deleted when the associated CloudFormation stack is destroyed. By setting the `removalPolicy` property to `RemovalPolicy.DESTROY` during instantiation, the default behavior (retaining the file system) is overridden. This requires importing `RemovalPolicy` from `aws-cdk-lib`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fileSystem =  new efs.FileSystem(this, 'EfsFileSystem', {\n  vpc: new ec2.Vpc(this, 'VPC'),\n  removalPolicy: RemovalPolicy.DESTROY,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Field Index Policies for CloudWatch Logs\nDESCRIPTION: Shows how to create field index policies to optimize query performance and reduce costs for specific log fields.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst fieldIndexPolicy = new logs.FieldIndexPolicy({\n  fields: ['Operation', 'RequestId'],\n});\n\nnew logs.LogGroup(this, 'LogGroup', {\n  logGroupName: 'cdkIntegLogGroup',\n  fieldIndexPolicies: [fieldIndexPolicy],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Identity Pool with Custom Roles in TypeScript\nDESCRIPTION: This code demonstrates how to create an Identity Pool with custom authenticated and unauthenticated roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst authenticatedRole = new iam.Role(this, 'authRole', {\n  assumedBy: new iam.ServicePrincipal('service.amazonaws.com'),\n});\nconst unauthenticatedRole = new iam.Role(this, 'unauthRole', {\n  assumedBy: new iam.ServicePrincipal('service.amazonaws.com'),\n});\nconst identityPool = new IdentityPool(this, 'TestIdentityPoolActions', {\n  authenticatedRole,\n  unauthenticatedRole,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Network Load Balancer Endpoint in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to add a Network Load Balancer (NLB) as an endpoint to a Global Accelerator Listener's Endpoint Group within the AWS CDK. It sets a weight of 128 for the endpoint and enables the preservation of the client's original IP address. This code assumes that `listener` (a `globalaccelerator.Listener`) and `nlb` (an `elbv2.NetworkLoadBalancer`) CDK constructs are already defined. Requires the `aws-globalaccelerator`, `aws-elasticloadbalancingv2`, and `aws-globalaccelerator-endpoints` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const nlb: elbv2.NetworkLoadBalancer;\ndeclare const listener: globalaccelerator.Listener;\n\nlistener.addEndpointGroup('Group', {\n  endpoints: [\n    new ga_endpoints.NetworkLoadBalancerEndpoint(nlb, {\n      weight: 128,\n      preserveClientIp: true, \n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Logging Event to CloudWatch LogGroup with EventBridge - TypeScript\nDESCRIPTION: This snippet shows how to create a CloudWatch LogGroup, define an EventBridge rule to match 'aws.ec2' events, and add the LogGroup as the target using the AWS CDK in TypeScript. It demonstrates how to direct incoming events to a LogGroup for monitoring or auditing purposes. Required dependencies are aws-cdk-lib/aws-logs and aws-cdk-lib/aws-events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst logGroup = new logs.LogGroup(this, 'MyLogGroup', {\n  logGroupName: 'MyLogGroup',\n});\n\nconst rule = new events.Rule(this, 'rule', {\n  eventPattern: {\n    source: [\"aws.ec2\"],\n  },\n});\n\nrule.addTarget(new targets.CloudWatchLogGroup(logGroup));\n```\n\n----------------------------------------\n\nTITLE: Creating AppSync JS Function and Pipeline Resolver in TypeScript\nDESCRIPTION: This TypeScript CDK code demonstrates creating an AppSync Function and a Pipeline Resolver using JavaScript runtime (`JS_1_0_0`). The function's code is loaded from an external `.js` file, while the resolver's 'before' and 'after' step code is defined inline. The function is included in the resolver's pipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.GraphqlApi;\n\nconst myJsFunction = new appsync.AppsyncFunction(this, 'function', {\n  name: 'my_js_function',\n  api,\n  dataSource: api.addNoneDataSource('none'),\n  code: appsync.Code.fromAsset('directory/function_code.js'),\n  runtime: appsync.FunctionRuntime.JS_1_0_0,\n});\n\nnew appsync.Resolver(this, 'PipelineResolver', {\n  api,\n  typeName: 'typeName',\n  fieldName: 'fieldName',\n  code: appsync.Code.fromInline(`\n    // The before step\n    export function request(...args) {\n      console.log(args);\n      return {}\n    }\n\n    // The after step\n    export function response(ctx) {\n      return ctx.prev.result\n    }\n  `),\n  runtime: appsync.FunctionRuntime.JS_1_0_0,\n  pipelineConfig: [myJsFunction],\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying BuildSpec from Source File in CodeBuild Project\nDESCRIPTION: Shows how to use a specific file from the project's source artifact as the buildspec for a CodeBuild project. This example uses a file named 'my-buildspec.yml' from a GitHub repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromSourceFilename('my-buildspec.yml'),\n  source: codebuild.Source.gitHub({\n    owner: 'awslabs',\n    repo: 'aws-cdk',\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Granting EKS Cluster Access via Access Policies - AWS CDK - TypeScript\nDESCRIPTION: Grants granular access to IAM roles for performing EKS cluster administration or namespace management, including cluster admin and namespace-limited policies. Cluster is constructed with custom roles, kubectl handler, and memory configuration. Outputs are IAM-permissioned resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\ndeclare const vpc: ec2.Vpc;\n\nconst clusterAdminRole = new iam.Role(this, 'ClusterAdminRole', {\n  assumedBy: new iam.ArnPrincipal('arn_for_trusted_principal'),\n});\n\nconst eksAdminRole = new iam.Role(this, 'EKSAdminRole', {\n  assumedBy: new iam.ArnPrincipal('arn_for_trusted_principal'),\n});\n\nconst cluster = new eks.Cluster(this, 'Cluster', {\n  vpc,\n  mastersRole: clusterAdminRole,\n  version: eks.KubernetesVersion.V1_32,\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n    memory: Size.gibibytes(4),\n  },\n});\n\n// Cluster Admin role for this cluster\ncluster.grantAccess('clusterAdminAccess', clusterAdminRole.roleArn, [\n  eks.AccessPolicy.fromAccessPolicyName('AmazonEKSClusterAdminPolicy', {\n    accessScopeType: eks.AccessScopeType.CLUSTER,\n  }),\n]);\n\n// EKS Admin role for specified namespaces of this cluster\ncluster.grantAccess('eksAdminRoleAccess', eksAdminRole.roleArn, [\n  eks.AccessPolicy.fromAccessPolicyName('AmazonEKSAdminPolicy', { \n    accessScopeType: eks.AccessScopeType.NAMESPACE,\n    namespaces: ['foo', 'bar'],\n  }),\n]);\n```\n\n----------------------------------------\n\nTITLE: Enabling VSS-Compatible Windows Application Backup for EC2 Using AWS Backup - AWS CDK - TypeScript\nDESCRIPTION: Shows how to enable AWS Backup to perform VSS-consistent backups of Windows applications running on EC2 instances by setting the windowsVss parameter to true in the BackupPlan construct. Dependencies are the backup CDK module. The plan will create VSS-aware snapshots if the application registers a VSS writer. No extra inputs are needed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst plan = new backup.BackupPlan(this, 'Plan', {\n  windowsVss: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Stream Key to an IVS Channel\nDESCRIPTION: Creates a stream key for an existing IVS channel. Stream keys are used by broadcast encoders to initiate streams.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst myStreamKey = myChannel.addStreamKey('StreamKey');\n```\n\n----------------------------------------\n\nTITLE: Configuring EFS File System Location in CodeBuild Project\nDESCRIPTION: Creates a CodeBuild project with an EFS file system mount configuration. Demonstrates how to specify the file system identifier, location, mount point, and mount options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n  }),\n  fileSystemLocations: [\n    codebuild.FileSystemLocation.efs({\n      identifier: \"myidentifier2\",\n      location: \"myclodation.mydnsroot.com:/loc\",\n      mountPoint: \"/media\",\n      mountOptions: \"opts\"\n    })\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Production-Grade OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: This snippet illustrates configuring an `es.Domain` for production use with AWS CDK. It specifies the Elasticsearch version, defines capacity with master and data nodes, configures EBS volume size, enables zone awareness across multiple Availability Zones, and configures logging for slow searches, application logs, and slow indexing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst prodDomain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n  capacity: {\n    masterNodes: 5,\n    dataNodes: 20,\n  },\n  ebs: {\n    volumeSize: 20,\n  },\n  zoneAwareness: {\n    availabilityZoneCount: 3,\n  },\n  logging: {\n    slowSearchLogEnabled: true,\n    appLogEnabled: true,\n    slowIndexLogEnabled: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Custom ECS Deployment Configuration in AWS CDK\nDESCRIPTION: Shows how to create a custom traffic routing strategy for CodeDeploy ECS deployments. This example creates a canary deployment that shifts 5% of traffic initially and then the remaining 95% after 15 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nnew codedeploy.EcsDeploymentConfig(this, 'CustomConfig', {\n  trafficRouting: new codedeploy.TimeBasedCanaryTrafficRouting({\n    interval: Duration.minutes(15),\n    percentage: 5,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Publishing a Message to an SNS Topic with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates publishing a message to an Amazon SNS topic via EventBridge Scheduler using the AWS CDK. It creates an SNS topic, defines a JSON payload, configures an `SnsPublish` target with this payload, and sets up a schedule to trigger the target hourly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sns from 'aws-cdk-lib/aws-sns';\n\nconst topic = new sns.Topic(this, 'Topic');\n\nconst payload = {\n  message: 'Hello scheduler!',\n};\n\nconst target = new targets.SnsPublish(topic, {\n  input: ScheduleTargetInput.fromObject(payload),\n});\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.hours(1)),\n  target,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a gRPC Route Matching Method Name and Metadata - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet creates a gRPC route that filters requests by both method name and service name, and matches on multiple metadata conditions using appmesh.HeaderMatch. It shows how to ensure all metadata conditions are fulfilled for the route to match. Dependencies: AWS CDK App Mesh library, virtual router and node. Inputs are the service and method names, plus metadata matchers. Outputs a route that only matches the specified gRPC method with strict header/metadata requirements. Constraint: serviceName must be specified when methodName is present.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-grpc-retry', {\n  routeSpec: appmesh.RouteSpec.grpc({\n    weightedTargets: [{ virtualNode: node }],\n    match: {\n      // When method name is specified, service name must be also specified.\n      methodName: 'methodname',\n      serviceName: 'servicename',\n      metadata: [\n        // All specified metadata must match for the route to match.\n        appmesh.HeaderMatch.valueStartsWith('Content-Type', 'application/'),\n        appmesh.HeaderMatch.valueDoesNotStartWith('Content-Type', 'text/'),\n      ],\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Scaling Auto Scaling Group based on Network Traffic in TypeScript\nDESCRIPTION: Configures target tracking scaling policies for an AWS Auto Scaling Group based on average incoming and outgoing network traffic per instance. These policies adjust the instance count to keep the network traffic per instance around the specified `targetBytesPerSecond`. Requires an existing `autoscaling.AutoScalingGroup` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.scaleOnIncomingBytes('LimitIngressPerInstance', {\n    targetBytesPerSecond: 10 * 1024 * 1024 // 10 MB/s\n});\nautoScalingGroup.scaleOnOutgoingBytes('LimitEgressPerInstance', {\n    targetBytesPerSecond: 10 * 1024 * 1024 // 10 MB/s\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Included Nested Stacks in CDK\nDESCRIPTION: Demonstrates how to access nested stacks that have been included with CfnInclude. This provides access to both the stack and template objects for further manipulation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parentTemplate: cfn_inc.CfnInclude;\n\nconst includedChildStack = parentTemplate.getNestedStack('ChildStack');\nconst childStack: core.NestedStack = includedChildStack.stack;\nconst childTemplate: cfn_inc.CfnInclude = includedChildStack.includedTemplate;\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Step Functions as a Pipe Target using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure an AWS Step Functions state machine as a pipe target using AWS CDK in TypeScript. It shows instantiation of a new pipe with an SQS queue as the source and a state machine as the target, without additional customization. Dependencies include AWS CDK modules for SQS, Step Functions, and Pipes. Inputs are SQS queue and state machine constructs; output is an initialized Pipe resource connecting these components.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetStateMachine: sfn.IStateMachine;\n\nconst pipeTarget = new targets.SfnStateMachine(targetStateMachine,{});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Version Upgrades for an OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS CDK `es.Domain` construct while enabling in-place version upgrades. Setting `enableVersionUpgrade` to `true` allows modifying the domain's `version` property in the CDK code and deploying the changes without replacing the entire domain resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst devDomain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_10,\n  enableVersionUpgrade: true, // defaults to false\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Glue Table with LakeFormation Tags\nDESCRIPTION: Example demonstrating how to create a Glue table and apply LakeFormation tags to it using L1 constructs. This includes setting up a database, table, data lake settings, tag definition and tag association.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lakeformation/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport { S3Table, Database, DataFormat, Schema } from '@aws-cdk/aws-glue-alpha';\nimport { CfnDataLakeSettings, CfnTag, CfnTagAssociation } from 'aws-cdk-lib/aws-lakeformation';\n\ndeclare const stack: cdk.Stack;\ndeclare const accountId: string;\n\nconst tagKey = 'aws';\nconst tagValues = ['dev'];\n\nconst database = new Database(this, 'Database');\n\nconst table = new S3Table(this, 'Table', {\n  database,\n  columns: [\n    {\n      name: 'col1',\n      type: Schema.STRING,\n    },\n    {\n      name: 'col2',\n      type: Schema.STRING,\n    }\n  ],\n  dataFormat: DataFormat.CSV,\n});\n\nconst synthesizer = stack.synthesizer as cdk.DefaultStackSynthesizer;\nnew CfnDataLakeSettings(this, 'DataLakeSettings', {\n  admins: [\n    { \n      dataLakePrincipalIdentifier: stack.formatArn({\n        service: 'iam',\n        resource: 'role',\n        region: '',\n        account: accountId,\n        resourceName: 'Admin',\n      }),\n    },\n    {\n      // The CDK cloudformation execution role.\n      dataLakePrincipalIdentifier: synthesizer.cloudFormationExecutionRoleArn.replace('${AWS::Partition}', 'aws'),\n    },\n  ],\n});\n\nconst tag = new CfnTag(this, 'Tag', {\n  catalogId: accountId,\n  tagKey,\n  tagValues,\n});\n\nconst lfTagPairProperty: CfnTagAssociation.LFTagPairProperty = {\n  catalogId: accountId,\n  tagKey,\n  tagValues,\n};\n\nconst tagAssociation = new CfnTagAssociation(this, 'TagAssociation', {\n  lfTags: [lfTagPairProperty],\n  resource: {\n    tableWithColumns: {\n      databaseName: database.databaseName,\n      columnNames: ['col1', 'col2'],\n      catalogId: accountId,\n      name: table.tableName,\n    }\n  }\n});\n\ntagAssociation.node.addDependency(tag);\ntagAssociation.node.addDependency(table);\n\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing EFS File System in TypeScript\nDESCRIPTION: Imports an EFS file system that was created outside the current CDK stack. This is achieved using the `FileSystem.fromFileSystemAttributes` static method, requiring the file system ID (or ARN) and its associated security group ID. The imported security group is configured to disallow all outbound traffic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst importedFileSystem = efs.FileSystem.fromFileSystemAttributes(this, 'existingFS', {\n  fileSystemId: 'fs-12345678', // You can also use fileSystemArn instead of fileSystemId.\n  securityGroup: ec2.SecurityGroup.fromSecurityGroupId(this, 'SG', 'sg-123456789', {\n    allowAllOutbound: false,\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Folder Structure for Node with Playwright Scripts in AWS Synthetics\nDESCRIPTION: Shows the required folder structure for Node.js with Playwright scripts when supplying code via fromAsset() or fromBucket(). Includes information about how the handler path should reflect the file location.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\ncanary/\n <filename>.js,.mjs,.cjs\nsome/dir/path\n              <filename>.js,.mjs,.cjs\n```\n\n----------------------------------------\n\nTITLE: Configuring Deployment Validation with Test Listener in AWS CDK\nDESCRIPTION: Sets up a CodeDeploy deployment group with a test listener for validating the green deployment before routing production traffic. The test listener serves traffic on a different port, allowing validation of the new version without affecting production traffic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myApplication: codedeploy.EcsApplication;\ndeclare const service: ecs.FargateService;\ndeclare const blueTargetGroup: elbv2.ITargetGroup;\ndeclare const greenTargetGroup: elbv2.ITargetGroup;\ndeclare const listener: elbv2.IApplicationListener;\ndeclare const testListener: elbv2.IApplicationListener;\n\nnew codedeploy.EcsDeploymentGroup(this, 'BlueGreenDG', {\n  service,\n  blueGreenDeploymentConfig: {\n    blueTargetGroup,\n    greenTargetGroup,\n    listener,\n    testListener,\n  },\n  deploymentConfig: codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES,\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Precreated Lambda Service Role for custom roles - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to configure CDK to use a precreated IAM role for a Lambda function's service role by providing a mapping to usePrecreatedRoles. After creating the role and policies (guided by the generated report), developers update the customizeRoles configuration to inform CDK of the precreated role name mapped to the logical ID. This ensures Lambda functions use externally provisioned roles. Requires App, Stack, and iam modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const app: App;\nconst stack = new Stack(app, 'MyStack');\niam.Role.customizeRoles(this, {\n  usePrecreatedRoles: {\n    'MyStack/MyLambda/ServiceRole': 'my-role-name',\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Warm Throughput for DynamoDB TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure Warm Throughput for a DynamoDB TableV2 using AWS CDK. The `warmThroughput` property allows pre-warming the table with specified read and write capacity units per second to handle anticipated load immediately upon creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  warmThroughput: {\n      readUnitsPerSecond: 15000,\n      writeUnitsPerSecond: 20000,\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Delivery Stream Permission to Access Resource (e.g., Lambda) with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to grant a Firehose delivery stream permission to invoke an AWS Lambda function using AWS CDK in TypeScript. It defines a Lambda function, then uses the function's 'grantInvoke' method to allow the delivery stream principal the ability to invoke it. Dependencies: AWS CDK modules ('aws-cdk-lib/aws-lambda', 'aws-cdk-lib/aws-kinesisfirehose'). The main input is a delivery stream construct to be granted resource access. This pattern allows complex cross-resource permission grants for custom or third-party destinations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst fn = new lambda.Function(this, 'Function', {\n  code: lambda.Code.fromInline('exports.handler = (event) => {}'),\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n});\n\ndeclare const deliveryStream: firehose.DeliveryStream;\nfn.grantInvoke(deliveryStream);\n```\n\n----------------------------------------\n\nTITLE: Adding HTTP Gateway Route in AWS App Mesh with CDK\nDESCRIPTION: Demonstrates how to add an HTTP-based gateway route to a virtual gateway in AWS App Mesh. The route matches traffic based on path and routes it to a virtual service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gateway: appmesh.VirtualGateway;\ndeclare const virtualService: appmesh.VirtualService;\n\ngateway.addGatewayRoute('gateway-route-http', {\n  routeSpec: appmesh.GatewayRouteSpec.http({\n    routeTarget: virtualService,\n    match: {\n      path: appmesh.HttpGatewayRoutePathMatch.regex('regex'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON Policy Documents\nDESCRIPTION: Shows how to parse JSON policy documents and create managed policies from them.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst policyDocument = {\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"FirstStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\"iam:ChangePassword\"],\n      \"Resource\": [\"*\"],\n    },\n    {\n      \"Sid\": \"SecondStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\"s3:ListAllMyBuckets\"],\n      \"Resource\": [\"*\"],\n    },\n    {\n      \"Sid\": \"ThirdStatement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:List*\",\n        \"s3:Get*\",\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::confidential-data\",\n        \"arn:aws:s3:::confidential-data/*\",\n      ],\n      \"Condition\": {\"Bool\": {\"aws:MultiFactorAuthPresent\": \"true\"}},\n    },\n  ],\n};\n\nconst customPolicyDocument = iam.PolicyDocument.fromJson(policyDocument);\n\n// You can pass this document as an initial document to a ManagedPolicy\n// or inline Policy.\nconst newManagedPolicy = new iam.ManagedPolicy(this, 'MyNewManagedPolicy', {\n  document: customPolicyDocument,\n});\nconst newPolicy = new iam.Policy(this, 'MyNewPolicy', {\n  document: customPolicyDocument,\n});\n```\n\n----------------------------------------\n\nTITLE: Input Transformation from Object for EventBridge Pipe\nDESCRIPTION: Shows how to transform input events using static values, dynamic values, and pipe variables before sending to the target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst targetInputTransformation = pipes.InputTransformation.fromObject({\n  staticField: 'static value',\n  dynamicField: pipes.DynamicInput.fromEventPath('$.body.payload'),\n  pipeVariable: pipes.DynamicInput.pipeName,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  pipeName: 'MyPipe',\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue, {\n    inputTransformation: targetInputTransformation, \n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating SES Configuration Set with Advanced Options - AWS CDK - TypeScript\nDESCRIPTION: This snippet creates a configuration set for Amazon SES using AWS CDK, with fields for custom redirect domains for tracking, TLS policy enforcement, associated dedicated IP pool, and maximum delivery duration. Key parameters include customTrackingRedirectDomain, tlsPolicy, dedicatedIpPool, and maxDeliveryDuration. Input: details of configuration; Output: SES configuration set resource with the defined behaviors.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Duration } from 'aws-cdk-lib';\n\ndeclare const myPool: ses.IDedicatedIpPool;\n\nnew ses.ConfigurationSet(this, 'ConfigurationSet', {\n  customTrackingRedirectDomain: 'track.cdk.dev',\n  tlsPolicy: ses.ConfigurationSetTlsPolicy.REQUIRE,\n  dedicatedIpPool: myPool,\n  // Specify maximum delivery time\n  // This configuration can be useful in such cases as time-sensitive emails (like those containing a one-time-password),\n  // transactional emails, and email that you want to ensure isn't delivered during non-business hours.\n  maxDeliveryDuration: Duration.minutes(10),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring GP3 EBS Block Devices for Auto Scaling Group in TypeScript\nDESCRIPTION: Creates an AWS Auto Scaling Group with a specified EBS GP3 volume attached as a block device. It defines the `deviceName`, volume size (15 GiB), `volumeType` as GP3, and sets the provisioned `throughput` (125 MiB/s), which is specific to GP3 volumes. Dependencies include `ec2.Vpc`, `ec2.InstanceType`, `ec2.IMachineImage`, and `autoscaling` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nconst autoScalingGroup = new autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n  blockDevices: [\n    {\n        deviceName: 'gp3-volume',\n        volume: autoscaling.BlockDeviceVolume.ebs(15, {\n          volumeType: autoscaling.EbsDeviceVolumeType.GP3,\n          throughput: 125,\n        }),\n      },\n  ],\n  // ...\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing MSK Cluster in TypeScript\nDESCRIPTION: This example demonstrates how to import an existing MSK Cluster into a CDK app using its ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = msk.Cluster.fromClusterArn(this, 'Cluster',\n  'arn:aws:kafka:us-west-2:1234567890:cluster/a-cluster/11111111-1111-1111-1111-111111111111-1',\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Transformation with AWS Lambda for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up data transformation using an AWS Lambda function for an Amazon Data Firehose delivery stream, including custom buffering and retry configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Provide a Lambda function that will transform records before delivery, with custom\n// buffering and retry configuration\nconst lambdaFunction = new lambda.Function(this, 'Processor', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'process-records')),\n});\nconst lambdaProcessor = new firehose.LambdaFunctionProcessor(lambdaFunction, {\n  bufferInterval: Duration.minutes(5),\n  bufferSize: Size.mebibytes(5),\n  retries: 5,\n});\ndeclare const bucket: s3.Bucket;\nconst s3Destination = new firehose.S3Bucket(bucket, {\n  processor: lambdaProcessor,\n});\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: s3Destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Automated Backups in FSx for Lustre Configuration in TypeScript\nDESCRIPTION: This snippet configures automatic backup retention and backup scheduling for FSx for Lustre file systems in the CDK. Requires 'aws-cdk-lib' for cdk.Duration and the FSx module for DailyAutomaticBackupStartTime. Parameters include backup retention period (in days), whether to copy tags to backups, and the daily backup start time (hour/minute). Outputs a Lustre configuration where backups are managed automatically according to the specified schedule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst lustreConfiguration = {\n  // ...\n  automaticBackupRetention: cdk.Duration.days(3), // backup retention\n  copyTagsToBackups: true, // if true, tags are copied to backups\n  dailyAutomaticBackupStartTime: new fsx.DailyAutomaticBackupStartTime({ hour: 11, minute: 30 }),  // backup window\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting IP Preferences for App Mesh Virtual Nodes\nDESCRIPTION: Shows how to configure IP preferences for Virtual Nodes using both DNS and CloudMap service discovery. Demonstrates setting IPv4/IPv6 preferences and includes configuration for service discovery attributes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst mesh = new appmesh.Mesh(this, 'mesh', {\n  meshName: 'mesh-with-preference',\n});\n\nconst dnsNode = new appmesh.VirtualNode(this, 'dns-node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('test', appmesh.DnsResponseType.LOAD_BALANCER, appmesh.IpPreference.IPV4_ONLY),\n});\n\nconst vpc = new ec2.Vpc(this, 'vpc');\nconst namespace = new cloudmap.PrivateDnsNamespace(this, 'test-namespace', {\n  vpc,\n  name: 'domain.local',\n});\nconst service = namespace.createService('Svc');\n\nconst instanceAttribute : { [key: string]: string} = {};\ninstanceAttribute.testKey = 'testValue';\n\nconst cloudmapNode = new appmesh.VirtualNode(this, 'cloudmap-node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service, instanceAttribute, appmesh.IpPreference.IPV4_ONLY),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Extension with Lambda Destination using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS AppConfig `Extension`. It defines an action that triggers on the `ON_DEPLOYMENT_START` action point and sends events to an AWS Lambda function specified via `appconfig.LambdaDestination`. Requires a `lambda.Function` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nnew appconfig.Extension(this, 'MyExtension', {\n  actions: [\n    new appconfig.Action({\n      actionPoints: [appconfig.ActionPoint.ON_DEPLOYMENT_START],\n      eventDestination: new appconfig.LambdaDestination(fn),\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Unsigned Basic Authentication for an OpenSearch/Elasticsearch Domain\nDESCRIPTION: Shows how to configure an `es.Domain` to accept unsigned HTTP requests using basic authentication by setting `useUnsignedBasicAuth` to `true` in AWS CDK. This automatically enables required settings like HTTPS, encryption, and Fine-Grained Access Control (FGAC). A default master user 'admin' is created if none is specified, and its password is generated and stored in Secrets Manager, accessible via `domain.masterUserPassword`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n  useUnsignedBasicAuth: true,\n});\n\nconst masterUserPassword = domain.masterUserPassword;\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a CodeCommit Repository in TypeScript with AWS CDK\nDESCRIPTION: Creates a basic CodeCommit repository with a name and optional description. This is the foundational step for using CodeCommit with AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst repo = new codecommit.Repository(this, 'Repository', {\n  repositoryName: 'MyRepositoryName',\n  description: 'Some description.', // optional property\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Account Recovery Method for Cognito UserPool - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to set up email-only account recovery for a UserPool, precluding SMS recovery if MFA is in use on the phone number. Requires Cognito CDK module. The 'accountRecovery' property is used to specify the recovery channel. Input is the recovery configuration; output is a UserPool enforcing email-only recovery.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'UserPool', {\n  // ...\n  accountRecovery: cognito.AccountRecovery.EMAIL_ONLY,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring UltraWarm Nodes for an OpenSearch/Elasticsearch Domain\nDESCRIPTION: Demonstrates how to configure an `es.Domain` with UltraWarm nodes using AWS CDK. This involves specifying the number of warm nodes (`warmNodes`) and their instance type (`warmInstanceType`) within the `capacity` property. UltraWarm provides a cost-effective tier for storing large amounts of read-only data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_10,\n  capacity: {\n    masterNodes: 2,\n    warmNodes: 2,\n    warmInstanceType: 'ultrawarm1.medium.elasticsearch',\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Column Compression Encoding in Redshift Tables with AWS CDK\nDESCRIPTION: Configures specific compression encodings for Redshift table columns using the `encoding` property and values from `ColumnEncoding`. Applying appropriate compression can reduce storage footprint and improve I/O performance. Requires importing `ColumnEncoding` from `@aws-cdk/aws-redshift-alpha`, an existing `cluster` object, and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nimport { ColumnEncoding } from '@aws-cdk/aws-redshift-alpha';\n\nnew Table(this, 'Table', {\n  tableColumns: [\n    { name: 'col1', dataType: 'varchar(4)', encoding: ColumnEncoding.TEXT32K },\n    { name: 'col2', dataType: 'float', encoding: ColumnEncoding.DELTA32K },\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Full Template Match in TypeScript\nDESCRIPTION: Illustrates using the `templateMatches()` method to assert that the generated CloudFormation template matches a given structure. By default, it performs an 'object-like' comparison, meaning the actual template can be a superset of the expected structure. The expectation is an object representing the desired CloudFormation resources and their properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.templateMatches({\n  Resources: {\n    BarLogicalId: {\n      Type: 'Foo::Bar',\n      Properties: {\n        Baz: 'Qux',\n      },\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Glue S3 Table with Partition Indexes in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS Glue S3 Table with partition indexes using AWS CDK to optimize query performance on highly partitioned tables. It defines a partition index using the `partitionIndexes` property, specifying an optional `indexName` and the `keyNames` (which must be a subset of `partitionKeys`). A table can have up to 3 partition indexes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  partitionKeys: [{\n    name: 'year',\n    type: glue.Schema.SMALL_INT,\n  }, {\n    name: 'month',\n    type: glue.Schema.SMALL_INT,\n  }],\n  partitionIndexes: [{\n    indexName: 'my-index', // optional\n    keyNames: ['year'],\n  }], // supply up to 3 indexes\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Suppression List in SES Configuration Set - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to disable the account-level SES suppression list for a configuration set by setting disableSuppressionList to true. Emails sent using this configuration set will bypass all suppression list checks. Useful in testing or bulk messaging scenarios, but may increase risk of sending to problematic recipients.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.ConfigurationSet(this, 'ConfigurationSet', {\n  disableSuppressionList: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Deferred SSM Parameter Resolution with Tokens - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to convert a looked-up SSM parameter value into a Lazy CDK token for use as an input to other properties. This causes evaluation to be deferred until after all lookups have completed, solving the problem of using placeholders at synthesis time. The code depends on AWS CDK's ssm, iam, and Lazy modules. Inputs include the SSM parameter name and property accepting a token.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst arnLookup = ssm.StringParameter.valueFromLookup(this, '/my/role/arn');\niam.Role.fromRoleArn(this, 'role', Lazy.string({ produce: () => arnLookup }));\n```\n\n----------------------------------------\n\nTITLE: Configuring Termination Policies for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet demonstrates configuring multiple termination policies for an AWS Auto Scaling Group using the AWS CDK, including a custom Lambda function policy. It sets the `terminationPolicies` array with `CUSTOM_LAMBDA_FUNCTION`, `OLDEST_INSTANCE`, and `DEFAULT`. The `terminationPolicyCustomLambdaFunctionArn` property is required and set when using the custom Lambda policy. Dependencies include declared variables for `vpc`, `instanceType`, `machineImage`, and `arn`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\ndeclare const arn: string;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  terminationPolicies: [\n    autoscaling.TerminationPolicy.CUSTOM_LAMBDA_FUNCTION,\n    autoscaling.TerminationPolicy.OLDEST_INSTANCE,\n    autoscaling.TerminationPolicy.DEFAULT,\n  ],\n\n  //terminationPolicyCustomLambdaFunctionArn property must be specified if the TerminationPolicy.CUSTOM_LAMBDA_FUNCTION is used\n  terminationPolicyCustomLambdaFunctionArn: arn,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using a Python Layer with a Python Function in AWS CDK\nDESCRIPTION: Demonstrates how to create a Python Lambda function that uses a Python layer, combining both constructs together.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonFunction(this, 'MyFunction', {\n  entry: '/path/to/my/function',\n  runtime: Runtime.PYTHON_3_8,\n  layers: [\n    new python.PythonLayerVersion(this, 'MyLayer', {\n      entry: '/path/to/my/layer', // point this to your library's directory\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring User Verification Settings in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure user verification settings for a Cognito User Pool, including email and SMS verification messages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  selfSignUpEnabled: true,\n  userVerification: {\n    emailSubject: 'Verify your email for our awesome app!',\n    emailBody: 'Thanks for signing up to our awesome app! Your verification code is {####}',\n    emailStyle: cognito.VerificationEmailStyle.CODE,\n    smsMessage: 'Thanks for signing up to our awesome app! Your verification code is {####}',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Latency-Based Routing in Route53 using AWS CDK\nDESCRIPTION: Shows how to enable latency-based routing for an A record in Route53. It uses the region parameter to specify the AWS region for the record.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecordLatency1', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4'),\n  region: 'us-east-1',\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing the CloudFront Endpoint of a Cognito Domain using AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to retrieve the CloudFront distribution endpoint associated with a Cognito user pool domain and expose it as a CloudFormation output. Required dependencies are AWS CDK for Cognito, and a user pool with an attached domain. Inputs include the domain configuration; outputs include a deployment-time CloudFront endpoint for use in integrations or documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'UserPool');\nconst domain = userpool.addDomain('Domain', {\n  cognitoDomain: {\n    domainPrefix: 'my-awesome-app',\n  },\n});\n\nnew CfnOutput(this, 'CloudFrontEndpoint', {\n  value: domain.cloudFrontEndpoint,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Network Isolation for a SageMaker Model with TypeScript\nDESCRIPTION: This snippet demonstrates how to enable network isolation for a SageMaker model using the CDK. Network isolation prevents the containers from making outbound network calls.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const image: sagemaker.ContainerImage;\ndeclare const modelData: sagemaker.ModelData;\n\nconst model = new sagemaker.Model(this, 'ContainerModel', {\n  containers: [\n    {\n      image,\n      modelData,\n    }\n  ],\n  networkIsolation: true,\n});\n```\n\n----------------------------------------\n\nTITLE: MIME Extension Lookup Example\nDESCRIPTION: Example showing how to get the default extension for a content-type\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nmime.extension('application/octet-stream') // 'bin'\n```\n\n----------------------------------------\n\nTITLE: Adding a gRPC Route with Timeout Settings - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet demonstrates configuring a gRPC route on an App Mesh virtual router with custom idle and per-request timeouts via the timeout property. It uses appmesh.RouteSpec.grpc and requires service name as part of the match. Dependencies: AWS CDK, App Mesh modules, and router/node. Inputs include serviceName, idle, and perRequest timeouts. Output is a gRPC route that enforces the specified timeouts for request handling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-http', {\n  routeSpec: appmesh.RouteSpec.grpc({\n    weightedTargets: [\n      {\n        virtualNode: node,\n      },\n    ],\n    match: {\n      serviceName: 'my-service.default.svc.cluster.local',\n    },\n    timeout:  {\n      idle : Duration.seconds(2),\n      perRequest: Duration.seconds(1),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining KMS Key with Trust for Account Identities Using AWS CDK in TypeScript\nDESCRIPTION: Creates a KMS key that trusts AWS account identities by enabling 'trustAccountIdentities', which permits IAM users/roles (not just root) to be granted KMS permissions via IAM policies. This matches the default AWS KMS console behavior. Requires 'aws-cdk-lib/aws-kms'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kms.Key(this, 'MyKey', { trustAccountIdentities: true });\n```\n\n----------------------------------------\n\nTITLE: Disabling a Schedule (AWS CDK, TypeScript)\nDESCRIPTION: Configures an EventBridge Scheduler schedule with the enabled property set to false, preventing the schedule from triggering automatically. Useful for disabling schedules without deleting them. Inputs are schedule details and target; output is a disabled schedule. Main dependency is Schedule with a LambdaInvoke target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nnew Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(10)),\n    target: target,\n    enabled: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Auto Software Updates for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet shows how to enable automatic service software updates for an OpenSearch domain by setting the `enableAutoSoftwareUpdate` property to `true` within the `Domain` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_3,\n  enableAutoSoftwareUpdate: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using Match.absent for Asserting Absence of Properties in TypeScript\nDESCRIPTION: Illustrates the `Match.absent()` matcher used within `Match.objectLike` in `hasResourceProperties()`. This asserts that a specific key (`Bob` in the first example) should *not* be present in the target object. The first example passes because 'Bob' is absent at that level, while the second fails because 'Wobble' is present.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": {\n//           \"Wobble\": \"Flob\",\n//         }\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.objectLike({\n    Bob: Match.absent(),\n  }),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.objectLike({\n    Wobble: Match.absent(),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration with Deployment Strategy in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration with a custom deployment strategy for controlled rollout. The strategy defines how the configuration will be deployed to the target environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n  deploymentStrategy: new appconfig.DeploymentStrategy(this, 'MyDeploymentStrategy', {\n    rolloutStrategy: appconfig.RolloutStrategy.linear({\n      growthFactor: 15,\n      deploymentDuration: Duration.minutes(30),\n      finalBakeTime: Duration.minutes(15),\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Updating KMS Key Policy via Escape Hatch in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates using an AWS CDK escape hatch in TypeScript to update the KMS key policy for an SSE-KMS encrypted S3 bucket used with CloudFront OAC. It defines the desired stricter policy (`scopedDownKeyPolicy`) with `StringEquals` and the specific distribution ARN, then accesses the underlying CloudFormation resource (`kms.CfnKey`) to directly set the `keyPolicy` property, overriding the default wildcard policy. This requires obtaining the CloudFront distribution ID after the initial deployment. Dependencies include `aws-cdk-lib/aws-kms`, `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst kmsKey = new kms.Key(this, 'myKMSKey');\nconst myBucket = new s3.Bucket(this, 'mySSEKMSEncryptedBucket', {\n  encryption: s3.BucketEncryption.KMS,\n  encryptionKey: kmsKey,\n  objectOwnership: s3.ObjectOwnership.BUCKET_OWNER_ENFORCED,\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket)\n  },\n});\n\n// Add the following to scope down the key policy\nconst scopedDownKeyPolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"arn:aws:iam::111122223333:root\"\n            },\n            \"Action\": \"kms:*\",\n            \"Resource\": \"*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"cloudfront.amazonaws.com\"\n            },\n            \"Action\": [\n                \"kms:Decrypt\",\n                \"kms:Encrypt\",\n                \"kms:GenerateDataKey*\"\n            ],\n            \"Resource\": \"*\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"AWS:SourceArn\": \"arn:aws:cloudfront::111122223333:distribution/<CloudFront distribution ID>\"\n                }\n            }\n        }\n    ]\n};\nconst cfnKey = (kmsKey.node.defaultChild as kms.CfnKey);\ncfnKey.keyPolicy = scopedDownKeyPolicy;\n```\n\n----------------------------------------\n\nTITLE: Using Local File as BuildSpec in CodeBuild Project\nDESCRIPTION: Demonstrates how to use a file from the local CDK project directory as the buildspec for a CodeBuild project. The file will be uploaded to S3 and referenced from the CodeBuild project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromAsset('my-buildspec.yml'),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting EFS Read Permissions to an IAM Role (Default) in TypeScript\nDESCRIPTION: Grants read-only access to an EFS file system for a specified IAM role using the `.grantRead()` helper method. By default, using this method also updates the file system's resource policy to enforce IAM authentication and deny anonymous access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts // fixture=with-filesystem-instance\nconst role = new iam.Role(this, 'ClientRole', {\n  assumedBy: new iam.AnyPrincipal(),\n});\n\nfileSystem.grantRead(role);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating API Gateway Route53 Alias Record\nDESCRIPTION: Demonstrates how to create a Route53 A-record that aliases to an API Gateway REST API or domain name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as apigw from 'aws-cdk-lib/aws-apigateway';\n\ndeclare const zone: route53.HostedZone;\ndeclare const restApi: apigw.LambdaRestApi;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.ApiGateway(restApi)),\n  // or - route53.RecordTarget.fromAlias(new alias.ApiGatewayDomain(domainName)),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EFS Access Point with AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a new EFS Access Point associated with an existing EFS FileSystem instance using the `addAccessPoint` method in AWS CDK. An optional `clientToken` can be provided to ensure idempotency if the request is retried.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=with-filesystem-instance\nfileSystem.addAccessPoint('MyAccessPoint', {\n  // create a unique access point via an optional client token\n  clientToken: 'client-token',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using a Customer Managed KMS Key for Repository Encryption\nDESCRIPTION: Creates a CodeCommit repository with a customer-managed KMS key for encryption instead of the default AWS-managed key, providing enhanced security control.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\ndeclare const kmsKey: kms.IKey;\n\nconst repo = new codecommit.Repository(this, 'Repository', {\n  repositoryName: 'MyRepositoryName',\n  kmsKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an ECS Deployment with CodeDeploy in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic ECS deployment using the EcsDeployment construct. It specifies the deployment group, task definition, container name, and port.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const deploymentGroup: codedeploy.IEcsDeploymentGroup;\ndeclare const taskDefinition: ecs.ITaskDefinition;\n\nnew EcsDeployment({\n  deploymentGroup,\n  targetService: {\n    taskDefinition,\n    containerName: 'mycontainer',\n    containerPort: 80,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating EKS Cluster with Masters Role - AWS CDK - TypeScript\nDESCRIPTION: Creates an Amazon EKS cluster specifying a master IAM role, granting it cluster admin permissions through AmazonEKSClusterAdminPolicy. Requires a pre-existing IAM role and proper Kubernetes version. Ensures administrative access from outside the CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const role: iam.Role;\nnew eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  mastersRole: role,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Firehose Event Destination to SES Configuration Set (with/without IAM Role) - AWS CDK - TypeScript\nDESCRIPTION: This code provides two usages for attaching a Firehose delivery stream as an event destination for SES using AWS CDK: one with an automatically created IAM role and another specifying a user-defined IAM Role. Required dependencies are 'aws-cdk-lib/aws-kinesisfirehose' for the delivery stream and optionally 'aws-cdk-lib/aws-iam' for the role. This allows SES send events to be delivered to Kinesis Firehose for further processing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as firehose from 'aws-cdk-lib/aws-kinesisfirehose';\n\ndeclare const myConfigurationSet: ses.ConfigurationSet;\ndeclare const firehoseDeliveryStream: firehose.IDeliveryStream;\ndeclare const iamRole: iam.IRole;\n\n// Create IAM Role automatically\nmyConfigurationSet.addEventDestination('ToFirehose', {\n  destination: ses.EventDestination.firehoseDeliveryStream({\n    deliveryStream: firehoseDeliveryStream,\n  }),\n})\n\n// Specify your IAM Role\nmyConfigurationSet.addEventDestination('ToFirehose', {\n  destination: ses.EventDestination.firehoseDeliveryStream({\n    deliveryStream: firehoseDeliveryStream,\n    role: iamRole,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Elastic Beanstalk Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to an Elastic Beanstalk environment endpoint with optional health check evaluation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zone: route53.HostedZone;\ndeclare const ebsEnvironmentUrl: string;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(\n    new targets.ElasticBeanstalkEnvironmentEndpointTarget(ebsEnvironmentUrl, {\n      evaluateTargetHealth: true,\n    }),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Pre-Compilation with TSC for NodejsFunction in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable pre-compilation using TSC for a NodejsFunction, which can be useful when esbuild doesn't support certain TypeScript features.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    preCompilation: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Python Lambda Bundling with Private PyPI Indexes\nDESCRIPTION: Configures custom PyPI index URLs for Python dependency resolution during the Lambda bundling process using buildArgs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst entry = '/path/to/function';\nconst image = DockerImage.fromBuild(entry);\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    buildArgs: { PIP_INDEX_URL: \"https://your.index.url/simple/\", PIP_EXTRA_INDEX_URL: \"https://your.extra-index.url/simple/\" },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AWS Batch Fairshare Scheduling Policy with Shares in TypeScript\nDESCRIPTION: This snippet demonstrates setting up a Fairshare Scheduling Policy for an AWS Batch Job Queue. It creates a policy (`fairsharePolicy`) and defines two shares, 'A' and 'B', both with a weight factor of 1. This policy is then associated with a new Job Queue, replacing the default FIFO behavior to allow for share-based job scheduling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fairsharePolicy = new batch.FairshareSchedulingPolicy(this, 'myFairsharePolicy');\n\nfairsharePolicy.addShare({\n  shareIdentifier: 'A',\n  weightFactor: 1,\n});\nfairsharePolicy.addShare({\n  shareIdentifier: 'B',\n  weightFactor: 1,\n});\nnew batch.JobQueue(this, 'JobQueue', {\n  schedulingPolicy: fairsharePolicy,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Static Import Methods in AWS CDK TypeScript\nDESCRIPTION: Shows the required signature for static `fromXxx` methods (like `fromFooArn` and `fromFooName`) used to import existing AWS resources into a CDK application based on their attributes (ARN, name). These methods should be defined on the resource construct class and return the resource's interface type (e.g., `IFoo`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nstatic fromFooArn(scope: Construct, id: string, bucketArn: string): IFoo;\nstatic fromFooName(scope: Construct, id: string, bucketName: string): IFoo;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring EventBridge Target for AppSync API Invocation in TypeScript\nDESCRIPTION: This TypeScript CDK snippet configures an Amazon EventBridge rule target to invoke an AWS AppSync GraphQL API mutation. It uses the `targets.AppSync` class, specifying the target API, the GraphQL mutation operation (`graphQLOperation`), and the input variables for the mutation using `events.RuleTargetInput.fromObject`. The target API must be configured with AWS_IAM authorization.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as events from 'aws-cdk-lib/aws-events';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\n\ndeclare const rule: events.Rule;\ndeclare const api: appsync.GraphqlApi;\n\nrule.addTarget(new targets.AppSync(api, {\n  graphQLOperation: 'mutation Publish($message: String!){ publish(message: $message) { message } }',\n  variables: events.RuleTargetInput.fromObject({\n    message: 'hello world',\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Caching for CodeBuild Project in TypeScript\nDESCRIPTION: Demonstrates how to set up S3 caching for a CodeBuild project. It includes the cache configuration in the project settings and the necessary cache section in the buildspec.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myCachingBucket: s3.Bucket;\n\nnew codebuild.Project(this, 'Project', {\n  source: codebuild.Source.bitBucket({\n    owner: 'awslabs',\n    repo: 'aws-cdk',\n  }),\n\n  cache: codebuild.Cache.bucket(myCachingBucket),\n\n  // BuildSpec with a 'cache' section necessary for S3 caching. This can\n  // also come from 'buildspec.yml' in your source.\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands: ['...'],\n      },\n    },\n    cache: {\n      paths: [\n        // The '**/*' is required to indicate all files in this directory\n        '/root/cachedir/**/*',\n      ],\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Event Path Input Transformation for EventBridge Pipe\nDESCRIPTION: Demonstrates how to transform events by extracting specific paths from the source event payload.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst targetInputTransformation = pipes.InputTransformation.fromEventPath('$.body.payload')\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue, {\n    inputTransformation: targetInputTransformation, \n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom CDK8s Constructs in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom CDK8s construct for a load-balanced web service. It shows the pattern of using the 'constructs' module instead of 'aws-cdk-lib' when mixing AWS CDK with CDK8s.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as constructs from 'constructs';\nimport * as cdk8s from 'cdk8s';\nimport * as kplus from 'cdk8s-plus-25';\n\ninterface LoadBalancedWebService {\n  readonly port: number;\n  readonly image: string;\n  readonly replicas: number;\n}\n\nconst app = new cdk8s.App();\nconst chart = new cdk8s.Chart(app, 'my-chart');\n\nclass LoadBalancedWebService extends constructs.Construct {\n  constructor(scope: constructs.Construct, id: string, props: LoadBalancedWebService) {\n    super(scope, id);\n\n    const deployment = new kplus.Deployment(chart, 'Deployment', {\n      replicas: props.replicas,\n      containers: [ new kplus.Container({ image: props.image }) ],\n    });\n\n    deployment.exposeViaService({\n      ports: [\n        { port: props.port },\n      ],\n      serviceType: kplus.ServiceType.LOAD_BALANCER,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SNS Subscription Delivery Policy with AWS CDK in TypeScript\nDESCRIPTION: Illustrates how to specify a detailed delivery policy for an HTTPS subscription on an SNS topic using AWS CDK. The deliveryPolicy option configures retry and throttling behavior, and header content type. Dependencies include aws-cdk-lib/aws-sns, aws-cdk-lib/aws-sns-subscriptions, and aws-cdk-lib (for Duration). Parameters control retry timing, backoff, throttling, and request formatting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.addSubscription(\n  new subscriptions.UrlSubscription(\n    'https://foobar.com/',\n    {\n      deliveryPolicy: {\n        healthyRetryPolicy: {\n          minDelayTarget: Duration.seconds(5),\n          maxDelayTarget: Duration.seconds(10),\n          numRetries: 6,\n          backoffFunction: sns.BackoffFunction.EXPONENTIAL,\n        },\n        throttlePolicy: {\n          maxReceivesPerSecond: 10,\n        },\n        requestPolicy: {\n          headerContentType: 'application/json',\n        },\n      },\n    },\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Encrypting EventBridge Pipe Data with KMS in TypeScript\nDESCRIPTION: Demonstrates how to configure an EventBridge Pipe to use a customer-managed KMS key for encrypting pipe data at rest.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\ndeclare const kmsKey: kms.Key;\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue),\n  kmsKey,\n  // pipeName is required when using a KMS key\n  pipeName: 'MyPipe',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Profiling Group with Publish Permissions in AWS CDK\nDESCRIPTION: Creates a CodeGuru Profiler profiling group and grants permissions to an IAM role to publish profiling data. This setup allows the profiling agent to send performance data to the profiling group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codeguruprofiler/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// The execution role of your application that publishes to the ProfilingGroup via CodeGuru Profiler Profiling Agent. (the following is merely an example)\nconst publishAppRole = new iam.Role(this, 'PublishAppRole', {\n  assumedBy: new iam.AccountRootPrincipal(),\n});\n\nconst profilingGroup = new codeguruprofiler.ProfilingGroup(this, 'MyProfilingGroup');\nprofilingGroup.grantPublish(publishAppRole);\n```\n\n----------------------------------------\n\nTITLE: Configuring Tiered Storage for MSK in TypeScript\nDESCRIPTION: This example shows how to configure an MSK Cluster with tiered storage, which provides a low-cost storage tier for virtually unlimited storage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const bucket: s3.IBucket;\n\nconst cluster = new msk.Cluster(this, 'cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_6_0,\n  vpc,\n  storageMode: msk.StorageMode.TIERED,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Kinesis Stream Consumer with Enhanced Fan-out - AWS CDK - TypeScript\nDESCRIPTION: This code creates a Kinesis StreamConsumer with a custom name and associates it with a specified stream to enable enhanced fan-out. Requires aws-cdk-lib, kinesis modules, and the referenced stream construct. Inputs are streamConsumerName and the stream; output is a StreamConsumer resource with dedicated throughput.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst stream = new kinesis.Stream(this, 'MyStream');\n\nconst streamConsumer = new kinesis.StreamConsumer(this, 'MyStreamConsumer', {\n  streamConsumerName: 'MyStreamConsumer',\n  stream,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Manual Key Signing Key for DNSSEC in TypeScript\nDESCRIPTION: Manually creates a Key Signing Key for DNSSEC in Route53 using an existing hosted zone and KMS key. This approach requires separately enabling DNSSEC for the hosted zone.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const hostedZone: route53.HostedZone;\ndeclare const kmsKey: kms.Key;\nnew route53.KeySigningKey(this, 'KeySigningKey', {\n  hostedZone,\n  kmsKey,\n  keySigningKeyName: 'ksk',\n  status: route53.KeySigningKeyStatus.ACTIVE,\n});\n```\n\n----------------------------------------\n\nTITLE: Passing and Encrypting Replication Buckets - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates two related scenarios for defining and encrypting an S3 replication bucket in a different stack using the AWS CDK: first, configuring a replication bucket with a KMS key (which is not supported for cross-environment referencing), and second, resolving the limitation by using a KMS alias in place of the key. Dependencies include '@aws-cdk/aws-s3', '@aws-cdk/aws-kms', and '@aws-cdk/aws-codepipeline'. All cross-region or cross-account replication buckets must be encrypted using an alias to ensure pipeline runtime success. Key parameters include physical bucket name generation, region specification, and KMS key/alias reference.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Passing a replication bucket created in a different stack.\nconst app = new App();\nconst replicationStack = new Stack(app, 'ReplicationStack', {\n  env: {\n    region: 'us-west-1',\n  },\n});\nconst key = new kms.Key(replicationStack, 'ReplicationKey');\nconst replicationBucket = new s3.Bucket(replicationStack, 'ReplicationBucket', {\n  // like was said above - replication buckets need a set physical name\n  bucketName: PhysicalName.GENERATE_IF_NEEDED,\n  encryptionKey: key, // does not work!\n});\n\n// later...\nnew codepipeline.Pipeline(replicationStack, 'Pipeline', {\n  crossRegionReplicationBuckets: {\n    'us-west-1': replicationBucket,\n  },\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Passing an encrypted replication bucket created in a different stack.\nconst app = new App();\nconst replicationStack = new Stack(app, 'ReplicationStack', {\n  env: {\n    region: 'us-west-1',\n  },\n});\nconst key = new kms.Key(replicationStack, 'ReplicationKey');\nconst alias = new kms.Alias(replicationStack, 'ReplicationAlias', {\n  // aliasName is required\n  aliasName: PhysicalName.GENERATE_IF_NEEDED,\n  targetKey: key,\n});\nconst replicationBucket = new s3.Bucket(replicationStack, 'ReplicationBucket', {\n  bucketName: PhysicalName.GENERATE_IF_NEEDED,\n  encryptionKey: alias,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring External Modules for NodejsFunction\nDESCRIPTION: Demonstrates how to specify which modules should be treated as external and not bundled with the Lambda function code, useful for modules available in Lambda runtime or in Layers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    externalModules: [\n      '@aws-sdk/*', // Use the AWS SDK for JS v3 available in the Lambda runtime\n      'cool-module', // 'cool-module' is already available in a Layer\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Node Modules for NodejsFunction\nDESCRIPTION: Demonstrates how to specify Node modules that should be installed in the node_modules folder of the Lambda package rather than bundled, useful for native dependencies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    nodeModules: ['native-module', 'other-module'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining BuildSpec for CodeBuild Project with Secondary Artifacts (TypeScript)\nDESCRIPTION: This snippet shows a sample `BuildSpec` configuration for a CodeBuild project that uses secondary sources and artifacts, defined using the AWS CDK. It demonstrates accessing the secondary source directory via the environment variable `CODEBUILD_SRC_DIR_<identifier>` (e.g., `CODEBUILD_SRC_DIR_source2`) and defining the output for a secondary artifact under the `secondary-artifacts` section, keyed by the artifact's identifier (`artifact2`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'MyProject', {\n  // secondary sources and artifacts as above...\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands: [\n          'cd $CODEBUILD_SRC_DIR_source2',\n          'touch output2.txt',\n        ],\n      },\n    },\n    artifacts: {\n      'secondary-artifacts': {\n        'artifact2': {\n          'base-directory': '$CODEBUILD_SRC_DIR_source2',\n          'files': [\n            'output2.txt',\n          ],\n        },\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Route to WebSocket API in TypeScript (CDK)\nDESCRIPTION: This snippet demonstrates adding a custom route (e.g., 'sendmessage') to an existing WebSocket API. It uses the `addRoute` method on the `WebSocketApi` instance, specifying the route key and a `WebSocketLambdaIntegration` pointing to a handler Lambda function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const messageHandler: lambda.Function;\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nwebSocketApi.addRoute('sendmessage', {\n  integration: new WebSocketLambdaIntegration('SendMessageIntegration', messageHandler),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using Lambda Function as Pipe Enrichment in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe that uses a Lambda function as an enrichment between the source and target queues. The Lambda enrichment processes events before they are sent to the target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-enrichments-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\ndeclare const enrichmentFunction: lambda.Function;\n\nconst enrichment = new enrichments.LambdaEnrichment(enrichmentFunction);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SomeSource(sourceQueue),\n  enrichment,\n  target: new SomeTarget(targetQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Fine-Grained Access Control for an OpenSearch/Elasticsearch Domain\nDESCRIPTION: Demonstrates creating an `es.Domain` with Fine-Grained Access Control (FGAC) enabled using AWS CDK. This requires enabling HTTPS, node-to-node encryption, and encryption-at-rest. A master user is configured via `fineGrainedAccessControl`, and its generated password can be accessed through `domain.masterUserPassword`, typically to store it securely (e.g., in Secrets Manager).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n  },\n});\n\nconst masterUserPassword = domain.masterUserPassword;\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkStreamingJob with Optional Parameters in TypeScript\nDESCRIPTION: Example demonstrating how to create a PySparkStreamingJob with optional override parameters for streaming data processing, including Glue version, worker settings, and other job configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkStreamingJob(stack, 'PySparkStreamingJob', {\n  jobName: 'PySparkStreamingJobCustomName',\n  description: 'This is a description',\n  role,\n  script,\n  glueVersion: glue.GlueVersion.V3_0,\n  continuousLogging: { enabled: false },\n  workerType: glue.WorkerType.G_2X,\n  maxConcurrentRuns: 100,\n  timeout: cdk.Duration.hours(2),\n  connections: [glue.Connection.fromConnectionName(stack, 'Connection', 'connectionName')],\n  securityConfiguration: glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'SecurityConfig', 'securityConfigName'),\n  tags: {\n    FirstTagName: 'FirstTagValue',\n    SecondTagName: 'SecondTagValue',\n    XTagName: 'XTagValue',\n  },\n  numberOfWorkers: 2,\n  maxRetries: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Queue Event Source with Custom Parameters in TypeScript\nDESCRIPTION: This example shows how to create an SQS queue with a custom visibility timeout and configure it as a Lambda event source with batch processing options and batch item failure reporting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SqsEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\nconst queue = new sqs.Queue(this, 'MyQueue', {\n  visibilityTimeout: Duration.seconds(30),      // default,\n});\ndeclare const fn: lambda.Function;\n\nfn.addEventSource(new SqsEventSource(queue, {\n  batchSize: 10, // default\n  maxBatchingWindow: Duration.minutes(5),\n  reportBatchItemFailures: true, // default to false\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Replica Global Secondary Index Options for DynamoDB Global TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates configuring options like `readCapacity` and `contributorInsights` for Global Secondary Indexes (GSIs) on a per-replica basis within a DynamoDB Global TableV2 setup. The `globalSecondaryIndexOptions` property within each replica definition allows specifying overrides for inherited GSI settings. Dependencies include `aws-cdk-lib`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  contributorInsights: true,\n  billing: dynamodb.Billing.provisioned({\n    readCapacity: dynamodb.Capacity.fixed(10),\n    writeCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 10 }),\n  }),\n  // each global secondary index will inherit contributor insights as true\n  globalSecondaryIndexes: [\n    {\n      indexName: 'gsi1',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      readCapacity: dynamodb.Capacity.fixed(15),\n    },\n    {\n      indexName: 'gsi2',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      writeCapacity: dynamodb.Capacity.autoscaled({ minCapacity: 5, maxCapacity: 20 }),\n    },\n  ],\n  replicas: [\n    {\n      region: 'us-east-1',\n      globalSecondaryIndexOptions: {\n        gsi1: {\n          readCapacity: dynamodb.Capacity.autoscaled({ minCapacity: 1, maxCapacity: 10 })\n        },\n      },\n    },\n    {\n      region: 'us-east-2',\n      globalSecondaryIndexOptions: {\n        gsi2: {\n          contributorInsights: false,\n        },\n      },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Restricting Compute Environment to a Single EC2 Instance Type in AWS Batch with TypeScript\nDESCRIPTION: This snippet shows how to configure an AWS Batch managed EC2 compute environment to use only the 'M5AD.large' instance type via AWS CDK. It assumes '@aws-cdk/aws-ec2' and '@aws-cdk/aws-batch' dependencies, and a VPC object. The 'instanceTypes' property is set with an array of allowed EC2 instance types.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'VPC');\n\nnew batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.M5AD, ec2.InstanceSize.LARGE)],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an NS Record to a Route53 Hosted Zone using AWS CDK\nDESCRIPTION: Shows how to add an NS (Name Server) record to a Route53 hosted zone. It specifies the zone, record name, nameserver values, and TTL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.NsRecord(this, 'NSRecord', {\n  zone: myZone,\n  recordName: 'foo',\n  values: [\n    'ns-1.awsdns.co.uk.',\n    'ns-2.awsdns.com.',\n  ],\n  ttl: Duration.minutes(90),       // Optional - default is 30 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Using BEST_FIT_PROGRESSIVE Allocation Strategy in Managed EC2 Compute Environment with AWS Batch (TypeScript)\nDESCRIPTION: This code creates an AWS Batch managed EC2 compute environment with the 'BEST_FIT_PROGRESSIVE' allocation strategy (default when spot is false or omitted). The configuration combines the 'optimal' instance class and an explicit M5 instance class for flexible scheduling. Requires '@aws-cdk/aws-ec2', '@aws-cdk/aws-batch', and an initialized VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nconst computeEnv = new batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  instanceClasses: [ec2.InstanceClass.M5],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Users to IAM Groups in AWS CDK\nDESCRIPTION: Demonstrates how to add a user to a group in AWS CDK. This can be done with either new or imported users and groups, and can be performed from either the user or group side.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = new iam.User(this, 'MyUser'); // or User.fromUserName(this, 'User', 'johnsmith');\nconst group = new iam.Group(this, 'MyGroup'); // or Group.fromGroupArn(this, 'Group', 'arn:aws:iam::account-id:group/group-name');\n\nuser.addToGroup(group);\n// or\ngroup.addUser(user);\n```\n\n----------------------------------------\n\nTITLE: Generic Event Handler Implementation\nDESCRIPTION: Generic event handler method implementation for AWS resources that emit CloudWatch events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nonEvent(event: string, id: string, target: events.IEventRuleTarget): cloudwatch.EventRule\n```\n\n----------------------------------------\n\nTITLE: Passing Custom User Parameters to LambdaInvokeAction in CodePipeline (TypeScript)\nDESCRIPTION: Demonstrates how to pass custom user parameters to a Lambda function invoked by a LambdaInvokeAction in CodePipeline using TypeScript and AWS CDK. Parameters can be provided as structured objects (userParameters) or as a string (userParametersString), which are then accessible by the Lambda at execution time. Requires codepipeline, lambda constructs, and configured parameter values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst lambdaAction = new codepipeline_actions.LambdaInvokeAction({\n  actionName: 'Lambda',\n  lambda: fn,\n  userParameters: {\n    foo: 'bar',\n    baz: 'qux',\n  },\n  // OR\n  userParametersString: 'my-parameter-string',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Streams with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to configure a DynamoDB table with a Kinesis stream and replicas. It demonstrates setting up streams for both the primary table and a specific replica.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst stream1 = new kinesis.Stream(stack, 'Stream1');\nconst stream2 = kinesis.Stream.fromStreamArn(stack, 'Stream2', 'arn:aws:kinesis:us-east-2:123456789012:stream/my-stream');\n\nconst globalTable = new dynamodb.TableV2(this, 'GlobalTable', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  kinesisStream: stream1, // for table in us-west-2\n  replicas: [\n    { region: 'us-east-1' }, // no kinesis data stream will be set for this replica\n    {\n      region: 'us-east-2',\n      kinesisStream: stream2, // for table in us-east-2\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cognito User Pool Authorizer with AWS CDK - TypeScript\nDESCRIPTION: Illustrates creating a User Pool Authorizer using AWS Cognito within an HTTP API in AWS CDK. The snippet imports Cognito constructs, defines a User Pool, creates an HttpUserPoolAuthorizer instance, and assigns it to an API route via addRoutes. Dependencies include aws-cdk-lib/aws-cognito and aws-cdk-lib/aws-apigatewayv2-authorizers. Inputs involve a Cognito User Pool resource and HTTP endpoint; outputs are routes protected by Cognito tokens acquired from the User Pool. This setup enforces Cognito JWT authentication on API consumers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cognito from 'aws-cdk-lib/aws-cognito';\nimport { HttpUserPoolAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst userPool = new cognito.UserPool(this, 'UserPool');\n\nconst authorizer = new HttpUserPoolAuthorizer('BooksAuthorizer', userPool);\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi');\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  authorizer,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic AwsApiCall Usage in AWS CDK\nDESCRIPTION: Demonstrates how to use the AwsApiCall construct for making AWS API calls using the AWS JavaScript SDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew AwsApiCall(stack, 'MyAssertion', {\n  service: 'SQS',\n  api: 'receiveMessage',\n  parameters: {\n    QueueUrl: 'url',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing Lambda Deployment Group in TypeScript\nDESCRIPTION: Shows how to import an existing AWS CodeDeploy Lambda Deployment Group into an AWS CDK application. This is useful when the Deployment Group is managed outside the current CDK stack. It requires the associated CodeDeploy Application (`codedeploy.LambdaApplication`) and the name of the Deployment Group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: codedeploy.LambdaApplication;\nconst deploymentGroup = codedeploy.LambdaDeploymentGroup.fromLambdaDeploymentGroupAttributes(this, 'ExistingCodeDeployDeploymentGroup', {\n  application,\n  deploymentGroupName: 'MyExistingDeploymentGroup',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Reports in CodeBuild BuildSpec via CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to define a test report configuration within the BuildSpec of an AWS CodeBuild project using the AWS CDK. It specifies the report group name (`myReport`), the files to include (`**/*`), and the base directory (`build/test-results`) within the `reports` section of the BuildSpec object. This automatically creates a new test report group named `<ProjectName>-myReport`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'Project', {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    // ...\n    reports: {\n      myReport: {\n        files: '**/*',\n        'base-directory': 'build/test-results',\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Cognito Authentication for OpenSearch Dashboards in TypeScript\nDESCRIPTION: This snippet configures Amazon Cognito authentication for OpenSearch Dashboards. It requires providing an IAM role (`cognitoConfigurationRole`), an Identity Pool ID, and a User Pool ID within the `cognitoDashboardsAuth` property of the `Domain` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const cognitoConfigurationRole: iam.Role;\n\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  cognitoDashboardsAuth: {\n    role: cognitoConfigurationRole,\n    identityPoolId: 'example-identity-pool-id',\n    userPoolId: 'example-user-pool-id',\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Build Arguments for Go Function Bundling\nDESCRIPTION: Shows how to pass build arguments to the Docker container when bundling a Go function. This is useful for configuring network proxies or other build-time settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'handler', {\n  entry: 'app/cmd/api',\n  bundling: {\n    buildArgs: {\n      HTTPS_PROXY: 'https://127.0.0.1:3001',\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Auto-extracting Response Payload with Lambda Destination in TypeScript\nDESCRIPTION: Example showing how to configure a Lambda destination with the responseOnly option to auto-extract the response payload from the invocation record. This simplifies function chaining by eliminating the need for manual payload extraction in destination function code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-destinations/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Auto-extract response payload with a lambda destination\ndeclare const destinationFn: lambda.Function;\n\nconst sourceFn = new lambda.Function(this, 'Source', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n  // auto-extract on success\n  onSuccess: new destinations.LambdaDestination(destinationFn, {\n    responseOnly: true,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Basic ECR Repository in TypeScript\nDESCRIPTION: Initializes a basic ECR repository that can hold multiple versions of a container image.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst repository = new ecr.Repository(this, 'Repository');\n```\n\n----------------------------------------\n\nTITLE: Configuring SNS Topic as Lambda Event Source in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up an SNS topic to trigger a Lambda function. It includes configuration for a filter policy and a dead letter queue for handling failed executions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sns from 'aws-cdk-lib/aws-sns';\nimport { SnsEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\ndeclare const topic: sns.Topic;\nconst deadLetterQueue = new sqs.Queue(this, 'deadLetterQueue');\n\ndeclare const fn: lambda.Function;\nfn.addEventSource(new SnsEventSource(topic, {\n  filterPolicy: { },\n  deadLetterQueue: deadLetterQueue,\n}));\n```\n\n----------------------------------------\n\nTITLE: Setting Storage Type for DocumentDB\nDESCRIPTION: Demonstrates how to specify storage type for a DocumentDB cluster, with support for IOPT1 starting from engine version 5.0.0.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst cluster = new docdb.DatabaseCluster(this, 'Database', {\n  masterUser: {\n    username: 'myuser',\n  },\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n  vpc,\n  storageType: docdb.StorageType.IOPT1, // Default is StorageType.STANDARD\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with Traditional Managed Node Group in TypeScript\nDESCRIPTION: Shows how to create an EKS cluster using the traditional node group approach instead of Auto Mode, specifying the number of instances and instance type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.NODEGROUP,\n  defaultCapacity: 3, // Number of instances\n  defaultCapacityInstance: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.LARGE),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Buffering for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure buffering settings for an Amazon Data Firehose delivery stream, increasing the buffer interval to 10 minutes and the buffer size to 8 MiB.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Increase the buffer interval and size to 10 minutes and 8 MiB, respectively\ndeclare const bucket: s3.Bucket;\nconst destination = new firehose.S3Bucket(bucket, {\n  bufferingInterval: Duration.minutes(10),\n  bufferingSize: Size.mebibytes(8),\n});\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM Permissions for AppSync Field Access in TypeScript\nDESCRIPTION: This TypeScript CDK code demonstrates granting specific IAM permissions to an IAM role for accessing a particular AppSync GraphQL mutation field (`types/Mutation/fields/updateExample`). It uses the `api.grant` method with a custom `IamResource` to define the target resource and the `appsync:GraphQL` action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n});\ndeclare const api: appsync.IGraphqlApi;\n\napi.grant(role, appsync.IamResource.custom('types/Mutation/fields/updateExample'), 'appsync:GraphQL');\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Object Lambda Access Points in AWS CDK with TypeScript\nDESCRIPTION: Basic example of creating an S3 Object Lambda access point with a bucket and Lambda handler. This snippet shows the minimal configuration needed to set up an access point with a custom name and payload data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3objectlambda-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as s3objectlambda from '@aws-cdk/aws-s3objectlambda-alpha';\nimport * as cdk from 'aws-cdk-lib';\n\nconst stack = new cdk.Stack();\nconst bucket = new s3.Bucket(stack, 'MyBucket');\nconst handler = new lambda.Function(stack, 'MyFunction', {\n\truntime: lambda.Runtime.NODEJS_LATEST,\n\thandler: 'index.handler',\n\tcode: lambda.Code.fromAsset('lambda.zip'),\n});\nnew s3objectlambda.AccessPoint(stack, 'MyObjectLambda', {\n\tbucket,\n\thandler,\n\taccessPointName: 'my-access-point',\n\tpayload: {\n\t\tprop: \"value\",\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Axios Request Configuration Object in JavaScript\nDESCRIPTION: This JavaScript object illustrates the comprehensive set of options available for configuring an Axios HTTP request. It covers essential properties like `url` (required), `method` (defaults to 'GET'), `baseURL`, `headers`, `params`, and `data`. It also demonstrates advanced features such as request/response transformations (`transformRequest`, `transformResponse`), authentication (`auth`), proxy settings (`proxy`), timeout configuration (`timeout`), progress event handlers (`onUploadProgress`, `onDownloadProgress`), cancellation (`cancelToken`, `signal`), and status validation (`validateStatus`). Comments within the code explain the purpose and usage of each option.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // `url` is the server URL that will be used for the request\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n  method: 'get', // default\n\n  // `baseURL` will be prepended to `url` unless `url` is absolute and option `allowAbsoluteUrls` is set to true.\n  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs\n  // to methods of that instance.\n  baseURL: 'https://some-domain.com/api/',\n\n  // `allowAbsoluteUrls` determines whether or not absolute URLs will override a configured `baseUrl`.\n  // When set to true (default), absolute values for `url` will override `baseUrl`.\n  // When set to false, absolute values for `url` will always be prepended by `baseUrl`.\n  allowAbsoluteUrls: true,\n\n  // `transformRequest` allows changes to the request data before it is sent to the server\n  // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'\n  // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,\n  // FormData or Stream\n  // You may modify the headers object.\n  transformRequest: [function (data, headers) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformResponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n  \n  // `paramsSerializer` is an optional config that allows you to customize serializing `params`. \n  paramsSerializer: {\n\n    // Custom encoder function which sends key/value pairs in an iterative fashion.\n    encode?: (param: string): string => { /* Do custom operations here and return transformed string */ }, \n    \n    // Custom serializer function for the entire parameter. Allows user to mimic pre 1.x behaviour.\n    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), \n    \n    // Configuration for formatting array indexes in the params. \n    indexes: false // Three available options: (1) indexes: null (leads to no brackets), (2) (default) indexes: false (leads to empty brackets), (3) indexes: true (leads to brackets with indexes).    \n  },\n\n  // `data` is the data to be sent as the request body\n  // Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH'\n  // When no `transformRequest` is set, must be of one of the following types:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - Browser only: FormData, File, Blob\n  // - Node only: Stream, Buffer, FormData (form-data package)\n  data: {\n    firstName: 'Fred'\n  },\n\n  // syntax alternative to send data into the body\n  // method post\n  // only the value is sent, not the key\n  data: 'Country=Brasil&City=Belo Horizonte',\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // If the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000, // default is `0` (no timeout)\n\n  // `withCredentials` indicates whether or not cross-site Access-Control requests\n  // should be made using credentials\n  withCredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see lib/adapters/README.md)\n  adapter: function (config) {\n    /* ... */\n  },\n  // Also, you can set the name of the built-in adapter, or provide an array with their names\n  // to choose the first available in the environment\n  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']\n\n  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.\n  // This will set an `Authorization` header, overwriting any existing\n  // `Authorization` custom headers you have set using `headers`.\n  // Please note that only HTTP Basic auth is configurable through this parameter.\n  // For Bearer tokens and such, use `Authorization` custom headers instead.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` indicates the type of data that the server will respond with\n  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  //   browser only: 'blob'\n  responseType: 'json', // default\n\n  // `responseEncoding` indicates encoding to use for decoding responses (Node.js only)\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  // options are: 'ascii', 'ASCII', 'ansi', 'ANSI', 'binary', 'BINARY', 'base64', 'BASE64', 'base64url',\n  // 'BASE64URL', 'hex', 'HEX', 'latin1', 'LATIN1', 'ucs-2', 'UCS-2', 'ucs2', 'UCS2', 'utf-8', 'UTF-8',\n  // 'utf8', 'UTF8', 'utf16le', 'UTF16LE'\n  responseEncoding: 'utf8', // default\n\n  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n    \n  // `undefined` (default) - set XSRF header only for the same origin requests\n  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),\n\n  // `onUploadProgress` allows handling of progress events for uploads\n  // browser & node.js\n  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {\n    // Do whatever you want with the Axios progress event\n  },\n\n  // `onDownloadProgress` allows handling of progress events for downloads\n  // browser & node.js\n  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {\n    // Do whatever you want with the Axios progress event\n  },\n\n  // `maxContentLength` defines the max size of the http response content in bytes allowed in node.js\n  maxContentLength: 2000,\n\n  // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed\n  maxBodyLength: 2000,\n\n  // `validateStatus` defines whether to resolve or reject the promise for a given\n  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` defines the maximum number of redirects to follow in node.js.\n  // If set to 0, no redirects will be followed.\n  maxRedirects: 21, // default\n\n  // `beforeRedirect` defines a function that will be called before redirect.\n  // Use this to adjust the request options upon redirecting,\n  // to inspect the latest response headers,\n  // or to cancel the request by throwing an error\n  // If maxRedirects is set to 0, `beforeRedirect` is not used.\n  beforeRedirect: (options, { headers }) => {\n    if (options.hostname === \"example.com\") {\n      options.auth = \"user:password\";\n    }\n  },\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n  \n  // `transport` determines the transport method that will be used to make the request.\n  // If defined, it will be used. Otherwise, if `maxRedirects` is 0,\n  // the default `http` or `https` library will be used, depending on the protocol specified in `protocol`.\n  // Otherwise, the `httpFollow` or `httpsFollow` library will be used, again depending on the protocol,\n  // which can handle redirects.\n  transport: undefined, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows options to be added like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // `proxy` defines the hostname, port, and protocol of the proxy server.\n  // You can also define your proxy using the conventional `http_proxy` and\n  // `https_proxy` environment variables. If you are using environment variables\n  // for your proxy configuration, you can also define a `no_proxy` environment\n  // variable as a comma-separated list of domains that should not be proxied.\n  // Use `false` to disable proxies, ignoring environment variables.\n  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and\n  // supplies credentials.\n  // This will set an `Proxy-Authorization` header, overwriting any existing\n  // `Proxy-Authorization` custom headers you have set using `headers`.\n  // If the proxy server uses HTTPS, then you must set the protocol to `https`.\n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    // hostname: '127.0.0.1' // Takes precedence over 'host' if both are defined\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` specifies a cancel token that can be used to cancel the request\n  // (see Cancellation section below for details)\n  cancelToken: new CancelToken(function (cancel) {\n  }),\n\n  // an alternative way to cancel Axios requests using AbortController\n  signal: new AbortController().signal,\n\n  // `decompress` indicates whether or not the response body should be decompressed\n  // automatically. If set to `true` will also remove the 'content-encoding' header\n  // from the responses objects of all decompressed responses\n}\n```\n\n----------------------------------------\n\nTITLE: Starting an AWS CodeBuild Job with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates configuring an AWS CodeBuild project to be triggered by EventBridge Scheduler using the AWS CDK. It assumes an existing CodeBuild project (`project`) and creates a `CodeBuildStartBuild` target. A schedule is then defined to trigger this target every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codebuild from 'aws-cdk-lib/aws-codebuild';\n\ndeclare const project: codebuild.Project;\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.CodeBuildStartBuild(project),\n});\n```\n\n----------------------------------------\n\nTITLE: Starting an AWS CodePipeline Execution with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet illustrates how to start an AWS CodePipeline execution using EventBridge Scheduler and AWS CDK. It assumes an existing CodePipeline `Pipeline`, creates a `CodePipelineStartPipelineExecution` target referencing this pipeline, and defines a schedule to trigger the pipeline execution every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codepipeline from 'aws-cdk-lib/aws-codepipeline';\n\ndeclare const pipeline: codepipeline.Pipeline;\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.CodePipelineStartPipelineExecution(pipeline),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Caching for CodeBuild Project in TypeScript\nDESCRIPTION: Shows how to set up local caching for a CodeBuild project. It demonstrates enabling Docker layer and custom caching modes, along with the necessary cache configuration in the buildspec.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'Project', {\n  source: codebuild.Source.gitHubEnterprise({\n    httpsCloneUrl: 'https://my-github-enterprise.com/owner/repo',\n  }),\n\n  // Enable Docker AND custom caching\n  cache: codebuild.Cache.local(codebuild.LocalCacheMode.DOCKER_LAYER, codebuild.LocalCacheMode.CUSTOM),\n\n  // BuildSpec with a 'cache' section necessary for 'CUSTOM' caching. This can\n  // also come from 'buildspec.yml' in your source.\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands: ['...'],\n      },\n    },\n    cache: {\n      paths: [\n        // The '**/*' is required to indicate all files in this directory\n        '/root/cachedir/**/*',\n      ],\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Development OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: This snippet demonstrates the minimal configuration required to create an Amazon OpenSearch Service (or Elasticsearch Service) domain using AWS CDK. It instantiates an `es.Domain` construct, specifying only the desired Elasticsearch version (`V7_1`). This is suitable for basic development or testing purposes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst devDomain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using JSON-Aware Source Processing with CDK Tokens\nDESCRIPTION: Demonstrates how to use Source.jsonData with CDK Tokens that reference construct properties, enabling proper JSON escaping for special characters in the referenced values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\ndeclare const param: ssm.StringParameter;\n\n// Example with a secret value that contains double quotes\nconst deployment = new s3deploy.BucketDeployment(this, 'JsonDeployment', {\n  sources: [\n    s3deploy.Source.jsonData('config.json', {\n      api_endpoint: 'https://api.example.com',\n      secretValue: param.stringValue, // value with double quotes\n      config: {\n        enabled: true,\n        features: ['feature1', 'feature2']\n      }\n    },\n    // Enable escaping at deployment time\n    { escape: true },\n    )\n  ],\n  destinationBucket: bucket,\n});\n```\n\n----------------------------------------\n\nTITLE: Ensuring Deployment Readiness Dependencies for CDK S3 Bucket (TypeScript)\nDESCRIPTION: This snippet shows how to make sure another construct depending on files inside an S3 bucket waits until those files are actually deployed. Using deployment.deployedBucket from the BucketDeployment, resources instantiated downstream can be made to depend on the deployed content, ensuring proper resource initialization order. Requires the AWS CDK s3 and s3-deployment modules, as well as knowledge of construct dependency chaining.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const websiteBucket: s3.Bucket;\n\nconst deployment = new s3deploy.BucketDeployment(this, 'DeployWebsite', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket: websiteBucket,\n});\n\nnew ConstructThatReadsFromTheBucket(this, 'Consumer', {\n  // Use 'deployment.deployedBucket' instead of 'websiteBucket' here\n  bucket: deployment.deployedBucket,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling All Group Metrics for an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable monitoring for all available group metrics on an AWS Auto Scaling Group using the AWS CDK. It initializes an `AutoScalingGroup` and sets the `groupMetrics` property to `[autoscaling.GroupMetrics.all()]`. Dependencies include declared variables for `vpc`, `instanceType`, and `machineImage`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\n// Enable monitoring of all group metrics\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  groupMetrics: [autoscaling.GroupMetrics.all()],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Classic Load Balancer Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to a Classic Load Balancer with optional health check evaluation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elb from 'aws-cdk-lib/aws-elasticloadbalancing';\n\ndeclare const zone: route53.HostedZone;\ndeclare const lb: elb.LoadBalancer;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(\n    new targets.ClassicLoadBalancerTarget(lb, {\n      evaluateTargetHealth: true,\n    }),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AWS App Mesh Mesh with Default Egress Filter in TypeScript\nDESCRIPTION: Instantiates an AWS App Mesh `Mesh` resource using the CDK `appmesh.Mesh` construct within the current scope (`this`, typically a Stack). It assigns the mesh the logical ID 'AppMesh' and the physical name 'myAwsMesh'. By default, without specifying `egressFilter`, it uses `DROP_ALL`, blocking outbound traffic from services within the mesh.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mesh = new appmesh.Mesh(this, 'AppMesh', {\n  meshName: 'myAwsMesh',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using EKS Access Policies - AWS CDK - TypeScript\nDESCRIPTION: Shows how to instantiate predefined AWS-managed EKS access policies and scope them at the cluster or namespace level using AccessPolicy. These are not standard IAM policies but EKS-specific identity policies. Required for granular access control on the cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\n// AmazonEKSClusterAdminPolicy with `cluster` scope\neks.AccessPolicy.fromAccessPolicyName('AmazonEKSClusterAdminPolicy', {\n  accessScopeType: eks.AccessScopeType.CLUSTER,\n});\n// AmazonEKSAdminPolicy with `namespace` scope\neks.AccessPolicy.fromAccessPolicyName('AmazonEKSAdminPolicy', {\n  accessScopeType: eks.AccessScopeType.NAMESPACE,\n  namespaces: ['foo', 'bar'] } );\n```\n\n----------------------------------------\n\nTITLE: Creating an SSM Incident Manager Incident via a CloudWatch Alarm Action (TypeScript)\nDESCRIPTION: This snippet demonstrates attaching an action to a CloudWatch alarm that creates an incident in AWS Systems Manager Incident Manager. It uses the `SsmIncidentAction` class from `aws-cdk-lib/aws-cloudwatch-actions`, requiring the name of the response plan ('ResponsePlanName' in the example) to be used for the incident creation. The action is added to a predefined `cloudwatch.Alarm`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch-actions/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const alarm: cloudwatch.Alarm;\n// Create an Incident Manager incident based on a specific response plan\nalarm.addAlarmAction(\n  new actions.SsmIncidentAction('ResponsePlanName')\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Warm Throughput for DynamoDB Tables in TypeScript\nDESCRIPTION: This example shows how to configure warm throughput for a DynamoDB table to handle anticipated read and write operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  warmThroughput: {\n      readUnitsPerSecond: 15000,\n      writeUnitsPerSecond: 20000,\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Predefined Lambda Deployment Configurations in TypeScript\nDESCRIPTION: Demonstrates assigning a predefined CodeDeploy traffic shifting configuration to a LambdaDeploymentGroup using AWS CDK. CodeDeploy for Lambda provides several built-in configurations like `CANARY_10PERCENT_30MINUTES`, which dictates how traffic is shifted to the new Lambda version. This snippet shows referencing such a predefined configuration constant.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = codedeploy.LambdaDeploymentConfig.CANARY_10PERCENT_30MINUTES;\n\ndeclare const application: codedeploy.LambdaApplication;\ndeclare const alias: lambda.Alias;\nconst deploymentGroup = new codedeploy.LambdaDeploymentGroup(this, 'BlueGreenDeployment', {\n  application,\n  alias,\n  deploymentConfig: config,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a TopicPolicy with a Policy Document in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to initialize an SNS TopicPolicy in AWS CDK by passing in a pre-constructed IAM PolicyDocument object with explicit SIDs and statements. This approach allows for granular control and multiple statements at creation time. Requires sns and iam constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic');\nconst policyDocument = new iam.PolicyDocument({\n  assignSids: true,\n  statements: [\n    new iam.PolicyStatement({\n      actions: [\"sns:Subscribe\"],\n      principals: [new iam.AnyPrincipal()],\n      resources: [topic.topicArn],\n    }),\n  ],\n});\n\nconst topicPolicy = new sns.TopicPolicy(this, 'Policy', {\n  topics: [topic],\n  policyDocument,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Secrets via ARN, Name, or Attributes - AWS CDK TypeScript\nDESCRIPTION: Details various flexible approaches for importing existing secrets into a CDK stack: by complete ARN, partial ARN (name only), by name, or by explicit attributes (including an encryption key). Enables referencing externally-managed resources for use in the stack. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-kms. Expects valid ARNs, names, and potentially Key object. Useful for multi-region and cross-stack scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst secretCompleteArn = 'arn:aws:secretsmanager:eu-west-1:111111111111:secret:MySecret-f3gDy9';\nconst secretPartialArn = 'arn:aws:secretsmanager:eu-west-1:111111111111:secret:MySecret'; // No Secrets Manager suffix\nconst encryptionKey = kms.Key.fromKeyArn(this, 'MyEncKey', 'arn:aws:kms:eu-west-1:111111111111:key/21c4b39b-fde2-4273-9ac0-d9bb5c0d0030');\nconst mySecretFromCompleteArn = secretsmanager.Secret.fromSecretCompleteArn(this, 'SecretFromCompleteArn', secretCompleteArn);\nconst mySecretFromPartialArn = secretsmanager.Secret.fromSecretPartialArn(this, 'SecretFromPartialArn', secretPartialArn);\nconst mySecretFromName = secretsmanager.Secret.fromSecretNameV2(this, 'SecretFromName', 'MySecret')\nconst mySecretFromAttrs = secretsmanager.Secret.fromSecretAttributes(this, 'SecretFromAttributes', {\n  secretCompleteArn,\n  encryptionKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an ECS Deployment Group for Blue/Green Deployments in TypeScript\nDESCRIPTION: Demonstrates setting up an AWS CodeDeploy Deployment Group for an Amazon ECS service configured for blue/green deployments using AWS CDK. It involves creating an ECS service with the `CODE_DEPLOY` deployment controller type and then defining an `EcsDeploymentGroup` linked to the service, blue/green target groups, and a listener. A predefined ECS deployment configuration (`CANARY_10PERCENT_5MINUTES`) is used. Note that deployments must be initiated via CodeDeploy APIs/console, not CloudFormation, when using this setup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myApplication: codedeploy.EcsApplication;\ndeclare const cluster: ecs.Cluster;\ndeclare const taskDefinition: ecs.FargateTaskDefinition;\ndeclare const blueTargetGroup: elbv2.ITargetGroup;\ndeclare const greenTargetGroup: elbv2.ITargetGroup;\ndeclare const listener: elbv2.IApplicationListener;\n\nconst service = new ecs.FargateService(this, 'Service', {\n  cluster,\n  taskDefinition,\n  deploymentController: {\n    type: ecs.DeploymentControllerType.CODE_DEPLOY,\n  },\n});\n\nnew codedeploy.EcsDeploymentGroup(this, 'BlueGreenDG', {\n  service,\n  blueGreenDeploymentConfig: {\n    blueTargetGroup,\n    greenTargetGroup,\n    listener,\n  },\n  deploymentConfig: codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES,\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate with Email Validation - AWS CDK - TypeScript\nDESCRIPTION: The code provisions an ACM certificate validated via email using AWS CDK. Email validation is the default method and requires the user to complete requested validation by following email instructions sent to domain contacts. Inputs: domain name, optional validation method. Outputs: ACM certificate pending email validation. Dependencies: aws-cdk-lib/aws-certificatemanager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew acm.Certificate(this, 'Certificate', {\n  domainName: 'hello.example.com',\n  validation: acm.CertificateValidation.fromEmail(), // Optional, this is the default\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up CloudFront OAI (Legacy) with Custom Identity in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a CloudFront S3 origin using a specific, user-defined Origin Access Identity (OAI) in AWS CDK TypeScript. It involves creating an `OriginAccessIdentity` instance (`myOai`) and passing it via the `originAccessIdentity` property within the second argument to `origins.S3BucketOrigin.withOriginAccessIdentity`. Dependencies include `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst myOai = new cloudfront.OriginAccessIdentity(this, 'myOAI', {\n  comment: 'My custom OAI'\n});\nconst s3Origin = origins.S3BucketOrigin.withOriginAccessIdentity(myBucket, {\n  originAccessIdentity: myOai\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: s3Origin\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing OpenSearch Domain from CloudFormation Exports\nDESCRIPTION: Imports an OpenSearch domain using exported values from another CloudFormation stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst domainArn = Fn.importValue(`another-cf-stack-export-domain-arn`);\nconst domainEndpoint = Fn.importValue(`another-cf-stack-export-domain-endpoint`);\nconst domain = Domain.fromDomainAttributes(this, 'ImportedDomain', {\n  domainArn,\n  domainEndpoint,\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate Opting Out of Transparency Logging - AWS CDK - TypeScript\nDESCRIPTION: This snippet provisions an ACM certificate with transparency logging disabled by setting transparencyLoggingEnabled to false in AWS CDK. Inputs are the domain name and the transparency logging option. Outputs a certificate resource without public transparency logs. Dependencies: aws-cdk-lib/aws-certificatemanager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew acm.Certificate(this, 'Certificate', {\n  domainName: 'test.example.com',\n  transparencyLoggingEnabled: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Auto-Rollback Configuration for ECS Deployment in TypeScript\nDESCRIPTION: This snippet shows how to override the default AutoRollbackConfig for an ECS deployment. It allows customization of rollback behavior for failed deployments, deployments in alarm state, and stopped deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const deploymentGroup: codedeploy.IEcsDeploymentGroup;\ndeclare const taskDefinition: ecs.ITaskDefinition;\n\nnew EcsDeployment({\n  deploymentGroup,\n  targetService: {\n    taskDefinition,\n    containerName: 'mycontainer',\n    containerPort: 80,\n  },\n  autoRollback: {\n    failedDeployment: true,\n    deploymentInAlarm: true,\n    stoppedDeployment: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Generating CloudWatch Metric and Alarm for Primary DynamoDB Table Using AWS CDK - TypeScript\nDESCRIPTION: Illustrates how to generate a CloudWatch metric (specifically, ConsumedReadCapacityUnits) and attach an alarm for the primary DynamoDB table in a global table setup using AWS CDK's 'TableV2' construct in TypeScript. The example uses 'metricConsumedReadCapacityUnits' for monitoring and triggers a CloudWatch alarm if the threshold is reached. Dependencies include 'aws-cdk-lib' and 'aws-cdk-lib/aws-cloudwatch'. Input required is a properly defined global table; the output is an alarm resource in CloudWatch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n\n// metric is only for the table in us-west-2\nconst metric = globalTable.metricConsumedReadCapacityUnits();\n\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: metric,\n  evaluationPeriods: 1,\n  threshold: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Zero Buffering for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet shows how to set up zero buffering for an Amazon Data Firehose delivery stream by setting the buffer interval to 0 seconds.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Setup zero buffering\ndeclare const bucket: s3.Bucket;\nconst destination = new firehose.S3Bucket(bucket, {\n  bufferingInterval: Duration.seconds(0),\n});\nnew firehose.DeliveryStream(this, 'ZeroBufferDeliveryStream', {\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching VPCs to AWS Transit Gateway using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates creating VPCs, subnets, and a Transit Gateway with AWS CDK in TypeScript, and attaching the VPC to the Transit Gateway. Illustrates the use of the attachVpc() method with both required and optional parameters such as vpcAttachmentOptions to enable DNS support, appliance mode, IPv6, and security group referencing. Key parameters include the VPC, list of subnets, and optional attachment options. Outputs Transit Gateway Attachments; requires AWS CDK v2 constructs for VPCs, Subnets, and Transit Gateway.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst myVpc = new VpcV2(this, 'Vpc');\nconst subnet1 = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\n\nconst subnet2 = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.1.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\n\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\n\n// Create a basic attachment\nconst attachment = transitGateway.attachVpc('VpcAttachment', {\n  vpc: myVpc, \n  subnets: [subnet1, subnet2]\n});\n\n// Create an attachment with optional parameters\nconst attachmentWithOptions = transitGateway.attachVpc('VpcAttachmentWithOptions', {\n  vpc: myVpc, \n  subnets: [subnet1], \n  vpcAttachmentOptions: {\n    dnsSupport: true,\n    applianceModeSupport: true,\n    ipv6Support: true,\n    securityGroupReferencingSupport: true,\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using Command Hooks in Python Lambda Bundling\nDESCRIPTION: Implements command hooks to run additional commands before and after bundling Python Lambda functions, such as running tests or linting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst entry = '/path/to/function';\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    commandHooks: {\n      // run tests\n      beforeBundling(inputDir: string): string[] {\n        return ['pytest'];\n      },\n      afterBundling(inputDir: string): string[] {\n        return ['pylint'];\n      },\n      // ...\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Step Scaling Based on a Metric in TypeScript\nDESCRIPTION: Demonstrates how to implement step scaling using the `scaleOnMetric` method on a `ScalableAttribute`. It configures scaling steps based on a CloudWatch metric (`cpuUtilization`), specifying upper and lower bounds for metric values and the corresponding capacity change. The `adjustmentType` determines whether the 'change' value is an absolute number or a percentage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const capacity: ScalableAttribute;\ndeclare const cpuUtilization: cloudwatch.Metric;\n\ncapacity.scaleOnMetric('ScaleToCPU', {\n  metric: cpuUtilization,\n  scalingSteps: [\n    { upper: 10, change: -1 },\n    { lower: 50, change: +1 },\n    { lower: 70, change: +3 },\n  ],\n\n  // Change this to AdjustmentType.PercentChangeInCapacity to interpret the\n  // 'change' numbers before as percentages instead of capacity counts.\n  adjustmentType: appscaling.AdjustmentType.CHANGE_IN_CAPACITY,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Helm Charts from S3 Assets using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to use a local Helm chart by packaging it as an S3 asset and deploying it via AWS CDK. It first creates an `s3Assets.Asset` pointing to the local chart path, then passes this asset to the `chartAsset` property of `cluster.addHelmChart`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3Assets from 'aws-cdk-lib/aws-s3-assets';\n\ndeclare const cluster: eks.Cluster;\nconst chartAsset = new s3Assets.Asset(this, 'ChartAsset', {\n  path: '/path/to/asset'\n});\n\ncluster.addHelmChart('test-chart', {\n  chartAsset: chartAsset,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Application Associator with a New Application in TypeScript\nDESCRIPTION: Shows how to create an ApplicationAssociator that creates a new application and associates all stacks in the CDK App scope with it. Includes configuration for application name, description, and environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.createApplicationStack({\n    applicationName: 'MyAssociatedApplication',\n    // 'Application containing stacks deployed via CDK.' is the default\n    applicationDescription: 'Associated Application description',\n    stackName: 'MyAssociatedApplicationStack',\n    // AWS Account and Region that are implied by the current CLI configuration is the default\n    env: { account: '123456789012', region: 'us-east-1' },\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing EC2 Queue Processing Service Example\nDESCRIPTION: Example showing how to create an EC2-based queue processing service with VPC, cluster, and SQS queue configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-autoscaling-queue-worker.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(stack, 'Vpc', { maxAzs: 1 });\nconst cluster = new ecs.Cluster(stack, 'EcsCluster', { vpc });\ncluster.addCapacity('DefaultAutoScalingGroup', {\n  instanceType: new ec2.InstanceType('t2.micro')\n});\nconst queue = new sqs.Queue(stack, 'ProcessingQueue', {\n  QueueName: 'EcsEventQueue'\n});\n\nnew QueueProcessingEc2Service(stack, 'QueueProcessingEc2Service', {\n  cluster,\n  image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  desiredTaskCount: 2,\n  maxScalingCapacity: 5,\n  memoryReservationMiB: 512,\n  cpu: 256,\n  queue\n});\n```\n\n----------------------------------------\n\nTITLE: Associating a Key Value Store with a CloudFront Function using AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to associate a previously created CloudFront Key Value Store with a CloudFront Function. The function must use a runtime that supports Key Value Store access (e.g., `cloudfront.FunctionRuntime.JS_2_0` or newer). The association is made by passing the store object to the `keyValueStore` property of the `cloudfront.Function` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = new cloudfront.KeyValueStore(this, 'KeyValueStore');\nnew cloudfront.Function(this, 'Function', {\n  code: cloudfront.FunctionCode.fromInline('function handler(event) { return event.request }'),\n  // Note that JS_2_0 must be used for Key Value Store support\n  runtime: cloudfront.FunctionRuntime.JS_2_0,\n  keyValueStore: store,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an Application Load Balancer Endpoint in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to add an Application Load Balancer (ALB) as an endpoint to an existing Global Accelerator Listener's Endpoint Group using the AWS CDK. It configures the endpoint with a specific weight (128) and enables client IP address preservation. Assumes `listener` (a `globalaccelerator.Listener`) and `alb` (an `elbv2.ApplicationLoadBalancer`) are already defined CDK constructs. Requires the `aws-globalaccelerator`, `aws-elasticloadbalancingv2`, and `aws-globalaccelerator-endpoints` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const alb: elbv2.ApplicationLoadBalancer;\ndeclare const listener: globalaccelerator.Listener;\n\nlistener.addEndpointGroup('Group', {\n  endpoints: [\n    new ga_endpoints.ApplicationLoadBalancerEndpoint(alb, {\n      weight: 128,\n      preserveClientIp: true,\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Static `fromAttributes` Method in AWS CDK TypeScript\nDESCRIPTION: Specifies the recommended signature for a static `fromFooAttributes` method. This method is used when importing a resource requires multiple attributes beyond just ARN or name. It accepts a `scope`, `id`, and an `attrs` object containing the necessary attributes, returning the resource's interface type (`IFoo`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nstatic fromFooAttributes(scope: Construct, id: string, attrs: FooAttributes): IFoo;\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Internet Gateway Route with AWS CDK (TypeScript)\nDESCRIPTION: Shows how to set up an Internet Gateway (`InternetGateway`) for a `VpcV2`, create a `RouteTable` and a `SubnetV2`, and then add a default route (`0.0.0.0/0`) to the `RouteTable` targeting the Internet Gateway using the `Route` construct. This allows outbound internet access for associated subnets. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2` constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {\n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PRIVATE_ISOLATED });\n\nconst igw = new InternetGateway(this, 'IGW', {\n  vpc: myVpc,\n});\nnew Route(this, 'IgwRoute', {\n  routeTable,\n  destination: '0.0.0.0/0',\n  target:  { gateway: igw },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Passkey Sign-In with Hosted Domain Relying Party ID in TypeScript\nDESCRIPTION: This code illustrates configuring passkey (WebAuthn) sign-in for an AWS Cognito User Pool using AWS CDK. It enables both password and passkey authentication via `signInPolicy` and explicitly sets the `passkeyRelyingPartyId` to the hosted Amazon Cognito domain associated with the user pool client.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Use the hosted Amazon Cognito domain as the relying party ID\nnew cognito.UserPool(this, 'myuserpool', {\n  signInPolicy: {\n    allowedFirstAuthFactors: { password: true, passkey: true },\n  },\n  passkeyRelyingPartyId: 'myclientname.auth.region-name.amazoncognito.com',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an AppSync Function with VTL Templates in TypeScript\nDESCRIPTION: This TypeScript CDK code defines an AWS AppSync Function. It associates the function with a GraphQL API, specifies a data source (here, a 'None' data source), and configures VTL (Velocity Template Language) mapping templates for the request and response, loaded from external files.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.GraphqlApi;\n\nconst appsyncFunction = new appsync.AppsyncFunction(this, 'function', {\n  name: 'appsync_function',\n  api,\n  dataSource: api.addNoneDataSource('none'),\n  requestMappingTemplate: appsync.MappingTemplate.fromFile('request.vtl'),\n  responseMappingTemplate: appsync.MappingTemplate.fromFile('response.vtl'),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppRunner Service with ECR Repository\nDESCRIPTION: Creates an AppRunner service using an existing ECR repository as the source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\n\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcr({\n    imageConfiguration: { port: 80 },\n    repository: ecr.Repository.fromRepositoryName(this, 'NginxRepository', 'nginx'),\n    tagOrDigest: 'latest',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Distribution with Multiple Behaviors\nDESCRIPTION: This example demonstrates how to create a CloudFront distribution with multiple behaviors defined at creation time. It sets up a default behavior and an additional behavior for a specific path pattern ('/images/*.jpg').\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a Distribution with additional behaviors at creation time.\ndeclare const myBucket: s3.Bucket;\nconst bucketOrigin = new origins.S3Origin(myBucket);\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,\n    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n  },\n  additionalBehaviors: {\n    '/images/*.jpg': {\n      origin: bucketOrigin,\n      viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Read Permissions for AppConfig Environment Configuration in TypeScript\nDESCRIPTION: Demonstrates how to grant read access to configurations within an AppConfig Environment to an IAM principal (specifically an `iam.User`). It first creates an Application, Environment, and User, then uses the `env.grantReadConfig()` method to attach the necessary permissions to the user. Requires importing the `aws-iam` module. Assumes `this` is a CDK `Construct`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst app = new appconfig.Application(this, 'MyAppConfig');\nconst env = new appconfig.Environment(this, 'MyEnvironment', {\n  application: app,\n});\n\nconst user = new iam.User(this, 'MyUser');\nenv.grantReadConfig(user);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Health Checks for Route53 Records using AWS CDK\nDESCRIPTION: Demonstrates how to configure health checks for Route53 records. It creates a health check for an HTTP endpoint and associates it with an A record. A fallback record is also created for when the health check fails.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nconst healthCheck = new route53.HealthCheck(this, 'HealthCheck', {\n  type: route53.HealthCheckType.HTTP,\n  fqdn: 'example.com',\n  port: 80,\n  resourcePath: '/health',\n  failureThreshold: 3,\n  requestInterval: Duration.seconds(30),\n});\n\nnew route53.ARecord(this, 'ARecord', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4'),\n  healthCheck,\n  weight: 100,\n});\nnew route53.ARecord(this, 'ARecord2', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('5.6.7.8'),\n  weight: 0,\n});\n```\n\n----------------------------------------\n\nTITLE: Running All Unit Tests for a Module - Shell Commands\nDESCRIPTION: These commands navigate to the aws-cdk-lib directory and execute all or a specific module's unit tests using Yarn. Prerequisites include installed dependencies and correct module naming. Outputs are test results for the specified test suites.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_23\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/aws-cdk-lib\n$ yarn test aws-eks\n```\n\n----------------------------------------\n\nTITLE: Configuring Glue Table Storage Parameters in TypeScript\nDESCRIPTION: This snippet illustrates how to configure physical storage properties for an AWS Glue S3 Table using the `storageParameters` property in AWS CDK. It demonstrates setting parameters like skipping header lines (`skipHeaderLineCount`), specifying compression type (`compressionType`), and defining a custom separator character.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  storageParameters: [\n    glue.StorageParameter.skipHeaderLineCount(1),\n    glue.StorageParameter.compressionType(glue.CompressionType.GZIP),\n    glue.StorageParameter.custom('separatorChar', ',')\n  ],\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring EFS Support for S3 Bucket Deployments\nDESCRIPTION: Shows how to attach EFS storage to the underlying Lambda function for S3 bucket deployments that require more disk space than the default 512MB, using the useEfs and vpc properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\ndeclare const vpc: ec2.Vpc;\n\nnew s3deploy.BucketDeployment(this, 'DeployMeWithEfsStorage', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket,\n  destinationKeyPrefix: 'efs/',\n  useEfs: true,\n  vpc,\n  retainOnDelete: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Object Lambda to Handle Range and Part Number Requests\nDESCRIPTION: Example showing how to configure an S3 Object Lambda access point to support GetObject-Range and GetObject-PartNumber requests. This advanced configuration enables Lambda functions to handle requests for specific byte ranges or part numbers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3objectlambda-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as s3objectlambda from '@aws-cdk/aws-s3objectlambda-alpha';\nimport * as cdk from 'aws-cdk-lib';\n\nconst stack = new cdk.Stack();\nconst bucket = new s3.Bucket(stack, 'MyBucket');\nconst handler = new lambda.Function(stack, 'MyFunction', {\n\truntime: lambda.Runtime.NODEJS_LATEST,\n\thandler: 'index.handler',\n\tcode: lambda.Code.fromAsset('lambda.zip'),\n});\nnew s3objectlambda.AccessPoint(stack, 'MyObjectLambda', {\n\tbucket,\n\thandler,\n\taccessPointName: 'my-access-point',\n\tsupportsGetObjectRange: true,\n\tsupportsGetObjectPartNumber: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Duration Values with AWS CDK (TypeScript)\nDESCRIPTION: Shows how to add or subtract Duration instances to perform arithmetic on time intervals for construct parameters. Requires AWS CDK Duration class. Takes two Duration instances as input and produces a Duration representing their sum or difference. Intended for situations where dynamic or computed timeouts/rates are needed in constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nDuration.minutes(1).plus(Duration.seconds(60)); // 2 minutes\nDuration.minutes(5).minus(Duration.seconds(10)); // 290 secondes\n```\n\n----------------------------------------\n\nTITLE: Configuring Backup for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet shows various ways to configure backup settings for an Amazon Data Firehose delivery stream, including backing up all data to a new or existing S3 bucket and specifying a custom prefix for backups.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Enable backup of all source records (to an S3 bucket created by CDK).\ndeclare const bucket: s3.Bucket;\nnew firehose.DeliveryStream(this, 'Delivery Stream Backup All', {\n  destination:\n    new firehose.S3Bucket(bucket, {\n      s3Backup: {\n        mode: firehose.BackupMode.ALL,\n      },\n    }),\n});\n// Explicitly provide an S3 bucket to which all source records will be backed up.\ndeclare const backupBucket: s3.Bucket;\nnew firehose.DeliveryStream(this, 'Delivery Stream Backup All Explicit Bucket', {\n  destination: \n    new firehose.S3Bucket(bucket, {\n      s3Backup: {\n        bucket: backupBucket,\n      },\n    }),\n});\n// Explicitly provide an S3 prefix under which all source records will be backed up.\nnew firehose.DeliveryStream(this, 'Delivery Stream Backup All Explicit Prefix', {\n  destination:\n    new firehose.S3Bucket(bucket, {\n      s3Backup: {\n        mode: firehose.BackupMode.ALL,\n        dataOutputPrefix: 'mybackup',\n      },\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling KMS Key Rotation for Pipeline Artifacts\nDESCRIPTION: Configures a CodePipeline with key rotation enabled for the generated KMS keys. This enhances security but adds an additional $1/month cost.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Enable key rotation for the generated KMS key\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline', {\n  // ...\n  enableKeyRotation: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Ingress Connection for AppRunner Service\nDESCRIPTION: Sets up private access for an AppRunner service using VPC Ingress Connection.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const vpc: ec2.Vpc;\n\nconst interfaceVpcEndpoint = new ec2.InterfaceVpcEndpoint(this, 'MyVpcEndpoint', {\n  vpc,\n  service: ec2.InterfaceVpcEndpointAwsService.APP_RUNNER_REQUESTS,\n  privateDnsEnabled: false,\n});\n\nconst service = new apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: {\n      port: 8000,\n    },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  isPubliclyAccessible: false, // set false\n});\n\nnew apprunner.VpcIngressConnection(this, 'VpcIngressConnection', {\n  vpc,\n  interfaceVpcEndpoint,\n  service,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Rendition Settings for IVS Recording\nDESCRIPTION: Creates a recording configuration with custom rendition settings. This controls which video quality variants are generated during recording.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recordingBucket: s3.Bucket;\n\nconst recordingConfiguration= new ivs.RecordingConfiguration(this, 'RecordingConfiguration', {\n  bucket: recordingBucket,\n\n  // set rendition configuration\n  renditionConfiguration: ivs.RenditionConfiguration.custom([ivs.Resolution.HD, ivs.Resolution.SD]),\n});\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Cache Configuration\nDESCRIPTION: Creates a Docker image asset with cache configuration for optimizing build performance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  cacheFrom: [{ type: 'registry', params: { ref: 'ghcr.io/myorg/myimage:cache' }}],\n  cacheTo: { type: 'registry', params: { ref: 'ghcr.io/myorg/myimage:cache', mode: 'max', compression: 'zstd' }}\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS-based Job Definition in AWS Batch\nDESCRIPTION: Shows how to define an AWS Batch job that runs on Amazon EKS. This example creates an EKS job definition with a container that includes an emptyDir volume mounted with memory medium type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst jobDefn = new batch.EksJobDefinition(this, 'eksf2', {\n  container: new batch.EksContainerDefinition(this, 'container', {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    volumes: [batch.EksVolume.emptyDir({\n      name: 'myEmptyDirVolume',\n      mountPath: '/mount/path',\n      medium: batch.EmptyDirMediumType.MEMORY,\n      readonly: true,\n      sizeLimit: cdk.Size.mebibytes(2048),\n    })],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining IAM Authorization for a Mutation in GraphQL Schema\nDESCRIPTION: This GraphQL schema snippet demonstrates how to restrict access to a specific mutation (`updateExample`) to only requests authorized via AWS IAM. The `@aws_iam` directive is used to enforce this authorization requirement on the field.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_13\n\nLANGUAGE: graphql\nCODE:\n```\ntype Mutation {\n  updateExample(...): ...\n    @aws_iam\n}\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from S3 with Type using AWS CDK in TypeScript\nDESCRIPTION: This example shows how to create an AWS AppConfig `SourcedConfiguration` using a file from an S3 bucket, additionally specifying the configuration type (`FEATURE_FLAGS`), name, and description. It requires an `appconfig.Application` and an `s3.Bucket` instance. The `location` uses `appconfig.ConfigurationSource.fromBucket()` pointing to a specific file path.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const bucket: s3.Bucket;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromBucket(bucket, 'path/to/file.json'),\n  type: appconfig.ConfigurationType.FEATURE_FLAGS,\n  name: 'MyConfig',\n  description: 'This is my sourced configuration from CDK.',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Job Run Queuing in AWS CDK\nDESCRIPTION: Shows how to enable job run queuing for AWS Glue jobs to handle resource limitations and quotas.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkEtlJob(stack, 'PySparkETLJob', {\n  role,\n  script,\n  jobName: 'PySparkETLJob',\n  jobRunQueuingEnabled: true\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTPS Subscription to SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to add an HTTPS (or HTTP) endpoint as a subscription to an SNS topic using AWS CDK. It requires an existing sns.Topic instance and the aws-cdk-lib/aws-sns-subscriptions module. The endpoint URL can be any valid HTTPS/HTTP URL string, and the subscription can begin receiving notifications once created.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\n\nmyTopic.addSubscription(new subscriptions.UrlSubscription('https://foobar.com/'));\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from SSM Document using AWS CDK in TypeScript\nDESCRIPTION: This code demonstrates creating an AWS AppConfig `SourcedConfiguration` where the configuration source is an SSM Document. It depends on an existing `appconfig.Application` and an `ssm.CfnDocument` instance. The source location is specified using `appconfig.ConfigurationSource.fromCfnDocument()`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const document: ssm.CfnDocument;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromCfnDocument(document),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Interactive Debugging for CodeBuild Project via SSM in TypeScript\nDESCRIPTION: This snippet demonstrates configuring an AWS CodeBuild project to allow interactive debugging using SSM Session Manager. It sets `ssmSessionPermissions` to true and includes a `buildSpec` with the `codebuild-breakpoint` command. When this command is encountered during a build started with debugging enabled, the build pauses, allowing an SSM session to be attached for debugging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    buildImage: codebuild.LinuxBuildImage.STANDARD_7_0,\n  },\n  ssmSessionPermissions: true,\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n    phases: {\n      build: {\n        commands: [\n          // Pause the build container if possible\n          'codebuild-breakpoint',\n          // Regular build in a script in the repository\n          './my-build.sh',\n        ],\n      },\n    },\n  }),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Coverage Reports in CodeBuild (TypeScript)\nDESCRIPTION: This snippet demonstrates setting up a code coverage report group in AWS CodeBuild using the AWS CDK. It creates a `ReportGroup` with `type: codebuild.ReportGroupType.CODE_COVERAGE` and then configures the project's `BuildSpec` to use this report group's ARN, specifying the coverage report files, base directory, and file format (e.g., `JACOCOXML`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const source: codebuild.Source;\n\n// create a new ReportGroup\nconst reportGroup = new codebuild.ReportGroup(this, 'ReportGroup', {\n    type: codebuild.ReportGroupType.CODE_COVERAGE\n});\n\nconst project = new codebuild.Project(this, 'Project', {\n  source,\n  buildSpec: codebuild.BuildSpec.fromObject({\n    // ...\n    reports: {\n      [reportGroup.reportGroupArn]: {\n        files: '**/*',\n        'base-directory': 'build/coverage-report.xml',\n        'file-format': 'JACOCOXML'\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AWS App Mesh Mesh with IPv4 Preference in TypeScript\nDESCRIPTION: Instantiates an AWS App Mesh `Mesh` resource named 'myAwsMesh' using the CDK `appmesh.Mesh` construct. This example demonstrates configuring the mesh's service discovery settings by providing the `serviceDiscovery` property, specifically setting the `ipPreference` to `appmesh.IpPreference.IPV4_ONLY`. Assumes `this` refers to a CDK construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst mesh = new appmesh.Mesh(this, 'AppMesh', {\n  meshName: 'myAwsMesh',\n  serviceDiscovery: {\n    ipPreference: appmesh.IpPreference.IPV4_ONLY,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Redshift Cluster with Elastic IP using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a publicly accessible AWS Redshift cluster using AWS CDK and assign a specific Elastic IP address to it. It requires an existing VPC instance (`vpc`) and sets master user credentials. The `publiclyAccessible` property is set to true, and the `elasticIp` property specifies the Elastic IP address to associate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nnew Cluster(this, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n    publiclyAccessible: true,\n    elasticIp: '10.123.123.255', // A elastic ip you own\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Using Managed Origin Request Policy for CloudFront Distribution\nDESCRIPTION: This snippet demonstrates how to use a pre-defined (managed) origin request policy for a CloudFront distribution. It applies the CORS_S3_ORIGIN policy to the default behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Using an existing origin request policy for a Distribution\ndeclare const bucketOrigin: origins.S3Origin;\nnew cloudfront.Distribution(this, 'myDistManagedPolicy', {\n  defaultBehavior: {\n    origin: bucketOrigin,\n    originRequestPolicy: cloudfront.OriginRequestPolicy.CORS_S3_ORIGIN,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Application Load Balancer Origin\nDESCRIPTION: Sets up a private Application Load Balancer in a VPC as a CloudFront origin\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst alb = new elbv2.ApplicationLoadBalancer(this, 'ALB', {\n  vpc,\n  internetFacing: false,\n  vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: origins.VpcOrigin.withApplicationLoadBalancer(alb) },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding AWS Lambda Layer with Proxy-Agent using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import and attach the NodeProxyAgentLayer Lambda layer, which includes the proxy-agent NPM package, to an AWS Lambda function within AWS CDK. The dependencies are 'aws-cdk-lib/lambda-layer-node-proxy-agent' and 'aws-cdk-lib/aws-lambda'. The key parameter is the target Lambda function, with the layer making proxy-agent available under /nodejs/node_modules at runtime. proxy-agent version is 5.0.0. Ensure the Lambda function can access layers and the CDK stack includes the appropriate module imports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/lambda-layer-node-proxy-agent/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NodeProxyAgentLayer } from 'aws-cdk-lib/lambda-layer-node-proxy-agent';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const fn: lambda.Function;\nfn.addLayers(new NodeProxyAgentLayer(this, 'NodeProxyAgentLayer'));\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudWatch Alarm for All EventBridge Schedules with AWS CDK (TypeScript)\nDESCRIPTION: This example demonstrates how to create a CloudWatch alarm that triggers when any EventBridge schedule fails to invoke its target, using the static metricAllErrors method from the Schedule class. It configures the alarm to fire if any error is detected in a single evaluation period. Dependencies: aws-cdk-lib/aws-cloudwatch, aws-cdk-lib/aws-events-scheduler. The metricAllErrors method provides an aggregated metric for error conditions, and inputs are the schedule errors metric; output is the CloudWatch Alarm resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cloudwatch.Alarm(this, 'SchedulesErrorAlarm', {\n    metric: Schedule.metricAllErrors(),\n    threshold: 0,\n    evaluationPeriods: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration with Validators in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration with JSON Schema and Lambda function validators to ensure configuration correctness. Validators help ensure data is syntactically and semantically valid.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\ndeclare const fn: lambda.Function;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n  validators: [\n    appconfig.JsonSchemaValidator.fromFile('schema.json'),\n    appconfig.LambdaValidator.fromFunction(fn),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Capacity Distribution Strategy for AWS CDK Auto Scaling Group\nDESCRIPTION: Configures how an Auto Scaling group handles launch failures across Availability Zones. Options include BALANCED_BEST_EFFORT (default) to try another healthy AZ, or BALANCED_ONLY to maintain distribution by continuing to attempt launches in unhealthy zones.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  azCapacityDistributionStrategy: autoscaling.CapacityDistributionStrategy.BALANCED_ONLY,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling CPU-Based Scaling for QueueProcessingFargateService in aws-cdk ECS Patterns (TypeScript)\nDESCRIPTION: Demonstrates disabling the default CPU-based auto-scaling for QueueProcessingFargateService by setting disableCpuBasedScaling to true. This prevents the construct from adding default CPU-based scaling policies. Other configuration options remain similar to standard deployment. Prerequisites are an ECS cluster and aws-cdk ECS Patterns library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  command: [\"-c\", \"4\", \"amazon.com\"],\n  enableLogging: false,\n  desiredTaskCount: 2,\n  environment: {\n    TEST_ENVIRONMENT_VARIABLE1: \"test environment variable 1 value\",\n    TEST_ENVIRONMENT_VARIABLE2: \"test environment variable 2 value\",\n  },\n  maxScalingCapacity: 5,\n  containerName: 'test',\n  minHealthyPercent: 100,\n  disableCpuBasedScaling: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Identity Pool in TypeScript\nDESCRIPTION: This code creates a basic Identity Pool with minimal configuration, using default authenticated and unauthenticated roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew IdentityPool(this, 'myIdentityPool');\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkEtlJob with Optional Parameters in TypeScript\nDESCRIPTION: Example demonstrating how to create a PySparkEtlJob with optional override parameters such as Glue version, worker type, logging settings, and other job configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkEtlJob(stack, 'PySparkETLJob', {\n  jobName: 'PySparkETLJobCustomName',\n  description: 'This is a description',\n  role,\n  script,\n  glueVersion: glue.GlueVersion.V3_0,\n  continuousLogging: { enabled: false },\n  workerType: glue.WorkerType.G_2X,\n  maxConcurrentRuns: 100,\n  timeout: cdk.Duration.hours(2),\n  connections: [glue.Connection.fromConnectionName(stack, 'Connection', 'connectionName')],\n  securityConfiguration: glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'SecurityConfig', 'securityConfigName'),\n  tags: {\n    FirstTagName: 'FirstTagValue',\n    SecondTagName: 'SecondTagValue',\n    XTagName: 'XTagValue',\n  },\n  numberOfWorkers: 2,\n  maxRetries: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an SNS Action to an SES Receipt Rule - AWS CDK - TypeScript\nDESCRIPTION: This code shows how to add an SNS action to an existing SES receipt rule in AWS CDK, allowing you to publish notifications for incoming emails. Dependencies include 'aws-cdk-lib/aws-ses-actions' and a previously declared ReceiptRule and SNS Topic. The primary parameter is the SNS topic to which notifications are published. The action enables further integration upon email receipt.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as actions from 'aws-cdk-lib/aws-ses-actions';\n\ndeclare const awsRule: ses.ReceiptRule;\ndeclare const topic: sns.Topic;\nawsRule.addAction(new actions.Sns({\n  topic,\n}));\n```\n\n----------------------------------------\n\nTITLE: Invoking AppSync GraphQL API with EventBridge Rule in TypeScript\nDESCRIPTION: This snippet creates an AppSync GraphQL API target that is invoked every hour, calling the 'publish' mutation. It demonstrates how to set up the GraphQL API with IAM authorization and configure the EventBridge rule with the AppSync target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appsync from 'aws-cdk-lib/aws-appsync';\n\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'api',\n  definition: appsync.Definition.fromFile('schema.graphql'),\n  authorizationConfig: {\n    defaultAuthorization: { authorizationType: appsync.AuthorizationType.IAM }\n  },\n});\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(new targets.AppSync(api, {\n  graphQLOperation: 'mutation Publish($message: String!){ publish(message: $message) { message } }',\n  variables: events.RuleTargetInput.fromObject({\n    message: 'hello world',\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Lambda Rotation Schedule to a Secret - AWS CDK TypeScript\nDESCRIPTION: Illustrates scheduling automatic credential rotation on a secret via a user-provided Lambda function, with a configurable rotation window and update logic. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-lambda, aws-cdk-lib. Expects a previously defined Lambda function and secret. Options: rotationLambda (the Lambda), automaticallyAfter (duration between rotations), rotateImmediatelyOnUpdate (trigger on stack updates).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const fn: lambda.Function;\nconst secret = new secretsmanager.Secret(this, 'Secret');\n\nsecret.addRotationSchedule('RotationSchedule', {\n  rotationLambda: fn,\n  automaticallyAfter: Duration.days(15),\n  rotateImmediatelyOnUpdate: false, // default is true\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkStreamingJob with Required Parameters in TypeScript\nDESCRIPTION: Example showing how to create a PySparkStreamingJob with only the required parameters (role and script). This job type is for ETL on data streams using Apache Spark Structured Streaming.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkStreamingJob(stack, 'ImportedJob', { role, script });\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Billing\nDESCRIPTION: Shows how to configure on-demand billing for a DynamoDB table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.onDemand(),\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up S3 Website Endpoint Origin for CloudFront - AWS CDK - TypeScript\nDESCRIPTION: This code sets up a CloudFront origin that points to an S3 bucket configured as a static website using the S3StaticWebsiteOrigin class. The bucket is treated as an HTTP origin, leveraging built-in S3 redirects and custom error pages. Prerequisites: CDK libraries for s3, cloudfront, and the origins module. Parameters: pass in the S3 bucket. Output: CloudFront Distribution configured to use the website endpoint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.S3StaticWebsiteOrigin(myBucket) },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Response Headers to Amplify App in TypeScript\nDESCRIPTION: Configures custom HTTP response headers for specific URL patterns in an Amplify application. This example shows how to add custom headers for JSON files and specific path patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'App', {\n  sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-github-token'),\n  }),\n  customResponseHeaders: [\n    {\n      pattern: '*.json',\n      headers: {\n        'custom-header-name-1': 'custom-header-value-1',\n        'custom-header-name-2': 'custom-header-value-2',\n      },\n    },\n    {\n      pattern: '/path/*',\n      headers: {\n        'custom-header-name-1': 'custom-header-value-2',\n      },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Scheduling Hosted Lambda Rotation for a Secret - AWS CDK TypeScript\nDESCRIPTION: Shows how to enable automatic secret rotation using a pre-built (hosted) Lambda function provided by AWS Secrets Manager, e.g., for MySQL single user. No code or custom Lambda requiredjust choose a supported engine and scheme. Dependencies: aws-cdk-lib/aws-secretsmanager. Expects a Secret instance. Key property: hostedRotation (selects a built-in rotation template for a named database).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst secret = new secretsmanager.Secret(this, 'Secret');\n\nsecret.addRotationSchedule('RotationSchedule', {\n  hostedRotation: secretsmanager.HostedRotation.mysqlSingleUser(),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an EFS Volume to an Existing AWS Batch ECS Job Definition\nDESCRIPTION: Demonstrates how to add a persistent storage volume to an existing ECS container job definition. This approach allows for mounting an Amazon EFS file system to provide persistent storage for batch workloads.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myFileSystem: efs.IFileSystem;\ndeclare const jobDefn: batch.EcsJobDefinition;\n\njobDefn.container.addVolume(batch.EcsVolume.efs({\n  name: 'myVolume',\n  fileSystem: myFileSystem,\n  containerPath: '/Volumes/myVolume',\n}));\n```\n\n----------------------------------------\n\nTITLE: Exporting HTTP Lambda Authorizer ID in AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to create an HTTP Lambda Authorizer in AWS CDK, bind it to an API route, and export its ID and type using CloudFormation outputs. It includes setup for response types, Lambda integration, and demonstrates that 'authorizerId' is available only after route binding. Dependencies: aws-cdk-lib, Lambda, and API Gateway constructs are required. Inputs include the Lambda handler and configuration options, outputs are authorizer ID/type CloudFormation exports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpLambdaAuthorizer, HttpLambdaResponseType } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\nimport { CfnOutput } from 'aws-cdk-lib';\n\n// This function handles your auth logic\ndeclare const authHandler: lambda.Function;\n\nconst authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', authHandler, {\n  responseTypes: [HttpLambdaResponseType.SIMPLE], // Define if returns simple and/or iam response\n});\n\nconst api = new apigwv2.HttpApi(this, 'HttpApi');\n\napi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books',\n  authorizer,\n});\n\n// You can only access authorizerId after it's been bound to a route\n// In this example we expect use CfnOutput\nnew CfnOutput(this, 'authorizerId', { value: authorizer.authorizerId });\nnew CfnOutput(this, 'authorizerType', { value: authorizer.authorizationType });\n```\n\n----------------------------------------\n\nTITLE: Configuring Client-Side KMS Encryption (Explicit Key) for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet demonstrates configuring client-side encryption (CSE-KMS) for an AWS Glue S3 Table using a specific, user-provided AWS KMS key with AWS CDK. It sets `encryption` to `glue.TableEncryption.CLIENT_SIDE_KMS` and supplies an existing `kms.Key` instance via the `encryptionKey` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n// with an explicit KMS key\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.CLIENT_SIDE_KMS,\n  encryptionKey: new kms.Key(this, 'MyKey'),\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty CloudFront Key Value Store using AWS CDK (TypeScript)\nDESCRIPTION: Provides a basic example of creating an empty CloudFront Key Value Store using the `cloudfront.KeyValueStore` construct in AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = new cloudfront.KeyValueStore(this, 'KeyValueStore');\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes Manifests from a URL using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to fetch Kubernetes manifest definitions from a remote URL, parse the YAML content, and apply it to an EKS cluster using `cluster.addManifest`. This requires the `js-yaml` library for parsing and `sync-request` for synchronously fetching the content. An existing `eks.Cluster` instance is needed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n// This example is only available in TypeScript\n\nimport * as yaml from 'js-yaml';\nimport * as request from 'sync-request';\n\ndeclare const cluster: eks.Cluster;\nconst manifestUrl = 'https://url/of/manifest.yaml';\nconst manifest = yaml.safeLoadAll(request('GET', manifestUrl).getBody());\ncluster.addManifest('my-resource', manifest);\n```\n\n----------------------------------------\n\nTITLE: Configuring IAM Authentication for MSK in TypeScript\nDESCRIPTION: This snippet shows how to enable IAM client authentication for an MSK Cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n  encryptionInTransit: {\n    clientBroker: msk.ClientBrokerEncryption.TLS,\n  },\n  clientAuthentication: msk.ClientAuthentication.sasl({\n    iam: true,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a VirtualNode with customized JSON access logging format\nDESCRIPTION: Creates a VirtualNode with customized JSON access logging format. Configures service discovery, HTTP listener with health check, timeout settings, and TLS client policy with file-based certificate validation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\ndeclare const service: cloudmap.Service;\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service),\n  listeners: [appmesh.VirtualNodeListener.http({\n    port: 8080,\n    healthCheck: appmesh.HealthCheck.http({\n      healthyThreshold: 3,\n      interval: cdk.Duration.seconds(5), \n      path: '/ping',\n      timeout: cdk.Duration.seconds(2), \n      unhealthyThreshold: 2,\n    }),\n    timeout: {\n      idle: cdk.Duration.seconds(5),\n    },\n  })],\n  backendDefaults: {\n    tlsClientPolicy: {\n      validation: {\n        trust: appmesh.TlsValidationTrust.file('/keys/local_cert_chain.pem'),\n      },\n    },\n  },\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout',\n    appmesh.LoggingFormat.fromJson(\n      {testKey1: 'testValue1', testKey2: 'testValue2'})),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Parameters to a Redshift Cluster Parameter Group with AWS CDK\nDESCRIPTION: Demonstrates adding parameters to a Redshift `ClusterParameterGroup`. It first creates a new parameter group with an initial parameter (`require_ssl`) and then adds another parameter (`enable_user_activity_logging`) using the `addParameter` method. Requires importing `ClusterParameterGroup` from `@aws-cdk/aws-redshift-alpha`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { ClusterParameterGroup } from '@aws-cdk/aws-redshift-alpha';\n\nconst params = new ClusterParameterGroup(this, 'Params', {\n  description: 'desc',\n  parameters: {\n    require_ssl: 'true',\n  },\n});\n\nparams.addParameter('enable_user_activity_logging', 'true');\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Logging for MSK in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure an MSK Cluster to send logs to an S3 bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const bucket: s3.IBucket;\nconst cluster = new msk.Cluster(this, 'cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n  logging: {\n    s3: {\n      bucket,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Scheduling ECS Fargate Task Run with EventBridge Scheduler in AWS CDK\nDESCRIPTION: Creates an EventBridge Scheduler that runs a Fargate task in an ECS cluster every 60 minutes. The schedule uses a rate expression to define the frequency and targets a specific task definition within the provided cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.FargateTaskDefinition;\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(cdk.Duration.minutes(60)),\n  target: new targets.EcsRunFargateTask(cluster, {\n    taskDefinition,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding gRPC Gateway Route in AWS App Mesh with CDK\nDESCRIPTION: Shows how to add a gRPC-based gateway route to a virtual gateway in AWS App Mesh. The route matches traffic based on hostname and routes it to a virtual service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gateway: appmesh.VirtualGateway;\ndeclare const virtualService: appmesh.VirtualService;\n\ngateway.addGatewayRoute('gateway-route-grpc', {\n  routeSpec: appmesh.GatewayRouteSpec.grpc({\n    routeTarget: virtualService,\n    match: {\n      hostname: appmesh.GatewayRouteHostnameMatch.endsWith('.example.com'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Common Stage Settings (Throttling, Metrics) in TypeScript (CDK)\nDESCRIPTION: This snippet shows how to configure common settings for an API stage, such as throttling limits (rate and burst) and enabling detailed CloudWatch metrics. Although the example uses `HttpStage` and `HttpApi`, these configuration options (`throttle`, `detailedMetricsEnabled`) are applicable to `WebSocketStage` as well.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const api: apigwv2.HttpApi;\n\nnew apigwv2.HttpStage(this, 'Stage', {\n  httpApi: api,\n  throttle: {\n    rateLimit: 1000,\n    burstLimit: 1000,\n  },\n  detailedMetricsEnabled: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing an Included Resource in Other CDK Constructs (TypeScript)\nDESCRIPTION: Shows how to use attributes (like `.attrArn`) of a resource retrieved from an included template when defining other CDK constructs, such as granting permissions in an IAM Role policy statement.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\n\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.AnyPrincipal(),\n});\nrole.addToPolicy(new iam.PolicyStatement({\n  actions: ['s3:*'],\n  resources: [cfnBucket.attrArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Setting Advanced Options for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet illustrates how to configure advanced options for an OpenSearch domain using the `advancedOptions` property. It sets specific cluster settings like `rest.action.multi.allow_explicit_index`, `indices.fielddata.cache.size`, and `indices.query.bool.max_clause_count`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  advancedOptions: {\n    'rest.action.multi.allow_explicit_index': 'false',\n    'indices.fielddata.cache.size': '25',\n    'indices.query.bool.max_clause_count': '2048',\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Docker Image Asset from Dockerfile in TypeScript\nDESCRIPTION: Creates a Docker image asset from a local directory containing a Dockerfile. Supports optional build arguments and invalidation configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n\n  // Optional: describe the purpose of the asset with a human-readable string\n  displayName: 'Source for my function',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Load Balanced Fargate Service in AWS CDK\nDESCRIPTION: Creates an ECS service on Fargate behind a Network Load Balancer. Configures CPU and memory limits.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.NetworkLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring IAM Certificates in CloudFront Distribution\nDESCRIPTION: Demonstrates how to configure IAM certificates in CloudFront distributions using both the legacy API and escape hatches in the modern API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\nconst viewerCertificate = cloudfront.ViewerCertificate.fromIamCertificate('MYIAMROLEIDENTIFIER', {\n  aliases: ['MYALIAS'],\n});\n\nnew cloudfront.CloudFrontWebDistribution(this, 'MyCfWebDistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n      },\n      behaviors : [ {isDefaultBehavior: true} ],\n    },\n  ],\n  viewerCertificate: viewerCertificate,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\nconst distribution = new cloudfront.Distribution(this, 'MyCfWebDistribution', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(sourceBucket),\n  },\n  domainNames: ['MYALIAS'],\n});\n\nconst cfnDistribution = distribution.node.defaultChild as cloudfront.CfnDistribution;\n\ncfnDistribution.addPropertyOverride('ViewerCertificate.IamCertificateId', 'MYIAMROLEIDENTIFIER');\ncfnDistribution.addPropertyOverride('ViewerCertificate.SslSupportMethod', 'sni-only');\n```\n\n----------------------------------------\n\nTITLE: Granting Write Permissions to IoT Events Input\nDESCRIPTION: This snippet shows how to grant IAM permissions for writing to an AWS IoT Events input. It demonstrates how to use an existing input by name and grant write access to an IAM principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\n\ndeclare const grantable: iam.IGrantable;\nconst input = iotevents.Input.fromInputName(this, 'MyInput', 'my_input');\n\ninput.grantWrite(grantable);\n```\n\n----------------------------------------\n\nTITLE: Adding a WebSocket Route That Returns a Response in TypeScript (CDK)\nDESCRIPTION: This snippet shows how to configure a custom WebSocket route ('sendmessage') to allow the backend integration (a Lambda function) to return a response directly to the calling client. This is achieved by setting the `returnResponse` property to `true` in the `addRoute` options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const messageHandler: lambda.Function;\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nwebSocketApi.addRoute('sendmessage', {\n  integration: new WebSocketLambdaIntegration('SendMessageIntegration', messageHandler),\n  returnResponse: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Subscription Filter for CloudWatch Logs in TypeScript\nDESCRIPTION: Creates a Subscription Filter that sends log events matching a pattern ('ERROR' and 'MainThread') to a Lambda function destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as destinations from 'aws-cdk-lib/aws-logs-destinations';\n\ndeclare const fn: lambda.Function;\ndeclare const logGroup: logs.LogGroup;\n\nnew logs.SubscriptionFilter(this, 'Subscription', {\n  logGroup,\n  destination: new destinations.LambdaDestination(fn),\n  filterPattern: logs.FilterPattern.allTerms(\"ERROR\", \"MainThread\"),\n  filterName: 'ErrorInMainThread',\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Specified Instance Types and Classes for EC2 Compute Environment in AWS Batch (TypeScript)\nDESCRIPTION: This snippet demonstrates how to set up an AWS Batch managed EC2 compute environment that uses both specific instance types and the 'optimal' class for dynamic allocation. It provides two equivalent ways: initializing via constructor or incrementally via method calls post-creation. Requires '@aws-cdk/aws-batch', '@aws-cdk/aws-ec2', and a VPC. Beware of architectural constraintsavoid mixing incompatible architectures in instance types and classes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nconst computeEnv = new batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.M5AD, ec2.InstanceSize.LARGE)],\n  useOptimalInstanceClasses: true, // default\n  vpc,\n});\n// Note: this is equivalent to specifying\ncomputeEnv.addInstanceType(ec2.InstanceType.of(ec2.InstanceClass.M5AD, ec2.InstanceSize.LARGE));\ncomputeEnv.addInstanceClass(ec2.InstanceClass.C4);\ncomputeEnv.addInstanceClass(ec2.InstanceClass.M4);\ncomputeEnv.addInstanceClass(ec2.InstanceClass.R4);\n```\n\n----------------------------------------\n\nTITLE: Creating an OpenSearch/Elasticsearch Domain within a VPC using AWS CDK\nDESCRIPTION: This snippet demonstrates how to provision an `es.Domain` within an existing Amazon VPC using AWS CDK. It specifies the VPC, enables zone awareness (required for multi-AZ VPC deployments), sets data node capacity (considering the default of 2 AZs), and defines a removal policy. This setup allows secure communication between the domain and other VPC resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst vpc = new ec2.Vpc(this, 'Vpc');\nconst domainProps: es.DomainProps = {\n  version: es.ElasticsearchVersion.V7_1,\n  removalPolicy: RemovalPolicy.DESTROY,\n  vpc,\n  // must be enabled since our VPC contains multiple private subnets.\n  zoneAwareness: {\n    enabled: true,\n  },\n  capacity: {\n    // must be an even number since the default az count is 2.\n    dataNodes: 2,\n  },\n};\nnew es.Domain(this, 'Domain', domainProps);\n```\n```\n\n----------------------------------------\n\nTITLE: Mapping email_verified Attribute from Identity Provider using AWS CDK - TypeScript\nDESCRIPTION: This example shows how to map the email_verified attribute from a third-party identity provider (here, Google) into a Cognito user pool using CDK. Dependencies are aws-cdk-lib/cognito and a Google identity provider. Required parameters are provider attribute mapping and Google client ID. Inputs are attribute maps; output is a configured identity provider added to the user pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'Pool');\n\nnew cognito.UserPoolIdentityProviderGoogle(this, 'google', {\n  userPool: userpool,\n  clientId: 'google-client-id',\n  attributeMapping: {\n    email: cognito.ProviderAttribute.GOOGLE_EMAIL,\n    emailVerified: cognito.ProviderAttribute.GOOGLE_EMAIL_VERIFIED, // you can mapping the `email_verified` attribute.\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Parameter Mapping for ALB Integration\nDESCRIPTION: Demonstrates how to modify request parameters before they reach backend integrations. Creates a new header and removes an existing one using parameter mapping with Application Load Balancer integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpAlbIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const lb: elbv2.ApplicationLoadBalancer;\nconst listener = lb.addListener('listener', { port: 80 });\nlistener.addTargets('target', {\n  port: 80,\n});\n\nconst httpEndpoint = new apigwv2.HttpApi(this, 'HttpProxyPrivateApi', {\n  defaultIntegration: new HttpAlbIntegration('DefaultIntegration', listener, {\n    parameterMapping: new apigwv2.ParameterMapping()\n      .appendHeader('header2', apigwv2.MappingValue.requestHeader('header1'))\n      .removeHeader('header1'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging on Firehose Delivery Streams with Custom Log Group (TypeScript)\nDESCRIPTION: This example demonstrates enabling CloudWatch log delivery by specifying a custom LogGroup when constructing an S3Bucket destination for a Firehose delivery stream. Dependencies: aws-cdk-lib/aws-logs, @aws-cdk/aws-s3, @aws-cdk/aws-kinesisfirehose. Inputs: custom log group, S3 bucket. Outputs: Firehose delivery with logging directed to the provided LogGroup. Use EnableLogging to control log destination. The snippet presumes prior instantiation of required constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst logGroup = new logs.LogGroup(this, 'Log Group');\ndeclare const bucket: s3.Bucket;\nconst destination = new firehose.S3Bucket(bucket, {\n  loggingConfig: new firehose.EnableLogging(logGroup),\n});\n\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Individual Replicas to an Existing Neptune Cluster\nDESCRIPTION: Demonstrates how to add a new read replica instance to an existing Neptune database cluster using DatabaseInstance construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst replica1 = new neptune.DatabaseInstance(this, 'Instance', {\n  cluster,\n  instanceType: neptune.InstanceType.R5_LARGE,\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM permissions to a GeofenceCollection\nDESCRIPTION: Demonstrates how to grant read permissions to an IAM role for a GeofenceCollection. This allows the role to perform read operations on the geofence collection resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\n\nconst geofenceCollection = new location.GeofenceCollection(this, 'GeofenceCollection', {\n  geofenceCollectionName: 'MyGeofenceCollection',\n});\n\ngeofenceCollection.grantRead(role);\n```\n\n----------------------------------------\n\nTITLE: Using CodeCommit Source Action Variables in CodeBuild Action\nDESCRIPTION: This snippet shows how to use variables emitted by the CodeCommit source action in a subsequent CodeBuild action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const project: codebuild.PipelineProject;\ndeclare const repo: codecommit.Repository;\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository: repo,\n  output: sourceOutput,\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\n\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    COMMIT_ID: {\n      value: sourceAction.variables.commitId,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon Identity Provider for Cognito User Pool in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure 'Login with Amazon' as an identity provider for a Cognito User Pool, including setting up credentials.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'Pool');\n\nconst provider = new cognito.UserPoolIdentityProviderAmazon(this, 'Amazon', {\n  clientId: 'amzn-client-id',\n  clientSecret: 'amzn-client-secret',\n  userPool: userpool,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Server Side Token Check for User Pool Authentication in TypeScript\nDESCRIPTION: This snippet shows how to disable the server-side token check when adding a User Pool authentication provider to an Identity Pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const identityPool: IdentityPool;\nconst userPool = new cognito.UserPool(this, 'Pool');\nidentityPool.addUserPoolAuthentication(new UserPoolAuthenticationProvider({ \n  userPool,\n  disableServerSideTokenCheck: true, \n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Active Tracing for SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: Example showing how to create an SNS topic with active tracing configuration that enables X-Ray segment data vending when the sampled flag in the tracing header is true. This allows for better observability and monitoring of the message flow.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'MyTopic', {\n  tracingConfig: sns.TracingConfig.ACTIVE,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding to an EFS Resource Policy after Creation in TypeScript\nDESCRIPTION: Appends an IAM policy statement to the resource policy of an existing EFS file system construct. This uses the `addToResourcePolicy` method on the `FileSystem` object. Note that this method cannot be used on file systems imported via `fromFileSystemAttributes`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\ndeclare const statement: iam.PolicyStatement;\nconst fileSystem = new efs.FileSystem(this, 'MyEfsFileSystem', {\n  vpc: new ec2.Vpc(this, 'VPC'),\n});\n\nfileSystem.addToResourcePolicy(statement);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Step Scaling Steps for Auto Scaling\nDESCRIPTION: This plaintext diagram illustrates a possible step scaling configuration based on worker utilization percentage. It shows how capacity adjustments (+/- instances) correspond to different ranges of the metric's value.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n Scaling        -1          (no change)          +1       +3\n                                                           \n            \n                                                           \nWorker use  0%      10%                     50%       70%     100%\n```\n\n----------------------------------------\n\nTITLE: Using Customer Managed KMS Key for EventBus Encryption\nDESCRIPTION: Shows how to configure an EventBus to use a customer managed KMS key for encryption at rest. This requires importing the KMS module and providing an existing KMS key to the EventBus constructor.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\ndeclare const kmsKey: kms.IKey;\n\nnew events.EventBus(this, 'Bus', {\n  kmsKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic IVS Channel in TypeScript\nDESCRIPTION: Creates a basic Amazon IVS channel using the AWS CDK. This is the simplest form of channel creation without specifying additional options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myChannel = new ivs.Channel(this, 'Channel');\n```\n\n----------------------------------------\n\nTITLE: Retrieving Default CloudFront Distribution Metrics in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a CloudFront distribution and retrieve its default metrics such as requests, bytes uploaded/downloaded, and error rates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst dist = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n});\n\n// Retrieving default distribution metrics\nconst requestsMetric = dist.metricRequests();\nconst bytesUploadedMetric = dist.metricBytesUploaded();\nconst bytesDownloadedMetric = dist.metricBytesDownloaded();\nconst totalErrorRateMetric = dist.metricTotalErrorRate();\nconst http4xxErrorRateMetric = dist.metric4xxErrorRate();\nconst http5xxErrorRateMetric = dist.metric5xxErrorRate();\n```\n\n----------------------------------------\n\nTITLE: Configuring Zipped File Deployment in AWS CDK\nDESCRIPTION: This snippet demonstrates how to keep files zipped when deploying to an S3 bucket using AWS CDK. It uses the 'extract: false' option to prevent file extraction and shows how to reference the deployed object keys.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\ndeclare const destinationBucket: s3.Bucket;\n\nconst myBucketDeployment = new s3deploy.BucketDeployment(this, 'DeployMeWithoutExtractingFilesOnDestination', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket,\n  extract: false,\n});\n\nnew cdk.CfnOutput(this, 'ObjectKey', {\n  value: cdk.Fn.select(0, myBucketDeployment.objectKeys),\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Report Group Permissions in CodeBuild Project (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create an AWS CodeBuild project using the AWS CDK while opting out of the default behavior that grants the project's role permissions to create and use report groups. This is achieved by setting the `grantReportGroupPermissions` property to `false`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const source: codebuild.Source;\n\nconst project = new codebuild.Project(this, 'Project', {\n  source,\n  grantReportGroupPermissions: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing EFS Access Point with AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to import a pre-existing EFS Access Point into an AWS CDK application using the static method `efs.AccessPoint.fromAccessPointAttributes`. It requires the Access Point ID and information about the associated File System (including its ID and Security Group), which might also need to be imported. Note that the mount targets for the EFS file system must be in the 'available' state before deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nefs.AccessPoint.fromAccessPointAttributes(this, 'ap', {\n  accessPointId: 'fsap-1293c4d9832fo0912',\n  fileSystem: efs.FileSystem.fromFileSystemAttributes(this, 'efs', {\n    fileSystemId: 'fs-099d3e2f',\n    securityGroup: ec2.SecurityGroup.fromSecurityGroupId(this, 'sg', 'sg-51530134'),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Access Logging\nDESCRIPTION: Sets up access logging to CloudWatch Logs with various log formats including CLF and custom formats.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\ndeclare const api: apigwv2.HttpApi;\ndeclare const logGroup: logs.LogGroup;\n\nconst stage = new apigwv2.HttpStage(this, 'Stage', {\n  httpApi: api,\n  accessLogSettings: {\n    destination: new apigwv2.LogGroupLogDestination(logGroup),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Root Certificate Authority with CfnCertificateAuthority in AWS CDK (TypeScript)\nDESCRIPTION: This snippet uses the low-level CfnCertificateAuthority construct to define a root Certificate Authority in AWS using AWS CDK. It requires the aws-cdk-lib/aws-acmpca package and relevant context variables (this). Major properties such as type, keyAlgorithm, signingAlgorithm, and subject information must be supplied. The output is a resource provisioned in the resulting CloudFormation stack, with props specifying AWS ACM PCA configuration details.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-acmpca/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst cfnCertificateAuthority = new acmpca.CfnCertificateAuthority(this, 'CA', {\n  type: 'ROOT',\n  keyAlgorithm: 'RSA_2048',\n  signingAlgorithm: 'SHA256WITHRSA',\n  subject: {\n    country: 'US',\n    organization: 'string',\n    organizationalUnit: 'string',\n    distinguishedNameQualifier: 'string',\n    state: 'string',\n    commonName: '123',\n    serialNumber: 'string',\n    locality: 'string',\n    title: 'string',\n    surname: 'string',\n    givenName: 'string',\n    initials: 'DG',\n    pseudonym: 'string',\n    generationQualifier: 'DBG',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing OpenSearch/Elasticsearch Domain Metrics using AWS CDK\nDESCRIPTION: Illustrates how to obtain CloudWatch Metric objects associated with an `es.Domain` construct using AWS CDK helper methods. `domain.metricFreeStorageSpace()` provides a pre-defined metric, while `domain.metric('MetricName')` allows accessing other available metrics by their name (e.g., 'MasterSysMemoryUtilization'). These objects can be used to create CloudWatch Alarms.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const domain: es.Domain;\nconst freeStorageSpace = domain.metricFreeStorageSpace();\nconst masterSysMemoryUtilization = domain.metric('MasterSysMemoryUtilization');\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Typed SSM StringList Parameters - AWS CDK - TypeScript\nDESCRIPTION: This snippet retrieves a typed list value from an SSM StringList parameter using 'valueForTypedListParameter' in AWS CDK. It validates the list contents and types against an AWS-specific parameter type, particularly useful for resources like AMI lists. Required dependencies include the AWS CDK ssm module and ParameterValueType. Main inputs are the scope, parameter name, and AWS type; output is a list of the parameter's values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssm/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nssm.StringListParameter.valueForTypedListParameter(this, '/My/Public/Parameter', ssm.ParameterValueType.AWS_EC2_IMAGE_ID);\n```\n\n----------------------------------------\n\nTITLE: Enabling Autoscaling for a SageMaker Endpoint with TypeScript\nDESCRIPTION: This snippet demonstrates how to enable autoscaling for a SageMaker endpoint production variant using the CDK. It shows how to set the maximum capacity and scale based on invocations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const model: sagemaker.Model;\n\nconst variantName = 'my-variant';\nconst endpointConfig = new sagemaker.EndpointConfig(this, 'EndpointConfig', {\n  instanceProductionVariants: [\n    {\n      model: model,\n      variantName: variantName,\n    },\n  ]\n});\n\nconst endpoint = new sagemaker.Endpoint(this, 'Endpoint', { endpointConfig });\nconst productionVariant = endpoint.findInstanceProductionVariant(variantName);\nconst instanceCount = productionVariant.autoScaleInstanceCount({\n  maxCapacity: 3\n});\ninstanceCount.scaleOnInvocations('LimitRPS', {\n  maxRequestsPerSecond: 30,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing ACM Certificate by ARN - AWS CDK - TypeScript\nDESCRIPTION: This snippet imports an existing ACM certificate using its ARN in AWS CDK. The certificate resource can then be used in other constructs and stacks. Input: ACM certificate ARN. Output: Certificate object reference. Dependency: aws-cdk-lib/aws-certificatemanager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst arn = 'arn:aws:...';\nconst certificate = acm.Certificate.fromCertificateArn(this, 'Certificate', arn);\n```\n\n----------------------------------------\n\nTITLE: Creating a SageMaker Endpoint with TypeScript\nDESCRIPTION: This snippet shows how to create a SageMaker endpoint using an endpoint configuration with the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const endpointConfig: sagemaker.EndpointConfig;\n\nconst endpoint = new sagemaker.Endpoint(this, 'Endpoint', { endpointConfig });\n```\n\n----------------------------------------\n\nTITLE: Creating DynamoDB Global Tables in TypeScript\nDESCRIPTION: This example shows how to create a DynamoDB Global Table by specifying replication regions and configuring auto-scaling for write capacity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst globalTable = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  replicationRegions: ['us-east-1', 'us-east-2', 'us-west-2'],\n  billingMode: dynamodb.BillingMode.PROVISIONED,\n});\n\nglobalTable.autoScaleWriteCapacity({\n  minCapacity: 1,\n  maxCapacity: 10,\n}).scaleOnUtilization({ targetUtilizationPercent: 75 });\n```\n\n----------------------------------------\n\nTITLE: Creating KMS Key with Custom Pending Deletion Window Using AWS CDK in TypeScript\nDESCRIPTION: Defines a KMS key with a specified pending deletion waiting period using the 'pendingWindow' property. This property determines the number of days before AWS KMS deletes a customer master key (CMK) after it is scheduled for deletion. This example uses a 10-day window, overriding the default of 30 days. Requires 'aws-cdk-lib/aws-kms' and access to the Duration utility.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey', {\n  pendingWindow: Duration.days(10), // Default to 30 Days\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Glue External Table with a Connection in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS Glue `ExternalTable` using AWS CDK. Unlike `S3Table`, this table points to data residing in an external source (e.g., a Redshift table specified by `externalDataLocation`) accessible via a defined Glue Connection (`myConnection`). It requires existing `glue.Connection` and `glue.Database` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myConnection: glue.Connection;\ndeclare const myDatabase: glue.Database;\nnew glue.ExternalTable(this, 'MyTable', {\n  connection: myConnection,\n  externalDataLocation: 'default_db_public_example', // A table in Redshift\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Cross-Region Resources with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure two AWS CDK stacks in different regions and enable cross-region references to share resources such as an ACM certificate for a CloudFront distribution. Requires the 'crossRegionReferences' property set to true in each stack. Uses constructs from aws-cdk-lib such as acm.Certificate, route53.PublicHostedZone, cloudfront.Distribution, and origins.HttpOrigin. Prerequisites include the AWS CDK library and access to the relevant AWS resources. Inputs include configuration for stack environments, certificate, and domain properties; output is an enabled distribution with a cross-region certificate reference. Note: Custom resources and SSM parameters are used under the hood, subject to response body and parameter name length constraints.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst stack1 = new Stack(app, 'Stack1', {\n  env: {\n    region: 'us-east-1',\n  },\n  crossRegionReferences: true,\n});\nconst cert = new acm.Certificate(stack1, 'Cert', {\n  domainName: '*.example.com',\n  validation: acm.CertificateValidation.fromDns(route53.PublicHostedZone.fromHostedZoneId(stack1, 'Zone', 'Z0329774B51CGXTDQV3X')),\n});\n\nconst stack2 = new Stack(app, 'Stack2', {\n  env: {\n    region: 'us-east-2',\n  },\n  crossRegionReferences: true,\n});\nnew cloudfront.Distribution(stack2, 'Distribution', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('example.com'),\n  },\n  domainNames: ['dev.example.com'],\n  certificate: cert,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Policy Config Rule in TypeScript\nDESCRIPTION: Shows how to create a custom Config rule using a Guard policy. The rule checks if point-in-time recovery is enabled on active Amazon DynamoDB tables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst samplePolicyText = `\n# This rule checks if point in time recovery (PITR) is enabled on active Amazon DynamoDB tables\nlet status = ['ACTIVE']\n\nrule tableisactive when\n    resourceType == \"AWS::DynamoDB::Table\" {\n    configuration.tableStatus == %status\n}\n\nrule checkcompliance when\n    resourceType == \"AWS::DynamoDB::Table\"\n    tableisactive {\n        let pitr = supplementaryConfiguration.ContinuousBackupsDescription.pointInTimeRecoveryDescription.pointInTimeRecoveryStatus\n        %pitr == \"ENABLED\"\n}\n`;\n\nnew config.CustomPolicy(this, \"Custom\", {\n  policyText: samplePolicyText,\n  enableDebugLog: true,\n  ruleScope: config.RuleScope.fromResources([\n    config.ResourceType.DYNAMODB_TABLE,\n  ]),\n});\n```\n\n----------------------------------------\n\nTITLE: Using a predefined EC2 Deployment Configuration in TypeScript\nDESCRIPTION: Creates a Deployment Group with a predefined deployment configuration that determines how instances are deployed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentGroup = new codedeploy.ServerDeploymentGroup(this, 'CodeDeployDeploymentGroup', {\n  deploymentConfig: codedeploy.ServerDeploymentConfig.ALL_AT_ONCE,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Cognito User Pool Domains using AWS CDK - TypeScript\nDESCRIPTION: This brief snippet demonstrates importing an existing Cognito user pool domain into a CDK app with the UserPoolDomain.fromDomainName method. The only required input is the existing domain name; this allows attaching further configuration or referencing domain properties in other CDK resources. Outputs an imported UserPoolDomain object for continued use.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nconst myUserPoolDomain = cognito.UserPoolDomain.fromDomainName(this, 'my-user-pool-domain', 'domain-name');\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Origin from Lambda Function URL (No Auth) using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to create a Lambda Function URL with no authentication (`authType: lambda.FunctionUrlAuthType.NONE`) and configure it as an origin for a CloudFront distribution using `origins.FunctionUrlOrigin`. This allows direct invocation of the Lambda function via CloudFront. Requires `aws-cdk-lib/aws-lambda`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const fn: lambda.Function;\nconst fnUrl = fn.addFunctionUrl({ authType: lambda.FunctionUrlAuthType.NONE });\n\nnew cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: new origins.FunctionUrlOrigin(fnUrl) },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring FSx for Lustre with Drive Cache for Performance in AWS CDK\nDESCRIPTION: Improves performance of frequently accessed files by enabling a read drive cache that caches up to 20% of the total storage capacity. This configuration uses HDD storage with PERSISTENT_1 deployment type and specifies READ as the drive cache type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst fileSystem = new fsx.LustreFileSystem(this, 'FsxLustreFileSystem', {\n  lustreConfiguration: {\n    deploymentType: fsx.LustreDeploymentType.PERSISTENT_1,\n    driveCacheType: fsx.DriveCacheType.READ,\n    },\n  storageCapacityGiB: 1200,\n  vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n  storageType: fsx.StorageType.HDD,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Contributor Insights with Table in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable Contributor Insights for a table and a specific global secondary index using the Table construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  contributorInsightsEnabled: true, // for a table\n});\n\ntable.addGlobalSecondaryIndex({\n  contributorInsightsEnabled: true, // for a specific global secondary index\n  indexName: 'gsi',\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Customized Warm Pool to an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet shows how to add and configure a warm pool for an AWS Auto Scaling Group using the AWS CDK. It calls the `addWarmPool()` method on an `AutoScalingGroup` instance, passing an options object to set `minSize` to 1 and enable `reuseOnScaleIn`. A dependency is a pre-declared `autoScalingGroup` variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.addWarmPool({\n  minSize: 1,\n  reuseOnScaleIn: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Input Transformation when Sending to SQS in AWS Pipe (TypeScript)\nDESCRIPTION: This snippet applies an inputTransformation to modify the event payload before sending it to an SQS queue target using AWS Pipe in AWS CDK (TypeScript). It demonstrates creating a dynamic input based on the event body and passing it as a transformed key-value object. Dependencies include AWS CDK for Pipes and SQS. The approach lets developers extract and reshape message content before delivery to the target SQS queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeTarget = new targets.SqsTarget(targetQueue,\n    {\n      inputTransformation: pipes.InputTransformation.fromObject( \n        { \n            \"SomeKey\": pipes.DynamicInput.fromEventPath('$.body')\n        })\n    }\n);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Constructs from CloudFormation Templates\nDESCRIPTION: Shows how to vend CloudFormation templates as reusable CDK Constructs. By setting preserveLogicalIds to false, the logical IDs are renamed using CDK's algorithm to ensure uniqueness.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Construct } from 'constructs';\nimport * as cfn_inc from 'aws-cdk-lib/cloudformation-include';\nimport * as path from 'path';\n\nexport class MyConstruct extends Construct {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    // include a template inside the Construct\n    new cfn_inc.CfnInclude(this, 'MyConstruct', {\n      templateFile: path.join(__dirname, 'my-template.json'),\n      preserveLogicalIds: false, // <--- !!!\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing AGA Security Group for ALB Connections in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to manage security group rules when using client IP preservation with Global Accelerator and an Application Load Balancer (ALB) in AWS CDK. It adds an ALB endpoint with `preserveClientIp: true`, then uses the `endpointGroup.connectionsPeer()` method (a CDK helper) to get a reference to the AGA-managed security group within the specified VPC. Finally, it configures the ALB's connections to allow incoming traffic on TCP port 443 specifically from this AGA security group. Assumes `listener`, `alb`, and `vpc` are pre-defined CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const listener: globalaccelerator.Listener;\n\n// Non-open ALB\ndeclare const alb: elbv2.ApplicationLoadBalancer;\n\nconst endpointGroup = listener.addEndpointGroup('Group', {\n  endpoints: [\n    new ga_endpoints.ApplicationLoadBalancerEndpoint(alb, {\n      preserveClientIp: true,\n    }),\n  ],\n});\n\n// Remember that there is only one AGA security group per VPC.\ndeclare const vpc: ec2.Vpc;\nconst agaSg = endpointGroup.connectionsPeer('GlobalAcceleratorSG', vpc);\n\n// Allow connections from the AGA to the ALB\nalb.connections.allowFrom(agaSg, ec2.Port.tcp(443));\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Dead-Letter Queue Source Permissions in TypeScript\nDESCRIPTION: Demonstrates controlling which queues can designate the created queue as their dead-letter queue (DLQ) using the `redriveAllowPolicy` attribute. Examples show allowing only specific `sourceQueues` or denying all queues via `redrivePermission: sqs.RedrivePermission.DENY_ALL`. Assumes `sourceQueue` is a pre-defined `sqs.IQueue` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.IQueue;\n\n// Only the sourceQueue can specify this queue as the dead-letter queue.\nconst queue1 = new sqs.Queue(this, 'Queue2', {\n  redriveAllowPolicy: {\n    sourceQueues: [sourceQueue],\n  }\n});\n\n// No source queues can specify this queue as the dead-letter queue.\nconst queue2 = new sqs.Queue(this, 'Queue', {\n  redriveAllowPolicy: {\n    redrivePermission: sqs.RedrivePermission.DENY_ALL,\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an S3 Table Bucket in TypeScript with AWS CDK\nDESCRIPTION: This snippet demonstrates how to create an S3 Table Bucket using the AWS CDK. It includes optional configuration for unreferenced file removal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3tables-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Build a Table bucket\nconst sampleTableBucket = new TableBucket(scope, 'ExampleTableBucket', {\n    tableBucketName: 'example-bucket-1',\n    // optional fields:\n    unreferencedFileRemoval: {\n        status: UnreferencedFileRemovalStatus.ENABLED,\n        noncurrentDays: 20,\n        unreferencedDays: 20,\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTP2 Route with Retry Policy - AWS App Mesh - TypeScript\nDESCRIPTION: This snippet shows how to configure an HTTP2 route with a retry policy on an App Mesh virtual router. The retryPolicy specifies the types of retry events (TCP and HTTP errors), the number of retries, and the timeout per attempt. Requires AWS CDK, App Mesh library, and predefined router/node objects. Inputs include weighted targets, retry event arrays, retryAttempts, and retryTimeout. Output is a resilient HTTP2 route capable of retrying on certain failures. The code is limited to a retry logic as specified (e.g., five attempts, 1-second timeout).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-http2-retry', {\n  routeSpec: appmesh.RouteSpec.http2({\n    weightedTargets: [{ virtualNode: node }],\n    retryPolicy: {\n      // Retry if the connection failed\n      tcpRetryEvents: [appmesh.TcpRetryEvent.CONNECTION_ERROR],\n      // Retry if HTTP responds with a gateway error (502, 503, 504)\n      httpRetryEvents: [appmesh.HttpRetryEvent.GATEWAY_ERROR],\n      // Retry five times\n      retryAttempts: 5,\n      // Use a 1 second timeout per retry\n      retryTimeout: Duration.seconds(1),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Generating a Client Secret for Cognito App Client (TypeScript)\nDESCRIPTION: This snippet shows how to configure a Cognito User Pool Client to automatically generate a client secret using AWS CDK. By setting `generateSecret: true`, a secret is created, which can then be accessed via the `userPoolClientSecret` property for use in other parts of the infrastructure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const importedPool: cognito.UserPool;\n\nconst userPoolClient = new cognito.UserPoolClient(this, 'UserPoolClient', {\n  userPool: importedPool,\n  generateSecret: true,\n});\n\n// Allows you to pass the generated secret to other pieces of infrastructure\nconst secret = userPoolClient.userPoolClientSecret;\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Authorization for AppSync Channel Namespaces in TypeScript with AWS CDK\nDESCRIPTION: This snippet shows how to override the default API-level authorization configuration for a specific AWS AppSync Channel Namespace using the AWS CDK. It configures the `authorizationConfig` property during namespace creation, specifying `API_KEY` for publishing and `LAMBDA` for subscribing. This requires the specified authorization types (API Key, Lambda) to be enabled at the parent `EventApi` level.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const api: appsync.EventApi;\n\nnew appsync.ChannelNamespace(this, 'Namespace', {\n  api,\n  authorizationConfig: {\n    // Override publishing authorization to API Key\n    publishAuthModeTypes: [appsync.AppSyncAuthorizationType.API_KEY],\n    // Override subscribing authorization to Lambda\n    subscribeAuthModeTypes: [appsync.AppSyncAuthorizationType.LAMBDA],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Hostname Rewrite for gRPC Gateway Routes in AWS App Mesh with CDK\nDESCRIPTION: Demonstrates how to configure hostname rewriting for gRPC-based gateway routes in AWS App Mesh. This example disables the default rewrite to virtual service name and retains the original request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gateway: appmesh.VirtualGateway;\ndeclare const virtualService: appmesh.VirtualService;\n\ngateway.addGatewayRoute('gateway-route-grpc', {\n  routeSpec: appmesh.GatewayRouteSpec.grpc({\n    routeTarget: virtualService,\n    match: {\n      hostname: appmesh.GatewayRouteHostnameMatch.exactly('example.com'),\n      // This disables the default rewrite to virtual service name and retain original request.\n      rewriteRequestHostname: false,\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting EFS Read Permissions While Allowing Anonymous Access in TypeScript\nDESCRIPTION: Grants read-only access to an EFS file system for a specified IAM role, while explicitly keeping anonymous access enabled. This is achieved by setting `allowAnonymousAccess: true` during file system creation and then using the `.grantRead()` method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst role = new iam.Role(this, 'ClientRole', {\n  assumedBy: new iam.AnyPrincipal(),\n});\nconst fileSystem = new efs.FileSystem(this, 'MyEfsFileSystem', {\n  vpc: new ec2.Vpc(this, 'VPC'),\n  allowAnonymousAccess: true,\n});\n\nfileSystem.grantRead(role);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a TableWidget to AWS CloudWatch Dashboard (TypeScript)\nDESCRIPTION: Demonstrates creating and adding a TableWidget that displays one or more metrics in a tabular format to a CloudWatch dashboard using AWS CDK. Requires instantiated Dashboard and Metric objects from the aws-cdk-lib/aws-cloudwatch module. Accepts an array of metrics and an optional title. Outputs a table representation of metric data to the dashboard.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const executionCountMetric: cloudwatch.Metric;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  title: \"Executions\",\n  metrics: [executionCountMetric],\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Extension with SNS Destination using AWS CDK in TypeScript\nDESCRIPTION: This code demonstrates creating an AWS AppConfig `Extension` that sends events to an Amazon SNS topic upon the `ON_DEPLOYMENT_START` action point. The destination is configured using `appconfig.SnsDestination`. Requires an `sns.Topic` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const topic: sns.Topic;\n\nnew appconfig.Extension(this, 'MyExtension', {\n  actions: [\n    new appconfig.Action({\n      actionPoints: [appconfig.ActionPoint.ON_DEPLOYMENT_START],\n      eventDestination: new appconfig.SnsDestination(topic),\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Canary Memory Allocation in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure the maximum memory allocated to the Synthetics Canary's underlying Lambda function using the `memory` property. This example sets the memory to 1024 MiB using `cdk.Size.mebibytes`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from \"aws-cdk-lib\";\n\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  memory: cdk.Size.mebibytes(1024), // 1024 MiB\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Cognito User Pools in TypeScript\nDESCRIPTION: This code example shows how to import existing Cognito User Pools into a CDK app using either the User Pool ID or ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst awesomePool = cognito.UserPool.fromUserPoolId(this, 'awesome-user-pool', 'us-east-1_oiuR12Abd');\n\nconst otherAwesomePool = cognito.UserPool.fromUserPoolArn(this, 'other-awesome-user-pool',\n  'arn:aws:cognito-idp:eu-west-1:123456789012:userpool/us-east-1_mtRyYQ14D');\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFormation Stack Drift Detection Config Rule in TypeScript\nDESCRIPTION: Demonstrates how to create a Config rule that checks for CloudFormation stack drift. The rule is compliant if the stack's status is 'IN_SYNC' and non-compliant if the drift status is 'DRIFTED'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// compliant if stack's status is 'IN_SYNC'\n// non-compliant if the stack's drift status is 'DRIFTED'\nnew config.CloudFormationStackDriftDetectionCheck(this, 'Drift', {\n  ownStackOnly: true, // checks only the stack containing the rule\n});\n```\n\n----------------------------------------\n\nTITLE: Patching Kubernetes Resources with KubernetesPatch in TypeScript\nDESCRIPTION: This snippet shows how to use the KubernetesPatch construct to update existing Kubernetes resources. It demonstrates patching a deployment to modify the number of replicas, including both apply and restore patches.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nnew eks.KubernetesPatch(this, 'hello-kub-deployment-label', {\n  cluster,\n  resourceName: \"deployment/hello-kubernetes\",\n  applyPatch: { spec: { replicas: 5 } },\n  restorePatch: { spec: { replicas: 3 } },\n})\n```\n\n----------------------------------------\n\nTITLE: Granting IAM permissions to a Map (Legacy)\nDESCRIPTION: Demonstrates how to grant rendering permissions to an IAM role for a Map resource. This allows the role to perform map rendering operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\n\nconst map = new location.Map(this, 'Map', {\n  style: location.Style.VECTOR_ESRI_NAVIGATION,\n});\nmap.grantRendering(role);\n```\n\n----------------------------------------\n\nTITLE: Asserting Full Resource Definition in TypeScript\nDESCRIPTION: Shows how to use `hasResource()` to assert that a resource of a given type exists with the specified *entire* definition, including `Properties`, `DependsOn`, etc. It performs deep partial matching by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.hasResource('Foo::Bar', {\n  Properties: { Lorem: 'Ipsum' },\n  DependsOn: [ 'Waldo', 'Fred' ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding to a Custom Schedule Group (AWS CDK, TypeScript)\nDESCRIPTION: This code creates a custom schedule group and assigns a schedule to it. The group helps in logical organization, tagging, and group-based permissions. Inputs are the group name and schedule configuration; output is a schedule added to the specified group. Dependencies: ScheduleGroup, Schedule, ScheduleExpression, LambdaInvoke.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nconst scheduleGroup = new ScheduleGroup(this, \"ScheduleGroup\", {\n    scheduleGroupName: \"MyScheduleGroup\",\n});\n\nnew Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(10)),\n    target,\n    scheduleGroup,\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Context via CDK CLI - Console\nDESCRIPTION: Shows how to inject context key-value pairs using the AWS CDK CLI's --context argument. This method sets runtime feature flags or custom settings for the duration of the current CLI invocation. No additional dependencies are needed, just the AWS CDK CLI installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_46\n\nLANGUAGE: console\nCODE:\n```\ncdk synth --context @aws-cdk/core:newStyleStackSynthesis=true\n```\n\n----------------------------------------\n\nTITLE: Importing MediaTailor Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the MediaTailor module from the AWS CDK library in a TypeScript project. It allows access to MediaTailor-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediatailor/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediatailor from 'aws-cdk-lib/aws-mediatailor';\n```\n\n----------------------------------------\n\nTITLE: Creating a Standalone Matchmaking Configuration in GameLift FlexMatch with TypeScript\nDESCRIPTION: This snippet shows how to create a standalone matchmaking configuration in GameLift FlexMatch. It uses a matchmaking ruleset to configure the matchmaker without a game session queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const ruleSet: gamelift.MatchmakingRuleSet;\n\nnew gamelift.StandaloneMatchmakingConfiguration(this, 'StandaloneMatchmaking', {\n  matchmakingConfigurationName: 'test-standalone-config-name',\n  ruleSet: ruleSet,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppSync Route53 Alias Record\nDESCRIPTION: Demonstrates creating a Route53 A-record that aliases to an AppSync GraphQL API endpoint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appsync from 'aws-cdk-lib/aws-appsync';\n\ndeclare const zone: route53.HostedZone;\ndeclare const graphqlApi: appsync.GraphqlApi;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.AppSyncTarget(graphqlApi)),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a SageMaker Pipeline Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a SageMaker pipeline as the target. The pipe will send events from an SQS queue source to the SageMaker pipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetPipeline: sagemaker.IPipeline;\n\nconst pipelineTarget = new targets.SageMakerTarget(targetPipeline);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipelineTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Extension with EventBridge Destination using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS AppConfig `Extension` that targets an Amazon EventBridge event bus (specifically the default bus in this example) as the event destination for the `ON_DEPLOYMENT_START` action point. It first imports the default event bus using `events.EventBus.fromEventBusName` and then uses `appconfig.EventBridgeDestination`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst bus = events.EventBus.fromEventBusName(this, 'MyEventBus', 'default');\n\nnew appconfig.Extension(this, 'MyExtension', {\n  actions: [\n    new appconfig.Action({\n      actionPoints: [appconfig.ActionPoint.ON_DEPLOYMENT_START],\n      eventDestination: new appconfig.EventBridgeDestination(bus),\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Private Registry Authentication in ECS Task Definition\nDESCRIPTION: This snippet demonstrates how to use the new private registry authentication features in an ECS task definition. It shows creating a secret, defining a task, and adding a container with credentials for a private image.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-priv-registry-support.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst taskDefinition = new ecs.Ec2TaskDefinition(stack, 'TaskDef');\n\nconst secret = secretsManager.Secret.fromSecretArn(stack, 'myRepoSecret', 'arn:aws:secretsmanager:.....')\n\ntaskDefinition.AddContainer('myPrivateContainer', {\n  image: ecs.ContainerImage.fromInternet('userx/test', {\n      credentials: ecs.RepositoryCreds.fromSecret(secret)\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Routing Events to Different EventBridge Bus in TypeScript\nDESCRIPTION: This snippet creates a scheduled event rule that routes events to an imported EventBridge bus. It demonstrates how to use the EventBus target to redirect events to a different bus.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.expression('rate(1 minute)'),\n});\n\nrule.addTarget(new targets.EventBus(\n  events.EventBus.fromEventBusArn(\n    this,\n    'External',\n    `arn:aws:events:eu-west-1:999999999999:event-bus/test-bus`,\n  ),\n));\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Scaling Policy for GameLift FleetIQ Game Server Group (TypeScript)\nDESCRIPTION: Demonstrates attaching an auto scaling policy to a GameLift FleetIQ GameServerGroup, utilizing metrics like PercentUtilizedGameServers and estimated warmup to dynamically manage server count. This is done via AWS CDK, using parameters for instance types, template, VPC, and scaling configuration. Input resources must exist, and the output is a scalable, intelligent server group construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const launchTemplate: ec2.ILaunchTemplate;\ndeclare const vpc: ec2.IVpc;\n\nnew gamelift.GameServerGroup(this, 'Game server group', {\n  gameServerGroupName: 'sample-gameservergroup-name',\n  instanceDefinitions: [{\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  },\n  {\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  }],\n  launchTemplate: launchTemplate,\n  vpc: vpc,\n  autoScalingPolicy: {\n    estimatedInstanceWarmup: Duration.minutes(5),\n    targetTrackingConfiguration: 5\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Inline IAM Policy to Lambda Trigger for Cognito User Pool in TypeScript\nDESCRIPTION: This snippet demonstrates how to add an inline IAM policy to a Lambda trigger to avoid circular dependencies when providing permissions to the user pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const postAuthFn: lambda.Function;\n\nconst userpool = new cognito.UserPool(this, 'myuserpool', {\n  lambdaTriggers: {\n    postAuthentication: postAuthFn,\n  },\n});\n\n// provide permissions to describe the user pool scoped to the ARN the user pool\npostAuthFn.role?.attachInlinePolicy(new iam.Policy(this, 'userpool-policy', {\n  statements: [new iam.PolicyStatement({\n    actions: ['cognito-idp:DescribeUserPool'],\n    resources: [userpool.userPoolArn],\n  })],\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Asset Publishing Roles\nDESCRIPTION: Setup of AppStagingSynthesizer with custom IAM roles for file and image asset publishing operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    fileAssetPublishingRole: BootstrapRole.fromRoleArn('arn:aws:iam::123456789012:role/S3Access'),\n    imageAssetPublishingRole: BootstrapRole.fromRoleArn('arn:aws:iam::123456789012:role/ECRAccess'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Health Checks for AWS App Runner Service using AWS CDK - TypeScript\nDESCRIPTION: Illustrates customizing health checks for an AWS App Runner service in AWS CDK using TypeScript. The example employs the 'healthCheck' property set with 'apprunner.HealthCheck.http', enabling specification of parameters like thresholds, intervals, timeout, and path for HTTP health checks. Dependencies are core AWS CDK and 'apprunner'. Required parameters include health thresholds and duration values. The output is a service with tailored health monitoring settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  healthCheck: apprunner.HealthCheck.http({\n    healthyThreshold: 5,\n    interval: Duration.seconds(10),\n    path: '/',\n    timeout: Duration.seconds(10),\n    unhealthyThreshold: 10,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using CodeBuild Project as CloudWatch Event Target (TypeScript)\nDESCRIPTION: This snippet illustrates how to trigger an AWS CodeBuild project in response to an AWS CodeCommit repository event using AWS CloudWatch Events and the AWS CDK. It defines an event rule on a `codecommit.Repository`'s `onCommit` event and sets the target to the CodeBuild project using `aws-events-targets.CodeBuildProject`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n// start build when a commit is pushed\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\n\ndeclare const codeCommitRepository: codecommit.Repository;\ndeclare const project: codebuild.Project;\n\ncodeCommitRepository.onCommit('OnCommit', {\n  target: new targets.CodeBuildProject(project),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Actions for Stuck Jobs in AWS Batch Job Queue using TypeScript\nDESCRIPTION: This snippet shows how to configure a Job Queue to automatically take action on jobs that remain in the RUNNABLE state for a specified duration. It defines a `jobStateTimeLimitActions` rule to cancel jobs stuck in RUNNABLE state for more than 10 minutes due to insufficient instance capacity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew batch.JobQueue(this, 'JobQueue', {\n    jobStateTimeLimitActions: [\n      {\n        action: batch.JobStateTimeLimitActionsAction.CANCEL,\n        maxTime: cdk.Duration.minutes(10),\n        reason: batch.JobStateTimeLimitActionsReason.INSUFFICIENT_INSTANCE_CAPACITY,\n        state: batch.JobStateTimeLimitActionsState.RUNNABLE,\n      },\n    ]\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Destination Encryption for Amazon Data Firehose in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable encryption for data delivered to an S3 bucket by an Amazon Data Firehose delivery stream using a KMS key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\ndeclare const key: kms.Key;\nconst destination = new firehose.S3Bucket(bucket, {\n  encryptionKey: key,\n});\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Fine-Grained Access Control\nDESCRIPTION: Sets up an OpenSearch domain with fine-grained access control and a master user.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n  },\n});\n\nconst masterUserPassword = domain.masterUserPassword;\n```\n\n----------------------------------------\n\nTITLE: Allowing EC2 Instance Connection to FSx Lustre File System in TypeScript\nDESCRIPTION: This snippet shows how to permit network connectivity from an EC2 instance to an FSx Lustre file system using the CDK. Requires both LustreFileSystem and EC2 Instance constructs. The allowDefaultPortFrom method configures security group rules allowing the instance to access the FSx service's default port. There is no need to specify port numbers as FSx uses a fixed port. Outputs modified connection rules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fileSystem: fsx.LustreFileSystem;\ndeclare const instance: ec2.Instance;\n\nfileSystem.connections.allowDefaultPortFrom(instance);\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Timeout for ECS Deployment in TypeScript\nDESCRIPTION: This snippet illustrates how to modify the default timeout for a CodeDeploy Deployment. It overrides the default 30-minute timeout with a custom duration of 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const deploymentGroup: codedeploy.IEcsDeploymentGroup;\ndeclare const taskDefinition: ecs.ITaskDefinition;\n\nnew EcsDeployment({\n  deploymentGroup,\n  targetService: {\n    taskDefinition,\n    containerName: 'mycontainer',\n    containerPort: 80,\n  },\n  timeout: Duration.minutes(60),\n});\n```\n\n----------------------------------------\n\nTITLE: Bringing Your Own DKIM to an SES Identity - AWS CDK - TypeScript\nDESCRIPTION: This code configures DKIM for an SES identity using custom public/private keys (BYODKIM), as opposed to Easy DKIM. The dkimIdentity parameter specifies the selector and key material, which can be retrieved from AWS Secrets Manager. CDK automatically sets up necessary DNS records if the identity is based on a Route 53 hosted zone. This approach offers enhanced DKIM control and key rotation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myHostedZone: route53.IPublicHostedZone;\n\nnew ses.EmailIdentity(this, 'Identity', {\n  identity: ses.Identity.publicHostedZone(myHostedZone),\n  dkimIdentity: ses.DkimIdentity.byoDkim({\n    privateKey: SecretValue.secretsManager('dkim-private-key'),\n    publicKey: '...base64-encoded-public-key...',\n    selector: 'selector',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating CodeBuild Project with S3 Source in TypeScript\nDESCRIPTION: Shows how to create a CodeBuild project using an S3 bucket as the source. It creates a new S3 bucket and uses a specific path within it as the source for the CodeBuild project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst bucket = new s3.Bucket(this, 'MyBucket');\n\nnew codebuild.Project(this, 'MyProject', {\n  source: codebuild.Source.s3({\n    bucket: bucket,\n    path: 'path/to/file.zip',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Inserting a Stage at a Specific Position in the Pipeline\nDESCRIPTION: Shows how to insert a new stage at a specific position in the pipeline using the placement property with rightBefore or justAfter options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Insert a new Stage at an arbitrary point\ndeclare const pipeline: codepipeline.Pipeline;\ndeclare const anotherStage: codepipeline.IStage;\ndeclare const yetAnotherStage: codepipeline.IStage;\n\nconst someStage = pipeline.addStage({\n  stageName: 'SomeStage',\n  placement: {\n    // note: you can only specify one of the below properties\n    rightBefore: anotherStage,\n    justAfter: yetAnotherStage,\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Private Hosted Zone in Route53 using AWS CDK\nDESCRIPTION: Shows how to create a private hosted zone in Amazon Route53 using the AWS CDK. It requires a VPC to be associated with the hosted zone. The zoneName parameter specifies the fully qualified domain name for the hosted zone.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst zone = new route53.PrivateHostedZone(this, 'HostedZone', {\n  zoneName: 'fully.qualified.domain.com',\n  vpc,    // At least one VPC has to be added to a Private Hosted Zone.\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Tasks with Public IPs for QueueProcessingFargateService (TypeScript)\nDESCRIPTION: Configures the QueueProcessingFargateService to assign public IP addresses to its tasks by setting assignPublicIp: true. This allows containers to be directly accessible from the internet, typically when deployed in public subnets. Requires a VPC and ECS cluster with appropriate network setup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  vpc,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  assignPublicIp: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Cognito User Pool Domain Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to a Cognito User Pool domain.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cognito from 'aws-cdk-lib/aws-cognito';\n\ndeclare const zone: route53.HostedZone;\ndeclare const domain: cognito.UserPoolDomain;\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.UserPoolDomainTarget(domain)),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting AssumeRole Permission to User\nDESCRIPTION: Demonstrates how to grant a user permission to assume a role using grantAssumeRole.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = new iam.User(this, 'user')\nconst role = new iam.Role(this, 'role', {\n  assumedBy: new iam.AccountPrincipal(this.account)\n});\n\nrole.grantAssumeRole(user);\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing ECS CodeDeploy Application in TypeScript\nDESCRIPTION: Illustrates how to import an existing AWS CodeDeploy Application for ECS into an AWS CDK application using its name. This is useful for referencing applications managed externally.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = codedeploy.EcsApplication.fromEcsApplicationName(\n  this,\n  'ExistingCodeDeployApplication',\n  'MyExistingApplication',\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an Alarm on CloudWatch Logs Incoming Events in TypeScript\nDESCRIPTION: Creates an alarm based on the IncomingLogEvents metric to monitor log ingestion volume, ensuring the log ingestion process is functioning correctly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst logGroup = new logs.LogGroup(this, 'MyLogGroup');\nconst incomingEventsMetric = logGroup.metricIncomingLogEvents();\nnew cloudwatch.Alarm(this, 'HighLogVolumeAlarm', {\n  metric: incomingEventsMetric,\n  threshold: 1000,\n  evaluationPeriods: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Deployment Configuration for QueueProcessingFargateService (TypeScript)\nDESCRIPTION: Demonstrates how to configure custom deployment parameters, such as maxHealthyPercent and minHealthyPercent, for QueueProcessingFargateService. These parameters allow tuning the rolling deployment behavior for ECS services. Requires an ECS cluster and the standard ECS Patterns constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  command: [\"-c\", \"4\", \"amazon.com\"],\n  enableLogging: false,\n  desiredTaskCount: 2,\n  environment: {},\n  maxScalingCapacity: 5,\n  maxHealthyPercent: 200,\n  minHealthyPercent: 66,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Context Using cdk.json Configuration File - JSON\nDESCRIPTION: Demonstrates context assignment by including key-value pairs under the context key in the project's cdk.json configuration file. Useful for persistent, project-wide settings, this approach is evaluated during CDK app execution. Only valid JSON files are accepted and must be present at project root.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_47\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"context\": {\n    \"@aws-cdk/core:newStyleStackSynthesis\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Context Using cdk.context.json File - JSON\nDESCRIPTION: Shows a flat key-value context mapping in cdk.context.json for storing resolved and cached CDK context values. Typically maintained by the toolkit, but may be edited for manual overrides or sharing. Values must be valid JSON and reference context key names matching those expected by AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_48\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"@aws-cdk/core:newStyleStackSynthesis\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Config Rule Re-evaluation Notifications in TypeScript CDK\nDESCRIPTION: Implements event handling for AWS Config rule re-evaluation status changes. Creates an SNS topic and configures it to receive notifications when the rule is re-evaluated.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Topic to which re-evaluation notification events will be published\nconst reEvaluationTopic = new sns.Topic(this, 'ComplianceTopic');\n\nconst rule = new config.CloudFormationStackDriftDetectionCheck(this, 'Drift');\nrule.onReEvaluationStatus('ReEvaluationEvent', {\n  target: new targets.SnsTopic(reEvaluationTopic),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Identity Provider with Secrets Manager for Cognito User Pool in TypeScript\nDESCRIPTION: This code shows how to set up Google as an identity provider for a Cognito User Pool, using a client secret stored in AWS Secrets Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'Pool');\nconst secret = secretsmanager.Secret.fromSecretAttributes(this, \"CognitoClientSecret\", {\n    secretCompleteArn: \"arn:aws:secretsmanager:xxx:xxx:secret:xxx-xxx\"\n}).secretValue\n\nconst provider = new cognito.UserPoolIdentityProviderGoogle(this, 'Google', {\n  clientId: 'amzn-client-id',\n  clientSecretValue: secret,\n  userPool: userpool,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Authentication Session Validity for Cognito App Client (TypeScript)\nDESCRIPTION: This snippet configures the validity duration for the authentication session token used in API requests within the Cognito authentication flow. It sets the `authSessionValidity` property to 15 minutes using the AWS CDK `Duration` utility. The valid range is 3 to 15 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  // ...\n  authSessionValidity: Duration.minutes(15),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudTrail Management Event Logging (Read-Only) using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a CloudTrail trail to log only 'Read' type management events (control plane operations). This is done by setting the `managementEvents` property to `cloudtrail.ReadWriteType.READ_ONLY`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst trail = new cloudtrail.Trail(this, 'CloudTrail', {\n  // ...\n  managementEvents: cloudtrail.ReadWriteType.READ_ONLY,\n});\n```\n\n----------------------------------------\n\nTITLE: Using CodeStar Connections Source Action Variables in CodeBuild Action\nDESCRIPTION: This example shows how to use variables emitted by the CodeStar Connections source action (for BitBucket or GitHub) in a subsequent CodeBuild action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const project: codebuild.Project;\n\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeStarConnectionsSourceAction({\n  actionName: 'BitBucket_Source',\n  owner: 'aws',\n  repo: 'aws-cdk',\n  output: sourceOutput,\n  connectionArn: 'arn:aws:codestar-connections:us-east-1:123456789012:connection/12345678-abcd-12ab-34cdef5678gh',\n  variablesNamespace: 'SomeSpace', // optional - by default, a name will be generated for you\n});\n\n// later:\n\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    COMMIT_ID: {\n      value: sourceAction.variables.commitId,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Neptune Cluster Security with Connections\nDESCRIPTION: Shows how to configure security group rules to allow traffic to the Neptune cluster on its default port from any IPv4 address.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncluster.connections.allowDefaultPortFromAnyIpv4('Open to the world');\n```\n\n----------------------------------------\n\nTITLE: Creating a Pipeline with Initial Stages\nDESCRIPTION: Creates a CodePipeline with pre-defined stages during initialization. This example shows how to include a Source stage when creating the pipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Provide a Stage when creating a pipeline\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline', {\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [\n        // see below...\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Named IAM Instance Profiles with Paths in AWS CDK\nDESCRIPTION: Creates an IAM instance profile with a custom name and path. This allows for more specific organization and identification of instance profiles in your AWS account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n});\n\nconst instanceProfile = new iam.InstanceProfile(this, 'InstanceProfile', {\n  role,\n  instanceProfileName: 'MyInstanceProfile',\n  path: '/sample/path/',\n});\n```\n\n----------------------------------------\n\nTITLE: Selecting Amazon Cognito Managed Login Page Versions using AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates configuring which version of Amazon Cognito's managed login page to use, either the new UI or the classic hosted UI, via the managedLoginVersion property in the domain configuration. Requires AWS CDK for Cognito and ManagedLoginVersion enum. Inputs are domain prefixes and the ManagedLoginVersion; the effect is that each domain variant uses the specified UI version.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nconst pool = new cognito.UserPool(this, 'Pool');\n\n// Use the new managed login page\npool.addDomain('CognitoDomainWithBlandingDesignManagedLogin', {\n  cognitoDomain: {\n    domainPrefix: 'blanding-design-ui',\n  },\n  managedLoginVersion: cognito.ManagedLoginVersion.NEWER_MANAGED_LOGIN,\n});\n\n// Use the classic hosted UI\npool.addDomain('DomainWithClassicHostedUi', {\n  cognitoDomain: {\n    domainPrefix: 'classic-hosted-ui',\n  },\n  managedLoginVersion: cognito.ManagedLoginVersion.CLASSIC_HOSTED_UI,\n});\n```\n\n----------------------------------------\n\nTITLE: Rotating an Access Key for an IAM User Using Serial (TypeScript)\nDESCRIPTION: Demonstrates rotation of an IAM user's access key by specifying a monotonically increasing serial property. Each time the serial is incremented, a new key is created and the old one deleted. Requires an existing IAM user. This is managed via CloudFormation deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = new iam.User(this, 'MyUser');\\nconst accessKey = new iam.AccessKey(this, 'MyAccessKey', { user: user, serial: 1 });\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Network Load Balancer Origin\nDESCRIPTION: Sets up a private Network Load Balancer in a VPC as a CloudFront origin with required security group\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst nlb = new elbv2.NetworkLoadBalancer(this, 'NLB', {\n  vpc,\n  internetFacing: false,\n  vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_ISOLATED },\n  securityGroups: [new ec2.SecurityGroup(this, 'NLB-SG', { vpc })],\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: origins.VpcOrigin.withNetworkLoadBalancer(nlb) },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFront Key Value Store with Initial Data using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates creating CloudFront Key Value Stores and populating them with initial data using the `source` property. It shows two methods: importing from a local JSON file using `ImportSource.fromAsset` and providing data directly as an inline JSON string using `ImportSource.fromInline`. The required JSON structure is mentioned in the surrounding text.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst storeAsset = new cloudfront.KeyValueStore(this, 'KeyValueStoreAsset', {\n  keyValueStoreName: 'KeyValueStoreAsset',\n  source: cloudfront.ImportSource.fromAsset('path-to-data.json'),\n});\n\nconst storeInline = new cloudfront.KeyValueStore(this, 'KeyValueStoreInline', {\n  keyValueStoreName: 'KeyValueStoreInline',\n  source: cloudfront.ImportSource.fromInline(JSON.stringify({\n    data: [\n      {\n        key: \"key1\",\n        value: \"value1\",\n      },\n      {\n        key: \"key2\",\n        value: \"value2\",\n      },\n    ],\n  })),\n});\n```\n\n----------------------------------------\n\nTITLE: Tagging Instances in Managed EC2 Compute Environment using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to add tags to the EC2 instances launched by an AWS Batch Managed EC2 ECS Compute Environment. It creates the compute environment (`tagCE`) associated with a VPC (`vpc`) and then uses the `Tags.of(resource).add(key, value)` API from CDK to apply a tag ('super': 'salamander') to it.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.IVpc;\n\nconst tagCE = new batch.ManagedEc2EcsComputeEnvironment(this, 'CEThatMakesTaggedInstnaces', {\n  vpc,\n});\n\nTags.of(tagCE).add('super', 'salamander');\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Cross-Account CloudFormation Action in AWS CodePipeline\nDESCRIPTION: Implements a CloudFormation action that deploys to a different AWS account. This example demonstrates how CodePipeline can be configured to create or update stacks in another account by automatically creating the necessary cross-account roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst sourceOutput = new codepipeline.Artifact();\nnew codepipeline_actions.CloudFormationCreateUpdateStackAction({\n  actionName: 'CloudFormationCreateUpdate',\n  stackName: 'MyStackName',\n  adminPermissions: true,\n  templatePath: sourceOutput.atPath('template.yaml'),\n  account: '123456789012',\n});\n```\n\n----------------------------------------\n\nTITLE: Starting an Amazon Inspector Assessment Run with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to trigger an Amazon Inspector assessment run using EventBridge Scheduler configured via AWS CDK. It assumes an existing `CfnAssessmentTemplate`, converts it to an `IAssessmentTemplate`, creates an `InspectorStartAssessmentRun` target referencing this template, and sets up a schedule to trigger the assessment run every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as inspector from 'aws-cdk-lib/aws-inspector';\n\ndeclare const cfnAssessmentTemplate: inspector.CfnAssessmentTemplate;\n\nconst assessmentTemplate = inspector.AssessmentTemplate.fromCfnAssessmentTemplate(this, 'MyAssessmentTemplate', cfnAssessmentTemplate);\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.InspectorStartAssessmentRun(assessmentTemplate),\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Evaluation Modes for Config Rules in TypeScript\nDESCRIPTION: Demonstrates how to specify evaluation modes for different types of Config rules. Examples include setting detective and proactive modes for managed rules, and proactive or detective modes for custom rules and policies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\ndeclare const samplePolicyText: string;\n\nnew config.ManagedRule(this, 'ManagedRule', {\n  identifier: config.ManagedRuleIdentifiers.API_GW_XRAY_ENABLED,\n  evaluationModes: config.EvaluationMode.DETECTIVE_AND_PROACTIVE,\n});\n\nnew config.CustomRule(this, 'CustomRule', {\n  lambdaFunction: fn,\n  evaluationModes: config.EvaluationMode.PROACTIVE,\n});\n\nnew config.CustomPolicy(this, 'CustomPolicy', {\n  policyText: samplePolicyText,\n  evaluationModes: config.EvaluationMode.DETECTIVE,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Route Selection Expression for API Gateway v2 HTTP API in AWS CDK (TypeScript)\nDESCRIPTION: This code illustrates how to enable the routeSelectionExpression option in HttpApi. When set to true, the API uses the default route selection logic (${request.method} ${request.path}) to match routes. Dependencies required: aws-cdk-lib/aws-apigatewayv2. Input: boolean flag for routeSelectionExpression. Output: HttpApi using default route selection which may limit custom expressions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew apigwv2.HttpApi(this, 'HttpProxyApi', {\n  routeSelectionExpression: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Enforcing SSL via addToResourcePolicy on an SNS Topic in AWS CDK (TypeScript)\nDESCRIPTION: Illustrates setting the enforceSSL property at topic construction and adding resource policy statements directly with addToResourcePolicy. This ensures that only encrypted connections are allowed when publishing to the topic. The snippet includes assigning permissions to the S3 service principal. Suitable for compliance-mandated or security-focused deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'TopicAddPolicy', {\n  enforceSSL: true,\n});\n\ntopic.addToResourcePolicy(new iam.PolicyStatement({\n  principals: [new iam.ServicePrincipal('s3.amazonaws.com')],\n  actions: ['sns:Publish'],\n  resources: [topic.topicArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Retrieving MSK Cluster Endpoints in TypeScript\nDESCRIPTION: This snippet shows how to retrieve and output various endpoint types for an MSK Cluster, including bootstrap brokers and ZooKeeper connection strings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: msk.Cluster;\nnew CfnOutput(this, 'BootstrapBrokers', { value: cluster.bootstrapBrokers });\nnew CfnOutput(this, 'BootstrapBrokersTls', { value: cluster.bootstrapBrokersTls });\nnew CfnOutput(this, 'BootstrapBrokersSaslScram', { value: cluster.bootstrapBrokersSaslScram });\nnew CfnOutput(this, 'BootstrapBrokerStringSaslIam', { value: cluster.bootstrapBrokersSaslIam });\nnew CfnOutput(this, 'ZookeeperConnection', { value: cluster.zookeeperConnectionString });\nnew CfnOutput(this, 'ZookeeperConnectionTls', { value: cluster.zookeeperConnectionStringTls });\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamoDB Stream with Filters as Lambda Event Source in TypeScript\nDESCRIPTION: This snippet shows how to add a DynamoDB Stream as an event source to a Lambda function with filters. It filters events based on the 'id' column being a boolean with a value of true.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport { DynamoEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\ndeclare const table: dynamodb.Table;\n\ndeclare const fn: lambda.Function;\nfn.addEventSource(new DynamoEventSource(table, {\n  startingPosition: lambda.StartingPosition.LATEST,\n  filters: [\n    lambda.FilterCriteria.filter({\n      eventName: lambda.FilterRule.isEqual('INSERT'),\n      dynamodb: {\n        NewImage: {\n          id: { BOOL: lambda.FilterRule.isEqual(true) },\n        },\n      },\n    }),\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating Encrypted OpenSearch Domain\nDESCRIPTION: Creates an OpenSearch domain with node-to-node encryption and encryption at rest enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  ebs: {\n    volumeSize: 100,\n    volumeType: ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD,\n  },\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Security Groups to DocumentDB Cluster\nDESCRIPTION: Shows how to add existing security groups to a DocumentDB cluster outside of the Connections object management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const cluster: docdb.DatabaseCluster;\n\nconst securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', {\n  vpc,\n});\ncluster.addSecurityGroups(securityGroup);\n```\n\n----------------------------------------\n\nTITLE: Configuring Stage Level Conditions in a Pipeline using AWS CDK (TypeScript)\nDESCRIPTION: This example configures conditional logic for different stage events (before entry, on success, on failure) within an AWS CodePipeline using AWS CDK (TypeScript). It demonstrates attaching rules for Lambda invocation and CloudWatch checks using the beforeEntry, onSuccess, and onFailure properties for a stage. You must provide sourceAction and buildAction, and utilize codepipeline and codepipeline_actions. Conditions are associated with specific result actions (Fail, Rollback). Only supported in pipelineType V2.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n      // BeforeEntry condition - checks before entering the stage\n      beforeEntry: {\n        conditions: [{\n          rules: [ new codepipeline.Rule({\n            name: 'LambdaCheck',\n            provider: 'LambdaInvoke',\n            version: '1',\n            configuration: {\n              FunctionName: 'LambdaFunctionName',\n            },\n          })],\n          result:  codepipeline.Result.FAIL,\n        }],\n      },\n      // OnSuccess condition - checks after successful stage completion\n      onSuccess: {\n        conditions: [{\n          result: codepipeline.Result.FAIL,\n          rules: [new codepipeline.Rule({\n            name: 'CloudWatchCheck',\n            provider: 'LambdaInvoke',\n            version: '1',\n            configuration: {\n              AlarmName: 'AlarmName1',\n              WaitTime: '300', // 5 minutes\n              FunctionName: 'funcName2'\n            },\n          })],\n        }],\n      },\n      // OnFailure condition - handles stage failure\n      onFailure: {\n        conditions: [{\n          result: codepipeline.Result.ROLLBACK,\n            rules: [new codepipeline.Rule({\n            name: 'RollBackOnFailure',\n            provider: 'LambdaInvoke',\n            version: '1',\n            configuration: {\n              AlarmName: 'Alarm',\n              WaitTime: '300', // 5 minutes\n              FunctionName: 'funcName1'\n            },\n          })],\n        }],\n      },\n    },\n  ],\n\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Organizations Module in TypeScript\nDESCRIPTION: Example of importing the AWS Organizations module from aws-cdk-lib for use in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-organizations/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as organizations from 'aws-cdk-lib/aws-organizations';\n```\n\n----------------------------------------\n\nTITLE: Configuring Resource Options in AWS CDK TypeScript\nDESCRIPTION: Demonstrates how to specify CloudFormation resource attributes and dependencies using cfnOptions property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst rawBucket = new s3.CfnBucket(this, 'Bucket', { /* ... */ });\n// -or-\nconst rawBucketAlt = myBucket.node.defaultChild as s3.CfnBucket;\n\n// then\nrawBucket.cfnOptions.condition = new CfnCondition(this, 'EnableBucket', { /* ... */ });\nrawBucket.cfnOptions.metadata = {\n  metadataKey: 'MetadataValue',\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Force Deletion for CodeBuild Report Group (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure an AWS CodeBuild `ReportGroup` to be forcefully deleted, including all its associated reports, when removed from the CDK stack. This requires setting the `removalPolicy` to `cdk.RemovalPolicy.DESTROY` and enabling the `deleteReports` option.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst reportGroup = new codebuild.ReportGroup(this, 'ReportGroup', {\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n      deleteReports: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AWS Batch Job Definition with Fargate Container\nDESCRIPTION: Shows how to define an AWS Batch job that runs on AWS Fargate instead of EC2. This example configures memory, CPU, ephemeral storage, and specifies ARM64 architecture with Linux OS family.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst jobDefn = new batch.EcsJobDefinition(this, 'JobDefn', {\n  container: new batch.EcsFargateContainerDefinition(this, 'myFargateContainer', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n    ephemeralStorageSize: cdk.Size.gibibytes(100),\n    fargateCpuArchitecture: ecs.CpuArchitecture.ARM64,\n    fargateOperatingSystemFamily: ecs.OperatingSystemFamily.LINUX,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Linking Local AWS CDK with a Test App\nDESCRIPTION: Series of commands to create a test CDK app and link it with the local CDK repository for testing code changes. This process allows developers to verify their changes in a real application context.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ mkdir cdkApp # in parent dir of aws-cdk\n$ cd cdkApp\n$ npx cdk init app --language typescript\n$ npx cdk --version # shows the latest CDK version e.g. 2.155.0 (build 34dcc5a)\n$ ../aws-cdk/link-all.sh # link the aws-cdk repo with your cdkApp\n$ npx cdk --version # verify linked cdk version 0.0.0\n# Define the resource that uses your aws-cdk changes in cdkApp lib folder\n$ npx cdk deploy # deploy successfully\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon Pinpoint Analytics for Cognito User Pool Clients (Cross-Account) using AWS CDK - TypeScript\nDESCRIPTION: This snippet configures CDK Cognito user pool analytics using a Pinpoint app from another AWS account by specifying applicationId, externalId, and roleArn explicitly in the analytics property. Requires Pinpoint and IAM CDK modules, plus cross-account permissions, and all three attributes must be provided while not specifying the application property. Outputs are a user pool client with cross-account analytics integration enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pinpoint from 'aws-cdk-lib/aws-pinpoint';\n\ndeclare const userPool: cognito.UserPool;\ndeclare const pinpointApp: pinpoint.CfnApp;\ndeclare const pinpointRole: iam.Role;\n\nnew cognito.UserPoolClient(this, 'Client', {\n  userPool,\n  analytics: {\n    // Your Pinpoint project ID\n    applicationId: pinpointApp.ref,\n\n    // External ID for the IAM role\n    externalId: \"sample-external-id\",\n\n    // IAM role that Cognito can assume to publish to Pinpoint\n    role: pinpointRole,\n\n    // Whether to include user data in analytics events\n    shareUserData: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Partition Filtering on a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet shows how to enable partition filtering for an AWS Glue S3 Table using AWS CDK, which is beneficial for tables with a large and growing number of partitions. The `enablePartitionFiltering` property is set to `true` during table definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  database: myDatabase,\n  columns: [{\n      name: 'col1',\n      type: glue.Schema.STRING,\n  }],\n  partitionKeys: [{\n      name: 'year',\n      type: glue.Schema.SMALL_INT,\n  }, {\n      name: 'month',\n      type: glue.Schema.SMALL_INT,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n  enablePartitionFiltering: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Global Accelerator with Listeners and NLB Endpoints in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the basic setup of an AWS Global Accelerator using the AWS CDK. It creates an Accelerator, adds a Listener for ports 80 and 443, imports two Network Load Balancers (NLBs) from different regions using their ARNs, and adds each NLB as an endpoint in a separate Endpoint Group associated with the Listener. It relies on the `aws-globalaccelerator`, `aws-elasticloadbalancingv2`, and `aws-globalaccelerator-endpoints` CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Create an Accelerator\nconst accelerator = new globalaccelerator.Accelerator(this, 'Accelerator');\n\n// Create a Listener\nconst listener = accelerator.addListener('Listener', {\n  portRanges: [\n    { fromPort: 80 },\n    { fromPort: 443 },\n  ],\n});\n\n// Import the Load Balancers\nconst nlb1 = elbv2.NetworkLoadBalancer.fromNetworkLoadBalancerAttributes(this, 'NLB1', {\n  loadBalancerArn: 'arn:aws:elasticloadbalancing:us-west-2:111111111111:loadbalancer/app/my-load-balancer1/e16bef66805b',\n});\nconst nlb2 = elbv2.NetworkLoadBalancer.fromNetworkLoadBalancerAttributes(this, 'NLB2', {\n  loadBalancerArn: 'arn:aws:elasticloadbalancing:ap-south-1:111111111111:loadbalancer/app/my-load-balancer2/5513dc2ea8a1',\n});\n\n// Add one EndpointGroup for each Region we are targeting\nlistener.addEndpointGroup('Group1', {\n  endpoints: [new ga_endpoints.NetworkLoadBalancerEndpoint(nlb1)],\n});\nlistener.addEndpointGroup('Group2', {\n  // Imported load balancers automatically calculate their Region from the ARN.\n  // If you are load balancing to other resources, you must also pass a `region`\n  // parameter here.\n  endpoints: [new ga_endpoints.NetworkLoadBalancerEndpoint(nlb2)],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Inference Pipeline Model in Amazon SageMaker with TypeScript\nDESCRIPTION: This snippet shows how to create an inference pipeline model in Amazon SageMaker using the CDK. It demonstrates how to specify multiple containers for the model.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const image1: sagemaker.ContainerImage;\ndeclare const modelData1: sagemaker.ModelData;\ndeclare const image2: sagemaker.ContainerImage;\ndeclare const modelData2: sagemaker.ModelData;\ndeclare const image3: sagemaker.ContainerImage;\ndeclare const modelData3: sagemaker.ModelData;\n\nconst model = new sagemaker.Model(this, 'InferencePipelineModel', {\n  containers: [\n    { image: image1, modelData: modelData1 },\n    { image: image2, modelData: modelData2 },\n    { image: image3, modelData: modelData3 }\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Query Depth Limit for an AppSync API in TypeScript\nDESCRIPTION: This TypeScript CDK code demonstrates how to limit the maximum nesting level for GraphQL queries processed by an AppSync API. The `queryDepthLimit` property is set to 2, meaning queries with nesting deeper than two levels will be rejected.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'LimitQueryDepths',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.schema.graphql')),\n  queryDepthLimit: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Rule to SES Receipt Rule Set - AWS CDK - TypeScript\nDESCRIPTION: This code illustrates adding a new rule to an existing SES receipt rule set using AWS CDK. The addRule method defines the recipients for the new rule. It requires prior initialization of a ReceiptRuleSet construct. The new rule will process emails for the matching recipients. The snippet highlights that unless specified, the rule is appended after the last added rule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst ruleSet = new ses.ReceiptRuleSet(this, 'RuleSet');\n\nconst awsRule = ruleSet.addRule('Aws', {\n  recipients: ['aws.com'],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Standalone Fargate Profile\nDESCRIPTION: Creates a standalone Fargate profile for an EKS cluster using the FargateProfile construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nnew eks.FargateProfile(this, 'MyProfile', {\n  cluster,\n  selectors: [ { namespace: 'default' } ],\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Strong Reference Behavior in CloudFormation (TypeScript)\nDESCRIPTION: Provides a CDK example where a Lambda function (`stack2`) depends on an S3 bucket (`stack1`) via its name in an environment variable and IAM permissions. This setup illustrates how CloudFormation's strong references prevent breaking changes, like renaming the bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst bucket = new s3.Bucket(stack1, 'Bucket', {\n  bucketName: 'amzn-s3-demo-bucket',\n});\nconst handler = new lambda.Function(stack2, 'Handler', {\n  environment: {\n    BUCKET_NAME: bucket.bucketName,\n  },\n});\nbucket.grantRead(handler);\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking API Gateway V2 HTTP API with EventBridge Rule in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the ApiGatewayV2 target to trigger an HTTP API. It assumes an existing HttpApi and Rule have been declared.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as apigwv2 from 'aws-cdk-lib/aws-apigatewayv2';\n\ndeclare const httpApi: apigwv2.HttpApi;\ndeclare const rule: events.Rule;\n\nrule.addTarget(new targets.ApiGatewayV2(httpApi));\n```\n\n----------------------------------------\n\nTITLE: Adding Parameters Directly to a Redshift Cluster's Group with AWS CDK\nDESCRIPTION: Shows how to add a parameter directly to the parameter group associated with a specific Redshift cluster using `cluster.addToParameterGroup()`. If the cluster doesn't have a custom parameter group, the CDK will create one. Requires `Cluster`, `ec2.Vpc`, `cdk.SecretValue`, and an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as cdk from 'aws-cdk-lib';\ndeclare const vpc: ec2.Vpc;\n\nconst cluster = new Cluster(this, 'Cluster', {\n  masterUser: {\n    masterUsername: 'admin',\n    masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n  },\n  vpc,\n});\n\ncluster.addToParameterGroup('enable_user_activity_logging', 'true');\n```\n```\n\n----------------------------------------\n\nTITLE: Importing an existing Lambda CodeDeploy Application in TypeScript\nDESCRIPTION: Imports an already existing CodeDeploy Application for Lambda function deployments using the fromLambdaApplicationName static method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = codedeploy.LambdaApplication.fromLambdaApplicationName(\n  this,\n  'ExistingCodeDeployApplication',\n  'MyExistingApplication',\n);\n```\n\n----------------------------------------\n\nTITLE: Creating the Elasticsearch Service-Linked Role using AWS CDK\nDESCRIPTION: Shows how to create the required Service-Linked Role (SLR) for OpenSearch/Elasticsearch using the AWS CDK `iam.CfnServiceLinkedRole` construct. Note that creating an SLR is an account-level operation; this construct should ideally only be deployed once per account, as subsequent attempts in other stacks within the same account will fail.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst slr = new iam.CfnServiceLinkedRole(this, 'ElasticSLR', {\n  awsServiceName: 'es.amazonaws.com',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Pattern Variable for Region Replacement in AWS CDK\nDESCRIPTION: This example shows how to create a pattern variable for changing the region throughout a dashboard. It uses an input type and sets a default value.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cw from 'aws-cdk-lib/aws-cloudwatch';\n\nconst dashboard = new cw.Dashboard(this, 'Dash', {\n  defaultInterval: Duration.days(7),\n  variables: [new cw.DashboardVariable({\n    id: 'region2',\n    type: cw.VariableType.PATTERN,\n    label: 'RegionPattern',\n    inputType: cw.VariableInputType.INPUT,\n    value: 'us-east-1',\n    defaultValue: cw.DefaultValue.value('us-east-1'),\n    visible: true,\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an IAM User by ARN with AWS CDK (TypeScript)\nDESCRIPTION: Imports an existing IAM user using their full ARN, enabling further resource management within CDK. Input is the user ARN string; output is an imported user object. Appropriate for referencing externally managed users.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = iam.User.fromUserArn(this, 'MyImportedUserByArn', 'arn:aws:iam::123456789012:user/johnsmith');\n```\n\n----------------------------------------\n\nTITLE: Appending Pipeline-level Variables to an Existing Pipeline - AWS CDK - TypeScript\nDESCRIPTION: Shows how to add a pipeline-level variable to an already defined pipeline using the 'addVariable()' method. The snippet assumes a pre-declared pipeline instance and demonstrates instantiation and addition of a pipeline variable. Intended for dynamic extension of pipeline environments after initial creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeline: codepipeline.Pipeline;\n\nconst variable = new codepipeline.Variable({\n  variableName: 'bucket-var',\n  description: 'description',\n  defaultValue: 'sample',\n});\npipeline.addVariable(variable);\n```\n\n----------------------------------------\n\nTITLE: Creating Acceptor IAM Role for Cross-Account Peering (TypeScript)\nDESCRIPTION: Shows how to create the necessary IAM role in the acceptor VPC's account for cross-account VPC peering using the `acceptorVpc.createAcceptorVpcRole` method within the AWS CDK stack managing the acceptor VPC. This role grants the specified requestor account ID the permissions required to initiate the peering connection request. The ARN of this role is needed by the requestor. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\n\nconst acceptorVpc = new VpcV2(this, 'VpcA', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/16'),\n});\n\nconst acceptorRoleArn = acceptorVpc.createAcceptorVpcRole('000000000000'); // Requestor account ID\n```\n```\n\n----------------------------------------\n\nTITLE: Requiring an API Key for WebSocket API Access in TypeScript (CDK)\nDESCRIPTION: This snippet demonstrates how to enforce API Key usage for accessing a WebSocket API. It configures the `apiKeySelectionExpression` property during `WebSocketApi` creation to specify how the API key should be provided by the client, in this case, via the `x-api-key` header (`WebSocketApiKeySelectionExpression.HEADER_X_API_KEY`). This is often used with Usage Plans.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi',{\n  apiKeySelectionExpression: apigwv2.WebSocketApiKeySelectionExpression.HEADER_X_API_KEY,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset Bundling Output Type with BundlingOptions in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates forcing the output of an asset bundling process to be zipped, regardless if the output is already an archive, by setting outputType: BundlingOutput.NOT_ARCHIVED. The configuration specifies the Docker image and command used for bundling, and is used within the Asset construct. Prerequisites include aws-cdk-lib and a properly configured Docker environment. Key parameters are outputType, image, and command; inputs are the source asset path and command script that generates the bundle. Output is a zipped asset uploaded to S3, with optional constraint to always zip the output.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-assets/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst asset = new Asset(this, 'BundledAsset', {\n  path: '/path/to/asset',\n  bundling: {\n    image: cdk.DockerImage.fromRegistry('alpine'),\n    command: ['command-that-produces-an-archive.sh'],\n    outputType: cdk.BundlingOutput.NOT_ARCHIVED, // Bundling output will be zipped even though it produces a single archive file.\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Organization Webhook for CodeBuild in TypeScript\nDESCRIPTION: Demonstrates how to set up a webhook for an entire GitHub organization, allowing CodeBuild to trigger builds for multiple repositories based on specified filters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst gitHubSource = codebuild.Source.gitHub({\n  owner: 'aws',\n  webhookTriggersBatchBuild: true, // optional, default is false\n  webhookFilters: [\n    codebuild.FilterGroup\n      .inEventOf(codebuild.EventAction.WORKFLOW_JOB_QUEUED)\n      .andRepositoryNameIs(\"aws-.*\")\n      .andRepositoryNameIsNot(\"aws-cdk-lib\"),\n  ], // optional, by default all pushes and Pull Requests will trigger a build\n});\n```\n\n----------------------------------------\n\nTITLE: Using spec2cdk Programmatically in TypeScript\nDESCRIPTION: Examples of how to use the spec2cdk package programmatically to generate AWS CDK L1 modules. Demonstrates generating all modules at once or specific services with custom instructions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/spec2cdk/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateAll } from '@aws-cdk/spec2cdk';\n\ndeclare const outputDir: string;\n\n// Generate all modules\nawait generateAll(outputPath, { outputPath });\n\n// Generate modules with specific instructions\nawait generate({\n  'aws-lambda': { services: ['AWS::Lambda'] },\n  'aws-s3': { services: ['AWS::S3'] },\n}, { outputPath });\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic CloudTrail Trail using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates the basic creation of an AWS CloudTrail trail using the AWS CDK `cloudtrail.Trail` construct in TypeScript. It provisions a trail with default settings, including creating a new S3 bucket for log delivery, enabling multi-region delivery, and including global service events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst trail = new cloudtrail.Trail(this, 'CloudTrail');\n```\n\n----------------------------------------\n\nTITLE: Looking up a Bedrock Provisioned Model by ARN in AWS CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to reference an existing Amazon Bedrock provisioned throughput model in an AWS CDK application via its ARN using the `ProvisionedModel.fromProvisionedModelArn` method. It depends on the `aws-cdk-lib/aws-bedrock` module. The method requires the CDK scope (`this`), a logical ID (`'Model'`), and the full ARN of the provisioned model (e.g., 'arn:aws:bedrock:us-east-2:123456789012:provisioned-model/abc-123') as input. The result is an object representing the referenced provisioned model, suitable for use with other CDK resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-bedrock/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as bedrock from 'aws-cdk-lib/aws-bedrock';\n\nbedrock.ProvisionedModel.fromProvisionedModelArn(\n  this,\n  'Model',\n  'arn:aws:bedrock:us-east-2:123456789012:provisioned-model/abc-123',\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Compute Reservation for AWS Batch Fairshare Policy in TypeScript\nDESCRIPTION: This snippet demonstrates configuring a `computeReservation` for an AWS Batch Fairshare Scheduling Policy. It creates a policy reserving 75% of the maximum vCPU capacity for shares that are not currently active in the queue. It also defines three shares ('A', 'B', 'C') with different weight factors (1, 0.5, 2) directly within the policy constructor.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew batch.FairshareSchedulingPolicy(this, 'myFairsharePolicy', {\n  computeReservation: 75,\n  shares: [\n    { weightFactor: 1, shareIdentifier: 'A' },\n    { weightFactor: 0.5, shareIdentifier: 'B' },\n    { weightFactor: 2, shareIdentifier: 'C' },\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a GaugeWidget to AWS CloudWatch Dashboard (TypeScript)\nDESCRIPTION: Provides an example for adding a GaugeWidget to display a metric as a gauge visualization, with a configurable left Y axis min and max. Dashboard, Alarm, and Metric constructs from aws-cdk-lib/aws-cloudwatch are required. LeftYAxis properties define the value range of the gauge, e.g., from 0 to 1000.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const errorAlarm: cloudwatch.Alarm;\ndeclare const gaugeMetric: cloudwatch.Metric;\n\ndashboard.addWidgets(new cloudwatch.GaugeWidget({\n  metrics: [gaugeMetric],\n  leftYAxis: {\n    min: 0,\n    max: 1000,\n  }\n}));\n```\n\n----------------------------------------\n\nTITLE: Subscribing SMS Number to SNS Topic with AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to subscribe a phone number for SMS notifications to an SNS topic using the SmsSubscription class. The phone number must be in E.164 format (e.g., '+15551231234'). Requires an existing SNS topic and imports from aws-cdk-lib/aws-sns-subscriptions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'Topic');\n\nmyTopic.addSubscription(new subscriptions.SmsSubscription('+15551231234'));\n```\n\n----------------------------------------\n\nTITLE: Importing AWS EventSchemas Module - AWS CDK - TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS EventSchemas module from the aws-cdk-lib package for use in AWS Cloud Development Kit (CDK) projects. It enables developers to access AWS::EventSchemas CloudFormation resources using automatically generated L1 constructs, since hand-written (L2) constructs are not available. The import statement is required at the beginning of your CDK application to work with EventSchemas resources programmatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-eventschemas/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as eventschemas from 'aws-cdk-lib/aws-eventschemas';\n```\n\n----------------------------------------\n\nTITLE: Granting Redshift Table Privileges to a User with AWS CDK in TypeScript\nDESCRIPTION: Demonstrates how to grant specific actions (e.g., `DROP`, `SELECT`) on a Redshift table to a database user using the `table.grant()` method. This requires instantiating both a `User` and a `Table` construct within the same CDK scope, referencing the same cluster and database name. Requires `User`, `Table`, and `TableAction` imports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nconst user = new User(this, 'User', {\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\nconst table = new Table(this, 'Table', {\n  tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n\ntable.grant(user, TableAction.DROP, TableAction.SELECT);\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing MQTT Message Republishing with AWS IoT Rules\nDESCRIPTION: Creates an AWS IoT Rule that republishes messages to another MQTT topic. Includes quality of service configuration options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, timestamp() as timestamp, temperature FROM 'device/+/data'\"),\n  actions: [\n    new actions.IotRepublishMqttAction('${topic()}/republish', {\n      qualityOfService: actions.MqttQualityOfService.AT_LEAST_ONCE,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Including Nested CloudFormation Stacks in CDK\nDESCRIPTION: Shows how to include templates that use nested stacks with CfnInclude. This allows working with complex CloudFormation templates that reference child templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst parentTemplate = new cfn_inc.CfnInclude(this, 'ParentStack', {\n  templateFile: 'path/to/my-parent-template.json',\n  loadNestedStacks: {\n    'ChildStack': {\n      templateFile: 'path/to/my-nested-template.json',\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Dedicated SES IP Pool - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to create a dedicated IP pool for Amazon SES via the DedicatedIpPool construct in AWS CDK. The dedicatedIpPoolName must use lowercase letters, digits, underscores, and hyphens (max 64 characters), or an error will be thrown. The scalingMode parameter manages pool scaling. The IP pool is later referenced in SES configuration sets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.DedicatedIpPool(this, 'Pool', {\n  dedicatedIpPoolName: 'mypool',\n  scalingMode: ses.ScalingMode.STANDARD,\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding VPC Subnets for GameLift FleetIQ Game Server Group (TypeScript)\nDESCRIPTION: This code demonstrates explicitly assigning VPC subnets for a GameLift FleetIQ GameServerGroup during creation using AWS CDK, overriding the default behavior of using all supported availability zones. The subnet type is set to PUBLIC; this configuration is immutable post-creation. Prerequisites include provided launch template and VPC; output is a game server group limited to designated subnets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const launchTemplate: ec2.ILaunchTemplate;\ndeclare const vpc: ec2.IVpc;\n\nnew gamelift.GameServerGroup(this, 'GameServerGroup', {\n  gameServerGroupName: 'sample-gameservergroup-name',\n  instanceDefinitions: [{\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  },\n  {\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  }],\n  launchTemplate: launchTemplate,\n  vpc: vpc,\n  vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing IAM Groups by Name in AWS CDK\nDESCRIPTION: Imports an existing IAM group using its name (with path). This allows you to reference and use an existing group in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nconst group = iam.Group.fromGroupName(this, 'MyImportedGroupByName', 'group-name');\n```\n\n----------------------------------------\n\nTITLE: Including a YAML CloudFormation Template in CDK (TypeScript)\nDESCRIPTION: Shows how to use the `CfnInclude` class in TypeScript to include an existing CloudFormation template stored in a YAML file. This is similar to including JSON, just changing the file extension in the `templateFile` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst cfnTemplate = new cfn_inc.CfnInclude(this, 'Template', {\n  templateFile: 'my-template.yaml',\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling UltraWarm Nodes for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet configures an OpenSearch domain to use UltraWarm nodes for cost-effective storage of large amounts of read-only data. It specifies the number of master nodes, warm nodes, and the instance type for the warm nodes within the `capacity` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  capacity: {\n    masterNodes: 2,\n    warmNodes: 2,\n    warmInstanceType: 'ultrawarm1.medium.search',\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for CloudWatch Logs Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a CloudWatch Logs target and input transformation. This allows customizing the payload sent to the log group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetLogGroup: logs.LogGroup;\n\nconst logGroupTarget = new targets.CloudWatchLogsTarget(targetLogGroup, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: logGroupTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating NotificationRule with SNS and Slack Targets in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a NotificationRule for a CodeBuild project, with both SNS and Slack targets. It shows the setup of the project, topic, and Slack channel, as well as the creation and configuration of the notification rule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codestarnotifications/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as notifications from 'aws-cdk-lib/aws-codestarnotifications';\nimport * as codebuild from 'aws-cdk-lib/aws-codebuild';\nimport * as sns from 'aws-cdk-lib/aws-sns';\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\n\nconst project = new codebuild.PipelineProject(this, 'MyProject');\n\nconst topic = new sns.Topic(this, 'MyTopic1');\n\nconst slack = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\n});\n\nconst rule = new notifications.NotificationRule(this, 'NotificationRule', {\n  source: project,\n  events: [\n    'codebuild-project-build-state-succeeded',\n    'codebuild-project-build-state-failed',\n  ],\n  targets: [topic],\n  notificationRuleName: 'MyNotificationRuleName',\n  enabled: true, // The default is true\n  detailType: notifications.DetailType.FULL, // The default is FULL\n  createdBy: 'Jone Doe',\n});\nrule.addTarget(slack);\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project Logging to S3 in TypeScript\nDESCRIPTION: This snippet shows how to configure an AWS CodeBuild project to send its build logs to an AWS S3 bucket using the AWS CDK. A new S3 bucket is created and assigned to the project's logging configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  logging: {\n    s3: {\n      bucket: new s3.Bucket(this, `LogBucket`)\n    }\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AWS Batch Compute Environment Configuration\nDESCRIPTION: Shows the structure of a basic AWS Batch compute environment with two instance types and their vCPU allocations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_25\n\nLANGUAGE: plaintext\nCODE:\n```\nCompute Environment:\n\n1. m5.xlarge => 4 vCPU\n2. m5.2xlarge => 8 vCPU\n```\n\n----------------------------------------\n\nTITLE: Disabling CloudWatch Logging on Firehose Delivery Streams (TypeScript)\nDESCRIPTION: This snippet shows how to disable CloudWatch logging for an S3Bucket destination in a Firehose delivery stream using DisableLogging via the AWS CDK. Dependencies: @aws-cdk/aws-s3, @aws-cdk/aws-kinesisfirehose. Inputs: S3 bucket. Outputs: Firehose that does not publish logs to CloudWatch. This can help reduce log costs or control unwanted logging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst destination = new firehose.S3Bucket(bucket, {\n  loggingConfig: new firehose.DisableLogging(),\n});\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Subnet with IPv4 and IPv6 CIDRs using SubnetV2 in TypeScript\nDESCRIPTION: This example shows how to create a subnet using the SubnetV2 construct. It demonstrates setting IPv4 and IPv6 CIDR blocks, specifying the subnet type as public, and enabling automatic public IP assignment for instances launched in this subnet.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc', {\n  secondaryAddressBlocks: [\n    IpAddresses.amazonProvidedIpv6({ cidrBlockName: 'AmazonProvidedIp'}),\n  ],\n});\n\nnew SubnetV2(this, 'subnetA', {\n  vpc: myVpc,\n  availabilityZone: 'us-east-1a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  ipv6CidrBlock: new IpCidr('2a05:d02c:25:4000::/60'),\n  subnetType: SubnetType.PUBLIC,\n  mapPublicIpOnLaunch: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Dependencies in AWS CDK\nDESCRIPTION: Shows how to specify resource dependencies using the addDependency method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst resourceA = new CfnResource(this, 'ResourceA', resourceProps);\nconst resourceB = new CfnResource(this, 'ResourceB', resourceProps);\n\nresourceB.addDependency(resourceA);\n```\n\n----------------------------------------\n\nTITLE: Suppressing CloudWatch Logs Resource Policy Creation for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet demonstrates how to prevent the automatic creation of a CloudWatch Logs resource policy when enabling logging for an OpenSearch domain by setting `suppressLogsResourcePolicy` to `true`. This is useful to avoid exceeding the regional limit on resource policies, but requires manually creating a suitable policy beforehand.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n  },\n  logging: {\n    auditLogEnabled: true,\n    slowSearchLogEnabled: true,\n    appLogEnabled: true,\n    slowIndexLogEnabled: true,\n  },\n  suppressLogsResourcePolicy: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Weighted Routing in Route53 using AWS CDK\nDESCRIPTION: Demonstrates how to enable weighted routing for an A record in Route53. It uses the weight parameter to specify the routing weight for the record.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecordWeighted1', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4'),\n  weight: 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Attribute Verification Behavior (KeepOriginal) in TypeScript\nDESCRIPTION: This AWS CDK snippet configures a Cognito User Pool's behavior when a user updates their email or phone number. By setting `keepOriginal: { email: true, phone: true }`, the pool retains the previously verified email and phone number as active and usable for sign-in until the newly provided values are successfully verified by the user. It also shows enabling username sign-in and auto-verification for context.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  signInAliases: { username: true },\n  autoVerify: { email: true, phone: true },\n  keepOriginal: {\n    email: true,\n    phone: true,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Alarm on CloudWatch Logs Incoming Bytes in TypeScript\nDESCRIPTION: Creates an alarm based on the IncomingBytes metric to monitor data volume ingested by CloudWatch Logs, triggering when it exceeds 5MB in an evaluation period.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst logGroup = new logs.LogGroup(this, 'MyLogGroup');\nconst incomingBytesMetric = logGroup.metricIncomingBytes();\nnew cloudwatch.Alarm(this, 'HighDataVolumeAlarm', {\n  metric: incomingBytesMetric,\n  threshold: 5000000,  // 5 MB\n  evaluationPeriods: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Kinesis Stream with Custom Name - AWS CDK - TypeScript\nDESCRIPTION: This snippet creates a new Amazon Kinesis stream within an AWS CDK stack, specifying the stream's name via the streamName property. It demonstrates instantiating a kinesis.Stream construct and configuring its identifier. Requires aws-cdk-lib, constructs, and the kinesis module in TypeScript. Inputs are the CDK scope, logical ID, and properties; output is a Stream resource with the given name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kinesis.Stream(this, 'MyFirstStream', {\n  streamName: 'my-awesome-stream',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Canary Schedule with Rate in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a Synthetics Canary to run at a fixed rate using `synthetics.Schedule.rate`. This example sets the canary to run every 5 minutes. This is used within the `schedule` property of the `synthetics.Canary` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst schedule = synthetics.Schedule.rate(Duration.minutes(5)); // Runs every 5 minutes.\n```\n\n----------------------------------------\n\nTITLE: Creating Global Accelerator Route53 Alias Record\nDESCRIPTION: Demonstrates creating a Route53 A-record that aliases to a Global Accelerator with optional health check evaluation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as globalaccelerator from 'aws-cdk-lib/aws-globalaccelerator';\n\ndeclare const zone: route53.HostedZone;\ndeclare const accelerator: globalaccelerator.Accelerator;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(\n    new targets.GlobalAcceleratorTarget(accelerator, {\n      evaluateTargetHealth: true,\n    }),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon EMR Module with AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the EMR module from the aws-cdk-lib for use in TypeScript AWS CDK applications. The import statement allows developers to use L1 constructs for Amazon EMR by referencing definitions provided by the aws-cdk-lib/aws-emr package. No additional configuration or prerequisites are required aside from a working TypeScript AWS CDK environment; this import is typically the first step before defining EMR resources within your application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-emr/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as emr from 'aws-cdk-lib/aws-emr';\n```\n\n----------------------------------------\n\nTITLE: Importing MediaConvert Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the MediaConvert module from the AWS CDK library. It allows access to MediaConvert-related constructs and functionality in a TypeScript project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediaconvert/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediaconvert from 'aws-cdk-lib/aws-mediaconvert';\n```\n\n----------------------------------------\n\nTITLE: Folder Structure for Node with Puppeteer Scripts in AWS Synthetics\nDESCRIPTION: Shows the required folder structure for Node.js with Puppeteer scripts when supplying code via fromAsset() or fromBucket(). The canary requires specific organization of files for proper execution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\ncanary/\n nodejs/\n    node_modules/\n         <filename>.js\n```\n\n----------------------------------------\n\nTITLE: Importing CodeStarConnections Module in TypeScript\nDESCRIPTION: Basic import statement for using AWS CodeStarConnections constructs in an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codestarconnections/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codestarconnections from 'aws-cdk-lib/aws-codestarconnections';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS GameLift Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS GameLift construct library module within an AWS CDK application. It makes the GameLift constructs (primarily L1 at this time) available under the `gamelift` namespace. This is the entry point for using GameLift resources in CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-gamelift/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as gamelift from 'aws-cdk-lib/aws-gamelift';\n```\n\n----------------------------------------\n\nTITLE: Implementing Token-Based Role Mapping\nDESCRIPTION: Shows how to implement token-based role mapping using the cognito:roles or cognito:preferred_role claims from the identity provider.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IdentityPoolProviderUrl } from 'aws-cdk-lib/aws-cognito-identitypool';\n\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  roleMappings: [{\n    providerUrl: IdentityPoolProviderUrl.AMAZON,\n    useToken: true,\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing and Modifying Resources from Nested Stacks\nDESCRIPTION: Shows how to reference and modify resources from included nested stacks in CDK. This enables integration with other CDK constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const childTemplate: cfn_inc.CfnInclude;\n\nconst cfnBucket = childTemplate.getResource('MyBucket') as s3.CfnBucket;\ncfnBucket.bucketName = 'amzn-s3-demo-bucket1';\n\nconst role = new iam.Role(this, 'MyRole', {\n  assumedBy: new iam.AccountRootPrincipal(),\n});\n\nrole.addToPolicy(new iam.PolicyStatement({\n  actions: [\n    's3:GetObject*',\n    's3:GetBucket*',\n    's3:List*',\n  ],\n  resources: [cfnBucket.attrArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Output Configuration\nDESCRIPTION: Creates a Docker image asset with specified output configuration for the build process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  outputs: ['type=local,dest=out'],\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Access Policies Post-Creation using AWS CDK\nDESCRIPTION: Demonstrates adding complex access policies to an already defined `es.Domain` instance using the `addAccessPolicies` method in AWS CDK. This is useful for scenarios like cross-account access (e.g., from Kinesis Firehose), as it allows referencing the domain's ARN (`domain.domainArn`) within the policy statements for more specific resource targeting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_1,\n});\n\ndomain.addAccessPolicies(\n  new iam.PolicyStatement({\n    actions: ['es:ESHttpPost', 'es:ESHttpPut'],\n    effect: iam.Effect.ALLOW,\n    principals: [new iam.AccountPrincipal('123456789012')],\n    resources: [domain.domainArn, `${domain.domainArn}/*`],\n  }),\n  new iam.PolicyStatement({\n    actions: ['es:ESHttpGet'],\n    effect: iam.Effect.ALLOW,\n    principals: [new iam.AccountPrincipal('123456789012')],\n    resources: [\n      `${domain.domainArn}/_all/_settings`,\n      `${domain.domainArn}/_cluster/stats`,\n      `${domain.domainArn}/index-name*/_mapping/type-name`,\n      `${domain.domainArn}/roletest*/_mapping/roletest`,\n      `${domain.domainArn}/_nodes`,\n      `${domain.domainArn}/_nodes/stats`,\n      `${domain.domainArn}/_nodes/*/stats`,\n      `${domain.domainArn}/_stats`,\n      `${domain.domainArn}/index-name*/_stats`,\n      `${domain.domainArn}/roletest*/_stat`,\n    ],\n  }),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CleanRoomsML Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet imports the 'aws-cdk-lib/aws-cleanroomsml' module into a TypeScript AWS CDK project, enabling use of the automatically generated L1 constructs for AWS CleanRoomsML resources. No additional dependencies are required beyond AWS CDK itself and its CleanRoomsML library. This import is essential for referencing any L1 resources tied to AWS CleanRoomsML within a CDK application. No additional parameters are involved; the output is a namespace ('cleanroomsml') that can be used to instantiate or configure AWS CleanRoomsML CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cleanroomsml/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cleanroomsml from 'aws-cdk-lib/aws-cleanroomsml';\n```\n\n----------------------------------------\n\nTITLE: Creating a Pipeline with a Custom Name in TypeScript\nDESCRIPTION: Creates a CodePipeline with a specified human-readable name using the pipelineName property. This makes the pipeline easier to identify in the AWS Console.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Give the Pipeline a nice, human-readable name\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline', {\n  pipelineName: 'MyPipeline',\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to AWS Batch Jobs with Reference Syntax\nDESCRIPTION: Shows how to define and use parameters in AWS Batch job definitions. This example demonstrates defining a parameter and referencing it in the container command using the Ref:: syntax.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nnew batch.EcsJobDefinition(this, 'JobDefn', {\n  parameters: { echoParam: 'foobar' },\n  container: new batch.EcsEc2ContainerDefinition(this, 'containerDefn', {\n    image: ecs.ContainerImage.fromRegistry('public.ecr.aws/amazonlinux/amazonlinux:latest'),\n    memory: cdk.Size.mebibytes(2048),\n    cpu: 256,\n    command: [\n      'echo',\n      'Ref::echoParam',\n    ],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Pre/Post Traffic Hooks to Lambda Deployment Group in TypeScript\nDESCRIPTION: Illustrates how to add PreTraffic and PostTraffic hooks to an AWS CodeDeploy LambdaDeploymentGroup using AWS CDK. These hooks are Lambda functions executed before traffic shifting begins and after it completes, respectively. They allow running custom logic like integration tests (PreTraffic) or end-to-end validation (PostTraffic) to control the deployment outcome. The example shows adding hooks during creation and to an existing group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const warmUpUserCache: lambda.Function;\ndeclare const endToEndValidation: lambda.Function;\ndeclare const alias: lambda.Alias;\n\n// pass a hook whe creating the deployment group\nconst deploymentGroup = new codedeploy.LambdaDeploymentGroup(this, 'BlueGreenDeployment', {\n  alias: alias,\n  deploymentConfig: codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE,\n  preHook: warmUpUserCache,\n});\n\n// or configure one on an existing deployment group\ndeploymentGroup.addPostHook(endToEndValidation);\n```\n\n----------------------------------------\n\nTITLE: Importing an IAM User by Attributes with AWS CDK (TypeScript)\nDESCRIPTION: Shows how to import an IAM user based on a set of attributes, such as ARN, providing more flexibility in how users are referenced. Requires an attribute object, usually at least `userArn`; outputs an imported user. Useful for cross-account scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = iam.User.fromUserAttributes(this, 'MyImportedUserByAttributes', {\\n  userArn: 'arn:aws:iam::123456789012:user/johnsmith',\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring KMS Encryption (Auto Key) for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet demonstrates configuring server-side encryption with an AWS KMS key (SSE-KMS) for an AWS Glue S3 Table using AWS CDK. By setting `encryption` to `glue.TableEncryption.KMS`, AWS CDK automatically creates and manages a KMS key for encrypting the table's data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\n// KMS key is created automatically\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.KMS,\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Provider URLs\nDESCRIPTION: Demonstrates how to configure role mappings using custom provider URLs for non-standard identity providers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IdentityPoolProviderUrl } from 'aws-cdk-lib/aws-cognito-identitypool';\n\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  roleMappings: [\n    {\n      providerUrl: IdentityPoolProviderUrl.custom('my-custom-provider.com'),\n      useToken: true,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Sparkline in SingleValueWidget (TypeScript)\nDESCRIPTION: Demonstrates setting the sparkline property to true in SingleValueWidget to show a small trend graph beneath the value. Requires Dashboard and SingleValueWidget constructs from aws-cdk-lib/aws-cloudwatch. Cannot be used simultaneously with setPeriodToTimeRange: true.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.SingleValueWidget({\n  metrics: [ /* ... */ ],\n\n  sparkline: true,\n}));\n```\n\n----------------------------------------\n\nTITLE: Importing an existing EC2/on-premise CodeDeploy Application in TypeScript\nDESCRIPTION: Imports an already existing CodeDeploy Application for EC2/on-premise deployments using the fromServerApplicationName static method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = codedeploy.ServerApplication.fromServerApplicationName(\n  this,\n  'ExistingCodeDeployApplication',\n  'MyExistingApplication',\n);\n```\n\n----------------------------------------\n\nTITLE: WebSocket Lambda Integration Implementation\nDESCRIPTION: Shows how to integrate a WebSocket API route with a Lambda function. Configures a sendMessage route that forwards requests to a Lambda function when clients connect/disconnect or send messages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nnew apigwv2.WebSocketStage(this, 'mystage', {\n  webSocketApi,\n  stageName: 'dev',\n  autoDeploy: true,\n});\n\ndeclare const messageHandler: lambda.Function;\nwebSocketApi.addRoute('sendMessage', {\n  integration: new WebSocketLambdaIntegration('SendMessageIntegration', messageHandler),\n});\n```\n\n----------------------------------------\n\nTITLE: Finding CloudFormation Outputs Matching Properties in TypeScript\nDESCRIPTION: Illustrates using `findOutputs()` to retrieve a map of CloudFormation Outputs that match a given logical ID (or `*` for all) and properties. The result is a map where keys are the logical IDs of the matching outputs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst result = template.findOutputs('*', { Value: 'Fred' });\nexpect(result.Foo).toEqual({ Value: 'Fred', Description: 'FooFred' });\nexpect(result.Bar).toEqual({ Value: 'Fred', Description: 'BarFred' });\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Partition Index to an Existing Glue Table in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a partition index to an already defined AWS Glue Table (`myTable`) using the `addPartitionIndex` method in AWS CDK. It requires an existing `glue.Table` instance and specifies the index details, including an optional `indexName` and the `keyNames`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myTable: glue.Table;\nmyTable.addPartitionIndex({\n  indexName: 'my-index',\n  keyNames: ['year'],\n});\n```\n\n----------------------------------------\n\nTITLE: Provisioning ACM Certificate with Specific Key Algorithm - AWS CDK - TypeScript\nDESCRIPTION: The code provisions an ACM certificate specifying the key algorithm (e.g., EC_PRIME256V1) using AWS CDK. Inputs include domain name and keyAlgorithm (choices are RSA_2048, EC_prime256v1, EC_secp384r1). Outputs a certificate with the desired key type. Dependencies: aws-cdk-lib/aws-certificatemanager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-certificatemanager/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew acm.Certificate(this, 'Certificate', {\n  domainName: 'test.example.com',\n  keyAlgorithm: acm.KeyAlgorithm.EC_PRIME256V1,\n});\n```\n\n----------------------------------------\n\nTITLE: Auto Scaling SageMaker Endpoint Variant Provisioned Concurrency in TypeScript\nDESCRIPTION: This example demonstrates configuring autoscaling for the provisioned concurrency of an AWS SageMaker endpoint variant. It defines a `ScalableTarget` for the specific variant using its resource ID (`endpoint/MyEndpoint/variant/MyVariant`) and the `sagemaker:variant:DesiredProvisionedConcurrency` dimension. Target tracking scaling is then configured to maintain the `SAGEMAKER_VARIANT_PROVISIONED_CONCURRENCY_UTILIZATION` metric at 90%.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst target = new appscaling.ScalableTarget(this, 'SageMakerVariantScalableTarget', {\n  serviceNamespace: appscaling.ServiceNamespace.SAGEMAKER,\n  scalableDimension: 'sagemaker:variant:DesiredProvisionedConcurrency',\n  minCapacity: 2,\n  maxCapacity: 10,\n  resourceId: 'endpoint/MyEndpoint/variant/MyVariant',\n});\n\ntarget.scaleToTrackMetric('SageMakerVariantProvisionedConcurrencyUtilization', {\n  targetValue: 0.9,\n  predefinedMetric: appscaling.PredefinedMetric.SAGEMAKER_VARIANT_PROVISIONED_CONCURRENCY_UTILIZATION,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudFront OAC with List Permission in AWS CDK (TypeScript)\nDESCRIPTION: Shows an AWS CDK TypeScript example for configuring an S3 bucket origin using `S3BucketOrigin.withOriginAccessControl` and specifying `AccessLevel.LIST` alongside `AccessLevel.READ` in the `originAccessLevels` property. This grants the CloudFront distribution `s3:ListBucket` permission on the S3 bucket, enabling it to return 404 Not Found errors for missing objects instead of the default 403 Forbidden. Setting `defaultRootObject` is recommended when using this configuration. Dependencies include `aws-cdk-lib/aws-s3`, `aws-cdk-lib/aws-cloudfront`, and `aws-cdk-lib/aws-cloudfront-origins`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst s3Origin = origins.S3BucketOrigin.withOriginAccessControl(myBucket, {\n  originAccessLevels: [cloudfront.AccessLevel.READ, cloudfront.AccessLevel.LIST],\n});\nnew cloudfront.Distribution(this, 'distribution', {\n  defaultBehavior: {\n    origin: s3Origin,\n  },\n  defaultRootObject: 'index.html', // recommended to specify\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions on a KMS-encrypted Secret - AWS CDK TypeScript\nDESCRIPTION: Demonstrates how to grant both Secrets Manager access and KMS key permissions for an IAM Role on a secret encrypted with a specific KMS Key. The CDK ensures proper permission propagation across both resources. Dependencies: aws-cdk-lib/aws-secretsmanager, aws-cdk-lib/aws-iam, aws-cdk-lib/aws-kms. Expects defined Role, Key, and Secret; handles cross-account access use cases.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\nconst key = new kms.Key(this, 'KMS');\nconst secret = new secretsmanager.Secret(this, 'Secret', { encryptionKey: key });\nsecret.grantRead(role);\nsecret.grantWrite(role);\n```\n\n----------------------------------------\n\nTITLE: Configuring Neptune Logging with CloudWatch Integration\nDESCRIPTION: Demonstrates how to enable audit logging in Neptune and configure logs to be exported to CloudWatch Logs with a custom retention period.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Cluster parameter group with the neptune_enable_audit_log param set to 1\nconst clusterParameterGroup = new neptune.ClusterParameterGroup(this, 'ClusterParams', {\n  description: 'Cluster parameter group',\n  parameters: {\n    neptune_enable_audit_log: '1'\n  },\n});\n\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  // Audit logs are enabled via the clusterParameterGroup\n  clusterParameterGroup,\n  // Optionally configuring audit logs to be exported to CloudWatch Logs\n  cloudwatchLogsExports: [neptune.LogType.AUDIT],\n  // Optionally set a retention period on exported CloudWatch Logs\n  cloudwatchLogsRetention: logs.RetentionDays.ONE_MONTH,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding EventBridge Event Destination to SES Configuration Set - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates configuring SES event publishing to Amazon EventBridge using AWS CDK. A default event bus is retrieved by name and passed as a destination for the configuration set. This enables orchestration and automation via EventBridge rules. Requires the ConfigurationSet construct and an existing EventBus.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as events from 'aws-cdk-lib/aws-events';\n\ndeclare const myConfigurationSet: ses.ConfigurationSet;\n\nconst bus = events.EventBus.fromEventBusName(this, 'EventBus', 'default');\n\nmyConfigurationSet.addEventDestination('ToEventBus', {\n  destination: ses.EventDestination.eventBus(bus),\n})\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Security Hub Module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Security Hub module (`aws-securityhub`) from the `aws-cdk-lib` library in a TypeScript CDK project. This import makes the Security Hub L1 constructs available for use in defining Security Hub resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-securityhub/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as securityhub from 'aws-cdk-lib/aws-securityhub';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Deadline Module in TypeScript\nDESCRIPTION: Basic import statement for accessing the AWS Deadline module within a CDK application. This allows you to work with AWS Deadline resources using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-deadline/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as deadline from 'aws-cdk-lib/aws-deadline';\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing CodeBuild Fleet in TypeScript\nDESCRIPTION: This snippet shows how to configure an AWS CodeBuild project to use an existing reserved capacity fleet by importing it using its ARN. This allows sharing fleet resources across multiple CDK stacks or projects.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    fleet: codebuild.Fleet.fromFleetArn(\n      this, 'SharedFleet',\n      'arn:aws:codebuild:us-east-1:123456789012:fleet/MyFleet:ed0d0823-e38a-4c10-90a1-1bf25f50fa76',\n    ),\n    buildImage: codebuild.LinuxBuildImage.STANDARD_7_0,\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Extension with SQS Destination using AWS CDK in TypeScript\nDESCRIPTION: This snippet illustrates creating an AWS AppConfig `Extension` where the event destination for the `ON_DEPLOYMENT_START` action point is an Amazon SQS queue. It uses `appconfig.SqsDestination` to specify the target queue. Requires an `sqs.Queue` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const queue: sqs.Queue;\n\nnew appconfig.Extension(this, 'MyExtension', {\n  actions: [\n    new appconfig.Action({\n      actionPoints: [appconfig.ActionPoint.ON_DEPLOYMENT_START],\n      eventDestination: new appconfig.SqsDestination(queue),\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Interface VPC Endpoint Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to an Interface VPC Endpoint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const zone: route53.HostedZone;\ndeclare const interfaceVpcEndpoint: ec2.InterfaceVpcEndpoint;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.InterfaceVpcEndpointTarget(interfaceVpcEndpoint)),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Local Secondary Indexes for DynamoDB TableV2 via Property in TypeScript\nDESCRIPTION: This snippet shows how to define Local Secondary Indexes (LSIs) for a DynamoDB TableV2 by providing an array to the `localSecondaryIndexes` property during table instantiation. Defining LSIs requires the table to have a `sortKey` defined. Each LSI shares the table's partition key but uses a specified `sortKey`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n  localSecondaryIndexes: [\n    {\n      indexName: 'lsi',\n      sortKey: { name: 'sk', type: dynamodb.AttributeType.NUMBER },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing S3 Model Data for SageMaker with TypeScript\nDESCRIPTION: This snippet shows how to reference model data stored in an S3 bucket for use in a SageMaker model using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\nconst bucket = new s3.Bucket(this, 'MyBucket');\nconst modelData = sagemaker.ModelData.fromBucket(bucket, 'path/to/artifact/file.tar.gz');\n```\n\n----------------------------------------\n\nTITLE: Manual KMS Key Policy Statement for Imported Keys with OAC (JSON)\nDESCRIPTION: Specifies the IAM policy statement that needs to be manually added to an imported KMS key's policy to enable CloudFront OAC access for SSE-KMS encryption. This is required because AWS CDK cannot modify imported resources. The statement grants `kms:Decrypt`, `kms:Encrypt`, and `kms:GenerateDataKey*` permissions to the CloudFront service, conditioned on the specific distribution's `AWS:SourceArn` using `StringEquals`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Sid\": \"AllowCloudFrontServicePrincipalSSE-KMS\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n        \"Service\": [\n            \"cloudfront.amazonaws.com\"\n        ]\n     },\n    \"Action\": [\n        \"kms:Decrypt\",\n        \"kms:Encrypt\",\n        \"kms:GenerateDataKey*\"\n    ],\n    \"Resource\": \"*\",\n    \"Condition\": {\n            \"StringEquals\": {\n                \"AWS:SourceArn\": \"arn:aws:cloudfront::111122223333:distribution/<CloudFront distribution ID>\"\n            }\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Using API Gateway REST API as Pipe Enrichment in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe that uses an API Gateway REST API as an enrichment. Note that only REST APIs are supported by EventBridge Pipes, HTTP APIs are not supported.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-enrichments-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\ndeclare const restApi: apigateway.RestApi;\n\nconst enrichment = new enrichments.ApiGatewayEnrichment(restApi);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SomeSource(sourceQueue),\n  enrichment,\n  target: new SomeTarget(targetQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Schedule Group (AWS CDK, TypeScript)\nDESCRIPTION: Demonstrates how to retrieve the default schedule group from Amazon EventBridge Scheduler using the CDK ScheduleGroup construct. This is typically used to organize schedules logically and manage group-level permissions. Input is the CDK scope, output is a reference to the default schedule group resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultScheduleGroup = ScheduleGroup.fromDefaultScheduleGroup(this, \"DefaultGroup\");\n```\n\n----------------------------------------\n\nTITLE: Creating a BitBucket Source Action in CodePipeline\nDESCRIPTION: This snippet demonstrates how to use a BitBucket Git repository as a source in CodePipeline using the CodeStar Connections source action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeStarConnectionsSourceAction({\n  actionName: 'BitBucket_Source',\n  owner: 'aws',\n  repo: 'aws-cdk',\n  output: sourceOutput,\n  connectionArn: 'arn:aws:codestar-connections:us-east-1:123456789012:connection/12345678-abcd-12ab-34cdef5678gh',\n});\n```\n\n----------------------------------------\n\nTITLE: Monitoring SageMaker Endpoint Metrics with TypeScript\nDESCRIPTION: This snippet shows how to monitor CloudWatch metrics for a SageMaker endpoint production variant using the CDK. It demonstrates creating an alarm for the model latency metric.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const endpointConfig: sagemaker.EndpointConfig;\n\nconst endpoint = new sagemaker.Endpoint(this, 'Endpoint', { endpointConfig });\nconst productionVariant = endpoint.findInstanceProductionVariant('my-variant');\nproductionVariant.metricModelLatency().createAlarm(this, 'ModelLatencyAlarm', {\n  threshold: 100000,\n  evaluationPeriods: 3,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding an HTTPS Subscription using CloudFormation Parameter Token in TypeScript\nDESCRIPTION: Demonstrates subscribing an SNS topic to an HTTPS endpoint where the URL is determined at deploy time via a CloudFormation parameter. Depends on aws-cdk-lib/aws-sns, aws-cdk-lib/aws-sns-subscriptions, and aws-cdk-lib/aws-cloudformation. This approach allows dynamic endpoint configuration, making the deployment more flexible to different environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'MyTopic');\nconst url = new CfnParameter(this, 'url-param');\n\nmyTopic.addSubscription(new subscriptions.UrlSubscription(url.valueAsString));\n```\n\n----------------------------------------\n\nTITLE: Adding a DS Record to a Route53 Hosted Zone using AWS CDK\nDESCRIPTION: Demonstrates how to add a DS (Delegation Signer) record to a Route53 hosted zone. It specifies the zone, record name, DS values, and TTL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.DsRecord(this, 'DSRecord', {\n  zone: myZone,\n  recordName: 'foo',\n  values: [\n    '12345 3 1 123456789abcdef67890123456789abcdef67890',\n  ],\n  ttl: Duration.minutes(90),       // Optional - default is 30 minutes\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching IAM Role to Redshift Cluster via Method using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to attach an additional IAM role to an existing AWS Redshift cluster instance using the `addIamRole` method in AWS CDK. An IAM role is created, and then the `addIamRole` method is called on the cluster object to associate the role. This allows dynamically adding permissions to the cluster after its initial creation. Requires an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n});\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n});\ncluster.addIamRole(role);\n```\n```\n\n----------------------------------------\n\nTITLE: Importing KMS Key by ARN Using AWS CDK in TypeScript\nDESCRIPTION: Imports an existing KMS key into the CDK application using its ARN. This allows external or pre-existing keys to be used in the stack. Once imported, operations like adding aliases are permitted; however, modifying the key's resource policy is a no-op (as the stack does not own the key). Requires the 'aws-cdk-lib/aws-kms' module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myKeyImported = kms.Key.fromKeyArn(this, 'MyImportedKey', 'arn:aws:...');\n\n// you can do stuff with this imported key.\nmyKeyImported.addAlias('alias/foo');\n```\n\n----------------------------------------\n\nTITLE: Implementing IAM Authorizer with Grant Syntax in AWS CDK - TypeScript\nDESCRIPTION: This example demonstrates using the built-in IAM authorizer in AWS CDK for controlling access to HTTP API routes. The snippet shows defaultAuthorizer assignment using HttpIamAuthorizer, and how to grant invoke permissions via the grantInvoke method for a specific principal. Dependencies include aws-cdk-lib/aws-apigatewayv2-authorizers and aws-cdk-lib/aws-apigatewayv2-integrations. Input requires an IAM principal and API integration; output ensures only authorized IAM entities can invoke API operations on protected routes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const principal: iam.AnyPrincipal;\n\nconst authorizer = new HttpIamAuthorizer();\n\nconst httpApi = new apigwv2.HttpApi(this, 'HttpApi', {\n  defaultAuthorizer: authorizer,\n});\n\nconst routes = httpApi.addRoutes({\n  integration: new HttpUrlIntegration('BooksIntegration', 'https://get-books-proxy.example.com'),\n  path: '/books/{book}',\n});\n\nroutes[0].grantInvoke(principal);\n```\n\n----------------------------------------\n\nTITLE: Enabling Version Upgrades for OpenSearch Domain\nDESCRIPTION: Creates an OpenSearch domain with version upgrade capability enabled to allow version updates without domain replacement.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst devDomain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  enableVersionUpgrade: true, // defaults to false\n});\n```\n\n----------------------------------------\n\nTITLE: Creating EKS Cluster with Default Managed Node Group\nDESCRIPTION: Creates an EKS cluster with default managed node group configuration using 2 m5.large instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nnew eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.NODEGROUP,\n});\n```\n\n----------------------------------------\n\nTITLE: Associating a CloudFormation Stack with an AppRegistry Application in TypeScript\nDESCRIPTION: Associates a CloudFormation stack, defined within the CDK application, with an AppRegistry Application using the `associateApplicationWithStack` method. This groups relevant stacks under an application for better insights. Requires an `App` and `Stack` instance from `aws-cdk-lib` and an existing `appreg.Application` instance. A stack can only be associated with one application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst app = new App();\nconst myStack = new Stack(app, 'MyStack');\n\ndeclare const application: appreg.Application;\napplication.associateApplicationWithStack(myStack);\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Choice-Based Authentication in Cognito User Pool with TypeScript\nDESCRIPTION: This snippet demonstrates configuring a Cognito User Pool for choice-based authentication, allowing multiple sign-in methods. It enables standard password authentication, email OTP, SMS OTP, and passkey sign-in by setting the corresponding flags in `allowedFirstAuthFactors` within the `signInPolicy`. It also shows adding a user pool client configured for the `USER_AUTH` flow, which is necessary for these authentication methods. Note that SMS OTP requires account activation and choice-based authentication requires an Essentials or higher feature plan.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst userPool = new cognito.UserPool(this, 'myuserpool', {\n  signInPolicy: {\n    allowedFirstAuthFactors: {\n      password: true, // password authentication must be enabled\n      emailOtp: true, // enables email message one-time password\n      smsOtp: true,   // enables SMS message one-time password\n      passkey: true,  // enables passkey sign-in\n    },\n  },\n});\n\n// You should also configure the user pool client with USER_AUTH authentication flow allowed\nuserPool.addClient('myclient', {\n  authFlows: { user: true },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Replica Regions to Secrets Using addReplicaRegion()\nDESCRIPTION: This example demonstrates an alternative approach to replicating secrets by first creating the secret and then adding replica regions using the addReplicaRegion() method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst secret = new secretsmanager.Secret(this, 'Secret');\nsecret.addReplicaRegion('eu-west-1');\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Bucket Website Route53 Alias Record\nDESCRIPTION: Demonstrates creating a Route53 A-record that aliases to an S3 bucket configured for static website hosting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst recordName = 'www';\nconst domainName = 'example.com';\n\nconst bucketWebsite = new s3.Bucket(this, 'BucketWebsite', {\n  bucketName: [recordName, domainName].join('.'), // www.example.com\n  publicReadAccess: true,\n  websiteIndexDocument: 'index.html',\n});\n\nconst zone = route53.HostedZone.fromLookup(this, 'Zone', { domainName }); // example.com\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  recordName, // www\n  target: route53.RecordTarget.fromAlias(\n    new targets.BucketWebsiteTarget(bucketWebsite, {\n      evaluateTargetHealth: true,\n    }),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Dead-Letter Queue for EventBus in AWS CDK\nDESCRIPTION: Sets up an SQS queue as a dead-letter queue for an EventBus to capture events that fail to be delivered to targets. This requires importing the SQS module and creating both a queue and EventBus resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\n\nconst dlq = new sqs.Queue(this, 'DLQ');\n\nconst bus = new events.EventBus(this, 'Bus', {\n  deadLetterQueue: dlq,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoT Greengrass Module with AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to import the AWS IoT Greengrass construct module from aws-cdk-lib in a TypeScript project. It is required to enable usage of Greengrass L1 constructs within the AWS CDK infrastructure-as-code workflow. The import statement is foundational and should be placed at the top of any TypeScript file that plans to use Greengrass CloudFormation resources through CDK. Prerequisites include installing aws-cdk-lib as a dependency in the project. No direct parameters are used, and the expected result is the availability of the greengrass namespace for defining Greengrass constructs. This import is strictly for TypeScript-based CDK development.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-greengrass/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as greengrass from 'aws-cdk-lib/aws-greengrass';\n```\n\n----------------------------------------\n\nTITLE: Highlighting TableWidget Cells with Thresholds (TypeScript)\nDESCRIPTION: Illustrates the use of the thresholds property to highlight table cells based on value, using TableThreshold and Color helpers in AWS CDK. Requires cloudwatch.TableThreshold and cloudwatch.Color imports. Highlights cells red, orange, or green depending on their value range.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  // ...\n  \n  thresholds: [\n    cloudwatch.TableThreshold.above(1000, cloudwatch.Color.RED),\n    cloudwatch.TableThreshold.between(500, 1000, cloudwatch.Color.ORANGE),\n    cloudwatch.TableThreshold.below(500, cloudwatch.Color.GREEN),\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Changing the Deployment Controller for ApplicationLoadBalancedFargateService (TypeScript)\nDESCRIPTION: Demonstrates how to specify a custom deployment controller (e.g., CODE_DEPLOY) when creating ApplicationLoadBalancedFargateService. This feature provides control over the update and deployment process for ECS services, enabling advanced deployment strategies such as blue/green using AWS CodeDeploy. Dependencies include the ECS cluster and ECS Patterns modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedFargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 1024,\n  desiredCount: 1,\n  cpu: 512,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  minHealthyPercent: 100,\n  deploymentController: {\n    type: ecs.DeploymentControllerType.CODE_DEPLOY,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS RAM Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Resource Access Manager (RAM) module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ram/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as ram from 'aws-cdk-lib/aws-ram';\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Replica Provisioned Billing\nDESCRIPTION: Shows how to configure different provisioned billing settings for each replica.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.provisioned({\n    readCapacity: dynamodb.Capacity.fixed(10),\n    writeCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 15 }),\n  }),\n  replicas: [\n    {\n      region: 'us-east-1',\n    },\n    {\n      region: 'us-east-2',\n      readCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 20, targetUtilizationPercent: 50 }),\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Preventing User Existence Errors in Cognito App Client (TypeScript)\nDESCRIPTION: This snippet configures an AWS Cognito App Client to prevent user existence errors during authentication attempts. Setting `preventUserExistenceErrors` to `true` makes Cognito return generic failure messages instead of specific 'UserNotFoundException' errors, enhancing security.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  preventUserExistenceErrors: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Behavior to Existing CloudFront Distribution\nDESCRIPTION: This snippet shows how to add a custom behavior to an existing CloudFront distribution. It overrides the default viewer protocol policy for a specific path pattern ('/images/*.jpg') and sets it to REDIRECT_TO_HTTPS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Add a behavior to a Distribution after initial creation.\ndeclare const myBucket: s3.Bucket;\ndeclare const myWebDistribution: cloudfront.Distribution;\nmyWebDistribution.addBehavior('/images/*.jpg', new origins.S3Origin(myBucket), {\n  viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Billing Mode Change with Seed Capacity\nDESCRIPTION: Demonstrates how to configure seed capacity when changing billing modes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst globalTable = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.provisioned({\n    readCapacity: dynamodb.Capacity.fixed(10),\n    writeCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 10, seedCapacity: 20 }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing CDK Constructs using Classic Import Style (TypeScript)\nDESCRIPTION: Demonstrates the classic import method in TypeScript for AWS CDK. It imports core classes like `Stack` and `App` directly from `aws-cdk-lib`, along with specific service modules (e.g., `aws_s3` aliased as `s3`). It then instantiates an App, a Stack, and an S3 Bucket within that stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport { Stack, App, aws_s3 as s3 } from 'aws-cdk-lib';\n\nconst app = new App();\nconst stack = new Stack(app, 'TestStack');\n\nnew s3.Bucket(stack, 'TestBucket');\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Custom KMS Decrypt Permissions for S3 BucketDeployment Handler (TypeScript)\nDESCRIPTION: This example shows how to grant explicit KMS permissions to the Lambda handler role created by a BucketDeployment if the source S3 bucket is encrypted with a customer-managed KMS key. This is vital when the default S3 managed key policy does not suffice. Requires the IAM and S3 modules from the AWS CDK, and the encryption key ARN. The key elements are a call to addToPolicy with the correct actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\n\nconst deployment = new s3deploy.BucketDeployment(this, 'DeployFiles', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'source-files'))],\n  destinationBucket,\n});\n\ndeployment.handlerRole.addToPolicy(\n  new iam.PolicyStatement({\n    actions: ['kms:Decrypt', 'kms:DescribeKey'],\n    effect: iam.Effect.ALLOW,\n    resources: ['<encryption key ARN>'],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Endpoint Service Private DNS in TypeScript\nDESCRIPTION: Sets up a private DNS configuration for a VPC endpoint service to use a custom domain instead of the default AWS-generated endpoint hostname. This resolves certificate validation issues with HTTPS traffic and requires domain ownership verification.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NetworkLoadBalancer } from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\nconst vpc = new ec2.Vpc(this, 'VPC');\nconst nlb = new NetworkLoadBalancer(this, 'NLB', {\n  vpc,\n});\nconst vpces = new ec2.VpcEndpointService(this, 'VPCES', {\n  vpcEndpointServiceLoadBalancers: [nlb],\n});\n// You must use a public hosted zone so domain ownership can be verified\nconst zone = new route53.PublicHostedZone(this, 'PHZ', {\n  zoneName: 'aws-cdk.dev',\n});\nnew route53.VpcEndpointServiceDomainName(this, 'EndpointDomain', {\n  endpointService: vpces,\n  domainName: 'my-stuff.aws-cdk.dev',\n  publicHostedZone: zone,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS FMS L1 Construct Library in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS Firewall Manager (FMS) module from the AWS CDK library. This import provides access to the low-level (L1) constructs corresponding to AWS::FMS CloudFormation resources, allowing programmatic definition of FMS resources within a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fms/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as fms from 'aws-cdk-lib/aws-fms';\n```\n\n----------------------------------------\n\nTITLE: Creating a Jenkins Action in AWS CodePipeline\nDESCRIPTION: Creates a Jenkins build action that can be added to a CodePipeline stage. This connects the pipeline to a specific Jenkins project and specifies the action type (build in this case).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const jenkinsProvider: codepipeline_actions.JenkinsProvider;\nconst buildAction = new codepipeline_actions.JenkinsAction({\n  actionName: 'JenkinsBuild',\n  jenkinsProvider: jenkinsProvider,\n  projectName: 'MyProject',\n  type: codepipeline_actions.JenkinsActionType.BUILD,\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Redshift Privileges (App 1 - Creation) using AWS CDK\nDESCRIPTION: Illustrates the first part of a scenario showing potential privilege management conflicts across different CDK applications. This snippet creates a Redshift user and table, then grants `INSERT` permission on the table to the user. Requires `User`, `Table`, and `TableAction` imports, and an existing `cluster` object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nconst databaseName = 'databaseName';\nconst username = 'myuser'\nconst tableName = 'mytable'\n\nconst user = new User(this, 'User', {\n  username: username,\n  cluster: cluster,\n  databaseName: databaseName,\n});\nconst table = new Table(this, 'Table', {\n  tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n  cluster: cluster,\n  databaseName: databaseName,\n});\ntable.grant(user, TableAction.INSERT);\n```\n```\n\n----------------------------------------\n\nTITLE: Using a CloudWatch SEARCH Expression in MathExpression (TypeScript)\nDESCRIPTION: Illustrates creating a `cloudwatch.MathExpression` that utilizes a CloudWatch SEARCH function. This expression searches for all 'CPUUtilization' metrics within the 'AWS/EC2' namespace having an 'InstanceId' dimension, aggregates them using 'Average' over a 300-second period. The label is suppressed to show individual metric labels instead.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst cpuUtilization = new cloudwatch.MathExpression({\n  expression: \"SEARCH('{AWS/EC2,InstanceId} MetricName=\\\"CPUUtilization\\\"', 'Average', 300)\",\n\n  // Specifying '' as the label suppresses the default behavior\n  // of using the expression as metric label. This is especially appropriate\n  // when using expressions that return multiple time series (like SEARCH()\n  // or METRICS()), to show the labels of the retrieved metrics only.\n  label: '',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Existing FSx Lustre File System and VPC Resources in TypeScript\nDESCRIPTION: This example demonstrates how to import an existing FSx for Lustre file system and associated network resources into an AWS CDK app using the fromLustreFileSystemAttributes and fromVpcAttributes static methods. It requires identifiers for the security group, file system DNS name, file system ID, subnet IDs, and VPC ID. Allows subsequent attachment and network permission configuration for new EC2 instances. Outputs construct references for VPC, security group, and FSx resources that can be further configured.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst sg = ec2.SecurityGroup.fromSecurityGroupId(this, 'FsxSecurityGroup', '{SECURITY-GROUP-ID}');\nconst fs = fsx.LustreFileSystem.fromLustreFileSystemAttributes(this, 'FsxLustreFileSystem', {\n  dnsName: '{FILE-SYSTEM-DNS-NAME}',\n  fileSystemId: '{FILE-SYSTEM-ID}',\n  securityGroup: sg,\n});\n\nconst vpc = ec2.Vpc.fromVpcAttributes(this, 'Vpc', {\n  availabilityZones: ['us-west-2a', 'us-west-2b'],\n  publicSubnetIds: ['{US-WEST-2A-SUBNET-ID}', '{US-WEST-2B-SUBNET-ID}'],\n  vpcId: '{VPC-ID}',\n});\n\nconst inst = new ec2.Instance(this, 'inst', {\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.LARGE),\n  machineImage: new ec2.AmazonLinuxImage({\n    generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,\n  }),\n  vpc,\n  vpcSubnets: {\n    subnetType: ec2.SubnetType.PUBLIC,\n  },\n});\n\nfs.connections.allowDefaultPortFrom(inst);\n```\n\n----------------------------------------\n\nTITLE: Quoting or MIME-Encoding Invalid 'fromName' in SES UserPool Email - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates handling non-compliant 'fromName' values in SES configuration for UserPool emails. If 'fromName' does not satisfy RFC 5322 atom or quoted-string, Cognito will quote or MIME-encode it automatically. Input is a possibly non-compliant 'fromName' and 'fromEmail'; output is a formatted RFC 5322 compliant sender header.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  email: cognito.UserPoolEmail.withSES({\n    fromEmail: 'noreply@myawesomeapp.com',\n    fromName: 'myname@mycompany.com',\n  }),\n});\n// => From: \"myname@mycompany.com\" <noreply@myawesomeapp.com>\n```\n\n----------------------------------------\n\nTITLE: Using an Existing IAM Role for CodeCommit Source Action\nDESCRIPTION: This snippet shows how to use an existing IAM role for the CodeCommit source action's event rule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst eventRole = iam.Role.fromRoleArn(this, 'Event-role', 'roleArn');\ndeclare const repo: codecommit.Repository;\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository: repo,\n  output: new codepipeline.Artifact(),\n  eventRole,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Full Precision in SingleValueWidget (TypeScript)\nDESCRIPTION: Shows how to use the fullPrecision property with SingleValueWidget to display as many digits as possible in the cell without rounding. Requires Dashboard and SingleValueWidget constructs. The metrics array must contain the target metrics, and full precision display of values is enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.SingleValueWidget({\n  metrics: [ /* ... */ ],\n\n  fullPrecision: true,\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Connection Pools in App Mesh\nDESCRIPTION: Demonstrates how to add connection pools to both Virtual Node and Virtual Gateway listeners. Includes configuration for HTTP and gRPC connection pool settings with maximum connections and pending requests limits.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('node', appmesh.DnsResponseType.ENDPOINTS),\n  listeners: [appmesh.VirtualNodeListener.http({\n    port: 80,\n    connectionPool: {\n      maxConnections: 100,\n      maxPendingRequests: 10,\n    },\n  })],\n});\n\nconst gateway = new appmesh.VirtualGateway(this, 'gateway', {\n  mesh,\n  listeners: [appmesh.VirtualGatewayListener.grpc({\n    port: 8080,\n    connectionPool: {\n      maxRequests: 10,\n    },\n  })],\n  virtualGatewayName: 'gateway',\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Default Warm Pool to an AutoScalingGroup in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a warm pool with default settings to an existing AWS Auto Scaling Group using the AWS CDK. It calls the `addWarmPool()` method on an `AutoScalingGroup` instance. A dependency is a pre-declared `autoScalingGroup` variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const autoScalingGroup: autoscaling.AutoScalingGroup;\n\nautoScalingGroup.addWarmPool();\n```\n```\n\n----------------------------------------\n\nTITLE: Sharing an AppRegistry Attribute Group with Principals in TypeScript\nDESCRIPTION: Shares an AppRegistry Attribute Group with specific AWS accounts, AWS Organizations (or OUs via ARN), IAM roles, and IAM users using the `shareAttributeGroup` method. Requires an existing `appreg.AttributeGroup` instance, IAM principal instances (`iam.IRole`, `iam.IUser`), and AWS Organizations to be enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const attributeGroup: appreg.AttributeGroup;\ndeclare const myRole: iam.IRole;\ndeclare const myUser: iam.IUser;\nattributeGroup.shareAttributeGroup('MyShareId', {\n  name: 'MyShare',\n  accounts: ['123456789012'],\n  organizationArns: ['arn:aws:organizations::123456789012:organization/o-my-org-id'],\n  roles: [myRole],\n  users: [myUser],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding an A Record for an EC2 Instance with Elastic IP in Route53 using AWS CDK\nDESCRIPTION: Demonstrates how to add an A record for an EC2 instance with an Elastic IP (EIP) to a Route53 hosted zone. It creates an EIP, associates it with the instance, and then creates an A record pointing to the EIP.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const instance: ec2.Instance;\n\nconst elasticIp = new ec2.CfnEIP(this, 'EIP', {\n  domain: 'vpc',\n  instanceId: instance.instanceId,\n});\n\ndeclare const myZone: route53.HostedZone;\nnew route53.ARecord(this, 'ARecord', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses(elasticIp.ref),\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM Permissions to an OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: Illustrates using helper methods on the AWS CDK `es.Domain` construct to grant specific IAM permissions to an AWS resource, such as a Lambda function (`fn`). The `grantIndexWrite` method grants write access to a specific index, while `grantPathRead` grants read access to a specific API path within the domain.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\ndeclare const domain: es.Domain;\n\n// Grant write access to the app-search index\ndomain.grantIndexWrite('app-search', fn);\n\n// Grant read access to the 'app-search/_search' path\ndomain.grantPathRead('app-search/_search', fn);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Environment Variables to an AppSync API in TypeScript\nDESCRIPTION: This TypeScript CDK code shows how to add environment variables to an AppSync API, making them accessible within resolvers. Variables can be provided during initialization using the `environmentVariables` property or added later using the `addEnvironmentVariable` method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'api',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.schema.graphql')),\n  environmentVariables: {\n    EnvKey1: 'non-empty-1',\n  },\n});\n\napi.addEnvironmentVariable('EnvKey2', 'non-empty-2');\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project with Windows Image from ECR and Certificate in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS CodeBuild project using AWS CDK. It configures the build environment to use a specific Windows image fetched from an ECR repository, specifying the image tag and type (SERVER_2019). It also includes configuration for importing a PEM encoded certificate from an S3 bucket into the build environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const ecrRepository: ecr.Repository;\n\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    buildImage: codebuild.WindowsBuildImage.fromEcrRepository(ecrRepository, 'v1.0', codebuild.WindowsImageType.SERVER_2019),\n    // optional certificate to include in the build image\n    certificate: {\n      bucket: s3.Bucket.fromBucketName(this, 'Bucket', 'amzn-s3-demo-bucket'),\n      objectKey: 'path/to/cert.pem',\n    },\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving EKS Cluster Security Group ID - AWS CDK - TypeScript\nDESCRIPTION: Fetches the ID of the default cluster security group, vital for configuring traffic or referencing in additional security postures. Requires an initialized eks.Cluster and is accessible post-creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst clusterSecurityGroupId = cluster.clusterSecurityGroupId;\n```\n\n----------------------------------------\n\nTITLE: Configuring Provisioned Billing\nDESCRIPTION: Example of configuring provisioned billing with fixed read capacity and autoscaled write capacity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.provisioned({\n    readCapacity: dynamodb.Capacity.fixed(10),\n    writeCapacity: dynamodb.Capacity.autoscaled({ maxCapacity: 15 }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Lambda Cleanup on Canary Deletion in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a Synthetics Canary to automatically delete its underlying Lambda function when the canary resource is deleted from the CDK stack. This is achieved by setting the `provisionedResourceCleanup` property to `true`. Note that other resources like S3 buckets and CloudWatch Logs still require manual cleanup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst canary = new synthetics.Canary(this, 'Canary', {\n  test: synthetics.Test.custom({\n    handler: 'index.handler',\n    code: synthetics.Code.fromInline('/* Synthetics handler code'),\n  }),\n  provisionedResourceCleanup: true,\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing OpenSearchServerless CDK Module\nDESCRIPTION: Example showing how to import the AWS OpenSearchServerless module from aws-cdk-lib for use in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchserverless/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opensearchserverless from 'aws-cdk-lib/aws-opensearchserverless';\n```\n\n----------------------------------------\n\nTITLE: Importing Encrypted Kinesis Stream with KMS Key - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import an encrypted Kinesis stream along with its KMS key using Stream.fromStreamAttributes. It instantiates a KMS key from ARN and supplies streamArn and encryptionKey as properties. Requires aws-cdk-lib, kinesis, and kms modules. Inputs are the streamArn and the encryptionKey; output is an imported Stream reference with encryption context.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst importedStream = kinesis.Stream.fromStreamAttributes(this, 'ImportedEncryptedStream', {\n  streamArn: 'arn:aws:kinesis:us-east-2:123456789012:stream/f3j09j2230j',\n  encryptionKey: kms.Key.fromKeyArn(this, 'key',\n    'arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012',\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Platform Specification\nDESCRIPTION: Creates a Docker image asset for a specific platform architecture.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  platform: Platform.LINUX_ARM64,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Virtual Router in a Separate Stack using Constructor in TypeScript\nDESCRIPTION: Demonstrates creating an `appmesh.Mesh` within one stack (`infraStack`) and an `appmesh.VirtualRouter` within a different stack (`appStack`) using the `VirtualRouter` class constructor directly. This approach requires explicitly passing the `mesh` object (from `infraStack`) in the properties when instantiating the `VirtualRouter` in `appStack`. The router listens on HTTP port 8081. Requires pre-declared `infraStack` and `appStack` variables of type `cdk.Stack`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const infraStack: cdk.Stack;\ndeclare const appStack: cdk.Stack;\n\nconst mesh = new appmesh.Mesh(infraStack, 'AppMesh', {\n  meshName: 'myAwsMesh',\n  egressFilter: appmesh.MeshFilterType.ALLOW_ALL,\n});\n\n// the VirtualRouter will belong to 'appStack',\n// even though the Mesh belongs to 'infraStack'\nconst router = new appmesh.VirtualRouter(appStack, 'router', {\n  mesh, // notice that mesh is a required property when creating a router with the 'new' statement\n  listeners: [appmesh.VirtualRouterListener.http(8081)],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Deployment Group for blue-green deployments in TypeScript\nDESCRIPTION: Creates a CodeDeploy Deployment Group for Lambda functions to enable traffic shifting deployments using Lambda Aliases with a linear traffic shift configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myApplication: codedeploy.LambdaApplication;\ndeclare const func: lambda.Function;\nconst version = func.currentVersion;\nconst version1Alias = new lambda.Alias(this, 'alias', {\n  aliasName: 'prod',\n  version,\n});\n\nconst deploymentGroup = new codedeploy.LambdaDeploymentGroup(this, 'BlueGreenDeployment', {\n  application: myApplication, // optional property: one will be created for you if not provided\n  alias: version1Alias,\n  deploymentConfig: codedeploy.LambdaDeploymentConfig.LINEAR_10PERCENT_EVERY_1MINUTE,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing ECS Deployment Configuration in AWS CDK\nDESCRIPTION: Shows how to import an existing CodeDeploy ECS deployment configuration by name using the fromEcsDeploymentConfigName method. This allows referencing deployment configurations that were created outside of CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentConfig = codedeploy.EcsDeploymentConfig.fromEcsDeploymentConfigName(\n  this,\n  'ExistingDeploymentConfiguration',\n  'MyExistingDeploymentConfiguration',\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Template from Stack in TypeScript\nDESCRIPTION: Demonstrates how to initialize a `Template` instance from an AWS CDK `Stack` object. This requires importing `Stack` from `aws-cdk-lib` and `Template` from `aws-cdk-lib/assertions`. The `Template.fromStack()` static method synthesizes the stack and creates a Template object for assertion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport { Stack } from 'aws-cdk-lib';\nimport { Template } from 'aws-cdk-lib/assertions';\n\nconst stack = new Stack(/* ... */);\n// ...\nconst template = Template.fromStack(stack);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Stream with Enhanced Fan-Out as Lambda Event Source in TypeScript\nDESCRIPTION: This snippet shows how to use a dedicated-throughput consumer with enhanced fan-out for a Kinesis Stream as a Lambda event source using the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\nimport { KinesisConsumerEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\nconst stream = new kinesis.Stream(this, 'MyStream');\nconst streamConsumer = new kinesis.StreamConsumer(this, 'MyStreamConsumer', {\n  stream,\n  streamConsumerName: 'MyStreamConsumer',\n});\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new KinesisConsumerEventSource(streamConsumer, {\n  batchSize: 100, // default\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n}));\n```\n\n----------------------------------------\n\nTITLE: Overriding Suppression List Reasons in SES Configuration Set - AWS CDK - TypeScript\nDESCRIPTION: This example configures a configuration set to override the types of email events (bounces and/or complaints) that are suppressed. Different suppressionReasons are demonstrated for only bounces, only complaints, or both. This enables fine-grained control over which problematic emails SES should filter out. Each variant creates separate configuration set resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// Only bounces will be suppressed.\nnew ses.ConfigurationSet(this, 'ConfigurationSet', {\n  suppressionReasons: ses.SuppressionReasons.BOUNCES_ONLY,\n});\n\n// Only complaints will be suppressed.\nnew ses.ConfigurationSet(this, 'ConfigurationSet', {\n  suppressionReasons: ses.SuppressionReasons.COMPLAINTS_ONLY,\n});\n\n// Both bounces and complaints will be suppressed.\nnew ses.ConfigurationSet(this, 'ConfigurationSet', {\n  suppressionReasons: ses.SuppressionReasons.BOUNCES_AND_COMPLAINTS,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Supported Identity Providers for a Cognito App Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to explicitly specify which identity providers an AWS Cognito App Client supports. By default, all providers (including 'COGNITO') are enabled. This example restricts the client to only support Amazon and the native Cognito user pool identity provider.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  // ...\n  supportedIdentityProviders: [\n    cognito.UserPoolClientIdentityProvider.AMAZON,\n    cognito.UserPoolClientIdentityProvider.COGNITO,\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Scopes for Config Rules in TypeScript\nDESCRIPTION: Shows how to configure scopes for both managed and custom Config rules. Examples include restricting to a specific security group, multiple resource types, and resources with a specific tag.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst sshRule = new config.ManagedRule(this, 'SSH', {\n  identifier: config.ManagedRuleIdentifiers.EC2_SECURITY_GROUPS_INCOMING_SSH_DISABLED,\n  ruleScope: config.RuleScope.fromResource(config.ResourceType.EC2_SECURITY_GROUP, 'sg-1234567890abcdefgh'), // restrict to specific security group\n});\n\ndeclare const evalComplianceFn: lambda.Function;\nconst customRule = new config.CustomRule(this, 'Lambda', {\n  lambdaFunction: evalComplianceFn,\n  configurationChanges: true,\n  ruleScope: config.RuleScope.fromResources([config.ResourceType.CLOUDFORMATION_STACK, config.ResourceType.S3_BUCKET]), // restrict to all CloudFormation stacks and S3 buckets\n});\n\nconst tagRule = new config.CustomRule(this, 'CostCenterTagRule', {\n  lambdaFunction: evalComplianceFn,\n  configurationChanges: true,\n  ruleScope: config.RuleScope.fromTag('Cost Center', 'MyApp'), // restrict to a specific tag\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Volume Copy Bundling for Go Function in AWS CDK\nDESCRIPTION: Shows how to set up a Go function with volume-copy based bundling instead of default bind mounts. This alternative approach is useful for Docker-in-Docker setups or when using remote Docker sockets, though it may be slower than the default method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'GoFunction', {\n  entry: 'app/cmd/api',\n  bundling: {\n       bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an SNS Topic with Signature Version in AWS CDK (TypeScript)\nDESCRIPTION: This example shows how to specify a signature version for an Amazon SNS topic in AWS CDK, impacting the hashing algorithm (e.g., SHA1 or SHA256) used for signing notifications and confirmations. This snippet is relevant in cases where signature method compliance is required for subscribing endpoints. The only dependency is sns from aws-cdk-lib, and the signatureVersion property is set to '2' (i.e., SHA256), overriding the default of '1'. Outputs a Topic construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic', {\n  signatureVersion: '2',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from S3 with Deployment Strategy using AWS CDK in TypeScript\nDESCRIPTION: This code shows how to create an AWS AppConfig `SourcedConfiguration` from S3 and associate a custom deployment strategy. It defines a new `appconfig.DeploymentStrategy` with a linear rollout (`appconfig.RolloutStrategy.linear`) specifying growth factor, deployment duration, and final bake time. Requires `appconfig.Application` and `s3.Bucket` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const bucket: s3.Bucket;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromBucket(bucket, 'path/to/file.json'),\n  deploymentStrategy: new appconfig.DeploymentStrategy(this, 'MyDeploymentStrategy', {\n    rolloutStrategy: appconfig.RolloutStrategy.linear({\n      growthFactor: 15,\n      deploymentDuration: Duration.minutes(30),\n      finalBakeTime: Duration.minutes(15),\n    }),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a VirtualNode with constructor and adding tags\nDESCRIPTION: Demonstrates creating a VirtualNode using the constructor with CloudMap service discovery, HTTP listener with timeout configuration, TLS client policy, and standard access logging. Shows how to add tags to the node.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\ndeclare const service: cloudmap.Service;\n\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service),\n  listeners: [appmesh.VirtualNodeListener.http({\n    port: 8080,\n    healthCheck: appmesh.HealthCheck.http({\n      healthyThreshold: 3,\n      interval: Duration.seconds(5),\n      path: '/ping',\n      timeout: Duration.seconds(2),\n      unhealthyThreshold: 2,\n    }),\n    timeout: {\n      idle: Duration.seconds(5),\n    },\n  })],\n  backendDefaults: {\n    tlsClientPolicy: {\n      validation: {\n        trust: appmesh.TlsValidationTrust.file('/keys/local_cert_chain.pem'),\n      },\n    },\n  },\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout'),\n});\n\ncdk.Tags.of(node).add('Environment', 'Dev');\n```\n\n----------------------------------------\n\nTITLE: Adding an Elastic IP Address Endpoint in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to add an Elastic IP (EIP) address as an endpoint to a Global Accelerator Listener's Endpoint Group via the AWS CDK. The endpoint is configured with a specific weight (128). Note that client IP preservation is not typically configured for EIP endpoints directly in this manner. Assumes `listener` (a `globalaccelerator.Listener`) and `eip` (an `ec2.CfnEIP` or similar EIP representation) are previously defined CDK constructs. Requires the `aws-globalaccelerator`, `aws-ec2`, and `aws-globalaccelerator-endpoints` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const listener: globalaccelerator.Listener;\ndeclare const eip: ec2.CfnEIP;\n\nlistener.addEndpointGroup('Group', {\n  endpoints: [\n    new ga_endpoints.CfnEipEndpoint(eip, {\n      weight: 128,\n    }),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Controlling Source Object Keys Output in AWS CDK S3 Deployment\nDESCRIPTION: This snippet shows how to disable the output of source object keys when deploying to an S3 bucket using AWS CDK. It uses the 'outputObjectKeys: false' option to prevent returning keys in the custom resource's Data property, useful for large deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\ndeclare const destinationBucket: s3.Bucket;\n\nconst myBucketDeployment = new s3deploy.BucketDeployment(this, 'DeployMeWithoutExtractingFilesOnDestination', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket,\n  outputObjectKeys: false,\n});\n\nnew cdk.CfnOutput(this, 'ObjectKey', {\n  value: cdk.Fn.select(0, myBucketDeployment.objectKeys),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Secrets Using secretObjectValue Property\nDESCRIPTION: This example demonstrates how to create a structured JSON secret using the secretObjectValue property. It shows how to handle different types of values, including IAM user credentials, plain text values, and existing secret values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = new iam.User(this, 'User');\nconst accessKey = new iam.AccessKey(this, 'AccessKey', { user });\ndeclare const stack: Stack;\n\nnew secretsmanager.Secret(this, 'Secret', {\n  secretObjectValue: {\n    username: SecretValue.unsafePlainText(user.userName),\n    database: SecretValue.unsafePlainText('foo'),\n    password: accessKey.secretAccessKey,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a SAML Principal from Provider with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to create a SAML principal from a provider, optionally customizing the assertion context with additional conditions (e.g., `StringEquals`). Useful in IAM trust policies. Requires CDK IAM SAML constructs; inputs are the provider and assertion context; output is a SamlPrincipal instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst provider = new iam.SamlProvider(this, 'Provider', {\\n  metadataDocument: iam.SamlMetadataDocument.fromFile('/path/to/saml-metadata-document.xml'),\\n});\\nconst principal = new iam.SamlPrincipal(provider, {\\n  StringEquals: {\\n    'SAML:iss': 'issuer',\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Geographic Restrictions in CloudFront Distribution\nDESCRIPTION: Demonstrates how to add geographic restrictions to a CloudFront Web Distribution to control content access by location.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\nnew cloudfront.CloudFrontWebDistribution(this, 'MyDistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n      },\n      behaviors : [ {isDefaultBehavior: true}],\n    },\n  ],\n  geoRestriction: cloudfront.GeoRestriction.allowlist('US', 'GB'),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS BackupGateway Module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Backup Gateway L1 construct module in TypeScript using the AWS CDK library (`aws-cdk-lib`). It makes the `backupgateway` namespace available, allowing the use of L1 constructs corresponding to AWS::BackupGateway CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backupgateway/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as backupgateway from 'aws-cdk-lib/aws-backupgateway';\n```\n\n----------------------------------------\n\nTITLE: Lambda Destination Success Invocation Record Format in JSON\nDESCRIPTION: Example of the JSON format for an invocation record sent to a destination when a Lambda function invocation succeeds. The record includes metadata about the request, function context, and the function's response payload.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-destinations/README.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"version\": \"1.0\",\n\t\"timestamp\": \"2019-11-24T23:08:25.651Z\",\n\t\"requestContext\": {\n\t\t\"requestId\": \"c2a6f2ae-7dbb-4d22-8782-d0485c9877e2\",\n\t\t\"functionArn\": \"arn:aws:lambda:sa-east-1:123456789123:function:event-destinations:$LATEST\",\n\t\t\"condition\": \"Success\",\n\t\t\"approximateInvokeCount\": 1\n\t},\n\t\"requestPayload\": {\n\t\t\"Success\": true\n\t},\n\t\"responseContext\": {\n\t\t\"statusCode\": 200,\n\t\t\"executedVersion\": \"$LATEST\"\n\t},\n\t\"responsePayload\": \"<data returned by the function here>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Repositories\nDESCRIPTION: Demonstrates different methods to import existing ECR repositories into a CDK app.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst repositoryFromName = ecr.Repository.fromRepositoryName(this, 'ImportedRepoByName', 'my-repo-name');\n\nconst repositoryFromArn = ecr.Repository.fromRepositoryArn(this, 'ImportedRepoByArn', 'arn:aws:ecr:us-east-1:123456789012:repository/my-repo-name');\n\nconst repositoryFromLookup = ecr.Repository.fromLookup(this, 'ImportedRepoByLookup', {\n  repositoryArn: 'arn:aws:ecr:us-east-1:123456789012:repository/my-repo-name',\n  repositoryName: 'my-repo-name',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Route53 Resolver Module in TypeScript\nDESCRIPTION: Shows how to import the AWS Route53 Resolver module into a CDK application. This import statement provides access to L1 constructs for Route53 Resolver resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53resolver/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as route53resolver from 'aws-cdk-lib/aws-route53resolver';\n```\n\n----------------------------------------\n\nTITLE: Adding Default IAM Role to Redshift Cluster via Method using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to add a default IAM role to an already defined AWS Redshift cluster instance using the `addDefaultIamRole` method in AWS CDK. It first creates the IAM role and the Redshift cluster, then associates the role as the default role for the cluster instance. Requires an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nconst defaultRole = new iam.Role(this, 'DefaultRole', {\n  assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n},\n);\n\nconst redshiftCluster = new Cluster(this, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n    roles: [defaultRole], // Role must also be in the roles list initially or added separately\n});\n\nredshiftCluster.addDefaultIamRole(defaultRole);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Description to an AWS CDK Stack - TypeScript\nDESCRIPTION: Illustrates how to include a human-readable description in a AWS CDK Stack using the description property within StackProps. This feature helps in identifying stacks in the AWS CloudFormation console. Requires initialization of the app and stack objects, and the description is provided as a string parameter.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack(app, 'StackName', {\n  description: 'This is a description.',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Auto Scaling Group with a Mixed Instances Policy in TypeScript\nDESCRIPTION: This snippet shows how to configure an Auto Scaling Group (ASG) to use a Mixed Instances Policy. This policy allows launching a combination of On-Demand and Spot instances and enables the use of multiple instance types specified via launch template overrides, potentially improving cost-efficiency and availability. Different launch templates can be specified per override.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const launchTemplate1: ec2.LaunchTemplate;\ndeclare const launchTemplate2: ec2.LaunchTemplate;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  mixedInstancesPolicy: {\n    instancesDistribution: {\n      onDemandPercentageAboveBaseCapacity: 50, // Mix Spot and On-Demand instances\n    },\n    launchTemplate: launchTemplate1,\n    launchTemplateOverrides: [ // Mix multiple instance types\n      { instanceType: new ec2.InstanceType('t3.micro') },\n      { instanceType: new ec2.InstanceType('t3a.micro') },\n      { instanceType: new ec2.InstanceType('t4g.micro'), launchTemplate: launchTemplate2 },\n    ],\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Adding User Pool Authentication to Identity Pool in TypeScript\nDESCRIPTION: This snippet shows how to add a Cognito User Pool as an authentication provider to an Identity Pool using UserPoolAuthenticationProvider.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst userPool = new cognito.UserPool(this, 'Pool');\n\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  authenticationProviders: {\n    userPools: [new UserPoolAuthenticationProvider({ userPool })],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing SMS Number via CloudFormation Parameter Token with AWS CDK in TypeScript\nDESCRIPTION: Illustrates subscribing an SNS topic to a phone number supplied via CloudFormation parameter token. The SMS subscription is dynamically configured at deployment, enabling flexible infrastructure. Relies on aws-cdk-lib/aws-cloudformation for parameter handling and expects the phone number in E.164 format.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'Topic');\nconst smsNumber = new CfnParameter(this, 'sms-param');\n\nmyTopic.addSubscription(new subscriptions.SmsSubscription(smsNumber.valueAsString));\n```\n\n----------------------------------------\n\nTITLE: Configuring SASL/IAM + TLS Authentication for MSK in TypeScript\nDESCRIPTION: This example demonstrates how to enable both IAM and TLS client authentication for an MSK Cluster, using an ACM Private Certificate Authority.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acmpca from 'aws-cdk-lib/aws-acmpca';\n\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'Cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n  encryptionInTransit: {\n    clientBroker: msk.ClientBrokerEncryption.TLS,\n  },\n  clientAuthentication: msk.ClientAuthentication.saslTls({\n    iam: true,\n    certificateAuthorities: [\n      acmpca.CertificateAuthority.fromCertificateAuthorityArn(\n        this,\n        'CertificateAuthority',\n        'arn:aws:acm-pca:us-west-2:1234567890:certificate-authority/11111111-1111-1111-1111-111111111111',\n      ),\n    ],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing IPolicyValidationPluginBeta1 in AWS CDK (TypeScript)\nDESCRIPTION: Implements the IPolicyValidationPluginBeta1 interface to define a custom policy validation plugin for AWS CDK. The example plugin class overrides the \"name\" property and provides a validate() method that processes context.templatePaths and returns a PolicyValidationPluginReportBeta1 object. Dependencies include the relevant AWS CDK core types; key parameters are the context object and hardcoded report structure for demonstration. The validate() function expects inputs such as template file paths and outputs a structured report detailing validation results and violations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_53\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass MyPlugin implements IPolicyValidationPluginBeta1 {\n  public readonly name = 'MyPlugin';\n\n  public validate(context: IPolicyValidationContextBeta1): PolicyValidationPluginReportBeta1 {\n    // First read the templates using context.templatePaths...\n\n    // ...then perform the validation, and then compose and return the report.\n    // Using hard-coded values here for better clarity:\n    return {\n      success: false,\n      violations: [{\n        ruleName: 'CKV_AWS_117',\n        description: 'Ensure that AWS Lambda function is configured inside a VPC',\n        fix: 'https://docs.bridgecrew.io/docs/ensure-that-aws-lambda-function-is-configured-inside-a-vpc-1',\n        violatingResources: [{\n          resourceLogicalId: 'MyFunction3BAA72D1',\n          templatePath: '/home/johndoe/myapp/cdk.out/MyService.template.json',\n          locations: ['Properties/VpcConfig'],\n        }],\n      }],\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Target for EventBridge Pipe in TypeScript\nDESCRIPTION: Demonstrates how to configure an SQS queue as the target for an EventBridge Pipe.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const targetQueue: sqs.Queue;\nconst pipeTarget = new SqsTarget(targetQueue);\n```\n\n----------------------------------------\n\nTITLE: Creating CloudFront Route53 Alias Record\nDESCRIPTION: Shows how to create a Route53 A-record that aliases to a CloudFront distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudfront from 'aws-cdk-lib/aws-cloudfront';\n\ndeclare const zone: route53.HostedZone;\ndeclare const distribution: cloudfront.CloudFrontWebDistribution;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.CloudFrontTarget(distribution)),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Dashboard Default Interval for Metrics (TypeScript)\nDESCRIPTION: Shows how to set the defaultInterval property when instantiating a Dashboard so that displayed metrics aggregate over a custom relative time range, such as 7 days. Requires import of Duration helper and Dashboard from aws-cdk-lib/aws-cloudwatch. The interval is specified with a Duration object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cw from 'aws-cdk-lib/aws-cloudwatch';\n\nconst dashboard = new cw.Dashboard(this, 'Dash', {\n  defaultInterval: Duration.days(7),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing OpenSearch/Elasticsearch Domain in TypeScript\nDESCRIPTION: Demonstrates how to import an existing Amazon OpenSearch/Elasticsearch Service domain into an AWS CDK application using the `Domain.fromDomainEndpoint` factory method. This allows managing or referencing certain aspects of a pre-existing domain within the CDK code by providing its endpoint URL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domainEndpoint = 'https://my-domain-jcjotrt6f7otem4sqcwbch3c4u.us-east-1.es.amazonaws.com';\nconst domain = es.Domain.fromDomainEndpoint(this, 'ImportedDomain', domainEndpoint);\n```\n```\n\n----------------------------------------\n\nTITLE: Granting IAM Permissions for AWS App Mesh Resource Streaming in CDK\nDESCRIPTION: Shows how to grant IAM permissions to stream aggregated resources from AWS App Mesh. This example grants permissions for a specific virtual gateway.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\nconst gateway = new appmesh.VirtualGateway(this, 'testGateway', { mesh });\nconst envoyUser = new iam.User(this, 'envoyUser');\n\n/**\n * This will grant `grantStreamAggregatedResources` ONLY for this gateway.\n */\ngateway.grantStreamAggregatedResources(envoyUser)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic CustomResource in AWS CDK with TypeScript\nDESCRIPTION: Illustrates the definition of an AWS CDK `CustomResource`. It requires specifying a `resourceType` (which must start with 'Custom::'), providing necessary `properties` for the resource logic, and linking it to a custom resource provider (like an SNS topic or Lambda function ARN) via the `serviceToken` property. This provider handles the CREATE, UPDATE, and DELETE lifecycle events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew CustomResource(this, 'MyMagicalResource', {\n  resourceType: 'Custom::MyCustomResource', // must start with 'Custom::'\n\n  // the resource properties\n  properties: {\n    Property1: 'foo',\n    Property2: 'bar'\n  },\n\n  // the ARN of the provider (SNS/Lambda) which handles\n  // CREATE, UPDATE or DELETE events for this resource type\n  // see next section for details\n  serviceToken: 'ARN'\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up CloudWatch Event Rules for CodeCommit Repository Events\nDESCRIPTION: Configures CloudWatch event rules that trigger on specific CodeCommit repository activities, such as commits to a branch or comments on pull requests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sns from 'aws-cdk-lib/aws-sns';\nimport * as targets from 'aws-cdk-lib/aws-events-targets';\n\ndeclare const repo: codecommit.Repository;\ndeclare const project: codebuild.PipelineProject;\ndeclare const myTopic: sns.Topic;\n\n// starts a CodeBuild project when a commit is pushed to the \"main\" branch of the repo\nrepo.onCommit('CommitToMain', {\n  target: new targets.CodeBuildProject(project),\n  branches: ['main'],\n});\n\n// publishes a message to an Amazon SNS topic when a comment is made on a pull request\nconst rule = repo.onCommentOnPullRequest('CommentOnPullRequest', {\n  target: new targets.SnsTopic(myTopic),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Advanced IVS Channel with Preset Configuration\nDESCRIPTION: Creates an advanced IVS channel with specific type and preset settings. This allows for more control over streaming bandwidth and quality settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst myChannel = new ivs.Channel(this, 'myChannel', {\n  type: ivs.ChannelType.ADVANCED_HD,\n  preset: ivs.Preset.CONSTRAINED_BANDWIDTH_DELIVERY,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Endpoint for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a custom endpoint for an OpenSearch domain, allowing access via a specified custom domain name (`search.example.com`). The configuration is done using the `customEndpoint` property within the `Domain` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  customEndpoint: {\n    domainName: 'search.example.com',\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC Connector for AppRunner Service\nDESCRIPTION: Associates an AppRunner service with a custom VPC using a VPC connector.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\nconst vpc = new ec2.Vpc(this, 'Vpc', {\n  ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16')\n});\n\nconst vpcConnector = new apprunner.VpcConnector(this, 'VpcConnector', {\n  vpc,\n  vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n  vpcConnectorName: 'MyVpcConnector',\n});\n\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  vpcConnector,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Signing Profile for Lambda Bundle with AWS CDK Signer (TypeScript)\nDESCRIPTION: Demonstrates how to instantiate a SigningProfile construct in an AWS CDK (TypeScript) stack using the AWS Signer module. This snippet creates a new signing profile tailored for Lambda code bundles by specifying the corresponding signing platform. Required dependencies include the AWS CDK libraries and the signer module. Key parameters include the CDK scope, a logical ID for the resource, and the selected platform. The output is a configurable SigningProfile construct, which is by default valid for 135 months, unless modified with the signatureValidityPeriod property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-signer/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst signingProfile = new signer.SigningProfile(this, 'SigningProfile', { \n  platform: signer.Platform.AWS_LAMBDA_SHA384_ECDSA,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Inline BuildSpec for CodeBuild Project in TypeScript\nDESCRIPTION: Shows how to define an inline buildspec for a CodeBuild project using an object. The buildspec will be rendered as JSON within the CodeBuild project configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromObject({\n    version: '0.2',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Excluding Files from Python Lambda Packaging\nDESCRIPTION: Uses the assetExcludes option to exclude specific directories or files from being included in the Lambda deployment package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonFunction(this, 'function', {\n  entry: '/path/to/poetry-function',\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    // translates to `rsync --exclude='.venv'`\n    assetExcludes: ['.venv'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing IAM Groups by ARN in AWS CDK\nDESCRIPTION: Imports an existing IAM group using its Amazon Resource Name (ARN). This allows you to reference and use an existing group in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst group = iam.Group.fromGroupArn(this, 'MyImportedGroupByArn', 'arn:aws:iam::account-id:group/group-name');\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project with Explicit GPU Image Details in TypeScript\nDESCRIPTION: This snippet demonstrates configuring an AWS CodeBuild project to use an AWS Deep Learning Container (DLC) image by explicitly providing the repository name, tag, and the AWS account ID where the repository resides. This method is useful when the CDK's default region-to-account mapping for DLC images might be outdated or for targeting specific accounts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    buildImage: codebuild.LinuxGpuBuildImage.awsDeepLearningContainersImage(\n      'tensorflow-inference', '2.1.0-gpu-py36-cu101-ubuntu18.04', '123456789012'),\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Image Tag Immutability\nDESCRIPTION: Configures an ECR repository with immutable image tags.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nnew ecr.Repository(this, 'Repo', { imageTagMutability: ecr.TagMutability.IMMUTABLE });\n```\n\n----------------------------------------\n\nTITLE: Creating IAM Groups in AWS CDK\nDESCRIPTION: Creates a new IAM user group. IAM groups allow you to specify permissions for multiple users at once.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst group = new iam.Group(this, 'MyGroup');\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with Private NLB using AWS CDK in TypeScript\nDESCRIPTION: Demonstrates setting up a private integration using `HttpNlbIntegration` to connect an HTTP API directly to a Network Load Balancer (NLB) listener within a VPC. This example creates a VPC, an NLB, a listener, and configures the listener as the default integration for the HTTP API. Requires `aws-ec2`, `aws-elasticloadbalancingv2`, `aws-apigatewayv2`, and `aws-apigatewayv2-integrations` CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { HttpNlbIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst vpc = new ec2.Vpc(this, 'VPC');\nconst lb = new elbv2.NetworkLoadBalancer(this, 'lb', { vpc });\nconst listener = lb.addListener('listener', { port: 80 });\nlistener.addTargets('target', {\n  port: 80,\n});\n\nconst httpEndpoint = new apigwv2.HttpApi(this, 'HttpProxyPrivateApi', {\n  defaultIntegration: new HttpNlbIntegration('DefaultIntegration', listener),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Resource Absence with New `resourceCountIs` (TypeScript)\nDESCRIPTION: Shows how to assert the absence of a resource type (`FOO::BAR`) using the `resourceCountIs` method from `@aws-cdk/assertions` by checking if the count is 0.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nTemplate.fromStack(stack).resourceCountIs('FOO::BAR', 0);\n```\n```\n\n----------------------------------------\n\nTITLE: Transformed Payload for Lambda Enrichment in JSON\nDESCRIPTION: Illustrates the transformed payload sent to the Lambda function for enrichment after applying the input transformation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    ...\n    \"staticField\": \"static value\",\n    \"dynamicField\": \"Test message.\",\n    \"pipeVariable\": \"MyPipe\",\n    ...\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Device Tracking for Cognito UserPool - AWS CDK - TypeScript\nDESCRIPTION: This snippet enables user device tracking in a Cognito UserPool, requiring a challenge on new devices and remembering devices only after user prompt. Uses the 'deviceTracking' property. Inputs are challenge and remember settings; output is enhanced user sign-in security with detailed device management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  deviceTracking: {\n    challengeRequiredOnNewDevice: true,\n    deviceOnlyRememberedOnUserPrompt: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TableWidget Layout Property (TypeScript)\nDESCRIPTION: Shows how to use the layout property of TableWidget to switch between displaying metrics as rows or columns on the CloudWatch dashboard. Depends on aws-cdk-lib/aws-cloudwatch for Dashboard and TableWidget constructs. The layout key accepts either cloudwatch.TableLayout.HORIZONTAL or cloudwatch.TableLayout.VERTICAL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  // ...\n  \n  layout: cloudwatch.TableLayout.VERTICAL,\n}));\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for EventBridge Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an EventBridge event bus target and input transformation. This allows customizing the payload sent to the event bus.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetEventBus: events.EventBus;\n\nconst eventBusTarget = new targets.EventBridgeTarget(targetEventBus, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: eventBusTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Global Accelerator with Specific IP Addresses in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to create an AWS Global Accelerator instance using the AWS CDK, explicitly providing a list of static IPv4 addresses ('1.1.1.1', '2.2.2.2') and specifying the IP address type as IPv4. This is useful when you need to use pre-allocated IP addresses for the accelerator. It depends on the `aws-globalaccelerator` CDK module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-globalaccelerator/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst accelerator = new globalaccelerator.Accelerator(this, 'Accelerator', {\n  ipAddresses: [\n    '1.1.1.1',\n    '2.2.2.2',\n  ],\n  ipAddressType: globalaccelerator.IpAddressType.IPV4,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using S3EventSourceV2 with Imported Bucket in TypeScript\nDESCRIPTION: This example shows how to use S3EventSourceV2 to connect a Lambda function to an existing S3 bucket referenced by name. This approach works with IBucket instances that might not be compatible with the standard S3EventSource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport { S3EventSourceV2 } from 'aws-cdk-lib/aws-lambda-event-sources';\n\nconst bucket = s3.Bucket.fromBucketName(this, 'Bucket', 'amzn-s3-demo-bucket');\ndeclare const fn: lambda.Function;\n\nfn.addEventSource(new S3EventSourceV2(bucket, {\n  events: [ s3.EventType.OBJECT_CREATED, s3.EventType.OBJECT_REMOVED ],\n  filters: [ { prefix: 'subdir/' } ], // optional\n}));\n```\n\n----------------------------------------\n\nTITLE: Working with CloudFormation Mappings\nDESCRIPTION: Shows how to create and use CloudFormation mappings for region-specific values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nconst regionTable = new CfnMapping(this, 'RegionTable', {\n  mapping: {\n    'us-east-1': {\n      regionName: 'US East (N. Virginia)',\n      // ...\n    },\n    'us-east-2': {\n      regionName: 'US East (Ohio)',\n      // ...\n    },\n    // ...\n  }\n});\n\nregionTable.findInMap(Aws.REGION, 'regionName')\n```\n\nLANGUAGE: yaml\nCODE:\n```\nMappings:\n  RegionTable:\n    us-east-1:\n      regionName: US East (N. Virginia)\n    us-east-2:\n      regionName: US East (Ohio)\n```\n\n----------------------------------------\n\nTITLE: Incorporating Environment Secrets into AWS App Runner Service using AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to inject environment secrets into an AWS App Runner service using the AWS CDK in TypeScript. This example uses both AWS Secrets Manager and SSM Parameter Store as sources for secrets via the 'environmentSecrets' attribute in the service's image configuration and further showcases the use of the 'addSecret' method to add additional secrets post definition. Dependencies include aws-cdk-lib modules for 'aws-secretsmanager', 'aws-ssm', and 'apprunner'. Key parameters include 'SECRET', 'PARAMETER', 'SECRET_ID', and 'SECRET_STAGE'. Inputs are secret resources and output is a configured App Runner service with these secured environment variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';\nimport * as ssm from 'aws-cdk-lib/aws-ssm';\n\ndeclare const stack: Stack;\n\nconst secret = new secretsmanager.Secret(stack, 'Secret');\nconst parameter = ssm.StringParameter.fromSecureStringParameterAttributes(stack, 'Parameter', {\n  parameterName: '/name',\n  version: 1,\n});\n\nconst service = new apprunner.Service(stack, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: {\n      port: 8000,\n      environmentSecrets: {\n        SECRET: apprunner.Secret.fromSecretsManager(secret),\n        PARAMETER: apprunner.Secret.fromSsmParameter(parameter),\n        SECRET_ID: apprunner.Secret.fromSecretsManagerVersion(secret, { versionId: 'version-id' }),\n        SECRET_STAGE: apprunner.Secret.fromSecretsManagerVersion(secret, { versionStage: 'version-stage' }),\n      },\n    },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  })\n});\n\nservice.addSecret('LATER_SECRET', apprunner.Secret.fromSecretsManager(secret, 'field'));\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Region CloudFormation Action\nDESCRIPTION: Demonstrates how to set up a CloudFormation action that deploys to a different AWS region by specifying the target region directly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Actions that don't take an AWS resource will accept an explicit `region` parameter.\ndeclare const stage: codepipeline.IStage;\ndeclare const templatePath: codepipeline.ArtifactPath;\nstage.addAction(new codepipeline_actions.CloudFormationCreateUpdateStackAction({\n  templatePath,\n  adminPermissions: false,\n  stackName: Stack.of(this).stackName,\n  actionName: 'cloudformation-create-update',\n  // ...\n  region: 'us-west-1',\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Hosted Configuration in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration with a specific configuration type such as FEATURE_FLAGS. This allows for specialized handling of the configuration data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n  type: appconfig.ConfigurationType.FEATURE_FLAGS,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Redshift Table Sort Keys with AWS CDK in TypeScript\nDESCRIPTION: Creates a Redshift table with specified sort keys (`sortKey: true` on columns) and a sort style (`sortStyle: TableSortStyle.COMPOUND`). Sort keys improve query performance by allowing Redshift to efficiently skip blocks of data that don't match query predicates. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableColumns: [\n    { name: 'col1', dataType: 'varchar(4)', sortKey: true },\n    { name: 'col2', dataType: 'float', sortKey: true },\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n  sortStyle: TableSortStyle.COMPOUND,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Spot Instances for GameLift Fleet in TypeScript\nDESCRIPTION: Enables the use of Spot Instances for a GameLift fleet instead of the default On-Demand Instances. Spot instances can provide cost savings but come with potential availability trade-offs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\nnew gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n    }]\n  },\n  useSpot: true\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS App Mesh Resources by Attributes in CDK\nDESCRIPTION: Demonstrates how to import existing AWS App Mesh resources using their attributes. This example imports a virtual node and a mesh by name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst virtualNodeName = 'my-virtual-node';\nappmesh.VirtualNode.fromVirtualNodeAttributes(this, 'imported-virtual-node', {\n  mesh: appmesh.Mesh.fromMeshName(this, 'Mesh', 'testMesh'),\n  virtualNodeName: virtualNodeName,\n});\n\nappmesh.Mesh.fromMeshName(this, 'imported-mesh', 'abc');\n```\n\n----------------------------------------\n\nTITLE: Configuring ECS Cluster and Fargate Service with Capacity Providers\nDESCRIPTION: Example showing how to create an ECS cluster with Fargate capacity providers and configure a Fargate service with mixed capacity provider strategies using FARGATE and FARGATE_SPOT.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-fargate-capacity-providers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new cdk.Stack();\nconst vpc = new ec2.Vpc(stack, 'MyVpc', {});\nconst cluster = new ecs.Cluster(stack, 'EcsCluster', {\n  vpc,\n  capacityProviders: ['FARGATE', 'FARGATE_SPOT'],\n});\n\nconst taskDefinition = new ecs.FargateTaskDefinition(stack, 'FargateTaskDef');\n\nconst container = taskDefinition.addContainer('web', {\n  image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  memoryLimitMiB: 512,\n});\ncontainer.addPortMappings({ containerPort: 8000 });\n\nnew ecs.FargateService(stack, 'FargateService', {\n  cluster,\n  taskDefinition,\n  capacityProviderStrategies: [\n    {\n      capacityProvider: 'FARGATE_SPOT',\n      weight: 2,\n    },\n    {\n      capacityProvider: 'FARGATE',\n      weight: 1,\n    }\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Auth with Existing Credentials in TypeScript\nDESCRIPTION: Adds password protection to an Amplify app using basic authentication with existing credentials stored in Secrets Manager. This example uses credentials from a secret for GitHub authentication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-github-token'),\n  }),\n  basicAuth: amplify.BasicAuth.fromCredentials('username', SecretValue.secretsManager('my-github-token')),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Single-User Credential Rotation for Redshift Cluster\nDESCRIPTION: Configures automatic rotation for the Redshift cluster's master user password stored in AWS Secrets Manager. Calling `cluster.addRotationSingleUser()` sets up rotation with a default interval (typically 30 days). Requires an existing `Cluster` object (`cluster`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\ncluster.addRotationSingleUser(); // Will rotate automatically after 30 days\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Start and End Time for Recurring Schedules (AWS CDK, TypeScript)\nDESCRIPTION: Illustrates how to restrict a recurring schedule's active period by specifying start and end Date objects in the schedule configuration. Only triggers between the defined time range. Inputs are scheduling details, start, and end time; outputs are schedule invocation only within the specified window. Requires cdk.Duration, Schedule, LambdaInvoke.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nnew Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(cdk.Duration.hours(12)),\n    target: target,\n    start: new Date('2023-01-01T00:00:00.000Z'),\n    end: new Date('2023-02-01T00:00:00.000Z'),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Contributor Insights with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to enable Contributor Insights for a DynamoDB table using the TableV2 construct, which provides information about the most accessed and throttled items.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  contributorInsights: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional Health Checks for Auto Scaling Group in TypeScript\nDESCRIPTION: Creates an AWS Auto Scaling Group configured with multiple health check types beyond the default EC2 check. It uses `autoscaling.HealthChecks.withAdditionalChecks` to specify additional types like EBS, ELB, and VPC_LATTICE, along with a common `gracePeriod`. EC2 health checks are implicitly included. Dependencies include `ec2.Vpc`, `ec2.InstanceType`, `ec2.MachineImage`, `Duration`, and `autoscaling` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n  healthChecks: autoscaling.HealthChecks.withAdditionalChecks({\n    gracePeriod: Duration.seconds(100),\n    additionalTypes: [\n      autoscaling.AdditionalHealthCheckType.EBS,\n      autoscaling.AdditionalHealthCheckType.ELB,\n      autoscaling.AdditionalHealthCheckType.VPC_LATTICE,\n    ],\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing an IAM User by Name with AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to import an existing IAM user into a CDK stack using the username. Supports paths as per AWS documentation. Requires IAM module and the user's name as input; outputs an imported User construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = iam.User.fromUserName(this, 'MyImportedUserByName', 'johnsmith');\n```\n\n----------------------------------------\n\nTITLE: Adding Request and Response Interceptors in Axios - JavaScript\nDESCRIPTION: Demonstrates how to use interceptors in Axios instances to preprocess requests and responses or handle errors. The snippet shows adding both request and response interceptors to an instance, with each interceptor able to transform configuration or handle errors at various points in the request lifecycle. Requires `axios` and the instantiation of an Axios instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst instance = axios.create();\n\n// Add a request interceptor\ninstance.interceptors.request.use(function (config) {\n    // Do something before request is sent\n    return config;\n  }, function (error) {\n    // Do something with request error\n    return Promise.reject(error);\n  });\n\n// Add a response interceptor\ninstance.interceptors.response.use(function (response) {\n    // Any status code that lie within the range of 2xx cause this function to trigger\n    // Do something with response data\n    return response;\n  }, function (error) {\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\n    // Do something with response error\n    return Promise.reject(error);\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Launch Type for ECS Task Target in TypeScript\nDESCRIPTION: This snippet demonstrates how to override the default launch type for an ECS task target. It shows how to set the launchType property to specify whether the task should run on EC2 or Fargate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(new targets.EcsTask({\n  cluster,\n  taskDefinition,\n  launchType: ecs.LaunchType.FARGATE,\n}));\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sum Custom Resource Handler (Node.js, JavaScript)\nDESCRIPTION: This JavaScript handler is meant for a custom resource Lambda function that adds two numbers provided in the event\\'s ResourceProperties and returns the result in Data.Result. The handler is designed to be used with a CustomResourceProvider in AWS CDK, must be in a directory by itself, and cannot import outside dependencies. Inputs are lhs and rhs under ResourceProperties, and the output object must be shaped as Data: { Result: sum }.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nexports.handler = async (e) => {\n  return {\n    Data: {\n      Result: e.ResourceProperties.lhs + e.ResourceProperties.rhs,\n    },\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Referencing Predefined AppConfig Deployment Strategy by ID using CDK in TypeScript\nDESCRIPTION: Illustrates referencing one of AWS AppConfig's predefined deployment strategies (specifically `CANARY_10_PERCENT_20_MINUTES`) by its known ID string representation using the `fromDeploymentStrategyId` static method and the `appconfig.DeploymentStrategyId` enum/constant. Assumes `this` is a CDK `Construct` and `appconfig` is the imported module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nappconfig.DeploymentStrategy.fromDeploymentStrategyId(\n  this,\n  'MyImportedPredefinedDeploymentStrategy',\n  appconfig.DeploymentStrategyId.CANARY_10_PERCENT_20_MINUTES,\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling NodeGroup Auto-Repair in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable the auto-repair configuration for a Managed Node Group in EKS. It shows using the enableNodeAutoRepair property when adding node group capacity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n\ncluster.addNodegroupCapacity('NodeGroup', {\n  enableNodeAutoRepair:true,\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Resource Existence with Old `toHaveResource` (TypeScript)\nDESCRIPTION: Illustrates the deprecated `toHaveResource` Jest matcher from `@aws-cdk/assert` used to assert the existence of a specific resource type (`FOO::BAR`) within a synthesized CDK stack template. The second example shows checking the complete resource definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexpect(stack).toHaveResource('FOO::BAR', {/*...*/});\nexpect(stack).toHaveResource('FOO::BAR', {/*...*/}, ResourcePart.CompleteDefinition);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Kubernetes Manifests to Existing Clusters in TypeScript\nDESCRIPTION: This snippet demonstrates how to add Kubernetes manifests to an existing cluster using the addManifest method. It shows defining a ConfigMap resource as an example.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\ncluster.addManifest('Test', {\n  apiVersion: 'v1',\n  kind: 'ConfigMap',\n  metadata: {\n    name: 'myconfigmap',\n  },\n  data: {\n    Key: 'value',\n    Another: '123454',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom S3 Origin Access Control Construct for CloudFront - AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates how to pass a custom S3OriginAccessControl instance to the S3BucketOrigin.withOriginAccessControl() method to gain fine-grained control over signing behaviors (e.g., SIGV4_NO_OVERRIDE) in a CloudFront Distribution. Prerequisites: instantiate both the S3 bucket and S3OriginAccessControl. Parameters include the custom OAC object. Final output is a new CloudFront Distribution using the customized origin.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst oac = new cloudfront.S3OriginAccessControl(this, 'MyOAC', { \n  signing: cloudfront.Signing.SIGV4_NO_OVERRIDE\n});\nconst s3Origin = origins.S3BucketOrigin.withOriginAccessControl(myBucket, {\n    originAccessControl: oac \n  }\n)\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: s3Origin\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Reading CloudFormation Pseudo Parameters via CDK Stack (AWS CDK, TypeScript)\nDESCRIPTION: Fetches pseudo parameter values (account, region, partition) from the current stack, ensuring qualification in cross-stack scenarios. This snippet uses the Stack.of() pattern and the returned properties are CloudFormation tokens unless the values are known at synthesis time. Useful for dynamically parameterizing resources and outputs based on the deployment context.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n// \"this\" is the current construct\nconst stack = Stack.of(this);\n\nstack.account; // Returns the AWS::AccountId for this stack (or the literal value if known)\nstack.region;  // Returns the AWS::Region for this stack (or the literal value if known)\nstack.partition; // Returns the AWS::Partition for this stack (or the literal value if known)\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Destination for EventBridge Pipe in TypeScript\nDESCRIPTION: Shows how to set up a CloudWatch Logs log group as a log destination for an EventBridge Pipe, including log level and execution data configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\ndeclare const logGroup: logs.LogGroup;\n\nconst cwlLogDestination = new pipes.CloudwatchLogsLogDestination(logGroup);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue),\n  logLevel: pipes.LogLevel.TRACE,\n  logIncludeExecutionData: [pipes.IncludeExecutionData.ALL],\n  logDestinations: [cwlLogDestination],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Cloud Map Service Discovery with HTTP API\nDESCRIPTION: Sets up a private DNS namespace and service discovery integration for HTTP API using VPC Link. Creates a basic discovery service private integration by configuring VPC, namespace, and service components.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as servicediscovery from 'aws-cdk-lib/aws-servicediscovery';\nimport { HttpServiceDiscoveryIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst vpc = new ec2.Vpc(this, 'VPC');\nconst vpcLink = new apigwv2.VpcLink(this, 'VpcLink', { vpc });\nconst namespace = new servicediscovery.PrivateDnsNamespace(this, 'Namespace', {\n  name: 'boobar.com',\n  vpc,\n});\nconst service = namespace.createService('Service');\n\nconst httpEndpoint = new apigwv2.HttpApi(this, 'HttpProxyPrivateApi', {\n  defaultIntegration: new HttpServiceDiscoveryIntegration('DefaultIntegration', service, {\n    vpcLink,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Space-Delimited Table Pattern Filters\nDESCRIPTION: Demonstrates how to create filters for space-delimited log formats like Apache server logs, with column-specific conditions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst pattern = logs.FilterPattern.spaceDelimited('time', 'component', '...', 'result_code', 'latency')\n  .whereString('component', '=', 'HttpServer')\n  .whereNumber('result_code', '!=', 200);\n```\n\n----------------------------------------\n\nTITLE: CapacityProviderStrategy Interface Definition\nDESCRIPTION: TypeScript interface definition for the CapacityProviderStrategy, specifying the structure for capacity provider configuration including provider name, base value, and weight.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-fargate-capacity-providers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * A Capacity Provider strategy to use for the service.\n */\nexport interface CapacityProviderStrategy {\n  /**\n   * The name of the Capacity Provider. Currently only FARGATE and FARGATE_SPOT are supported.\n   */\n  readonly capacityProvider: string;\n\n  /**\n   * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one\n   * capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default\n   * value of 0 is used.\n   *\n   * @default - none\n   */\n  readonly base?: number;\n\n  /**\n   * The weight value designates the relative percentage of the total number of tasks launched that should use the\n   * specified\ncapacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.\n   *\n   * @default - 0\n   */\n  readonly weight?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Support for CloudFront Distribution in TypeScript\nDESCRIPTION: This snippet shows how to enable gRPC support for a CloudFront distribution by including HTTP/2 and allowing all HTTP methods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nnew cloudfront.Distribution(this, 'myCdn', {\n  defaultBehavior: {\n    origin: new origins.HttpOrigin('www.example.com'),\n    allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL, // `AllowedMethods.ALLOW_ALL` is required if `enableGrpc` is true\n    enableGrpc: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Auto Scaling Group Capacity to EKS Cluster\nDESCRIPTION: Adds self-managed capacity to an EKS cluster using an Auto Scaling Group with specific subnet selection.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const cluster: eks.Cluster;\ncluster.addAutoScalingGroupCapacity('nodes', {\n  vpcSubnets: { subnets: vpc.privateSubnets },\n  instanceType: new ec2.InstanceType('t2.medium'),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Attaching a CloudFront Function using AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates creating a CloudFront Function with inline JavaScript code and associating it with the default behavior of a CloudFront distribution. It specifies the function code using `FunctionCode.fromInline`, sets the runtime to `JS_2_0`, and attaches it to the `VIEWER_REQUEST` event using the `functionAssociations` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n// Add a cloudfront Function to a Distribution\nconst cfFunction = new cloudfront.Function(this, 'Function', {\n  code: cloudfront.FunctionCode.fromInline('function handler(event) { return event.request }'),\n  runtime: cloudfront.FunctionRuntime.JS_2_0,\n});\n\ndeclare const s3Bucket: s3.Bucket;\nnew cloudfront.Distribution(this, 'distro', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(s3Bucket),\n    functionAssociations: [{\n      function: cfFunction,\n      eventType: cloudfront.FunctionEventType.VIEWER_REQUEST,\n    }],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Connection Management Permissions in TypeScript (CDK)\nDESCRIPTION: This snippet illustrates how to grant permissions to a Lambda function (`fn`) to manage WebSocket connections (e.g., send messages back to clients, disconnect clients) using the API Gateway Management API. Permissions can be granted per stage using `stage.grantManagementApiAccess(fn)` or for all stages of the API using `webSocketApi.grantManageConnections(fn)`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nconst stage = new apigwv2.WebSocketStage(this, 'mystage', {\n  webSocketApi,\n  stageName: 'dev',\n});\n// per stage permission\nstage.grantManagementApiAccess(fn);\n// for all the stages permission\nwebSocketApi.grantManageConnections(fn);\n```\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Updating ElasticsearchVersion to EngineVersion\nDESCRIPTION: Demonstrates how to replace ElasticsearchVersion with EngineVersion when migrating to OpenSearch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst version = es.ElasticsearchVersion.V7_1;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst version = opensearch.EngineVersion.ELASTICSEARCH_7_1;\n```\n\n----------------------------------------\n\nTITLE: Adding Volumes to an EKS Job Definition in AWS Batch\nDESCRIPTION: Demonstrates how to add different volume types to an EKS container in AWS Batch. This example shows how to configure emptyDir, hostPath, and Kubernetes secret volumes for an EKS job definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const jobDefn: batch.EksJobDefinition;\njobDefn.container.addVolume(batch.EksVolume.emptyDir({\n  name: 'emptyDir',\n  mountPath: '/Volumes/emptyDir',\n}));\njobDefn.container.addVolume(batch.EksVolume.hostPath({\n  name: 'hostPath',\n  hostPath: '/sys',\n  mountPath: '/Volumes/hostPath',\n}));\njobDefn.container.addVolume(batch.EksVolume.secret({\n  name: 'secret',\n  optional: true,\n  mountPath: '/Volumes/secret',\n  secretName: 'mySecret',\n}));\n```\n\n----------------------------------------\n\nTITLE: Using Match.anyValue for Asserting Presence of Any Value in TypeScript\nDESCRIPTION: Demonstrates the `Match.anyValue()` matcher within `hasResourceProperties()`. This asserts that a value must exist and not be nullish (`null` or `undefined`) at the specified location. The first example passes as the array 'Wobble' contains two non-nullish values. The second example fails because the property 'Wimble' does not exist.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": {\n//           \"Wobble\": [\"Flob\", \"Flib\"],\n//         }\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: {\n    Wobble: [ Match.anyValue(), Match.anyValue() ],\n  },\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: {\n    Wimble: Match.anyValue(),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Exact Path Matching and Rewriting in AWS App Mesh with CDK\nDESCRIPTION: Shows how to configure exact path matching and rewriting for HTTP-based gateway routes in AWS App Mesh. This example rewrites the path from '/test' to '/rewrittenPath'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gateway: appmesh.VirtualGateway;\ndeclare const virtualService: appmesh.VirtualService;\n\ngateway.addGatewayRoute('gateway-route-http-2', {\n  routeSpec: appmesh.GatewayRouteSpec.http({\n    routeTarget: virtualService,\n    match: {\n      // This rewrites the path from '/test' to '/rewrittenPath'.\n      path: appmesh.HttpGatewayRoutePathMatch.exactly('/test', '/rewrittenPath'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Neptune Parameter Groups\nDESCRIPTION: Demonstrates how to create and configure both cluster and instance parameter groups for Neptune, which allow customizing database behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst clusterParams = new neptune.ClusterParameterGroup(this, 'ClusterParams', {\n  description: 'Cluster parameter group',\n  parameters: {\n    neptune_enable_audit_log: '1'\n  },\n});\n\nconst dbParams = new neptune.ParameterGroup(this, 'DbParams', {\n  description: 'Db parameter group',\n  parameters: {\n    neptune_query_timeout: '120000',\n  },\n});\n\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  clusterParameterGroup: clusterParams,\n  parameterGroup: dbParams,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Repository KMS Encryption\nDESCRIPTION: Creates ECR repositories with different encryption configurations using KMS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew ecr.Repository(this, 'Repo', {\n  encryption: ecr.RepositoryEncryption.KMS\n});\n```\n\n----------------------------------------\n\nTITLE: Using Duration Utility Methods with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates the use of the Duration class's static factory methods for specifying time intervals in AWS CDK constructs. No external dependencies beyond the CDK. The shown methods instantiate Duration objects representing seconds, minutes, hours, days, or parse ISO 8601 strings. Inputs are numbers or strings representing time. Outputs are Duration objects usable as parameters in AWS construct APIs. Limitations: only Duration-compatible AWS properties can be set this way.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nDuration.seconds(300)   // 5 minutes\nDuration.minutes(5)     // 5 minutes\nDuration.hours(1)       // 1 hour\nDuration.days(7)        // 7 days\nDuration.parse('PT5M')  // 5 minutes\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple IAM Principals in Policy Statement\nDESCRIPTION: Demonstrates how to add multiple service principals and ARN principals to a policy statement, which results in them being merged in the final JSON output.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst statement = new iam.PolicyStatement();\nstatement.addServicePrincipal('cloudwatch.amazonaws.com');\nstatement.addServicePrincipal('ec2.amazonaws.com');\nstatement.addArnPrincipal('arn:aws:boom:boom');\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Principal\": {\n    \"Service\": [ \"cloudwatch.amazonaws.com\", \"ec2.amazonaws.com\" ],\n    \"AWS\": \"arn:aws:boom:boom\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Glue S3 Table with Explicit Bucket and Prefix in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS Glue S3 Table using AWS CDK where the S3 bucket (`myBucket`) and object prefix (`s3Prefix`) for the table's data are explicitly provided, instead of being implicitly created. It requires existing `s3.Bucket` and `glue.Database` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myBucket: s3.Bucket;\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  bucket: myBucket,\n  s3Prefix: 'my-table/',\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Removal Policy for TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to set the removal policy for a TableV2 instance, which controls what happens to the table during stack deletion. It also shows how to configure replicas.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  // applies to all replicas, i.e., us-west-2, us-east-1, us-east-2\n  removalPolicy: cdk.RemovalPolicy.DESTROY,\n  replicas: [\n    { region: 'us-east-1' },\n    { region: 'us-east-2' },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration with Environment Deployment in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration and specifies which environments to deploy it to using the deployTo parameter.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\ndeclare const env: appconfig.Environment;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n  deployTo: [env],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding OpenID Connect and SAML Providers to Identity Pool in TypeScript\nDESCRIPTION: This snippet shows how to add OpenID Connect and SAML providers to an Identity Pool using existing IAM providers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const openIdConnectProvider: iam.OpenIdConnectProvider;\ndeclare const samlProvider: iam.SamlProvider;\n\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  authenticationProviders: {\n    openIdConnectProviders: [openIdConnectProvider],\n    samlProviders: [samlProvider],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up CloudFront Invalidation after S3 Bucket Deployment\nDESCRIPTION: Demonstrates how to configure CloudFront distribution invalidation after an S3 bucket deployment is completed, allowing for cache invalidation of specific paths.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudfront from 'aws-cdk-lib/aws-cloudfront';\nimport * as origins from 'aws-cdk-lib/aws-cloudfront-origins';\n\nconst bucket = new s3.Bucket(this, 'Destination');\n\n// Handles buckets whether or not they are configured for website hosting.\nconst distribution = new cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: new origins.S3Origin(bucket) },\n});\n\nnew s3deploy.BucketDeployment(this, 'DeployWithInvalidation', {\n  sources: [s3deploy.Source.asset('./website-dist')],\n  destinationBucket: bucket,\n  distribution,\n  distributionPaths: ['/images/*.png'],\n});\n```\n\n----------------------------------------\n\nTITLE: Navigating to Test Directory - Shell Command\nDESCRIPTION: This command navigates to the AWS EKS framework-integ test directory. It is a preliminary step required before creating or modifying test files for EKS integration. The command should be run from the project root or appropriate context.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_17\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/@aws-cdk-testing/framework-integ/test/aws-eks/test\n```\n\n----------------------------------------\n\nTITLE: Creating a Flink Application with Code from S3 Bucket in TypeScript\nDESCRIPTION: Shows how to create a Flink application using the Application construct with code loaded from an S3 bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-kinesisanalytics-flink-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n[flink application using code from bucket](test/integ.application-code-from-bucket.lit.ts)\n```\n\n----------------------------------------\n\nTITLE: Configuring ELBv2 Load Balancer Origin\nDESCRIPTION: Sets up an internet-facing Application Load Balancer as a CloudFront origin\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst lb = new elbv2.ApplicationLoadBalancer(this, 'LB', {\n  vpc,\n  internetFacing: true,\n});\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.LoadBalancerV2Origin(lb) },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Expiration Times for Cognito App Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure the expiration times for access tokens, ID tokens, and refresh tokens issued by an AWS Cognito User Pool for a specific App Client. It uses the AWS CDK `Duration` utility to set validity periods (e.g., 60 minutes for access/ID tokens, 30 days for refresh tokens).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst pool = new cognito.UserPool(this, 'Pool');\npool.addClient('app-client', {\n  // ...\n  accessTokenValidity: Duration.minutes(60),\n  idTokenValidity: Duration.minutes(60),\n  refreshTokenValidity: Duration.days(30),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Converting L1 to L2 Resource using from*Name/Arn/Attributes (TypeScript)\nDESCRIPTION: Demonstrates alternative methods (`fromBucketName`, `fromKeyArn`, `fromVpcAttributes`) for creating immutable L2 representations from L1 Cfn resources retrieved from an included template. This is useful when `fromCfn*` methods fail or are unavailable. Requires providing necessary attributes like name, ARN, or ID.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\n\n// using from*Name()\nconst cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\nconst bucket = s3.Bucket.fromBucketName(this, 'L2Bucket', cfnBucket.ref);\n\n// using from*Arn()\nconst cfnKey = cfnTemplate.getResource('Key') as kms.CfnKey;\nconst key = kms.Key.fromKeyArn(this, 'L2Key', cfnKey.attrArn);\n\n// using from*Attributes()\ndeclare const privateCfnSubnet1: ec2.CfnSubnet;\ndeclare const privateCfnSubnet2: ec2.CfnSubnet;\nconst cfnVpc = cfnTemplate.getResource('Vpc') as ec2.CfnVPC;\nconst vpc = ec2.Vpc.fromVpcAttributes(this, 'L2Vpc', {\n  vpcId: cfnVpc.ref,\n  availabilityZones: core.Fn.getAzs(),\n  privateSubnetIds: [privateCfnSubnet1.ref, privateCfnSubnet2.ref],\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Reboot for Redshift Parameter Changes with AWS CDK\nDESCRIPTION: Configures a Redshift cluster to automatically reboot when parameter changes requiring a reboot are applied. This is achieved by calling `cluster.enableRebootForParameterChanges()` after adding parameters (e.g., via `addToParameterGroup`). Requires `Cluster`, `ec2.Vpc`, `cdk.SecretValue`, and an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as cdk from 'aws-cdk-lib';\ndeclare const vpc: ec2.Vpc;\n\nconst cluster = new Cluster(this, 'Cluster', {\n  masterUser: {\n    masterUsername: 'admin',\n    masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n  },\n  vpc,\n});\n\ncluster.addToParameterGroup('enable_user_activity_logging', 'true');\ncluster.enableRebootForParameterChanges()\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Cross-Region Certificate Issue with CloudFront (TypeScript)\nDESCRIPTION: Highlights the problem with cross-region dependencies. It attempts to create an ACM certificate in `us-east-2` and use it with a CloudFront distribution in the same stack. This fails because CloudFront requires ACM certificates to be in `us-east-1`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst appStack = new Stack(app, 'AppStack', { env: { region: 'us-east-2' } });\nconst service = new ApplicationLoadBalancedFargateService(appStack, 'Service');\n\n// this won't work!!!\nconst certificate = new acm.Certificate(appStack, 'Cert');\nconst distribution = new Distribution(appStack, 'Distribution', {\n  defaultBehavior: { origin: new LoadBalancerV2Origin(service.loadBalancer) },\n  certificate,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Provisioning a Fargate-only EKS Cluster in TypeScript\nDESCRIPTION: Shows how to create an EKS cluster that uses only Fargate workers using the FargateCluster construct. It specifies the Kubernetes version as the required property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew eks.FargateCluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for API Destination Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an API Destination target and input transformation. This allows customizing the payload sent to the API destination.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const dest: events.ApiDestination;\n\nconst apiTarget = new targets.ApiDestinationTarget(dest, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: apiTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating VPC with DNS Support and Hostnames using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to create an AWS VPC using AWS CDK, specifically enabling DNS support and DNS hostnames. This configuration is crucial when using Elastic IPs with Redshift clusters within a VPC, ensuring that connections originating from within the VPC resolve to the cluster's private IP address instead of the public Elastic IP.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as cdk from 'aws-cdk-lib';\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nconst vpc = new ec2.Vpc(this, 'VPC', {\n  enableDnsSupport: true,\n  enableDnsHostnames: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Artifact Encryption with KMS in AWS CDK\nDESCRIPTION: Shows how to configure custom encryption for canary artifacts using KMS. The example creates a custom KMS key and configures the canary to use KMS encryption mode with the custom key for artifact storage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst key = new kms.Key(this, 'myKey');\n\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_7_0,\n  artifactsBucketLifecycleRules: [{\n    expiration: Duration.days(30),\n  }],\n  artifactS3EncryptionMode: synthetics.ArtifactsEncryptionMode.KMS,\n  artifactS3KmsKey: key,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Public Hosted Zones in Route53 with TypeScript\nDESCRIPTION: Demonstrates how to import existing public hosted zones in Route53 with two different methods - one that imports both zone name and ID, and another that imports only the ID.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst zoneFromAttributes = route53.PublicHostedZone.fromPublicHostedZoneAttributes(this, 'MyZone', {\n  zoneName: 'example.com',\n  hostedZoneId: 'ZOJJZC49E0EPZ',\n});\n\n// Does not know zoneName\nconst zoneFromId = route53.PublicHostedZone.fromPublicHostedZoneId(this, 'MyZone', 'ZOJJZC49E0EPZ');\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon Pinpoint Analytics for Cognito User Pool Clients (Same Account) using AWS CDK - TypeScript\nDESCRIPTION: This code demonstrates how to configure Cognito user pool client analytics by associating a Pinpoint project from the same AWS account. Dependencies include aws-cdk-lib/aws-pinpoint and IAM role configuration, plus Cognito resources. Parameters are the analytics.application property for the Pinpoint app and shareUserData flag. Outputs are a user pool client with analytics enabled, limited to regions where Pinpoint is available.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pinpoint from 'aws-cdk-lib/aws-pinpoint';\n\ndeclare const userPool: cognito.UserPool;\ndeclare const pinpointApp: pinpoint.CfnApp;\ndeclare const pinpointRole: iam.Role;\n\nnew cognito.UserPoolClient(this, 'Client', {\n  userPool,\n  analytics: {\n    // Your Pinpoint project\n    application: pinpointApp,\n\n    // Whether to include user data in analytics events\n    shareUserData: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with No Initial Capacity and Adding Node Groups in TypeScript\nDESCRIPTION: Demonstrates how to create an EKS cluster with no initial capacity and then add node groups later, specifying the size range and instance types.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.NODEGROUP,\n  defaultCapacity: 0,\n});\n\n// Add node groups as needed\ncluster.addNodegroupCapacity('custom-node-group', {\n  minSize: 1,\n  maxSize: 3,\n  instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.LARGE)],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Outlier Detection to App Mesh Virtual Node\nDESCRIPTION: Shows how to configure outlier detection for a Virtual Node listener in App Mesh. Requires Cloud Map service discovery and includes configuration for ejection duration, interval, maximum ejection percentage, and server error thresholds.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'vpc');\nconst namespace = new cloudmap.PrivateDnsNamespace(this, 'test-namespace', {\n    vpc,\n    name: 'domain.local',\n});\nconst service = namespace.createService('Svc');\n\ndeclare const mesh: appmesh.Mesh;\nconst node = mesh.addVirtualNode('virtual-node', {\n  serviceDiscovery: appmesh.ServiceDiscovery.cloudMap(service),\n  listeners: [appmesh.VirtualNodeListener.http({\n    outlierDetection: {\n      baseEjectionDuration: Duration.seconds(10),\n      interval: Duration.seconds(30),\n      maxEjectionPercent: 50,\n      maxServerErrors: 5,\n    },\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-User Credential Rotation for Redshift Cluster\nDESCRIPTION: Sets up the multi-user rotation scheme for a specific Redshift user's credentials stored in AWS Secrets Manager. This requires creating a `User` construct first and then calling `cluster.addRotationMultiUser()` with a name for the rotation configuration and the user's secret. Requires `User` import and existing `cluster` object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\n\nconst user = new User(this, 'User', {\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\ncluster.addRotationMultiUser('MultiUserRotation', {\n  secret: user.secret,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Associating FSx Lustre File System with S3 Data Repository in TypeScript\nDESCRIPTION: This example configures a data repository association (DRA) between an FSx for Lustre file system and an S3 bucket, enabling hierarchical storage management. Dependencies include the 'aws_s3' module, an existing VPC, and bucket. Parameters include export and import paths (provided via S3 URLs), deployment type, and auto import policy. This setup allows file metadata to be synchronized from the S3 backing store to FSx whenever changes occur. Outputs a linked FSx file system with S3 as its data repository. Not supported for 'PERSISTENT_2' deployment type in CloudFormation/CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { aws_s3 as s3 } from 'aws-cdk-lib';\n\ndeclare const vpc: ec2.Vpc;\ndeclare const bucket: s3.Bucket;\n\nconst lustreConfiguration = {\n  deploymentType: fsx.LustreDeploymentType.SCRATCH_2,\n  exportPath: bucket.s3UrlForObject(),\n  importPath: bucket.s3UrlForObject(),\n  autoImportPolicy: fsx.LustreAutoImportPolicy.NEW_CHANGED_DELETED,\n};\n\nconst fs = new fsx.LustreFileSystem(this, \"FsxLustreFileSystem\", {\n  vpc: vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n  storageCapacityGiB: 1200,\n  lustreConfiguration,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring EventBridge Integration with CDK\nDESCRIPTION: TypeScript code for setting up AppSync-EventBridge integration using AWS CDK, including API and resolver configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as events from 'aws-cdk-lib/aws-events';\n\nconst api = new appsync.GraphqlApi(this, 'EventBridgeApi', {\n  name: 'EventBridgeApi',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.eventbridge.graphql')),\n});\n\nconst bus = new events.EventBus(this, 'DestinationEventBus', {});\n\nconst dataSource = api.addEventBridgeDataSource('NoneDS', bus);\n\ndataSource.createResolver('EventResolver', {\n  typeName: 'Mutation',\n  fieldName: 'emitEvent',\n  requestMappingTemplate: appsync.MappingTemplate.fromFile('request.vtl'),\n  responseMappingTemplate: appsync.MappingTemplate.fromFile('response.vtl'),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimal DynamoDB Table in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic DynamoDB table with a partition key using the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Function Variable with Search in AWS CDK\nDESCRIPTION: This snippet demonstrates how to create a variable for Lambda functions using a metric query search. It uses a radio input type and populates values from the search results.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cw from 'aws-cdk-lib/aws-cloudwatch';\n\nconst dashboard = new cw.Dashboard(this, 'Dash', {\n  defaultInterval: Duration.days(7),\n  variables: [new cw.DashboardVariable({\n    id: 'functionName',\n    type: cw.VariableType.PATTERN,\n    label: 'Function',\n    inputType: cw.VariableInputType.RADIO,\n    value: 'originalFuncNameInDashboard',\n    // equivalent to cw.Values.fromSearch('{AWS/Lambda,FunctionName} MetricName=\\\"Duration\\\"', 'FunctionName')\n    values: cw.Values.fromSearchComponents({\n      namespace: 'AWS/Lambda',\n      dimensions: ['FunctionName'],\n      metricName: 'Duration',\n      populateFrom: 'FunctionName',\n    }),\n    defaultValue: cw.DefaultValue.FIRST,\n    visible: true,\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: EventBridge Request Mapping Template\nDESCRIPTION: Velocity template for mapping GraphQL mutations to EventBridge PutEvents operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_6\n\nLANGUAGE: velocity\nCODE:\n```\n{\n    \"version\" : \"2018-05-29\",\n    \"operation\": \"PutEvents\",\n    \"events\" : [\n        {\n            \"source\": \"integ.appsync.eventbridge\",\n            \"detailType\": \"Mutation.emitEvent\",\n            \"detail\": $util.toJson($context.arguments)\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AppRunner Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the AWS AppRunner construct library from the AWS CDK library in TypeScript. The 'apprunner' module provides access to L1 constructs for AWS AppRunner, enabling infrastructure as code for AppRunner resources that mirror CloudFormation resources. Dependency required: 'aws-cdk-lib' package. To use, ensure 'aws-cdk-lib' is installed, then import as shown. This import exposes all AppRunner L1 constructs under the 'apprunner' namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apprunner/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as apprunner from 'aws-cdk-lib/aws-apprunner';\n```\n\n----------------------------------------\n\nTITLE: Granting Read Permissions to CloudWatch Log Group in TypeScript\nDESCRIPTION: Simplified method to grant read permissions to a CloudWatch Log Group for the Elasticsearch service principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst logGroup = new logs.LogGroup(this, 'LogGroup');\nlogGroup.grantRead(new iam.ServicePrincipal('es.amazonaws.com'));\n```\n\n----------------------------------------\n\nTITLE: Verifying README Examples in AWS CDK\nDESCRIPTION: Command to run the Rosetta script, which ensures that sample code in README files compiles correctly. This is important for maintaining accurate documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ /bin/bash ./scripts/run-rosetta.sh\n```\n\n----------------------------------------\n\nTITLE: Defining QueueProcessingEc2ServiceProps Interface in TypeScript\nDESCRIPTION: Interface specifying EC2-specific properties for queue processing including CPU and memory configurations for the container.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-autoscaling-queue-worker.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface QueueProcessingEc2ServiceProps {\n  readonly cpu?: number;\n  readonly memoryLimitMiB?: number;\n  readonly memoryReservationMiB?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebHostedImage Class for Container Images in TypeScript\nDESCRIPTION: This snippet shows the implementation of the WebHostedImage class, which replaces the DockerHubImage class. It includes support for optional credentials and methods for binding these credentials to a container definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-priv-registry-support.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// define props\nexport interface WebHostedImageProps {\n    credentials: RepositoryCreds;\n}\n\n// \"DockerHubImage\" class --> \"WebHostedImage\"\nexport class WebHostedImage implements IContainerImage {\n  public readonly imageName: string;\n  public readonly credentials: IRepositoryCreds;\n\n  // add credentials to constructor\n  constructor(imageName: string, props: WebHostedImageProps) {\n    this.imageName = imageName\n    this.credentials = props.credentials\n  }\n\n  public bind(_containerDefinition: ContainerDefinition): void {\n    // bind repositoryCredentials to ContainerDefinition\n    this.repositoryCredentials.bind();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Daily, Weekly, and Monthly AWS Backup Plan with 5-Year Retention - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to create a comprehensive AWS Backup Plan with a daily, weekly, and monthly backup schedule and 5-year retention period using the AWS CDK in TypeScript. Requires the AWS CDK backup module and a CDK construct scope (such as a Stack or Construct). The resulting plan automates backup policies for supported AWS resources. No inputs beyond the construct scope and the plan name; outputs a BackupPlan instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Daily, weekly and monthly with 5 year retention\nconst plan = backup.BackupPlan.dailyWeeklyMonthly5YearRetention(this, 'Plan');\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Branch Creation and Deletion in TypeScript\nDESCRIPTION: Sets up automatic branch creation and deletion for an Amplify app based on repository activity. This allows Amplify to automatically connect new branches that match specific patterns and remove them when deleted from the repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-github-token'),\n  }),\n  autoBranchCreation: { // Automatically connect branches that match a pattern set\n    patterns: ['feature/*', 'test/*'],\n  },\n  autoBranchDeletion: true, // Automatically disconnect a branch when you delete a branch from your repository\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Kinesis Subscription Filter for CloudWatch Logs in TypeScript\nDESCRIPTION: Creates a Subscription Filter that sends log events to a Kinesis Stream with RANDOM distribution method for log data distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as destinations from 'aws-cdk-lib/aws-logs-destinations';\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\ndeclare const stream: kinesis.Stream;\ndeclare const logGroup: logs.LogGroup;\n\nnew logs.SubscriptionFilter(this, 'Subscription', {\n  logGroup,\n  destination: new destinations.KinesisDestination(stream),\n  filterPattern: logs.FilterPattern.allTerms(\"ERROR\", \"MainThread\"),\n  filterName: 'ErrorInMainThread',\n  distribution: logs.Distribution.RANDOM,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring a Custom Stack Synthesizer in TypeScript\nDESCRIPTION: Illustrates how to configure a stack with a specific synthesizer. This example instantiates a custom stack (`MyStack`) and passes a `DefaultStackSynthesizer` instance in the stack properties, customizing it to use a specific S3 bucket (`amzn-s3-demo-bucket`) for file assets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew MyStack(app, 'MyStack', {\n  synthesizer: new DefaultStackSynthesizer({\n    fileAssetsBucketName: 'amzn-s3-demo-bucket',\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring API Gateway v2 HTTP API Endpoint for IPv4 and Dual Stack in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet configures the ipAddressType property of the HttpApi construct to enable support for both IPv4 and IPv6 endpoints (DUAL_STACK). Requires aws-cdk-lib/aws-apigatewayv2. Inputs: ipAddressType property. Outputs: HttpApi instance with dual stack support, making the API accessible via both IPv4 and IPv6.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew apigwv2.HttpApi(this, 'HttpApi', {\n  ipAddressType: apigwv2.IpAddressType.DUAL_STACK,\n});\n```\n\n----------------------------------------\n\nTITLE: Running Node-Bundle Command Line Help\nDESCRIPTION: Example of accessing the help documentation for the node-bundle CLI tool, which shows available commands and options for bundling Node.js packages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/node-bundle/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ node-bundle --help\nUsage: node-bundle COMMAND\n\nCommands:\n  node-bundle validate  Validate the package is ready for bundling\n  node-bundle write     Write the bundled version of the project to a temp\n                        directory\n  node-bundle pack      Write the bundle and create the tarball\n\nOptions:\n  --entrypoint       List of entrypoints to bundle                       [array]\n  --external         Packages in this list will be excluded from the bundle and\n                     added as dependencies (example: fsevents:optional)\n                                                           [array] [default: []]\n  --allowed-license  List of valid licenses                [array] [default: []]\n  --resource         List of resources that need to be explicitly copied to the\n                     bundle (example:\n                     node_modules/proxy-agent/contextify.js:bin/contextify.js)\n                                                           [array] [default: []]\n  --dont-attribute   Dependencies matching this regular expressions wont be\n                     added to the notice file                           [string]\n  --test             Validation command to sanity test the bundle after its\n                     created                                            [string]\n  --help             Show help                                         [boolean]\n  --version          Show version number                               [boolean]\n```\n\n----------------------------------------\n\nTITLE: Registering New Region Information in TypeScript\nDESCRIPTION: Demonstrates how to add missing regional information by implementing the IFact interface and registering a new fact in the database.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/region-info/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyFact implements regionInfo.IFact {\n  public readonly region = 'bermuda-triangle-1';\n  public readonly name = regionInfo.FactName.S3_STATIC_WEBSITE_ENDPOINT;\n  public readonly value = 's3-website.bermuda-triangle-1.nowhere.com';\n}\n\nregionInfo.Fact.register(new MyFact());\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Groups for Scheduled Fargate Task\nDESCRIPTION: Sets up a Fargate task with custom security groups, VPC configuration, and cluster settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'Vpc', { maxAzs: 1 });\nconst cluster = new ecs.Cluster(this, 'EcsCluster', { vpc });\nconst securityGroup = new ec2.SecurityGroup(this, 'SG', { vpc });\n\nconst scheduledFargateTask = new ecsPatterns.ScheduledFargateTask(this, 'ScheduledFargateTask', {\n  cluster,\n  scheduledFargateTaskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    memoryLimitMiB: 512,\n  },\n  schedule: appscaling.Schedule.expression('rate(1 minute)'),\n  securityGroups: [securityGroup],\n});\n```\n\n----------------------------------------\n\nTITLE: Maintaining Logical ID When Migrating CloudFront Distribution in TypeScript\nDESCRIPTION: This code demonstrates how to maintain the same logical ID for the underlying CfnDistribution when migrating from CloudFrontWebDistribution to the newer Distribution construct, avoiding deletion and recreation of the distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\n\nconst myDistribution = new cloudfront.Distribution(this, 'MyCfWebDistribution', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(sourceBucket),\n  },\n});\nconst cfnDistribution = myDistribution.node.defaultChild as cloudfront.CfnDistribution;\ncfnDistribution.overrideLogicalId('MyDistributionCFDistribution3H55TI9Q');\n```\n\n----------------------------------------\n\nTITLE: Implementing API Metrics\nDESCRIPTION: Shows how to access and configure CloudWatch metrics for both API and stage-level monitoring.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new apigwv2.HttpApi(this, 'my-api');\nconst clientErrorMetric = api.metricClientError();\n```\n\n----------------------------------------\n\nTITLE: Enabling Additional CloudFront Distribution Metrics in TypeScript\nDESCRIPTION: This code shows how to enable and retrieve additional CloudFront distribution metrics, including specific error rates, origin latency, and cache hit rate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst dist = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n  publishAdditionalMetrics: true,\n});\n\n// Retrieving additional distribution metrics\nconst latencyMetric = dist.metricOriginLatency();\nconst cacheHitRateMetric = dist.metricCacheHitRate();\nconst http401ErrorRateMetric = dist.metric401ErrorRate();\nconst http403ErrorRateMetric = dist.metric403ErrorRate();\nconst http404ErrorRateMetric = dist.metric404ErrorRate();\nconst http502ErrorRateMetric = dist.metric502ErrorRate();\nconst http503ErrorRateMetric = dist.metric503ErrorRate();\nconst http504ErrorRateMetric = dist.metric504ErrorRate();\n```\n\n----------------------------------------\n\nTITLE: Using Command Hooks for Pre/Post-Build Actions\nDESCRIPTION: Demonstrates how to run additional commands before or after the bundling process. This example shows running Go tests before bundling the function code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// This example only available in TypeScript\n// Run additional commands on a GoFunction via `commandHooks` property\nnew go.GoFunction(this, 'handler', {\n  bundling: {\n    commandHooks: {\n      // run tests\n      beforeBundling(inputDir: string): string[] {\n        return ['go test ./cmd/api -v'];\n      },\n      // ...\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a One Zone EFS File System (Specific AZ) in TypeScript\nDESCRIPTION: Initializes an EFS file system configured for One Zone storage within a specific Availability Zone ('us-east-1b' in this example). This requires setting `oneZone: true` and explicitly defining the single target Availability Zone within the `vpcSubnets` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew efs.FileSystem(this, 'OneZoneFileSystem', {\n  vpc,\n  oneZone: true,\n  vpcSubnets: {\n    availabilityZones: ['us-east-1b'],\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Individual Subnets in TypeScript\nDESCRIPTION: Shows how to import individual subnets using the SubnetV2.fromSubnetV2Attributes() method, which is useful for working with specific subnets independently of a VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nSubnetV2.fromSubnetV2Attributes(this, 'ImportedSubnet', {\n  subnetId: 'subnet-0123456789abcdef0',\n  availabilityZone: 'us-west-2a',\n  ipv4CidrBlock: '10.2.0.0/24',\n  routeTableId: 'rtb-0871c310f98da2cbb',\n  subnetType: SubnetType.PRIVATE_ISOLATED,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Attribute Mapping for Amazon Identity Provider in Cognito User Pool\nDESCRIPTION: This code demonstrates how to map attributes from 'Login With Amazon' to standard and custom attributes in a Cognito User Pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst userpool = new cognito.UserPool(this, 'Pool');\n\nnew cognito.UserPoolIdentityProviderAmazon(this, 'Amazon', {\n  clientId: 'amzn-client-id',\n  clientSecret: 'amzn-client-secret',\n  userPool: userpool,\n  attributeMapping: {\n    email: cognito.ProviderAttribute.AMAZON_EMAIL,\n    website: cognito.ProviderAttribute.other('url'), // use other() when an attribute is not pre-defined in the CDK\n    custom: {\n      // custom user pool attributes go here\n      uniqueId: cognito.ProviderAttribute.AMAZON_USER_ID,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Same-Account/Same-Region VPC Peering with AWS CDK (TypeScript)\nDESCRIPTION: Illustrates defining two `VpcV2` instances within the same CDK stack (implying the same AWS account and region) with non-overlapping CIDR blocks. It then establishes a VPC peering connection between them using the `vpcA.createPeeringConnection` method, passing the acceptor VPC object. Dependencies include `@aws-cdk/core` (for Stack) and implicitly `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\n\nconst vpcA = new VpcV2(this, 'VpcA', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/16'),\n});\n\nconst vpcB = new VpcV2(this, 'VpcB', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n});\n\nconst peeringConnection = vpcA.createPeeringConnection('sameAccountSameRegionPeering', {\n  acceptorVpc: vpcB,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding ARM64 Managed and Self-Managed Nodegroups - AWS CDK - TypeScript\nDESCRIPTION: Illustrates adding both managed and self-managed nodegroup capacities with ARM64 architecture to an existing EKS cluster. The correct Amazon Linux 2 AMI for ARM64 is automatically selected. The example requires ARM64-compatible EC2 instance types (e.g., m6g.medium) and an initialized eks.Cluster construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n// add a managed ARM64 nodegroup\ncluster.addNodegroupCapacity('extra-ng-arm', {\n  instanceTypes: [new ec2.InstanceType('m6g.medium')],\n  minSize: 2,\n});\n\n// add a self-managed ARM64 nodegroup\ncluster.addAutoScalingGroupCapacity('self-ng-arm', {\n  instanceType: new ec2.InstanceType('m6g.medium'),\n  minCapacity: 2,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Ingress Traffic Rules for GameLift Fleet in TypeScript\nDESCRIPTION: Sets up ingress rules to allow external traffic to reach game sessions on a GameLift fleet. This example shows both defining rules in the constructor and adding rules to an existing fleet.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\n\nconst fleet = new gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n    }]\n  },\n  ingressRules: [{\n    source: gamelift.Peer.anyIpv4(),\n    port: gamelift.Port.tcpRange(100, 200),\n  }]\n});\n// Allowing a specific CIDR for port 1111 on UDP Protocol\nfleet.addIngressRule(gamelift.Peer.ipv4('1.2.3.4/32'), gamelift.Port.udp(1111));\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-Region KMS Key Using AWS CDK in TypeScript\nDESCRIPTION: Defines a multi-region primary KMS key with the 'multiRegion' property set to true. Multi-region support enables cryptographic operations across AWS regions with a globally unique key. By default, multiRegion is false. Requires 'aws-cdk-lib/aws-kms'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey', {\n  multiRegion: true, // Default is false\n});\n```\n\n----------------------------------------\n\nTITLE: Utilizing Action-level Variables - AWS CodePipeline - TypeScript\nDESCRIPTION: Shows how to use action-level variables within CodePipeline actions using the AWS CDK. Variables exposed by an action can be referenced in subsequent actions via the '.variables' interface, and a custom variables namespace can be assigned for clarity. Also demonstrates the usage of global variables available through the 'GlobalVariables' class. Key points include how to reference action-emitted variables and assign custom namespaces for variable scoping.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// MyAction is some action type that produces variables, like EcrSourceAction\nconst myAction = new MyAction({\n  // ...\n  actionName: 'myAction',\n});\nnew OtherAction({\n  // ...\n  config: myAction.variables.myVariable,\n  actionName: 'otherAction',\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// MyAction is some action type that produces variables, like EcrSourceAction\nconst myAction = new MyAction({\n  // ...\n  variablesNamespace: 'MyNamespace',\n  actionName: 'myAction',\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// OtherAction is some action type that produces variables, like EcrSourceAction\nnew OtherAction({\n  // ...\n  config: codepipeline.GlobalVariables.executionId,\n  actionName: 'otherAction',\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Node Group Capacity to EKS Cluster\nDESCRIPTION: Demonstrates adding a custom node group to an EKS cluster with specific configuration for instance types, size, and storage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.NODEGROUP,\n  defaultCapacity: 0,\n});\n\ncluster.addNodegroupCapacity('custom-node-group', {\n  instanceTypes: [new ec2.InstanceType('m5.large')],\n  minSize: 4,\n  diskSize: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing DynamoDB Tables in TypeScript\nDESCRIPTION: This example shows how to reference an existing DynamoDB table using its ARN and grant read/write permissions to a user.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const user: iam.User;\nconst table = dynamodb.Table.fromTableArn(this, 'ImportedTable', 'arn:aws:dynamodb:us-east-1:111111111:table/my-table');\n// now you can just call methods on the table\ntable.grantReadWriteData(user);\n```\n\n----------------------------------------\n\nTITLE: Creating a Kinesis Data Stream Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a Kinesis data stream as the target. The pipe will send events from an SQS queue source to the data stream with the specified partition key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetStream: kinesis.Stream;\n\nconst streamTarget = new targets.KinesisTarget(targetStream, {\n    partitionKey: 'pk',\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: streamTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Using Array Matchers in AWS CDK Template Testing\nDESCRIPTION: Demonstrates how to use Match.arrayWith() and Match.arrayEquals() to assert array properties in CDK template resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": [\"Flob\", \"Cat\"]\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.arrayWith(['Flob']),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', Match.objectLike({\n  Fred: Match.arrayWith(['Wobble']),\n}));\n```\n\n----------------------------------------\n\nTITLE: Using mime-db library in Node.js (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates the basic usage of the `mime-db` library within a Node.js application. It imports the database using `require('mime-db')` and then accesses the information associated with the 'application/javascript' MIME type using property lookup on the returned database object. Assumes the 'mime-db' package has been installed via npm.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-db/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar db = require('mime-db')\n\n// grab data on .js files\nvar data = db['application/javascript']\n```\n\n----------------------------------------\n\nTITLE: Granting HMAC GenerateMac and VerifyMac Permissions Using AWS CDK in TypeScript\nDESCRIPTION: Shows how to grant an IAM user permissions to generate or verify HMAC (mac) values using a specific KMS key. These methods attach 'kms:GenerateMac' and 'kms:VerifyMac' actions, respectively, to the principal's policy. Typically used with HMAC key types. Requires 'aws-cdk-lib/aws-kms' and 'aws-cdk-lib/aws-iam'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey');\nconst user = new iam.User(this, 'MyUser');\nkey.grantGenerateMac(user); // Adds 'kms:GenerateMac' to the principal's policy\nkey.grantVerifyMac(user); // Adds 'kms:VerifyMac' to the principal's policy\n```\n\n----------------------------------------\n\nTITLE: Configuring Point-in-Time Recovery for DynamoDB Table in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates configuring Point-in-Time Recovery (PITR) for an AWS DynamoDB table using the AWS CDK. It enables PITR by setting `pointInTimeRecoveryEnabled` to `true` and specifies a custom recovery period of 4 days using `recoveryPeriodInDays` within the `pointInTimeRecoverySpecification` property. Requires the `@aws-cdk/aws-dynamodb` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n  pointInTimeRecoverySpecification: {\n    pointInTimeRecoveryEnabled: true,\n    recoveryPeriodInDays: 4,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Alarm for GameLift Server Utilization in TypeScript\nDESCRIPTION: Creates a CloudWatch alarm that monitors the percentage of utilized game servers in a GameLift FleetIQ group. The alarm triggers when server utilization exceeds 90% for 2 evaluation periods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gameServerGroup: gamelift.IGameServerGroup;\n// Alarm that triggers when the percent of utilized game servers exceed 90%\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: gameServerGroup.metric('UtilizedGameServers'),\n  threshold: 0.9,\n  evaluationPeriods: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Target Input from a JSON Object (AWS CDK, TypeScript)\nDESCRIPTION: Shows how to build a JSON-formatted input payload for a schedule target using ScheduleTargetInput.fromObject. This input will be delivered to the target upon invocation. Input is an object of key-value pairs; output is a compatible input for schedule targets. Dependency: ScheduleTargetInput.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst input = ScheduleTargetInput.fromObject({\n    'QueueName': 'MyQueue'\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Kinesis Stream for DynamoDB in TypeScript\nDESCRIPTION: This example shows how to configure a Kinesis Data Stream on a DynamoDB table to capture item-level changes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kinesis from 'aws-cdk-lib/aws-kinesis';\n\nconst stream = new kinesis.Stream(this, 'Stream');\n\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  kinesisStream: stream,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a VPC with IPv4 and IPv6 Support using VpcV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a VPC using the VpcV2 construct with both IPv4 and IPv6 address blocks. It specifies a primary IPv4 CIDR and adds an Amazon-provided IPv6 CIDR as a secondary address block.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nnew VpcV2(this, 'Vpc', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/24'),\n  secondaryAddressBlocks: [\n    IpAddresses.amazonProvidedIpv6({cidrBlockName: 'AmazonProvidedIpv6'}),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Current CDK Tagging API Usage in TypeScript\nDESCRIPTION: Example of how tags are currently applied and removed in the AWS CDK using the node.applyAspect method, which is considered verbose and unintuitive.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/tagging-API-change.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nmyConstruct.node.applyAspect(new Tag('key', 'value'));\n\nmyConstruct.node.applyAspect(new RemoveTag('key', 'value'));\n```\n\n----------------------------------------\n\nTITLE: Creating EKS Cluster with AWS CLI and Helm in Lambda Layer - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates instantiating an EKS cluster with a kubectl Lambda handler, where kubectl, helm, and the AWS CLI are provided via Lambda layers. The Lambda layer version must match the Kubernetes cluster version. Outputs a fully configured eks.Cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nconst cluster = new eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Queued Matchmaking Configuration in GameLift FlexMatch with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a queued matchmaking configuration in GameLift FlexMatch. It uses a game session queue and a matchmaking ruleset to configure the matchmaker.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const queue: gamelift.GameSessionQueue;\ndeclare const ruleSet: gamelift.MatchmakingRuleSet;\n\nnew gamelift.QueuedMatchmakingConfiguration(this, 'QueuedMatchmakingConfiguration', {\n  matchmakingConfigurationName: 'test-queued-config-name',\n  gameSessionQueues: [queue],\n  ruleSet: ruleSet,\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Additional Data to S3 Object Lambda Function\nDESCRIPTION: Example demonstrating how to provide supplemental data to the Lambda function used to transform objects. The data is delivered as a JSON payload to the Lambda function, which can be used for configuration or context information.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3objectlambda-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\nimport * as s3objectlambda from '@aws-cdk/aws-s3objectlambda-alpha';\nimport * as cdk from 'aws-cdk-lib';\n\nconst stack = new cdk.Stack();\nconst bucket = new s3.Bucket(stack, 'MyBucket');\nconst handler = new lambda.Function(stack, 'MyFunction', {\n\truntime: lambda.Runtime.NODEJS_LATEST,\n\thandler: 'index.handler',\n\tcode: lambda.Code.fromAsset('lambda.zip'),\n});\nnew s3objectlambda.AccessPoint(stack, 'MyObjectLambda', {\n\tbucket,\n\thandler,\n\taccessPointName: 'my-access-point',\n\tpayload: {\n\t\tprop: \"value\",\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a One Zone EFS File System (Default AZ) in TypeScript\nDESCRIPTION: Initializes an EFS file system configured for One Zone storage within a given VPC. By setting the `oneZone` property to `true`, the file system's data is stored within a single Availability Zone, automatically selecting the first available AZ in the VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew efs.FileSystem(this, 'OneZoneFileSystem', {\n  vpc,\n  oneZone: true,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Zone with Trailing Dot in TypeScript\nDESCRIPTION: Creates a Route53 hosted zone with a domain name that already includes a trailing dot, preventing the CDK from automatically adding an additional dot. This is useful for managing existing domains that have trailing dots.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nnew route53.PublicHostedZone(this, 'HostedZone', {\n  zoneName: 'fully.qualified.domain.com.',\n  addTrailingDot: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from Secrets Manager using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an AWS AppConfig `SourcedConfiguration` using a secret stored in AWS Secrets Manager as the configuration source. It requires an existing `appconfig.Application` instance and a `secrets.Secret` instance. The `location` property is configured using `appconfig.ConfigurationSource.fromSecret()`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const secret: secrets.Secret;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromSecret(secret),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with Mixed Auto Mode and Node Groups in TypeScript\nDESCRIPTION: Shows how to create an EKS cluster combining Auto Mode with traditional node groups for specific workload requirements, including node pool configuration and a specialized node group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'Cluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.AUTOMODE,\n  compute: {\n    nodePools: ['system', 'general-purpose'],\n  },\n});\n\n// Add specialized node group for specific workloads\ncluster.addNodegroupCapacity('specialized-workload', {\n  minSize: 1,\n  maxSize: 3,\n  instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.XLARGE)],\n  labels: {\n    workload: 'specialized',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying a Custom IAM Role for GameLift FleetIQ Group (TypeScript)\nDESCRIPTION: This snippet details how to provide a custom IAM role for a GameLift FleetIQ GameServerGroup, enabling explicit control over permissions required by GameLift and Auto Scaling. It constructs a composite principal IAM role with attached managed policy and then references it during GameServerGroup instantiation. Inputs are launch template, VPC, and configured IAM role; output is a server group using the specified role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const launchTemplate: ec2.ILaunchTemplate;\ndeclare const vpc: ec2.IVpc;\n\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.CompositePrincipal(new iam.ServicePrincipal('gamelift.amazonaws.com'),\n  new iam.ServicePrincipal('autoscaling.amazonaws.com'))\n});\nrole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('GameLiftGameServerGroupPolicy'));\n\nnew gamelift.GameServerGroup(this, 'Game server group', {\n  gameServerGroupName: 'sample-gameservergroup-name',\n  instanceDefinitions: [{\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  },\n  {\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  }],\n  launchTemplate: launchTemplate,\n  vpc: vpc,\n  role: role\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Transit Gateway Route Table Associations and Propagations (AWS CDK TypeScript)\nDESCRIPTION: Shows how to associate Transit Gateway attachments with route tables and enable route propagation using AWS CDK in TypeScript. addAssociation() links an attachment to a route table for routing, while enablePropagation() advertises routes from the attachment to the route table. All resources (TransitGateway, VPC, subnet, attachment) must exist. The output is a customized route table associated with and propagating from specific attachments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\nconst routeTable = transitGateway.addRouteTable('CustomRouteTable');\nconst myVpc = new VpcV2(this, 'Vpc');\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\nconst attachment = transitGateway.attachVpc('VpcAttachment', {\n  vpc: myVpc, \n  subnets: [subnet]\n});\n\n// Associate an attachment with a route table\nrouteTable.addAssociation('Association', attachment);\n\n// Enable route propagation for an attachment\nrouteTable.enablePropagation('Propagation', attachment);\n```\n\n----------------------------------------\n\nTITLE: Enabling Full Precision in TableWidget Cells (TypeScript)\nDESCRIPTION: Demonstrates how to set the fullPrecision property on a TableWidget to display as many digits as can fit before rounding. Requires AWS CDK Dashboard and TableWidget objects. Shows unrounded precise values in table cells.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  // ...\n\n  fullPrecision: true,\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Tracker in AWS Location Service\nDESCRIPTION: Creates a new Tracker resource with an optional custom name and KMS key for encryption. Trackers store position updates for devices and can be used to query current location or location history.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const key: kms.Key;\n\nnew location.Tracker(this, 'Tracker', {\n  trackerName: 'MyTracker', // optional, defaults to a generated name\n  kmsKey: key, // optional, defaults to use an AWS managed key\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Settings in JavaScript Module\nDESCRIPTION: JavaScript configuration module that exports project settings including project number, project ID, and field IDs for Priority, Status, and Needs Attention. This file needs to be updated with the IDs retrieved from the GraphQL query.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/scripts/prioritization/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// project-config.js\nmodule.exports = {\n  ...\n  projectNumber: 263,         // Project Number\n  projectId: \"xxx\",           // Project ID\n  priorityFieldId: \"xxx\",     // Priority field ID\n  statusFieldId: \"xxx\",       // Status field ID\n  attentionFieldId: \"xxx\",    // Needs Attention field ID\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Redirection Rules to Amplify App in TypeScript\nDESCRIPTION: Shows how to configure custom URL redirection rules for an Amplify application. This example demonstrates setting up a temporary redirect from one specific URL to another.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const amplifyApp: amplify.App;\namplifyApp.addCustomRule({\n  source: '/docs/specific-filename.html',\n  target: '/documents/different-filename.html',\n  status: amplify.RedirectStatus.TEMPORARY_REDIRECT,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling installLatestAwsSdk in CloudWatch LogGroup Custom Resource - TypeScript\nDESCRIPTION: This example illustrates how to configure the CloudWatch LogGroup event target in EventBridge to set installLatestAwsSdk to false. By default, an AWS custom resource is created with installLatestAwsSdk set to true, which may cause deployment issues in certain AWS partitions (e.g., China). This option disables the SDK installation. Dependencies include aws-cdk-lib/aws-logs and aws-cdk-lib/aws-events; the LogGroup and rule must already exist.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\ndeclare const logGroup: logs.LogGroup;\ndeclare const rule: events.Rule;\n\nrule.addTarget(new targets.CloudWatchLogGroup(logGroup, {\n  installLatestAwsSdk: false,\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross Account Zone Delegation with Custom STS Region in TypeScript\nDESCRIPTION: Creates a cross-account zone delegation with a specific AWS region for the STS AssumeRole operation. This is needed when both accounts must be opted-in to the region used for credential validation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst subZone = new route53.PublicHostedZone(this, 'SubZone', {\n  zoneName: 'sub.someexample.com',\n});\n\n// import the delegation role by constructing the roleArn\nconst delegationRoleArn = Stack.of(this).formatArn({\n  region: '', // IAM is global in each partition\n  service: 'iam',\n  account: 'parent-account-id',\n  resource: 'role',\n  resourceName: 'MyDelegationRole',\n});\nconst delegationRole = iam.Role.fromRoleArn(this, 'DelegationRole', delegationRoleArn);\n\nnew route53.CrossAccountZoneDelegationRecord(this, 'delegate', {\n  delegatedZone: subZone,\n  parentHostedZoneName: 'someexample.com', // or you can use parentHostedZoneId\n  delegationRole,\n  assumeRoleRegion: \"us-east-1\",\n});\n```\n\n----------------------------------------\n\nTITLE: Importing a Complex VPC with Multiple CIDR Blocks and Subnets in TypeScript\nDESCRIPTION: Demonstrates importing a VPC with multiple CIDR blocks, including secondary IPv4 and IPv6 blocks, IPAM pools, and different subnet types. Also shows how to add new subnets and gateways to the imported VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\n\nconst importedVpc = VpcV2.fromVpcV2Attributes(this, 'ImportedVPC', {\n  vpcId: 'vpc-XXX',\n  vpcCidrBlock: '10.1.0.0/16',\n  secondaryCidrBlocks: [\n    {\n      cidrBlock: '10.2.0.0/16',\n      cidrBlockName: 'ImportedBlock1',\n    },\n    {\n      ipv6IpamPoolId: 'ipam-pool-XXX',\n      ipv6NetmaskLength: 52,\n      cidrBlockName: 'ImportedIpamIpv6',\n    },\n    {\n      ipv4IpamPoolId: 'ipam-pool-XXX',\n      ipv4IpamProvisionedCidrs: ['10.2.0.0/16'],\n      cidrBlockName: 'ImportedIpamIpv4',\n    },\n    {\n      amazonProvidedIpv6CidrBlock: true,\n    }\n  ],\n  subnets: [{\n    subnetName: 'IsolatedSubnet2',\n    subnetId: 'subnet-03cd773c0fe08ed26',\n    subnetType: SubnetType.PRIVATE_ISOLATED,\n    availabilityZone: 'us-west-2a',\n    ipv4CidrBlock: '10.2.0.0/24',\n    routeTableId: 'rtb-0871c310f98da2cbb',\n  },\n  {\n    subnetId: 'subnet-0fa477e01db27d820',\n    subnetType: SubnetType.PUBLIC,\n    availabilityZone: 'us-west-2b',\n    ipv4CidrBlock: '10.3.0.0/24',\n    routeTableId: 'rtb-014f3043098fe4b96',\n  }],\n});\n\n// You can now use the imported VPC in your stack\n\n// Adding a new subnet to the imported VPC\nconst importedSubnet = new SubnetV2(this, 'NewSubnet', {\n  availabilityZone: 'us-west-2a',\n  ipv4CidrBlock: new IpCidr('10.2.2.0/24'),\n  vpc: importedVpc,\n  subnetType: SubnetType.PUBLIC,\n});\n\n// Adding gateways to the imported VPC\nimportedVpc.addInternetGateway();\nimportedVpc.addNatGateway({ subnet: importedSubnet });\nimportedVpc.addEgressOnlyInternetGateway();\n```\n\n----------------------------------------\n\nTITLE: Creating a Redshift User with Custom Username in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Redshift user with a custom username.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nnew User(this, 'User', {\n  username: 'myuser',\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM permissions to a RouteCalculator (Legacy)\nDESCRIPTION: Demonstrates how to grant read permissions to an IAM role for a RouteCalculator resource. This allows the role to perform read operations on the route calculator.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\n\nconst routeCalculator = new location.RouteCalculator(this, 'RouteCalculator', {\n  dataSource: location.DataSource.ESRI,\n});\nrouteCalculator.grantRead(role);\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Values in CodePipeline Integration Test in TypeScript\nDESCRIPTION: This code snippet shows how to assert specific values from an API call response in a CodePipeline integration test. It demonstrates the use of the assertAtPath() method to check for expected values at specific paths in the response object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as integ from '@aws-cdk/integ-tests-alpha';\n\ndeclare const app: App;\ndeclare const stack: Stack;\ndeclare const pipelineName: string;\ndeclare const expectedString: string;\n\nconst testCase = new integ.IntegTest(app, 'PipelineAdditionalInputsTest', {\n  testCases: [stack],\n});\n\nconst source = testCase.assertions.awsApiCall('CodePipeline', 'GetPipeline', {\n  name: pipelineName,\n});\n\n// assert the value at the given path matches the expected string\n// the numbers index arrays in the json response object\nsource.assertAtPath('pipeline.stages.0.actions.0.name', integ.ExpectedResult.stringLikeRegexp(expectedString));\n```\n\n----------------------------------------\n\nTITLE: Fetching URL with Proxy Awareness using proxy-from-env in Node.js\nDESCRIPTION: This JavaScript example demonstrates how to use the `proxy-from-env` package to make HTTP requests that respect proxy settings defined in environment variables. It retrieves the appropriate proxy URL using `getProxyForUrl`, constructs the `http.get` options accordingly (either for a direct connection or via the proxy), and then performs the request, logging the response body. The example uses Node.js built-in modules `http` and `url`, along with the `proxy-from-env` package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/proxy-from-env/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar http = require('http');\nvar parseUrl = require('url').parse;\nvar getProxyForUrl = require('proxy-from-env').getProxyForUrl;\n\nvar some_url = 'http://example.com/something';\n\n// // Example, if there is a proxy server at 10.0.0.1:1234, then setting the\n// // http_proxy environment variable causes the request to go through a proxy.\n// process.env.http_proxy = 'http://10.0.0.1:1234';\n// \n// // But if the host to be proxied is listed in NO_PROXY, then the request is\n// // not proxied (but a direct request is made).\n// process.env.no_proxy = 'example.com';\n\nvar proxy_url = getProxyForUrl(some_url);  // <-- Our magic.\nif (proxy_url) {\n  // Should be proxied through proxy_url.\n  var parsed_some_url = parseUrl(some_url);\n  var parsed_proxy_url = parseUrl(proxy_url);\n  // A HTTP proxy is quite simple. It is similar to a normal request, except the\n  // path is an absolute URL, and the proxied URL's host is put in the header\n  // instead of the server's actual host.\n  httpOptions = {\n    protocol: parsed_proxy_url.protocol,\n    hostname: parsed_proxy_url.hostname,\n    port: parsed_proxy_url.port,\n    path: parsed_some_url.href,\n    headers: {\n      Host: parsed_some_url.host,  // = host name + optional port.\n    },\n  };\n} else {\n  // Direct request.\n  httpOptions = some_url;\n}\nhttp.get(httpOptions, function(res) {\n  var responses = [];\n  res.on('data', function(chunk) { responses.push(chunk); });\n  res.on('end', function() { console.log(responses.join(''));  });\n});\n```\n\n----------------------------------------\n\nTITLE: Markdown Link to Cloud Assembly Schema Documentation\nDESCRIPTION: A markdown link directing users to the cloud assembly schema documentation located in the aws-cdk-lib package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/cloud-assembly.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Cloud Assembly Specification, Version 2.0\n\nSee [cloud-assembly-schema](../packages/aws-cdk-lib/cloud-assembly-schema/README.md)\n```\n\n----------------------------------------\n\nTITLE: Lambda Enrichment Implementation for EventBridge Pipe\nDESCRIPTION: Example implementation of a Lambda function enrichment that can be used to process events in the pipe.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass LambdaEnrichment implements pipes.IEnrichment {\n  enrichmentArn: string;\n  private inputTransformation: pipes.InputTransformation  | undefined;\n  \n  constructor(private readonly lambda: lambda.Function, props: {inputTransformation?: pipes.InputTransformation} = {}) {\n    this.enrichmentArn = lambda.functionArn;\n    this.inputTransformation = props?.inputTransformation\n  }\n  \n  bind(pipe: pipes.IPipe): pipes.EnrichmentParametersConfig {\n    return {\n      enrichmentParameters: {\n        inputTemplate: this.inputTransformation?.bind(pipe).inputTemplate,\n      },\n    };\n  }\n  \n  grantInvoke(pipeRole: cdk.aws_iam.IRole): void {\n    this.lambda.grantInvoke(pipeRole);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming the Sum Custom Resource Output (AWS CDK, TypeScript)\nDESCRIPTION: This code shows how to instantiate the Sum construct, passing lhs and rhs as arguments, and export the computed result using a CfnOutput resource. It uses asString to ensure the result is output as a CloudFormation template string. Dependencies include the previously defined Sum construct and aws-cdk-lib CfnOutput. Inputs are numeric values, and output is a CloudFormation output with the sum as value.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst sum = new Sum(this, 'MySum', { lhs: 40, rhs: 2 });\nnew CfnOutput(this, 'Result', { value: Token.asString(sum.result) });\n```\n\n----------------------------------------\n\nTITLE: Granting Custom Permissions to IAM User on Kinesis Stream - AWS CDK - TypeScript\nDESCRIPTION: This example grants custom IAM permissions to a user for a specific Kinesis stream using the grant method, specifying the desired actions (such as kinesis:ListShards). Requires aws-cdk-lib, iam, kinesis, and constructs modules. Inputs are the User construct and permission actions; output is fine-grained resource access for the user.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = new iam.User(this, 'MyUser');\n\nconst stream = new kinesis.Stream(this, 'MyStream');\n\n// give my user permissions to list shards\nstream.grant(user, 'kinesis:ListShards');\n```\n\n----------------------------------------\n\nTITLE: Debug Configuration for VS Code\nDESCRIPTION: JSON configuration for setting up VS Code debugging with CDK applications, including workspace and launch configurations for TypeScript debugging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_58\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"folders\": [\n    { \"path\": \"<path-to-cdk-repo>/aws-cdk\" },\n    { \"path\": \"<path-to-cdk-app>/hello-cdk\" }\n  ],\n  \"launch\": {\n    \"configurations\": [{\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Debug hello-cdk\",\n      \"program\": \"${workspaceFolder:hello-cdk}/bin/hello-cdk.js\",\n      \"cwd\": \"${workspaceFolder:hello-cdk}\",\n      \"console\": \"internalConsole\",\n      \"sourceMaps\": true,\n      \"skipFiles\": [ \"<node_internals>/**/*\" ],\n      \"outFiles\": [\n        \"${workspaceFolder:aws-cdk}/**/*.js\",\n        \"${workspaceFolder:hello-cdk}/**/*.js\",\n      ],\n    }]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Bundling for Complex Setups in TypeScript\nDESCRIPTION: This snippet shows how to configure Docker bundling for complex setups, such as Docker-in-Docker or remote Docker sockets, by using volume copy instead of bind mounts.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Platform Version for Scheduled Fargate Task\nDESCRIPTION: Configures a scheduled Fargate task with a specific platform version and memory limit running on a defined schedule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst scheduledFargateTask = new ecsPatterns.ScheduledFargateTask(this, 'ScheduledFargateTask', {\n  cluster,\n  scheduledFargateTaskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    memoryLimitMiB: 512,\n  },\n  schedule: appscaling.Schedule.expression('rate(1 minute)'),\n  platformVersion: ecs.FargatePlatformVersion.VERSION1_4,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Redshift Table with a Specific Name using AWS CDK in TypeScript\nDESCRIPTION: Creates a Redshift table with an explicitly defined `tableName`. Note that for CDK versions v2.114.1 and earlier, the table name cannot be changed after creation. For versions greater than v2.114.1, the `tableName` can be modified. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableName: 'oldTableName' // This value can be change for versions greater than v2.114.1\n  tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeDeploy Server Deployment in AWS CodePipeline\nDESCRIPTION: Sets up a CodeDeploy server deployment action in a pipeline for EC2/on-premise deployments. This connects a CodePipeline build output to a CodeDeploy deployment group for application deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline', {\n  pipelineName: 'MyPipeline',\n});\n\n// add the source and build Stages to the Pipeline...\nconst buildOutput = new codepipeline.Artifact();\ndeclare const deploymentGroup: codedeploy.ServerDeploymentGroup;\nconst deployAction = new codepipeline_actions.CodeDeployServerDeployAction({\n  actionName: 'CodeDeploy',\n  input: buildOutput,\n  deploymentGroup,\n});\npipeline.addStage({\n  stageName: 'Deploy',\n  actions: [deployAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing a Deep Learning Container Image for SageMaker with TypeScript\nDESCRIPTION: This snippet shows how to reference a deep learning container image for use in SageMaker using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\nconst repositoryName = 'huggingface-pytorch-training';\nconst tag = '1.13.1-transformers4.26.0-gpu-py39-cu117-ubuntu20.04';\n\nconst image = sagemaker.ContainerImage.fromDlc(repositoryName, tag);\n```\n\n----------------------------------------\n\nTITLE: Adding an Action to an Existing Stage\nDESCRIPTION: Shows how to add an action to a stage after the stage has been created using the addAction method. This allows for extending pipeline stages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Use the `IStage.addAction()` method to mutate an existing Stage.\ndeclare const sourceStage: codepipeline.IStage;\ndeclare const someAction: codepipeline.Action;\nsourceStage.addAction(someAction);\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Auth with Generated Password in TypeScript\nDESCRIPTION: Adds password protection to an Amplify app using basic authentication with a generated password in Secrets Manager. This approach automatically creates a secure password that is stored in AWS Secrets Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-github-token'),\n  }),\n  basicAuth: amplify.BasicAuth.fromGeneratedPassword('username'),\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing CloudFormation Parameters with Build-time Values\nDESCRIPTION: Demonstrates how to replace CloudFormation parameters with build-time values using CfnInclude. This removes parameters from the template and replaces all references with the provided values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nnew cfn_inc.CfnInclude(this, 'includeTemplate', {\n  templateFile: 'path/to/my/template',\n  parameters: {\n    'MyParam': 'my-value',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda CodeDeploy Application in TypeScript\nDESCRIPTION: Creates a new CodeDeploy Application that deploys to a Lambda function with an optional application name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = new codedeploy.LambdaApplication(this, 'CodeDeployApplication', {\n  applicationName: 'MyApplication', // optional property\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Self-Managed Kafka Event Source for Lambda\nDESCRIPTION: Configures a self-managed Kafka cluster as an event source for Lambda using CDK. Includes broker configuration, authentication, and consumer group settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Secret } from 'aws-cdk-lib/aws-secretsmanager';\nimport { SelfManagedKafkaEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\n\n// The list of Kafka brokers\nconst bootstrapServers = ['kafka-broker:9092'];\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\n// The secret that allows access to your self hosted Kafka cluster\ndeclare const secret: Secret;\n\n// (Optional) The consumer group id to use when connecting to the Kafka broker. If omitted the UUID of the event source mapping will be used.\nconst consumerGroupId = \"my-consumer-group-id\";\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new SelfManagedKafkaEventSource({\n  bootstrapServers: bootstrapServers,\n  topic: topic,\n  consumerGroupId: consumerGroupId,\n  secret: secret,\n  batchSize: 100, // default\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n}));\n```\n\n----------------------------------------\n\nTITLE: Setting TextWidget Background to Transparent (TypeScript)\nDESCRIPTION: Shows how to set the background property of a TextWidget to cloudwatch.TextWidgetBackground.TRANSPARENT for a transparent background. Use with markdown content for visual integration with dashboard. Requires imports from aws-cdk-lib/aws-cloudwatch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TextWidget({\n  markdown: '# Key Performance Indicators',\n  background: cloudwatch.TextWidgetBackground.TRANSPARENT\n}));\n```\n\n----------------------------------------\n\nTITLE: Saving awslint Exclude Rules to package.json\nDESCRIPTION: Example showing how to capture failed linting rules and save them as exclude patterns in the module's package.json file to bootstrap the linting process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/awslint/README.md#2025-04-23_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ npm run awslint -- --save\n[shows errors]\n\n$ cat package.json\n{\n  ...\n  \"awslint\": {\n    \"exclude\": [\n      \"...\", // added by awslint --save\n      \"...\", // added by awslint --save\n    ]\n  }\n}\n\n$ npm run awslint\n[no errors]\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual-Stack Application Load Balancers for ECS Services in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to configure AWS Application Load Balancers (ALBs) with dual-stack IP addressing for both ECS Fargate and EC2 services using the AWS CDK `ecsPatterns`. It requires a VPC configured with `ec2.IpProtocol.DUAL_STACK` and sets the `ipAddressType` property to `elbv2.IpAddressType.DUAL_STACK` on the service constructs. Key dependencies include `aws-cdk-lib/aws-ec2`, `aws-cdk-lib/aws-ecs`, `aws-cdk-lib/aws-ecs-patterns`, and `aws-cdk-lib/aws-elasticloadbalancingv2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_31\n\nLANGUAGE: ts\nCODE:\n```\nimport * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\n// The VPC and subnet must have associated IPv6 CIDR blocks.\nconst vpc = new ec2.Vpc(this, 'Vpc', {\n  ipProtocol: ec2.IpProtocol.DUAL_STACK,\n});\nconst cluster = new ecs.Cluster(this, 'EcsCluster', { vpc });\n\nconst service = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'myService', {\n  cluster,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  },\n  minHealthyPercent: 100,\n  ipAddressType: elbv2.IpAddressType.DUAL_STACK,\n});\n\nconst applicationLoadBalancedEc2Service = new ecsPatterns.ApplicationLoadBalancedEc2Service(this, 'myService', {\n  cluster,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n  },\n  minHealthyPercent: 100,\n  ipAddressType: elbv2.IpAddressType.DUAL_STACK,\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping Validation When Applying Kubernetes Manifests in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to skip the `kubectl` validation step when applying a Kubernetes manifest using the `KubernetesManifest` construct in AWS CDK. This is achieved by setting the `skipValidation` property to `true` in the construct's props.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nnew eks.KubernetesManifest(this, 'HelloAppWithoutValidation', {\n  cluster,\n  manifest: [{ foo: 'bar' }],\n  skipValidation: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Deployment Bake Time in AWS CDK\nDESCRIPTION: Sets up a CodeDeploy deployment group with a 30-minute bake time before terminating the original blue task set, allowing for extended monitoring of the new deployment. The configuration continues to monitor CloudWatch alarms during the bake time for automatic rollback if issues occur.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { aws_cloudwatch as cloudwatch } from 'aws-cdk-lib';\n\ndeclare const service: ecs.FargateService;\ndeclare const blueTargetGroup: elbv2.ITargetGroup;\ndeclare const greenTargetGroup: elbv2.ITargetGroup;\ndeclare const listener: elbv2.IApplicationListener;\ndeclare const blueUnhealthyHosts: cloudwatch.Alarm;\ndeclare const greenUnhealthyHosts: cloudwatch.Alarm;\ndeclare const blueApiFailure: cloudwatch.Alarm;\ndeclare const greenApiFailure: cloudwatch.Alarm;\n\nnew codedeploy.EcsDeploymentGroup(this, 'BlueGreenDG', {\n  service,\n  blueGreenDeploymentConfig: {\n    blueTargetGroup,\n    greenTargetGroup,\n    listener,\n    // CodeDeploy will wait for 30 minutes after completing the blue-green deployment before it terminates the blue tasks\n    terminationWaitTime: Duration.minutes(30),\n  },\n  // CodeDeploy will continue to monitor these alarms during the 30-minute bake time and will automatically\n  // roll back if they go into a failed state at any point during the deployment.\n  alarms: [blueUnhealthyHosts, greenUnhealthyHosts, blueApiFailure, greenApiFailure],\n  deploymentConfig: codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling CloudTrail Log File Validation using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to disable the default log file integrity validation feature when creating a CloudTrail trail using the AWS CDK in TypeScript. The `enableFileValidation` property is set to `false` in the `TrailProps`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst trail = new cloudtrail.Trail(this, 'CloudTrail', {\n  enableFileValidation: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Global Secondary Indexes for DynamoDB TableV2 via Property in TypeScript\nDESCRIPTION: This snippet shows how to define Global Secondary Indexes (GSIs) for a DynamoDB TableV2 by providing an array to the `globalSecondaryIndexes` property during table instantiation. Each object in the array defines an index with its `indexName` and `partitionKey`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  globalSecondaryIndexes: [\n    {\n      indexName: 'gsi',\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GitHub Source Credentials for CodeBuild in TypeScript\nDESCRIPTION: This snippet shows how to create GitHub source credentials for AWS CodeBuild using the AWS CDK. It utilizes `SecretValue.secretsManager` to fetch the access token securely from AWS Secrets Manager. The comment notes that `GitHubEnterpriseSourceCredentials` is used for GitHub Enterprise.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.GitHubSourceCredentials(this, 'CodeBuildGitHubCreds', {\n  accessToken: SecretValue.secretsManager('my-token'),\n});\n// GitHub Enterprise is almost the same,\n// except the class is called GitHubEnterpriseSourceCredentials\n```\n\n----------------------------------------\n\nTITLE: Starting a SageMaker Pipeline Execution with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates starting an Amazon SageMaker pipeline execution via EventBridge Scheduler using AWS CDK. It assumes an existing SageMaker `IPipeline`, creates a `SageMakerStartPipelineExecution` target referencing the pipeline and providing optional pipeline parameters, and establishes a schedule to trigger this execution every 60 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from 'aws-cdk-lib/aws-sagemaker';\n\ndeclare const pipeline: sagemaker.IPipeline;\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.SageMakerStartPipelineExecution(pipeline, {\n    pipelineParameterList: [{\n      name: 'parameter-name',\n      value: 'parameter-value',\n    }],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Cross-Region Replication Buckets\nDESCRIPTION: Configures a pipeline with custom replication buckets for cross-region actions instead of using the automatically generated support stacks and buckets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Supply replication buckets for the Pipeline instead of using the generated support stack\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline', {\n  // ...\n\n  crossRegionReplicationBuckets: {\n    // note that a physical name of the replication Bucket must be known at synthesis time\n    'us-west-1': s3.Bucket.fromBucketAttributes(this, 'UsWest1ReplicationBucket', {\n      bucketName: 'amzn-s3-demo-bucket',\n      // optional KMS key\n      encryptionKey: kms.Key.fromKeyArn(this, 'UsWest1ReplicationKey',\n        'arn:aws:kms:us-west-1:123456789012:key/1234-5678-9012'\n      ),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting IP Address Type for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet configures the IP address type for an OpenSearch domain. It sets the `ipAddressType` property to `IpAddressType.DUAL_STACK`, enabling the domain to support both IPv4 and IPv6 addresses.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_3,\n  ipAddressType: IpAddressType.DUAL_STACK,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Converting L1 to L2 Resource using fromCfn* Method (TypeScript)\nDESCRIPTION: Illustrates the preferred method for converting a retrieved L1 Cfn resource (`kms.CfnKey`) to its corresponding mutable L2 construct (`kms.IKey`) using the static `fromCfnKey` method. This allows using L2 methods like `addToResourcePolicy`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst cfnKey = cfnTemplate.getResource('Key') as kms.CfnKey;\nconst key = kms.Key.fromCfnKey(cfnKey);\n```\n\n----------------------------------------\n\nTITLE: Setting Kubectl Provider Memory for EKS Cluster - AWS CDK - TypeScript\nDESCRIPTION: Shows how to increase the memory (default 1024MiB) for the kubectl provider Lambda function using the 'memory' property. Useful for large manifest deployments or resource-intensive kubectl operations. Requires @aws-cdk/lambda-layer-kubectl-v32 and eks.KubernetesVersion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nnew eks.Cluster(this, 'MyCluster', {\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n    memory: Size.gibibytes(4),\n  },\n  version: eks.KubernetesVersion.V1_32,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Trusted Key Groups in CloudFront Distribution\nDESCRIPTION: Shows how to configure trusted key groups for signed URLs or cookies validation in CloudFront Web Distribution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\ndeclare const publicKey: string;\nconst pubKey = new cloudfront.PublicKey(this, 'MyPubKey', {\n  encodedKey: publicKey,\n});\n\nconst keyGroup = new cloudfront.KeyGroup(this, 'MyKeyGroup', {\n  items: [\n    pubKey,\n  ],\n});\n\nnew cloudfront.CloudFrontWebDistribution(this, 'AnAmazingWebsiteProbably', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n      },\n      behaviors: [\n        {\n          isDefaultBehavior: true,\n          trustedKeyGroups: [\n            keyGroup,\n          ],\n        },\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Filter Pattern to EventBridge Pipe\nDESCRIPTION: Demonstrates how to add filtering to a pipe to only process messages matching specific criteria, such as customer type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst sourceFilter = new pipes.Filter(\n  [\n    pipes.FilterPattern.fromObject({\n      body: {\n        // only forward events with customerType B2B or B2C\n        customerType: ['B2B', 'B2C'] \n      },\n    })\n  ]\n)\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue),\n  filter: sourceFilter, \n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom IAM Role for GameLift Fleet in TypeScript\nDESCRIPTION: Creates and assigns a custom IAM role to a GameLift fleet with specific permissions. This allows the fleet to access other AWS resources such as CloudWatch. The example shows both constructor assignment and granular permission granting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.CompositePrincipal(new iam.ServicePrincipal('gamelift.amazonaws.com'))\n});\nrole.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('CloudWatchAgentServerPolicy'));\n\nconst fleet = new gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n    }]\n  },\n  role: role\n});\n\n// Actions can also be grantted through dedicated method\nfleet.grant(role, 'gamelift:ListFleets');\n```\n\n----------------------------------------\n\nTITLE: Enabling Server Side Rendering in Amplify App in TypeScript\nDESCRIPTION: Configures an Amplify application to support server-side rendering by setting the platform property to WEB_COMPUTE. By default, Amplify uses WEB platform which only supports static assets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  platform: amplify.Platform.WEB_COMPUTE,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Share Decay for AWS Batch Fairshare Scheduling Policy in TypeScript\nDESCRIPTION: This snippet shows how to configure the `shareDecay` parameter for an AWS Batch Fairshare Scheduling Policy. It creates a policy (`fairsharePolicy`) with a `shareDecay` of 5 minutes. This means the scheduler will only consider the resource usage of jobs for the past 5 minutes when calculating fairshare allocations, linearly decreasing the impact of longer-running jobs over that time.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fairsharePolicy = new batch.FairshareSchedulingPolicy(this, 'myFairsharePolicy', {\n   shareDecay: cdk.Duration.minutes(5),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a New ECS CodeDeploy Application in TypeScript\nDESCRIPTION: Shows how to create a new AWS CodeDeploy Application specifically designed for deploying Amazon ECS services using AWS CDK. An optional application name can be provided.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = new codedeploy.EcsApplication(this, 'CodeDeployApplication', {\n  applicationName: 'MyApplication', // optional property\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing EKS Clusters and KubectlProvider in TypeScript\nDESCRIPTION: This snippet shows how to import an existing EKS cluster and kubectl provider created in another stack. It demonstrates using the fromKubectlProviderAttributes and fromClusterAttributes methods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nconst handlerRole = iam.Role.fromRoleArn(this, 'HandlerRole', 'arn:aws:iam::123456789012:role/lambda-role');\n\nconst kubectlProvider = eks.KubectlProvider.fromKubectlProviderAttributes(this, 'KubectlProvider', {\n  serviceToken: 'arn:aws:lambda:us-east-2:123456789012:function:my-function:1',\n  role: handlerRole,\n});\n\nconst cluster = eks.Cluster.fromClusterAttributes(this, 'Cluster', {\n  clusterName: 'cluster',\n  kubectlProvider,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Static and Blackhole Routes to Transit Gateway Route Table (AWS CDK TypeScript)\nDESCRIPTION: Demonstrates how to add static and blackhole routes to a Transit Gateway route table using AWS CDK in TypeScript. Utilizes addRoute() to direct traffic to a specific destination CIDR via an attachment, and addBlackholeRoute() to block traffic to a specified destination. Requires initialized TransitGateway, route table, VPC, subnet, and a VPC attachment. Outputs a custom route table with both active and blackhole routes for precise traffic control.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\nconst routeTable = transitGateway.addRouteTable('CustomRouteTable');\n\nconst myVpc = new VpcV2(this, 'Vpc');\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC \n});\n\nconst attachment = transitGateway.attachVpc('VpcAttachment', {\n  vpc: myVpc, \n  subnets: [subnet]\n});\n\n// Add a static route to direct traffic\nrouteTable.addRoute('StaticRoute', attachment, '10.0.0.0/16');\n\n// Block unwanted traffic with a blackhole route\nrouteTable.addBlackholeRoute('BlackholeRoute', '172.16.0.0/16');\n```\n\n----------------------------------------\n\nTITLE: Setting Up Image Scan Completion Event\nDESCRIPTION: Configures an event rule for image scan completion and adds a target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nrepository.onImageScanCompleted('ImageScanComplete')\n  .addTarget(target);\n```\n\n----------------------------------------\n\nTITLE: HTML Sponsor Table Layout Structure\nDESCRIPTION: Table-based layout for displaying sponsor information in a 3-column grid format with company logos, descriptions and links. Includes responsive image handling with picture elements for dark/light mode support.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<table align=\"center\" width=\"100%\">\n  <tr width=\"33.333333333333336%\">\n    <td align=\"center\" width=\"33.333333333333336%\">\n      <a href=\"https://stytch.com/?utm_source=oss-sponsorship&utm_medium=paid_sponsorship&utm_content=website-link&utm_campaign=axios-http\" style=\"padding: 10px; display: inline-block\">\n        <picture>\n          <source width=\"200px\" height=\"38px\" media=\"(prefers-color-scheme: dark)\" srcset=\"https://axios-http.com/assets/sponsors/stytch_white.png\">\n          <img width=\"200px\" height=\"38px\" src=\"https://axios-http.com/assets/sponsors/stytch.png\" alt=\"Stytch\"/>\n        </picture>\n      </a>\n      <!-- Additional sponsor cells follow similar pattern -->\n    </td>\n  </tr>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Creating a Redshift User with Custom Encryption Key in TypeScript\nDESCRIPTION: This snippet shows how to create a Redshift user with a custom encryption key for the user credentials.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\nconst encryptionKey = new kms.Key(this, 'Key');\nnew User(this, 'User', {\n  encryptionKey: encryptionKey,\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n\n----------------------------------------\n\nTITLE: Submitting Multipart Form Data with Request Library - JavaScript\nDESCRIPTION: This snippet demonstrates how to use the 'request' library to submit a multipart form, including both simple fields and a file upload, in Node.js. It creates a formData object, attaches a file as a stream, and posts it to a given URL. Key dependencies include the 'request' library and Node's 'fs' module for file streams; the callback handles error and success responses from the server.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar formData = {\n  my_field: 'my_value',\n  my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),\n};\n\nrequest.post({url:'http://service.com/upload', formData: formData}, function(err, httpResponse, body) {\n  if (err) {\n    return console.error('upload failed:', err);\n  }\n  console.log('Upload successful!  Server responded with:', body);\n});\n```\n\n----------------------------------------\n\nTITLE: Generating CloudFormation Import for Cross-Stack Reference (JSON)\nDESCRIPTION: Shows the CloudFormation `Resources` section for `stack2`, demonstrating how it imports the S3 bucket ARN exported by `stack1`. The `Fn::ImportValue` function is used within the IAM Policy to reference the exported bucket ARN for setting permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"Resources\": {\n    \"HandlerServiceRoleDefaultPolicyCBD0CC91\": {\n       \"Type\": \"AWS::IAM::Policy\",\n       \"Properties\": {\n         \"PolicyDocument\": {\n           \"Statement\": [\n              {\n                \"Action\": [\n                  \"s3:GetBucket*\",\n                  \"s3:GetObject*\",\n                  \"s3:List*\"\n                ],\n                \"Effect\": \"Allow\",\n                \"Resource\": [\n                  {\n                    \"Fn::ImportValue\": \"stack1:ExportsOutputFnGetAttBucket83908E77Arn063C8555\"\n                  },\n                  {\n                    \"Fn::Join\": [\n                      \"\",\n                      [\n                        {\n                          \"Fn::ImportValue\": \"stack1:ExportsOutputFnGetAttBucket83908E77Arn063C8555\"\n                        },\n                        \"/*\"\n                      ]\n                    ]\n                  }\n                ]\n              }\n           ],\n         \"Version\": \"2012-10-17\"\n         },\n         \"PolicyName\": \"HandlerServiceRoleDefaultPolicyCBD0CC91\",\n         \"Roles\": [\n           {\n             \"Ref\": \"HandlerServiceRoleFCDC14AE\"\n           }\n         ]\n       }\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Including Hashes in Poetry-based Lambda Packaging\nDESCRIPTION: Enables the inclusion of dependency hashes in Poetry-managed Python Lambda functions using the poetryIncludeHashes option.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonFunction(this, 'function', {\n  entry: '/path/to/poetry-function',\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    poetryIncludeHashes: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing InternetMonitor Constructs with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the InternetMonitor constructs module from aws-cdk-lib in TypeScript. The import statement allows developers to access L1 constructs for InternetMonitor resources, which are used just like CloudFormation resources due to the current lack of hand-written (L2) constructs. The aws-cdk-lib package is required as a dependency, and no additional parameters are specified in this import. The snippet serves as a foundational step for further AWS CDK project development utilizing InternetMonitor.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-internetmonitor/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as internetmonitor from 'aws-cdk-lib/aws-internetmonitor';\n```\n\n----------------------------------------\n\nTITLE: Stateful Resource Implementation\nDESCRIPTION: Example of implementing a stateful resource with proper JSDoc annotation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @stateful\n */\nexport class Table { }\n```\n\n----------------------------------------\n\nTITLE: Axios POST Request Example\nDESCRIPTION: Example of making a POST request with Axios including request body data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\naxios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n----------------------------------------\n\nTITLE: Including AWS SDK in the Bundle for NodejsFunction\nDESCRIPTION: Shows how to include the AWS SDK in the bundle asset instead of using the version provided by the Lambda runtime.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew nodejs.NodejsFunction(this, 'my-handler', {\n  bundling: {\n    bundleAwsSDK: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating IoT Rule to Put Messages to IoT Events Input in TypeScript\nDESCRIPTION: This snippet creates an AWS IoT Rule that puts messages to an IoT Events input when triggered. It demonstrates how to configure the IoT Events input, set up the topic rule with SQL, and add the IotEventsPutMessageAction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\ndeclare const role: iam.IRole;\n\nconst input = new iotevents.Input(this, 'MyInput', {\n  attributeJsonPaths: ['payload.temperature', 'payload.transactionId'],\n});\nconst topicRule = new iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\n    \"SELECT * FROM 'device/+/data'\",\n  ),\n  actions: [\n    new actions.IotEventsPutMessageAction(input, {\n      batchMode: true, // optional property, default is 'false'\n      messageId: '${payload.transactionId}', // optional property, default is a new UUID\n      role: role, // optional property, default is a new UUID\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing a Route53 Hosted Zone by ID Only in TypeScript\nDESCRIPTION: Imports an existing Route53 hosted zone when only the zone ID is known. This avoids retrieval of the zone name, which may be beneficial in some deployment scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst zone = route53.HostedZone.fromHostedZoneId(this, 'MyZone', 'ZOJJZC49E0EPZ');\n```\n\n----------------------------------------\n\nTITLE: Original TypeScript with export * statement\nDESCRIPTION: An example showing a TypeScript file with a wildcard export statement which re-exports all symbols from another module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/lazify/README.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nexport * from './my-module';\n```\n\n----------------------------------------\n\nTITLE: Granting Send Email Permission to IAM User for SES Identity - AWS CDK - TypeScript\nDESCRIPTION: This snippet grants the SES send email privilege on a verified identity to a specified IAM user using the grantSendEmail method. Dependencies are 'aws-cdk-lib/aws-iam' and an initialized SES EmailIdentity and IAM User. This allows the IAM principal to send emails using the associated address or domain.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const user: iam.User;\n\nconst identity = new ses.EmailIdentity(this, 'Identity', {\n  identity: ses.Identity.domain('cdk.dev'),\n});\n\nidentity.grantSendEmail(user);\n```\n\n----------------------------------------\n\nTITLE: Configuring Scheduled EC2 Task with Custom Container Name\nDESCRIPTION: Creates a scheduled EC2 task with a custom container name, memory limit, and environment variables running on a specified schedule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst ecsScheduledTask = new ecsPatterns.ScheduledEc2Task(this, 'ScheduledTask', {\n    cluster,\n    scheduledEc2TaskImageOptions: {\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n        containerName: 'customContainerName',\n        memoryLimitMiB: 256,\n        environment: { name: 'TRIGGER', value: 'CloudWatch Events' },\n    },\n    schedule: appscaling.Schedule.expression('rate(1 minute)'),\n    enabled: true,\n    ruleName: 'sample-scheduled-task-rule',\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching IAM Role during Redshift Cluster Creation using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates attaching an IAM role to an AWS Redshift cluster at the time of creation using AWS CDK. An IAM role assumed by the Redshift service principal is created and then included in the `roles` array property of the `Cluster` constructor. This grants the cluster the permissions defined in the attached role. Requires an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n});\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  roles: [role],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: ECS Service Deployment Configuration\nDESCRIPTION: Configures an ECS deployment action in CodePipeline to deploy to a Fargate service using image definitions file. Includes optional deployment timeout setting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const service: ecs.FargateService;\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst buildOutput = new codepipeline.Artifact();\nconst deployStage = pipeline.addStage({\n  stageName: 'Deploy',\n  actions: [\n    new codepipeline_actions.EcsDeployAction({\n      actionName: 'DeployAction',\n      service,\n      // if your file is called imagedefinitions.json,\n      // use the `input` property,\n      // and leave out the `imageFile` property\n      input: buildOutput,\n      // if your file name is _not_ imagedefinitions.json,\n      // use the `imageFile` property,\n      // and leave out the `input` property\n      imageFile: buildOutput.atPath('imageDef.json'),\n      deploymentTimeout: Duration.minutes(60), // optional, default is 60 minutes\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying Assets to Amplify in TypeScript\nDESCRIPTION: Demonstrates how to deploy S3 assets to an Amplify app using CDK, without needing a source code provider. This approach allows deploying pre-built applications as ZIP packages directly from S3.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as assets from 'aws-cdk-lib/aws-s3-assets';\n\ndeclare const asset: assets.Asset;\ndeclare const amplifyApp: amplify.App;\nconst branch = amplifyApp.addBranch(\"dev\", { asset: asset });\n```\n\n----------------------------------------\n\nTITLE: Creating Ray Job with Optional Parameters in AWS CDK\nDESCRIPTION: Demonstrates creating a Ray Job with full configuration options including custom name, worker settings, runtime, and security settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.RayJob(stack, 'ImportedJob', {\n  role,\n  script,\n  jobName: 'RayCustomJobName',\n  description: 'This is a description',\n  workerType: glue.WorkerType.Z_2X,\n  numberOfWorkers: 5,\n  runtime: glue.Runtime.RAY_TWO_FOUR,\n  maxRetries: 3,\n  maxConcurrentRuns: 100,\n  timeout: cdk.Duration.hours(2),\n  connections: [glue.Connection.fromConnectionName(stack, 'Connection', 'connectionName')],\n  securityConfiguration: glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'SecurityConfig', 'securityConfigName'),\n  tags: {\n    FirstTagName: 'FirstTagValue',\n    SecondTagName: 'SecondTagValue',\n    XTagName: 'XTagValue',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning Entire CodeCommit Repository in CodeBuild Action\nDESCRIPTION: This example demonstrates how to clone the entire CodeCommit repository for use in a CodeBuild action by setting the codeBuildCloneOutput property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const project: codebuild.PipelineProject;\ndeclare const repo: codecommit.Repository;\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeCommitSourceAction({\n  actionName: 'CodeCommit',\n  repository: repo,\n  output: sourceOutput,\n  codeBuildCloneOutput: true,\n});\n\nconst buildAction = new codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput, // The build action must use the CodeCommitSourceAction output as input.\n  outputs: [new codepipeline.Artifact()], // optional\n});\n```\n\n----------------------------------------\n\nTITLE: Deferring JSON Key Resolution Using CfnJson - TypeScript\nDESCRIPTION: Demonstrates leveraging CfnJson to dynamically generate JSON values at deploy time. Particularly useful for scenarios (like IAM conditions) where CloudFormation intrinsic functions or parameters must be used in JSON keys, which is otherwise unsupported by vanilla JSON. Dependencies include aws-cdk-lib constructs such as CfnJson, CfnParameter, and aws_iam, and the code assumes access to a construct scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst tagParam = new CfnParameter(this, 'TagName');\n\nconst stringEquals = new CfnJson(this, 'ConditionJson', {\n  value: {\n    [`aws:PrincipalTag/${tagParam.valueAsString}`]: true,\n  },\n});\n\nconst principal = new iam.AccountRootPrincipal().withConditions({\n  StringEquals: stringEquals,\n});\n\nnew iam.Role(this, 'MyRole', { assumedBy: principal });\n```\n\n----------------------------------------\n\nTITLE: Enabling Advanced Security Mode for UserPool - AWS CDK - TypeScript\nDESCRIPTION: This code configures advanced security (deprecated, see documentation) for an AWS Cognito UserPool by setting the 'advancedSecurityMode' property to 'ENFORCED'. Requires Cognito CDK. Input is a security mode value; output is a UserPool with enforced advanced security features. Note: Advanced security mode may be deprecated in the future.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  advancedSecurityMode: cognito.AdvancedSecurityMode.ENFORCED,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced Options for Elasticsearch Domain\nDESCRIPTION: Sets advanced options for an Elasticsearch domain, including configuration parameters for REST actions, field data cache size, and query boolean clause count limits.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nnew es.Domain(this, 'Domain', {\n  version: es.ElasticsearchVersion.V7_7,\n  advancedOptions: {\n    'rest.action.multi.allow_explicit_index': 'false',\n    'indices.fielddata.cache.size': '25',\n    'indices.query.bool.max_clause_count': '2048',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Failure Destination for Kafka Events\nDESCRIPTION: Demonstrates how to configure an S3 bucket as a failure destination for failed Kafka event processing in Lambda.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ManagedKafkaEventSource, S3OnFailureDestination } from 'aws-cdk-lib/aws-lambda-event-sources';\nimport { IBucket } from 'aws-cdk-lib/aws-s3';\n\n// Your MSK cluster arn\nconst clusterArn = 'arn:aws:kafka:us-east-1:0123456789019:cluster/SalesCluster/abcd1234-abcd-cafe-abab-9876543210ab-4';\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\ndeclare const bucket: IBucket;\ndeclare const myFunction: lambda.Function;\n\nconst s3OnFailureDestination = new S3OnFailureDestination(bucket);\n\nmyFunction.addEventSource(new ManagedKafkaEventSource({\n  clusterArn,\n  topic,\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n  onFailure: s3OnFailureDestination,\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating IoT Rule to Write Data to OpenSearch Service in TypeScript\nDESCRIPTION: This snippet creates an AWS IoT Rule that writes data to an OpenSearch Service when triggered. It demonstrates how to set up the topic rule with SQL and add an OpenSearchAction with specified index and type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opensearch from 'aws-cdk-lib/aws-opensearchservice';\ndeclare const domain: opensearch.Domain;\n\nconst topicRule = new iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\n    \"SELECT topic(2) as device_id, year, month, day FROM 'device/+/data'\",\n  ),\n});\n\ntopicRule.addAction(new actions.OpenSearchAction(domain, {\n  id: 'my-id',\n  index: 'my-index',\n  type: 'my-type',\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating Cloud9 EC2 Environments with VPC Configuration\nDESCRIPTION: Demonstrates different ways to create Cloud9 EC2 environments with various VPC configurations including new VPC, default VPC, and custom subnet selection.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-cloud9-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// create a cloud9 ec2 environment in a new VPC\nconst vpc = new ec2.Vpc(this, 'VPC', { maxAzs: 3});\nnew cloud9.Ec2Environment(this, 'Cloud9Env', { vpc, imageId: cloud9.ImageId.AMAZON_LINUX_2, });\n\n// or create the cloud9 environment in the default VPC with specific instanceType\nconst defaultVpc = ec2.Vpc.fromLookup(this, 'DefaultVPC', { isDefault: true });\nnew cloud9.Ec2Environment(this, 'Cloud9Env2', {\n  vpc: defaultVpc,\n  instanceType: new ec2.InstanceType('t3.large'),\n  imageId: cloud9.ImageId.AMAZON_LINUX_2,\n});\n\n// or specify in a different subnetSelection\nconst c9env = new cloud9.Ec2Environment(this, 'Cloud9Env3', {\n  vpc,\n  subnetSelection: {\n    subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,\n  },\n  imageId: cloud9.ImageId.AMAZON_LINUX_2,\n});\n\n// print the Cloud9 IDE URL in the output\nnew CfnOutput(this, 'URL', { value: c9env.ideUrl });\n```\n\n----------------------------------------\n\nTITLE: Configuring SASL/SCRAM Authentication for MSK in TypeScript\nDESCRIPTION: This example demonstrates how to enable SASL/SCRAM client authentication for an MSK Cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n  encryptionInTransit: {\n    clientBroker: msk.ClientBrokerEncryption.TLS,\n  },\n  clientAuthentication: msk.ClientAuthentication.sasl({\n    scram: true,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Lambda Deployment Configuration with Specific Name in TypeScript\nDESCRIPTION: Shows creating a custom CodeDeploy Lambda deployment configuration with a specific name (`deploymentConfigName`) using AWS CDK. While allowing custom naming, specifying `deploymentConfigName` prevents updating the traffic routing properties (interval, percentage) through subsequent CDK deployments; updates would need to be done directly via CodeDeploy APIs or console.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = new codedeploy.LambdaDeploymentConfig(this, 'CustomConfig', {\n  trafficRouting: new codedeploy.TimeBasedCanaryTrafficRouting({\n    interval: Duration.minutes(15),\n    percentage: 5,\n  }),\n  deploymentConfigName: 'MyDeploymentConfig',\n});\n```\n\n----------------------------------------\n\nTITLE: Granting Delegation Permissions on Imported Hosted Zones in TypeScript\nDESCRIPTION: Shows how to grant delegation permissions to a cross-account role for various types of imported hosted zones. This enables cross-account zone delegation without creating new hosted zones.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst crossAccountRole = new iam.Role(this, 'CrossAccountRole', {\n  // The role name must be predictable\n  roleName: 'MyDelegationRole',\n  // The other account\n  assumedBy: new iam.AccountPrincipal('12345678901'),\n});\n\nconst zoneFromId = route53.HostedZone.fromHostedZoneId(this, 'MyZone', 'zone-id');\nzoneFromId.grantDelegation(crossAccountRole);\n\nconst publicZoneFromId = route53.PublicHostedZone.fromPublicHostedZoneId(this, 'MyPublicZone', 'public-zone-id');\npublicZoneFromId.grantDelegation(crossAccountRole);\n\nconst privateZoneFromId = route53.PrivateHostedZone.fromPrivateHostedZoneId(this, 'MyPrivateZone', 'private-zone-id');\nprivateZoneFromId.grantDelegation(crossAccountRole);\n```\n\n----------------------------------------\n\nTITLE: Importing IAM Instance Profiles by Name in AWS CDK\nDESCRIPTION: Imports an existing IAM instance profile using its name. This allows you to reference and use an existing instance profile in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst instanceProfile = iam.InstanceProfile.fromInstanceProfileName(this, 'ImportedInstanceProfile', 'MyInstanceProfile');\n```\n\n----------------------------------------\n\nTITLE: More Examples of Incorrect Default Documentation in AWS CDK\nDESCRIPTION: Examples showing unhelpful ways to document default behavior for capacity properties, demonstrating circular references and vague descriptions that don't provide meaningful information.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Minimum capacity of the AutoScaling resource\n *\n * @default - no minimum capacity\n *              DO NOT - there most certainly is. It's probably 0 or 1.\n *\n * // OR\n * @default - the minimum capacity is the default minimum capacity\n *              DO NOT - this is circular and useless to the reader.\n *                         Describe what will actually happen.\n */\nminCapacity?: number;\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK Java Packages with Maven\nDESCRIPTION: Installs AWS CDK Java packages using Maven, including main JAR, sources, and JavaDoc files\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmvn install:install-file -Dfile=/path/to/zip/java/software/amazon/awscdk/dynamodb/1.2.3/dynamodb-1.2.3.jar\nmvn install:install-file -Dfile=/path/to/zip/java/software/amazon/awscdk/dynamodb/1.2.3/dynamodb-1.2.3-sources.jar\nmvn install:install-file -Dfile=/path/to/zip/java/software/amazon/awscdk/dynamodb/1.2.3/dynamodb-1.2.3-javadoc.jar\n```\n\n----------------------------------------\n\nTITLE: Implementing S3 Object Storage from IoT Rules\nDESCRIPTION: Creates an AWS IoT Rule that stores data in S3 buckets. Demonstrates default key patterns and custom key configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst bucket = new s3.Bucket(this, 'MyBucket');\n\nnew iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\"),\n  actions: [new actions.S3PutObjectAction(bucket)],\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Deletion Protection for DynamoDB Table in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to enable deletion protection for an AWS DynamoDB table using the AWS CDK. By setting the `deletionProtection` property to `true` during table instantiation, the table is safeguarded against accidental deletion. This requires the `@aws-cdk/aws-dynamodb` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  deletionProtection: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Build Target\nDESCRIPTION: Creates a Docker image asset specifying a particular build target stage from the Dockerfile.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  target: 'a-target',\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Amazon ECS Exec for ECS Task Target in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable Amazon ECS Exec for an ECS task target. It shows how to set up container overrides and enable the execute command feature for running commands in or getting a shell to a container.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\ndeclare const cluster: ecs.ICluster;\ndeclare const taskDefinition: ecs.TaskDefinition;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nrule.addTarget(new targets.EcsTask({\n  cluster,\n  taskDefinition,\n  taskCount: 1,\n  containerOverrides: [{\n    containerName: 'TheContainer',\n    command: ['echo', events.EventField.fromPath('$.detail.event')],\n  }],\n  enableExecuteCommand: true,\n}));\n```\n\n----------------------------------------\n\nTITLE: Building framework-integ using Lerna - Shell Command\nDESCRIPTION: This shell command builds the @aws-cdk-testing/framework-integ package using Lerna before running integration tests. It is a prerequisite to preparing the framework-integ module. Lerna and Node.js must be installed globally, and this command should be run from the project root. The output is a successful module build for further integration testing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ npx lerna run build --scope=@aws-cdk-testing/framework-integ\n```\n\n----------------------------------------\n\nTITLE: Creating a Glue Security Configuration with Default KMS Keys in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an AWS Glue SecurityConfiguration resource using AWS CDK. It configures CloudWatch encryption with KMS, Job Bookmarks encryption with Client-Side KMS, and S3 encryption with KMS. By default, AWS CDK creates shared KMS keys for these configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew glue.SecurityConfiguration(this, 'MySecurityConfiguration', {\n  cloudWatchEncryption: {\n    mode: glue.CloudWatchEncryptionMode.KMS,\n  },\n  jobBookmarksEncryption: {\n    mode: glue.JobBookmarksEncryptionMode.CLIENT_SIDE_KMS,\n  },\n  s3Encryption: {\n    mode: glue.S3EncryptionMode.KMS,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM permissions to a PlaceIndex (Legacy)\nDESCRIPTION: Demonstrates how to grant search permissions to an IAM role for a PlaceIndex resource. This allows the role to perform search operations on the place index.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\n\nconst placeIndex = new location.PlaceIndex(this, 'PlaceIndex');\nplaceIndex.grantSearch(role);\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFront Function without Auto-Publishing using AWS CDK (TypeScript)\nDESCRIPTION: Shows how to create a CloudFront Function using AWS CDK but prevent it from being automatically published to the `LIVE` stage upon creation. This is achieved by setting the `autoPublish` property to `false`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nnew cloudfront.Function(this, 'Function', {\n  code: cloudfront.FunctionCode.fromInline('function handler(event) { return event.request }'),\n  runtime: cloudfront.FunctionRuntime.JS_2_0,\n  autoPublish: false\n});\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Stack with New `Template` and `App` (TypeScript)\nDESCRIPTION: Shows the current approach using `@aws-cdk/assertions`. `Template.fromStack(stack).toJSON()` synthesizes the stack and returns the template as a JSON object for comparison. `App.of(stack).synth()` performs synthesis, usually for validation or further processing, mirroring the old `SynthUtils.synthesize(stack)` call.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexpect(Template.fromStack(stack).toJSON()).toEqual(/*...*/);\nApp.of(stack).synth();\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Additional Deployment Sources to S3 Deployment (TypeScript)\nDESCRIPTION: This illustrates how to use the addSource method to append extra sources to an existing BucketDeployment. Useful for complex deployments involving multiple assets or incremental content layering. Prerequisites are AWS CDK's s3 and s3-deployment modules, and the object deployed must conform to the expected source interface. Accepts additional files or directories, and applies the same deployment configuration to further sources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const websiteBucket: s3.IBucket;\n\nconst deployment = new s3deploy.BucketDeployment(this, 'DeployWebsite', {\n  sources: [s3deploy.Source.asset('./website-dist')],\n  destinationBucket: websiteBucket,\n  destinationKeyPrefix: 'web/static', // optional prefix in destination bucket\n});\n\ndeployment.addSource(s3deploy.Source.asset('./another-asset'));\n```\n\n----------------------------------------\n\nTITLE: IAM Policy Resource Attribute References Example - CloudFormation - JSON\nDESCRIPTION: This JSON snippet demonstrates referencing a resource attribute (e.g., ARN) via Fn::GetAtt and the special AWS::NoValue pseudo-parameter, common in CloudFormation-generated IAM policies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Fn::GetAtt\": [\n      \"SomeResource\",\n      \"Arn\"\n    ]\n  },\n  {\n    \"Ref\": \"AWS::NoValue\",\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Acknowledging Annotations Using the Annotations API in AWS CDK (TypeScript)\nDESCRIPTION: Acknowledges a warning by its identifier within a construct using the Annotations API when strict mode is enabled in AWS CDK. This call prevents a specific warning (e.g., exceeding the IAM group policy quota) from throwing an error during synthesis. Dependencies include the Annotations utility from AWS CDK's core library. The key parameters are the warning ID and an explanation string, and this method returns void but suppresses the indicated warning for the construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_54\n\nLANGUAGE: TypeScript\nCODE:\n```\nAnnotations.of(this).acknowledgeWarning('IAM:Group:MaxPoliciesExceeded', 'Account has quota increased to 20');\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Region S3 Deployment\nDESCRIPTION: Sets up an S3 deployment action that targets a bucket in a different AWS region. The pipeline will automatically create replication buckets for cross-region artifact transfers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Deploy to an imported S3 bucket from a different Region.\ndeclare const stage: codepipeline.IStage;\ndeclare const input: codepipeline.Artifact;\nstage.addAction(new codepipeline_actions.S3DeployAction({\n  bucket: s3.Bucket.fromBucketAttributes(this, 'Bucket', {\n    region: 'us-west-1',\n    // ...\n  }),\n  input: input,\n  actionName: 's3-deploy-action',\n  // ...\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring Redshift Table Distribution Key with AWS CDK in TypeScript\nDESCRIPTION: Defines a Redshift table specifying a distribution key (`distKey: true` on a column) and a distribution style (`distStyle: TableDistStyle.KEY`). This configuration optimizes query performance by distributing data across compute nodes based on the values in the specified key column. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableColumns: [\n    { name: 'col1', dataType: 'varchar(4)', distKey: true },\n    { name: 'col2', dataType: 'float' },\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n  distStyle: TableDistStyle.KEY,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for Kinesis Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a Kinesis data stream target and input transformation. This allows customizing the payload sent to the data stream.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetStream: kinesis.Stream;\n\nconst streamTarget = new targets.KinesisTarget(targetStream, {\n    partitionKey: 'pk',\n    inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: streamTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating GameLift Aliases for Fleet Abstraction in TypeScript\nDESCRIPTION: Demonstrates how to create and manage GameLift aliases, which abstract fleet designations to allow seamless traffic switching between fleets. Shows both adding an alias to an existing fleet and creating a standalone terminal alias.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fleet: gamelift.BuildFleet;\n\n// Add an alias to an existing fleet using a dedicated fleet method\nconst liveAlias = fleet.addAlias('live');\n\n// You can also create a standalone alias\nnew gamelift.Alias(this, 'TerminalAlias', {\n  aliasName: 'terminal-alias',\n  terminalMessage: 'A terminal message',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Axios in JavaScript\nDESCRIPTION: Different ways to import Axios in JavaScript using ES modules and CommonJS approaches.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport axios, {isCancel, AxiosError} from 'axios';\n\n// Alternative import approaches\nimport axios from 'axios';\nconsole.log(axios.isCancel('something'));\n\nconst axios = require('axios');\nconsole.log(axios.isCancel('something'));\n\nimport { default as axios } from 'axios';\n\nconst axios = require('axios/dist/browser/axios.cjs');\n```\n\n----------------------------------------\n\nTITLE: Importing a Route53 Hosted Zone by Domain Name Lookup in TypeScript\nDESCRIPTION: Imports an existing Route53 hosted zone using a domain name lookup. This requires an environment to be configured with valid AWS credentials.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nroute53.HostedZone.fromLookup(this, 'MyZone', {\n  domainName: 'example.com',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Versions for CloudFront Distribution in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a CloudFront distribution to use specific HTTP versions, in this case, both HTTP/2 and HTTP/3.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n// Configure a distribution to use HTTP/2 and HTTP/3\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n  httpVersion: cloudfront.HttpVersion.HTTP2_AND_3,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Project with Predefined GPU Image in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS CodeBuild project configured to use a predefined AWS Deep Learning Container (DLC) image suitable for GPU workloads. It utilizes a constant from the `LinuxGpuBuildImage` class specifically for TensorFlow inference.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew codebuild.Project(this, 'Project', {\n  environment: {\n    buildImage: codebuild.LinuxGpuBuildImage.DLC_TENSORFLOW_2_1_0_INFERENCE,\n  },\n  // ...\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Glue Security Configuration with a Custom KMS Key in TypeScript\nDESCRIPTION: This snippet shows how to create an AWS Glue SecurityConfiguration using AWS CDK, specifying a custom AWS KMS key for CloudWatch encryption. It requires an existing `kms.Key` instance (`key`) to be passed to the `kmsKey` property within the `cloudWatchEncryption` configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const key: kms.Key;\nnew glue.SecurityConfiguration(this, 'MySecurityConfiguration', {\n  cloudWatchEncryption: {\n    mode: glue.CloudWatchEncryptionMode.KMS,\n    kmsKey: key,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Illustrating Breaking API Change by Making Property Optional in TypeScript\nDESCRIPTION: Demonstrates how changing a non-nullable class property (`count: number`) to optional (`count?: number`) in TypeScript constitutes a breaking API surface change. Existing code that assumes the property is always defined (e.g., `obj.count + 1`) will subsequently fail compilation due to the possibility of `undefined`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nclass SomeClass {\n  public readonly count: number;\n  //                let's say I want to change this to 'count?: number',\n  //                  i.e. make it optional.\n}\n\n// Someone could have written the following code:\nconst obj = new SomeClass();\nconsole.log(obj.count + 1);\n\n// After the proposed change, this code that used to compile fine will now throw:\nconsole.log(obj.count + 1);\n//          ~~~~~~~~~ Error: Object is possibly 'undefined'.\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Classic Authentication Flow\nDESCRIPTION: Shows how to enable the Classic (basic) Authentication Flow in a Cognito Identity Pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  allowClassicFlow: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting AWS Credentials as Environment Variables in Gitpod (Shell)\nDESCRIPTION: This snippet shows an alternative method for providing AWS credentials in Gitpod by setting them as persistent environment variables using the Gitpod CLI (`gp env`). It sets the AWS Access Key ID, Secret Access Key, and Default Region, then verifies the environment variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\neval $(gp env -e AWS_ACCESS_KEY_ID=XXXXXXXXX)\neval $(gp env -e AWS_SECRET_ACCESS_KEY=YYYYYYY)\neval $(gp env -e AWS_DEFAULT_REGION=ZZZZZZZZ)\neval $(gp env -e)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying CloudFormation Parameters in CDK\nDESCRIPTION: Demonstrates how to retrieve and modify CloudFormation parameters using CfnInclude. This allows manipulation of parameter defaults and other properties from within CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst param: core.CfnParameter = cfnTemplate.getParameter('MyParameter');\n\n// mutating the parameter\nparam.default = 'MyDefault';\n```\n\n----------------------------------------\n\nTITLE: Generating Execute API ARN for WebSocket API in TypeScript (CDK)\nDESCRIPTION: This snippet shows how to generate the ARN required for invoking a specific route (e.g., `$connect`) on a specific stage ('dev') of a WebSocket API using the `arnForExecuteApiV2` method. This ARN is often used in IAM policies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst api = new apigwv2.WebSocketApi(this, 'mywsapi');\nconst arn = api.arnForExecuteApiV2('$connect', 'dev');\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Replica to Existing TableV2\nDESCRIPTION: Demonstrates how to add a new replica to an existing TableV2 instance using the addReplica method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack', { env: { region: 'us-west-2' } });\n\nconst globalTable = new dynamodb.TableV2(stack, 'GlobalTable', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  replicas: [{ region: 'us-east-1' }],\n});\n\nglobalTable.addReplica({ region: 'us-east-2', deletionProtection: true });\n```\n\n----------------------------------------\n\nTITLE: Accessing Neptune Cluster Endpoints\nDESCRIPTION: Demonstrates how to retrieve the socket address (host:port) of a Neptune cluster's writer endpoint for connecting to the database.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst writeAddress = cluster.clusterEndpoint.socketAddress;   // \"HOSTNAME:PORT\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Redshift Cluster Endpoint in TypeScript\nDESCRIPTION: This snippet shows how to access the endpoint of a Redshift cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ncluster.clusterEndpoint.socketAddress;   // \"HOSTNAME:PORT\"\n```\n\n----------------------------------------\n\nTITLE: Final Scoped-Down KMS Key Policy Statement for CloudFront OAC (JSON)\nDESCRIPTION: Displays the final, recommended KMS key policy statement required for CloudFront OAC access to an SSE-KMS encrypted S3 bucket after applying security best practices. It grants `kms:Decrypt`, `kms:Encrypt`, and `kms:GenerateDataKey*` permissions to the `cloudfront.amazonaws.com` service principal, but only when the request originates from the specific CloudFront distribution ARN identified in the `StringEquals` condition for `AWS:SourceArn`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n        \"Service\": [\n            \"cloudfront.amazonaws.com\"\n        ]\n     },\n    \"Action\": [\n        \"kms:Decrypt\",\n        \"kms:Encrypt\",\n        \"kms:GenerateDataKey*\"\n    ],\n    \"Resource\": \"*\",\n    \"Condition\": {\n            \"StringEquals\": {\n                \"AWS:SourceArn\": \"arn:aws:cloudfront::111122223333:distribution/<CloudFront distribution ID>\"\n            }\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating the Elasticsearch Service-Linked Role using AWS CLI\nDESCRIPTION: Provides the AWS CLI command to manually create the `AWSServiceRoleForAmazonElasticsearchService` Service-Linked Role (SLR). This role is required for certain OpenSearch/Elasticsearch configurations (like VPC access) and might need to be created explicitly before deploying the CDK stack if it doesn't already exist.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n```console\naws iam create-service-linked-role --aws-service-name es.amazonaws.com\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Redshift Table with AWS CDK in TypeScript\nDESCRIPTION: Instantiates a basic Redshift table within a specified cluster and database using the AWS CDK `Table` construct. This operation executes a query against the Redshift cluster to create the table with the defined columns and data types. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions to Identity Pool Roles in TypeScript\nDESCRIPTION: This snippet shows how to grant permissions to authenticated and unauthenticated roles in an Identity Pool, including direct policy statement additions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\n\nconst identityPool = new IdentityPool(this, 'myIdentityPool');\ndeclare const table: dynamodb.Table;\n\n// Grant permissions to authenticated users\ntable.grantReadWriteData(identityPool.authenticatedRole);\n// Grant permissions to unauthenticated guest users\ntable.grantReadData(identityPool.unauthenticatedRole);\n\n// Or add policy statements straight to the role\nidentityPool.authenticatedRole.addToPrincipalPolicy(new iam.PolicyStatement({\n  effect: iam.Effect.ALLOW,\n  actions: ['dynamodb:UpdateItem'],\n  resources: [table.tableArn],\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Playback Key Pair for Private Channels\nDESCRIPTION: Creates a playback key pair for validating playback tokens. This is necessary for private channels that require authorization.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst keyPair = new ivs.PlaybackKeyPair(this, 'PlaybackKeyPair', {\n  publicKeyMaterial: myPublicKeyPemString,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Lambda Function Integration Test in TypeScript\nDESCRIPTION: A basic integration test for AWS Lambda that creates a function with minimal configuration. This demonstrates the structure of an integration test file including the CDK app setup, stack creation, resource definition, and integration test configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as cdk from 'aws-cdk-lib/core';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as integ from '@aws-cdk/integ-tests-alpha';\n\nconst app = new cdk.App();\n\nconst stack = new cdk.Stack(app, 'aws-cdk-lambda-1');\n\nconst fn = new lambda.Function(stack, 'MyLambda', {\n  code: new lambda.InlineCode('foo'),\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n});\n\nnew integ.IntegTest(app, 'LambdaTest', {\n  testCases: [stack],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing ALB Controller on EKS Cluster\nDESCRIPTION: Deploys the AWS Load Balancer Controller on an EKS cluster for managing Elastic Load Balancers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nnew eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  albController: {\n    version: eks.AlbControllerVersion.V2_8_2,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Introspection for an AppSync API in TypeScript\nDESCRIPTION: This TypeScript CDK snippet shows how to disable introspection queries on an AWS AppSync GraphQL API. Setting the `introspectionConfig` property to `appsync.IntrospectionConfig.DISABLED` prevents clients from querying the schema structure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'DisableIntrospectionApi',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.schema.graphql')),\n  introspectionConfig: appsync.IntrospectionConfig.DISABLED,\n});\n```\n\n----------------------------------------\n\nTITLE: Rendered IAM Policy Resource Attribute Reference Example - Policy Report - JSON\nDESCRIPTION: This JSON snippet shows how references to resource attributes and pseudo-parameters are rendered more readably in the CDK policy report, using placeholder formatting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"(Path/To/SomeResource.Arn)\"\n  \"(NOVALUE)\"\n]\n```\n\n----------------------------------------\n\nTITLE: Disabling the Default Execute API Endpoint in API Gateway v2 HTTP API via AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to instantiate an API Gateway v2 HttpApi construct with the execute API endpoint disabled using the disableExecuteApiEndpoint property. This is useful for cases where only custom domain names or specific endpoints should be exposed. It requires aws-cdk-lib/aws-apigatewayv2. Minimal configuration inputs; output is a HttpApi instance with execute endpoint disabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst httpApi = new apigwv2.HttpApi(this, 'HttpApi', {\n  disableExecuteApiEndpoint: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with Step Functions using AWS CDK in TypeScript\nDESCRIPTION: Illustrates setting up `HttpStepFunctionsIntegration` for starting (asynchronously and synchronously) and stopping Step Functions state machine executions via different HTTP API routes (`/start`, `/start-sync`, `/stop`). Requires an `sfn.StateMachine` instance and the `aws-apigatewayv2`, `aws-apigatewayv2-integrations`, and `aws-stepfunctions` CDK modules. The `STOP_EXECUTION` subtype necessitates parameter mapping for `ExecutionArn` from the request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { HttpStepFunctionsIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\nimport * as sfn from 'aws-cdk-lib/aws-stepfunctions';\n\ndeclare const stateMachine: sfn.StateMachine;\ndeclare const httpApi: apigwv2.HttpApi;\n\nhttpApi.addRoutes({\n  path: '/start',\n  methods: [ apigwv2.HttpMethod.POST ],\n  integration: new HttpStepFunctionsIntegration('StartExecutionIntegration', {\n    stateMachine,\n    subtype: apigwv2.HttpIntegrationSubtype.STEPFUNCTIONS_START_EXECUTION,\n  }),\n});\n\nhttpApi.addRoutes({\n  path: '/start-sync',\n  methods: [ apigwv2.HttpMethod.POST ],\n  integration: new HttpStepFunctionsIntegration('StartSyncExecutionIntegration', {\n    stateMachine,\n    subtype: apigwv2.HttpIntegrationSubtype.STEPFUNCTIONS_START_SYNC_EXECUTION,\n  }),\n});\n\nhttpApi.addRoutes({\n  path: '/stop',\n  methods: [ apigwv2.HttpMethod.POST ],\n  integration: new HttpStepFunctionsIntegration('StopExecutionIntegration', {\n    stateMachine,\n    subtype: apigwv2.HttpIntegrationSubtype.STEPFUNCTIONS_STOP_EXECUTION,\n    // For the `STOP_EXECUTION` subtype, it is necessary to specify the `executionArn`.\n    parameterMapping: new apigwv2.ParameterMapping()\n      .custom('ExecutionArn', '$request.querystring.executionArn'),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Metric Aggregation and Label (TypeScript)\nDESCRIPTION: Shows how to override the default aggregation settings when obtaining a metric. This example gets the Lambda error metric but configures it to use the 'AVERAGE' statistic over a 1-minute period and assigns a custom label 'Lambda failure rate' for display in graphs. Requires `lambda.Function`, `cloudwatch.Stats`, and `Duration`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const fn: lambda.Function;\n\nconst minuteErrorRate = fn.metricErrors({\n  statistic: cloudwatch.Stats.AVERAGE,\n  period: Duration.minutes(1),\n  label: 'Lambda failure rate'\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up CloudWatch Logs Integration with IoT Rules\nDESCRIPTION: Configures an AWS IoT Rule to send log data to CloudWatch Logs. Creates a log group and associates it with the IoT rule action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as logs from 'aws-cdk-lib/aws-logs';\n\nconst logGroup = new logs.LogGroup(this, 'MyLogGroup');\n\nnew iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\"),\n  actions: [new actions.CloudWatchLogsAction(logGroup)],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Jenkins Provider in AWS CodePipeline with TypeScript\nDESCRIPTION: Creates a Jenkins provider for use with CodePipeline actions. This allows integration between AWS CodePipeline and a Jenkins server. The provider requires a name, server URL, and optionally a version specification.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst jenkinsProvider = new codepipeline_actions.JenkinsProvider(this, 'JenkinsProvider', {\n  providerName: 'MyJenkinsProvider',\n  serverUrl: 'http://my-jenkins.com:8080',\n  version: '2', // optional, default: '1'\n});\n```\n\n----------------------------------------\n\nTITLE: Alternative: Managing Warning Acknowledgement Using Context and Metadata in AWS CDK (TypeScript)\nDESCRIPTION: Illustrates an alternative approach for warning acknowledgement using the CDK context system and node metadata manipulation. The `acknowledgeWarning` function would set a context key for acknowledgement and attempt to remove the related metadata, while `addWarningV2` checks this context before adding a message. Practical usage is currently constrained because context cannot be set on existing nodes and node metadata removal APIs are unavailable in public CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/acknowledge-warnings.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\npublic acknowledgeWarning(id: string, message?: string) {\n  this.scope.node.setContext(id, message ?? true); // can't do this today\n  this.scope.node.removeMetadata(id); // this method does not exist\n}\npublic addWarningV2(id: string, message: string) {\n  if (this.scope.node.tryGetContext(id) === undefined) {\n    this.addMessage(...);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an SNS Trigger to a CodeCommit Repository\nDESCRIPTION: Establishes an Amazon SNS notification trigger for all actions and branches in a CodeCommit repository using the notify method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const repo: codecommit.Repository;\n\n// trigger is established for all repository actions on all branches by default.\nrepo.notify('arn:aws:sns:*:123456789012:my_topic');\n```\n\n----------------------------------------\n\nTITLE: Configuring Command Hooks for NodejsFunction in TypeScript\nDESCRIPTION: This snippet shows how to set up command hooks for a NodejsFunction, allowing execution of additional commands before bundling, before installation, and after bundling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n// This example only available in TypeScript\n// Run additional props via `commandHooks`\nnew nodejs.NodejsFunction(this, 'my-handler-with-commands', {\n  bundling: {\n    commandHooks: {\n      beforeBundling(inputDir: string, outputDir: string): string[] {\n        return [\n          `echo hello > ${inputDir}/a.txt`,\n          `cp ${inputDir}/a.txt ${outputDir}`,\n        ];\n      },\n      afterBundling(inputDir: string, outputDir: string): string[] {\n        return [`cp ${inputDir}/b.txt ${outputDir}/txt`];\n      },\n      beforeInstall() {\n        return [];\n      },\n      // ...\n    },\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Image Scanning on Push\nDESCRIPTION: Creates an ECR repository with automatic image scanning enabled when images are pushed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst repository = new ecr.Repository(this, 'Repo', {\n  imageScanOnPush: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Server-Side Encryption on Firehose Delivery Streams (TypeScript)\nDESCRIPTION: This snippet demonstrates how to enable server-side encryption (SSE) for a Firehose delivery stream by using different key management options: an AWS-owned KMS key, a customer-managed KMS key generated by CDK, or an explicitly provided KMS Key instance. Dependencies: @aws-cdk/aws-kinesisfirehose, @aws-cdk/aws-kms (for custom key option). Inputs: destination, optional KMS key. Output: encrypted Firehose delivery streams. The code highlights three approaches to Firehose stream encryption.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const destination: firehose.IDestination;\n\n// SSE with an AWS-owned key\nnew firehose.DeliveryStream(this, 'Delivery Stream with AWS Owned Key', {\n  encryption: firehose.StreamEncryption.awsOwnedKey(),\n  destination: destination,\n});\n// SSE with an customer-managed key that is created automatically by the CDK\nnew firehose.DeliveryStream(this, 'Delivery Stream with Customer Managed Key', {\n  encryption: firehose.StreamEncryption.customerManagedKey(),\n  destination: destination,\n});\n// SSE with an customer-managed key that is explicitly specified\ndeclare const key: kms.Key;\nnew firehose.DeliveryStream(this, 'Delivery Stream with Customer Managed and Provided Key', {\n  encryption: firehose.StreamEncryption.customerManagedKey(key),\n  destination: destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Alternative Enum-like Class Pattern with Custom Factory Method\nDESCRIPTION: An alternative implementation of the Enum-like Class pattern that uses a static factory method for custom values, providing a more consistent API for both predefined and custom options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport class MyOption {\n  public static COMMON_OPTION_1 = new MyOption('common.option-1');\n  public static COMMON_OPTION_2 = new MyOption('common.option-2');\n\n  public static custom(value: string) {\n    return new MyOption(value);\n  }\n\n  // 'protected' iso. 'private' so that someone that really wants to can still\n  // do subclassing. But maybe might as well be private.\n  protected constructor(public readonly value: string) { }\n}\n\n// Usage\nnew BoomBoom(this, 'Boom', {\n  option: MyOption.COMMON_OPTION_1\n});\n\nnew BoomBoom(this, 'Boom', {\n  option: MyOption.custom('my-value')\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring RDS Connection with Secret Manager in AWS CDK\nDESCRIPTION: Shows how to set up an RDS connection for AWS Glue using JDBC and AWS Secrets Manager for credential management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const securityGroup: ec2.SecurityGroup;\ndeclare const subnet: ec2.Subnet;\ndeclare const db: rds.DatabaseCluster;\nnew glue.Connection(this, \"RdsConnection\", {\n  type: glue.ConnectionType.JDBC,\n  securityGroups: [securityGroup],\n  subnet,\n  properties: {\n    JDBC_CONNECTION_URL: `jdbc:mysql://${db.clusterEndpoint.socketAddress}/databasename`,\n    JDBC_ENFORCE_SSL: \"false\",\n    SECRET_ID: db.secret!.secretName,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Neptune Database Port\nDESCRIPTION: Shows how to override the default Neptune port (8182) with a custom port when creating a database cluster.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  port: 12345,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Copy Tags to Snapshot for Neptune\nDESCRIPTION: Demonstrates how to enable copying of all cluster tags to snapshots when they are created by setting the copyTagsToSnapshot property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  copyTagsToSnapshot: true  // whether to save the cluster tags when creating the snapshot.\n});\n```\n\n----------------------------------------\n\nTITLE: Splitting Amazon Resource Names (ARNs) with stack.splitArn (TypeScript)\nDESCRIPTION: Shows how to extract components from an ARN string using the stack.splitArn method and a specified ArnFormat. Relies on an AWS CDK Stack instance and an ARN to split. Takes an ARN and an ArnFormat as input, returns an object with parsed ARN properties such as resourceName, which can be destructured for further logic. Use when you need to reference a specific part of an ARN in CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const stack: Stack;\n\n// Extracts the function name out of an AWS Lambda Function ARN\nconst arnComponents = stack.splitArn(arn, ArnFormat.COLON_RESOURCE_NAME);\nconst functionName = arnComponents.resourceName;\n```\n\n----------------------------------------\n\nTITLE: Setting a Default Integration for Catch-All Routes in API Gateway v2 HTTP API using AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript example sets the defaultIntegration property on HttpApi to specify a default integration, so requests hitting undefined routes are forwarded to a specified backend. Dependencies: aws-cdk-lib/aws-apigatewayv2, aws-cdk-lib/aws-apigatewayv2-integrations. Inputs include the target integration URL. Outputs: HttpApi with global default integration behavior. This helps ensure fallback handling for unexpected routes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpUrlIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nnew apigwv2.HttpApi(this, 'HttpProxyApi', {\n  defaultIntegration: new HttpUrlIntegration('DefaultIntegration', 'https://example.com'),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Off-Peak Window for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet configures a daily off-peak window for an OpenSearch domain. It enables the feature using `offPeakWindowEnabled` (optional if `offPeakWindowStart` is set) and specifies the start time for the 10-hour window using `offPeakWindowStart` with hours and minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_3,\n  offPeakWindowEnabled: true, // can be omitted if offPeakWindowStart is set\n  offPeakWindowStart: {\n    hours: 20,\n    minutes: 0,\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an S3 Bucket in CloudFormation (JSON)\nDESCRIPTION: An example CloudFormation template snippet in JSON format defining a single S3 bucket resource named 'Bucket' with a specific bucket name property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Resources\": {\n    \"Bucket\": {\n      \"Type\": \"AWS::S3::Bucket\",\n      \"Properties\": {\n        \"BucketName\": \"amzn-s3-demo-bucket\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic CloudWatch Alarm in AWS CDK\nDESCRIPTION: Demonstrates how to create a CloudWatch Alarm for a Lambda function's error metric using the Alarm constructor.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\n\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: fn.metricErrors(),\n  threshold: 100,\n  evaluationPeriods: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: WebSocket Mock Integration Setup\nDESCRIPTION: Demonstrates how to create a mock integration for WebSocket APIs without backend integration. Configures a sendMessage route that returns a static response using request templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketMockIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nnew apigwv2.WebSocketStage(this, 'mystage', {\n  webSocketApi,\n  stageName: 'dev',\n  autoDeploy: true,\n});\n\n\nwebSocketApi.addRoute('sendMessage', {\n  integration: new WebSocketMockIntegration('DefaultIntegration', {\n    requestTemplates: { 'application/json': JSON.stringify({ statusCode: 200 }) },\n    templateSelectionExpression: '\\\\$default',\n  }),\n  returnResponse: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Requiring User Verification for Passkey Sign-In in TypeScript\nDESCRIPTION: This AWS CDK code configures a Cognito User Pool to require user verification (like biometrics or device PIN) during passkey registration and authentication. It enables passkey sign-in via `signInPolicy`, sets the relying party ID, and specifies `passkeyUserVerification: cognito.PasskeyUserVerification.REQUIRED` to enforce verification.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  signInPolicy: {\n    allowedFirstAuthFactors: { password: true, passkey: true },\n  },\n  passkeyRelyingPartyId: 'auth.example.com',\n  passkeyUserVerification: cognito.PasskeyUserVerification.REQUIRED,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Cooldown Period for Queue Processing Fargate Service\nDESCRIPTION: Shows how to configure a custom cooldown period for scaling activities in QueueProcessingFargateService.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  vpc,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  assignPublicIp: true,\n  cooldown: Duration.seconds(500),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Custom Domain for AWS AppSync Event API in TypeScript\nDESCRIPTION: This example shows how to configure a custom domain name for an AWS AppSync Event API. It creates an ACM certificate for the domain and sets up the API with the custom domain configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acm from 'aws-cdk-lib/aws-certificatemanager';\nimport * as route53 from 'aws-cdk-lib/aws-route53';\n\nconst myDomainName = 'api.example.com';\nconst certificate = new acm.Certificate(this, 'cert', { domainName: myDomainName });\n\nconst apiKeyProvider: appsync.AppSyncAuthProvider = {\n  authorizationType: appsync.AppSyncAuthorizationType.API_KEY,\n};\n\nconst api = new appsync.EventApi(this, 'api', {\n  apiName: 'Api',\n  ownerContact: 'OwnerContact',\n  authorizationConfig: {\n    authProviders: [\n      apiKeyProvider,\n    ],\n    connectionAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultPublishAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n    defaultSubscribeAuthModeTypes: [\n      appsync.AppSyncAuthorizationType.API_KEY,\n    ],\n  },\n  // Custom Domain Settings\n  domainName: {\n    certificate,\n    domainName: myDomainName,\n  },\n});\n\napi.addChannelNamespace('default');\n\n// You can get custom HTTP/Realtime endpoint\nnew CfnOutput(this, 'AWS AppSync Events HTTP endpoint', { value: api.customHttpEndpoint });\nnew CfnOutput(this, 'AWS AppSync Events Realtime endpoint', { value: api.customRealtimeEndpoint });\n```\n\n----------------------------------------\n\nTITLE: Defining Role Configuration Prop in AWS CDK TypeScript\nDESCRIPTION: Illustrates defining an optional `role` property of type `iam.IRole` within a construct's props interface (`FooProps`). This allows users to specify an existing IAM role for the resource; if omitted, the construct should typically create a default role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface FooProps {\n  /**\n   * The role to associate with foo.\n   * @default - a role will be automatically created\n   */\n  role?: iam.IRole;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Function with Default Values in TypeScript\nDESCRIPTION: An example showing how to create a Lambda function with only the required properties for integration testing. This represents the minimum configuration needed for testing a new L2 construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'Handler', {\n  code,\n  handler,\n  runtime,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Static Grant Methods in AWS CDK TypeScript\nDESCRIPTION: Demonstrates how to define static grant methods on the resource construct class (e.g., `Table.grantAllListStreams`). These methods are used for granting permissions that apply broadly (e.g., across all resources of that type) rather than to a specific instance. They typically accept an `iam.IGrantable` and return an `iam.Grant` object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport class Table {\n  public static grantAll(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n  public static grantAllListStreams(grantee: iam.IGrantable): iam.Grant;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing ServiceCatalogAppRegistry Constructs with AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the ServiceCatalogAppRegistry module from the aws-cdk-lib for use in AWS CDK TypeScript projects. The 'servicecatalogappregistry' import provides access to the automatically generated L1 constructs, enabling users to define AWS Service Catalog AppRegistry resources in their CDK stacks. Ensure that 'aws-cdk-lib' is installed as a project dependency before using these imports. Inputs are import statements, and outputs are the corresponding namespace made available for reference in user-defined CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-servicecatalogappregistry/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as servicecatalogappregistry from 'aws-cdk-lib/aws-servicecatalogappregistry';\n```\n\n----------------------------------------\n\nTITLE: Configuring Client-Side KMS Encryption (Auto Key) for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet shows how to configure client-side encryption using an AWS KMS key (CSE-KMS) for an AWS Glue S3 Table with AWS CDK. Setting `encryption` to `glue.TableEncryption.CLIENT_SIDE_KMS` prompts CDK to automatically create a KMS key for client-side encryption operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\n// KMS key is created automatically\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.CLIENT_SIDE_KMS, \n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Variables in IoT Events Detector Instance\nDESCRIPTION: Creates an Action that sets a variable in the detector instance when triggered. This example demonstrates setting a variable value from an input attribute.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-actions-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\nimport * as actions from '@aws-cdk/aws-iotevents-actions-alpha';\n\ndeclare const input: iotevents.IInput;\n\nconst state = new iotevents.State({\n  stateName: 'MyState',\n  onEnter: [{\n    eventName: 'test-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [\n      new actions.SetVariableAction(\n        'MyVariable',\n        iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      ),\n    ],\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Basic Auth to Specific Branch in TypeScript\nDESCRIPTION: Demonstrates how to add basic authentication to a specific branch in an Amplify app. This allows for protecting only certain environments (like feature branches) with password authentication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const amplifyApp: amplify.App;\namplifyApp.addBranch('feature/next', {\n  basicAuth: amplify.BasicAuth.fromGeneratedPassword('username'),\n});\n```\n\n----------------------------------------\n\nTITLE: Example Usage of the New Tagging API with ECS Resources in TypeScript\nDESCRIPTION: Example demonstrating how the proposed tagging API would be used with ECS task definitions and services, showing both tag addition and removal operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/tagging-API-change.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Create Task Definition\nconst taskDefinition = new ecs.Ec2TaskDefinition(stack, 'TaskDef');\n\n// Create Service\nconst service = new ecs.Ec2Service(stack, \"Service\", {\n  cluster,\n  taskDefinition,\n});\n\nTag.add(taskDefinition, 'tfoo', 'tbar');\nTag.remove(taskDefinition, 'foo', 'bar');\n\nTag.add(service, 'sfoo', 'sbar');\nTag.remove(service, 'foo', 'bar');\n```\n\n----------------------------------------\n\nTITLE: Creating a Redshift Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic Redshift cluster using the AWS CDK. It creates a VPC and a Redshift cluster with a master user.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\nconst vpc = new ec2.Vpc(this, 'Vpc');\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc\n});\n```\n\n----------------------------------------\n\nTITLE: Importing a Basic VPC in TypeScript\nDESCRIPTION: Demonstrates how to import an existing VPC using the VpcV2.fromVpcV2Attributes() method with only the required parameters: VPC ID and primary CIDR block.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\n\nconst importedVpc = VpcV2.fromVpcV2Attributes(stack, 'ImportedVpc', {\n      vpcId: 'mockVpcID',\n      vpcCidrBlock: '10.0.0.0/16',\n});\n```\n\n----------------------------------------\n\nTITLE: Adding External Authentication Providers to Identity Pool in TypeScript\nDESCRIPTION: This code demonstrates how to add various external authentication providers (Amazon, Facebook, Google, Apple, Twitter) directly to an Identity Pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  authenticationProviders: {\n    amazon: {\n      appId: 'amzn1.application.12312k3j234j13rjiwuenf',\n    },\n    facebook: {\n      appId: '1234567890123',\n    },\n    google: {\n      clientId: '12345678012.apps.googleusercontent.com',\n    },\n    apple: {\n      servicesId: 'com.myappleapp.auth',\n    },\n    twitter: {\n      consumerKey: 'my-twitter-id',\n      consumerSecret: 'my-twitter-secret',\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Not Matcher in AWS CDK Template Testing\nDESCRIPTION: Illustrates the usage of Match.not() to invert search patterns and match elements that do not match the specified pattern in CDK templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": [\"Flob\", \"Cat\"]\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.not(['Flob']),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', Match.objectLike({\n  Fred: Match.not(['Flob', 'Cat']),\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS for VirtualNode and VirtualGateway listeners\nDESCRIPTION: Demonstrates three methods of providing TLS certificates to App Mesh proxies: from AWS Certificate Manager (ACM), from customer-provided files, and from a Secrets Discovery Service (SDS) endpoint. Shows configuration for both VirtualNode and VirtualGateway resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// A Virtual Node with listener TLS from an ACM provided certificate\ndeclare const cert: certificatemanager.Certificate;\ndeclare const mesh: appmesh.Mesh;\n\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('node'),\n  listeners: [appmesh.VirtualNodeListener.grpc({\n    port: 80,\n    tls: {\n      mode: appmesh.TlsMode.STRICT,\n      certificate: appmesh.TlsCertificate.acm(cert),\n    },\n  })],\n});\n\n// A Virtual Gateway with listener TLS from a customer provided file certificate\nconst gateway = new appmesh.VirtualGateway(this, 'gateway', {\n  mesh,\n  listeners: [appmesh.VirtualGatewayListener.grpc({\n    port: 8080,\n    tls: {\n      mode: appmesh.TlsMode.STRICT,\n      certificate: appmesh.TlsCertificate.file('path/to/certChain', 'path/to/privateKey'),\n    },\n  })],\n  virtualGatewayName: 'gateway',\n});\n\n// A Virtual Gateway with listener TLS from a SDS provided certificate\nconst gateway2 = new appmesh.VirtualGateway(this, 'gateway2', {\n  mesh,\n  listeners: [appmesh.VirtualGatewayListener.http2({\n    port: 8080,\n    tls: {\n      mode: appmesh.TlsMode.STRICT,\n      certificate: appmesh.TlsCertificate.sds('secrete_certificate'),\n    },\n  })],\n  virtualGatewayName: 'gateway2',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Compute Platform for AWS CodeGuru Profiler\nDESCRIPTION: Demonstrates how to create a profiling group with a specific compute platform configuration. This example shows how to configure a profiling group specifically for AWS Lambda environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codeguruprofiler/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst profilingGroup = new codeguruprofiler.ProfilingGroup(this, 'MyProfilingGroup', {\n  computePlatform: codeguruprofiler.ComputePlatform.AWS_LAMBDA,\n});\n```\n\n----------------------------------------\n\nTITLE: Building and Testing aws-cdk-lib Module\nDESCRIPTION: Commands to build and test the aws-cdk-lib module specifically. This is a common workflow when making changes to this core module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/aws-cdk-lib\n$ yarn build\n$ yarn test\n```\n\n----------------------------------------\n\nTITLE: Setting Period for SingleValueWidget (TypeScript)\nDESCRIPTION: Illustrates how to set the period property on SingleValueWidget to specify the aggregation time interval, e.g., 15 minutes. Duration helper is required. Adjusts the default data aggregation window for the widget.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.SingleValueWidget({\n  metrics: [ /* ... */ ],\n\n  period: Duration.minutes(15),\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating an EKS Cluster with Auto Mode Explicitly Enabled in TypeScript\nDESCRIPTION: Demonstrates how to create an EKS cluster with Auto Mode explicitly enabled using the defaultCapacityType property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksAutoCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.AUTOMODE,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Sourced Configuration from S3 Bucket in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a sourced configuration that references a file stored in an Amazon S3 bucket. The versioned bucket is used to store configuration data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nconst bucket = new s3.Bucket(this, 'MyBucket', {\n  versioned: true,\n});\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromBucket(bucket, 'path/to/file.json'),\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering and Sorting AlarmStatusWidget Output (TypeScript)\nDESCRIPTION: Demonstrates configuring an AlarmStatusWidget to show only firing alarms, sorted by state update timestamp. Requires Alarm, Dashboard, and relevant constants from aws-cdk-lib/aws-cloudwatch. Customizes the displayed alarm states and order for focused monitoring.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const errorAlarm: cloudwatch.Alarm;\n\ndashboard.addWidgets(new cloudwatch.AlarmStatusWidget({\n  title: \"Errors\",\n  alarms: [errorAlarm],\n  sortBy: cloudwatch.AlarmStatusWidgetSortBy.STATE_UPDATED_TIMESTAMP,\n  states: [cloudwatch.AlarmState.ALARM],\n}));\n```\n\n----------------------------------------\n\nTITLE: JSON IAM Policy Resource Example - AWS CloudFormation - JSON\nDESCRIPTION: This snippet provides a CloudFormation-structured IAM policy Resource field using Fn::Join, Fn::Ref, and string concatenation to build an ARN. It is meant to demonstrate how CDK or CloudFormation templates might generate ARNs with embedded pseudo-parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Fn::Join\": [\n    \"\",\n    [\n      \"arn:\",\n      {\n        \"Ref\": \"AWS::Partition\"\n      },\n      \":iam::\",\n      {\n        \"Ref\": \"AWS::AccountId\"\n      },\n      \":role/Role\"\n    ]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Managing CloudFront Distribution Permissions in TypeScript\nDESCRIPTION: This snippet illustrates how to grant permissions on a CloudFront distribution, including allowing specific actions and creating invalidations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const distribution: cloudfront.Distribution;\ndeclare const lambdaFn: lambda.Function;\ndistribution.grant(lambdaFn, 'cloudfront:ListInvalidations', 'cloudfront:GetInvalidation');\ndistribution.grantCreateInvalidation(lambdaFn);\n```\n\n----------------------------------------\n\nTITLE: Implementing Rule-Based Role Mapping\nDESCRIPTION: Demonstrates how to implement rule-based role mapping using custom claims from the identity provider to assign specific roles based on claim values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IdentityPoolProviderUrl, RoleMappingMatchType } from 'aws-cdk-lib/aws-cognito-identitypool';\n\ndeclare const adminRole: iam.Role;\ndeclare const nonAdminRole: iam.Role;\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  roleMappings: [{\n    providerUrl: IdentityPoolProviderUrl.AMAZON,\n    rules: [\n      {\n        claim: 'custom:admin',\n        claimValue: 'admin',\n        mappedRole: adminRole,\n      },\n      {\n        claim: 'custom:admin',\n        claimValue: 'admin',\n        matchType: RoleMappingMatchType.NOTEQUAL,\n        mappedRole: nonAdminRole,\n      }\n    ],\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up a DynamoDB Stream Source for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a DynamoDB stream as the source. The example first creates a DynamoDB table with streaming enabled, then configures the pipe to start processing events from the latest stream position.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-sources-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst table = new ddb.TableV2(this, 'MyTable', {\n  partitionKey: {\n    name: 'id',\n    type: ddb.AttributeType.STRING,\n  },\n  dynamoStream: ddb.StreamViewType.NEW_IMAGE,\n});\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeSource = new sources.DynamoDBSource(table, {\n  startingPosition: sources.DynamoDBStartingPosition.LATEST,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: pipeSource,\n  target: new SqsTarget(targetQueue)\n});\n```\n\n----------------------------------------\n\nTITLE: Sharing an AppRegistry Application with Resource Association Permission in TypeScript\nDESCRIPTION: Shares an AppRegistry Application with multiple AWS accounts and grants them permission to associate their own resources (like CloudFormation stacks) with the shared application by setting `sharePermission` to `appreg.SharePermission.ALLOW_ACCESS`. Requires an existing `appreg.Application` instance and AWS Organizations enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const application: appreg.Application;\napplication.shareApplication('MyShareId', {\n  name: 'MyShare',\n  accounts: ['123456789012', '234567890123'],\n  sharePermission: appreg.SharePermission.ALLOW_ACCESS,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling JSON Format for Policy Validation Reports via Context - TypeScript\nDESCRIPTION: Demonstrates how to instruct AWS CDK to emit policy validation reports in JSON format by setting the @aws-cdk/core:validationReportJson context key at app construction. When specified, report output will be written to policy-validation-report.json in the cloud assembly directory after synthesis. Requires aws-cdk-lib and the desired context key assigned at App construction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  context: { '@aws-cdk/core:validationReportJson': true },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Amplify Module in AWS CDK (TypeScript)\nDESCRIPTION: Imports the AWS Amplify namespace (`amplify`) from the `aws-cdk-lib` package in TypeScript. This import is necessary to access and utilize AWS Amplify L1 constructs within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-amplify/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as amplify from 'aws-cdk-lib/aws-amplify';\n```\n\n----------------------------------------\n\nTITLE: Importing CodeGuru Reviewer Module in AWS CDK\nDESCRIPTION: Basic import statement for accessing AWS CodeGuru Reviewer constructs in a CDK application. This allows usage of L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codegurureviewer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codegurureviewer from 'aws-cdk-lib/aws-codegurureviewer';\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Options for Python Lambda Bundling\nDESCRIPTION: Sets additional Docker options like network, security options, user, and volumes for the Python Lambda bundling environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst entry = '/path/to/function';\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n      network: 'host',\n      securityOpt: 'no-new-privileges',\n      user: 'user:group',\n      volumesFrom: ['777f7dc92da7'],\n      volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing IAM Policies for Universal Target in EventBridge Scheduler\nDESCRIPTION: Creates an EventBridge Scheduler that invokes an AWS SQS sendMessage API call with custom IAM policy statements. This example demonstrates how to override the default policy generation with specific resource-scoped permissions for better security.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.minutes(60)),\n  target: new targets.Universal({\n    service: 'sqs',\n    action: 'sendMessage',\n    policyStatements: [\n      new iam.PolicyStatement({\n        actions: ['sqs:SendMessage'],\n        resources: ['arn:aws:sqs:us-east-1:123456789012:my_queue'],\n      }),\n      new iam.PolicyStatement({\n        actions: ['kms:Decrypt', 'kms:GenerateDataKey*'],\n        resources: ['arn:aws:kms:us-east-1:123456789012:key/0987dcba-09fe-87dc-65ba-ab0987654321'],\n      }),\n    ],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudFormation Stack Notification Check Config Rule in TypeScript\nDESCRIPTION: Shows how to create a Config rule that checks if CloudFormation stacks are sending event notifications to specified SNS topics. The rule is non-compliant if a stack does not send notifications to either of the allowed topics.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// topics to which CloudFormation stacks may send event notifications\nconst topic1 = new sns.Topic(this, 'AllowedTopic1');\nconst topic2 = new sns.Topic(this, 'AllowedTopic2');\n\n// non-compliant if CloudFormation stack does not send notifications to 'topic1' or 'topic2'\nnew config.CloudFormationStackNotificationCheck(this, 'NotificationCheck', {\n  topics: [topic1, topic2],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing prlint GitHub Action Dependencies\nDESCRIPTION: Commands for navigating to the prlint directory and installing its dependencies using yarn package manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/prlint/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\ncd tools/@aws-cdk/prlint\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CleanRooms L1 Constructs in TypeScript\nDESCRIPTION: This TypeScript code snippet shows how to import the AWS CleanRooms module from the core AWS CDK library. This import makes the L1 CloudFormation constructs for CleanRooms available for use within a CDK application. Requires the 'aws-cdk-lib' package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cleanrooms/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cleanrooms from 'aws-cdk-lib/aws-cleanrooms';\n```\n\n----------------------------------------\n\nTITLE: Creating an MSK Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic MSK Cluster using the AWS CDK. It specifies the cluster name, Kafka version, and VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'Cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Deploy-Time Asset Lifetime in TypeScript\nDESCRIPTION: Shows how to configure the lifetime of deploy-time file assets by setting deployTimeFileAssetLifetime when initializing the App with a default stack synthesizer.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BucketEncryption } from 'aws-cdk-lib/aws-s3';\n\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    deployTimeFileAssetLifetime: Duration.days(100),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Default IAM Role during Redshift Cluster Creation using AWS CDK (TypeScript)\nDESCRIPTION: This snippet illustrates how to create an IAM role assumed by the Redshift service and set it as the default role for an AWS Redshift cluster during its creation using AWS CDK. The `defaultRole` property simplifies operations requiring Redshift to access other AWS services, as the role ARN doesn't need to be explicitly provided. Requires an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as cdk from 'aws-cdk-lib';\nimport { Cluster } from 'aws-cdk-lib/aws-redshift-alpha'; // Assuming Cluster is from aws-redshift-alpha\ndeclare const vpc: ec2.Vpc;\ndeclare const this: cdk.Stack; // Assuming 'this' is a CDK Stack context\n\nconst defaultRole = new iam.Role(this, 'DefaultRole', {\n  assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n},\n);\n\nnew Cluster(this, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n    roles: [defaultRole], // Role must also be in the roles list\n    defaultRole: defaultRole,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Subscribing Email via CloudFormation Parameter Token with AWS CDK in TypeScript\nDESCRIPTION: Shows how to subscribe an SNS topic to an email address supplied at deployment time via a CloudFormation parameter. Utilizes aws-cdk-lib/aws-cloudformation for parameter definition. The recipient must confirm their subscription via a verification email. Supports dynamic configuration for different environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns-subscriptions/README.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myTopic = new sns.Topic(this, 'Topic');\nconst emailAddress = new CfnParameter(this, 'email-param');\n\nmyTopic.addSubscription(new subscriptions.EmailSubscription(emailAddress.valueAsString));\n```\n\n----------------------------------------\n\nTITLE: Adding a Virtual Router to an App Mesh Mesh in TypeScript\nDESCRIPTION: Uses the `addVirtualRouter` convenience method on a pre-existing `appmesh.Mesh` instance (`mesh`) to create and associate a `VirtualRouter` resource within the same CDK stack as the mesh. The router is configured with an HTTP listener (`appmesh.VirtualRouterListener.http`) on port 8080. Requires a `mesh` variable (of type `appmesh.Mesh`) declared in the scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\nconst router = mesh.addVirtualRouter('router', {\n  listeners: [appmesh.VirtualRouterListener.http(8080)],\n});\n```\n\n----------------------------------------\n\nTITLE: Using Trigger with Pre-existing Lambda Functions in AWS CDK\nDESCRIPTION: Creates a Trigger construct that uses a pre-defined Lambda function. This example shows how to trigger an existing function with custom timeout and invocation type configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/triggers/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as triggers from 'aws-cdk-lib/triggers';\n\nconst func = new lambda.Function(this, 'MyFunction', {\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_18_X,\n  code: lambda.Code.fromInline('foo'),\n});\n\nnew triggers.Trigger(this, 'MyTrigger', {\n  handler: func,\n  timeout: Duration.minutes(10),\n  invocationType: triggers.InvocationType.EVENT,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Protection Policy for CloudWatch Logs\nDESCRIPTION: Demonstrates how to create and configure a data protection policy with custom identifiers and audit destinations for sensitive data masking.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst dataProtectionPolicy = new logs.DataProtectionPolicy({\n  name: 'data protection policy',\n  description: 'policy description',\n  identifiers: [\n    logs.DataIdentifier.DRIVERSLICENSE_US,\n    new logs.DataIdentifier('EmailAddress'),\n    new logs.CustomDataIdentifier('EmployeeId', 'EmployeeId-\\\\d{9}')],\n  logGroupAuditDestination: logGroupDestination,\n  s3BucketAuditDestination: bucket,\n  deliveryStreamNameAuditDestination: deliveryStream.deliveryStreamName,\n});\n\nnew logs.LogGroup(this, 'LogGroupLambda', {\n  logGroupName: 'cdkIntegLogGroup',\n  dataProtectionPolicy: dataProtectionPolicy,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Canary Timeout in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to configure the maximum execution duration (timeout) for a Synthetics Canary using the `timeout` property. This example sets the timeout to 60 seconds using `cdk.Duration.seconds`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from \"aws-cdk-lib\";\n\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  timeout: cdk.Duration.seconds(60), // 60 seconds\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon SES VDM Options for Configuration Sets in TypeScript\nDESCRIPTION: Creates a configuration set with specific Virtual Deliverability Manager options. This must be used in conjunction with account-level settings to enable VDM functionality.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nnew ses.ConfigurationSet(this, 'ConfigurationSetWithVdmOptions', {\n  vdmOptions: {\n    engagementMetrics: true,\n    optimizedSharedDelivery: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing Lambda Deployment Configuration in TypeScript\nDESCRIPTION: Demonstrates how to import an existing CodeDeploy Lambda Deployment Configuration into an AWS CDK application by its name. This allows referencing configurations created outside the current CDK stack or shared across multiple deployment groups.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentConfig = codedeploy.LambdaDeploymentConfig.fromLambdaDeploymentConfigName(\n  this,\n  'ExistingDeploymentConfiguration',\n  'MyExistingDeploymentConfiguration',\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling Availability Zone Relocation for Redshift Cluster in TypeScript\nDESCRIPTION: This snippet shows how to enable availability zone relocation for a Redshift cluster using RA3 node types.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const vpc: ec2.IVpc;\n\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  nodeType: NodeType.RA3_XLPLUS,\n  availabilityZoneRelocation: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Owner Contact for AppSync GraphQL API in TypeScript\nDESCRIPTION: This snippet demonstrates how to set the owner contact information for an AWS AppSync GraphQL API resource. The owner contact is a string with a length of 0-256 characters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'OwnerContact', {\n    name: 'OwnerContact',\n    definition: appsync.Definition.fromSchema(appsync.SchemaFile.fromAsset(path.join(__dirname, 'appsync.test.graphql'))),\n    ownerContact: 'test-owner-contact',\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting Amplify App to GitLab Source in TypeScript\nDESCRIPTION: Creates an Amplify application with GitLab as the source code provider. This snippet shows how to configure GitLab repository connection using an OAuth token stored in Secrets Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  sourceCodeProvider: new amplify.GitLabSourceCodeProvider({\n    owner: '<user>',\n    repository: '<repo>',\n    oauthToken: SecretValue.secretsManager('my-gitlab-token'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating AWS CodeArtifact with Python Lambda Bundling\nDESCRIPTION: Demonstrates how to use AWS CodeArtifact as a private PyPI repository for Python Lambda dependencies by setting the PIP_INDEX_URL environment variable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { execSync } from 'child_process';\n\nconst entry = '/path/to/function';\nconst image = DockerImage.fromBuild(entry);\n\nconst domain = 'my-domain';\nconst domainOwner = '111122223333';\nconst repoName = 'my_repo';\nconst region = 'us-east-1';\nconst codeArtifactAuthToken = execSync(`aws codeartifact get-authorization-token --domain ${domain} --domain-owner ${domainOwner} --query authorizationToken --output text`).toString().trim();\n\nconst indexUrl = `https://aws:${codeArtifactAuthToken}@${domain}-${domainOwner}.d.codeartifact.${region}.amazonaws.com/pypi/${repoName}/simple/`;\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    environment: { PIP_INDEX_URL: indexUrl },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Generic Integration Test Stack Comments - TypeScript\nDESCRIPTION: This snippet shows a placeholder for stack verification steps within a TypeScript-based integration test. It is intended for contributors to specify the individual verification steps for a CDK stack. This snippet has no dependencies and should be manually customized for each test.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n/*\n * Stack verification steps:\n * * <step-1>\n * * <step-2>\n */\n```\n\n----------------------------------------\n\nTITLE: Attaching a Recording Configuration to an IVS Channel\nDESCRIPTION: Creates an IVS channel with recording enabled by attaching a recording configuration to it.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recordingConfiguration: ivs.RecordingConfiguration;\n\nconst channel = new ivs.Channel(this, 'Channel', {\n  // set recording configuration\n  recordingConfiguration: recordingConfiguration,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IVS L1 Constructs in TypeScript\nDESCRIPTION: Imports the AWS IVS L1 construct library from `aws-cdk-lib` into a TypeScript CDK project. This allows developers to use IVS resources like Channels and Stream Keys directly, similar to CloudFormation definitions. Requires the `aws-cdk-lib` dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ivs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ivs from 'aws-cdk-lib/aws-ivs';\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubectl Handler Environment - AWS CDK - TypeScript\nDESCRIPTION: Configures environment variables for the kubectl Lambda handler when creating an EKS cluster. Particularly useful for settings like HTTP proxies. Requires the @aws-cdk/lambda-layer-kubectl-v32 package, and properties are passed in 'kubectlProviderOptions'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nconst cluster = new eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n    environment: {\n        'http_proxy': 'http://proxy.myproxy.com',\n    },\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a VPC with BYOIP IPv6 Addresses in TypeScript\nDESCRIPTION: This example shows how to create a VPC using VpcV2 with Bring Your Own IP (BYOIP) IPv6 addresses. It demonstrates specifying a primary IPv4 CIDR and adding a BYOIP IPv6 pool as a secondary address block.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst myVpc = new VpcV2(this, 'Vpc', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n  secondaryAddressBlocks: [IpAddresses.ipv6ByoipPool({\n    cidrBlockName: 'MyByoipCidrBlock',\n    ipv6PoolId: 'ipv6pool-ec2-someHashValue',\n    ipv6CidrBlock: '2001:db8::/32'\n  })],\n  enableDnsHostnames: true,\n  enableDnsSupport: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Limiting Concurrent Builds in CodeBuild Project\nDESCRIPTION: Demonstrates how to set a concurrent build limit to control the number of simultaneous builds allowed for a project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  concurrentBuildLimit: 1\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring awslint via package.json\nDESCRIPTION: Example showing how to configure awslint options through the package.json file by adding an awslint key with desired configuration options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/awslint/README.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"awslint\": {\n    \"debug\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Endpoint Origin\nDESCRIPTION: Creates a CloudFront distribution with an HTTP endpoint as the origin\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.HttpOrigin('www.example.com') },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an App Mesh Virtual Service with Virtual Router Provider in TypeScript\nDESCRIPTION: Instantiates an `appmesh.VirtualService` using the CDK construct within the current scope (`this`). It configures the service with an optional `virtualServiceName` (recommended to match the service discovery name) and specifies an existing `appmesh.VirtualRouter` instance (`router`) as its provider using `appmesh.VirtualServiceProvider.virtualRouter()`. This routes traffic for the virtual service via the specified router. Requires a `router` variable (of type `appmesh.VirtualRouter`) declared in the scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\n\nnew appmesh.VirtualService(this, 'virtual-service', {\n  virtualServiceName: 'my-service.default.svc.cluster.local', // optional\n  virtualServiceProvider: appmesh.VirtualServiceProvider.virtualRouter(router),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding EC2 Instance as Load Balancer Target - AWS CDK - TypeScript\nDESCRIPTION: This snippet configures a classic Elastic Load Balancer with an EC2 Instance as its target using the InstanceTarget wrapper. Dependencies include ec2 and elb modules. The EC2 instance is created with specified instance type and Amazon Linux 2 image; the load balancer adds the instance as a target, suitable for dynamic or single-host use cases.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticloadbalancing/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\nconst lb = new elb.LoadBalancer(this, 'LB', {\n  vpc,\n  internetFacing: true,\n});\n\n// instance to add as the target for load balancer.\nconst instance = new ec2.Instance(this, 'targetInstance', {\n  vpc: vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n  machineImage: new ec2.AmazonLinuxImage({ generation: ec2.AmazonLinuxGeneration.AMAZON_LINUX_2 }),\n});\nlb.addTarget(new elb.InstanceTarget(instance));\n```\n\n----------------------------------------\n\nTITLE: Adding Construct Validation in TypeScript\nDESCRIPTION: Example showing how to add post-initialization validation to a construct using addValidation(). Used when construct integrity can only be verified after complete initialization.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nthis.node.addValidation({\n  // 'validate' should return a string[] list of errors\n  validate: () => this.rules.length === 0\n    ? ['At least one Rule must be added. Call \\'addRule()\\' to add Rules.']\n    : []\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Multivalue Answer Routing in Route53 using AWS CDK\nDESCRIPTION: Demonstrates how to enable multivalue answer routing for an A record in Route53. It uses the multivalueAnswer parameter to enable this routing policy.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecordMultiValue1', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4'),\n  multiValueAnswer: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Gateway Route Path Rewrite in AWS App Mesh with CDK\nDESCRIPTION: Demonstrates different ways to configure path rewriting for HTTP-based gateway routes in AWS App Mesh, including disabling default rewrite and specifying custom rewrite paths.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const gateway: appmesh.VirtualGateway;\ndeclare const virtualService: appmesh.VirtualService;\n\ngateway.addGatewayRoute('gateway-route-http', {\n  routeSpec: appmesh.GatewayRouteSpec.http({\n    routeTarget: virtualService,\n    match: {\n      // This disables the default rewrite to '/', and retains original path.\n      path: appmesh.HttpGatewayRoutePathMatch.startsWith('/path-to-app/', ''),\n    },\n  }),\n});\n\ngateway.addGatewayRoute('gateway-route-http-1', {\n  routeSpec: appmesh.GatewayRouteSpec.http({\n    routeTarget: virtualService,\n    match: {\n      // If the request full path is '/path-to-app/xxxxx', this rewrites the path to '/rewrittenUri/xxxxx'.\n      // Please note both `prefixPathMatch` and `rewriteTo` must start and end with the `/` character.\n      path: appmesh.HttpGatewayRoutePathMatch.startsWith('/path-to-app/', '/rewrittenUri/'),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Amazon SES Virtual Deliverability Manager in TypeScript\nDESCRIPTION: Sets up the Virtual Deliverability Manager at the account level. This enables engagement tracking and optimized shared delivery by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ses/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// Enables engagement tracking and optimized shared delivery by default\nnew ses.VdmAttributes(this, 'Vdm');\n```\n\n----------------------------------------\n\nTITLE: Instantiating Lambda Functions with Code Variants - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates the recommended approach for specifying code sources when creating a lambda.Function construct in AWS CDK TypeScript, replacing TypeScript union types with distinct static factory methods on the lambda.Code class. The snippet highlights three alternative code source methods: asset, bucket, and inline. Dependencies include AWS CDK's lambda module. Inputs involve construct parameters and code source details, while the output is a configured Function. Avoids unions to ensure cross-language compatibility.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew lambda.Function(this, 'MyFunction', {\n  code: lambda.Code.asset('/asset/path'), // or\n  code: lambda.Code.bucket(myBucket, 'bundle.zip'), // or\n  code: lambda.Code.inline('code')\n  // etc\n})\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AmplifyUIBuilder Module for AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS AmplifyUIBuilder library from aws-cdk-lib for use within a TypeScript project using the AWS Cloud Development Kit. No special prerequisites are required beyond having aws-cdk-lib installed as a dependency. The import enables access to the L1 constructs corresponding to AWS::AmplifyUIBuilder CloudFormation resources. This is necessary since L2 constructs are not available yet; developers must use L1 constructs for direct resource management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-amplifyuibuilder/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as amplifyuibuilder from 'aws-cdk-lib/aws-amplifyuibuilder';\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Submodules for CodeBuild Source in TypeScript\nDESCRIPTION: Demonstrates how to enable fetching of Git submodules when cloning a repository for a CodeBuild project. This can be applied to any Git-based source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst gitHubSource = codebuild.Source.gitHub({\n  owner: 'awslabs',\n  repo: 'aws-cdk',\n  fetchSubmodules: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Kinesis Analytics Construct Module - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the Amazon Kinesis Data Analytics construct library from 'aws-cdk-lib/aws-kinesisanalytics' in a TypeScript-based AWS CDK project. It enables access to all L1 CloudFormation resources for Kinesis Analytics within the CDK, with the prerequisite that 'aws-cdk-lib' is installed as a project dependency. No L2 (handwritten higher-level) constructs are available. The import must be placed at the top of your TypeScript CDK application file to access all generated resources under the 'kinesisanalytics' namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisanalytics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as kinesisanalytics from 'aws-cdk-lib/aws-kinesisanalytics';\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Environment Variables for Go Builds\nDESCRIPTION: Demonstrates how to set custom environment variables that will be available during the Go build process. These are in addition to standard variables like GOOS, GOARCH, and GO111MODULE that are set automatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'handler', {\n  entry: 'app/cmd/api',\n  bundling: {\n    environment: {\n      HELLO: 'WORLD',\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using an AWS Lambda Function as a Custom Resource Provider in TypeScript\nDESCRIPTION: Illustrates configuring an AWS CDK `CustomResource` to use an AWS Lambda function directly as its provider. A `lambda.SingletonFunction` is defined, and its ARN (`fn.functionArn`) is supplied as the `serviceToken`. CloudFormation directly invokes this function for CREATE, UPDATE, and DELETE events. Note: Higher-level CDK custom resource constructs are often preferred for easier implementation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst fn = new lambda.SingletonFunction(this, 'MyProvider', functionProps);\n\nnew CustomResource(this, 'MyResource', {\n  serviceToken: fn.functionArn,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Loading Nested Stacks After CfnInclude Creation\nDESCRIPTION: Demonstrates how to load nested stacks after the CfnInclude object has been created. This provides flexibility in when nested stacks are included.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const parentTemplate: cfn_inc.CfnInclude;\nconst includedChildStack = parentTemplate.loadNestedStack('ChildTemplate', {\n  templateFile: 'path/to/my-nested-template.json',\n});\n```\n\n----------------------------------------\n\nTITLE: Lambda Destination Failure Invocation Record Format in JSON\nDESCRIPTION: Example JSON format for an invocation record sent to a destination when a Lambda function invocation fails. This record includes error details such as error message, error type, and stack trace along with request metadata.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-destinations/README.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": \"1.0\",\n  \"timestamp\": \"2019-11-24T21:52:47.333Z\",\n  \"requestContext\": {\n    \"requestId\": \"8ea123e4-1db7-4aca-ad10-d9ca1234c1fd\",\n    \"functionArn\": \"arn:aws:lambda:sa-east-1:123456678912:function:event-destinations:$LATEST\",\n    \"condition\": \"RetriesExhausted\",\n    \"approximateInvokeCount\": 3\n  },\n  \"requestPayload\": {\n    \"Success\": false\n  },\n  \"responseContext\": {\n    \"statusCode\": 200,\n    \"executedVersion\": \"$LATEST\",\n    \"functionError\": \"Handled\"\n  },\n  \"responsePayload\": {\n    \"errorMessage\": \"Failure from event, Success = false, I am failing!\",\n    \"errorType\": \"Error\",\n    \"stackTrace\": [ \"exports.handler (/var/task/index.js:18:18)\" ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Branches to Amplify App in TypeScript\nDESCRIPTION: Demonstrates how to add branches to an Amplify application with configuration options like performance mode and environment variables. This snippet shows adding main and dev branches with different settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const amplifyApp: amplify.App;\n\nconst main = amplifyApp.addBranch('main'); // `id` will be used as repo branch name\nconst dev = amplifyApp.addBranch('dev', {\n  performanceMode: true, // optional, enables performance mode\n});\ndev.addEnvironment('STAGE', 'dev');\n```\n\n----------------------------------------\n\nTITLE: Creating and Associating an Attribute Group with an AppRegistry Application in TypeScript\nDESCRIPTION: Demonstrates creating a new attribute group and immediately associating it with an existing AppRegistry application instance using the `addAttributeGroup` method on the application object. Requires an existing `appreg.Application` instance (`application`) and the definition for the new attribute group (name, description, attributes).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appreg.Application;\ndeclare const attributeGroup: appreg.AttributeGroup;\napplication.addAttributeGroup('MyAttributeGroupId' , {\n    attributeGroupName: 'MyAttributeGroupName',\n    description: 'Test attribute group',\n    attributes: {},\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a CloudWatch Logs Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a CloudWatch Logs log group as the target. The pipe will send events from an SQS queue source to the log group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetLogGroup: logs.LogGroup;\n\nconst logGroupTarget = new targets.CloudWatchLogsTarget(targetLogGroup);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: logGroupTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Sharing an AppRegistry Attribute Group with Application Association Permission in TypeScript\nDESCRIPTION: Shares an AppRegistry Attribute Group with multiple AWS accounts and grants them permission to associate their applications with the shared attribute group by setting `sharePermission` to `appreg.SharePermission.ALLOW_ACCESS`. Requires an existing `appreg.AttributeGroup` instance and AWS Organizations enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const attributeGroup: appreg.AttributeGroup;\nattributeGroup.shareAttributeGroup('MyShareId', {\n  name: 'MyShare',\n  accounts: ['123456789012', '234567890123'],\n  sharePermission: appreg.SharePermission.ALLOW_ACCESS,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeStar Notifications for a CodeCommit Repository\nDESCRIPTION: Defines CodeStar notification rules for a CodeCommit repository, setting up Slack notifications for pull request creation events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codecommit/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as chatbot from 'aws-cdk-lib/aws-chatbot';\n\ndeclare const repository: codecommit.Repository;\nconst target = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\n  slackChannelConfigurationName: 'YOUR_CHANNEL_NAME',\n  slackWorkspaceId: 'YOUR_SLACK_WORKSPACE_ID',\n  slackChannelId: 'YOUR_SLACK_CHANNEL_ID',\n});\nconst rule = repository.notifyOnPullRequestCreated('NotifyOnPullRequestCreated', target);\n```\n\n----------------------------------------\n\nTITLE: Custom Options Configuration\nDESCRIPTION: Demonstrates setting custom options like maxDataSize\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nvar FormData = require('form-data');\n\nvar form = new FormData({ maxDataSize: 20971520 });\nform.append('my_field', 'my value');\nform.append('my_buffer', /* something big */);\n```\n\n----------------------------------------\n\nTITLE: Specifying EC2 AMI for Cloud9 Environment\nDESCRIPTION: Shows how to specify a custom EC2 AMI image when creating a Cloud9 environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-cloud9-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultVpc = ec2.Vpc.fromLookup(this, 'DefaultVPC', { isDefault: true });\nnew cloud9.Ec2Environment(this, 'Cloud9Env2', {\n  vpc: defaultVpc,\n  instanceType: new ec2.InstanceType('t3.large'),\n  imageId: cloud9.ImageId.UBUNTU_18_04,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS S3Express Construct Library - TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS S3Express L1 construct module from the aws-cdk-lib package. The import pattern follows standard AWS CDK module usage and is a prerequisite for defining S3Express resources in your infrastructure code. No additional parameters are needed for the import itself, but you must have aws-cdk-lib installed as a dependency. The snippet is intended to be placed at the top of your AWS CDK application files for subsequent use of S3Express constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3express/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as s3express from 'aws-cdk-lib/aws-s3express';\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Minor Version Upgrades for Neptune Cluster\nDESCRIPTION: Shows how to enable automatic minor version upgrades for a Neptune cluster, which automatically updates the engine version after a stabilization period.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nnew neptune.DatabaseCluster(this, 'Cluster', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  autoMinorVersionUpgrade: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Origin Behavior in CloudFront Distribution\nDESCRIPTION: Shows how to configure a CloudFront distribution with an S3 bucket origin using both the legacy and modern APIs. The modern version uses CloudFront Origins module for simpler configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\ndeclare const oai: cloudfront.OriginAccessIdentity;\n\nnew cloudfront.CloudFrontWebDistribution(this, 'MyCfWebDistribution', {\n  originConfigs: [\n    {\n      s3OriginSource: {\n        s3BucketSource: sourceBucket,\n        originAccessIdentity: oai,\n      },\n      behaviors : [ {isDefaultBehavior: true}],\n    },\n  ],\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceBucket: s3.Bucket;\n\nconst distribution = new cloudfront.Distribution(this, 'MyCfWebDistribution', {\n  defaultBehavior: {\n    origin: new origins.S3Origin(sourceBucket) // This class automatically creates an Origin Access Identity\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AppRegistry Attribute Group in TypeScript\nDESCRIPTION: Defines a new AWS AppRegistry Attribute Group using the AWS CDK. It specifies a unique name (immutable and unique at the account level), an optional description, and a set of user-defined attributes structured as a JSON object. Dependencies include the `appreg` module from the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst attributeGroup = new appreg.AttributeGroup(this, 'MyFirstAttributeGroup', {\n  attributeGroupName: 'MyFirstAttributeGroupName',\n  description: 'description for my attribute group', // the description is optional,\n  attributes: {\n    project: 'foo',\n    team: ['member1', 'member2', 'member3'],\n    public: false,\n    stages: {\n      alpha: 'complete',\n      beta: 'incomplete',\n      release: 'not started'\n    }\n  }\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Uploading a Custom Server Build to GameLift in TypeScript\nDESCRIPTION: This snippet demonstrates how to upload a custom server build to GameLift. It creates a Build resource using content from an S3 bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst build = new gamelift.Build(this, 'Build', {\n  content: gamelift.Content.fromBucket(bucket, \"sample-asset-key\")\n});\n\nnew CfnOutput(this, 'BuildArn', { value: build.buildArn });\nnew CfnOutput(this, 'BuildId', { value: build.buildId });\n```\n\n----------------------------------------\n\nTITLE: Token-Aware Input Validation in TypeScript\nDESCRIPTION: Example of input validation that checks for both resolved values and Tokens. Demonstrates proper error handling for CDK construct parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nif (!Token.isUnresolved(props.minCapacity) && props.minCapacity < 1) {\n  throw new Error(`'minCapacity' should be at least 1, got '${props.minCapacity}'`);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating IoT Rule to Send Messages to HTTPS Endpoints in TypeScript\nDESCRIPTION: This snippet creates an AWS IoT Rule that sends messages to an HTTPS endpoint when triggered. It shows how to set up the topic rule with SQL and add an HttpsAction with custom headers and authentication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst topicRule = new iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\n    \"SELECT topic(2) as device_id, year, month, day FROM 'device/+/data'\",\n  ),\n});\n\ntopicRule.addAction(\n  new actions.HttpsAction('https://example.com/endpoint', {\n    confirmationUrl: 'https://example.com',\n    headers: [\n      { key: 'key0', value: 'value0' },\n      { key: 'key1', value: 'value1' },\n    ],\n    auth: { serviceName: 'serviceName', signingRegion: 'us-east-1' },\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Referencing Existing AppConfig Deployment Strategy by ID using CDK in TypeScript\nDESCRIPTION: Shows how to reference an existing, externally created AWS AppConfig Deployment Strategy within a CDK application by its unique ID using the `fromDeploymentStrategyId` static method. The string 'abc123' is used as a placeholder for an actual deployment strategy ID. Assumes `this` is a CDK `Construct` and `appconfig` is the imported module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nappconfig.DeploymentStrategy.fromDeploymentStrategyId(this, 'MyImportedDeploymentStrategy', appconfig.DeploymentStrategyId.fromString('abc123'));\n```\n```\n\n----------------------------------------\n\nTITLE: Detecting Source Code Vulnerabilities with InspectorSourceCodeScanAction (TypeScript)\nDESCRIPTION: Shows how to automate vulnerability scanning of application source code using InspectorSourceCodeScanAction in AWS CodePipeline via AWS CDK TypeScript. The action consumes source output and emits scan output which can be further consumed in the pipeline. Dependencies include codepipeline, codepipeline_actions for CodeStarConnectionsSourceAction and InspectorSourceCodeScanAction; inputs require a third-party repository connection ARN, owner, and repository name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const pipeline: codepipeline.Pipeline;\n\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.CodeStarConnectionsSourceAction({\n  actionName: 'CodeStarConnectionsSourceAction',\n  output: sourceOutput,\n  connectionArn: 'your-connection-arn',\n  owner: 'your-owner',\n  repo: 'your-repo',\n});\n\nconst scanOutput = new codepipeline.Artifact();\nconst scanAction = new codepipeline_actions.InspectorSourceCodeScanAction({\n  actionName: 'InspectorSourceCodeScanAction',\n  input: sourceOutput,\n  output: scanOutput,\n});\n\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\npipeline.addStage({\n  stageName: 'Scan',\n  actions: [scanAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Kinesis Stream Source for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an Amazon Kinesis stream as the source. The configuration specifies that the pipe should start reading from the latest records in the stream, ignoring any backlog of older records.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-sources-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceStream: kinesis.Stream;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeSource = new sources.KinesisSource(sourceStream, {\n  startingPosition: sources.KinesisStartingPosition.LATEST,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: pipeSource,\n  target: new SqsTarget(targetQueue)\n});\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Docker Image for Python Lambda Bundling\nDESCRIPTION: Specifies a custom Docker image for bundling Python Lambda functions, allowing for customized environments for dependency installation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst entry = '/path/to/function';\nconst image = DockerImage.fromBuild(entry);\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: { image },\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Neptune Metrics for Monitoring\nDESCRIPTION: Shows how to access metrics for both Neptune clusters and instances to help with monitoring database performance and usage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: neptune.DatabaseCluster;\ndeclare const instance: neptune.DatabaseInstance;\n\ncluster.metric('SparqlRequestsPerSec'); // cluster-level SparqlErrors metric\ninstance.metric('SparqlRequestsPerSec') // instance-level SparqlErrors metric\n```\n\n----------------------------------------\n\nTITLE: Visualizing the AWS CDK Pull Request Workflow (Mermaid)\nDESCRIPTION: This Mermaid diagram outlines the process flow for handling incoming Pull Requests (PRs) in the AWS CDK repository. It shows decision points based on whether an issue is attached, the issue's priority (P1/P2), the PR's effort size, build status, and potential outcomes like review, requests for changes, or closure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_13\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    A[Incoming PR] -->B[Is an issue attached?]\n    B -->|Yes - labels copied from issue| C[Is it labeled P1?]\n    B -->|No - auto-labeled as P2| D[\"Is the effort small?\"]\n    C -->|Yes - P1| E[Is the PR build succeeding?]\n    C -->|No - it is P2| D\n    D -->|Yes| E\n    D -->|No| F[Can you break down the PR into smaller chunks?]\n    F --->|Yes| I[Please do. This will help get traction on your PR.]\n    F -->|No| J[Try to garner community support on the issue you are <br/> trying to solve. With 20 +1s, the issue will be relabeled as P1.]\n    E --->|Yes| G[We will review your PR as soon as we can]\n    E -->|No| H[If the build is failing for more than 4 weeks <br/> without any work on it, we will close the PR.]\n```\n\n----------------------------------------\n\nTITLE: Setting Resolver Count Limit for an AppSync API in TypeScript\nDESCRIPTION: This TypeScript CDK snippet illustrates setting a limit on the total number of resolvers that can be processed within a single GraphQL query. The `resolverCountLimit` property is set to 2, restricting queries from invoking more than two resolvers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new appsync.GraphqlApi(this, 'api', {\n  name: 'LimitResolverCount',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.schema.graphql')),\n  resolverCountLimit: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CodeArtifact Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS CodeArtifact module from the `aws-cdk-lib`. This import provides access primarily to the L1 constructs for interacting with AWS CodeArtifact resources (like Domains and Repositories) within an AWS CDK application, mirroring CloudFormation usage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codeartifact/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as codeartifact from 'aws-cdk-lib/aws-codeartifact';\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Headers to CloudFront Origin\nDESCRIPTION: Demonstrates how to add custom headers to CloudFront requests sent to the origin\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: origins.S3BucketOrigin.withOriginAccessControl(myBucket, {\n    customHeaders: {\n      Foo: 'bar',\n    },\n  })},\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Main Node for Multi-Node Job in AWS Batch\nDESCRIPTION: Demonstrates how to specify a non-default main node index for a multi-node job definition. This approach allows for designating a specific node as the control node in a distributed batch workload.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst multiNodeJob = new batch.MultiNodeJobDefinition(this, 'JobDefinition', {\n  mainNode: 5,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.R4, ec2.InstanceSize.LARGE),\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Specific Table Replica\nDESCRIPTION: Example showing how to obtain a reference to a specific replica table and grant permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\ndeclare const user: iam.User;\n\nclass FooStack extends cdk.Stack {\n  public readonly globalTable: dynamodb.TableV2;\n\n  public constructor(scope: Construct, id: string, props: cdk.StackProps) {\n    super(scope, id, props);\n\n    this.globalTable = new dynamodb.TableV2(this, 'GlobalTable', {\n      partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n      replicas: [\n        { region: 'us-east-1' },\n        { region: 'us-east-2' },\n      ],\n    });\n  }\n}\n\ninterface BarStackProps extends cdk.StackProps {\n  readonly replicaTable: dynamodb.ITableV2;\n}\n\nclass BarStack extends cdk.Stack {\n  public constructor(scope: Construct, id: string, props: BarStackProps) {\n    super(scope, id, props);\n\n    // user is given grantWriteData permissions to replica in us-east-1\n    props.replicaTable.grantWriteData(user);\n  }\n}\n\nconst app = new cdk.App();\n\nconst fooStack = new FooStack(app, 'FooStack', { env: { region: 'us-west-2' } });\nconst barStack = new BarStack(app, 'BarStack', {\n  replicaTable: fooStack.globalTable.replica('us-east-1'),\n  env: { region: 'us-east-1' },\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying AWS CDK Download Integrity\nDESCRIPTION: Commands to verify the integrity of the AWS CDK download using GPG signature verification\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngpg --import cdk-team.asc\ngpg --verify aws-cdk-x.y.z.zip.sig aws-cdk-x.y.z.zip\n```\n\n----------------------------------------\n\nTITLE: Customizing EKS Cluster Node Group Capacity\nDESCRIPTION: Creates an EKS cluster with customized node group configuration, specifying instance count and type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nnew eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.NODEGROUP,\n  defaultCapacity: 5,\n  defaultCapacityInstance: ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.SMALL),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Continuous Backup and PITR with Custom Retention - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates configuring continuous backup and point-in-time restore (PITR) on an AWS Backup plan rule using the enableContinuousBackup and deleteAfter properties in TypeScript. If PITR is enabled, moveToColdStorageAfter must not be set, and a retention (deleteAfter) is required. Requires the backup CDK module and a Duration utility. Resulting rule enforces PITR with a custom retention period of 14 days.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\nplan.addRule(new backup.BackupPlanRule({\n  enableContinuousBackup: true,\n  deleteAfter: Duration.days(14),\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket IAM Authorizer in AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to set up an IAM authorizer for a WebSocket API in AWS CDK using TypeScript. It configures a connect route using a Lambda integration, creates an IAM user, generates an ARN for the WebSocket API, and attaches an inline policy granting invoke permissions. Dependencies include the aws-cdk-lib for API Gateway, IAM constructs, and Lambda functions. Key parameters are the Lambda handler for the API route and the user to be granted permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';\nimport { WebSocketLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\n// This function handles your connect route\ndeclare const connectHandler: lambda.Function;\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'WebSocketApi');\n\nwebSocketApi.addRoute('$connect', {\n  integration: new WebSocketLambdaIntegration('Integration', connectHandler),\n  authorizer: new WebSocketIamAuthorizer()\n});\n\n// Create an IAM user (identity)\nconst user = new iam.User(this, 'User');\n\nconst webSocketArn = Stack.of(this).formatArn({\n  service: 'execute-api',\n  resource: webSocketApi.apiId,\n});\n\n// Grant access to the IAM user\nuser.attachInlinePolicy(new iam.Policy(this, 'AllowInvoke', {\n  statements: [\n    new iam.PolicyStatement({\n      actions: ['execute-api:Invoke'],\n      effect: iam.Effect.ALLOW,\n      resources: [webSocketArn],\n    }),\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Base Class for AWS CDK Resource\nDESCRIPTION: Shows the recommended pattern for implementing an abstract base class for an AWS CDK resource. This base class implements the construct interface and leaves attributes as abstract properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class FooBase extends Resource implements IFoo {\n  public abstract fooName: string;\n  public abstract fooArn: string;\n\n  // .. concrete implementation of IFoo (grants, metrics, factories),\n  // should only rely on \"fooName\" and \"fooArn\" theoretically\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating HTTP API with Private ALB using AWS CDK in TypeScript\nDESCRIPTION: Shows how to set up a private integration using `HttpAlbIntegration` to connect an HTTP API directly to an Application Load Balancer (ALB) listener within a VPC. This example creates a VPC, an ALB, a listener, and configures the listener as the default integration for the HTTP API. Requires `aws-ec2`, `aws-elasticloadbalancingv2`, `aws-apigatewayv2`, and `aws-apigatewayv2-integrations` CDK modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { HttpAlbIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\nconst vpc = new ec2.Vpc(this, 'VPC');\nconst lb = new elbv2.ApplicationLoadBalancer(this, 'lb', { vpc });\nconst listener = lb.addListener('listener', { port: 80 });\nlistener.addTargets('target', {\n  port: 80,\n});\n\nconst httpEndpoint = new apigwv2.HttpApi(this, 'HttpProxyPrivateApi', {\n  defaultIntegration: new HttpAlbIntegration('DefaultIntegration', listener),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Construct Annotations in TypeScript\nDESCRIPTION: Example demonstrating how to add deployment-time error annotations to a construct using the Annotations class. Shows proper subnet validation with error messaging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nif (!Token.isUnresolved(subnetIds) && subnetIds.length < 2) {\n  Annotations.of(this).addError(`Need at least 2 subnet ids, got: ${JSON.stringify(subnetIds)}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying and Diffing CDK Application - Shell Commands\nDESCRIPTION: These commands use the AWS CDK CLI to show differences (diff) and deploy a test application. They must be run with properly configured AWS credentials, and require the cdk CLI and all dependencies installed. They expect a valid, compiled JavaScript app as input and output either a diff summary or a deployment result.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_20\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/@aws-cdk-testing/framework-integ\n$ npx cdk -a test/aws-eks/test/sample.js diff\n$ npx cdk -a test/aws-eks/test/sample.js deploy\n```\n\n----------------------------------------\n\nTITLE: Creating a CodeDeploy Application for EC2/on-premise instances in TypeScript\nDESCRIPTION: Creates a new CodeDeploy Application that deploys to EC2 or on-premise instances with an optional application name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst application = new codedeploy.ServerApplication(this, 'CodeDeployApplication', {\n  applicationName: 'MyApplication', // optional property\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AccessAnalyzer Module in TypeScript CDK\nDESCRIPTION: This snippet demonstrates how to import the AWS AccessAnalyzer L1 construct library module (`aws-cdk-lib/aws-accessanalyzer`) into a TypeScript AWS CDK application. This import makes the L1 constructs, which correspond directly to AWS AccessAnalyzer CloudFormation resources, available for use within the CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-accessanalyzer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as accessanalyzer from 'aws-cdk-lib/aws-accessanalyzer';\n```\n\n----------------------------------------\n\nTITLE: Creating a Redshift User in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a user within a Redshift cluster database using the User construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew User(this, 'User', {\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkFlexEtlJob with Required Parameters in TypeScript\nDESCRIPTION: Example showing how to create a PySparkFlexEtlJob with only the required parameters. Flex jobs are designed for non-urgent jobs like pre-production jobs, testing, and one-time data loads.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkFlexEtlJob(stack, 'ImportedJob', { role, script });\n```\n\n----------------------------------------\n\nTITLE: Running pkglint on Whole Repo - Console Command - Bash\nDESCRIPTION: This command executes 'lerna run pkglint' from the repo root to lint all package.json files according to pkglint rules, attempting automatic fixes where applicable. Dependencies: lerna and pkglint should be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\n$ lerna run pkglint\n```\n\n----------------------------------------\n\nTITLE: Registering Policy Validation Plugins with AWS CDK App or Stage - TypeScript\nDESCRIPTION: Shows how to enable policy validation by registering plugins that implement IPolicyValidationPluginBeta1 at the App or Stage level using the policyValidationBeta1 property. This ensures all synthesized CloudFormation templates are validated post-synthesis, and different scopes (entire app or specific stage) can have different plugins. Assumes available validation plugin classes and dependency on aws-cdk-lib.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\n// globally for the entire app (an app is a stage)\nconst app = new App({\n  policyValidationBeta1: [\n    // These hypothetical classes implement IPolicyValidationPluginBeta1:\n    new ThirdPartyPluginX(),\n    new ThirdPartyPluginY(),\n  ],\n});\n\n// only apply to a particular stage\nconst prodStage = new Stage(app, 'ProdStage', {\n  policyValidationBeta1: [\n    new ThirdPartyPluginX(),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Page Application Redirects in TypeScript\nDESCRIPTION: Creates a standard SPA (Single Page Application) redirect rule that forwards all requests to index.html except for specific file types. This pattern is commonly used for React, Vue, or Angular applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mySinglePageApp: amplify.App;\n\nmySinglePageApp.addCustomRule(amplify.CustomRule.SINGLE_PAGE_APPLICATION_REDIRECT);\n```\n\n----------------------------------------\n\nTITLE: Adding an AlarmWidget to AWS CloudWatch Dashboard (TypeScript)\nDESCRIPTION: Shows how to display the state of a single CloudWatch Alarm by adding an AlarmWidget to the dashboard. Depends on Dashboard and Alarm constructs from aws-cdk-lib/aws-cloudwatch. The alarm property references the specific alarm object to visualize.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const errorAlarm: cloudwatch.Alarm;\n\ndashboard.addWidgets(new cloudwatch.AlarmWidget({\n  title: \"Errors\",\n  alarm: errorAlarm,\n}));\n```\n\n----------------------------------------\n\nTITLE: Extracting Public Key from Private Key using OpenSSL (Bash)\nDESCRIPTION: Uses the OpenSSL command-line tool to extract the public key from an existing RSA private key file (`private_key.pem`). The extracted public key is saved to a file named `public_key.pem`. The content of this output file is used in the AWS CDK `PublicKey` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nopenssl rsa -pubout -in private_key.pem -out public_key.pem\n```\n\n----------------------------------------\n\nTITLE: Defining ScheduledEc2TaskProps Interface in TypeScript\nDESCRIPTION: This code snippet defines the ScheduledEc2TaskProps interface, which contains properties necessary for constructing the Ec2TaskDefinition, Ec2EventRuleTarget, and EventRule. It includes options for specifying the cluster, container image, schedule expression, and various container configuration parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-scheduled-ecs-task-construct.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ScheduledEc2TaskProps {\n  readonly cluster: ICluster;\n  readonly image: ContainerImage;\n  readonly scheduleExpression: string;\n  readonly command?: string;\n  readonly cpu?: number;\n  readonly desiredTaskCount?: number;\n  readonly environment?: { [key: string]: string };\n  readonly memoryLimitMiB?: number;\n  readonly memoryReservationMiB?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Function with Deploy-Time Assets in TypeScript\nDESCRIPTION: Demonstrates how to create a Lambda function with code assets that are marked as deploy-time assets by default, meaning they're only needed during deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const stack: Stack;\nnew lambda.Function(stack, 'lambda', {\n  code: lambda.AssetCode.fromAsset(path.join(__dirname, 'assets')), // lambda marks deployTime = true\n  handler: 'index.handler',\n  runtime: lambda.Runtime.PYTHON_3_9,\n});\n```\n\n----------------------------------------\n\nTITLE: Associating an Existing Attribute Group with an AppRegistry Application in TypeScript\nDESCRIPTION: Associates a pre-existing or separately defined AppRegistry Attribute Group with an existing AppRegistry Application using the `associateWith` method on the attribute group object. Requires existing instances of both `appreg.Application` (`application`) and `appreg.AttributeGroup` (`attributeGroup`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appreg.Application;\ndeclare const attributeGroup: appreg.AttributeGroup;\nattributeGroup.associateWith(application);\n```\n```\n\n----------------------------------------\n\nTITLE: Lambda Function for Enrichment in TypeScript\nDESCRIPTION: Provides an example of a Lambda function that concatenates the static field, dynamic field, and pipe variable for enrichment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function handler (event: any) {\n  return event.staticField + \"-\" + event.dynamicField + \"-\" + event.pipeVariable;\n};\n```\n\n----------------------------------------\n\nTITLE: Granting Authorization Token Read Access\nDESCRIPTION: Grants an IAM user permission to read ECR authorization tokens for Docker authentication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = new iam.User(this, 'User');\necr.AuthorizationToken.grantRead(user);\n```\n\n----------------------------------------\n\nTITLE: Creating an API Gateway REST API Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an API Gateway REST API as the target. The pipe will send events from an SQS queue source to the REST API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\n\nconst fn = new lambda.Function( this, 'MyFunc', {\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  code: lambda.Code.fromInline( 'exports.handler = e => {}' ),\n});\n\nconst restApi = new api.LambdaRestApi( this, 'MyRestAPI', { handler: fn } );\nconst apiTarget = new targets.ApiGatewayTarget(restApi);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: apiTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Lazified JavaScript with explicit getters for exports\nDESCRIPTION: The transformed JavaScript code that replaces wildcard exports with explicit getters for each exported symbol. This allows lazy loading of the module only when a specific export is accessed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/lazify/README.md#2025-04-23_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nObject.defineProperty(exports, \"foo\", { get: () => require(\"./my-module\").foo });\nObject.defineProperty(exports, \"bar\", { get: () => require(\"./my-module\").bar });\nObject.defineProperty(exports, \"baz\", { get: () => require(\"./my-module\").baz });\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Lex module in TypeScript\nDESCRIPTION: Simple import statement for accessing the AWS Lex module in the AWS CDK. This is the basic starting point for working with Lex resources in a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lex/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lex from 'aws-cdk-lib/aws-lex';\n```\n\n----------------------------------------\n\nTITLE: Importing Elastic Beanstalk Module in TypeScript\nDESCRIPTION: Example of importing the AWS Elastic Beanstalk module from aws-cdk-lib for use in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticbeanstalk/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elasticbeanstalk from 'aws-cdk-lib/aws-elasticbeanstalk';\n```\n\n----------------------------------------\n\nTITLE: Importing SimSpaceWeaver Module with AWS CDK Using TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS SimSpaceWeaver construct library from the aws-cdk-lib package in a TypeScript file. This import is a prerequisite for utilizing SimSpaceWeaver resources and constructs in CDK applications, allowing users to interact with any available L1 resource constructs. The key parameter is the package path 'aws-cdk-lib/aws-simspaceweaver', and it assumes that AWS CDK v2 is installed as a dependency. The input is a TypeScript source file and the output is enabling access to SimSpaceWeaver constructs; there are no functional limitations, but no L2 constructs are currently available for this service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-simspaceweaver/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as simspaceweaver from 'aws-cdk-lib/aws-simspaceweaver';\n```\n\n----------------------------------------\n\nTITLE: Creating GitHub Repository with S3 Content Import using AWS CodeStar\nDESCRIPTION: Demonstrates how to create a new GitHub repository and populate it with contents from an S3 bucket using AWS CodeStar. Requires a GitHub access token stored in AWS Secrets Manager and an existing S3 bucket containing the repository contents.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-codestar-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codestar from '@aws-cdk/aws-codestar-alpha';\nimport * as s3 from 'aws-cdk-lib/aws-s3'\n\nnew codestar.GitHubRepository(this, 'GitHubRepo', {\n  owner: 'aws',\n  repositoryName: 'aws-cdk',\n  accessToken: SecretValue.secretsManager('my-github-token', {\n    jsonField: 'token',\n  }),\n  contentsBucket: s3.Bucket.fromBucketName(this, 'Bucket', 'amzn-s3-demo-bucket'),\n  contentsKey: 'import.zip',\n});\n```\n\n----------------------------------------\n\nTITLE: Proposed CDK Tagging API Usage in TypeScript\nDESCRIPTION: Proposed new tagging API that simplifies tag application and removal by using static methods on the Tag class, eliminating the need to expose 'node' to users.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/tagging-API-change.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nTag.add(myConstruct, 'key', 'value');\n\nTag.remove(myConstruct, 'key');\n```\n\n----------------------------------------\n\nTITLE: Invoking AWS Lambda in CodePipeline Stage with AWS CDK (TypeScript)\nDESCRIPTION: Illustrates the addition of a LambdaInvokeAction to a CodePipeline stage in AWS CDK (TypeScript). The snippet declares a Lambda function, configures the pipeline, and creates a LambdaInvokeAction, showing typical usage for invoking a Lambda within a pipeline stage. The key inputs are the Lambda function and action name; the output is a configured pipeline with Lambda integration. Requires aws-cdk-lib, codepipeline, and lambda modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const fn: lambda.Function;\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst lambdaAction = new codepipeline_actions.LambdaInvokeAction({\n  actionName: 'Lambda',\n  lambda: fn,\n});\npipeline.addStage({\n  stageName: 'Lambda',\n  actions: [lambdaAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Working with Blue-Green Deployment Hooks in CDK\nDESCRIPTION: Shows how to access and modify CloudFormation hooks for blue-green deployments through CfnInclude. This enables customizing deployment configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst hook: core.CfnHook = cfnTemplate.getHook('MyOutput');\n\n// mutating the hook\ndeclare const myRole: iam.Role;\nconst codeDeployHook = hook as core.CfnCodeDeployBlueGreenHook;\ncodeDeployHook.serviceRole = myRole.roleArn;\n```\n\n----------------------------------------\n\nTITLE: Configuring S3-Managed Encryption for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet shows how to configure server-side encryption with S3-managed keys (SSE-S3) for the data associated with an AWS Glue S3 Table using AWS CDK. This is achieved by setting the `encryption` property to `glue.TableEncryption.S3_MANAGED`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.S3_MANAGED,\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a One-time Schedule (AWS CDK, TypeScript)\nDESCRIPTION: Shows how to configure a one-time EventBridge Scheduler that runs a task at a specific date, time, and timezone using AWS CDK. Uses ScheduleExpression.at to specify the occurrence. Inputs are the desired Date object and timezone; output is a single scheduled invocation. Dependencies include Schedule, ScheduleExpression, LambdaInvoke, and TimeZone.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const target: targets.LambdaInvoke;\n\nconst oneTimeSchedule = new Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.at(\n        new Date(2022, 10, 20, 19, 20, 23),\n        TimeZone.AMERICA_NEW_YORK,\n    ),\n    target,\n    description: 'This is a one-time schedule in New York timezone',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Lambda Function Integration Test in TypeScript\nDESCRIPTION: Example of creating a basic integration test for a Lambda function using CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\nconst stack = new Stack();\nnew lambda.Function(stack, 'MyFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Go Module Proxies\nDESCRIPTION: Demonstrates how to configure Go module proxies for dependency resolution during the build process. This example configures the function to use Google's proxy server with a direct fallback.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'GoFunction', {\n  entry: 'app/cmd/api',\n  bundling: {\n    goProxies: [go.GoFunction.GOOGLE_GOPROXY, 'direct'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding DynamoDB Gateway VPC Endpoint Route with AWS CDK (TypeScript)\nDESCRIPTION: Shows how to create a DynamoDB Gateway VPC Endpoint (`ec2.GatewayVpcEndpoint`) within a `VpcV2` and associated subnets. It then adds a route (using `0.0.0.0/0` destination for simplicity, though typically a more specific prefix list is used for endpoints) to a `RouteTable` targeting this endpoint via the `Route` construct, allowing resources in the VPC to access DynamoDB without traversing the public internet. Dependencies include `@aws-cdk/core` (for Stack) and `@aws-cdk/aws-ec2`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PRIVATE });\n\nconst dynamoEndpoint = new ec2.GatewayVpcEndpoint(this, 'DynamoEndpoint', {\n  service: ec2.GatewayVpcEndpointAwsService.DYNAMODB,\n  vpc: myVpc,\n  subnets: [subnet],\n});\nnew Route(this, 'DynamoDBRoute', {\n  routeTable,\n  destination: '0.0.0.0/0',\n  target: { endpoint: dynamoEndpoint },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing DynamoDB Table Data from S3 in CSV Format Using AWS CDK - TypeScript\nDESCRIPTION: Provides an example for importing initial data into a DynamoDB table from S3 in CSV format during resource creation using AWS CDK in TypeScript. Demonstrates use of the 'importSource' property with gzip compression, configurable CSV delimiter, and an explicit header list. Inputs required are an S3 bucket reference, partition key schema, and S3 object prefix. Outputs are a DynamoDB table resource set up for import upon creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack');\n\ndeclare const bucket: s3.IBucket;\n\nnew dynamodb.Table(stack, 'Table', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n  importSource: {\n    compressionType: dynamodb.InputCompressionType.GZIP,\n    inputFormat: dynamodb.InputFormat.csv({\n      delimiter: ',',\n      headerList: ['id', 'name'],\n    }),\n    bucket,\n    keyPrefix: 'prefix',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS WAF Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS WAF module from the AWS CDK library (`aws-cdk-lib`). This import is necessary to interact with AWS WAF resources, typically using the lower-level (L1) constructs within a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-waf/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as waf from 'aws-cdk-lib/aws-waf';\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Volume Copy for Python Lambda Function\nDESCRIPTION: Demonstrates how to configure Python Lambda function bundling to use volume copy instead of bind mounts for Docker-in-Docker or remote Docker socket scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst entry = '/path/to/function';\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing S3 Bucket by Attributes in TypeScript\nDESCRIPTION: This snippet shows how to import an existing S3 bucket into your AWS CDK application using its attributes (name and region). This is useful when referencing a bucket created outside the current stack, potentially in a different region, for use in CodePipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst sourceBucket = s3.Bucket.fromBucketAttributes(this, 'SourceBucket', {\n  bucketName: 'amzn-s3-demo-bucket',\n  region: 'ap-southeast-1',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Providing Nested Values to Helm Charts in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates passing nested configuration values to a Helm chart using the `values` property in `cluster.addHelmChart`. A nested JavaScript object is used to structure the values, which are then passed to the Helm deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n\ncluster.addHelmChart('ExternalSecretsOperator', {\n  chart: 'external-secrets',\n  release: 'external-secrets',\n  repository: 'https://charts.external-secrets.io',\n  namespace: 'external-secrets',\n  values: {\n    installCRDs: true,\n    webhook: {\n      port: 9443\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing Jenkins Provider in AWS CodePipeline\nDESCRIPTION: Imports a Jenkins provider that was registered in a different CDK app or through the AWS Console. This allows referencing an existing Jenkins integration without creating a new one.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst jenkinsProvider = codepipeline_actions.JenkinsProvider.fromJenkinsProviderAttributes(this, 'JenkinsProvider', {\n  providerName: 'MyJenkinsProvider',\n  serverUrl: 'http://my-jenkins.com:8080',\n  version: '2', // optional, default: '1'\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Cache Settings in Amplify App in TypeScript\nDESCRIPTION: Sets custom caching configuration for an Amplify application by controlling how cookies affect the cache key. This example demonstrates setting the cache config type to exclude all cookies from the cache key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-amplify-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst amplifyApp = new amplify.App(this, 'MyApp', {\n  cacheConfigType: amplify.CacheConfigType.AMPLIFY_MANAGED_NO_COOKIES,\n});\n```\n\n----------------------------------------\n\nTITLE: Example Go Project Directory Structure\nDESCRIPTION: Shows an example directory structure for a Go Lambda function project. This illustrates where the main.go file, modules, and dependencies would typically be located.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nlambda-app\n cmd\n    api\n        main.go\n go.mod\n go.sum\n pkg\n    auth\n       auth.go\n    middleware\n        middleware.go\n vendor\n     github.com\n        aws\n            aws-lambda-go\n     modules.txt\n```\n\n----------------------------------------\n\nTITLE: Integration Test API Call\nDESCRIPTION: Shows how to use awsApiCall method with DeployAssert for integration testing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst integ = new IntegTest(app, 'Integ', {\n  testCases: [stack],\n});\ninteg.assertions.awsApiCall('SQS', 'receiveMessage', {\n  QueueUrl: 'url',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS App Mesh Resources by ARN in CDK\nDESCRIPTION: Shows how to import existing AWS App Mesh resources using their ARN. This example imports a virtual node and a mesh.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst arn = 'arn:aws:appmesh:us-east-1:123456789012:mesh/testMesh/virtualNode/testNode';\nappmesh.VirtualNode.fromVirtualNodeArn(this, 'importedVirtualNode', arn);\n\nconst meshArn = 'arn:aws:appmesh:us-east-1:123456789012:mesh/testMesh';\nappmesh.Mesh.fromMeshArn(this, 'imported-mesh', meshArn);\n```\n\n----------------------------------------\n\nTITLE: Configuring Password Generation for Redshift Cluster in TypeScript\nDESCRIPTION: This snippet shows how to configure password generation for a Redshift cluster by specifying characters to exclude from the generated password.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\nconst vpc = new ec2.Vpc(this, 'Vpc');\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n    excludeCharacters: '\"@/\\\\ \\'`',\n  },\n  vpc\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS HealthImaging Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS HealthImaging module from the `aws-cdk-lib`. This import makes the L1 constructs for AWS HealthImaging available under the `healthimaging` namespace, allowing interaction with HealthImaging resources as defined in CloudFormation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-healthimaging/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as healthimaging from 'aws-cdk-lib/aws-healthimaging';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SAM L1 Constructs in AWS CDK with TypeScript\nDESCRIPTION: This TypeScript code imports the necessary module (`aws-sam`) from the AWS CDK library (`aws-cdk-lib`) to work with AWS Serverless Application Model (SAM) resources. It assigns the imported module to the `serverless` alias. This is required to use the low-level L1 constructs, which map directly to CloudFormation `AWS::Serverless` resources, as higher-level L2 constructs are not currently provided by the official library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sam/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as serverless from 'aws-cdk-lib/aws-sam';\n```\n\n----------------------------------------\n\nTITLE: Example AWS CDK Construct Tree JSON Structure\nDESCRIPTION: Sample tree.json output showing a stack with two resources (a custom resource and an SNS topic) and their respective metadata attributes following AWS CDK conventions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/construct-tree.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": \"tree-0.1\",\n  \"tree\": {\n    \"id\": \"App\",\n    \"path\": \"\",\n    \"children\": {\n      \"Tree\": {\n        \"path\": \"Tree\"\n      },\n      \"mystack\": {\n        \"path\": \"mystack\",\n        \"children\": {\n          \"mycfnresource\": {\n            \"path\": \"mystack/mycfnresource\",\n            \"attributes\": {\n              \"aws:cdk:props\": {\n                \"mystringpropkey\": \"mystringpropval\",\n                \"mylistpropkey\": [\n                  \"listitem1\"\n                ],\n                \"mystructpropkey\": {\n                  \"myboolpropkey\": true,\n                  \"mynumpropkey\": 50\n                }\n              }\n            }\n          },\n          \"mytopic\": {\n            \"path\": \"mystack/mytopic\",\n            \"attributes\": {\n              \"aws:cdk:cloudformation:type\": \"AWS::SNS::Topic\",\n              \"aws:cdk:cloudformation:properties\": {\n                \"DisplayName\": \"MyTopic\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Amazon FSx for Lustre File System Type Version in TypeScript\nDESCRIPTION: This snippet demonstrates how to specify the Lustre version using the fileSystemTypeVersion property when creating a Lustre file system. Dependencies include an existing VPC and the FSx library. Accepts Lustre deployment type, storage size, VPC/subnet, and the desired file system version as inputs. Outputs a version-specific FSx Lustre file system. Ensure that the selected version is compatible with the requested deployment type as per FSx documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nconst fileSystem = new fsx.LustreFileSystem(this, 'FsxLustreFileSystem', {\nlustreConfiguration: { deploymentType: fsx.LustreDeploymentType.SCRATCH_2 },\n  storageCapacityGiB: 1200,\n  vpc,\n  vpcSubnet: vpc.privateSubnets[0],\n  fileSystemTypeVersion: fsx.FileSystemTypeVersion.V_2_15,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing New AWS CDK Assertions Module (TypeScript)\nDESCRIPTION: Shows the new way of importing components for CDK testing using the `@aws-cdk/assertions` module. It imports the `Template` class for interacting with the synthesized stack template and the `Match` class for using matchers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Template } from '@aws-cdk/assertions';\nimport { Match, Template } from '@aws-cdk/assertions';\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific CloudFormation Output in TypeScript\nDESCRIPTION: Shows how to use `hasOutput()` to assert that the CloudFormation template contains an Output with a specific logical ID and matching properties (like `Value` or `Export`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst expected = {\n  Value: 'Bar',\n  Export: { Name: 'ExportBaz' },\n};\ntemplate.hasOutput('Foo', expected);\n```\n```\n\n----------------------------------------\n\nTITLE: Deploying Application with Metrics Sidecar\nDESCRIPTION: Creates a Fargate service with an application container and metrics sidecar, using docker labels for service discovery.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\ndeclare const vpc: ec2.Vpc;\nconst service = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {\n  cluster,\n  vpc,\n  desiredCount: 1,\n  minHealthyPercent: 100,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n    dockerLabels: {\n      'application.label.one': 'first_label',\n      'application.label.two': 'second_label',\n    },\n  },\n});\n\nservice.taskDefinition.addContainer('Sidecar', {\n  image: ecs.ContainerImage.fromRegistry('example/metrics-sidecar'),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkEtlJob with Required Parameters in TypeScript\nDESCRIPTION: Example showing how to create a PySparkEtlJob with only the required parameters including role, script and job name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkEtlJob(stack, 'PySparkETLJob', {\n  role,\n  script,\n  jobName: 'PySparkETLJob',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Forecast Construct Library - TypeScript\nDESCRIPTION: This snippet shows how to import the AWS Forecast construct library from the aws-cdk-lib in a TypeScript project. The forecast module provides access to L1 constructs for AWS Forecast, enabling users to define AWS Forecast resources in their CDK stacks. No additional dependencies beyond aws-cdk-lib are required, and this import supports further usage of AWS Forecast CloudFormation resources via CDK. The import does not include any resource instantiations or definitions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-forecast/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as forecast from 'aws-cdk-lib/aws-forecast';\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum TLS Protocol Version for CloudFront Distribution using TypeScript\nDESCRIPTION: Demonstrates customizing the minimum TLS protocol version for a CloudFront `Distribution` when using a custom domain name. This example sets the `minimumProtocolVersion` to `TLS_V1_2016` and specifies the `sslSupportMethod` as SNI-only. Requires an ACM certificate and associated domain names configured for the distribution. Assumes an existing S3 bucket (`myBucket`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// Create a Distribution with a custom domain name and a minimum protocol version.\ndeclare const myBucket: s3.Bucket;\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: new origins.S3Origin(myBucket) },\n  domainNames: ['www.example.com'],\n  minimumProtocolVersion: cloudfront.SecurityPolicyProtocol.TLS_V1_2016,\n  sslSupportMethod: cloudfront.SSLMethod.SNI,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Post CLI Context via App Constructor - TypeScript\nDESCRIPTION: Illustrates setting context values specifically intended to override CLI-provided context via the postCliContext property in the AWS CDK App constructor. Useful for enforcing or testing settings independent of command-line flags, this requires aws-cdk-lib and correct keys/values as per desired feature flags.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nnew App({\n  postCliContext: {\n    '@aws-cdk/core:newStyleStackSynthesis': true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Original JavaScript with eager require()\nDESCRIPTION: An example showing the original JavaScript code with eager loading of a module. This code loads my-module immediately at startup regardless of whether its functionality is used.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/lazify/README.md#2025-04-23_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst my_module_1 = require('./my-module');\n\nfunction hello() {\n  return my_module_1.hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Resource from an Included Template in CDK (TypeScript)\nDESCRIPTION: Illustrates how to access a specific resource (identified by its logical ID 'Bucket' from the original template) from a `CfnInclude` instance using the `getResource` method. The result is cast to the corresponding L1 construct type (`s3.CfnBucket`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\n// cfnBucket is of type s3.CfnBucket\n```\n\n----------------------------------------\n\nTITLE: Creating a Private IVS Channel\nDESCRIPTION: Creates a private IVS channel that requires playback authorization. Private channels restrict access to streams by channel or viewer.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst myChannel = new ivs.Channel(this, 'Channel', {\n  authorized: true, // default value is false\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Pipes Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Pipes module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pipes/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pipes from 'aws-cdk-lib/aws-pipes';\n```\n\n----------------------------------------\n\nTITLE: Defining `addToRolePolicy` Method in AWS CDK TypeScript\nDESCRIPTION: Defines the required `addToRolePolicy` method signature on the construct interface (`IFoo`). This method accepts an `iam.PolicyStatement` and allows adding permissions to the IAM role associated with the resource. Implementations should handle cases where the resource is imported (unowned) by potentially issuing a notice instead of modifying a policy.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface IFoo {\n  addToRolePolicy(statement: iam.Statement): void;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Import Method (`fromArn`) in AWS CDK TypeScript\nDESCRIPTION: Provides an example implementation for a static `fromArn` method within a resource construct class (`Foo`). It utilizes an inner class `_Foo` that extends a base class (`FooBase`) to create an instance representing the imported resource. This pattern encapsulates the import logic and demonstrates deriving other resource attributes (like `fooName`) from the provided ARN using `this.node.stack.parseArn`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n<!-- markdownlint-disable MD013 -->\n```ts\nclass Foo {\n  static fromArn(scope: Construct, fooArn: string): IFoo {\n    class _Foo extends FooBase {\n      public get fooArn() { return fooArn; }\n      public get fooName() { return this.node.stack.parseArn(fooArn).resourceName; }\n    }\n\n    return new _Foo(scope, fooArn);\n  }\n}\n```\n<!-- markdownlint-enable MD013 -->\n```\n\n----------------------------------------\n\nTITLE: AWS Batch Job Queue Status Example\nDESCRIPTION: Illustrates a job queue scenario with two jobs and their vCPU requirements, demonstrating how BEST_FIT allocation works.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_26\n\nLANGUAGE: plaintext\nCODE:\n```\nJob Queue:\n---------\n| A | B |\n---------\n\nJob Requirements:\nA => 4 vCPU - ALLOCATED TO m5.xlarge\nB => 2 vCPU - WAITING\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Client Authentication for MSK in TypeScript\nDESCRIPTION: This snippet shows how to enable client authentication with TLS for an MSK Cluster, using an ACM Private Certificate Authority.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acmpca from 'aws-cdk-lib/aws-acmpca';\n\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'Cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n  encryptionInTransit: {\n    clientBroker: msk.ClientBrokerEncryption.TLS,\n  },\n  clientAuthentication: msk.ClientAuthentication.tls({\n    certificateAuthorities: [\n      acmpca.CertificateAuthority.fromCertificateAuthorityArn(\n        this,\n        'CertificateAuthority',\n        'arn:aws:acm-pca:us-west-2:1234567890:certificate-authority/11111111-1111-1111-1111-111111111111',\n      ),\n    ],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Project Visibility in CodeBuild Project\nDESCRIPTION: Shows how to configure the visibility settings for project builds, controlling whether builds are publicly readable or private.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  visibility: codebuild.ProjectVisibility.PUBLIC_READ,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Table Class for DynamoDB in TypeScript\nDESCRIPTION: This snippet demonstrates how to set the table class to STANDARD_INFREQUENT_ACCESS for a DynamoDB table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  tableClass: dynamodb.TableClass.STANDARD_INFREQUENT_ACCESS,\n});\n```\n\n----------------------------------------\n\nTITLE: Exclude Node_modules for JetBrains IDEs - Node Script - Bash\nDESCRIPTION: This command uses Node.js to execute a helper script that removes or excludes nested node_modules directories, preventing IDE crashes due to symlinked dependencies. Used when developing within JetBrains IDEs like WebStorm or IntelliJ on large monorepos.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\nnode ./scripts/jetbrains-remove-node-modules.js\n```\n\n----------------------------------------\n\nTITLE: Importing DLM Module in TypeScript\nDESCRIPTION: Example of importing the AWS CDK DLM module in a TypeScript application. This import statement provides access to the L1 constructs for working with Amazon Data Lifecycle Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dlm/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dlm from 'aws-cdk-lib/aws-dlm';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS APS Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code imports the `aws-aps` module from the `aws-cdk-lib` library. This import statement makes the AWS::APS L1 constructs available for use within an AWS CDK application, allowing developers to define Amazon Managed Service for Prometheus resources programmatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-aps/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as aps from 'aws-cdk-lib/aws-aps';\n```\n\n----------------------------------------\n\nTITLE: Importing LookoutEquipment Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the LookoutEquipment module from the aws-cdk-lib package in a TypeScript project. This import allows access to LookoutEquipment constructs and resources in your CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lookoutequipment/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lookoutequipment from 'aws-cdk-lib/aws-lookoutequipment';\n```\n\n----------------------------------------\n\nTITLE: Creating a Single Container Model in Amazon SageMaker with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a single-container model in Amazon SageMaker using the CDK. It shows how to specify the container image and model data from local assets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\nimport * as path from 'path';\n\nconst image = sagemaker.ContainerImage.fromAsset(path.join('path', 'to', 'Dockerfile', 'directory'));\nconst modelData = sagemaker.ModelData.fromAsset(path.join('path', 'to', 'artifact', 'file.tar.gz'));\n\nconst model = new sagemaker.Model(this, 'PrimaryContainerModel', {\n  containers: [\n    {\n      image: image,\n      modelData: modelData,\n    }\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: EventBridge Response Mapping Template\nDESCRIPTION: Simple Velocity template for converting EventBridge PutEvents result to JSON response.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_7\n\nLANGUAGE: velocity\nCODE:\n```\n$util.toJson($ctx.result)'\n```\n\n----------------------------------------\n\nTITLE: Referencing Action Variables in CodePipeline Stages - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates the direct use of action-level variables emitted by a CodePipeline action in a subsequent action, such as using a source action's versionId in a deploy action. Requires '@aws-cdk/aws-codepipeline' and '@aws-cdk/aws-codepipeline-actions'. Shows integration into the pipeline's stages and actions. Key parameters include artifact wiring and referencing variables in configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.S3SourceAction;\ndeclare const sourceOutput: codepipeline.Artifact;\ndeclare const deployBucket: s3.Bucket;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Deploy',\n      actions: [\n        new codepipeline_actions.S3DeployAction({\n          actionName: 'DeployAction',\n          // can reference the variables\n          objectKey: `${sourceAction.variables.versionId}.txt`,\n          input: sourceOutput,\n          bucket: deployBucket,\n        }),\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Uploading a Realtime Server Script from S3 with GameLift in TypeScript\nDESCRIPTION: Creates a GameLift Script resource that references content stored in an S3 bucket. This script will be deployed to Realtime Servers fleets and placed in the /local/game directory on each instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nnew gamelift.Script(this, 'Script', {\n  content: gamelift.Content.fromBucket(bucket, \"sample-asset-key\")\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Glue Table Parameters in TypeScript\nDESCRIPTION: This snippet shows how to add user-defined key-value pair properties to an AWS Glue S3 Table using the `parameters` property within the AWS CDK definition. These parameters are stored as metadata with the table definition in the Glue Data Catalog.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  parameters: {\n    key1: 'val1',\n    key2: 'val2',\n  },\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Password Generation for Redshift User in TypeScript\nDESCRIPTION: This snippet shows how to configure password generation for a Redshift user by specifying characters to exclude from the generated password.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew User(this, 'User', {\n  cluster: cluster,\n  databaseName: 'databaseName',\n  excludeCharacters: '\"@/\\\\ \\'`',\n});\n```\n\n----------------------------------------\n\nTITLE: Updating S3 and ECR Asset Configurations\nDESCRIPTION: Replace deprecated sourceHash with assetHash for Assets and DockerImageAssets. Use httpUrl instead of s3Url for S3 Assets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nasset.sourceHash\nasset.s3Url\n\n// New\nasset.assetHash\nasset.httpUrl\n\n// For DockerImageAsset\n// Old\nimage.sourceHash\n// New\nimage.assetHash\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Disabled Cache\nDESCRIPTION: Creates a Docker image asset with caching disabled for the build process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  cacheDisabled: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Importing AWS VerifiedPermissions Module in AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the aws-verifiedpermissions module from aws-cdk-lib into a TypeScript project. This import enables access to L1 constructs for AWS VerifiedPermissions resources within AWS CDK applications. No additional dependencies are required beyond the AWS CDK libraries, and this pattern is standard for leveraging AWS service modules in CDK. The import does not accept parameters and does not produce direct output; it is intended for initializing use of VerifiedPermissions resources in your CDK infrastructure code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-verifiedpermissions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as verifiedpermissions from 'aws-cdk-lib/aws-verifiedpermissions';\n```\n\n----------------------------------------\n\nTITLE: Starting an AWS Step Functions State Machine with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to trigger an AWS Step Functions state machine execution using EventBridge Scheduler via the AWS CDK. It defines a simple state machine consisting of a single `CallAwsService` task to put a parameter into SSM. It then configures a `StepFunctionsStartExecution` target with custom input payload and creates a schedule to run it every hour.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sfn from 'aws-cdk-lib/aws-stepfunctions';\nimport * as tasks from 'aws-cdk-lib/aws-stepfunctions-tasks';\n\nconst payload = {\n  Name: \"MyParameter\",\n  Value: '',\n};\n\nconst putParameterStep = new tasks.CallAwsService(this, 'PutParameter', {\n  service: 'ssm',\n  action: 'putParameter',\n  iamResources: ['*'],\n  parameters: {\n    \"Name.$\": '$.Name',\n    \"Value.$\": '$.Value',\n    Type: 'String',\n    Overwrite: true,\n  },\n});\n\nconst stateMachine = new sfn.StateMachine(this, 'StateMachine', {\n  definitionBody: sfn.DefinitionBody.fromChainable(putParameterStep)\n});\n\nnew Schedule(this, 'Schedule', {\n  schedule: ScheduleExpression.rate(Duration.hours(1)),\n  target: new targets.StepFunctionsStartExecution(stateMachine, {\n    input: ScheduleTargetInput.fromObject(payload),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Cross-Region References Feature in CDK Stack (TypeScript)\nDESCRIPTION: Demonstrates how to enable the proposed cross-region reference mechanism for a specific CDK stack. The `crossRegionReferences` property is set to `true` in the stack's properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew Stack(app, 'MyStack', {\n  crossRegionReferences: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Deletion Protection for DocumentDB\nDESCRIPTION: Demonstrates how to enable deletion protection on a DocumentDB cluster to prevent accidental deletion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new docdb.DatabaseCluster(this, 'Database', {\n  masterUser: {\n    username: 'myuser',\n  },\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n  vpcSubnets: {\n    subnetType: ec2.SubnetType.PUBLIC,\n  },\n  vpc,\n  deletionProtection: true, // Enable deletion protection.\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying EC2 Instance Type for GameLift Fleet in TypeScript\nDESCRIPTION: Defines the instance type to be used for a GameLift fleet. This determines the computing resources available for each game server instance in the fleet, which cannot be changed after fleet creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\nnew gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n    }]\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing SageMaker Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the AWS SageMaker module from the core AWS CDK library (`aws-cdk-lib`) into a TypeScript project. This import makes the SageMaker L1 constructs available for use within the CDK application under the `sagemaker` alias. Requires the `aws-cdk-lib` package to be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sagemaker/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport * as sagemaker from 'aws-cdk-lib/aws-sagemaker';\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Neptune Graph CDK Module\nDESCRIPTION: Example showing how to import the AWS CDK Neptune Graph module into a TypeScript project. This allows access to the L1 CloudFormation constructs for Neptune Graph.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-neptunegraph/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as neptunegraph from 'aws-cdk-lib/aws-neptunegraph';\n```\n\n----------------------------------------\n\nTITLE: Configuring Lambda Function Invocation from IoT Rules\nDESCRIPTION: Sets up an AWS IoT Rule that triggers a Lambda function execution. Includes creation of the Lambda function and its integration with the IoT rule.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iot-actions-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst func = new lambda.Function(this, 'MyFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromInline(`\n    exports.handler = (event) => {\n      console.log(\"It is test for lambda action of AWS IoT Rule.\", event);\n    };`\n  ),\n});\n\nnew iot.TopicRule(this, 'TopicRule', {\n  sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, timestamp() as timestamp, temperature FROM 'device/+/data'\"),\n  actions: [new actions.LambdaFunctionAction(func)],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Fargate Profile to EKS Cluster\nDESCRIPTION: Adds a Fargate profile to an existing EKS cluster for running pods in the default namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\ncluster.addFargateProfile('MyProfile', {\n  selectors: [ { namespace: 'default' } ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Kubectl Provider and EKS Cluster - AWS CDK - TypeScript\nDESCRIPTION: Shows how to reference an existing kubectl Lambda provider and IAM role in AWS CDK for associating with an imported EKS cluster. Relies on a retrieved Lambda function ARN and required Layer. Allows integration with more restrictive IAM trust relationships for kubectl execution.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nconst handlerRole = iam.Role.fromRoleArn(this, 'HandlerRole', 'arn:aws:iam::123456789012:role/lambda-role');\n// get the serivceToken from the custom resource provider\nconst functionArn = lambda.Function.fromFunctionName(this, 'ProviderOnEventFunc', 'ProviderframeworkonEvent-XXX').functionArn;\nconst kubectlProvider = eks.KubectlProvider.fromKubectlProviderAttributes(this, 'KubectlProvider', {\n  serviceToken: functionArn,\n  role: handlerRole,\n});\n\nconst cluster = eks.Cluster.fromClusterAttributes(this, 'Cluster', {\n  clusterName: 'cluster',\n  kubectlProvider,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring a Classic ELB for CodeDeploy Deployment Group in TypeScript\nDESCRIPTION: Specifies a Classic Elastic Load Balancer for a CodeDeploy Deployment Group using the LoadBalancer.classic factory method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elb from 'aws-cdk-lib/aws-elasticloadbalancing';\n\ndeclare const lb: elb.LoadBalancer;\nlb.addListener({\n  externalPort: 80,\n});\n\nconst deploymentGroup = new codedeploy.ServerDeploymentGroup(this, 'DeploymentGroup', {\n  loadBalancer: codedeploy.LoadBalancer.classic(lb),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SAML Authentication\nDESCRIPTION: Enables SAML authentication for OpenSearch domain with fine-grained access control.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  enforceHttps: true,\n  nodeToNodeEncryption: true,\n  encryptionAtRest: {\n    enabled: true,\n  },\n  fineGrainedAccessControl: {\n    masterUserName: 'master-user',\n    samlAuthenticationEnabled: true,\n    samlAuthenticationOptions: {\n      idpEntityId: 'entity-id',\n      idpMetadataContent: 'metadata-content-with-quotes-escaped',\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Alexa Skill Deployment with Secrets\nDESCRIPTION: Configures Alexa Skill deployment using CodePipeline. Uses secrets from Secrets Manager for authentication and includes support for manifest overrides.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n// Read the secrets from ParameterStore\nconst clientId = SecretValue.secretsManager('AlexaClientId');\nconst clientSecret = SecretValue.secretsManager('AlexaClientSecret');\nconst refreshToken = SecretValue.secretsManager('AlexaRefreshToken');\n\n// Add deploy action\nconst sourceOutput = new codepipeline.Artifact();\nnew codepipeline_actions.AlexaSkillDeployAction({\n  actionName: 'DeploySkill',\n  runOrder: 1,\n  input: sourceOutput,\n  clientId: clientId.toString(),\n  clientSecret: clientSecret,\n  refreshToken: refreshToken,\n  skillId: 'amzn1.ask.skill.12345678-1234-1234-1234-123456789012',\n});\n```\n\n----------------------------------------\n\nTITLE: Using Predefined ECS Deployment Configurations in AWS CDK\nDESCRIPTION: Demonstrates how to use predefined CodeDeploy configurations for ECS traffic shifting during deployments. This example uses the CANARY_10PERCENT_5MINUTES configuration that shifts 10% of traffic initially, then the remaining 90% after 5 minutes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = codedeploy.EcsDeploymentConfig.CANARY_10PERCENT_5MINUTES;\n```\n\n----------------------------------------\n\nTITLE: Importing AWS KafkaConnect Module in AWS CDK (TypeScript)\nDESCRIPTION: Imports the necessary AWS KafkaConnect module (`kafkaconnect`) from the `aws-cdk-lib` package. This is the standard way to begin using KafkaConnect L1 constructs within an AWS CDK application written in TypeScript. Requires the `aws-cdk-lib` package to be installed as a dependency in the project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kafkaconnect/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kafkaconnect from 'aws-cdk-lib/aws-kafkaconnect';\n```\n\n----------------------------------------\n\nTITLE: Configuring Provider URLs with Static Values\nDESCRIPTION: Shows how to configure role mappings using static provider URLs for supported identity providers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IdentityPoolProviderUrl } from 'aws-cdk-lib/aws-cognito-identitypool';\n\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  roleMappings: [{\n    providerUrl: IdentityPoolProviderUrl.FACEBOOK,\n    useToken: true,\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Matchmaking RuleSet in GameLift FlexMatch with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a matchmaking ruleset in GameLift FlexMatch. It loads the ruleset content from a JSON file.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew gamelift.MatchmakingRuleSet(this, 'RuleSet', {\n  matchmakingRuleSetName: 'my-test-ruleset',\n  content: gamelift.RuleSetContent.fromJsonFile(path.join(__dirname, 'my-ruleset', 'ruleset.json')),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing RefactorSpaces Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the RefactorSpaces module from the aws-cdk-lib package in a TypeScript project. It allows access to RefactorSpaces constructs and resources in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-refactorspaces/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as refactorspaces from 'aws-cdk-lib/aws-refactorspaces';\n```\n\n----------------------------------------\n\nTITLE: Associating Extensions with AppConfig Application using AWS CDK in TypeScript\nDESCRIPTION: This code demonstrates how to associate an existing AWS AppConfig `Extension` with an `appconfig.Application` using the `addExtension()` method. It also shows how to directly define an action point handler (e.g., `onDeploymentComplete`) on the application resource, associating it with a specific event destination like `appconfig.LambdaDestination`. Requires `appconfig.Application`, `appconfig.Extension`, and `appconfig.LambdaDestination` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const extension: appconfig.Extension;\ndeclare const lambdaDestination: appconfig.LambdaDestination;\n\napplication.addExtension(extension);\napplication.onDeploymentComplete(lambdaDestination);\n```\n```\n\n----------------------------------------\n\nTITLE: Importing FraudDetector Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import the 'aws-frauddetector' module from the 'aws-cdk-lib' package in TypeScript. The import grants access to the automatically generated L1 constructs for AWS FraudDetector, enabling direct working with underlying CloudFormation resources. To use these constructs, ensure that 'aws-cdk-lib' is installed in your project; no L2 constructs are currently available for this service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-frauddetector/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as frauddetector from 'aws-cdk-lib/aws-frauddetector';\n```\n\n----------------------------------------\n\nTITLE: Filtering Files for Output Artifacts in Commands Action\nDESCRIPTION: This example shows how to filter specific files to be included in the output artifact of a Commands action. It creates an output artifact with a path pattern filter and demonstrates creating files that match this pattern.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceArtifact: codepipeline.Artifact;\n\n// filter files to be included in the output artifact\nconst outputArtifact = new codepipeline.Artifact('OutputArtifact', ['my-dir/**/*']);\nconst commandsAction = new codepipeline_actions.CommandsAction({\n  actionName: 'Commands',\n  commands: [\n    'mkdir -p my-dir',\n    'echo \"HelloWorld\" > my-dir/file.txt',\n  ],\n  input: sourceArtifact,\n  output: outputArtifact,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Context via node.setContext Method - TypeScript\nDESCRIPTION: Shows how to set app-level context dynamically after AWS CDK App instantiation using the node.setContext method. This approach enables late context assignment or overrides for testing and conditional configurations. Requires an initialized App object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\napp.node.setContext('@aws-cdk/core:newStyleStackSynthesis', true);\n```\n\n----------------------------------------\n\nTITLE: Using Serialized JSON Matcher in AWS CDK Template Testing\nDESCRIPTION: Demonstrates how to use Match.serializedJson() for deep matching within stringified JSON properties in CDK template resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Baz\": \"{ \\\"Fred\\\": [\\\"Waldo\\\", \\\"Willow\\\"] }\"\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Baz: Match.serializedJson({\n    Fred: Match.arrayWith([\"Waldo\"]),\n  }),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Baz: Match.serializedJson({\n    Fred: [\"Waldo\", \"Johnny\"],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Sharing an AppRegistry Application with Principals in TypeScript\nDESCRIPTION: Shares an AppRegistry Application with specific AWS accounts, AWS Organizations (or OUs via ARN), IAM roles, and IAM users using the `shareApplication` method. Requires an existing `appreg.Application` instance, IAM principal instances (`iam.IRole`, `iam.IUser`), and AWS Organizations to be enabled in the account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const application: appreg.Application;\ndeclare const myRole: iam.IRole;\ndeclare const myUser: iam.IUser;\napplication.shareApplication('MyShareId', {\n  name:'MyShare',\n  accounts: ['123456789012'],\n  organizationArns: ['arn:aws:organizations::123456789012:organization/o-my-org-id'],\n  roles: [myRole],\n  users: [myUser],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a GeofenceCollection in AWS Location Service\nDESCRIPTION: Creates a new GeofenceCollection resource with an optional custom name and KMS key for encryption. GeofenceCollections store and manage virtual boundaries that can trigger notifications when crossed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const key: kms.Key;\n\nnew location.GeofenceCollection(this, 'GeofenceCollection', {\n  geofenceCollectionName: 'MyGeofenceCollection', // optional, defaults to a generated name\n  kmsKey: key, // optional, defaults to use an AWS managed key\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Static Service Principal\nDESCRIPTION: Demonstrates how to create a service principal with a static name for services that don't follow the standard naming pattern.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst sp = iam.ServicePrincipal.fromStaticServicePrincipleName('elasticmapreduce.amazonaws.com.cn');\n```\n\n----------------------------------------\n\nTITLE: Sample AWS CloudTrail Event for S3 PutObject (JSON)\nDESCRIPTION: This JSON object represents a sample AWS CloudTrail event log recorded for an S3 `PutObject` API call. It includes details such as the event source (s3.amazonaws.com), affected resources (S3 object and bucket ARNs), event time, user agent, user identity (including assumed role details), request parameters (bucket name, key), and other metadata associated with the API call. This structure is typical for CloudTrail events and is useful for auditing and monitoring AWS resource activity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/SAMPLE-EVENTS.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"eventSource\": \"s3.amazonaws.com\",\n  \"resources\": [\n    {\n      \"ARN\": \"arn:aws:s3:::amzn-s3-demo-bucket/OBJECTKEY\",\n      \"type\": \"AWS::S3::Object\"\n    },\n    {\n      \"accountId\": \"123456789012\",\n      \"ARN\": \"arn:aws:s3:::amzn-s3-demo-bucket\",\n      \"type\": \"AWS::S3::Bucket\"\n    }\n  ],\n  \"eventTime\": \"2020-05-22T08:38:05Z\",\n  \"userAgent\": \"[aws-cli/1.16.96 Python/2.7.12 Linux/4.4.0-146-generic botocore/1.12.86]\",\n  \"readOnly\": false,\n  \"recipientAccountId\": \"123456789012\",\n  \"awsRegion\": \"eu-west-1\",\n  \"requestID\": \"CF9748DFDC5FB0A4\",\n  \"additionalEventData\": {\n    \"CipherSuite\": \"ECDHE-RSA-AES128-GCM-SHA256\",\n    \"bytesTransferredOut\": 0,\n    \"AuthenticationMethod\": \"AuthHeader\",\n    \"x-amz-id-2\": \"hRJMAs5p4ALZIabP4ATIL53npWU61+N6LYWj02gdQtR0ymKSySzVXUSZx7ydv7tRJwk+XMaPerM=\",\n    \"bytesTransferredIn\": 197,\n    \"SignatureVersion\": \"SigV4\"\n  },\n  \"eventType\": \"AwsApiCall\",\n  \"eventID\": \"3074546e-1bfa-4973-8502-b1bb4d0bda1a\",\n  \"eventVersion\": \"1.05\",\n  \"eventName\": \"PutObject\",\n  \"sourceIPAddress\": \"1.2.3.4\",\n  \"userIdentity\": {\n    \"accountId\": \"123456789012\",\n    \"type\": \"AssumedRole\",\n    \"principalId\": \"AROAJBNCAL3UTR5C42U4M:user-SomeRole\",\n    \"accessKeyId\": \"AZYCAIJERO6H7\",\n    \"sessionContext\": {\n      \"attributes\": {\n        \"mfaAuthenticated\": \"false\",\n        \"creationDate\": \"2020-05-22T08:10:21Z\"\n      },\n      \"sessionIssuer\": {\n        \"accountId\": \"123456789012\",\n        \"type\": \"Role\",\n        \"principalId\": \"AROAJBNCAL3UTR5C42U4M\",\n        \"userName\": \"SomeRole\",\n        \"arn\": \"arn:aws:iam::123456789012:role/SomeRole\"\n      }\n    },\n    \"arn\": \"arn:aws:sts::123456789012:assumed-role/SomeRole/user-SomeRole\"\n  },\n  \"responseElements\": null,\n  \"requestParameters\": {\n    \"bucketName\": \"amzn-s3-demo-bucket\",\n    \"Host\": \"amzn-s3-demo-bucket.s3.eu-west-1.amazonaws.com\",\n    \"key\": \"OBJECTKEY\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AWS CodeArtifact with Python Lambda Docker Build Args\nDESCRIPTION: Shows how to use AWS CodeArtifact with Python Lambda functions by setting build arguments for the Docker bundling process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { execSync } from 'child_process';\n\nconst entry = '/path/to/function';\nconst image = DockerImage.fromBuild(entry);\n\nconst domain = 'my-domain';\nconst domainOwner = '111122223333';\nconst repoName = 'my_repo';\nconst region = 'us-east-1';\nconst codeArtifactAuthToken = execSync(`aws codeartifact get-authorization-token --domain ${domain} --domain-owner ${domainOwner} --query authorizationToken --output text`).toString().trim();\n\nconst indexUrl = `https://aws:${codeArtifactAuthToken}@${domain}-${domainOwner}.d.codeartifact.${region}.amazonaws.com/pypi/${repoName}/simple/`;\n\nnew python.PythonFunction(this, 'function', {\n  entry,\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    buildArgs: { PIP_INDEX_URL: indexUrl },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting Version Information in JavaScript\nDESCRIPTION: This code snippet shows the structure of the object exported by the resolve-version.js script. It includes the current version, file locations for version and changelog, prerelease tag, and version marker for package.json files.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/release.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  version: '2.0.0-alpha.1',          // the current version\n  versionFile: 'version.v2.json',    // the version file\n  changelogFile: 'CHANGELOG.v2.md',  // changelog file name\n  prerelease: 'alpha',               // prerelease tag (undefined for stable)\n  marker: '0.0.0'                    // version marker in package.json files\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Encrypted Kinesis Stream (Managed KMS Key) - AWS CDK - TypeScript\nDESCRIPTION: This example enables encryption using a user-managed AWS KMS key by specifying the encryption property as kinesis.StreamEncryption.KMS. CDK will automatically create and associate the KMS key with the stream. It requires kinesis, aws-cdk-lib, and constructs modules. Key parameter is encryption; outputs an encrypted Stream linked to a user-managed KMS key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew kinesis.Stream(this, 'MyEncryptedStream', {\n  encryption: kinesis.StreamEncryption.KMS,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Conditions to IAM Principal\nDESCRIPTION: Demonstrates how to add conditions to an existing principal using the withConditions method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst principal = new iam.AccountPrincipal('123456789000')\n  .withConditions({ StringEquals: { foo: \"baz\" } });\n```\n\n----------------------------------------\n\nTITLE: Importing Existing OpenSearch Domain by Endpoint\nDESCRIPTION: Imports an existing OpenSearch domain using its endpoint URL.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst domainEndpoint = 'https://my-domain-jcjotrt6f7otem4sqcwbch3c4u.us-east-1.es.amazonaws.com';\nconst domain = Domain.fromDomainEndpoint(this, 'ImportedDomain', domainEndpoint);\n```\n\n----------------------------------------\n\nTITLE: Creating AWS App Mesh Mesh with ALLOW_ALL Egress Filter in TypeScript\nDESCRIPTION: Creates an AWS App Mesh `Mesh` resource named 'myAwsMesh' using the CDK `appmesh.Mesh` construct. This snippet explicitly configures the `egressFilter` property to `appmesh.MeshFilterType.ALLOW_ALL`, permitting all outbound traffic from services within the mesh. Assumes `this` refers to a CDK construct (like a Stack).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mesh = new appmesh.Mesh(this, 'AppMesh', {\n  meshName: 'myAwsMesh',\n  egressFilter: appmesh.MeshFilterType.ALLOW_ALL,\n});\n```\n\n----------------------------------------\n\nTITLE: Critical Security Fix Warning\nDESCRIPTION: Warning message about critical vulnerability fix CVE-2023-45857 with link to details.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n Critical vulnerability fix. See https://security.snyk.io/vuln/SNYK-JS-AXIOS-6032459\n```\n\n----------------------------------------\n\nTITLE: Skipping CRD Installation for Helm Charts in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to prevent the installation of Custom Resource Definitions (CRDs) that might be bundled with a Helm chart. This is achieved by setting the `skipCrds` property to `true` when defining the Helm chart installation using the `eks.HelmChart` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n// option 1: use a construct\nnew eks.HelmChart(this, 'NginxIngress', {\n  cluster,\n  chart: 'nginx-ingress',\n  repository: 'https://helm.nginx.com/stable',\n  namespace: 'kube-system',\n  skipCrds: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Load Balancer Origin Properties\nDESCRIPTION: Configures advanced properties for a Load Balancer origin including timeouts and protocol policies\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const loadBalancer: elbv2.ApplicationLoadBalancer;\nconst origin = new origins.LoadBalancerV2Origin(loadBalancer, {\n  connectionAttempts: 3,\n  connectionTimeout: Duration.seconds(5),\n  readTimeout: Duration.seconds(45),\n  keepaliveTimeout: Duration.seconds(45),\n  protocolPolicy: cloudfront.OriginProtocolPolicy.MATCH_VIEWER,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Cost Explorer Construct Library - TypeScript\nDESCRIPTION: Demonstrates how to import the AWS Cost Explorer (CE) module from the aws-cdk-lib for use in AWS CDK projects. This import is required to access both the automatically generated L1 CloudFormation constructs for AWS::CE and any future constructs in the aws-cdk-lib/aws-ce namespace. No additional dependencies beyond aws-cdk-lib are required, and the snippet does not expect parameters or return values. It is limited to importing the namespace and does not perform any AWS resource operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ce/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as ce from 'aws-cdk-lib/aws-ce';\n```\n\n----------------------------------------\n\nTITLE: Assigning Multiple Resource Types to an AWS Backup Plan Selection - AWS CDK - TypeScript\nDESCRIPTION: Shows how to assign various AWS resourcesincluding DynamoDB tables, RDS instances/clusters, Aurora Serverless clusters, tag-based resources, and custom Constructsto an AWS Backup Plan selection using the AWS CDK in TypeScript. Dependencies include AWS CDK modules for DynamoDB, RDS, EC2, and Backup, and properly initialized resource objects. Accepts a list of BackupResource instances as the resources parameter in addSelection(). Output is a new backup selection with the given resources associated.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const plan: backup.BackupPlan;\ndeclare const vpc: ec2.Vpc;\nconst myTable = dynamodb.Table.fromTableName(this, 'Table', 'myTableName');\nconst myDatabaseInstance = new rds.DatabaseInstance(this, 'DatabaseInstance', {\n  engine: rds.DatabaseInstanceEngine.mysql({ version: rds.MysqlEngineVersion.VER_8_0_26 }),\n  vpc,\n});\nconst myDatabaseCluster = new rds.DatabaseCluster(this, 'DatabaseCluster', {\n  engine: rds.DatabaseClusterEngine.auroraMysql({ version: rds.AuroraMysqlEngineVersion.VER_2_08_1 }),\n  credentials: rds.Credentials.fromGeneratedSecret('clusteradmin'),\n  instanceProps: {\n    vpc,\n  },\n});\nconst myServerlessCluster = new rds.ServerlessCluster(this, 'ServerlessCluster', {\n  engine: rds.DatabaseClusterEngine.AURORA_POSTGRESQL,\n  parameterGroup: rds.ParameterGroup.fromParameterGroupName(this, 'ParameterGroup', 'default.aurora-postgresql11'),\n  vpc,\n});\nconst myCoolConstruct = new Construct(this, 'MyCoolConstruct');\n\nplan.addSelection('Selection', {\n  resources: [\n    backup.BackupResource.fromDynamoDbTable(myTable), // A DynamoDB table\n    backup.BackupResource.fromRdsDatabaseInstance(myDatabaseInstance), // A RDS instance\n    backup.BackupResource.fromRdsDatabaseCluster(myDatabaseCluster), // A RDS database cluster\n    backup.BackupResource.fromRdsServerlessCluster(myServerlessCluster), // An Aurora Serverless cluster\n    backup.BackupResource.fromTag('stage', 'prod'), // All resources that are tagged stage=prod in the region/account\n    backup.BackupResource.fromConstruct(myCoolConstruct), // All backupable resources in `myCoolConstruct`\n  ]\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Artifact Storage with Lifecycle Rules in AWS CDK\nDESCRIPTION: Demonstrates how to configure artifact storage for a Synthetics canary with lifecycle rules. The example creates a canary that stores artifacts with a 30-day expiration policy.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst canary = new synthetics.Canary(this, 'MyCanary', {\n  schedule: synthetics.Schedule.rate(Duration.minutes(5)),\n  test: synthetics.Test.custom({\n    code: synthetics.Code.fromAsset(path.join(__dirname, 'canary')),\n    handler: 'index.handler',\n  }),\n  runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_6_2,\n  artifactsBucketLifecycleRules: [{\n    expiration: Duration.days(30),\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Multi-Region and Global Service Events in CloudTrail using AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to configure a CloudTrail trail to operate only in the region it's deployed in and to exclude events from global services (like IAM, CloudFront). This is achieved by setting `isMultiRegionTrail` and `includeGlobalServiceEvents` properties to `false`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst trail = new cloudtrail.Trail(this, 'CloudTrail', {\n  // ...\n  isMultiRegionTrail: false,\n  includeGlobalServiceEvents: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto-Hibernation for Cloud9 Environment\nDESCRIPTION: Shows how to configure automatic stopping of the EC2 instance after a period of inactivity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-cloud9-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst defaultVpc = ec2.Vpc.fromLookup(this, 'DefaultVPC', { isDefault: true });\nnew cloud9.Ec2Environment(this, 'Cloud9Env2', {\n  vpc: defaultVpc,\n  imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  automaticStop: Duration.minutes(30),\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Cross-Stack CloudFormation Export Errors (Text)\nDESCRIPTION: Shows an example of a CloudFormation error message encountered when attempting to delete an exported resource that is still in use by another stack. No code execution or programming prerequisites are required. The example is intended to help users recognize blocking export errors related to stack dependencies and automatic references. Be aware that such errors must be resolved by breaking cross-stack references as described in the documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nExport Stack1:ExportsOutputFnGetAtt-****** cannot be deleted as it is in use by Stack1\n```\n\n----------------------------------------\n\nTITLE: Disabling Resource Pruning for an EKS Cluster in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to disable the default behavior of automatic resource pruning when defining an AWS EKS cluster using the CDK. This is done by setting the `prune` property to `false` during cluster instantiation with `eks.Cluster`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nnew eks.Cluster(this, 'MyCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  prune: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Choice-Based Authentication in Cognito User Pool with TypeScript\nDESCRIPTION: This snippet demonstrates how to explicitly disable choice-based authentication methods (like OTP or passkey) in an AWS Cognito User Pool using AWS CDK. By setting only `password: true` within `allowedFirstAuthFactors` in the `signInPolicy`, it restricts authentication solely to the user's password. It also explicitly sets the `featurePlan` to `LITE`, although password-only is supported on all plans.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  signInPolicy: {\n    allowedFirstAuthFactors: { password: true },\n  },\n  featurePlan: cognito.FeaturePlan.LITE,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Template from String in TypeScript\nDESCRIPTION: Shows how to create a `Template` instance directly from a JSON string representing a CloudFormation template. This is useful for testing against existing or pre-generated templates. The `Template.fromString()` static method parses the provided JSON string.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=init\nconst templateJson = '{ \"Resources\": ... }'; /* The CloudFormation template as JSON serialized string. */\nconst template = Template.fromString(templateJson);\n```\n```\n\n----------------------------------------\n\nTITLE: CloudFormation Template with Complex Intrinsic Functions (JSON)\nDESCRIPTION: An example CloudFormation template defining a KMS Key with a policy that uses the `Fn::If` intrinsic function. This complexity might prevent successful conversion to an L2 construct using `fromCfn*` methods.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Resources\": {\n    \"Key\": {\n      \"Type\": \"AWS::KMS::Key\",\n      \"Properties\": {\n        \"KeyPolicy\": {\n          \"Statement\": [\n            {\n              \"Fn::If\": [\n                \"Condition\",\n                {\n                  \"Action\": \"kms:if-action\",\n                  \"Resource\": \"*\",\n                  \"Principal\": \"*\",\n                  \"Effect\": \"Allow\"\n                },\n                {\n                  \"Action\": \"kms:else-action\",\n                  \"Resource\": \"*\",\n                  \"Principal\": \"*\",\n                  \"Effect\": \"Allow\"\n                }\n              ]\n            }\n          ],\n          \"Version\": \"2012-10-17\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TriggerFunction in AWS CDK\nDESCRIPTION: Creates a TriggerFunction construct that defines and executes a Lambda function during deployment. This example configures a Node.js Lambda function that will be triggered when the stack is deployed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/triggers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as triggers from 'aws-cdk-lib/triggers';\n\nnew triggers.TriggerFunction(this, 'MyTrigger', {\n  runtime: lambda.Runtime.NODEJS_18_X,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(__dirname + '/my-trigger'),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Metric Method in TypeScript\nDESCRIPTION: Basic metric method signature required for all AWS resources that emit CloudWatch metrics. Takes a metric name and optional options, returns a CloudWatch metric object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nmetric(metricName: string, options?: cloudwatch.MetricOptions): cloudwatch.Metric;\n```\n\n----------------------------------------\n\nTITLE: Creating a circular traffic flow with VirtualNode and VirtualService\nDESCRIPTION: Shows how to create a circular traffic flow pattern by creating a VirtualNode and then adding a VirtualService as a backend whose provider is the same VirtualNode. Uses DNS service discovery.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mesh: appmesh.Mesh;\n\nconst node = new appmesh.VirtualNode(this, 'node', {\n  mesh,\n  serviceDiscovery: appmesh.ServiceDiscovery.dns('node'),\n});\n\nconst virtualService = new appmesh.VirtualService(this, 'service-1', {\n  virtualServiceProvider: appmesh.VirtualServiceProvider.virtualNode(node),\n  virtualServiceName: 'service1.domain.local',\n});\n\nnode.addBackend(appmesh.Backend.virtualService(virtualService));\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Macie module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Macie module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-macie/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as macie from 'aws-cdk-lib/aws-macie';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS NetworkManager module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS NetworkManager module from the aws-cdk-lib package in a TypeScript project. This import allows access to NetworkManager constructs and resources in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-networkmanager/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as networkmanager from 'aws-cdk-lib/aws-networkmanager';\n```\n\n----------------------------------------\n\nTITLE: Changelog Version Headers and Version Links\nDESCRIPTION: Markdown headers and links documenting version numbers and comparison links between releases\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CHANGELOG.v2.alpha.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [2.191.0-alpha.0](https://github.com/aws/aws-cdk/compare/v2.190.0-alpha.0...v2.191.0-alpha.0) (2025-04-22)\n\n## [2.190.0-alpha.0](https://github.com/aws/aws-cdk/compare/v2.189.1-alpha.0...v2.190.0-alpha.0) (2025-04-16)\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Bucket with Auto-Delete Objects Enabled in AWS CDK (JavaScript)\nDESCRIPTION: This code creates a CDK app that provisions an S3 bucket with autoDeleteObjects set to true. This configuration ensures that all objects are automatically deleted when the bucket is removed, which is especially important for integration testing to clean up resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tests.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, Stack } = require('aws-cdk-lib');\nconst s3 = require('aws-cdk-lib/aws-s3');\n\nconst app = new App();\nconst stack = new Stack(app, 'aws-cdk-s3-bucket-auto-delete-objects');\nnew s3.Bucket(stack, 'Bucket', { autoDeleteObjects: true, removalPolicy: s3.RemovalPolicy.DESTROY });\napp.synth();\n```\n\n----------------------------------------\n\nTITLE: Asserting Resource Count in TypeScript\nDESCRIPTION: Demonstrates how to use the `resourceCountIs()` method to assert the exact number of resources of a specific type within the CloudFormation template. It takes the resource type (e.g., 'Foo::Bar') and the expected count as arguments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.resourceCountIs('Foo::Bar', 2);\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Advanced Docker Options for Go Function Bundling\nDESCRIPTION: Shows how to configure additional Docker options for the build environment, including network settings, security options, user contexts, and volume configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'GoFunction', {\n  entry: 'app/cmd/api',\n  bundling: {\n      network: 'host',\n      securityOpt: 'no-new-privileges',\n      user: 'user:group',\n      volumesFrom: ['777f7dc92da7'],\n      volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n   },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a PySparkEtlJob with Optional Parameters for Flex Jobs in TypeScript\nDESCRIPTION: Example demonstrating how to create a PySparkEtlJob with optional override parameters for non-urgent workloads, including Glue version, worker type, and other job configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PySparkEtlJob(stack, 'pySparkEtlJob', {\n  jobName: 'pySparkEtlJob',\n  description: 'This is a description',\n  role,\n  script,\n  glueVersion: glue.GlueVersion.V3_0,\n  continuousLogging: { enabled: false },\n  workerType: glue.WorkerType.G_2X,\n  maxConcurrentRuns: 100,\n  timeout: cdk.Duration.hours(2),\n  connections: [glue.Connection.fromConnectionName(stack, 'Connection', 'connectionName')],\n  securityConfiguration: glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'SecurityConfig', 'securityConfigName'),\n  tags: {\n    FirstTagName: 'FirstTagValue',\n    SecondTagName: 'SecondTagValue',\n    XTagName: 'XTagValue',\n  },\n  numberOfWorkers: 2,\n  maxRetries: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Stack with Old `SynthUtils` (TypeScript)\nDESCRIPTION: Demonstrates the deprecated way of synthesizing a CDK stack to access its CloudFormation template using `SynthUtils.synthesize(stack).template`. The second line shows synthesizing without capturing the output, typically done for validation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexpect(SynthUtils.synthesize(stack).template).toEqual(/*...*/);\nSynthUtils.syntesize(stack);\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Comments to Redshift Tables and Columns with AWS CDK in TypeScript\nDESCRIPTION: Defines comments for both the Redshift table itself (`tableComment`) and its individual columns (`comment` property within `tableColumns`). Comments provide metadata and documentation directly within the database schema. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableColumns: [\n    { name: 'col1', dataType: 'varchar(4)', comment: 'This is a column comment' },\n    { name: 'col2', dataType: 'float', comment: 'This is a another column comment' }\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n  tableComment: 'This is a table comment',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AppStream L1 Constructs in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import the AWS CDK L1 constructs for Amazon AppStream 2.0. It makes the `appstream` namespace available, allowing developers to define AppStream resources like Fleets, Stacks, and Images using the CloudFormation-level constructs within their CDK applications. Requires the `aws-cdk-lib` package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appstream/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appstream from 'aws-cdk-lib/aws-appstream';\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Provider in Cognito Identity Pool\nDESCRIPTION: Demonstrates how to set up a custom authentication provider along with Google and OpenID Connect providers in a Cognito Identity Pool. Shows configuration of multiple authentication providers within a single identity pool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const openIdConnectProvider: iam.OpenIdConnectProvider;\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  authenticationProviders: {\n    google: {\n      clientId: '12345678012.apps.googleusercontent.com',\n    },\n    openIdConnectProviders: [openIdConnectProvider],\n    customProvider: 'my-custom-provider.example.com',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enum Definition in AWS CDK\nDESCRIPTION: Example of defining a standard enum in AWS CDK to represent a fixed set of options with specific string values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport enum MyEnum {\n  OPTION1 = 'op21',\n  OPTION2 = 'opt2',\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging VPC and its Components in TypeScript\nDESCRIPTION: Demonstrates how to add tags to a VPC using the Tag Manager. By default, a 'Name' tag is added when a resource name is provided. Additional custom tags can be added using Tags.of(myConstruct).add('key', 'value').\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new VpcV2(this, 'VPC-integ-test-tag', {\n  primaryAddressBlock: IpAddresses.ipv4('10.1.0.0/16'),\n  enableDnsHostnames: true,\n  enableDnsSupport: true,\n  vpcName: 'CDKintegTestVPC',\n});\n\n// Add custom tags if needed\nTags.of(vpc).add('Environment', 'Production');\n```\n\n----------------------------------------\n\nTITLE: Importing an existing CodeDeploy Deployment Group in TypeScript\nDESCRIPTION: Imports an existing CodeDeploy Deployment Group for EC2/on-premise deployments using fromServerDeploymentGroupAttributes method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: codedeploy.ServerApplication;\nconst deploymentGroup = codedeploy.ServerDeploymentGroup.fromServerDeploymentGroupAttributes(\n  this,\n  'ExistingCodeDeployDeploymentGroup', {\n    application,\n    deploymentGroupName: 'MyExistingDeploymentGroup',\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Adding a Stage to an Existing Pipeline\nDESCRIPTION: Demonstrates how to append a new stage to a pipeline after it has been created. This allows for modular pipeline construction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Append a Stage to an existing Pipeline\ndeclare const pipeline: codepipeline.Pipeline;\nconst sourceStage = pipeline.addStage({\n  stageName: 'Source',\n  actions: [ // optional property\n    // see below...\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual Stack for AppRunner Service\nDESCRIPTION: Enables dual stack (IPv4 and IPv6) for the AppRunner service's incoming public network configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  ipAddressType: apprunner.IpAddressType.DUAL_STACK,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Capacity Provider Strategies for Fargate Service\nDESCRIPTION: Example of setting up capacity provider strategies using FARGATE and FARGATE_SPOT providers with different weights.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\ncluster.enableFargateCapacityProviders();\n\nconst queueProcessingFargateService = new ecsPatterns.QueueProcessingFargateService(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 512,\n  image: ecs.ContainerImage.fromRegistry('test'),\n  minHealthyPercent: 100,\n  capacityProviderStrategies: [\n    {\n      capacityProvider: 'FARGATE_SPOT',\n      weight: 2,\n    },\n    {\n      capacityProvider: 'FARGATE',\n      weight: 1,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Game Server Launch Process in GameLift Fleet in TypeScript\nDESCRIPTION: Defines the runtime configuration for a GameLift fleet, specifying how game server processes should be launched on each instance. Includes path, parameters, and the number of concurrent executions limited to 50 per instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\n// Server processes can be delcared in a declarative way through the constructor\nconst fleet = new gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n      parameters: '-logFile /local/game/logs/myserver1935.log -port 1935',\n      concurrentExecutions: 100,\n    }]\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a Simple AppConfig Application with CDK in TypeScript\nDESCRIPTION: Shows the basic instantiation of an AWS AppConfig Application resource using the AWS CDK. The name and description are optional and not provided in this minimal example. Assumes `this` refers to the current CDK scope (Construct) and `appconfig` is the imported module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew appconfig.Application(this, 'MyApplication');\n```\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS DataSync Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS DataSync module from the AWS CDK library. This is the basic import statement needed to work with DataSync resources in a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-datasync/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as datasync from 'aws-cdk-lib/aws-datasync';\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Metric Methods\nDESCRIPTION: Static metric methods for Function class to access metrics across all resources of a certain type within an account.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nclass Function extends Resource implements IFunction {\n  public static metricAll(metricName: string, options?: cloudwatch.MetricOptions): cloudwatch.Metric;\n  public static metricAllErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Custom Go Build Flags\nDESCRIPTION: Shows how to pass additional build flags to the go build command during bundling. This example demonstrates passing linker flags to reduce binary size by stripping debug information.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'handler', {\n  entry: 'app/cmd/api',\n  bundling: {\n    goBuildFlags: ['-ldflags \"-s -w\"'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing AMI for Managed EC2 Compute Environment in AWS Batch with TypeScript\nDESCRIPTION: This snippet configures the Amazon Machine Image for an AWS Batch managed EC2 compute environment using AWS CDK. The code selects the Amazon Linux 2023 ECS-optimized AMI by specifying the 'images' property with 'EcsMachineImageType.ECS_AL2023'. Requires '@aws-cdk/aws-batch', '@aws-cdk/aws-ec2', 'EcsMachineImageType', and a VPC instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nnew batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  images: [\n    {\n      imageType: batch.EcsMachineImageType.ECS_AL2023,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Web Identity Principal with Session Tags\nDESCRIPTION: Shows how to create a web identity principal for services like Cognito with conditions and session tags.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nnew iam.Role(this, 'Role', {\n  assumedBy: new iam.WebIdentityPrincipal('cognito-identity.amazonaws.com', {\n    'StringEquals': {\n      'cognito-identity.amazonaws.com:aud': 'us-east-2:12345678-abcd-abcd-abcd-123456',\n     },\n    'ForAnyValue:StringLike': {\n      'cognito-identity.amazonaws.com:amr': 'unauthenticated',\n    },\n  }).withSessionTags(),\n});\n```\n\n----------------------------------------\n\nTITLE: Manipulating CloudFormation Mappings in CDK\nDESCRIPTION: Demonstrates how to access and update CloudFormation mappings through CfnInclude. This allows you to programmatically set mapping values from within CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst mapping: core.CfnMapping = cfnTemplate.getMapping('MyMapping');\n\n// mutating the mapping\nmapping.setValue('my-region', 'AMI', 'ami-04681a1dbd79675a5');\n```\n\n----------------------------------------\n\nTITLE: Configuring an Application Load Balancer for CodeDeploy in TypeScript\nDESCRIPTION: Specifies an Application Load Balancer Target Group for a CodeDeploy Deployment Group using the LoadBalancer.application factory method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alb: elbv2.ApplicationLoadBalancer;\nconst listener = alb.addListener('Listener', { port: 80 });\nconst targetGroup = listener.addTargets('Fleet', { port: 80 });\n\nconst deploymentGroup = new codedeploy.ServerDeploymentGroup(this, 'DeploymentGroup', {\n  loadBalancer: codedeploy.LoadBalancer.application(targetGroup),\n});\n```\n\n----------------------------------------\n\nTITLE: Sending multipart/form-data with FormData in Browser Axios\nDESCRIPTION: Shows how to send data using the `multipart/form-data` format in a browser environment with Axios. A standard `FormData` object is created, data fields are appended, and the `FormData` object is passed directly as the payload to `axios.post()`. Axios automatically sets the correct `Content-Type` header.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nconst formData = new FormData();\nformData.append('foo', 'bar');\n\naxios.post('https://httpbin.org/post', formData);\n```\n\n----------------------------------------\n\nTITLE: AWS CDK: Example Fixture Usage - Typescript\nDESCRIPTION: This snippet shows how to use a fixture in a Rosetta TypeScript example for AWS CDK documentation. The code expects 'bucket' and 'props' to be defined within the fixture file 'rosetta/with-bucket.ts-fixture', enabling successful compilation and testing of the usage snippet. Prerequisites include the existence of supporting fixture files and all necessary imports and variables being declared for compilation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nbucket.addLifecycleTransition({ ...props });\n```\n\n----------------------------------------\n\nTITLE: Manual S3 Bucket Policy Statement for Imported Buckets with OAC (JSON)\nDESCRIPTION: Provides the S3 bucket policy statement required to manually grant CloudFront OAC access to an imported S3 bucket. Since AWS CDK cannot modify imported bucket policies, this must be added outside the CDK deployment. The policy allows the `cloudfront.amazonaws.com` service principal to perform `s3:GetObject` actions on objects within the bucket (`arn:aws:s3:::<S3 bucket name>/*`), conditioned on the request originating from the specific CloudFront distribution ARN (`AWS:SourceArn` using `StringEquals`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": {\n        \"Effect\": \"Allow\",\n        \"Principal\": {\n            \"Service\": \"cloudfront.amazonaws.com\"\n        },\n        \"Action\": \"s3:GetObject\",\n        \"Resource\": \"arn:aws:s3:::<S3 bucket name>/*\",\n        \"Condition\": {\n            \"StringEquals\": {\n                \"AWS:SourceArn\": \"arn:aws:cloudfront::111122223333:distribution/<CloudFront distribution ID>\"\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS HealthLake Module in TypeScript CDK\nDESCRIPTION: Imports the AWS HealthLake construct library module (`aws-healthlake`) from the `aws-cdk-lib` package in a TypeScript AWS CDK application. This import makes the HealthLake L1 constructs available for use, allowing programmatic definition of HealthLake resources similar to how they are defined in CloudFormation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-healthlake/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as healthlake from 'aws-cdk-lib/aws-healthlake';\n```\n\n----------------------------------------\n\nTITLE: Setting Maintenance Track for Redshift Cluster using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to specify the maintenance track for an AWS Redshift cluster using AWS CDK. The `maintenanceTrackName` property is set to `redshift.MaintenanceTrackName.CURRENT`, ensuring the cluster updates to the most recent approved version during its maintenance window. Alternative `TRAILING` can be used for the previous version. Requires an existing VPC (`vpc`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as redshift from 'aws-cdk-lib/aws-redshift-alpha';\nimport * as cdk from 'aws-cdk-lib';\ndeclare const vpc: ec2.IVpc; // Assuming IVpc based on previous snippet\ndeclare const stack: cdk.Stack; // Using 'stack' as per snippet context\n\nnew redshift.Cluster(stack, 'Cluster', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  maintenanceTrackName: redshift.MaintenanceTrackName.CURRENT,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Route Tables to Transit Gateway in TypeScript\nDESCRIPTION: Shows how to add additional custom route tables to a Transit Gateway using the addRouteTable() method, allowing for more complex routing configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst transitGateway = new TransitGateway(this, 'MyTransitGateway');\n\nconst routeTable = transitGateway.addRouteTable('CustomRouteTable');\n```\n\n----------------------------------------\n\nTITLE: Setting Query Execution Timeout for Redshift Table Creation with AWS CDK\nDESCRIPTION: Configures the maximum duration for the table creation query using the `timeout` property. The default is 1 minute. This example sets the timeout to 15 minutes. Requires importing `Duration` from `aws-cdk-lib`, an existing `cluster` object, and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nimport { Duration } from 'aws-cdk-lib';\n\nnew Table(this, 'Table', {\n  tableColumns: [\n    { id: 'col1', name: 'col1', dataType: 'varchar(4)' },\n    { id: 'col2', name: 'col2', dataType: 'float' }\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n  timeout: Duration.minutes(15),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Type Check for AWS CDK Construct\nDESCRIPTION: Demonstrates how to implement a static type check method for an AWS CDK construct class. This pattern is required for all constructs in the AWS Construct Library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst IS_FOO = Symbol.for('@aws-cdk/aws-foo.Foo');\n\nexport class Foo {\n  public static isFoo(x: any): x is Foo {\n    return IS_FOO in x;\n  }\n\n  constructor(scope: Construct, id: string, props: FooProps) {\n    super(scope, id);\n\n    Object.defineProperty(this, IS_FOO, { value: true });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Assertion Example\nDESCRIPTION: Demonstrates complex assertions combining Lambda invocation and SQS message verification.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nmessage.assertAtPath('Messages.0.Body', ExpectedResult.objectLike({\n  requestContext: {\n    condition: 'Success',\n  },\n  requestPayload: {\n    status: 'OK',\n  },\n  responseContext: {\n    statusCode: 200,\n  },\n  responsePayload: 'success',\n}));\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Node Pools in EKS Auto Mode in TypeScript\nDESCRIPTION: Demonstrates how to disable the default node pools in an EKS cluster with Auto Mode by setting an empty array for nodePools.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksAutoCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.AUTOMODE,\n  compute: {\n    nodePools: [], // Disable default node pools\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Evidently Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Evidently module from the AWS CDK library using TypeScript. This import is necessary for using automatically generated L1 constructs for AWS::Evidently CloudFormation resources in CDK projects. No dependencies beyond installing 'aws-cdk-lib' are required. The 'evidently' namespace provides access to all AWS Evidently resource constructs, but note that higher-level (L2) hand-written abstractions are not available for this service yet. Input: None. Output: Ready access to Evidently constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-evidently/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as evidently from 'aws-cdk-lib/aws-evidently';\n```\n\n----------------------------------------\n\nTITLE: Overriding Existing Region Information in TypeScript\nDESCRIPTION: Shows how to correct existing information by implementing the IFact interface and registering it with the override flag set to true.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/region-info/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyFact implements regionInfo.IFact {\n  public readonly region = 'us-east-1';\n  public readonly name = regionInfo.FactName.S3_STATIC_WEBSITE_ENDPOINT;\n  public readonly value = 'the-correct-endpoint.amazonaws.com';\n}\n\nregionInfo.Fact.register(new MyFact(), true /* Allow overriding information */);\n```\n\n----------------------------------------\n\nTITLE: Definition of acknowledgeWarning Method for Warning Management in AWS CDK (TypeScript)\nDESCRIPTION: Presents the method signature for the new `acknowledgeWarning` API, which lets users acknowledge a warning by its unique ID, optionally providing a justification message. Used in custom AWS CDK extensions, it supports maintainability by tracking handled warnings programmatically. The function requires the warning ID and optionally a string message.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/acknowledge-warnings.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n  /**\n   * @param id - the id of the warning message to acknowledge\n   * @param message optional message to explain the reason for acknowledgement\n   */\n  public acknowledgeWarning(id: string, message?: string): void\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing AppRegistry Application in TypeScript\nDESCRIPTION: Demonstrates how to import an existing AppRegistry application into a CDK stack using its ARN via the Application.fromApplicationArn() method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst importedApplication = appreg.Application.fromApplicationArn(\n  this,\n  'MyImportedApplication',\n  'arn:aws:servicecatalog:us-east-1:012345678910:/applications/0aqmvxvgmry0ecc4mjhwypun6i',\n);\n```\n\n----------------------------------------\n\nTITLE: File Posting with Axios (JavaScript)\nDESCRIPTION: Demonstrates how to post single and multiple files using Axios with the FormData API. This is useful for file uploads in web applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.postForm('https://httpbin.org/post', {\n  'myVar' : 'foo',\n  'file': document.querySelector('#fileInput').files[0]\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.postForm('https://httpbin.org/post', {\n  'files[]': document.querySelector('#fileInput').files\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)\n```\n\n----------------------------------------\n\nTITLE: Importing AWS NimbleStudio Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS NimbleStudio module in a CDK application. This gives access to the L1 constructs for working with NimbleStudio resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-nimblestudio/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as nimblestudio from 'aws-cdk-lib/aws-nimblestudio';\n```\n\n----------------------------------------\n\nTITLE: Setting Explicit Runtime for NodejsFunction\nDESCRIPTION: Shows how to explicitly set the Node.js runtime version for a Lambda function instead of using the latest runtime version.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Runtime } from 'aws-cdk-lib/aws-lambda';\n\nnew nodejs.NodejsFunction(this, 'my-function', {\n    runtime: Runtime.NODEJS_18_X,\n});\n```\n\n----------------------------------------\n\nTITLE: Adjusting notificationArns Property Optionality - CloudFormationStackArtifact - AWS CDK - TypeScript\nDESCRIPTION: This comment documents a correction where the notificationArns property in CloudFormationStackArtifact was mistakenly required, but should have been optional. The change ensures TypeScript and consuming code can safely omit this property. No external dependencies are affected, but code interfacing with this property should handle undefined values. Applicable to both the @aws-cdk/cx-api and aws-cdk-lib.cx_api namespaces.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n# output property was mistakenly marked as required even though it should have allowed\n# for undefined, i.e optional\nchanged-type:@aws-cdk/cx-api.CloudFormationStackArtifact.notificationArns\nchanged-type:aws-cdk-lib.cx_api.CloudFormationStackArtifact.notificationArns\n```\n\n----------------------------------------\n\nTITLE: AWS CDK Custom Resource Handlers Structure\nDESCRIPTION: Lists of stable and experimental custom resource handlers used in AWS CDK, including details about their deployment locations and handling mechanisms.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/custom-resource-handlers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Custom Resource Handlers\n\nThis package contains the following custom resource handlers:\n\n## Stable\n\n- aws-certificatemanager/dns-validated-certificate-handler\n- aws-cloudfront/edge-function\n- aws-dynamodb/replica-handler\n- aws-ec2/restrict-default-security-group-handler\n- aws-ecr/auto-delete-images-handler\n- aws-ecs/lambda-source\n- aws-eks/custom-resource-handler\n- aws-eks/kubectl-handler\n- aws-events-targets/aws-api-handler\n- aws-iam/oidc-handler\n- aws-logs/log-retention-handler\n- aws-route53/cross-account-zone-delegation-handler\n- aws-route53/delete-existing-record-set-handler\n- aws-s3/auto-delete-objects-handler\n- aws-s3/notifications-resource-handler\n- aws-s3-deployment/bucket-deployment-handler\n- aws-ses/drop-spam-handler\n- aws-stepfunctions-tasks/cross-region-aws-sdk-handler\n- aws-stepfunctions-tasks/eval-nodejs-handler\n- aws-stepfunctions-tasks/role-policy-handler\n- aws-synthetics/auto-delete-underlying-resources-handler\n- custom-resources/aws-custom-resource-handler\n- pipelines/approve-lambda\n- triggers/lambda\n```\n\n----------------------------------------\n\nTITLE: Using Exclude Filters during S3 Bucket Deployment Process\nDESCRIPTION: Shows how to use exclude filters during the deployment process to prevent specific files from being deployed to the destination bucket and from being deleted during prune operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const destinationBucket: s3.Bucket;\nnew s3deploy.BucketDeployment(this, 'DeployButExcludeSpecificFiles', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, 'my-website'))],\n  destinationBucket,\n  exclude: ['*.txt'],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Scaling for AppRunner Service\nDESCRIPTION: Associates an AppRunner service with a custom auto scaling configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst autoScalingConfiguration = new apprunner.AutoScalingConfiguration(this, 'AutoScalingConfiguration', {\n  autoScalingConfigurationName: 'MyAutoScalingConfiguration',\n  maxConcurrency: 150,\n  maxSize: 20,\n  minSize: 5,\n});\n\nnew apprunner.Service(this, 'DemoService', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  autoScalingConfiguration,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Termination Protection on AWS CDK Stack - TypeScript\nDESCRIPTION: Demonstrates creation of a new AWS CDK Stack with termination protection enabled via the terminationProtection property in the Stack constructor. Requires the aws-cdk-lib and proper initialization of the app object. Takes an app object and a stack name as parameters, and enables termination protection by setting the property to true in the constructor's props. The resulting stack cannot be deleted accidentally until protection is disabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack(app, 'StackName', {\n  terminationProtection: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling ApplicationSignals on ECS with Sidecar Mode\nDESCRIPTION: This code demonstrates how to enable ApplicationSignals on ECS Fargate with sidecar mode. It configures instrumentation for a Java application and adds the CloudWatch Agent as a sidecar container to the task definition, enabling application monitoring.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-applicationsignals-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Construct } from 'constructs';\nimport * as appsignals from '@aws-cdk/aws-applicationsignals-alpha';\nimport * as cdk from 'aws-cdk-lib';\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\nclass MyStack extends cdk.Stack {\n  public constructor(scope?: Construct, id?: string, props: cdk.StackProps = {}) {\n    super();\n    const vpc = new ec2.Vpc(this, 'TestVpc', {});\n    const cluster = new ecs.Cluster(this, 'TestCluster', { vpc });\n\n    const fargateTaskDefinition = new ecs.FargateTaskDefinition(this, 'SampleAppTaskDefinition', {\n      cpu: 2048,\n      memoryLimitMiB: 4096,\n    });\n\n    fargateTaskDefinition.addContainer('app', {\n      image: ecs.ContainerImage.fromRegistry('test/sample-app'),\n    });\n\n    new appsignals.ApplicationSignalsIntegration(this, 'ApplicationSignalsIntegration', {\n      taskDefinition: fargateTaskDefinition,\n      instrumentation: {\n        sdkVersion: appsignals.JavaInstrumentationVersion.V2_10_0,\n      },\n      serviceName: 'sample-app',\n      cloudWatchAgentSidecar: {\n        containerName: 'cloudwatch-agent',\n        enableLogging: true,\n        cpu: 256,\n        memoryLimitMiB: 512,\n      }\n    });\n\n    new ecs.FargateService(this, 'MySampleApp', {\n      cluster: cluster,\n      taskDefinition: fargateTaskDefinition,\n      desiredCount: 1,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging for Redshift Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure logging for a Redshift cluster by specifying a logging bucket and key prefix.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst vpc = new ec2.Vpc(this, 'Vpc');\nconst bucket = s3.Bucket.fromBucketName(this, 'bucket', 'amzn-s3-demo-bucket');\n\nconst cluster = new Cluster(this, 'Redshift', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc,\n  loggingProperties: {\n    loggingBucket: bucket,\n    loggingKeyPrefix: 'prefix',\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon Redshift module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the Amazon Redshift module in a TypeScript project using AWS CDK. It allows access to Redshift-related constructs and functionalities within the CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-redshift/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as redshift from 'aws-cdk-lib/aws-redshift';\n```\n\n----------------------------------------\n\nTITLE: Defining KMS Key with Specific KeySpec and KeyUsage Using AWS CDK in TypeScript\nDESCRIPTION: Creates a KMS key with explicit key specification and usage properties, such as ECC_SECG_P256K1 for keySpec and SIGN_VERIFY for keyUsage. Useful for cryptographic operations (like signing/verification). KeySpec and KeyUsage must be compatible; otherwise, resource creation will fail. Defaults to SYMMETRIC_DEFAULT (keySpec) and ENCRYPT_DECRYPT (keyUsage) if unspecified. Requires 'aws-cdk-lib/aws-kms'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kms/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst key = new kms.Key(this, 'MyKey', {\n  keySpec: kms.KeySpec.ECC_SECG_P256K1, // Default to SYMMETRIC_DEFAULT\n  keyUsage: kms.KeyUsage.SIGN_VERIFY,    // and ENCRYPT_DECRYPT\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic IVS Recording Configuration\nDESCRIPTION: Creates a recording configuration that specifies how channel streams are recorded to an S3 bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// create an S3 bucket for storing recordings\nconst recordingBucket = new s3.Bucket(this, 'RecordingBucket');\n\n// create a basic recording configuration\nconst recordingConfiguration = new ivs.RecordingConfiguration(this, 'RecordingConfiguration', {\n  bucket: recordingBucket,\n});\n```\n\n----------------------------------------\n\nTITLE: Removed Windows Server 2019 Versions in AWS CDK EC2 Module\nDESCRIPTION: This snippet lists the Windows Server 2019 versions that have been removed from the AWS CDK EC2 module. It includes various configurations with different SQL Server editions, language packs, and security settings. The versions are specified using the WindowsVersion enum from the aws-cdk-lib.aws_ec2 namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_EXPRESS_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_EXPRESS_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_EXPRESS_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2019_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_EXPRESS_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_EXPRESS_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_EXPRESS_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_EXPRESS_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2022_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_CORE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_CORE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_CORE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_CORE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_FULL_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_FULL_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_FULL_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_STIG_FULL_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_TESLA_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_TESLA_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_TESLA_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_TESLA_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_FRENCH_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_FRENCH_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_FRENCH_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_FRENCH_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_GERMAN_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_GERMAN_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_GERMAN_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_GERMAN_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ITALIAN_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ITALIAN_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ITALIAN_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ITALIAN_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2017_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2019_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_JAPANESE_FULL_SQL_2022_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_KOREAN_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_KOREAN_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_KOREAN_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_KOREAN_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_POLISH_FULL_BASE_2023_11_15\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Connection in AWS CDK\nDESCRIPTION: Demonstrates how to configure a network connection for AWS Glue jobs with security groups and subnet settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const securityGroup: ec2.SecurityGroup;\ndeclare const subnet: ec2.Subnet;\nnew glue.Connection(this, 'MyConnection', {\n  type: glue.ConnectionType.NETWORK,\n  securityGroups: [securityGroup],\n  subnet,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Directory Service module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Directory Service module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-directoryservice/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as directoryservice from 'aws-cdk-lib/aws-directoryservice';\n```\n\n----------------------------------------\n\nTITLE: Configuring Repository Deletion Policy\nDESCRIPTION: Sets up a repository with automatic deletion of all images when the repository is removed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst repository = new ecr.Repository(this, 'MyTempRepo', {\n      removalPolicy: RemovalPolicy.DESTROY,\n      emptyOnDelete: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Certificate Authority Resource via AWS CDK in TypeScript\nDESCRIPTION: Demonstrates how to import an existing AWS Certificate Authority into a CDK stack using the static fromCertificateAuthorityArn method of the CertificateAuthority class. Requires the aws-cdk-lib/aws-acmpca module. The snippet expects a valid ARN and a scope/context (this), and returns a CertificateAuthority instance for use in infrastructure definitions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-acmpca/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as acmpca from 'aws-cdk-lib/aws-acmpca';\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst certificateAuthority = acmpca.CertificateAuthority.fromCertificateAuthorityArn(this, 'CA',\n  'arn:aws:acm-pca:us-east-1:123456789012:certificate-authority/023077d8-2bfa-4eb0-8f22-05c96deade77');\n```\n\n----------------------------------------\n\nTITLE: Building an Alpha AWS CDK Package via Lerna - Console Command - Bash\nDESCRIPTION: Invokes lerna to build (and all referenced dependencies) the targeted alpha package within the AWS CDK monorepo using its npm scope. Replace '@aws-cdk/some-package-alpha' with the actual package name. Requires lerna to be installed and bootstrapped.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\n$ npx lerna run build --scope=@aws-cdk/some-package-alpha\n```\n\n----------------------------------------\n\nTITLE: Creating an IVS Channel with Multitrack Video Support\nDESCRIPTION: Creates an IVS channel with multitrack video support. This requires a STANDARD channel type and Fragmented Mp4 container format.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew ivs.Channel(this, 'ChannelWithMultitrackVideo', {\n  type: ivs.ChannelType.STANDARD,\n  containerFormat: ivs.ContainerFormat.FRAGMENTED_MP4,\n  multitrackInputConfiguration: {\n    maximumResolution: ivs.MaximumResolution.HD,\n    policy: ivs.Policy.ALLOW,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Bucket Origin without Access Control\nDESCRIPTION: Sets up a basic S3 bucket origin with no origin access control (OAI/OAC) using S3BucketOrigin.withBucketDefaults()\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nnew cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: {\n    origin: origins.S3BucketOrigin.withBucketDefaults(myBucket)\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Named Custom ECS Deployment Configuration in AWS CDK\nDESCRIPTION: Demonstrates creating a custom CodeDeploy configuration with a specific name. Note that using a custom name prevents CDK from updating the interval/percentage parameters after creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst config = new codedeploy.EcsDeploymentConfig(this, 'CustomConfig', {\n  trafficRouting: new codedeploy.TimeBasedCanaryTrafficRouting({\n    interval: Duration.minutes(15),\n    percentage: 5,\n  }),\n  deploymentConfigName: 'MyDeploymentConfig',\n});\n```\n\n----------------------------------------\n\nTITLE: Visualizing CloudFormation Stack State Diagram\nDESCRIPTION: ASCII diagram showing all possible CloudFormation stack states and their transitions. The diagram includes create, update, rollback, and delete states, with annotations indicating which operations (Create, Update, Delete) occur in each progress state. Also includes special cases like cleanup and failed states.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/CLOUDFORMATION.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n      \n                        \n        <nonexistant>   \n                                          \n             \n                                                    \n                                 REVIEW_IN_PROGRESS \n                                                    \n                                \n                                           \n                \n                \n                  \n                                                                               \n      CREATE_IN_PROGRESS ROLLBACK_IN_PROGRESS    CREATE_FAILED    \n             [C]                        [D]                                   \n                 \n                                                         \n                                              \n                                                                  \n                                                ROLLBACK_FAILED   \n                                                                  \n                                              \n   \n        CREATE_COMPLETE     \n     UPDATE_COMPLETE     \n  UPDATE_ROLLBACK_COMPLETE                                                    \n                                                     \n                                                                               \n                                                                               \n                                                                               \n                                     \n                                                    UPDATE_COMPLETE_         \n     UPDATE_IN_PROGRESS CLEANUP_IN_PROGRESS        \n           [C,U]                                          [D]                \n               \n                                                                               \n                                                            \n                                                                              \n                                                         \n                         (no-rollback)                                       \n                         UPDATE_FAILED                                     \n                                                                              \n                                                          \n                                                                               \n                                                             \n                                                                                \n                           \n      UPDATE_ROLLBACK_                         UPDATE_ROLLBACK_COMPLETE_     \n        IN_PROGRESS          CLEANUP_IN_PROGRESS      \n            [U]                                           [D]              \n                         \n                        \n                        \n    \n      UPDATE_ROLLBACK_  \n           FAILED       \n                        \n    \n               \n               \n               \n            \n     DELETE_IN_PROGRESS                              \n         [D]            DELETE_FAILED    \n                                                      \n             \n                \n                \n                \n     \n                         \n       DELETE_COMPLETE   \n                         \n     \n```\n\n----------------------------------------\n\nTITLE: Demonstrating Input Type Coercion Difference in SDKv3 (TypeScript)\nDESCRIPTION: This snippet illustrates how SDKv3 is more strict with input types, causing the API call to fail when string values are provided instead of numbers for certain parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-custom-resource-sdk-adapter/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst codedeploy = new CodeDeploy();\n\nconst input: CreateDeploymentConfigCommandInput = {\n  deploymentConfigName: 'testtest',\n  computePlatform: 'Lambda',\n  trafficRoutingConfig: {\n      type: \"TimeBasedLinear\",\n      timeBasedLinear: {\n      linearInterval: \"1\" as any, // The type says 'number' but we're forcing strings here\n      linearPercentage:\"5\" as any,\n    },\n  },\n};\n\nawait codedeploy.createDeploymentConfig(input);\n\n// The above call fails with the following message:\n'SerializationException: STRING_VALUE can not be converted to an Integer'\n```\n\n----------------------------------------\n\nTITLE: Including Axios via CDN\nDESCRIPTION: HTML script tags for including Axios via jsDelivr or unpkg CDN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<script src=\"https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js\"></script>\n<script src=\"https://unpkg.com/axios@1.6.7/dist/axios.min.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Normalizing Duplicate Header Keys using AxiosHeaders - JavaScript\nDESCRIPTION: Illustrates normalizing AxiosHeaders when the object has duplicate header keys with different cases, consolidating them into single canonical forms and optionally formatting their case. Depends on the AxiosHeaders API and JavaScript runtime. Inputs are header objects mutated directly, outputs are normalized header maps without duplicates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_44\n\nLANGUAGE: javascript\nCODE:\n```\nconst headers = new AxiosHeaders({\n  'foo': '1',\n});\n\nheaders.Foo = '2';\nheaders.FOO = '3';\n\nconsole.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }\nconsole.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }\nconsole.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }\n```\n\n----------------------------------------\n\nTITLE: Creating OpenSearch Domain with GP3 Volumes\nDESCRIPTION: Configures an OpenSearch domain with GP3 EBS volumes, specifying volume size, throughput, and IOPS.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst gp3Domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_2_5,\n  ebs: {\n    volumeSize: 30,\n    volumeType: ec2.EbsDeviceVolumeType.GP3,\n    throughput: 125,\n    iops: 3000,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a VPC with IPAM-managed IP Addresses in TypeScript\nDESCRIPTION: This snippet illustrates how to create a VPC using VpcV2 with IP address management (IPAM). It demonstrates setting up IPAM pools for both public IPv6 and private IPv4 addresses, and using these pools to allocate IP addresses for the VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst ipam = new Ipam(this, 'Ipam', {\n  operatingRegions: ['us-west-1']\n});\nconst ipamPublicPool = ipam.publicScope.addPool('PublicPoolA', {\n  addressFamily: AddressFamily.IP_V6,\n  awsService: AwsServiceName.EC2,\n  locale: 'us-west-1',\n  publicIpSource: IpamPoolPublicIpSource.AMAZON,\n});\nipamPublicPool.provisionCidr('PublicPoolACidrA', { netmaskLength: 52 } );\n\nconst ipamPrivatePool = ipam.privateScope.addPool('PrivatePoolA', {\n  addressFamily: AddressFamily.IP_V4,\n});\nipamPrivatePool.provisionCidr('PrivatePoolACidrA', { netmaskLength: 8 } );\n\nnew VpcV2(this, 'Vpc', {\n  primaryAddressBlock: IpAddresses.ipv4('10.0.0.0/24'),\n  secondaryAddressBlocks: [\n    IpAddresses.amazonProvidedIpv6({ cidrBlockName: 'AmazonIpv6' }),\n    IpAddresses.ipv6Ipam({\n      ipamPool: ipamPublicPool,\n      netmaskLength: 52,\n      cidrBlockName: 'ipv6Ipam',\n    }),\n    IpAddresses.ipv4Ipam({\n      ipamPool: ipamPrivatePool,\n      netmaskLength: 8,\n      cidrBlockName: 'ipv4Ipam',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple APIs with Same Domain Name\nDESCRIPTION: Demonstrates how to associate multiple HTTP APIs with the same domain name using different mapping keys for routing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\n\ndeclare const handler: lambda.Function;\ndeclare const dn: apigwv2.DomainName;\n\nconst apiDemo = new apigwv2.HttpApi(this, 'DemoApi', {\n  defaultIntegration: new HttpLambdaIntegration('DefaultIntegration', handler),\n  defaultDomainMapping: {\n    domainName: dn,\n    mappingKey: 'demo',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Checking AWS CDK Version\nDESCRIPTION: Command to verify the CDK installation by displaying the version number of the installed CDK toolkit.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/pkglint/lib/banners/l1.deprecated.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncdk --version\n```\n\n----------------------------------------\n\nTITLE: Using New AWS CDK Service Spec Package\nDESCRIPTION: Code snippet showing the package name to use instead of the deprecated version\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/cfnspec/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n@aws-cdk/aws-service-spec\n```\n\n----------------------------------------\n\nTITLE: Importing AWS S3Outposts Construct Library in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the aws-s3outposts module from the aws-cdk-lib package in a TypeScript project, which is necessary to access L1 constructs for AWS S3Outposts with AWS CDK. Users must have the aws-cdk-lib installed as a dependency. The import provides access to S3Outposts resource types as used in AWS CloudFormation. No additional parameters are required for the import itself, and the code can be used as a prerequisite step in any AWS CDK stack involving S3Outposts constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3outposts/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3outposts from 'aws-cdk-lib/aws-s3outposts';\n```\n\n----------------------------------------\n\nTITLE: Default KMS Key Policy Statement for CloudFront OAC Access (JSON)\nDESCRIPTION: Illustrates the default KMS key policy statement automatically generated by AWS CDK's `S3BucketOrigin.withOriginAccessControl()` for SSE-KMS buckets. It allows the CloudFront service principal (`cloudfront.amazonaws.com`) to perform `kms:Decrypt` actions on any resource (`Resource: \"*\"`), conditioned on the source ARN matching any CloudFront distribution within the account (`ArnLike` with `distribution/*`). This policy uses a wildcard due to potential circular dependencies during initial deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Statement\": {\n        \"Effect\": \"Allow\",\n        \"Principal\": {\n            \"Service\": \"cloudfront.amazonaws.com\"\n        },\n        \"Action\": \"kms:Decrypt\",\n        \"Resource\": \"*\",\n        \"Condition\": {\n            \"ArnLike\": {\n                \"AWS:SourceArn\": \"arn:aws:cloudfront::<account ID>:distribution/*\"\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing State Machine Invocation Type in AWS Pipe (TypeScript)\nDESCRIPTION: This snippet shows how to specify the invocation type (e.g., FIRE_AND_FORGET) when targeting an AWS Step Functions state machine via Pipe in AWS CDK (TypeScript). The code configures the target with the chosen invocation type, letting developers control synchronization behavior. Dependencies include AWS CDK constructs for SQS, Step Functions, and Pipes. Key parameters: invocationType. Inputs are SQS queue and state machine objects. Output is a pipe with customized invocation behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetStateMachine: sfn.IStateMachine;\n\nconst pipeTarget = new targets.SfnStateMachine(targetStateMachine, {\n    invocationType: targets.StateMachineInvocationType.FIRE_AND_FORGET,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration from Inline Text in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration from inline plain text. The content type is automatically set to 'text/plain'.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my configuration content.'),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Factory Methods for Secondary Resource Association - AWS CDK - TypeScript\nDESCRIPTION: Provides the recommended signature and extensibility pattern for factory methods that create secondary resources associated with a primary resource construct in AWS CDK. Interfaces LogStreamOptions and LogStreamProps demonstrate prop inheritance for code reuse, while ILogGroup exposes addLogStream with extensible options typing. Designed for discoverability and to allow option sharing across constructs. Dependencies include AWS CDK constructs. Returns created secondary resources with supplied configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface LogStreamOptions {\n  logStreamName?: string;\n}\n\nexport interface LogStreamProps extends LogStreamOptions {\n  logGroup: ILogGroup;\n}\n\nexport interface ILogGroup {\n  addLogStream(id: string, options?: LogStreamOptions): LogStream;\n}\n```\n\n----------------------------------------\n\nTITLE: Running AWS CDK Integration Test with Update Workflow Disabled\nDESCRIPTION: Command to run a specific integration test with the update workflow disabled, which is required for tests involving hosted zones and certificates. This example shows how to run a certificate manager integration test.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/README.md#2025-04-23_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nyarn integ --disable-update-workflow aws-certificatemanager/test/integ.certificate-name\n```\n\n----------------------------------------\n\nTITLE: Asserting Property Absence with New `Match.not` (TypeScript)\nDESCRIPTION: Shows how to assert that a resource (`FOO::BAR`) does not have specific properties using `hasResourceProperties` combined with the `Match.not` matcher from `@aws-cdk/assertions`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nTemplate.fromStack(stack).hasResourceProperties('FOO::BAR', Match.not({\n  prop: 'does not exist',\n}));\n```\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Updating Module Imports for OpenSearch\nDESCRIPTION: Shows how to update import statements when migrating from the aws-elasticsearch module to the aws-opensearchservice module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as es from 'aws-cdk-lib/aws-elasticsearch';\nimport { Domain } from 'aws-cdk-lib/aws-elasticsearch';\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opensearch from 'aws-cdk-lib/aws-opensearchservice';\nimport { Domain } from 'aws-cdk-lib/aws-opensearchservice';\n```\n\n----------------------------------------\n\nTITLE: Opting into Experimental AWS CDK CLI Features using --unstable Flag\nDESCRIPTION: Shows examples of how users can enable experimental AWS CDK CLI features using the `--unstable` flag followed by an identifier for the specific feature (e.g., `--unstable='new-command'` or `--unstable='new-funky-bootstrap'`). This explicit opt-in mechanism allows developers to test new CLI functionality safely before it is considered stable.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ncdk new-command --unstable='new-command'\n\ncdk bootstrap --unstable='new-funky-bootstrap'\n```\n```\n\n----------------------------------------\n\nTITLE: Matching Templates with New `templateMatches` (TypeScript)\nDESCRIPTION: Shows the replacement method `templateMatches` from `@aws-cdk/assertions`. It's called on a `Template` instance and asserts that the stack's synthesized template matches the provided JSON structure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nTemplate.fromStack(stack).templateMatches({/*...*/});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Standard Lambda Function for Lambda@Edge in us-east-1 using AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to create a standard AWS Lambda function (`lambda.Function`) for use with Lambda@Edge when the CDK stack itself is deployed in the `us-east-1` region. This avoids the need for the specialized `EdgeFunction` construct in this specific regional scenario.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// Using a lambda Function instead of an EdgeFunction for stacks in `us-east-`.\nconst myFunc = new lambda.Function(this, 'MyFunction', {\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n  code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring EKS Cluster Endpoint Access\nDESCRIPTION: Configures the endpoint access type for an EKS cluster, restricting access to within the VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n  endpointAccess: eks.EndpointAccess.PRIVATE,\n});\n```\n\n----------------------------------------\n\nTITLE: Multiple Lambda Functions Project Structure\nDESCRIPTION: Shows a project structure with multiple Go Lambda functions sharing common packages. This illustrates a scenario where AssetHashType.OUTPUT would be more appropriate to avoid unnecessary redeployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nlambda-app\n cmd\n    api\n       main.go\n    anotherApi\n        main.go\n go.mod\n go.sum\n pkg\n     auth\n        auth.go\n     middleware\n         middleware.go\n```\n\n----------------------------------------\n\nTITLE: Configuring Audit and Profiler Logs\nDESCRIPTION: Shows how to enable and configure audit and profiler logs with CloudWatch integration and retention settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdb/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as logs from'aws-cdk-lib/aws-logs';\n\ndeclare const myLogsPublishingRole: iam.Role;\ndeclare const vpc: ec2.Vpc;\n\nconst cluster = new docdb.DatabaseCluster(this, 'Database', {\n  masterUser: {\n    username: 'myuser',\n  },\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.MEMORY5, ec2.InstanceSize.LARGE),\n  vpcSubnets: {\n    subnetType: ec2.SubnetType.PUBLIC,\n  },\n  vpc,\n  exportProfilerLogsToCloudWatch: true, // Enable sending profiler logs\n  exportAuditLogsToCloudWatch: true, // Enable sending audit logs\n  cloudWatchLogsRetention: logs.RetentionDays.THREE_MONTHS, // Optional - default is to never expire logs\n  cloudWatchLogsRetentionRole: myLogsPublishingRole, // Optional - a role will be created if not provided\n});\n```\n\n----------------------------------------\n\nTITLE: Deprecated TableOptions Property in AWS CDK DynamoDB\nDESCRIPTION: The serverSideEncryption property in TableOptions is deprecated. Use the encryption property with TableEncryption.AWS_MANAGED instead to achieve the same behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated\nnew Table(this, 'Table', {\n  serverSideEncryption: true\n});\n\n// Use this instead\nnew Table(this, 'Table', {\n  encryption: TableEncryption.AWS_MANAGED\n});\n```\n\n----------------------------------------\n\nTITLE: Sending URL-Encoded Data with URLSearchParams in Axios (JavaScript)\nDESCRIPTION: Demonstrates sending data in `application/x-www-form-urlencoded` format using the native `URLSearchParams` API in an Axios POST request. This is suitable for modern browsers and Node.js v10+. A `URLSearchParams` object is created, data is appended, and it's passed as the request body.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nconst params = new URLSearchParams({ foo: 'bar' });\nparams.append('extraparam', 'value');\naxios.post('/foo', params);\n```\n\n----------------------------------------\n\nTITLE: Defining Locked Python Package Versions for AWS CDK Project\nDESCRIPTION: Specifies exact versions of Python packages to ensure consistent dependency installation. Includes core HTTP-related packages like requests, urllib3, and supporting libraries with their pinned versions for reproducible builds.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/test/lambda-handler-project/lambda/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\ncertifi==2024.7.4\nchardet==3.0.4\nidna==3.7\nurllib3==1.26.19\n# Requests used by this lambda\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Generating RSA Private Key using OpenSSL (Bash)\nDESCRIPTION: Uses the OpenSSL command-line tool to generate a 2048-bit RSA private key. The generated key (which includes the public key component) is saved to a file named `private_key.pem`. This is the first step in creating keys for CloudFront signed URLs/cookies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\nopenssl genrsa -out private_key.pem 2048\n```\n\n----------------------------------------\n\nTITLE: Performing Substitutions in Templated Files with DeployTimeSubstitutedFile\nDESCRIPTION: Shows how to use the DeployTimeSubstitutedFile construct to replace placeholders in a local file with actual values during deployment, useful for creating API specs that reference other CDK resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const myLambdaFunction: lambda.Function;\ndeclare const destinationBucket: s3.Bucket;\n//(Optional) if provided, the resulting processed file would be uploaded to the destinationBucket under the destinationKey name.\ndeclare const destinationKey: string;\ndeclare const role: iam.Role;\n\nnew s3deploy.DeployTimeSubstitutedFile(this, 'MyFile', {\n  source: 'my-file.yaml',\n  destinationKey: destinationKey,\n  destinationBucket: destinationBucket,\n  substitutions: {\n    variableName: myLambdaFunction.functionName,\n  },\n  role: role,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Redshift Table Column Renaming with AWS CDK in TypeScript\nDESCRIPTION: Creates a Redshift table where columns can potentially be renamed by assigning a stable `id` attribute to each column definition. This feature requires enabling the `@aws-cdk/aws-redshift:columnId` feature flag in the CDK context. Requires an existing `cluster` object and the target `databaseName`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nnew Table(this, 'Table', {\n  tableColumns: [\n    { id: 'col1', name: 'col1', dataType: 'varchar(4)' },\n    { id: 'col2', name: 'col2', dataType: 'float' }\n  ],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Reference Project Structure for NodejsFunction\nDESCRIPTION: Illustrates the recommended file structure for using NodejsFunction in an AWS CDK project, showing the organization of Lambda handlers alongside CDK infrastructure code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-nodejs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n lib\n    my-construct.api.ts # Lambda handler for API\n    my-construct.auth.ts # Lambda handler for Auth\n    my-construct.ts # CDK construct with two Lambda functions\n package-lock.json # single lock file\n package.json # CDK and runtime dependencies defined in a single package.json\n tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Enabling ApplicationSignals on ECS with Daemon Mode\nDESCRIPTION: This code demonstrates how to enable ApplicationSignals on ECS EC2 with daemon mode. It creates a separate daemon service for the CloudWatch Agent and configures Python instrumentation for the application service, suitable for ECS on EC2 where the daemon deployment strategy is supported.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-applicationsignals-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Construct } from 'constructs';\nimport * as appsignals from '@aws-cdk/aws-applicationsignals-alpha';\nimport * as cdk from 'aws-cdk-lib';\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\nclass MyStack extends cdk.Stack {\n  public constructor(scope?: Construct, id?: string, props: cdk.StackProps = {}) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'TestVpc', {});\n    const cluster = new ecs.Cluster(this, 'TestCluster', { vpc });\n\n    // Define Task Definition for CloudWatch agent (Daemon)\n    const cwAgentTaskDefinition = new ecs.Ec2TaskDefinition(this, 'CloudWatchAgentTaskDefinition', {\n      networkMode: ecs.NetworkMode.HOST,\n    });\n\n    new appsignals.CloudWatchAgentIntegration(this, 'CloudWatchAgentIntegration', {\n      taskDefinition: cwAgentTaskDefinition,\n      containerName: 'ecs-cwagent',\n      enableLogging: false,\n      cpu: 128,\n      memoryLimitMiB: 64,\n      portMappings: [\n        {\n          containerPort: 4316,\n          hostPort: 4316,\n        },\n        {\n          containerPort: 2000,\n          hostPort: 2000,\n        },\n      ],\n    });\n\n    // Create the CloudWatch Agent daemon service\n    new ecs.Ec2Service(this, 'CloudWatchAgentDaemon', {\n      cluster,\n      taskDefinition: cwAgentTaskDefinition,\n      daemon: true,  // Runs one container per EC2 instance\n    });\n\n    // Define Task Definition for user application\n    const sampleAppTaskDefinition = new ecs.Ec2TaskDefinition(this, 'SampleAppTaskDefinition', {\n      networkMode: ecs.NetworkMode.HOST,\n    });\n\n    sampleAppTaskDefinition.addContainer('app', {\n      image: ecs.ContainerImage.fromRegistry('test/sample-app'),\n      cpu: 0,\n      memoryLimitMiB: 512,\n    });\n\n    // No CloudWatch Agent side car is needed as application container communicates to CloudWatch Agent daemon through host network\n    new appsignals.ApplicationSignalsIntegration(this, 'ApplicationSignalsIntegration', {\n      taskDefinition: sampleAppTaskDefinition,\n      instrumentation: {\n        sdkVersion: appsignals.PythonInstrumentationVersion.V0_8_0\n      },\n      serviceName: 'sample-app'\n    });\n\n    new ecs.Ec2Service(this, 'MySampleApp', {\n      cluster,\n      taskDefinition: sampleAppTaskDefinition,\n      desiredCount: 1,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Personalize Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Personalize module in a TypeScript project using the AWS CDK. It allows access to the Personalize service constructs for infrastructure definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-personalize/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as personalize from 'aws-cdk-lib/aws-personalize';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Lightsail module in TypeScript\nDESCRIPTION: Code snippet demonstrating how to import the AWS Lightsail module in a CDK application. This is the entry point for using Lightsail resources in your infrastructure as code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lightsail/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lightsail from 'aws-cdk-lib/aws-lightsail';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoT Module in TypeScript (CDK)\nDESCRIPTION: Imports the AWS IoT module from the 'aws-cdk-lib'. Note that this module primarily contains L1 constructs as official L2 constructs are not yet available in the core library. Users might need to refer to CloudFormation documentation or the experimental '@aws-cdk/aws-iot-alpha' package for higher-level abstractions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iot/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iot from 'aws-cdk-lib/aws-iot';\n```\n\n----------------------------------------\n\nTITLE: Implementing Device HeartBeat Pattern with Timer Actions\nDESCRIPTION: Example implementation of a Device HeartBeat detector model using timer actions. It shows how to set, reset, and clear timers based on different events, with state transitions when a timer expires.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-actions-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst online = new iotevents.State({\n  stateName: 'Online',\n  onEnter: [{\n    eventName: 'enter-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [\n      new actions.SetTimerAction('MyTimer', {\n        duration: cdk.Duration.seconds(60),\n      }),\n    ],\n  }],\n  onInput: [{\n    eventName: 'input-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [\n      new actions.ResetTimerAction('MyTimer'),\n    ],\n  }],\n  onExit: [{\n    eventName: 'exit-event',\n    actions: [\n      new actions.ClearTimerAction('MyTimer'),\n    ],\n  }],\n});\nconst offline = new iotevents.State({ stateName: 'Offline' });\n\nonline.transitionTo(offline, { when: iotevents.Expression.timeout('MyTimer') });\noffline.transitionTo(online, { when: iotevents.Expression.currentInput(input) });\n```\n\n----------------------------------------\n\nTITLE: Importing AWS X-Ray Module in TypeScript\nDESCRIPTION: This TypeScript code snippet shows how to import the AWS X-Ray module from the core AWS CDK library (`aws-cdk-lib`). This import is the first step to utilize AWS X-Ray resources, such as L1 constructs, within a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-xray/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as xray from 'aws-cdk-lib/aws-xray';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS PCS Module in TypeScript\nDESCRIPTION: Basic import statement to use AWS PCS constructs in an AWS CDK application. This allows access to L1 (CloudFormation-level) constructs for AWS PCS service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pcs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pcs from 'aws-cdk-lib/aws-pcs';\n```\n\n----------------------------------------\n\nTITLE: Granting Repository Pull and Push Access\nDESCRIPTION: Grants an IAM role both pull and push permissions for an ECR repository.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.ServicePrincipal('codebuild.amazonaws.com'),\n});\nrepository.grantPullPush(role);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS WorkSpacesWeb Module - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import the WorkSpacesWeb module from the AWS CDK library using TypeScript. No external dependencies are required beyond aws-cdk-lib, and this import is a prerequisite for interacting with L1 constructs corresponding to AWS::WorkSpacesWeb resources. The statement prepares the environment for resource definition, but no inputs or outputs are handled directly at this stage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-workspacesweb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as workspacesweb from 'aws-cdk-lib/aws-workspacesweb';\n```\n\n----------------------------------------\n\nTITLE: Scheduling Redshift Queries with AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to use AWS CDK (TypeScript) to schedule Amazon Redshift queries by creating an event rule that triggers at a specified rate. It imports Redshift Serverless modules, declares the Redshift workgroup, configures a CloudWatch Events rule for periodic execution, sets up a dead letter SQS queue for failed invocations, and binds the RedshiftQuery target with multiple SQL statements to the rule. Required dependencies include the AWS CDK libraries for Redshift Serverless, CloudWatch Events, and SQS. Key parameters are the workgroup ARN, database name, dead letter queue, and an array of SQL queries to execute.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-events-targets/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as redshiftserverless from 'aws-cdk-lib/aws-redshiftserverless'\n\ndeclare const workgroup: redshiftserverless.CfnWorkgroup;\n\nconst rule = new events.Rule(this, 'Rule', {\n  schedule: events.Schedule.rate(cdk.Duration.hours(1)),\n});\n\nconst dlq = new sqs.Queue(this, 'DeadLetterQueue');\n\nrule.addTarget(new targets.RedshiftQuery(workgroup.attrWorkgroupWorkgroupArn, {\n  database: 'dev',\n  deadLetterQueue: dlq,\n  sql: ['SELECT * FROM foo','SELECT * FROM baz'],\n}));\n```\n\n----------------------------------------\n\nTITLE: OAI to OAC Migration Step 1\nDESCRIPTION: Adds OAC bucket policy while maintaining OAI access during migration\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst stack = new Stack();\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst s3Origin = new origins.S3Origin(myBucket);\nconst distribution = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: s3Origin },\n});\n\nconst distributionArn = stack.formatArn(\n  {\n    service: 'cloudfront',\n    region: '',\n    resource: 'distribution',\n    resourceName: distribution.distributionId,\n    arnFormat: cdk.ArnFormat.SLASH_RESOURCE_NAME\n  }\n);\n\nconst cloudfrontSP = new iam.ServicePrincipal('cloudfront.amazonaws.com');\n\nconst oacBucketPolicyStatement = new iam.PolicyStatement(\n  {\n    effect: iam.Effect.ALLOW,\n    principals: [cloudfrontSP],\n    actions: ['s3:GetObject'],\n    resources: [myBucket.arnForObjects('*')],\n    conditions: {\n      \"StringEquals\": {\n        \"AWS:SourceArn\": distributionArn\n      }\n    }\n  }\n)\n\nmyBucket.addToResourcePolicy(oacBucketPolicyStatement);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SSMContacts Module with AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the SSMContacts module from aws-cdk-lib for use in AWS CDK applications written in TypeScript. The imported module enables developers to interact with SSMContacts resources by using automatically generated L1 constructs, closely mirroring direct CloudFormation resource usage. Prior to usage, ensure that aws-cdk-lib is installed as a dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssmcontacts/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ssmcontacts from 'aws-cdk-lib/aws-ssmcontacts';\n```\n\n----------------------------------------\n\nTITLE: Importing MediaPackageV2 module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the MediaPackageV2 module in a TypeScript project using the AWS CDK. It allows access to MediaPackageV2 constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediapackagev2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediapackage from 'aws-cdk-lib/aws-mediapackagev2';\n```\n\n----------------------------------------\n\nTITLE: Setting Table Class with TableV2 in TypeScript\nDESCRIPTION: This snippet shows how to configure the table class for a DynamoDB table using the TableV2 construct, demonstrating the use of the STANDARD_INFREQUENT_ACCESS class.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  tableClass: dynamodb.TableClass.STANDARD_INFREQUENT_ACCESS,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Timer Duration Using IoT Events Expression\nDESCRIPTION: Demonstrates setting timer duration using an IoT Events Expression that references an attribute from the input payload. This allows for dynamic timer durations based on input data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-actions-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nnew actions.SetTimerAction('MyTimer', {\n  durationExpression: iotevents.Expression.inputAttribute(input, 'payload.durationSeconds'),\n})\n```\n\n----------------------------------------\n\nTITLE: Running Build and Compatibility Checks for AWS CDK Package using Yarn\nDESCRIPTION: Shows the shell commands using Yarn to first build an AWS CDK package (`yarn build`) and then run compatibility checks (`yarn compat`). This process helps identify potential breaking API surface changes introduced in the codebase.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\n```shell\n$ yarn build\n$ yarn compat\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Identity Pools\nDESCRIPTION: Demonstrates how to import existing identity pools into a CDK stack using either the Identity Pool Id or ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nIdentityPool.fromIdentityPoolId(this, 'my-imported-identity-pool',\n  'us-east-1:dj2823ryiwuhef937');\nIdentityPool.fromIdentityPoolArn(this, 'my-imported-identity-pool',\n  'arn:aws:cognito-identity:us-east-1:123456789012:identitypool/us-east-1:dj2823ryiwuhef937');\n```\n\n----------------------------------------\n\nTITLE: Configuring text format access logging for a VirtualNode\nDESCRIPTION: Shows how to specify a text format for access logging in a VirtualNode. This is an alternative to the JSON format demonstrated in the previous example.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n  accessLog: appmesh.AccessLog.fromFilePath('/dev/stdout', appmesh.LoggingFormat.fromText('test_pattern')),\n```\n\n----------------------------------------\n\nTITLE: Importing a Route53 Hosted Zone with Known Attributes in TypeScript\nDESCRIPTION: Imports an existing Route53 hosted zone when both the zone name and ID are known. This approach avoids the need for lookups during deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst zone = route53.HostedZone.fromHostedZoneAttributes(this, 'MyZone', {\n  zoneName: 'example.com',\n  hostedZoneId: 'ZOJJZC49E0EPZ',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS DeviceFarm Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS DeviceFarm module in a TypeScript CDK project. It allows access to DeviceFarm constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-devicefarm/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as devicefarm from 'aws-cdk-lib/aws-devicefarm';\n```\n\n----------------------------------------\n\nTITLE: Linting a Package Independently - yarn lint - Bash\nDESCRIPTION: This snippet runs 'yarn lint' within a package directory to execute all configured linters for that package. Requires package-level lint scripts and dependencies to be properly set up. Used for code quality and style checking within a specific module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nyarn lint\n```\n\n----------------------------------------\n\nTITLE: Retrieving WebSocket API URLs in TypeScript (CDK)\nDESCRIPTION: This snippet shows how to access the WebSocket URL (`wss://...`) and the callback URL (`https://...`) for a deployed WebSocket API stage. These URLs are properties of the `WebSocketStage` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const webSocketStage: apigwv2.WebSocketStage;\n\nconst webSocketURL = webSocketStage.url;\n// wss://${this.api.apiId}.execute-api.${s.region}.${s.urlSuffix}/${urlPath}\nconst callbackURL = webSocketStage.callbackUrl;\n// https://${this.api.apiId}.execute-api.${s.region}.${s.urlSuffix}/${urlPath}\n```\n```\n\n----------------------------------------\n\nTITLE: Visualizing VPC and Stage Dependencies in Markdown Diagram\nDESCRIPTION: This snippet is a Markdown ASCII diagram illustrating the relationship between a central VPC stack and two application stacks organized within separate Stages. It demonstrates potential cross-Stage dependencies in a CI/CD context as considered in the AWS CDK documentation. There are no programming dependencies or parameters as this is a visual aid intended for conceptual clarity, and no functional code is present. The diagram input is text-only, with outputs intended for Markdown renderers that display monospaced diagrams.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cx-api/design/NESTED_ASSEMBLIES.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n                      \n                                     \n                         VpcStack    \n                                     \n                      \n                              \n                              \n                              \n                \n                                           \n     \nStage                                             Stage\n                                                       \n                       \n                                                     \n          App1Stack               App2Stack          \n                                                     \n                       \n                                                         \n     \n```\n```\n\n----------------------------------------\n\nTITLE: Associating a Tracker with GeofenceCollections\nDESCRIPTION: Shows how to create a Tracker with associated GeofenceCollections and how to add more GeofenceCollections later. This association enables position updates sent to the tracker to be evaluated against the geofences.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const geofenceCollection: location.GeofenceCollection;\ndeclare const geofenceCollectionForAdd: location.GeofenceCollection;\ndeclare const tracker: location.Tracker;\n\nconst tracker = new location.Tracker(this, 'Tracker', {\n  trackerName: 'MyTracker',\n  geofenceCollections: [geofenceCollection],\n});\n\ntracker.addGeofenceCollections(geofenceCollectionForAdd);\n```\n\n----------------------------------------\n\nTITLE: Granting Redshift Privileges (App 2 - Import) using AWS CDK\nDESCRIPTION: Illustrates the second part of a scenario showing potential privilege management conflicts. This snippet imports references to an existing Redshift user and table (presumably created by another app or process) and grants `INSERT` permission. If the first application later revokes the permission, this grant might become ineffective, leading to an inconsistent state. Requires `User.fromUserAttributes`, `Table.fromTableAttributes`, `SecretValue`, and `TableAction` imports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts fixture=cluster\nconst databaseName = 'databaseName';\nconst username = 'myuser'\nconst tableName = 'mytable'\n\nconst user = User.fromUserAttributes(this, 'User', {\n  username: username,\n  password: SecretValue.unsafePlainText('NOT_FOR_PRODUCTION'),\n  cluster: cluster,\n  databaseName: databaseName,\n});\nconst table = Table.fromTableAttributes(this, 'Table', {\n  tableName: tableName,\n  tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n  cluster: cluster,\n  databaseName: 'databaseName',\n});\ntable.grant(user, TableAction.INSERT);\n```\n```\n\n----------------------------------------\n\nTITLE: Using Enum-like Class in AWS CDK\nDESCRIPTION: Example of using an Enum-like Class with predefined options when instantiating a construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew BoomBoom(this, 'Boom', {\n  option: MyOption.COMMON_OPTION_1\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Python Shell Job with Optional Parameters in AWS CDK\nDESCRIPTION: Shows how to create a Python Shell Job with additional configuration options including custom name, Python version, capacity, and other settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PythonShellJob(stack, 'PythonShellJob', {\n  jobName: 'PythonShellJobCustomName',\n  description: 'This is a description',\n  pythonVersion: glue.PythonVersion.TWO,\n  maxCapacity: glue.MaxCapacity.DPU_1,\n  role,\n  script,\n  glueVersion: glue.GlueVersion.V2_0,\n  continuousLogging: { enabled: false },\n  workerType: glue.WorkerType.G_2X,\n  maxConcurrentRuns: 100,\n  timeout: cdk.Duration.hours(2),\n  connections: [glue.Connection.fromConnectionName(stack, 'Connection', 'connectionName')],\n  securityConfiguration: glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'SecurityConfig', 'securityConfigName'),\n  tags: {\n    FirstTagName: 'FirstTagValue',\n    SecondTagName: 'SecondTagValue',\n    XTagName: 'XTagValue',\n  },\n  numberOfWorkers: 2,\n  maxRetries: 2,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining NamespaceOptions Interface for ECS Cloud Map Integration in TypeScript\nDESCRIPTION: Interface defining the options for creating a Cloud Map namespace in an ECS cluster. It includes the namespace name, type, and VPC configuration parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-service-discovery-integration.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface NamespaceOptions {\n  /**\n   * The domain name for the namespace, such as foo.com\n   */\n  name: string;\n\n  /**\n   * The type of CloudMap Namespace to create in your cluster\n   *\n   * @default PrivateDns\n   */\n  type?: cloudmap.NamespaceType;\n\n  /**\n   * The Amazon VPC that you want to associate the namespace with. Required for Private DNS namespaces\n   *\n   * @default VPC of the cluster for Private DNS Namespace, otherwise none\n   */\n  vpc?: ec2.IVpc;\n}\n```\n\n----------------------------------------\n\nTITLE: Using an SNS Topic as a Custom Resource Provider in TypeScript\nDESCRIPTION: Shows how to configure an AWS CDK `CustomResource` to use an Amazon SNS topic as its provider. An `sns.Topic` is instantiated, and its ARN (`topic.topicArn`) is assigned to the `serviceToken` property of the `CustomResource`. CloudFormation sends lifecycle events (CREATE/UPDATE/DELETE) as notifications to this topic, which must be processed by external logic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst topic = new sns.Topic(this, 'MyProvider');\n\nnew CustomResource(this, 'MyResource', {\n  serviceToken: topic.topicArn\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Managing Multi-Region Locations for GameLift Fleet in TypeScript\nDESCRIPTION: Configures a GameLift fleet to deploy resources to multiple AWS regions beyond the home region. This allows hosting game sessions closer to players and includes capacity specifications for each location.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const build: gamelift.Build;\n\n// Locations can be added directly through constructor\nconst fleet = new gamelift.BuildFleet(this, 'Game server fleet', {\n  fleetName: 'test-fleet',\n  content: build,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  runtimeConfiguration: {\n    serverProcesses: [{\n      launchPath: '/local/game/GameLiftExampleServer.x86_64',\n    }]\n  },\n  locations: [ {\n    region: 'eu-west-1',\n    capacity: {\n      desiredCapacity: 5,\n      minSize: 2,\n      maxSize: 10\n    }\n  }, {\n    region: 'us-east-1',\n    capacity: {\n      desiredCapacity: 5,\n      minSize: 2,\n      maxSize: 10\n    }\n  }]\n});\n\n// Or through dedicated methods\nfleet.addLocation('ap-southeast-1', 5, 2, 10);\n```\n\n----------------------------------------\n\nTITLE: Specifying Server SDK Version for GameLift Build in TypeScript\nDESCRIPTION: This snippet shows how to specify the server SDK version when creating a GameLift Build. It's useful when integrating a game server build with a specific version of the GameLift SDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst build = new gamelift.Build(this, 'Build', {\n  content: gamelift.Content.fromBucket(bucket, \"sample-asset-key\"),\n  serverSdkVersion: '5.0.0',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a CloudFormation Stack Output (AWS CDK, TypeScript)\nDESCRIPTION: A CfnOutput is defined in this snippet to export or display values from a stack. It includes the output value, an optional description, and optional exportName for registering CloudFormation exports. This can be used to pass data (such as bucket names or ARNs) to other stacks or for human-visible outputs after a deployment. Requires aws-cdk-lib CfnOutput and a meaningful value to export.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nnew CfnOutput(this, 'OutputName', {\n  value: myBucket.bucketName,\n  description: 'The name of an S3 bucket', // Optional\n  exportName: 'TheAwesomeBucket', // Registers a CloudFormation export named \"TheAwesomeBucket\"\n});\n```\n\n----------------------------------------\n\nTITLE: Updated KMS Policy Condition Using StringEquals Specific ID (JSON)\nDESCRIPTION: Presents the modified `Condition` block for the KMS key policy, implementing best security practices after initial deployment. It replaces the `ArnLike` operator with `StringEquals` and substitutes the wildcard (`*`) with the specific CloudFront distribution ID (`<CloudFront distribution ID>`) in the `AWS:SourceArn`, ensuring only the designated distribution can use the key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n  \"Condition\": {\n      \"StringEquals\": {\n          \"AWS:SourceArn\": \"arn:aws:cloudfront::111122223333:distribution/<CloudFront distribution ID>\"\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for a CDK Library in package.json\nDESCRIPTION: Specifies `peerDependencies` and `devDependencies` for an NPM package that is a CDK library. It sets a minimum required version range for `aws-cdk-lib` and `constructs` in `peerDependencies` for compatibility, and a specific older version in `devDependencies` for testing against the minimum supported version.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n```javascript\n{\n  \"peerDependencies\": {\n    \"aws-cdk-lib\": \"^2.38.0\",\n    \"constructs\": \"^10.0.0\"\n  },\n  \"devDependencies\": {\n    /* Install the oldest version for testing so we don't accidentally use features from a newer version than we declare */\n    \"aws-cdk-lib\": \"2.38.0\"\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Changelog Feature Documentation\nDESCRIPTION: Markdown entries documenting new features and improvements added to AWS CDK\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CHANGELOG.v2.alpha.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Features\n\n* **location:** throw ValidationError instead of untyped errors ([#34174](https://github.com/aws/aws-cdk/issues/34174)) ([2ecf14a](https://github.com/aws/aws-cdk/commit/2ecf14a0c3e5a988532975536980d81589ea448e))\n* **msk:** throw ValidationError instead of untyped errors ([#34214](https://github.com/aws/aws-cdk/issues/34214)) ([02cb5a4](https://github.com/aws/aws-cdk/commit/02cb5a4284e9aad2f8cc4fc8fcb2c1aebe8f92be))\n```\n\n----------------------------------------\n\nTITLE: AxiosHeaders Usage (JavaScript)\nDESCRIPTION: Shows how to use the AxiosHeaders class to manipulate headers in Axios requests. This class provides a Map-like API for case-insensitive header manipulation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_39\n\nLANGUAGE: javascript\nCODE:\n```\naxios.interceptors.request.use((request: InternalAxiosRequestConfig) => {\n    request.headers.set('My-header', 'value');\n\n    request.headers.set({\n      \"My-set-header1\": \"my-set-value1\",\n      \"My-set-header2\": \"my-set-value2\"\n    });\n    \n    request.headers.set('User-Agent', false); // disable subsequent setting the header by Axios\n\n    request.headers.setContentType('text/plain');\n  \n    request.headers['My-set-header2'] = 'newValue' // direct access is deprecated\n  \n    return request;\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Generating CloudFormation Export for Cross-Stack Reference (JSON)\nDESCRIPTION: Illustrates the CloudFormation `Outputs` section generated by CDK for `stack1` in the same-region cross-stack reference example. It defines an `Export` containing the ARN of the S3 bucket, making it available for other stacks to import.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n \"Outputs\": {\n  \"ExportsOutputFnGetAttBucket83908E77Arn063C8555\": {\n   \"Value\": {\n    \"Fn::GetAtt\": [\n     \"Bucket83908E77\",\n     \"Arn\"\n    ]\n   },\n   \"Export\": {\n    \"Name\": \"stack1:ExportsOutputFnGetAttBucket83908E77Arn063C8555\"\n   }\n  }\n }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Size Utility Methods with AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates instantiating Size objects with static factory methods corresponding to binary digital storage units (KiB, MiB, GiB, TiB, PiB) for use in constructs. Depends on AWS CDK Size class. Inputs are numeric quantities, and the output is a Size instance. Used for specifying capacities and storage parameters in AWS resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nSize.kibibytes(200) // 200 KiB\nSize.mebibytes(5)   // 5 MiB\nSize.gibibytes(40)  // 40 GiB\nSize.tebibytes(200) // 200 TiB\nSize.pebibytes(3)   // 3 PiB\n```\n\n----------------------------------------\n\nTITLE: Creating a SageMaker Endpoint Configuration with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a SageMaker endpoint configuration with multiple production variants using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\n\ndeclare const modelA: sagemaker.Model;\ndeclare const modelB: sagemaker.Model;\n\nconst endpointConfig = new sagemaker.EndpointConfig(this, 'EndpointConfig', {\n  instanceProductionVariants: [\n    {\n      model: modelA,\n      variantName: 'modelA',\n      initialVariantWeight: 2.0,\n    },\n    {\n      model: modelB,\n      variantName: 'variantB',\n      initialVariantWeight: 1.0,\n    },\n  ]\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Function with Local Code Asset in TypeScript\nDESCRIPTION: Example of defining an AWS Lambda function in a CDK app that uses a local code asset. This demonstrates the pattern that will receive automatic metadata injection.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/code-asset-metadata.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'MyHandler', {\n  // ...\n  code: lambda.Code.asset('/path/to/handler')\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Spot Bid Percentage on Managed EC2 Compute Environment with AWS Batch in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to configure a managed EC2-based AWS Batch compute environment to use spot instances with a custom maximum spot bid percentage (20% of on-demand price). Requires '@aws-cdk/aws-ec2', '@aws-cdk/aws-batch', and a VPC instance. The relevant properties are 'spot', which enables spot capacity, and 'spotBidPercentage', which limits accepted Spot bids.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(this, 'VPC');\nnew batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n   vpc,\n   spot: true,\n   spotBidPercentage: 20,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS BillingConductor Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS BillingConductor module from the core AWS CDK library (`aws-cdk-lib`). This import provides access to the low-level (L1) constructs corresponding to AWS BillingConductor CloudFormation resources, allowing interaction with the service within a CDK application. The `aws-cdk-lib` package must be installed as a dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-billingconductor/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as billingconductor from 'aws-cdk-lib/aws-billingconductor';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CUR Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS CUR module in a TypeScript CDK project. It allows access to CUR-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cur/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cur from 'aws-cdk-lib/aws-cur';\n```\n\n----------------------------------------\n\nTITLE: Creating Lambda Function with Asset Using AppStagingSynthesizer\nDESCRIPTION: Example of using AppStagingSynthesizer with a Lambda function that includes file assets. Demonstrates asset handling capabilities.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n  }),\n});\n\nconst stack = new Stack(app, 'my-stack');\n\nnew lambda.Function(stack, 'lambda', {\n  code: lambda.AssetCode.fromAsset(path.join(__dirname, 'assets')),\n  handler: 'index.handler',\n  runtime: lambda.Runtime.PYTHON_3_9,\n});\n\napp.synth();\n```\n\n----------------------------------------\n\nTITLE: Stream Progress Tracking with Axios (Node.js)\nDESCRIPTION: Shows how to track upload progress for a readable stream in Node.js using Axios. This is useful for monitoring the progress of large file uploads or data streams.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_37\n\nLANGUAGE: javascript\nCODE:\n```\nconst {data} = await axios.post(SERVER_URL, readableStream, {\n   onUploadProgress: ({progress}) => {\n     console.log((progress * 100).toFixed(2));\n   },\n  \n   headers: {\n    'Content-Length': contentLength\n   },\n\n   maxRedirects: 0 // avoid buffering the entire stream\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS FinSpace Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import the AWS FinSpace constructs module from the AWS CDK library in TypeScript. The import statement is a prerequisite for using any AWS::FinSpace resources within a CDK application. Ensure that the 'aws-cdk-lib' and its aws-finspace subpackage are installed as dependencies in your project. No parameters are required for this import, and it enables further development using CDK's L1 constructs for FinSpace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-finspace/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as finspace from 'aws-cdk-lib/aws-finspace';\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon Pinpoint Module in AWS CDK\nDESCRIPTION: Example showing how to import the Amazon Pinpoint module in a TypeScript CDK application. This import statement provides access to L1 constructs for working with Pinpoint resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pinpoint/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pinpoint from 'aws-cdk-lib/aws-pinpoint';\n```\n\n----------------------------------------\n\nTITLE: Using API Destination as Pipe Enrichment in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe that uses an API destination as an enrichment. The API destination can process and modify events before they reach the target.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-enrichments-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\ndeclare const apiDestination: events.ApiDestination;\n\nconst enrichment = new enrichments.ApiDestinationEnrichment(apiDestination);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SomeSource(sourceQueue),\n  enrichment,\n  target: new SomeTarget(targetQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Rekognition module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Rekognition module in a TypeScript CDK project. It allows access to Rekognition constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rekognition/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as rekognition from 'aws-cdk-lib/aws-rekognition';\n```\n\n----------------------------------------\n\nTITLE: Granting Write Permissions to CloudWatch Log Group in TypeScript\nDESCRIPTION: Simplified method to grant write permissions (CreateLogStream and PutLogEvents) to a CloudWatch Log Group for the Elasticsearch service principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-logs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst logGroup = new logs.LogGroup(this, 'LogGroup');\nlogGroup.grantWrite(new iam.ServicePrincipal('es.amazonaws.com'));\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Staging Stack in TypeScript\nDESCRIPTION: Shows how to create a custom staging stack by subclassing DefaultStagingStack or implementing the IStagingResources interface from scratch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CustomStagingStackOptions extends DefaultStagingStackOptions {}\n\nclass CustomStagingStack extends DefaultStagingStack {\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AppRegistry Module in TypeScript\nDESCRIPTION: Demonstrates how to import the AWS Service Catalog App Registry module in a TypeScript CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appreg from '@aws-cdk/aws-servicecatalogappregistry-alpha';\n```\n\n----------------------------------------\n\nTITLE: Creating ELBv2 Route53 Alias Record\nDESCRIPTION: Demonstrates creating a Route53 A-record that aliases to an Application Load Balancer with optional health check evaluation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elbv2 from 'aws-cdk-lib/aws-elasticloadbalancingv2';\n\ndeclare const zone: route53.HostedZone;\ndeclare const lb: elbv2.ApplicationLoadBalancer;\n\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(\n    new targets.LoadBalancerTarget(lb, {\n      evaluateTargetHealth: true,\n    }),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Asserting Resource Absence with Old `not.toHaveResource` (TypeScript)\nDESCRIPTION: Demonstrates using the `.not` modifier with the deprecated `toHaveResource` matcher from `@aws-cdk/assert` to assert that a specific resource type (`FOO::BAR`) *does not* exist in the stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// asserting that the stack does not have a particular resource.\nexpect(stack).not.toHaveResource('FOO::BAR');\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PlaceIndex in AWS Location Service (Legacy)\nDESCRIPTION: Creates a legacy PlaceIndex resource with a specified data source. PlaceIndex resources enable searching geolocation information using a selected data provider.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew location.PlaceIndex(this, 'PlaceIndex', {\n  placeIndexName: 'MyPlaceIndex', // optional, defaults to a generated name\n  dataSource: location.DataSource.HERE, // optional, defaults to Esri\n});\n```\n\n----------------------------------------\n\nTITLE: Example Usage of New API - TypeScript Configuration\nDESCRIPTION: Example showing how to use the proposed new API to configure an Aurora cluster with mixed provisioned and serverless instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rds/adr/aurora-serverless-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew rds.DatabaseCluster(this, 'Cluster', {\n  engine: rds.DatabaseClusterEngine.auroraMysql({ version: rds.AuroraMysqlEngineVersion.VER_3_03_0 }),\n  // capacity applies to all serverless instances in the cluster\n  serverlessV2MaxCapacity: 1,\n  serverlessV2MinCapacity: 0.5,\n  writer: ClusterInstance.provisioned('writer', { ...props }),\n  readers: [\n    // puts it in promition tier 0-1\n    ClusterInstance.serverlessV2('reader1', { scaleWithWriter: true, ...additionalProps }),\n    ClusterInstance.serverlessV2('reader2'),\n    ClusterInstance.serverlessV2('reader3'),\n    // illustrating how it might be possible to add support for groups in the future.\n    // currently not supported by CFN\n    ClusterInstance.fromReaderGroup('analytics', { ...readerProps }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Rendered IAM Policy Resource String Example - Policy Report - JSON\nDESCRIPTION: This JSON snippet shows the user-friendly rendering of a CloudFormation-generated ARN used in CDK's policy report format, replacing pseudo-parameters with placeholders. Intended to make policy review clearer to users.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n\"arn:(PARTITION):iam::(ACCOUNT):role/Role\"\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in Assertions\nDESCRIPTION: Shows usage of Match utility for complex pattern matching in assertions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nmessage.expect(ExpectedResult.objectLike({\n  Messages: Match.arrayWith([\n    {\n      Payload: Match.serializedJson({ key: 'value' }),\n    },\n    {\n      Body: {\n        Values: Match.arrayWith([{ Asdf: 3 }]),\n        Message: Match.stringLikeRegexp('message'),\n      },\n    },\n  ]),\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Source with Custom Polling Parameters for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a customized SQS source that specifies batch size and batching window duration. This allows for optimizing the frequency and volume of message processing from the source queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-sources-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeSource = new sources.SqsSource(sourceQueue, {\n  batchSize: 10,\n  maximumBatchingWindow: cdk.Duration.seconds(10)\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: pipeSource,\n  target: new SqsTarget(targetQueue)\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration from File in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration from a local file. The content type will be automatically determined by the file extension unless explicitly specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromFile('config.json'),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS LookoutMetrics Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS LookoutMetrics module in a CDK application. This import statement provides access to the L1 constructs for LookoutMetrics service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lookoutmetrics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lookoutmetrics from 'aws-cdk-lib/aws-lookoutmetrics';\n```\n\n----------------------------------------\n\nTITLE: Adding AWS CLI Lambda Layer with AWS CDK - TypeScript\nDESCRIPTION: This TypeScript code shows how to import the AwsCliLayer from aws-cdk-lib/lambda-layer-awscli and attach it to an existing Lambda function using the AWS CDK. To use this, your environment must have AWS CDK and the aws-cdk-lib packages installed. The Lambda function to which this layer is attached should use a Python 3.x runtime, as required by the module. The AWS CLI will be available under /opt/awscli/aws in the Lambda environment. Inputs include a Lambda function reference; the output is the function with the attached layer containing AWS CLI v1.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/lambda-layer-awscli/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// AwsCliLayer bundles the AWS CLI in a lambda layer\nimport { AwsCliLayer } from 'aws-cdk-lib/lambda-layer-awscli';\n\ndeclare const fn: lambda.Function;\nfn.addLayers(new AwsCliLayer(this, 'AwsCliLayer'));\n```\n\n----------------------------------------\n\nTITLE: Using String Matchers in AWS CDK Template Testing\nDESCRIPTION: Shows how to use Match.stringLikeRegexp() to assert string properties using regular expressions in CDK template resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Template\": \"const includeHeaders = true;\"\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Template: Match.stringLikeRegexp('includeHeaders = (true|false)'),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Template: Match.stringLikeRegexp('includeHeaders = null'),\n});\n```\n\n----------------------------------------\n\nTITLE: Triggering Lambda on CloudTrail Events via EventBridge using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates creating an Amazon EventBridge rule that triggers an AWS Lambda function based on specific CloudTrail events. It uses `cloudtrail.Trail.onEvent` to define the rule and target, and `eventRule.addEventPattern` to filter events (e.g., for S3 actions from a specific account). Requires `aws-lambda`, `aws-events`, and `aws-events-targets` modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunctionHandler = new lambda.Function(this, 'MyFunction', {\n  code: lambda.Code.fromAsset('resource/myfunction'),\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  handler: 'index.handler',\n});\n\nconst eventRule = cloudtrail.Trail.onEvent(this, 'MyCloudWatchEvent', {\n  target: new targets.LambdaFunction(myFunctionHandler),\n});\n\neventRule.addEventPattern({\n  account: ['123456789012'],\n  source: ['aws.s3'],\n});\n```\n\n----------------------------------------\n\nTITLE: Simplified LoadBalancer Address Retrieval in TypeScript\nDESCRIPTION: This snippet shows a simplified way to access a LoadBalancer service address using the built-in getServiceLoadBalancerAddress method on the cluster object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst loadBalancerAddress = cluster.getServiceLoadBalancerAddress('my-service');\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for SageMaker Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a SageMaker pipeline target and input transformation. This allows customizing the payload sent to the SageMaker pipeline.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetPipeline: sagemaker.IPipeline;\n\nconst pipelineTarget = new targets.SageMakerTarget(targetPipeline, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipelineTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing S3 Source Action Variables in TypeScript\nDESCRIPTION: This snippet shows how to access output variables from an S3SourceAction (like the object version ID) in a subsequent CodeBuildAction within the same pipeline. It defines a `variablesNamespace` in the source action and references the variable using `sourceAction.variables.versionId` in the environment variables of the build action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst key = 'some/key.zip';\ndeclare const sourceBucket: s3.Bucket;\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.S3SourceAction({\n  actionName: 'S3Source',\n  bucketKey: key,\n  bucket: sourceBucket,\n  output: sourceOutput,\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\ndeclare const project: codebuild.PipelineProject;\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    VERSION_ID: {\n      value: sourceAction.variables.versionId,\n    },\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an IVS Channel with RTMP Ingest\nDESCRIPTION: Creates an IVS channel with RTMP ingest enabled. This is less secure than the default RTMPS but may be required for specific use cases.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst myRtmpChannel = new ivs.Channel(this, 'myRtmpChannel', {\n  type: ivs.ChannelType.STANDARD,\n  insecureIngest: true, // default value is false\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Application Stack in Specific Region (TypeScript)\nDESCRIPTION: Defines a CDK stack (`AppStack`) explicitly in the `us-east-2` region and creates an `ApplicationLoadBalancedFargateService` within it. This sets up the context for demonstrating cross-region challenges.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst appStack = new Stack(app, 'AppStack', { env: { region: 'us-east-2' } });\nconst service = new ApplicationLoadBalancedFargateService(appStack, 'Service');\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Budgets L1 Constructs in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS Budgets module from the AWS CDK library. This import is necessary to use the automatically generated L1 constructs for interacting with AWS Budgets resources within a CDK application, as L2 constructs are not yet available.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-budgets/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as budgets from 'aws-cdk-lib/aws-budgets';\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Grant Methods in AWS CDK TypeScript\nDESCRIPTION: Provides the signature guidelines for custom, use-case-specific grant methods (e.g., `grantReadWrite`, `grantPutItem`). These methods should be defined on the resource interface, have names prefixed with `grant`, accept an `iam.IGrantable` as the first argument, potentially accept other arguments, and must return an `iam.Grant` object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ngrantXxx(grantee: iam.IGrantable): iam.Grant;\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Execute API ARN\nDESCRIPTION: Creates an ARN for Execute API operations with specific HTTP method, path, and stage parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst api = new apigwv2.HttpApi(this, 'my-api');\nconst arn = api.arnForExecuteApi('GET', '/myApiPath', 'dev');\n```\n\n----------------------------------------\n\nTITLE: Basic Form-Data Usage\nDESCRIPTION: Example showing how to construct a form with string, buffer and file stream fields\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar FormData = require('form-data');\nvar fs = require('fs');\n\nvar form = new FormData();\nform.append('my_field', 'my value');\nform.append('my_buffer', new Buffer(10));\nform.append('my_file', fs.createReadStream('/foo/bar.jpg'));\n```\n\n----------------------------------------\n\nTITLE: Enabling Signed Content Payloads for S3 Bucket Deployment\nDESCRIPTION: Shows how to enable signed content payloads for S3 bucket deployments when bucket policies require them, by setting the signContent option to true.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.IBucket;\n\nnew s3deploy.BucketDeployment(this, 'DeployWithSignedPayloads', {\n  sources: [s3deploy.Source.asset('./website-dist')],\n  destinationBucket: bucket,\n  signContent: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Transforming Payloads in AWS Pipe State Machine Target (TypeScript)\nDESCRIPTION: This snippet demonstrates how to transform the input before it is sent to an AWS Step Functions state machine in an AWS Pipe using AWS CDK (TypeScript). It configures an inputTransformation to extract the event body, along with specifying invocationType. Dependencies are on AWS CDK modules for Pipes, SQS, and Step Functions. The main parameter is inputTransformation, shaping the payload as required by the downstream state machine.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetStateMachine: sfn.IStateMachine;\n\nconst pipeTarget = new targets.SfnStateMachine(targetStateMachine,\n    {\n      inputTransformation: pipes.InputTransformation.fromObject({ body: '<$.body>' }),\n      invocationType: targets.StateMachineInvocationType.FIRE_AND_FORGET,\n    }\n);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing Predefined Signing Platforms with AWS Signer (Text Enum)\nDESCRIPTION: Lists pre-defined platform constants from the AWS Signer CDK construct, which specify supported signing algorithms and platforms. These constants can be used as parameters when configuring signing profiles or jobs in AWS CDK projects, and help developers select the correct signing method for their application. No dependencies are required beyond the AWS CDK Signer module, and this section simply enumerates available options rather than demonstrating instantiation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-signer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPlatform.AWS_IOT_DEVICE_MANAGEMENT_SHA256_ECDSA\nPlatform.AWS_LAMBDA_SHA384_ECDSA\nPlatform.AMAZON_FREE_RTOS_TI_CC3220SF\nPlatform.AMAZON_FREE_RTOS_DEFAULT\n```\n\n----------------------------------------\n\nTITLE: OAI to OAC Migration Step 2\nDESCRIPTION: Replaces S3Origin with S3BucketOrigin.withOriginAccessControl() to complete OAC migration\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst bucket = new s3.Bucket(this, 'Bucket');\nconst s3Origin = origins.S3BucketOrigin.withOriginAccessControl(bucket);\nconst distribution = new cloudfront.Distribution(this, 'Distribution', {\n  defaultBehavior: { origin: s3Origin },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Load Balancer Listener Security Groups - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to restrict load balancer listener connections to specific security groups by using the allowConnectionsFrom property. The setup requires a pre-existing SecurityGroup and LoadBalancer instance. Key parameters include the SecurityGroup array and the external port; output is a listener limited to specified sources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticloadbalancing/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const mySecurityGroup: ec2.SecurityGroup;\ndeclare const lb: elb.LoadBalancer;\nlb.addListener({\n  externalPort: 80,\n  allowConnectionsFrom: [mySecurityGroup],\n});\n```\n\n----------------------------------------\n\nTITLE: Using Axios with TypeScript and Error Handling - TypeScript\nDESCRIPTION: Shows best practices for making requests with Axios in TypeScript, handling errors with type guards, and integrating with asynchronous/await logic. Explains error differentiation strategies using isAxiosError for better reliability in typed error handling. Requires Axios and appropriate TypeScript type definitions. Inputs include typed user objects and HTTP endpoints; outputs capture user data or error processing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nlet user: User = null;\ntry {\n  const { data } = await axios.get('/user?ID=12345');\n  user = data.userDetails;\n} catch (error) {\n  if (axios.isAxiosError(error)) {\n    handleAxiosError(error);\n  } else {\n    handleUnexpectedError(error);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using BEST_FIT Allocation Strategy in Managed EC2 Compute Environment with AWS Batch (TypeScript)\nDESCRIPTION: This snippet shows how to set a managed EC2 AWS Batch compute environment to use the 'BEST_FIT' allocation strategy by explicitly setting the 'allocationStrategy' property. Only the cheapest suitable instance type is selected for jobs until unavailable. Prerequisites are '@aws-cdk/aws-batch', '@aws-cdk/aws-ec2', a VPC, and 'AllocationStrategy'. This property is not available for Fargate compute environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-batch/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.IVpc;\n\nconst computeEnv = new batch.ManagedEc2EcsComputeEnvironment(this, 'myEc2ComputeEnv', {\n  vpc,\n  allocationStrategy: batch.AllocationStrategy.BEST_FIT,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Application Insights Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS Application Insights module from the AWS CDK library (`aws-cdk-lib`). This import is the first step required to define and configure Application Insights resources, primarily using the automatically generated L1 constructs, within a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationinsights/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as applicationinsights from 'aws-cdk-lib/aws-applicationinsights';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS CodeConnections Module in TypeScript\nDESCRIPTION: Shows how to import the AWS CodeConnections module in a TypeScript CDK application. This is the basic import statement needed to use CodeConnections resources in your CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codeconnections/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codeconnections from 'aws-cdk-lib/aws-codeconnections';\n```\n\n----------------------------------------\n\nTITLE: Initializing AppStagingSynthesizer with Default Resources\nDESCRIPTION: Basic setup of AppStagingSynthesizer with default resources configuration. Requires specifying a unique appId and optional bucket encryption settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id', // put a unique id here\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Event Source Interface Definition\nDESCRIPTION: Interface definition for AWS Lambda event sources, showing the bind method requirement.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IEventSource {\n  bind(fn: IFunction): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Proton Module in TypeScript\nDESCRIPTION: Basic import statement to include the AWS Proton module in a CDK application. This allows access to the L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-proton/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as proton from 'aws-cdk-lib/aws-proton';\n```\n\n----------------------------------------\n\nTITLE: Assigning Context in User Profile (~/.cdk.json) - JSON\nDESCRIPTION: Shows user-wide persistent context assignment in the ~/.cdk.json file by placing key-value pairs under the context property. This allows feature flags and configuration to be applied to all CDK projects executed by the same user. This file must be valid JSON and is loaded at runtime if present.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_49\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"context\": {\n    \"@aws-cdk/core:newStyleStackSynthesis\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Node Pools for EKS Auto Mode in TypeScript\nDESCRIPTION: Shows how to configure which node pools to enable in an EKS cluster with Auto Mode using the compute property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'EksAutoCluster', {\n  version: eks.KubernetesVersion.V1_32,\n  defaultCapacityType: eks.DefaultCapacityType.AUTOMODE,\n  compute: {\n    nodePools: ['system', 'general-purpose'],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Cassandra Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the `aws-cassandra` module from the `aws-cdk-lib`. This import is necessary to use the L1 constructs provided by the AWS CDK for provisioning AWS Cassandra resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cassandra/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cassandra from 'aws-cdk-lib/aws-cassandra';\n```\n\n----------------------------------------\n\nTITLE: Axios Instance Creation\nDESCRIPTION: Example of creating a custom Axios instance with specific configuration options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst instance = axios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Secrets Manager module with AWS CDK - TypeScript\nDESCRIPTION: Imports the AWS Secrets Manager constructs from the aws-cdk-lib package. This import is prerequisite for defining Secrets Manager resources or referencing them within AWS CDK TypeScript apps. No parameters; all later secret-related constructs depend on this import.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';\n```\n\n----------------------------------------\n\nTITLE: Associating CDK Pipeline Stages with ApplicationAssociator\nDESCRIPTION: Demonstrates how to associate CDK Pipeline stages with an ApplicationAssociator. This is necessary because pipeline stacks are inside Stages and not directly accessible to ApplicationAssociator.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from \"aws-cdk-lib\";\nimport * as codepipeline from \"aws-cdk-lib/pipelines\";\nimport * as codecommit from \"aws-cdk-lib/aws-codecommit\";\ndeclare const repo: codecommit.Repository;\ndeclare const pipeline: codepipeline.CodePipeline;\ndeclare const beta: cdk.Stage;\nclass ApplicationPipelineStack extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props: ApplicationPipelineStackProps) {\n    super(scope, id, props);\n\n   //associate the stage to application associator.\n   props.application.associateStage(beta);\n   pipeline.addStage(beta);\n  }\n};\n\ninterface ApplicationPipelineStackProps extends cdk.StackProps {\n  application: appreg.ApplicationAssociator;\n};\n\nconst app = new App();\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.createApplicationStack({\n    applicationName: 'MyPipelineAssociatedApplication',\n    stackName: 'MyPipelineAssociatedApplicationStack',\n    env: { account: '123456789012', region: 'us-east-1' },\n  })],\n});\n\nconst cdkPipeline = new ApplicationPipelineStack(app, 'CDKApplicationPipelineStack', {\n    application: associatedApp,\n    env: {account: '123456789012', region: 'us-east-1'},\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies Between Kubernetes Manifests in AWS CDK (TypeScript)\nDESCRIPTION: Illustrates how to enforce deployment order for Kubernetes resources managed by AWS CDK. It creates a Namespace manifest and a Service manifest using `cluster.addManifest`, then uses `service.node.addDependency(namespace)` to ensure the namespace is created before the service that depends on it.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst namespace = cluster.addManifest('my-namespace', {\n  apiVersion: 'v1',\n  kind: 'Namespace',\n  metadata: { name: 'my-app' },\n});\n\nconst service = cluster.addManifest('my-service', {\n  metadata: {\n    name: 'myservice',\n    namespace: 'my-app',\n  },\n  spec: { }, // ...\n});\n\nservice.node.addDependency(namespace); // will apply `my-namespace` before `my-service`.\n```\n\n----------------------------------------\n\nTITLE: Updating IContainerImage Interface with Repository Credentials in TypeScript\nDESCRIPTION: This snippet shows the modification of the IContainerImage interface to include an optional repositoryCredentials property, allowing for the specification of credentials for accessing private container images.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-priv-registry-support.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IContainerImage {\n  // ...\n  readonly imageName: string;\n\n  /**\n   * NEW: The credentials required to access the image\n   */\n  readonly repositoryCredentials?: IRepositoryCreds;\n\n  // ...\n  bind(containerDefinition: ContainerDefinition): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Tag Properties to BaseServiceOptions Interface in TypeScript\nDESCRIPTION: Extends the BaseServiceOptions interface to include properties for tag propagation and ECS managed tags. These properties allow users to specify how tags should be propagated and whether ECS managed tags should be enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface BaseServiceOptions {\n\n  ...\n\n   /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service\n   *\n   * Valid values are: PropagateTagFromType.SERVICE or PropagateTagFromType.TASK_DEFINITION\n   *\n   * @default - PropagatedTagSource.SERVICE if EC2 or Fargate Service, otherwise PropagatedTagSource.NONE.\n   */\n  readonly propagateTags?: PropagatedTagSource;\n\n   /**\n   * Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see\n   * [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html)\n   *\n   * @default true\n   */\n  readonly enableECSManagedTags?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Timestream Module in AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Timestream module from the aws-cdk-lib library in TypeScript. This import is a prerequisite for defining Timestream-related resources in an AWS CDK application. The module provides access to the L1 CloudFormation constructs for AWS Timestream, since L2 constructs are not yet available. No additional parameters are required, but the aws-cdk-lib dependency must be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-timestream/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as timestream from 'aws-cdk-lib/aws-timestream';\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Deployments to Same Environment in AWS AppConfig with TypeScript\nDESCRIPTION: Demonstrates sequential deployment of multiple configurations to the same environment. Deployments will occur in the order the configurations are declared.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new appconfig.Application(this, 'MyApp');\nconst env = new appconfig.Environment(this, 'MyEnv', {\n  application: app,\n});\n\nnew appconfig.HostedConfiguration(this, 'MyFirstHostedConfig', {\n  application: app,\n  deployTo: [env],\n  content: appconfig.ConfigurationContent.fromInlineText('This is my first configuration content.'),\n});\n\nnew appconfig.HostedConfiguration(this, 'MySecondHostedConfig', {\n  application: app,\n  deployTo: [env],\n  content: appconfig.ConfigurationContent.fromInlineText('This is my second configuration content.'),\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing TableWidget Summary Columns (TypeScript)\nDESCRIPTION: Demonstrates how to control TableWidget summary columns, stickiness, and column visibility using the summary property. Requires TableSummaryColumn constants and a Dashboard from aws-cdk-lib/aws-cloudwatch. Useful for showing only summary statistics and keeping them visible during scrolling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\n\ndashboard.addWidgets(new cloudwatch.TableWidget({\n  // ...\n  \n  summary: {\n    columns: [cloudwatch.TableSummaryColumn.AVERAGE],\n    hideNonSummaryColumns: true,\n    sticky: true,\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining a Glue Database in TypeScript using AWS CDK\nDESCRIPTION: This snippet demonstrates creating an AWS Glue Database resource using the AWS CDK. It specifies the `databaseName` and an optional `description` for the database within the Glue Data Catalog.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nnew glue.Database(this, 'MyDatabase', {\n  databaseName: 'my_database',\n  description: 'my_database_description',\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Protocol Implementation Wrapping\nDESCRIPTION: Shows how to wrap follow-redirects around custom HTTP/HTTPS protocol implementations for advanced usage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { http, https } = require('follow-redirects').wrap({\n  http: require('your-custom-http'),\n  https: require('your-custom-https'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom KMS Encryption for Event Filters\nDESCRIPTION: Shows how to use a custom KMS key for encrypting Kafka event filter criteria instead of the default AWS managed keys.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda-event-sources/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ManagedKafkaEventSource } from 'aws-cdk-lib/aws-lambda-event-sources';\nimport { Key } from 'aws-cdk-lib/aws-kms';\n\n// Your MSK cluster arn\nconst clusterArn = 'arn:aws:kafka:us-east-1:0123456789019:cluster/SalesCluster/abcd1234-abcd-cafe-abab-9876543210ab-4';\n\n// The Kafka topic you want to subscribe to\nconst topic = 'some-cool-topic';\n\n// Your self managed KMS key\nconst myKey = Key.fromKeyArn(\n  this,\n  'SourceBucketEncryptionKey',\n  'arn:aws:kms:us-east-1:123456789012:key/<key-id>',\n);\n\ndeclare const myFunction: lambda.Function;\nmyFunction.addEventSource(new ManagedKafkaEventSource({\n  clusterArn,\n  topic,\n  startingPosition: lambda.StartingPosition.TRIM_HORIZON,\n  filters: [\n    lambda.FilterCriteria.filter({\n      stringEquals: lambda.FilterRule.isEqual('test'),\n    }),\n  ],\n  filterEncryption: myKey,\n}));\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SupportApp Constructs in AWS CDK with TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS SupportApp module from 'aws-cdk-lib' in a TypeScript AWS CDK project. By importing 'supportapp', users gain access to any available L1 constructs related to AWS SupportApp. No additional dependencies are required other than 'aws-cdk-lib' installed in the project. The import enables usage of the SupportApp resources as defined in CloudFormation, although no higher-level L2 constructs are currently available.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-supportapp/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as supportapp from 'aws-cdk-lib/aws-supportapp';\n```\n\n----------------------------------------\n\nTITLE: Configuring ECR Repository as CodePipeline Source in TypeScript\nDESCRIPTION: This snippet demonstrates configuring an AWS ECR repository as a source stage in CodePipeline using AWS CDK. It imports the `aws-eck-lib/aws-ecr` module and defines an `EcrSourceAction` that triggers on changes to a specified image tag (defaults to 'latest') in the repository, producing an output artifact.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ecr from 'aws-cdk-lib/aws-ecr';\n\ndeclare const ecrRepository: ecr.Repository;\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.EcrSourceAction({\n  actionName: 'ECR',\n  repository: ecrRepository,\n  imageTag: 'some-tag', // optional, default: 'latest'\n  output: sourceOutput,\n});\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Public Gallery Authorization Access\nDESCRIPTION: Grants an IAM user access to retrieve authorization tokens for the public ECR gallery.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = new iam.User(this, 'User');\necr.PublicGalleryAuthorizationToken.grantRead(user);\n```\n\n----------------------------------------\n\nTITLE: Checking Resource Properties/Existence with New Assertions (TypeScript)\nDESCRIPTION: Shows the replacement methods from `@aws-cdk/assertions`. `Template.fromStack(stack).hasResourceProperties()` checks if a resource of the given type exists with the specified properties. `Template.fromStack(stack).hasResource()` checks the complete resource definition against the provided properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nTemplate.fromStack(stack).hasResourceProperties('FOO::BAR', {/*...*/});\nTemplate.fromStack(stacK).hasResource('FOO::BAR', {/*...*/});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS GreengrassV2 Constructs with AWS CDK - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import the GreengrassV2 construct library from the AWS CDK package. It is a foundational setup step to enable working with GreengrassV2 resources in an AWS CDK TypeScript project. No runtime logic is included; this import is a prerequisite for defining or referencing GreengrassV2 constructs in subsequent CDK code. The required dependency is 'aws-cdk-lib' with GreengrassV2 support. The import expects a properly configured CDK environment. There are no parameters; the output is the inclusion of the library in the project scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-greengrassv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as greengrass from 'aws-cdk-lib/aws-greengrassv2';\n```\n\n----------------------------------------\n\nTITLE: Adding a gRPC Route with Port Match - AWS App Mesh - TypeScript\nDESCRIPTION: This code adds a gRPC route that matches based on traffic arriving at a specified port, directing traffic to a virtual node. App Mesh constructs are used for configuration. Required dependencies are AWS CDK and App Mesh packages, with predeclared router and node. The input is the port number (here, 1234), and the output is a gRPC route only matching that port. Limitation: route only matches requests sent to the provided port.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const router: appmesh.VirtualRouter;\ndeclare const node: appmesh.VirtualNode;\n\nrouter.addRoute('route-grpc-port', {\n  routeSpec: appmesh.RouteSpec.grpc({\n    weightedTargets: [\n      {\n        virtualNode: node,\n      },\n    ],\n    match: {\n      port: 1234,\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Reconnection Window for IVS Recording\nDESCRIPTION: Creates a recording configuration with a reconnect window. This allows multiple stream fragments to be merged if disconnection occurs within the specified interval.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recordingBucket: s3.Bucket;\n\nconst recordingConfiguration= new ivs.RecordingConfiguration(this, 'RecordingConfiguration', {\n  bucket: recordingBucket,\n\n  // set recording reconnect window\n  recordingReconnectWindow: Duration.seconds(60),\n});\n```\n\n----------------------------------------\n\nTITLE: Example API Endpoint Interaction using Curl\nDESCRIPTION: Demonstrates a sample curl command to retrieve data from an example API endpoint. This represents the type of endpoint a CloudWatch Synthetics Canary might be configured to monitor.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n% curl \"https://api.example.com/user/books/topbook/\"\nThe Hitchhikers Guide to the Galaxy\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AuditManager Module - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS AuditManager module from the aws-cdk-lib in a TypeScript project. To use this code, ensure 'aws-cdk-lib' is installed as a dependency in your project. The import statement enables you to reference AuditManager resources and constructs within your AWS CDK app, although L2 constructs are currently unavailable, and L1 constructs should be used as described in the AWS CDK documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-auditmanager/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as auditmanager from 'aws-cdk-lib/aws-auditmanager';\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Response Handling in SDKv2 (TypeScript)\nDESCRIPTION: This snippet shows how SDKv2 automatically buffers the response stream when retrieving an object from S3.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-custom-resource-sdk-adapter/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// this buffers (consumes) the stream already\nconst get = await s3.getObject({ ... }).promise();\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for API Gateway Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with an API Gateway REST API target and input transformation. This allows customizing the payload sent to the REST API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\n\nconst fn = new lambda.Function( this, 'MyFunc', {\n  handler: 'index.handler',\n  runtime: lambda.Runtime.NODEJS_LATEST,\n  code: lambda.Code.fromInline( 'exports.handler = e => {}' ),\n});\n\nconst restApi = new api.LambdaRestApi( this, 'MyRestAPI', { handler: fn } );\nconst apiTarget = new targets.ApiGatewayTarget(restApi, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: apiTarget,\n});\n```\n\n----------------------------------------\n\nTITLE: Rate Limiting with Axios (Node.js)\nDESCRIPTION: Demonstrates how to set upload and download rate limits using Axios in Node.js. This is useful for controlling bandwidth usage or simulating slow network conditions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_38\n\nLANGUAGE: javascript\nCODE:\n```\nconst {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {\n  onUploadProgress: ({progress, rate}) => {\n    console.log(`Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s`)\n  },\n   \n  maxRate: [100 * 1024], // 100KB/s limit\n});\n```\n\n----------------------------------------\n\nTITLE: Adding NAT Gateway to VPC using AWS CDK in TypeScript\nDESCRIPTION: This code snippet shows how to add a NAT gateway to a VPC using AWS CDK. It creates a VPC, a route table, and a public subnet, then adds an internet gateway and a public NAT gateway to the VPC.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack();\nconst myVpc = new VpcV2(this, 'Vpc');\nconst routeTable = new RouteTable(this, 'RouteTable', {\n  vpc: myVpc,\n});\nconst subnet = new SubnetV2(this, 'Subnet', {  \n  vpc: myVpc,\n  availabilityZone: 'eu-west-2a',\n  ipv4CidrBlock: new IpCidr('10.0.0.0/24'),\n  subnetType: SubnetType.PUBLIC });\n\nmyVpc.addInternetGateway();\nmyVpc.addNatGateway({\n  subnet: subnet,\n  connectivityType: NatConnectivityType.PUBLIC,\n});\n```\n\n----------------------------------------\n\nTITLE: Using GitHub Source Action Variables in CodeBuild Action\nDESCRIPTION: This example shows how to use variables emitted by the GitHub source action in a subsequent CodeBuild action.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceOutput: codepipeline.Artifact;\ndeclare const project: codebuild.PipelineProject;\n\nconst sourceAction = new codepipeline_actions.GitHubSourceAction({\n  actionName: 'Github_Source',\n  output: sourceOutput,\n  owner: 'my-owner',\n  repo: 'my-repo',\n  oauthToken: SecretValue.secretsManager('my-github-token'),\n  variablesNamespace: 'MyNamespace', // optional - by default, a name will be generated for you\n});\n\n// later:\n\nnew codepipeline_actions.CodeBuildAction({\n  actionName: 'CodeBuild',\n  project,\n  input: sourceOutput,\n  environmentVariables: {\n    COMMIT_URL: {\n      value: sourceAction.variables.commitUrl,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating ContainerImage Class with fromInternet Method in TypeScript\nDESCRIPTION: This snippet shows the update to the ContainerImage class, adding a fromInternet method that creates a WebHostedImage instance with optional credentials. This allows for easy creation of container images from internet sources with authentication.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-priv-registry-support.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport class ContainerImage {\n  //...\n  public static fromInternet(imageName: string, props: WebHostedImageProps) {\n    return new WebHostedImage(imageName, props);\n  }\n  // ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interface and Class with Explicit Configuration Annotation - AWS CDK - TypeScript\nDESCRIPTION: Illustrates the correct way to separate interface and class implementations for a CDK construct, and uses the @config annotation to mark configuration-mutating methods per guidelines. The IFoo interface is implemented by Foo, which has methods with varying compliance to the configuration annotation rule. Highlights errors when missing proper @config tags or interface exposure. Requires AWS CDK as a dependency; shown inputs/outputs are methods managing internal state or configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface IFoo extends IConstruct {\n  bar(): void;\n}\n\nclass Foo extends Construct implements IFoo {\n  public bar() { }\n\n  @config\n  public goo() { }\n\n  public mutateMe() { } // ERROR! missing \"@config\" or missing on IFoo\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Detailed Axios Error Information in JavaScript\nDESCRIPTION: Illustrates how to use the `toJSON()` method on an Axios error object within the `.catch()` block. This method returns a serialized object containing comprehensive details about the HTTP error, which can be useful for logging or debugging purposes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\naxios.get('/user/12345')\n  .catch(function (error) {\n    console.log(error.toJSON());\n  });\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS CDK Alexa Skills Kit Module (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the `alexa-ask` module from the `aws-cdk-lib`. This import is the first step to utilize the available constructs (currently only L1) for defining Alexa Skills Kit resources within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/alexa-ask/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as alexa_ask from 'aws-cdk-lib/alexa-ask';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Auto Scaling Plans L1 Module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Auto Scaling Plans module from the AWS CDK library in TypeScript. This import is necessary to access the L1 constructs for defining Auto Scaling Plans resources within a CDK application, as higher-level L2 constructs are not yet available in the core library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscalingplans/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as autoscalingplans from 'aws-cdk-lib/aws-autoscalingplans';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IVSChat Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import the `aws-ivschat` module from the `aws-cdk-lib`. This import is necessary to use the low-level (L1) constructs for interacting with AWS IVSChat resources within an AWS CDK application. It requires the `aws-cdk-lib` dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ivschat/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ivschat from 'aws-cdk-lib/aws-ivschat';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoT SiteWise Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS IoT SiteWise module from the `aws-cdk-lib` library. This import statement makes the L1 constructs for IoTSiteWise available for use within an AWS CDK application, allowing developers to define SiteWise resources programmatically. It requires the `aws-cdk-lib` package to be installed in the project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotsitewise/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotsitewise from 'aws-cdk-lib/aws-iotsitewise';\n```\n\n----------------------------------------\n\nTITLE: Defining `addToResourcePolicy` Method in AWS CDK TypeScript\nDESCRIPTION: Defines the required `addToResourcePolicy` method signature on the construct interface (`IFoo`), which should also extend `iam.IResourceWithPolicy`. This method allows adding `iam.PolicyStatement`s to the resource's own policy. Implementations must consider limitations, especially for imported resources where modifying the policy might not be possible via CloudFormation, and issue notices accordingly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface IFoo extends iam.IResourceWithPolicy {\n  addToResourcePolicy(statement: iam.PolicyStatement): void;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS WAF Regional L1 Constructs with AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to import the 'aws-wafregional' module from the AWS CDK library in TypeScript, allowing direct use of WAF Regional L1 (CloudFormation) constructs. There are no additional dependencies beyond 'aws-cdk-lib', and this import is prerequisite to defining AWS WAF Regional resources in your CDK app. This import does not itself configure resources, but enables their subsequent definition and deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-wafregional/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as wafregional from 'aws-cdk-lib/aws-wafregional';\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom CodePipeline Action\nDESCRIPTION: Creates a custom action provider for CodePipeline. This example registers a GenericGitSource provider with specific properties for source control integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Make a custom CodePipeline Action\nnew codepipeline.CustomActionRegistration(this, 'GenericGitSourceProviderResource', {\n  category: codepipeline.ActionCategory.SOURCE,\n  artifactBounds: { minInputs: 0, maxInputs: 0, minOutputs: 1, maxOutputs: 1 },\n  provider: 'GenericGitSource',\n  version: '1',\n  entityUrl: 'https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html',\n  executionUrl: 'https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html',\n  actionProperties: [\n    {\n      name: 'Branch',\n      required: true,\n      key: false,\n      secret: false,\n      queryable: false,\n      description: 'Git branch to pull',\n      type: 'String',\n    },\n    {\n      name: 'GitUrl',\n      required: true,\n      key: false,\n      secret: false,\n      queryable: false,\n      description: 'SSH git clone URL',\n      type: 'String',\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Ray Job with Required Parameters in AWS CDK\nDESCRIPTION: Shows the minimal configuration needed to create a Ray Job in AWS Glue using role and script parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.RayJob(stack, 'ImportedJob', { role, script });\n```\n\n----------------------------------------\n\nTITLE: Retrieving Regional Information with RegionInfo Class in TypeScript\nDESCRIPTION: Demonstrates how to get region-specific information using the RegionInfo class, which is the preferred way to access the regional information database.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/region-info/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Get the information for \"eu-west-1\":\nconst region = regionInfo.RegionInfo.get('eu-west-1');\n\n// Access attributes:\nregion.s3StaticWebsiteEndpoint; // s3-website-eu-west-1.amazonaws.com\n```\n\n----------------------------------------\n\nTITLE: Configuring EC2 Health Checks for Auto Scaling Group in TypeScript\nDESCRIPTION: Creates an AWS Auto Scaling Group with specific EC2 health check settings. It uses `autoscaling.HealthChecks.ec2` to define the health check type and configure the `gracePeriod`, which is the time Auto Scaling waits after an instance launches before checking its health. Dependencies include `ec2.Vpc`, `ec2.InstanceType`, `ec2.MachineImage`, `Duration`, and `autoscaling` module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const vpc: ec2.Vpc;\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.MICRO),\n  machineImage: ec2.MachineImage.latestAmazonLinux2(),\n  healthChecks: autoscaling.HealthChecks.ec2({\n    gracePeriod: Duration.seconds(100),\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Global Defaults for Axios - JavaScript\nDESCRIPTION: Illustrates how to set global default options for Axios including `baseURL` and authorization headers. Also shows how to set the default content-type for POST requests. Requires that `axios` and any relevant authentication tokens are already available. Modifications here affect all Axios requests globally, so care must be taken with authentication and cross-domain requests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\naxios.defaults.baseURL = 'https://api.example.com';\n\n// Important: If axios is used with multiple domains, the AUTH_TOKEN will be sent to all of them.\n// See below for an example using Custom instance defaults instead.\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n----------------------------------------\n\nTITLE: Working with CloudFormation Conditions in CDK\nDESCRIPTION: Shows how to access and modify CloudFormation condition expressions through CfnInclude. This enables customizing conditional logic in imported templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst condition: core.CfnCondition = cfnTemplate.getCondition('MyCondition');\n\n// mutating the condition\ncondition.expression = core.Fn.conditionEquals(1, 2);\n```\n\n----------------------------------------\n\nTITLE: Supplying a Custom IAM SMS Role to Cognito UserPool - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to create an IAM role for Cognito to send SMS and assign it to a UserPool instance using the 'smsRole' and 'smsRoleExternalId' properties. Requires AWS CDK with Cognito and IAM modules. Key parameters: 'assumedBy' sets the principal for the role, 'smsRole' attaches the IAM role to the UserPool, and 'smsRoleExternalId' adds an external ID for secure role assumption. Input is an IAM role and configuration values; output is a properly configured Cognito UserPool with SMS role assignment. Ensure the assume role policy on the role matches the ExternalId requirement.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst poolSmsRole = new iam.Role(this, 'userpoolsmsrole', {\n  assumedBy: new iam.ServicePrincipal('foo'),\n});\n\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  smsRole: poolSmsRole,\n  smsRoleExternalId: 'c87467be-4f34-11ea-b77f-2e728ce88125',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining QueueProcessingFargateServiceProps Interface in TypeScript\nDESCRIPTION: Interface specifying Fargate-specific properties for queue processing including CPU and memory configurations that align with Fargate task requirements.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-autoscaling-queue-worker.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface QueueProcessingFargateServiceProps {\n  readonly cpu?: string;\n  readonly memoryMiB?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Structure for Complex Secrets\nDESCRIPTION: This example shows the JSON structure for a complex secret containing multiple fields like username, database, and password that would be stored in AWS Secrets Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-secretsmanager/README.md#2025-04-23_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"username\": \"myUsername\",\n  \"database\": \"foo\",\n  \"password\": \"mypassword\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Kinesis Stream by ARN - AWS CDK - TypeScript\nDESCRIPTION: This code snippet imports an existing Kinesis stream into the CDK stack using its ARN via the Stream.fromStreamArn static method. This is helpful for referencing resources created outside the current CDK app. Requires aws-cdk-lib and kinesis modules. The main input is the stream ARN; the output is a Stream construct referencing the external stream.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesis/README.md#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst importedStream = kinesis.Stream.fromStreamArn(this, 'ImportedStream',\n  'arn:aws:kinesis:us-east-2:123456789012:stream/f3j09j2230j',\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Deployments with addDeployments in AWS AppConfig with TypeScript\nDESCRIPTION: Demonstrates how to batch-define deployment order for multiple configurations using the addDeployments method, allowing explicit control of deployment sequence.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new appconfig.Application(this, 'MyApp');\nconst env = new appconfig.Environment(this, 'MyEnv', {\n  application: app,\n});\n\nconst secondConfig = new appconfig.HostedConfiguration(this, 'MySecondHostedConfig', {\n  application: app,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my second configuration content.'),\n});\n\nconst thirdConfig = new appconfig.HostedConfiguration(this, 'MyThirdHostedConfig', {\n  application: app,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my third configuration content.'),\n});\n\nconst firstConfig = new appconfig.HostedConfiguration(this, 'MyFirstHostedConfig', {\n  application: app,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my first configuration content.'),\n});\n\nenv.addDeployments(firstConfig, secondConfig, thirdConfig);\n```\n\n----------------------------------------\n\nTITLE: Modifying a Resource Property from an Included Template (TypeScript)\nDESCRIPTION: Demonstrates how to modify properties of a CloudFormation resource obtained via `getResource`. This example changes the `bucketName` property of the retrieved `CfnBucket` instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\ncfnBucket.bucketName = 'amzn-s3-demo-bucket';\n```\n\n----------------------------------------\n\nTITLE: Controlling S3 Table Bucket Permissions in TypeScript with AWS CDK\nDESCRIPTION: This snippet shows various ways to grant permissions to an S3 Table Bucket using the AWS CDK. It includes examples of granting read, write, and read-write permissions to different principals, as well as adding custom resource policy statements.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3tables-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Grant the principal read permissions to the bucket and all tables within\nconst accountId = '123456789012'\ntableBucket.grantRead(new iam.AccountPrincipal(accountId), '*');\n// Grant the role write permissions to the bucket and all tables within\nconst role = new iam.Role(stack, 'MyRole', { assumedBy: new iam.ServicePrincipal('sample') });\ntableBucket.grantWrite(role, '*');\n// Grant the user read and write permissions to the bucket and all tables within \ntableBucket.grantReadWrite(new iam.User(stack, 'MyUser'), '*');\n\n// Grant permissions to the bucket and a particular table within it\nconst tableId = '6ba046b2-26de-44cf-9144-0c7862593a7b'\ntableBucket.grantReadWrite(new iam.AccountPrincipal(accountId), tableId);\n\n// Add custom resource policy statements\nconst permissions = new iam.PolicyStatement({\n    effect: iam.Effect.ALLOW,\n    actions: ['s3tables:*'],\n    principals: [ new iam.ServicePrincipal('example.aws.internal') ],\n    resources: ['*']\n});\n\ntableBucket.addToResourcePolicy(permissions);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Payment Cryptography Module in TypeScript\nDESCRIPTION: Shows how to import the AWS Payment Cryptography module in a TypeScript CDK application. This import statement provides access to the L1 constructs for working with AWS Payment Cryptography resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-paymentcryptography/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as paymentcryptography from 'aws-cdk-lib/aws-paymentcryptography';\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Network Mode\nDESCRIPTION: Creates a Docker image asset with specified network mode for the build process.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset, NetworkMode } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  networkMode: NetworkMode.HOST,\n})\n```\n\n----------------------------------------\n\nTITLE: Manual S3 Bucket Policy Statement for Imported Buckets with OAI (Legacy) (JSON)\nDESCRIPTION: Specifies the S3 bucket policy statement required to manually grant read access (`s3:GetObject`) to an imported S3 bucket for a CloudFront Origin Access Identity (OAI). This policy needs to be applied outside the CDK application as CDK cannot modify imported resources. It grants access to the specific OAI principal (`arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity <origin access identity ID>`) for objects within the bucket (`arn:aws:s3:::<S3 bucket name>/*`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Id\": \"PolicyForCloudFrontPrivateContent\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity <origin access identity ID>\"\n            },\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::<S3 bucket name>/*\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring KeyPair for AWS CDK Auto Scaling Group Instances\nDESCRIPTION: Demonstrates how to configure a KeyPair for an Auto Scaling group when not using a ready-made LaunchTemplate. This enables SSH access to the EC2 instances in the Auto Scaling group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-autoscaling/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\ndeclare const instanceType: ec2.InstanceType;\ndeclare const machineImage: ec2.IMachineImage;\n\nconst myKeyPair = new ec2.KeyPair(this, 'MyKeyPair');\n\nnew autoscaling.AutoScalingGroup(this, 'ASG', {\n  vpc,\n  instanceType,\n  machineImage,\n\n  // ...\n\n  keyPair: myKeyPair,\n});\n```\n\n----------------------------------------\n\nTITLE: Custom IAM Policy for S3 API Calls\nDESCRIPTION: Example of adding custom IAM policies for S3 API calls where default permissions are insufficient.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst apiCall = integ.assertions.awsApiCall('S3', 'listObjectsV2', {\n  Bucket: 'mybucket',\n});\n\napiCall.provider.addToRolePolicy({\n  Effect: 'Allow',\n  Action: ['s3:GetObject', 's3:ListBucket'],\n  Resource: ['*'],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Kendra L1 Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet shows how to import the AWS Kendra module from 'aws-cdk-lib/aws-kendra' using TypeScript. It prepares the project to reference AWS Kendra L1 (low-level) constructs, given that no higher-level L2 constructs exist. Requires the aws-cdk-lib as a project dependency and is typically used in CDK construct or stack definitions; no parameters are taken and the module export is assigned to the kendra namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kendra/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kendra from 'aws-cdk-lib/aws-kendra';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS SecurityLake Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code imports the necessary module (`aws-securitylake`) from the AWS CDK library (`aws-cdk-lib`) to enable the use of AWS SecurityLake L1 constructs within a CDK application. This step is required before defining SecurityLake resources like Data Lakes or Subscribers using the CDK L1 constructs. Requires `aws-cdk-lib` to be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-securitylake/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as securitylake from 'aws-cdk-lib/aws-securitylake';\n```\n\n----------------------------------------\n\nTITLE: Creating Aurora Database Cluster - Current TypeScript API\nDESCRIPTION: Example showing the current AWS CDK API for creating an Aurora database cluster with provisioned instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rds/adr/aurora-serverless-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new rds.DatabaseCluster(this, 'Database', {\n  engine: rds.DatabaseClusterEngine.auroraMysql({ version: rds.AuroraMysqlEngineVersion.VER_2_08_1 }),\n  instances: 3, // default is 2\n  instanceProps: {\n    // optional , defaults to t3.medium\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.SMALL),\n    vpc,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Preferred Flat Property Structure in AWS CDK\nDESCRIPTION: Example of the recommended flat property structure with a shared prefix for related properties, improving usability while maintaining logical grouping.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew Bucket(this, 'MyBucket', {\n  websiteErrorDocument: '404.html',\n  websiteIndexDocument: 'index.html'\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Permissions Boundary Context in AWS CDK Configuration (JSON)\nDESCRIPTION: Defines the permissions boundary policy that is enforced throughout the CDK app by specifying the `@aws-cdk/core:permissionsBoundary` context key in a `cdk.json` configuration file. This configuration is required for organizations that enforce centralized permissions boundaries. The provided name may include placeholders (such as `${Qualifier}`) that are replaced at synthesis time. The input is a JSON object and is consumed by the CDK CLI and APIs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iam/README.md#2025-04-23_snippet_21\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"context\\\": {\\n     \\\"@aws-cdk/core:permissionsBoundary\\\": {\\n\\t   \\\"name\\\": \\\"cdk-${Qualifier}-PermissionsBoundary\\\"\\n\\t }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS FIS Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import the AWS Fault Injection Simulator (FIS) module (`aws-fis`) from the `aws-cdk-lib`. This is the standard way to make the FIS constructs (currently only L1) available in an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fis/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as fis from 'aws-cdk-lib/aws-fis';\n```\n\n----------------------------------------\n\nTITLE: Implementation of New Tag Class Methods in TypeScript\nDESCRIPTION: Implementation code for the proposed Tag class with static 'add' and 'remove' methods that handle tag application and removal. These methods internally use the existing applyAspect approach.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/tagging-API-change.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * The Tag Aspect will handle adding a tag to this node and cascading tags to children\n */\nexport class Tag extends TagBase {\n\n  /**\n   * add tags to the node of a construct and all its the taggable children\n   */\n  public static add(scope: Construct, key: string, value: string, props: TagProps = {}) {\n    scope.node.applyAspect(new Tag(key, value, props));\n  }\n\n  /**\n   * remove tags to the node of a construct and all its the taggable children\n   */\n  public static remove(scope: Construct, key: string, props: TagProps = {}) {\n    scope.node.applyAspect(new RemoveTag(key, props));\n  }\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoTEvents Construct Library - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS IoTEvents construct module from the aws-cdk-lib library into a TypeScript project. Importing the iotevents namespace allows you to access all L1 constructs related to AWS IoTEvents, which directly map to CloudFormation resources. No external prerequisites are required beyond aws-cdk-lib being installed as a dependency; you will use these constructs as you would with any CDK resource, but higher-level (L2) constructs are not yet available. The statement should be placed at the top-level of your TypeScript source file.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotevents/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from 'aws-cdk-lib/aws-iotevents';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS KinesisAnalyticsV2 Constructs in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS KinesisAnalyticsV2 module from the AWS CDK library, which is a prerequisite for defining KinesisAnalyticsV2 resources within a CDK application. No additional dependencies are required other than aws-cdk-lib. The import statement enables the use of both L1 (CloudFormation-based) constructs for KinesisAnalyticsV2, as no hand-written L2 constructs currently exist. There are no parameters or output values for this import operation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisanalyticsv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as kinesisanalytics from 'aws-cdk-lib/aws-kinesisanalyticsv2';\n```\n\n----------------------------------------\n\nTITLE: Importing Existing CloudFront Distributions in TypeScript\nDESCRIPTION: This code shows how to import an existing CloudFront distribution using its domain name and distribution ID. Imported distributions cannot be modified but can be referenced in other constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront/README.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n// Using a reference to an imported Distribution\nconst distribution = cloudfront.Distribution.fromDistributionAttributes(this, 'ImportedDist', {\n  domainName: 'd111111abcdef8.cloudfront.net',\n  distributionId: '012345ABCDEF',\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Staging Resources from Scratch in TypeScript\nDESCRIPTION: Demonstrates how to implement the IStagingResources interface from scratch by creating a custom staging stack that provides file and Docker image staging locations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CustomStagingStackProps extends StackProps {}\n\nclass CustomStagingStack extends Stack implements IStagingResources {\n  public constructor(scope: Construct, id: string, props: CustomStagingStackProps) {\n    super(scope, id, props);\n  }\n\n  public addFile(asset: FileAssetSource): FileStagingLocation {\n    return {\n      bucketName: 'amzn-s3-demo-bucket',\n      assumeRoleArn: 'myArn',\n      dependencyStack: this,\n    };\n  }\n\n  public addDockerImage(asset: DockerImageAssetSource): ImageStagingLocation {\n    return {\n      repoName: 'myRepo',\n      assumeRoleArn: 'myArn',\n      dependencyStack: this,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS License Manager in TypeScript\nDESCRIPTION: Basic import statement for using AWS License Manager resources in a CDK application. This allows access to the automatically generated L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-licensemanager/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as licensemanager from 'aws-cdk-lib/aws-licensemanager';\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Policy Prop in AWS CDK TypeScript\nDESCRIPTION: Shows how to define an optional `resourcePolicy` property within the construct's props. This property accepts an array of `iam.PolicyStatement` objects, allowing users to initialize the resource with a specific resource-based policy upon creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nresourcePolicy?: iam.PolicyStatement[]\n```\n```\n\n----------------------------------------\n\nTITLE: Target Message in SQS Queue after Enrichment in JSON\nDESCRIPTION: Shows the structure of the target message in the SQS queue after processing and enrichment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    ...\n    \"body\": \"static value-Test message.-MyPipe\",\n    ...\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual-Stack IP Address Type for WebSocket API in TypeScript (CDK)\nDESCRIPTION: This snippet demonstrates how to configure the API endpoint to support both IPv4 and IPv6 addresses (dual-stack). This is done by setting the `ipAddressType` property to `apigwv2.IpAddressType.DUAL_STACK` when creating the `WebSocketApi`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew apigwv2.WebSocketApi(this, 'WebSocketApi', {\n  ipAddressType: apigwv2.IpAddressType.DUAL_STACK,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking Lambda Function from IoT Events Action\nDESCRIPTION: Creates an Action that invokes a Lambda function when triggered. This shows how to integrate Lambda functions into an IoT Events detector model state.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-actions-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\nimport * as actions from '@aws-cdk/aws-iotevents-actions-alpha';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\n\ndeclare const input: iotevents.IInput;\ndeclare const func: lambda.IFunction;\n\nconst state = new iotevents.State({\n  stateName: 'MyState',\n  onEnter: [{\n    eventName: 'test-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [new actions.LambdaInvokeAction(func)],\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS CodeGuru Profiler Library in TypeScript\nDESCRIPTION: Code snippet for importing the CodeGuru Profiler library into a CDK project. This is the first step required before using any of the CodeGuru Profiler constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codeguruprofiler/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codeguruprofiler from 'aws-cdk-lib/aws-codeguruprofiler';\n```\n\n----------------------------------------\n\nTITLE: Importing Existing ECS Deployment Group in AWS CDK\nDESCRIPTION: Shows how to import an existing CodeDeploy ECS Deployment Group into a CDK stack using the fromEcsDeploymentGroupAttributes method. This allows integration with deployment groups that were created outside of CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: codedeploy.EcsApplication;\nconst deploymentGroup = codedeploy.EcsDeploymentGroup.fromEcsDeploymentGroupAttributes(this, 'ExistingCodeDeployDeploymentGroup', {\n  application,\n  deploymentGroupName: 'MyExistingDeploymentGroup',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing DSQL module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the DSQL module from the aws-cdk-lib package. It allows access to DSQL-related constructs and resources in a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dsql/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dsql from 'aws-cdk-lib/aws-dsql';\n```\n\n----------------------------------------\n\nTITLE: Registering Integration Test Case\nDESCRIPTION: Example of registering a stack as a test case with IntegTest construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const app: App;\ndeclare const stack: Stack;\nnew IntegTest(app, 'Integ', { testCases: [stack] });\n```\n\n----------------------------------------\n\nTITLE: Creating AppStream Fleet with Creation Policy\nDESCRIPTION: Example of setting a creation policy for an AppStream fleet resource to wait for fleet startup.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst fleet = new appstream.CfnFleet(this, 'Fleet', {\n  instanceType: 'stream.standard.small',\n  name: 'Fleet',\n  computeCapacity: {\n    desiredInstances: 1,\n  },\n  imageName: 'AppStream-AmazonLinux2-09-21-2022',\n});\nfleet.cfnOptions.creationPolicy = {\n  startFleet: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Illustrative Step Scaling Policy for CPU Usage\nDESCRIPTION: This plaintext diagram illustrates a potential step scaling policy based on CPU utilization percentages. It shows different scaling adjustments (e.g., -1, no change, +1, +3) applied when CPU usage crosses specific thresholds (10%, 50%, 70%).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationautoscaling/README.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n```plaintext\n Scaling        -1          (no change)          +1       +3\n                                                           \n            \n                                                           \nCPU usage   0%      10%                     50%       70%     100%\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring PAY_PER_REQUEST Billing Mode for DynamoDB in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a DynamoDB table with PAY_PER_REQUEST billing mode and specify maximum read/write request units.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,\n  maxReadRequestUnits: 100,\n  maxWriteRequestUnits: 200,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Pipeline Triggers by Pull Request Events using AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to configure a pipeline in AWS CDK (TypeScript) to trigger based on specific pull request event types using the 'events' property in pullRequestFilter. Supported events include opening or closing a pull request. Requires codepipeline and codepipeline_actions, and applies to pipelines of type V2. Use this pattern to respond only to selected pull request actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceAction: codepipeline_actions.CodeStarConnectionsSourceAction;\ndeclare const buildAction: codepipeline_actions.CodeBuildAction;\n\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  stages: [\n    {\n      stageName: 'Source',\n      actions: [sourceAction],\n    },\n    {\n      stageName: 'Build',\n      actions: [buildAction],\n    },\n  ],\n  triggers: [{\n    providerType: codepipeline.ProviderType.CODE_STAR_SOURCE_CONNECTION,\n    gitConfiguration: {\n      sourceAction,\n      pullRequestFilter: [{\n        branchesExcludes: ['exclude1', 'exclude2'],\n        branchesIncludes: ['include1', 'include2'],\n        events: [\n          codepipeline.GitPullRequestEvent.OPEN,\n          codepipeline.GitPullRequestEvent.CLOSED,\n        ],\n      }],\n    },\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SSO Constructs in AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS SSO construct module from the AWS CDK library in a TypeScript project. It is required for accessing and instantiating SSO-related resources within the CDK app, especially when working with automatically generated L1 constructs. The import should be placed at the top of the CDK source file. No parameters are involved. This usage requires the 'aws-cdk-lib' dependency and assumes a TypeScript development environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sso/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sso from 'aws-cdk-lib/aws-sso';\n```\n\n----------------------------------------\n\nTITLE: Referencing Resources Between Stacks within Same Region (TypeScript)\nDESCRIPTION: Demonstrates how AWS CDK handles references between resources defined in different stacks within the same AWS region. An S3 bucket created in `stack1` is granted read permissions by a Lambda function in `stack2`. CDK automatically manages the necessary CloudFormation Exports and Imports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst bucket = new s3.Bucket(stack1, 'Bucket');\nconst handler = new lambda.Function(stack2, 'Handler');\nbucket.grantRead(handler);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Firehose Delivery Stream with Direct S3 Destination (TypeScript)\nDESCRIPTION: This code demonstrates defining an S3 bucket destination for a Firehose delivery stream in the AWS CDK. It instantiates an S3 bucket and uses it as the destination in a Firehose DeliveryStream. Dependencies: @aws-cdk/aws-s3, @aws-cdk/aws-kinesisfirehose. Input: a declared S3 bucket. Output: Firehose delivery stream with S3 destination. The code assumes the bucket has already been created elsewhere.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\nconst s3Destination = new firehose.S3Bucket(bucket);\n\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: s3Destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IdentityStore Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the aws-identitystore module from the aws-cdk-lib package using TypeScript. This import is required to access L1 CloudFormation constructs for AWS IdentityStore resources in your CDK application. No configurable parameters are required for the import, and it assumes aws-cdk-lib is installed as a project dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-identitystore/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as identitystore from 'aws-cdk-lib/aws-identitystore';\n```\n\n----------------------------------------\n\nTITLE: Strengthening Property Requirement for kubectlLayer in EKS Cluster Props - AWS CDK - TypeScript\nDESCRIPTION: This code records the enforcement of the kubectlLayer property as required (was previously optional) for ClusterProps and FargateClusterProps in the aws_eks module. The change enables removal of an outdated kubectl layer dependency. Consumers must now explicitly specify kubectlLayer when creating EKS clusters and update their project dependencies accordingly. Inputs require explicit kubectlLayer; omission is no longer permitted.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n# Making kubectlLayer prop required from optional so we can remove the outdated kubectl layer dependency\nstrengthened:aws-cdk-lib.aws_eks.ClusterProps\nstrengthened:aws-cdk-lib.aws_eks.FargateClusterProps\nremoved:aws-cdk-lib.lambda_layer_kubectl.KubectlLayer\n```\n\n----------------------------------------\n\nTITLE: Including a JSON CloudFormation Template in CDK (TypeScript)\nDESCRIPTION: Demonstrates how to use the `CfnInclude` class from the `@aws-cdk/cloudformation-include` module in a TypeScript CDK application to include an existing CloudFormation template stored in a JSON file. It takes the scope (`this`), an ID ('Template'), and the path to the template file.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst cfnTemplate = new cfn_inc.CfnInclude(this, 'Template', {\n  templateFile: 'my-template.json',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Deployment Configuration with Zonal Configuration in TypeScript\nDESCRIPTION: Creates an EC2/on-premise deployment configuration with zonal configuration to deploy to one Availability Zone at a time.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentConfig = new codedeploy.ServerDeploymentConfig(this, 'DeploymentConfiguration', {\n  minimumHealthyHosts: codedeploy.MinimumHealthyHosts.count(2),\n  zonalConfig: {\n    monitorDuration: Duration.minutes(30),\n    firstZoneMonitorDuration: Duration.minutes(60),\n    minimumHealthyHostsPerZone: codedeploy.MinimumHealthyHostsPerZone.count(1),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing SQS Source for EventBridge Pipe\nDESCRIPTION: Shows how to create a source configuration for an EventBridge pipe using an SQS queue as the source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\nconst pipeSource = new SqsSource(sourceQueue);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS WAFv2 CDK Module - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS WAFv2 constructs module from the AWS CDK library in a TypeScript project. It sets up the environment for working with AWS::WAFv2 resources using the '@aws-cdk/aws-wafv2' package. No additional dependencies are required beyond the aws-cdk-lib NPM package. The import enables usage of L1 CloudFormation constructs for AWS WAFv2 resources; no parameters are taken, and the snippet outputs the imported module object.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-wafv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as wafv2 from 'aws-cdk-lib/aws-wafv2';\n```\n\n----------------------------------------\n\nTITLE: Importing OpsWorks CM module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the OpsWorks CM module in a TypeScript project using the AWS CDK. It allows access to OpsWorks CM constructs and functionality.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opsworkscm/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opsworkscm from 'aws-cdk-lib/aws-opsworkscm';\n```\n\n----------------------------------------\n\nTITLE: Running lazify on JavaScript files in current directory\nDESCRIPTION: A shell command to run the lazify tool on all JavaScript files in the current directory. This is the basic usage pattern for the tool.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/lazify/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Run on all JavaScript in the current directory\nlazify .\n```\n\n----------------------------------------\n\nTITLE: Creating an Alias A Record in Route53 using AWS CDK\nDESCRIPTION: Shows how to create an A record of type alias with the target set to another record created outside CDK. It uses the fromARecordAttributes method to register an existing DNS name as an AliasTarget.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nconst targetRecord = 'existing.record.cdk.local';\nconst record = route53.ARecord.fromARecordAttributes(this, 'A', {\n  zone: myZone,\n  recordName: 'test',\n  targetDNS: targetRecord,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS AppFlow Module in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS AppFlow module from the `aws-cdk-lib`. This import makes the AppFlow L1 constructs available for use within your CDK application stack definition. It's the entry point for defining AppFlow resources programmatically.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appflow/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appflow from 'aws-cdk-lib/aws-appflow';\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing Application for ApplicationAssociator in TypeScript\nDESCRIPTION: Demonstrates how to import an existing application by ARN and use it with ApplicationAssociator to associate all stacks in the App scope with the imported application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.existingApplicationFromArn({\n    applicationArnValue: 'arn:aws:servicecatalog:us-east-1:123456789012:/applications/applicationId',\n    stackName: 'MyAssociatedApplicationStack',\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Initial KMS Policy Condition Using ArnLike Wildcard (JSON)\nDESCRIPTION: Shows the specific `Condition` block from the initial KMS key policy generated for CloudFront OAC. It uses the `ArnLike` operator and a wildcard (`*`) to match the `AWS:SourceArn` against any CloudFront distribution ARN in the specified account (`arn:aws:cloudfront::<account ID>:distribution/*`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n  \"Condition\": {\n      \"ArnLike\": {\n          \"AWS:SourceArn\": \"arn:aws:cloudfront::<account ID>:distribution/*\"\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Adding IAM Policy Statement to Provider Role (AWS CDK, TypeScript)\nDESCRIPTION: Demonstrates attaching a raw IAM policy statement as a JSON object to a custom resource provider Lambda role in AWS CDK. This is done using addToRolePolicy on the provider, after creating or retrieving it. The statement allows s3:GetObject on all buckets (Resource: '*'). Note that the method expects direct JSON, not an iam.PolicyStatement object. Required dependencies are CustomResourceProvider and standard CDK libraries.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst provider = CustomResourceProvider.getOrCreateProvider(this, 'Custom::MyCustomResourceType', {\n  codeDirectory: `${__dirname}/my-handler`,\n  runtime: CustomResourceProviderRuntime.NODEJS_18_X,\n});\nprovider.addToRolePolicy({\n  Effect: 'Allow',\n  Action: 's3:GetObject',\n  Resource: '*',\n})\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Elemental MediaStore Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Elemental MediaStore module in a TypeScript project using the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediastore/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediastore from 'aws-cdk-lib/aws-mediastore';\n```\n\n----------------------------------------\n\nTITLE: Listing awslint Rules\nDESCRIPTION: Example showing how to list all available linter rules using the list command.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/awslint/README.md#2025-04-23_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ npm run awslint list\nmodule-name: module name must be @aws-cdk/aws-<namespace>\nconstruct-ctor: signature of all construct constructors should be \"scope, id, props\"\nresource-class: every resource must have a resource class (L2)\n...\n```\n\n----------------------------------------\n\nTITLE: Creating Route53 Record Alias Record\nDESCRIPTION: Demonstrates creating a Route53 A-record that aliases to another Route53 record.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53-targets/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const zone: route53.HostedZone;\ndeclare const record: route53.ARecord;\nnew route53.ARecord(this, 'AliasRecord', {\n  zone,\n  target: route53.RecordTarget.fromAlias(new targets.Route53RecordTarget(record)),\n});\n```\n\n----------------------------------------\n\nTITLE: Associating a Customer Managed KMS Key with AWS App Runner Source using AWS CDK - TypeScript\nDESCRIPTION: Shows how to specify a customer managed KMS key for App Runner source encryption in the AWS CDK using TypeScript. This involves providing a KMS key via the 'kmsKey' property while configuring a service with a public ECR image source. Required dependencies are 'aws-cdk-lib/aws-kms' and 'apprunner'. The main input is an instance of 'kms.IKey', ensuring encrypted storage for service assets. Output is an App Runner service resource encrypted with the provided key.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as kms from 'aws-cdk-lib/aws-kms';\n\ndeclare const kmsKey: kms.IKey;\n\nnew apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n  kmsKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS OpsWorks Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS OpsWorks module in a CDK application. This enables access to OpsWorks L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opsworks/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as opsworks from 'aws-cdk-lib/aws-opsworks';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS DMS Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Database Migration Service (DMS) module in a TypeScript CDK application. It allows access to DMS-related constructs and resources in your CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dms/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dms from 'aws-cdk-lib/aws-dms';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS NetworkFirewall Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS NetworkFirewall module in a CDK application. This import statement provides access to L1 constructs that wrap CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-networkfirewall/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as networkfirewall from 'aws-cdk-lib/aws-networkfirewall';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoTCoreDeviceAdvisor L1 Constructs in TypeScript\nDESCRIPTION: Imports the low-level (L1) constructs for the AWS IoT Core Device Advisor service from the AWS CDK library. This import is necessary to use the L1 constructs, which map directly to CloudFormation resources, within a TypeScript CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotcoredeviceadvisor/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as iotcoredeviceadvisor from 'aws-cdk-lib/aws-iotcoredeviceadvisor';\n```\n\n----------------------------------------\n\nTITLE: Example CloudFormation Error for Missing Elasticsearch SLR\nDESCRIPTION: Displays a typical error message encountered during CloudFormation deployment via AWS CDK if the required AWS Service-Linked Role (SLR) for Amazon OpenSearch/Elasticsearch Service (`AWSServiceRoleForAmazonElasticsearchService`) does not exist in the AWS account, particularly when configuring features like VPC access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n```console\nBefore you can proceed, you must enable a service-linked role to give Amazon ES...\n```\n```\n\n----------------------------------------\n\nTITLE: Creating GameSessionQueue with Destinations using AWS GameLift (TypeScript)\nDESCRIPTION: This snippet illustrates how to define a GameSessionQueue in AWS GameLift via CDK, set its name, assign a fleet as its destination, and dynamically add an alias destination. Prerequisites include declared BuildFleet and Alias resources. Inputs are queue name and destinations; output is a queue construct supporting flexible placement logic for incoming game session requests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fleet: gamelift.BuildFleet;\ndeclare const alias: gamelift.Alias;\n\nconst queue = new gamelift.GameSessionQueue(this, 'GameSessionQueue', {\n  gameSessionQueueName: 'my-queue-name',\n  destinations: [fleet]\n});\nqueue.addDestination(alias);\n```\n\n----------------------------------------\n\nTITLE: Accessing a Provider's Role ARN (AWS CDK, TypeScript)\nDESCRIPTION: This snippet uses CustomResourceProvider.getOrCreateProvider to obtain the provider instance then accesses its Lambda function roleArn property for use in IAM or other security-relevant settings. It is primarily useful when programmatically configuring permissions for the provider Lambda function and requires specifying codeDirectory and Lambda runtime for the provider. The resulting roleArn can be referenced elsewhere in CDK stacks.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst provider = CustomResourceProvider.getOrCreateProvider(this, 'Custom::MyCustomResourceType', {\n  codeDirectory: `${__dirname}/my-handler`,\n  runtime: CustomResourceProviderRuntime.NODEJS_18_X,\n});\n\nconst roleArn = provider.roleArn;\n```\n\n----------------------------------------\n\nTITLE: Multi-Architecture Integration Test Setup\nDESCRIPTION: Example of testing Lambda function deployment with different architectures (ARM64 and X86_64).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\n\nnew IntegTest(app, 'DifferentArchitectures', {\n  testCases: [\n    new StackUnderTest(app, 'Stack1', {\n      architecture: lambda.Architecture.ARM_64,\n    }),\n    new StackUnderTest(app, 'Stack2', {\n      architecture: lambda.Architecture.X86_64,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Enum-like Class Pattern in AWS CDK\nDESCRIPTION: Implementation of the Enum-like Class pattern which allows for both common predefined options and custom values, providing flexibility while maintaining type safety.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface MyProps {\n  readonly option: MyOption;\n}\n\nexport class MyOption {\n  public static COMMON_OPTION_1 = new MyOption('common.option-1');\n  public static COMMON_OPTION_2 = new MyOption('common.option-2');\n\n  public constructor(public readonly customValue: string) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing CloudFormation Resource Lifecycle State Transitions in ASCII Diagram\nDESCRIPTION: An ASCII diagram showing the complete lifecycle of a CloudFormation resource, including creation, update, and deletion states. The diagram illustrates how resources transition between states and highlights that CREATE_FAILED and UPDATE_FAILED are not stable states but trigger immediate follow-up actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/CLOUDFORMATION.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n                                  \n                                                          \n                                       <nonexistant>      \n                                                          \n                                  \n                                               \n                                               \n                                               \n                                                \n                                                                                            \n                                     CREATE_IN_PROGRESS      CREATE_FAILED    \n                                                                                              \n                                                  \n                                                                                                 \n                                                                                                 \n                                                                                                 \n                                                                       \n                                                                                                \n                         CREATE_COMPLETE                                          \n                                                                                               \n                                                                      \n                                                                                                \n                                                                          custom resource       \n                                                                              rollback          \n                                  \n                                                                                              \n                                    UPDATE_IN_PROGRESS                 \n                                                                                             \n                                                                    \n                                                                                              \n                                                                                              \n                                                                                              \n                                           \n                                                                                             \n                                      UPDATE_COMPLETE           UPDATE_FAILED       \n                                                            no-op                            \n                                  rollback \n                                                                                                \n                                                                      \n                                                                                                 \n                                                                                                 \n                                                                       \n                                                                                                \n   DELETE_IN_PROGRESS    \n                                                                                               \n                                                                      \n                                                                                                \n                           \n                                                                                              \n                                                                                              \n                 \n                                                                                            \n      DELETE_FAILED                  DELETE_SKIPPED                   DELETE_COMPLETE     \n                                                                                          \n               \n```\n\n----------------------------------------\n\nTITLE: Importing AWS NotificationsContacts Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS NotificationsContacts module into a CDK application. This provides access to L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-notificationscontacts/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as notificationscontacts from 'aws-cdk-lib/aws-notificationscontacts';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Panorama Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Panorama module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-panorama/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as panorama from 'aws-cdk-lib/aws-panorama';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS EMRServerless Construct Library in TypeScript with CDK\nDESCRIPTION: This snippet demonstrates how to import the EMRServerless module from the aws-cdk-lib package in TypeScript, enabling access to EMRServerless L1 constructs for AWS Cloud Development Kit (CDK) applications. The imported module is necessary for referencing EMRServerless resources and properties as defined in AWS CloudFormation. No additional dependencies are required beyond aws-cdk-lib, and the import is used in CDK stack definitions for resource management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-emrserverless/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as emrserverless from 'aws-cdk-lib/aws-emrserverless';\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Deploy-Time Asset in TypeScript\nDESCRIPTION: Shows how to explicitly create a deploy-time asset using the Asset class from aws-cdk-lib/aws-s3-assets, which will be stored with a deploy-time/ prefix.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Asset } from 'aws-cdk-lib/aws-s3-assets';\n\ndeclare const stack: Stack;\nconst asset = new Asset(stack, 'deploy-time-asset', {\n  deployTime: true,\n  path: path.join(__dirname, 'deploy-time-asset'),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining PropagatedTagSource Enum in TypeScript\nDESCRIPTION: Defines an enum for specifying the source of propagated tags in ECS services. It includes options for propagating tags from the service, task definition, or not propagating tags at all.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport enum PropagatedTagSource {\n  /**\n   * Propagate tags from service\n   */\n  SERVICE = 'SERVICE',\n\n  /**\n   * Propagate tags from task definition\n   */\n  TASK_DEFINITION = 'TASK_DEFINITION',\n\n  /**\n   * Do not propagate\n   */\n  NONE = 'NONE'\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Raw CloudFormation Resources\nDESCRIPTION: Example of creating raw CloudFormation resources using CfnResource class.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nnew CfnResource(this, 'ResourceId', {\n  type: 'AWS::S3::Bucket',\n  properties: {\n    BucketName: 'amzn-s3-demo-bucket'\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Context via App Constructor - TypeScript\nDESCRIPTION: Demonstrates setting one or more context values as key-value pairs during AWS CDK App instantiation by passing a context property. This influences feature flags and synthesis behavior throughout the app's lifetime. Requires aws-cdk-lib and the context is assigned at construction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nnew App({\n  context: {\n    '@aws-cdk/core:newStyleStackSynthesis': true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Building and Running Security Guardian Locally\nDESCRIPTION: Instructions for setting up and running the Security Guardian tool for local development. Includes commands for installing dependencies, building the project, and running with command-line arguments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/security-guardian/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run build\n```\n\nLANGUAGE: bash\nCODE:\n```\nnode dist/index.js \\\n  --data_directory=./changed_templates \\\n  --rule_file_path=./rules.guard \\\n  --output_format=single-line-summary \\\n  --show_summary=fail\n```\n\n----------------------------------------\n\nTITLE: Creating a Map in AWS Location Service (Legacy)\nDESCRIPTION: Creates a legacy Map resource with a specified style and custom layers. Map resources provide access to basemap data that can be used with a map rendering library to add interactive maps to applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew location.Map(this, 'Map', {\n  mapName: 'my-map',\n  style: location.Style.VECTOR_ESRI_NAVIGATION,\n  customLayers: [location.CustomLayer.POI],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing the LaunchWizard module in TypeScript\nDESCRIPTION: Basic import statement for using AWS LaunchWizard resources in a CDK application. This enables access to the L1 constructs that directly map to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-launchwizard/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as launchwizard from 'aws-cdk-lib/aws-launchwizard';\n```\n\n----------------------------------------\n\nTITLE: Configuring MSK Cluster Connections in TypeScript\nDESCRIPTION: This example shows how to control access to an MSK Cluster by configuring its connections. It allows connections from a specific IP range to specific ports.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-msk-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nconst cluster = new msk.Cluster(this, 'Cluster', {\n  clusterName: 'myCluster',\n  kafkaVersion: msk.KafkaVersion.V3_8_X,\n  vpc,\n});\n\ncluster.connections.allowFrom(\n  ec2.Peer.ipv4('1.2.3.4/8'),\n  ec2.Port.tcp(2181),\n);\ncluster.connections.allowFrom(\n  ec2.Peer.ipv4('1.2.3.4/8'),\n  ec2.Port.tcp(9094),\n);\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon MQ CDK Module - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the Amazon MQ module from the AWS CDK library for use in TypeScript projects. No additional dependencies are required other than 'aws-cdk-lib' being installed, and it enables access to Amazon MQ (aws-amazonmq) constructs in CDK applications. The statement is essential for referencing any resources or constructs related to Amazon MQ within the AWS CDK ecosystem.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-amazonmq/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as amazonmq from 'aws-cdk-lib/aws-amazonmq';\n```\n\n----------------------------------------\n\nTITLE: Creating Assertions for StepFunctions Integration Test in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create assertions for a StepFunctions integration test. It shows how to start a StateMachine execution, describe the execution results, and assert the expected outcome using the IntegTest class from @aws-cdk/integ-tests-alpha.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as integ from '@aws-cdk/integ-tests-alpha';\n\ndeclare const app: App;\ndeclare const sm: sfn.StateMachine;\ndeclare const stack: Stack;\n\nconst testCase = new integ.IntegTest(app, 'PutEvents', {\n  testCases: [stack],\n});\n\n// Start an execution\nconst start = testCase.assertions.awsApiCall('StepFunctions', 'startExecution', {\n  stateMachineArn: sm.stateMachineArn,\n});\n\n// describe the results of the execution\nconst describe = testCase.assertions.awsApiCall('StepFunctions', 'describeExecution', {\n  executionArn: start.getAttString('executionArn'),\n});\n\n// assert the results\ndescribe.expect(integ.ExpectedResult.objectLike({\n  status: 'SUCCEEDED',\n}));\n```\n\n----------------------------------------\n\nTITLE: Import Package Configuration for Java\nDESCRIPTION: Shows the correct package imports to use for Java implementations due to jsiirc.json file issues.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_13\n\nLANGUAGE: java\nCODE:\n```\nimport software.amazon.awscdk.aws_apigatewayv2_integrations.*;\n\n// If you want to import a specific construct\nimport software.amazon.awscdk.aws_apigatewayv2_integrations.WebSocketAwsIntegration;\n```\n\n----------------------------------------\n\nTITLE: S3 BucketDeployment Error Message Related to KMS Permissions (plaintext)\nDESCRIPTION: This error message illustrates the runtime failure observed when the Lambda function backing a BucketDeployment does not have sufficient KMS permissions to decrypt objects in an S3 bucket. The message can be used to diagnose policy issues or missing permissions related to KMS key configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-deployment/README.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\ndownload failed: ...\nAn error occurred (AccessDenied) when calling the GetObject operation:\nUser: *** is not authorized to perform: kms:Decrypt on the resource associated with this ciphertext\nbecause no identity-based policy allows the kms:Decrypt action\n```\n\n----------------------------------------\n\nTITLE: Counting Resources with Old `toCountResources` (TypeScript)\nDESCRIPTION: Demonstrates the deprecated `toCountResources` Jest matcher from `@aws-cdk/assert` used to assert the exact number of resources of a specific type (`FOO::BAR`) within a CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexpect(stack).toCountResources('FOO::BAR', 1);\n```\n```\n\n----------------------------------------\n\nTITLE: Single Lambda Function Project Structure\nDESCRIPTION: Shows a simpler project structure for a single Go Lambda function. This is used in the documentation to explain how AssetHashType.SOURCE might be appropriate for this type of project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nlambda-app\n cmd\n    api\n        main.go\n go.mod\n go.sum\n pkg\n     auth\n         auth.go\n```\n\n----------------------------------------\n\nTITLE: Configuring Deployment Order with addDeployment in AWS AppConfig with TypeScript\nDESCRIPTION: Demonstrates how to control deployment order using the addDeployment method when declaration order doesn't match desired deployment order.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new appconfig.Application(this, 'MyApp');\nconst env = new appconfig.Environment(this, 'MyEnv', {\n  application: app,\n});\n\nconst secondConfig = new appconfig.HostedConfiguration(this, 'MySecondHostedConfig', {\n  application: app,\n  content: appconfig.ConfigurationContent.fromInlineText('This is my second configuration content.'),\n});\n\nconst firstConfig = new appconfig.HostedConfiguration(this, 'MyFirstHostedConfig', {\n  application: app,\n  deployTo: [env],\n  content: appconfig.ConfigurationContent.fromInlineText('This is my first configuration content.'),\n});\n\nenv.addDeployment(secondConfig);\n```\n\n----------------------------------------\n\nTITLE: Importing MediaLive Module in TypeScript\nDESCRIPTION: Example of importing the AWS MediaLive module from the AWS CDK library for use in TypeScript applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-medialive/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as medialive from 'aws-cdk-lib/aws-medialive';\n```\n\n----------------------------------------\n\nTITLE: Associating an Attribute Group with an ApplicationAssociator Application\nDESCRIPTION: Shows how to associate an attribute group with an application created by ApplicationAssociator. The attribute group can contain metadata attributes related to the application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from \"aws-cdk-lib\";\n\nconst app = new App();\n\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.createApplicationStack({\n    applicationName: 'MyAssociatedApplication',\n    // 'Application containing stacks deployed via CDK.' is the default\n    applicationDescription: 'Associated Application description',\n    stackName: 'MyAssociatedApplicationStack',\n    // AWS Account and Region that are implied by the current CLI configuration is the default\n    env: { account: '123456789012', region: 'us-east-1' },\n  })],\n});\n\n// Associate application to the attribute group.\nassociatedApp.appRegistryApplication.addAttributeGroup('MyAttributeGroup' , {\n  attributeGroupName: 'MyAttributeGroupName',\n  description: 'Test attribute group',\n  attributes: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Transfer Module in TypeScript\nDESCRIPTION: This TypeScript code snippet shows how to import the AWS Transfer module from the core `aws-cdk-lib` package. This import is necessary to access AWS Transfer functionalities, specifically the L1 constructs, within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-transfer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as transfer from 'aws-cdk-lib/aws-transfer';\n```\n\n----------------------------------------\n\nTITLE: Migration Example: Updating Cognito Authentication Property\nDESCRIPTION: Shows how to update the Cognito authentication property from cognitoKibanaAuth to cognitoDashboardsAuth when migrating to OpenSearch.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticsearch/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nnew es.Domain(this, 'Domain', {\n  cognitoKibanaAuth: {\n    identityPoolId: 'test-identity-pool-id',\n    userPoolId: 'test-user-pool-id',\n    role: role,\n  },\n  version: elasticsearchVersion,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nnew opensearch.Domain(this, 'Domain', {\n  cognitoDashboardsAuth: {\n    identityPoolId: 'test-identity-pool-id',\n    userPoolId: 'test-user-pool-id',\n    role: role,\n  },\n  version: openSearchVersion,\n});\n```\n\n----------------------------------------\n\nTITLE: Updating EC2 VPC and Subnet Configurations\nDESCRIPTION: Replace deprecated SubnetType values and use new methods for adding VPC endpoints. Use securityGroups instead of securityGroupId for InterfaceVpcEndpoint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nSubnetType.ISOLATED\nSubnetType.PRIVATE\nvpc.addDynamoDbEndpoint()\nvpc.addS3Endpoint()\n\n// New\nSubnetType.PRIVATE_ISOLATED\nSubnetType.PRIVATE_WITH_NAT\nvpc.addGatewayEndpoint()\n\n// For InterfaceVpcEndpoint\n// Old\nendpoint.securityGroupId\n// New\nendpoint.connections\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Jobs with AsyncKit on Array Input\nDESCRIPTION: Demonstrates how to use AsyncKit's parallel method to process an array of items asynchronously. It includes error handling and job abortion functionality.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/asynckit/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar parallel = require('asynckit').parallel\n  , assert   = require('assert')\n  ;\n\nvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ]\n  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ]\n  , expectedTarget = [ 1, 1, 2, 4, 8, 16, 32, 64 ]\n  , target         = []\n  ;\n\nparallel(source, asyncJob, function(err, result)\n{\n  assert.deepEqual(result, expectedResult);\n  assert.deepEqual(target, expectedTarget);\n});\n\n// async job accepts one element from the array\n// and a callback function\nfunction asyncJob(item, cb)\n{\n  // different delays (in ms) per item\n  var delay = item * 25;\n\n  // pretend different jobs take different time to finish\n  // and not in consequential order\n  var timeoutId = setTimeout(function() {\n    target.push(item);\n    cb(null, item * 2);\n  }, delay);\n\n  // allow to cancel \"leftover\" jobs upon error\n  // return function, invoking of which will abort this job\n  return clearTimeout.bind(null, timeoutId);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for a CDK Application in package.json\nDESCRIPTION: Specifies `dependencies` for a CDK application in its `package.json` file. It includes `aws-cdk-lib` and `constructs` using caret ranges (`^`) to ensure the application uses the latest compatible versions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"dependencies\": {\n    \"aws-cdk-lib\": \"^2.38.0\",\n    \"constructs\": \"^10.0.0\"\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing GroundStation Construct Library with AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the GroundStation construct library from aws-cdk-lib for use in your TypeScript AWS CDK project. It supports the use of L1 (CloudFormation-based) constructs due to the absence of L2 (higher-level) constructs. No additional dependencies are required beyond aws-cdk-lib. The import provides access to all AWS::GroundStation resources and properties exposed through CloudFormation in a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-groundstation/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as groundstation from 'aws-cdk-lib/aws-groundstation';\n```\n\n----------------------------------------\n\nTITLE: Importing DocDBElastic module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the DocDBElastic module from the AWS CDK library in a TypeScript project. It allows access to the DocDBElastic constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-docdbelastic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as docdbelastic from 'aws-cdk-lib/aws-docdbelastic';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS InspectorV2 L1 Constructs in TypeScript\nDESCRIPTION: Imports the AWS InspectorV2 L1 construct library from the AWS CDK core library (`aws-cdk-lib`). This import statement makes the L1 constructs, which directly map to AWS CloudFormation resources for InspectorV2, available for use within a TypeScript CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-inspectorv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as inspector from 'aws-cdk-lib/aws-inspectorv2';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoTFleetWise Module in AWS CDK (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to import the iotfleetwise module from the AWS CDK library in TypeScript. It is required as a prerequisite for any further use of AWS IoTFleetWise L1 constructs, as there are no L2 constructs available for this service at present. The import statement enables access to all CloudFormation resources for AWS::IoTFleetWise via the CDK, and it is intended for use at the beginning of a CDK application file that leverages IoTFleetWise resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotfleetwise/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotfleetwise from 'aws-cdk-lib/aws-iotfleetwise';\n```\n\n----------------------------------------\n\nTITLE: Importing Java Package for AWS CDK Authorizers - Java\nDESCRIPTION: This snippet describes the workaround to import AWS CDK authorizers for Java, using the 'aws_apigatewayv2_authorizers' package instead of the conventional 'services.apigatewayv2_authorizers' package. Example imports are provided for both wildcard and explicit class import. This is required for proper construct resolution due to a module stabilization issue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nimport software.amazon.awscdk.aws_apigatewayv2_authorizers.*;\n\n// If you want to import a specific construct\nimport software.amazon.awscdk.aws_apigatewayv2_authorizers.WebSocketIamAuthorizer;\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic GoFunction in AWS CDK\nDESCRIPTION: Defines a simple GoFunction construct that points to a Golang Lambda function entry point. The entry parameter specifies the location of the main Go file or directory containing main.go.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'handler', {\n  entry: 'lambda-app/cmd/api',\n});\n```\n\n----------------------------------------\n\nTITLE: Visualizing CloudFormation Dependencies with GraphViz - Shell\nDESCRIPTION: This shell snippet illustrates piping the output of 'cdk synth' through 'template-deps-to-dot' and rendering an image with GraphViz. Prerequisites: cdk CLI, custom script template-deps-to-dot, and installed GraphViz (dot). Produces a PNG image of template dependencies. Replace placeholders with actual filenames.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_53\n\nLANGUAGE: shell\nCODE:\n```\ncdk -a some.app.js synth | $awscdk/scripts/template-deps-to-dot | dot -Tpng > deps.png\n```\n\n----------------------------------------\n\nTITLE: Disabling Auto-Deletion of Staging Assets in TypeScript\nDESCRIPTION: Shows how to disable automatic cleanup of staging resources (S3 buckets and ECR repositories) on stack deletion by setting autoDeleteStagingAssets to false.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BucketEncryption } from 'aws-cdk-lib/aws-s3';\n\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    autoDeleteStagingAssets: false,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Match.objectLike for Partial Object Matching in TypeScript\nDESCRIPTION: Demonstrates the `Match.objectLike()` matcher within `hasResourceProperties()` to assert that the target object contains at least the specified properties (superset check). It performs a deep partial match recursively. The first example shows a passing assertion, while the second shows a failing one because 'Brew: Coffee' is not present.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Given a template -\n// {\n//   \"Resources\": {\n//     \"MyBar\": {\n//       \"Type\": \"Foo::Bar\",\n//       \"Properties\": {\n//         \"Fred\": {\n//           \"Wobble\": \"Flob\",\n//           \"Bob\": \"Cat\"\n//         }\n//       }\n//     }\n//   }\n// }\n\n// The following will NOT throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.objectLike({\n    Wobble: 'Flob',\n  }),\n});\n\n// The following will throw an assertion error\ntemplate.hasResourceProperties('Foo::Bar', {\n  Fred: Match.objectLike({\n    Brew: 'Coffee',\n  }),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Cloning CodeCommit Repositories into Cloud9 Environment\nDESCRIPTION: Demonstrates how to clone AWS CodeCommit repositories into a Cloud9 environment during creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-cloud9-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codecommit from 'aws-cdk-lib/aws-codecommit';\n\n// create a codecommit repository to clone into the cloud9 environment\nconst repoNew = new codecommit.Repository(this, 'RepoNew', {\n  repositoryName: 'new-repo',\n});\n\n// import an existing codecommit repository to clone into the cloud9 environment\nconst repoExisting = codecommit.Repository.fromRepositoryName(this, 'RepoExisting', 'existing-repo');\n\n// create a new Cloud9 environment and clone the two repositories\ndeclare const vpc: ec2.Vpc;\nnew cloud9.Ec2Environment(this, 'C9Env', {\n  vpc,\n  clonedRepositories: [\n    cloud9.CloneRepository.fromCodeCommit(repoNew, '/src/new-repo'),\n    cloud9.CloneRepository.fromCodeCommit(repoExisting, '/src/existing-repo'),\n  ],\n  imageId: cloud9.ImageId.AMAZON_LINUX_2,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding EKS Add-ons to a Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to add AWS EKS add-ons to a cluster using the eks.Addon class. It shows configuring add-on name, version, and preservation settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\n\nnew eks.Addon(this, 'Addon', {\n  cluster,\n  addonName: 'aws-guardduty-agent',\n  addonVersion: 'v1.6.1',\n  // whether to preserve the add-on software on your cluster but Amazon EKS stops managing any settings for the add-on.\n  preserveOnDelete: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing SystemsManagerSAP Construct - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the SystemsManagerSAP module from the aws-cdk-lib package in TypeScript. It is a prerequisite step before using any SystemsManagerSAP L1 resources in CDK applications. No official L2 constructs exist for this service yet; users interact directly with L1 generated constructs. The import must be included at the top of your CDK application when working with SystemsManagerSAP resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-systemsmanagersap/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as systemsmanagersap from 'aws-cdk-lib/aws-systemsmanagersap';\n```\n\n----------------------------------------\n\nTITLE: Function Interface with Event Source Addition\nDESCRIPTION: Implementation of addEventSource method in Function interface for handling event sources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IFunction extends IResource {\n  public addEventSource(eventSource: IEventSource) {\n    eventSource.bind(this);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS DataBrew module in TypeScript\nDESCRIPTION: Basic import statement for accessing AWS DataBrew resources in an AWS CDK TypeScript project. This allows you to use L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-databrew/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as databrew from 'aws-cdk-lib/aws-databrew';\n```\n\n----------------------------------------\n\nTITLE: Importing DAX module in TypeScript for AWS CDK\nDESCRIPTION: This code snippet demonstrates how to import the DAX module from the AWS CDK library in a TypeScript project. It allows access to DAX-related constructs and functionality within the CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dax/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as dax from 'aws-cdk-lib/aws-dax';\n```\n\n----------------------------------------\n\nTITLE: Warning Message: KMS Key Policy Wildcard for CloudFront OAC\nDESCRIPTION: Displays a warning message emitted during AWS CDK synth time. This message explains that a wildcard (`*`) is used in the KMS key policy's condition for `AWS:SourceArn` to allow CloudFront access when using OAC with an SSE-KMS encrypted S3 bucket, initially avoiding circular dependencies. It advises users to refine this policy for better security after the first deployment by specifying the exact distribution ARN.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nTo avoid a circular dependency between the KMS key, Bucket, and Distribution during the initial deployment, a wildcard is used in the Key policy condition to match all Distribution IDs.\nAfter deploying once, it is strongly recommended to further scope down the policy for best security practices by following the guidance in the \"Using OAC for a SSE-KMS encrypted S3 origin\" section in the module README.\n```\n\n----------------------------------------\n\nTITLE: Implementing Tag Properties in FargateService Class Constructor in TypeScript\nDESCRIPTION: Updates the FargateService class constructor to include the new tag propagation and ECS managed tags properties. These properties are passed to the BaseService constructor with default values if not specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport class FargateService extends BaseService implements IFargateService {\n\n  ...\n\n  constructor(scope: cdk.Construct, id: string, props: FargateServiceProps) {\n\n    ...\n\n    super(scope, id, {\n      ...props,\n      desiredCount: props.desiredCount !== undefined ? props.desiredCount : 1,\n      launchType: LaunchType.FARGATE,\n      propagateTags: props.propagateTaskTagsFrom === undefined ? PropagatedTagSource.SERVICE : props.propagateTaskTagsFrom,\n      enableECSManagedTags: props.enableECSManagedTags,\n    }, {\n      cluster: props.cluster.clusterName,\n      taskDefinition: props.taskDefinition.taskDefinitionArn,\n      platformVersion: props.platformVersion,\n    }, props.taskDefinition);\n\n    ...\n\n  }\n\n  ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: Importing an AppRegistry Attribute Group by ARN in TypeScript\nDESCRIPTION: Imports an existing AWS AppRegistry Attribute Group into a CDK application using its Amazon Resource Name (ARN). This allows referencing attribute groups created outside the current CDK stack. It requires the `appreg` module and the specific ARN of the attribute group.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst importedAttributeGroup = appreg.AttributeGroup.fromAttributeGroupArn(\n  this,\n  'MyImportedAttrGroup',\n  'arn:aws:servicecatalog:us-east-1:012345678910:/attribute-groups/0aqmvxvgmry0ecc4mjhwypun6i',\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Proposed Solution for Cross-Region Certificate Reference (TypeScript)\nDESCRIPTION: Shows how the code would look using the proposed CDK feature for native cross-region references. Even though the certificate and distribution are defined in the `us-east-2` stack context, the underlying mechanism (enabled via `crossRegionReferences: true`) would handle creating the certificate in `us-east-1` and referencing it correctly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst appStack = new Stack(app, 'AppStack', { env: { region: 'us-east-2' } });\nconst service = new ApplicationLoadBalancedFargateService(appStack, 'Service');\n\n// this will work!!!\nconst certificate = new acm.Certificate(appStack, 'Cert');\nconst distribution = new Distribution(appStack, 'Distribution', {\n  defaultBehavior: { origin: new LoadBalancerV2Origin(service.loadBalancer) },\n  certificate,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Glue S3 Table in TypeScript\nDESCRIPTION: This snippet shows how to create a basic AWS Glue Table backed by S3 using AWS CDK. It defines the table within a specified Glue Database (`myDatabase`), lists its columns with names, types (`glue.Schema.STRING`, `glue.Schema.array`), and an optional comment, and sets the data format (`glue.DataFormat.JSON`). An S3 bucket is created implicitly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myDatabase: glue.Database;\nnew glue.S3Table(this, 'MyTable', {\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }, {\n    name: 'col2',\n    type: glue.Schema.array(glue.Schema.STRING),\n    comment: 'col2 is an array of strings' // comment is optional\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Data Pipeline Module in TypeScript\nDESCRIPTION: Shows how to import the AWS Data Pipeline module in a TypeScript CDK application. This is the basic first step for using Data Pipeline resources in your CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-datapipeline/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as datapipeline from 'aws-cdk-lib/aws-datapipeline';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS M2 Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS M2 module in a TypeScript project using the AWS CDK library. It allows access to M2-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-m2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as m2 from 'aws-cdk-lib/aws-m2';\n```\n\n----------------------------------------\n\nTITLE: Creating Service Linked Role for OpenSearch\nDESCRIPTION: Creates an IAM service-linked role for OpenSearch Service using CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst slr = new iam.CfnServiceLinkedRole(this, 'Service Linked Role', {\n  awsServiceName: 'es.amazonaws.com',\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Glue Library with AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Glue module provided by the aws-cdk-lib/aws-glue package in a TypeScript AWS CDK project. The import enables access to AWS Glue L1 constructs for use in CDK stacks. There are no other dependencies except the aws-cdk-lib and its aws-glue submodule. No parameters are required, and the output is the inclusion of the 'glue' namespace for subsequent Glue resource definitions in a CDK app.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-glue/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as glue from 'aws-cdk-lib/aws-glue';\n```\n\n----------------------------------------\n\nTITLE: Building AWS CDK Packages in CodeCatalyst Dev Env (Shell)\nDESCRIPTION: This snippet provides commands to build specific AWS CDK packages (`aws-cdk-lib` and `@aws-cdk-testing/framework-integ`) within an Amazon CodeCatalyst Dev Environment. It first installs dependencies using Yarn and then uses Lerna to run the build process for the specified scopes, allocating increased memory for Node.js.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn install\n$ NODE_OPTIONS=--max-old-space-size=8192 npx lerna run build --scope=aws-cdk-lib --scope=@aws-cdk-testing/framework-integ\n```\n\n----------------------------------------\n\nTITLE: Provisioning BYOIP CIDR Block using AWS CLI\nDESCRIPTION: This command shows how to provision a Bring Your Own IP (BYOIP) CIDR block in your AWS account using the AWS CLI. It requires a certified IP address block with an ROA and an X-509 certificate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\naws ec2 provision-byoip-cidr --region <region> --cidr <your CIDR block> --cidr-authorization-context Message=\"1|aws|<account>|<your CIDR block>|<expiration date>|SHA256\".Signature=\"<signature>\"\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Owners in Cloud9\nDESCRIPTION: Shows different ways to specify environment owners including account root, IAM users, federated users, and assumed roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-cloud9-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\nnew cloud9.Ec2Environment(this, 'C9Env', {\n  vpc,\n  imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  owner: cloud9.Owner.accountRoot('111111111')\n})\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Wisdom Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Wisdom module from the aws-cdk-lib package in a TypeScript AWS CDK project. It is a foundational step for accessing Wisdom resource constructs (currently L1) in CDK stacks. The only dependency is the aws-cdk-lib package; no parameters are needed for the import itself. The expected effect is that all constructs within the aws-wisdom namespace are available for use in subsequent code. There are currently no higher-level (L2) constructs, so users must interact with lower-level L1 constructs directly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-wisdom/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as wisdom from 'aws-cdk-lib/aws-wisdom';\n```\n\n----------------------------------------\n\nTITLE: Acknowledging Warnings in AWS CDK Constructs (TypeScript)\nDESCRIPTION: Demonstrates how to acknowledge a specific warning (with a unique identifier and optional message) at a particular scope within an AWS CDK construct using the `Annotations.of` API. This allows teams to document accepted risks or constraints and suppress warning output for the acknowledged case during synthesis. Requires the AWS CDK library with constructs supporting the `Annotations` API; inputs include a warning identifier string and a human-readable message.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/acknowledge-warnings.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nAnnotations.of(this).acknowledgeWarning(\n  '@aws-cdk/aws-iam:maxPoliciesExceeded',\n  'A limit increase has been submitted',\n);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Cloud9 Construct Library in AWS CDK (TypeScript)\nDESCRIPTION: This snippet imports the AWS Cloud9 module from the AWS CDK library in a TypeScript project. It enables the use of AWS Cloud9 resources within AWS CDK applications by making the L1 constructs accessible, even in the absence of official hand-written (L2) constructs. Prerequisites: Install the 'aws-cdk-lib' npm package and ensure you are using a compatible version of the AWS CDK. Input: This import statement is usually placed at the top of your TypeScript CDK application. Output: Grants access to AWS Cloud9 resources through the imported 'cloud9' namespace. Limitations: Only L1 constructs are available unless the alpha package is used.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloud9/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cloud9 from 'aws-cdk-lib/aws-cloud9';\n```\n\n----------------------------------------\n\nTITLE: AWS CDK Reference Documentation Index\nDESCRIPTION: Index of AWS CDK library classes, methods, properties and version constants for AWS services including ECS, Elastic Load Balancing, RDS, Lambda and other core services. This provides a comprehensive API reference for infrastructure as code using the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/deprecated_apis.txt#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Sample class references\naws-cdk-lib.aws_ecr_assets.DockerImageAssetOptions#repositoryName\naws-cdk-lib.aws_ecs.Cluster#addAutoScalingGroup\naws-cdk-lib.aws_elasticloadbalancingv2.ApplicationListener#addCertificateArns\naws-cdk-lib.aws_rds.DatabaseInstanceEngine#MYSQL\naws-cdk-lib.aws_lambda.Function#addVersion\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS::S3Tables Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the `aws-s3tables` module from the `aws-cdk-lib`. This import is necessary to use the L1 CloudFormation constructs provided by this module within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3tables/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3tables from 'aws-cdk-lib/aws-s3tables';\n```\n\n----------------------------------------\n\nTITLE: Exposing Role Property and Grantable Interface in AWS CDK TypeScript\nDESCRIPTION: Shows how a resource construct's interface (`IFoo`) should expose a read-only `role` property (of type `iam.IRole | undefined`) and extend `iam.IGrantable`. The `role` property provides access to the associated IAM role (if managed by the construct), while `IGrantable` enables the resource to be used in IAM grant operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface IFoo extends iam.IGrantable {\n  /**\n   * The role associated with foo. If foo is imported, no role will be available.\n   */\n  readonly role?: iam.IRole;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Batch Builds in CodeBuild Project\nDESCRIPTION: Shows how to enable batch builds for a CodeBuild project and handle the returned batch service role status.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const source: codebuild.Source;\n\nconst project = new codebuild.Project(this, 'MyProject', { source, });\n\nif (project.enableBatchBuilds()) {\n  console.log('Batch builds were enabled');\n}\n```\n\n----------------------------------------\n\nTITLE: Importing IoTWireless L1 Constructs in AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript code imports the `aws-iotwireless` module from the `aws-cdk-lib`. This makes the low-level (L1) CloudFormation constructs for AWS IoT Wireless available under the `iotwireless` namespace, enabling their use within a CDK stack definition. It's a prerequisite for defining any IoT Wireless resources using CDK's L1 constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotwireless/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport * as iotwireless from 'aws-cdk-lib/aws-iotwireless';\n```\n```\n\n----------------------------------------\n\nTITLE: Importing AWS::Oam module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS::Oam module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-oam/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as oam from 'aws-cdk-lib/aws-oam';\n```\n\n----------------------------------------\n\nTITLE: Configuring Thumbnail Generation for IVS Recording\nDESCRIPTION: Creates a recording configuration with custom thumbnail settings. This controls the resolution, storage, and interval at which thumbnails are generated.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const recordingBucket: s3.Bucket;\n\nconst recordingConfiguration = new ivs.RecordingConfiguration(this, 'RecordingConfiguration', {\n  bucket: recordingBucket,\n\n  // set thumbnail settings\n  thumbnailConfiguration: ivs.ThumbnailConfiguration.interval(ivs.Resolution.HD, [ivs.Storage.LATEST, ivs.Storage.SEQUENTIAL], Duration.seconds(30)),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS CodeStar module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS CodeStar module in a TypeScript project using the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codestar/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as codestar from 'aws-cdk-lib/aws-codestar';\n```\n\n----------------------------------------\n\nTITLE: Running awslint with Include/Exclude Filters\nDESCRIPTION: Examples demonstrating how to use the include (-i) and exclude (-x) options to filter which rules are evaluated by awslint.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/awslint/README.md#2025-04-23_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n# evaluate only the \"resource-props\" and \"import\" rules in all scopes\n$ npm run awslint -- -i resource-props -i import\n\n# evaluate only the \"import\" rule in all scopes besides ones that begin with \"@aws-cdk/aws-s3\"\n$ npm run awslint -- -i import -x \"*:@aws-cdk/aws-s3*\"\n```\n\n----------------------------------------\n\nTITLE: Importing AWS KinesisVideo Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the AWS KinesisVideo module from the AWS CDK library in a TypeScript project. It is required to access Kinesis Video Streams constructs (currently L1, auto-generated) within AWS infrastructure code. No external dependencies are needed beyond the AWS CDK library itself. The code does not take any parameters or provide output directly; rather, it sets up the namespace for subsequent resource declarations. Note that only L1 constructs are available at this time.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisvideo/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as kinesisvideo from 'aws-cdk-lib/aws-kinesisvideo';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS VoiceID L1 Constructs with AWS CDK in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS VoiceID construct library from the aws-cdk-lib module in TypeScript. It is required for using L1 (CloudFormation-level) constructs within AWS CDK when no L2 (handwritten, higher-level) constructs are available. The import enables access to VoiceID resources as defined in CloudFormation. The core dependency is aws-cdk-lib. No other parameters or inputs are needed. Outputs include availability of VoiceID construct classes for direct instantiation in a CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-voiceid/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as voiceid from 'aws-cdk-lib/aws-voiceid';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS B2BI Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS B2BI module (`aws-b2bi`) from the core AWS CDK library (`aws-cdk-lib`). This import is the first step required to utilize the available B2BI constructs (currently L1) within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-b2bi/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as b2bi from 'aws-cdk-lib/aws-b2bi';\n```\n\n----------------------------------------\n\nTITLE: Importing EMRContainers Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the EMRContainers module from the AWS CDK library (`aws-cdk-lib`). This import makes the L1 constructs for AWS EMR on EKS (EMRContainers) available for use within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-emrcontainers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as emrcontainers from 'aws-cdk-lib/aws-emrcontainers';\n```\n\n----------------------------------------\n\nTITLE: Importing MSK module in TypeScript for AWS CDK\nDESCRIPTION: This code snippet demonstrates how to import the MSK module from the aws-cdk-lib package in a TypeScript environment. It allows access to MSK-related constructs and functionality within an AWS CDK project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-msk/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as msk from 'aws-cdk-lib/aws-msk';\n```\n\n----------------------------------------\n\nTITLE: Retrieving Project Field IDs using GitHub GraphQL API in Bash\nDESCRIPTION: Uses GitHub CLI to query the GraphQL API for retrieving project and field IDs. The query focuses on single select fields (Priority, Status, Needs Attention) from the organization's project board.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/scripts/prioritization/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Get project and field IDs\ngh api graphql -f query='\nquery {\n    organization(login: \"aws\") {\n    projectV2(number: YOUR PROJECT NUMBER) {\n        id\n        fields(first: 20) {\n        nodes {\n            ... on ProjectV2SingleSelectField {\n            id\n            name\n            options {\n                id\n                name\n            }\n            }\n        }\n        }\n    }\n    }\n}\n' | jq '.data.organization.projectV2 as $project | {\n    projectId: $project.id,\n    fields: [\n    $project.fields.nodes[] | \n    select(.name == \"Priority\" or .name == \"Status\" or .name == \"Needs Attention\") |\n    {name: .name, id: .id}\n    ]\n}'\n```\n\n----------------------------------------\n\nTITLE: Customized Deployment Workflow Configuration\nDESCRIPTION: Example of customizing the integration test deployment workflow with specific CDK command options.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\n\nconst stackUnderTest = new Stack(app, 'StackUnderTest', /* ... */);\n\nconst stack = new Stack(app, 'stack');\n\nconst testCase = new IntegTest(app, 'CustomizedDeploymentWorkflow', {\n  testCases: [stackUnderTest],\n  diffAssets: true,\n  stackUpdateWorkflow: true,\n  cdkCommandOptions: {\n    deploy: {\n      args: {\n        requireApproval: RequireApproval.NEVER,\n        json: true,\n      },\n    },\n    destroy: {\n      args: {\n        force: true,\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Old AWS CDK Assert Module (TypeScript)\nDESCRIPTION: Demonstrates the old way of importing necessary components like `jest` extensions, `ABSENT`, `SynthUtils`, and `ResourcePart` from the deprecated `@aws-cdk/assert` module for CDK testing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport '@aws-cdk/assert/jest';\nimport { ABSENT, SynthUtils, ResourcePart } from '@aws-cdk/assert';\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Property Absence with Old `not.toHaveResource` (TypeScript)\nDESCRIPTION: Illustrates using the `.not` modifier with the deprecated `toHaveResource` matcher from `@aws-cdk/assert` to assert that a resource of type `FOO::BAR` does not exist *with* the specified properties.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// asserting that the stack does not have a resource with these properties\nexpect(stack).not.toHaveResource('FOO::BAR', {\n  prop: 'does not exist',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring KMS Encryption (Explicit Key) for a Glue S3 Table in TypeScript\nDESCRIPTION: This snippet shows how to configure server-side encryption with a specific, user-provided AWS KMS key (SSE-KMS) for an AWS Glue S3 Table using AWS CDK. It sets `encryption` to `glue.TableEncryption.KMS` and provides an existing `kms.Key` instance via the `encryptionKey` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n// with an explicit KMS key\nnew glue.S3Table(this, 'MyTable', {\n  encryption: glue.TableEncryption.KMS,\n  encryptionKey: new kms.Key(this, 'MyKey'),\n  // ...\n  database: myDatabase,\n  columns: [{\n    name: 'col1',\n    type: glue.Schema.STRING,\n  }],\n  dataFormat: glue.DataFormat.JSON,\n});\n```\n\n----------------------------------------\n\nTITLE: Versioning Experimental APIs and Deprecating Previous Versions in TypeScript\nDESCRIPTION: Demonstrates the process for evolving experimental APIs in AWS CDK. When a breaking change is needed for an experimental API (like adding a required parameter), a new version with an incremented suffix (e.g., `grantAwesomePowerBeta2`) is introduced, and the older version (`grantAwesomePowerBeta1`) is marked as `@deprecated`, guiding users to migrate.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/**\n* This method grants awesome powers to the given principal\n*\n* @param grantee The principal to grant powers to\n*/\ngrantAwesomePowerBeta2(grantee: iam.IGrantable)\n\n/**\n* This method grants awesome powers\n* @deprecated use grantAwesomePowerBeta2\n*/\ngrantAwesomePowerBeta1()\n```\n```\n\n----------------------------------------\n\nTITLE: Nested vs Flat Property Structure in AWS CDK\nDESCRIPTION: Comparison of nested and flat property structures for AWS CDK constructs, showing how flat structures are preferred for better discoverability and ease of use across languages.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew Bucket(this, 'MyBucket', {\n  bucketWebSiteConfiguration: {\n    errorDocument: '404.html',\n    indexDocument: 'index.html',\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS KendraRanking Constructs - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to import the AWS KendraRanking module using AWS CDK in TypeScript. This import is necessary to access L1 constructs, allowing you to define and manage AWS::KendraRanking CloudFormation resources programmatically. The snippet assumes the dependency on the 'aws-cdk-lib' package is satisfied.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kendraranking/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as kendraranking from 'aws-cdk-lib/aws-kendraranking';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Control Tower Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS Control Tower module in a CDK application using TypeScript. This provides access to L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-controltower/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as controltower from 'aws-cdk-lib/aws-controltower';\n```\n\n----------------------------------------\n\nTITLE: Counting Resources with New `resourceCountIs` (TypeScript)\nDESCRIPTION: Shows the replacement method `resourceCountIs` from `@aws-cdk/assertions`. It's called on a `Template` instance created from the stack and asserts the number of resources matching the specified type (`FOO::BAR`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nTemplate.fromStack(stack).resourceCountIs('FOO::BAR', 1);\n```\n```\n\n----------------------------------------\n\nTITLE: Excluding URLs in Poetry-based Lambda Packaging\nDESCRIPTION: Configures the bundling process to exclude URLs in Poetry-managed Python Lambda functions using the poetryWithoutUrls option.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonFunction(this, 'function', {\n  entry: '/path/to/poetry-function',\n  runtime: Runtime.PYTHON_3_8,\n  bundling: {\n    poetryWithoutUrls: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Properly Documenting Default Behavior for Props in AWS CDK\nDESCRIPTION: Example of correctly documenting default behavior for optional properties using the @default tag with a description that starts with a dash and explains the behavior when the property is not provided.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * External KMS key to use for bucket encryption.\n *\n * @default - if encryption is set to \"Kms\" and this property is undefined, a\n * new KMS key will be created and associated with this bucket.\n */\nencryptionKey?: kms.IEncryptionKey;\n```\n\n----------------------------------------\n\nTITLE: Using spec2cdk CLI Command Line Interface\nDESCRIPTION: Command line usage syntax for the spec2cdk CLI. Shows available command arguments and options for generating CDK L1 code including output path patterns, augmentation options, and service filtering.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/spec2cdk/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nUsage:\n    spec2cdk <OUTPUT-PATH> [--option=value]\n\nArguments:\n    OUTPUT-PATH                         The directory the generated code will be written to\n\nOptions:\n        --augmentations                 [string] [default: %moduleName%/%serviceShortName%-augmentations.generated.ts]\n          File and path pattern for generated augmentations files\n        --augmentations-support         [boolean]\n          Generates additional files required for augmentation files to compile. Use for testing only\n        --clear-output                  [boolean]\n          Completely delete the output path before generating new files\n        --debug                         [boolean]\n          Show additional debug output\n    -h, --help                          [boolean]\n          Show this help\n        --metrics                       [string] [default: %moduleName%/%serviceShortName%-canned-metrics.generated.ts]\n          File and path pattern for generated canned metrics files \n        --pattern                       [string] [default: %moduleName%/%serviceShortName%.generated.ts]\n          File and path pattern for generated files\n    -s, --service                       [array]\n          Generate files only for a specific service, e.g. AWS::S3\n\nPath patterns can use the following variables:\n\n    %moduleName%          The name of the module, e.g. aws-lambda\n    %serviceName%         The full name of the service, e.g. aws-lambda\n    %serviceShortName%    The short name of the service, e.g. lambda\n\nNote that %moduleName% and %serviceName% can be different if multiple services are generated into a single module.\n```\n\n----------------------------------------\n\nTITLE: Run foreach.sh on Dependency Closure - Console Command - Bash\nDESCRIPTION: This bash snippet demonstrates moving into a specific AWS CDK package directory and running 'foreach.sh --up' to invoke a command on the package and all its dependencies in topological order. Useful for targeted builds or checks. Requires correct repo structure and scripts present.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\n$ cd packages/my-module\\n$ ../scripts/foreach.sh --up COMMAND\n```\n\n----------------------------------------\n\nTITLE: Importing QLDB Module in AWS CDK\nDESCRIPTION: Example showing how to import the AWS QLDB module in a CDK application. This import statement allows access to L1 QLDB constructs for infrastructure definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-qldb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as qldb from 'aws-cdk-lib/aws-qldb';\n```\n\n----------------------------------------\n\nTITLE: Defining QueueProcessingServiceBaseProps Interface in TypeScript\nDESCRIPTION: Interface defining common properties for both EC2 and Fargate queue processing services including cluster configuration, image settings, scaling parameters and environment variables.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-autoscaling-queue-worker.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface QueueProcessingServiceBaseProps {\n  readonly cluster: ICluster;\n  readonly image: ContainerImage;\n  readonly command?: string[];\n  readonly desiredTaskCount?: number;\n  readonly enableLogging?: boolean;\n  readonly environment?: { [key: string]: string };\n  readonly queue?: IQueue;\n  readonly maxScalingCapacity?: number;\n  readonly scalingSteps: autoScaling.ScalingInterval[];\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS ResourceGroups Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS ResourceGroups module from the AWS CDK library. This import is necessary to use the L1 constructs provided for interacting with AWS ResourceGroups within a CDK application, as higher-level L2 constructs are not yet available for this service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-resourcegroups/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as resourcegroups from 'aws-cdk-lib/aws-resourcegroups';\n```\n\n----------------------------------------\n\nTITLE: Importing ElastiCache Module in TypeScript\nDESCRIPTION: Basic import statement for using AWS ElastiCache constructs in a CDK application. This provides access to the L1 constructs for ElastiCache service integration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-elasticache/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as elasticache from 'aws-cdk-lib/aws-elasticache';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS BCMDataExports Construct Library - AWS CDK - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import the AWS BCMDataExports construct library into your AWS CDK project. The import statement uses the aws-cdk-lib package to access the automatically generated L1 constructs for AWS::BCMDataExports, enabling you to define and deploy related CloudFormation resources from your CDK app. No external dependencies are required apart from aws-cdk-lib, and this snippet is included as a foundational step for any further interaction with the BCMDataExports service in the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-bcmdataexports/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as bcmdataexports from 'aws-cdk-lib/aws-bcmdataexports';\n```\n\n----------------------------------------\n\nTITLE: Publishing a New Integration Test using Yarn Integ - Shell Command\nDESCRIPTION: This Yarn command publishes or redeploys a new or updated integration test for AWS EKS, optionally skipping cleanup and updating the snapshot on test failure. It assumes all dependencies are installed and that the test file path is valid and points to a compiled .js file. This command is intended to accelerate integration test cycles and troubleshooting.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_22\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/@aws-cdk-testing/framework-integ\n$ yarn integ test/aws-eks/test/integ.my-test.js --no-clean --update-on-failed\n```\n\n----------------------------------------\n\nTITLE: Adding Warnings to AWS CDK Constructs with Annotations API (TypeScript)\nDESCRIPTION: Shows how to add a warning message at synthesis time for a given construct scope using the existing (pre-v2) `Annotations.of(scope).addWarning(message)` API. This method stores warnings as construct node metadata, which is processed by the CLI after synthesis. Dependencies are the AWS CDK with the constructs library, and the key input is a single warning string; no unique identifiers are supported in this approach.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/acknowledge-warnings.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nAnnotations.of(scope).addWarning('This is a warning');\n```\n\n----------------------------------------\n\nTITLE: Importing WorkSpacesThinClient Module in TypeScript\nDESCRIPTION: Imports the necessary AWS CDK module (`aws-workspacesthinclient`) from the `aws-cdk-lib` package. This allows developers to use the L1 constructs provided for the AWS WorkSpacesThinClient service within their CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-workspacesthinclient/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as workspacesthinclient from 'aws-cdk-lib/aws-workspacesthinclient';\n```\n\n----------------------------------------\n\nTITLE: Disabling Cross-Account Keys in Pipeline Configuration\nDESCRIPTION: Creates a pipeline without generating Customer Master Keys (CMKs) by setting crossAccountKeys to false. This avoids the $1/month cost when cross-account deployments aren't needed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Don't create Customer Master Keys\nconst pipeline = new codepipeline.Pipeline(this, 'MyFirstPipeline', {\n  crossAccountKeys: false,\n});\n```\n\n----------------------------------------\n\nTITLE: API Gateway V2 Resource Configuration Properties\nDESCRIPTION: Definition of AWS API Gateway V2 components including API mappings, authorizers, deployments, and domain configurations. These classes represent CloudFormation resources for API Gateway V2.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/deprecated_apis.txt#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface CfnApiV2Props {\n  readonly apiKeySelectionExpression?: string;\n  readonly basePath?: string;\n  readonly body?: any;\n  readonly bodyS3Location?: CfnApiV2.BodyS3LocationProperty;\n  readonly corsConfiguration?: CfnApiV2.CorsProperty;\n  readonly credentialsArn?: string;\n  readonly description?: string;\n  readonly disableSchemaValidation?: boolean;\n  readonly failOnWarnings?: boolean;\n  readonly name?: string;\n  readonly protocolType?: string;\n  readonly routeKey?: string;\n  readonly routeSelectionExpression?: string;\n  readonly tags?: any;\n  readonly target?: string;\n  readonly version?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing MWAA Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the MWAA module from the aws-cdk-lib package. It allows developers to use MWAA-related constructs in their CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mwaa/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as mwaa from 'aws-cdk-lib/aws-mwaa';\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK Python Packages\nDESCRIPTION: Installs AWS CDK Python wheel files into the current Python environment using pip\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install path/to/zip/python/*.whl\n```\n\n----------------------------------------\n\nTITLE: Creating a GitHub Source Action in CodePipeline\nDESCRIPTION: This snippet demonstrates how to use a GitHub repository as the source in CodePipeline. It includes setting up the pipeline, creating the source action, and using a GitHub access token stored in Secrets Manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Read the secret from Secrets Manager\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst sourceOutput = new codepipeline.Artifact();\nconst sourceAction = new codepipeline_actions.GitHubSourceAction({\n  actionName: 'GitHub_Source',\n  owner: 'awslabs',\n  repo: 'aws-cdk',\n  oauthToken: SecretValue.secretsManager('my-github-token'),\n  output: sourceOutput,\n  branch: 'develop', // default: 'master'\n});\npipeline.addStage({\n  stageName: 'Source',\n  actions: [sourceAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing LakeFormation Module in TypeScript\nDESCRIPTION: Basic import statement for the AWS LakeFormation module from AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lakeformation/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lakeformation from 'aws-cdk-lib/aws-lakeformation';\n```\n\n----------------------------------------\n\nTITLE: Importing OSIS Module in AWS CDK\nDESCRIPTION: Example showing how to import the AWS OSIS module in a CDK application. This provides access to L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-osis/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as osis from 'aws-cdk-lib/aws-osis';\n```\n\n----------------------------------------\n\nTITLE: Proposed API Interface Changes - Core TypeScript Definitions\nDESCRIPTION: New TypeScript interface definitions for supporting mixed provisioned and serverless instances in Aurora clusters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rds/adr/aurora-serverless-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DatabaseClusterBaseProps {\n  ...\n  /**\n   * @deprecated - use clusterInstances instead\n   */\n  readonly instances?: number;\n  /**\n   * @deprecated - use clusterInstances instead\n   */\n  readonly instanceProps?: InstanceProps;\n  readonly clusterInstances?: ClusterInstances;\n}\n\ninterface ClusterInstances {\n  readonly writer: IClusterInstance;\n  readonly readers?: IClusterInstance[];\n}\n\nclass ClusterInstance implements IClusterInstance {\n  public static provisioned(id: string, props: ProvisionedClusterInstanceProps = {}): IClusterInstance {\n    return new ClusterInstance(id, {\n      ...props,\n      instanceType: ClusterInstanceType.provisioned(props.instanceType),\n    });\n  }\n\n  public static serverlessV2(id: string, props: ServerlessV2ClusterInstanceProps = {}): IClusterInstance {\n    return new ClusterInstance(id, {\n      ...props,\n      instanceType: ClusterInstanceType.serverlessV2(),\n    });\n  }\n  private constructor(private id: string, private readonly props: ClusterInstanceProps = {}) { }\n\n  public bind(scope: Construct, cluster: DatabaseCluster, props: ClusterInstanceBindOptions): IAuroraClusterInstance {\n    // new class to represent this concept\n    return new AuroraClusterInstance(scope, this.id, {\n      cluster,\n      ...this.props,\n      ...props,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon Neptune module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the Amazon Neptune module from the AWS CDK library in a TypeScript project. It allows access to Neptune-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-neptune/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as neptune from 'aws-cdk-lib/aws-neptune';\n```\n\n----------------------------------------\n\nTITLE: Using CLI Credentials with AppStagingSynthesizer\nDESCRIPTION: Configuration of AppStagingSynthesizer to use CLI credentials for deployment operations instead of predefined roles.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    deploymentIdentities: DeploymentIdentities.cliCredentials(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Tarball Image Asset\nDESCRIPTION: Creates a Docker image asset from a local tarball file for deployment to ECR.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TarballImageAsset } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new TarballImageAsset(this, 'MyBuildImage', {\n  tarballFile: 'local-image.tar',\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting VPC Peering Connection via AWS CLI (Bash)\nDESCRIPTION: Shows the AWS CLI command (`aws ec2 delete-vpc-peering-connection`) used to delete an existing VPC peering connection. It requires the specific ID of the VPC peering connection (`pcx-xxxxxxxx`) to be deleted. Dependencies include having the AWS CLI installed and configured with appropriate permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n```bash\naws ec2 delete-vpc-peering-connection --vpc-peering-connection-id pcx-xxxxxxxx\n```\n```\n\n----------------------------------------\n\nTITLE: Using an Existing Staging Stack in TypeScript\nDESCRIPTION: Demonstrates how to use AppStagingSynthesizer.customResources() to supply an existing stack that implements IStagingResources as the staging stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst resourceApp = new App();\nconst resources = new CustomStagingStack(resourceApp, 'CustomStagingStack', {});\n\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.customResources({\n    resources,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS WorkSpaces Constructs in AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates importing the Amazon WorkSpaces construct library from the AWS CDK in a TypeScript project. It is a foundational step required to define and provision WorkSpaces resources using CDK. The import relies on the 'aws-cdk-lib' npm package, specifically its 'aws-workspaces' module. No parameters are needed; the output is access to the WorkSpaces constructs namespace, used in subsequent infrastructure definitions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-workspaces/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as workspaces from 'aws-cdk-lib/aws-workspaces';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS QuickSight module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS QuickSight module in a TypeScript project using AWS CDK. It allows access to QuickSight-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-quicksight/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as quicksight from 'aws-cdk-lib/aws-quicksight';\n```\n\n----------------------------------------\n\nTITLE: Setting Queue Timeout in CodeBuild Project\nDESCRIPTION: Shows how to configure a queued timeout duration for a CodeBuild project to limit how long a build can remain in the queue.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nnew codebuild.Project(this, 'MyProject', {\n  queuedTimeout: Duration.minutes(30)\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced GameSessionQueue Placement in AWS GameLift (TypeScript)\nDESCRIPTION: This code shows how to configure a more complex GameSessionQueue in AWS GameLift with custom event data, location restrictions, SNS notifications, player latency rules, and detailed priority order for placement decisions. It depends on declared BuildFleet and SNS Topic instances. Key parameters control not only destinations and allowed regions but also notification and latency policy settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const fleet: gamelift.BuildFleet;\ndeclare const topic: sns.Topic;\n\nnew gamelift.GameSessionQueue(this, 'MyGameSessionQueue', {\n      gameSessionQueueName: 'test-gameSessionQueue',\n      customEventData: 'test-event-data',\n      allowedLocations: ['eu-west-1', 'eu-west-2'],\n      destinations: [fleet],\n      notificationTarget: topic,\n      playerLatencyPolicies: [{\n        maximumIndividualPlayerLatency: Duration.millis(100),\n        policyDuration: Duration.seconds(300),\n      }],\n      priorityConfiguration: {\n        locationOrder: [\n          'eu-west-1',\n          'eu-west-2',\n        ],\n        priorityOrder: [\n          gamelift.PriorityType.LATENCY,\n          gamelift.PriorityType.COST,\n          gamelift.PriorityType.DESTINATION,\n          gamelift.PriorityType.LOCATION,\n        ],\n      },\n      timeout: Duration.seconds(300),\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring Handler Framework Components in TypeScript\nDESCRIPTION: Example TypeScript configuration object (`config.ts`) demonstrating how to define components for the CDK Handler Framework. It shows mapping AWS CDK modules (e.g., 'aws-s3', 'aws-stepfunctions-tasks') to component modules (e.g., 'replica-provider', 'eval-nodejs-provider') and specifying `ComponentProps` like `type`, `sourceCode`, `handler`, `runtime`, and `minifyAndBundle` for code generation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/custom-resource-handlers/lib/custom-resources-framework/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst config = {\n  'aws-s3': { // the aws-cdk-lib module\n    'replica-provider': [ // the component module\n      // handler framework component defined as a `ComponentProps` object\n      {\n        // the handler framework component type\n        type: ComponentType.FUNCTION,\n        // the source code that the component will use\n        sourceCode: path.resolve(__dirname, '..', 'aws-dynamodb', 'replica-handler', 'index.ts'),\n        // the handler in the source code that the component will execute\n        handler: 'index.onEventHandler',\n      },\n    ],\n  },\n  'aws-stepfunctions-tasks': {\n    // contains multiple component modules\n    'eval-nodejs-provider': [\n      {\n        type: ComponentType.SINGLETON_FUNCTION,\n        sourceCode: path.resolve(__dirname, '..', 'aws-stepfunctions-tasks', 'eval-nodejs-handler', 'index.ts'),\n      },\n    ],\n    'role-policy-provider': [\n      {\n        type: ComponentType.SINGLETON_FUNCTION,\n        sourceCode: path.resolve(__dirname, '..', 'aws-stepfunctions-tasks', 'role-policy-handler', 'index.py'),\n        runtime: Runtime.PYTHON_3_9,\n        // prevent minify and bundle since the source code is a python file\n        minifyAndBundle: false,\n      },\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Adding propagateTaskTagsFrom Property to Ec2ServiceProps Interface in TypeScript\nDESCRIPTION: Extends the Ec2ServiceProps interface to include the propagateTaskTagsFrom property. This property allows users to specify how tags should be propagated for EC2-based ECS services.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Ec2ServiceProps extends BaseServiceOptions {\n\n  ...\n\n   /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service.\n   * Tags can only be propagated to the tasks within the service during service creation.\n   *\n   * @default  PropagatedTagSource.SERVICE\n   */\n  readonly propagateTaskTagsFrom?: PropagatedTagSource;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Cognito Identity Pool Components in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the necessary components from the AWS CDK library to work with Cognito Identity Pools.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IdentityPool, UserPoolAuthenticationProvider } from 'aws-cdk-lib/aws-cognito-identitypool';\n```\n\n----------------------------------------\n\nTITLE: Implementing Tag Properties in BaseService Class Constructor in TypeScript\nDESCRIPTION: Updates the BaseService class constructor to include the new tag propagation and ECS managed tags properties. These properties are used when creating the CfnService resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport abstract class BaseService extends Resource\n  implements IService, elbv2.IApplicationLoadBalancerTarget, elbv2.INetworkLoadBalancerTarget {\n\n  ...\n\n  constructor(scope: Construct,\n              id: string,\n              props: BaseServiceProps,\n              additionalProps: any,\n              taskDefinition: TaskDefinition) {\n\n    ...\n\n    this.resource = new CfnService(this, \"Service\", {\n      desiredCount: props.desiredCount,\n      serviceName: this.physicalName,\n      loadBalancers: Lazy.anyValue({ produce: () => this.loadBalancers }),\n      deploymentConfiguration: {\n        maximumPercent: props.maxHealthyPercent || 200,\n        minimumHealthyPercent: props.minHealthyPercent === undefined ? 50 : props.minHealthyPercent\n      },\n      propagateTags: props.propagateTags === PropagatedTagSource.NONE ? undefined : props.propagateTags,\n      enableEcsManagedTags: props.enableECSManagedTags === undefined ? true : props.enableECSManagedTags,\n      launchType: props.launchType,\n      healthCheckGracePeriodSeconds: this.evaluateHealthGracePeriod(props.healthCheckGracePeriod),\n      /* role: never specified, supplanted by Service Linked Role */\n      networkConfiguration: Lazy.anyValue({ produce: () => this.networkConfiguration }),\n      serviceRegistries: Lazy.anyValue({ produce: () => this.serviceRegistries }),\n      ...additionalProps\n    });\n\n    ...\n\n  }\n\n  ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: Import Namespace Configuration for .NET\nDESCRIPTION: Shows the correct namespace to use for DotNet implementations due to jsiirc.json file issues.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nusing Amazon.CDK.AwsApigatewayv2Integrations;\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard and Custom Attributes for Cognito User Pool in TypeScript\nDESCRIPTION: This AWS CDK code configures attributes for a Cognito User Pool. It defines standard attributes like 'fullname' (required, immutable) and 'address' (optional, mutable) using the `standardAttributes` property. It also adds several custom attributes ('myappid', 'callingcode', 'isEmployee', 'joinedOn') with specific types (String, Number, Boolean, DateTime), constraints (min/max length, min/max value), and mutability settings via the `customAttributes` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  standardAttributes: {\n    fullname: {\n      required: true,\n      mutable: false,\n    },\n    address: {\n      required: false,\n      mutable: true,\n    },\n  },\n  customAttributes: {\n    'myappid': new cognito.StringAttribute({ minLen: 5, maxLen: 15, mutable: false }),\n    'callingcode': new cognito.NumberAttribute({ min: 1, max: 3, mutable: true }),\n    'isEmployee': new cognito.BooleanAttribute({ mutable: true }),\n    'joinedOn': new cognito.DateTimeAttribute(),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS EKS Node Authentication with ConfigMap\nDESCRIPTION: YAML configuration for aws-auth ConfigMap that enables worker nodes to join the EKS cluster. This config maps IAM roles to Kubernetes RBAC permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-eks/test/MANUAL_TEST.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aws-auth\n  namespace: kube-system\ndata:\n  mapRoles: |\n    - rolearn: <ROLE ARN>\n      username: system:node:{{EC2PrivateDNSName}}\n      groups:\n        - system:bootstrappers\n        - system:nodes\n```\n\n----------------------------------------\n\nTITLE: Deprecated RDS Database Engine Versions in AWS CDK\nDESCRIPTION: Several database engine versions for MariaDB, MySQL, and Oracle are deprecated due to approaching end-of-life dates or discontinuation of support. Use newer versions instead.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated MariaDB versions (10.0 and 10.1)\nMariaDbEngineVersion.VER_10_0\nMariaDbEngineVersion.VER_10_1\n\n// Deprecated MySQL versions (5.5 and 5.6)\nMysqlEngineVersion.VER_5_5\nMysqlEngineVersion.VER_5_6\n\n// Deprecated Oracle versions\nDatabaseInstanceEngine.ORACLE_SE\nDatabaseInstanceEngine.ORACLE_SE1\nDatabaseInstanceEngine.oracleSe()\nDatabaseInstanceEngine.oracleSe1()\n\n// Use newer supported versions instead\n```\n\n----------------------------------------\n\nTITLE: Importing AWS MediaConnect Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS MediaConnect module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediaconnect/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediaconnect from 'aws-cdk-lib/aws-mediaconnect';\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Detective Module in TypeScript\nDESCRIPTION: Shows how to import the AWS Detective module in a TypeScript CDK application. This is the basic import statement needed to start using Detective resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-detective/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as detective from 'aws-cdk-lib/aws-detective';\n```\n\n----------------------------------------\n\nTITLE: Matching Templates with Old `toMatchTemplate` (TypeScript)\nDESCRIPTION: Illustrates the deprecated `toMatchTemplate` Jest matcher from `@aws-cdk/assert` used to assert that the synthesized CloudFormation template for a stack matches a given JSON structure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexpect(stack).toMatchTemplate({/*...*/});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing DotNet Namespace for AWS CDK Authorizers - C#\nDESCRIPTION: This snippet provides the workaround for importing AWS CDK authorizers in DotNet where the standard namespace is not available due to a missing jsiirc.json. Instead of using the traditional 'Amazon.CDK.AWS.Apigatewayv2.Authorizers' namespace, 'Amazon.CDK.AwsApigatewayv2Authorizers' should be used. This is a purely syntactic change required for compatibility with this module version.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-authorizers/README.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing Amazon.CDK.AwsApigatewayv2Authorizers;;\n```\n\n----------------------------------------\n\nTITLE: Configuring CodeBuild Action as Test Type in TypeScript\nDESCRIPTION: This snippet shows how to configure a CodeBuildAction in CodePipeline to represent a 'Test' action category instead of the default 'Build' category. This is achieved by setting the `type` property to `codepipeline_actions.CodeBuildActionType.TEST`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const project: codebuild.PipelineProject;\nconst sourceOutput = new codepipeline.Artifact();\nconst testAction = new codepipeline_actions.CodeBuildAction({\n  actionName: 'IntegrationTest',\n  project,\n  input: sourceOutput,\n  type: codepipeline_actions.CodeBuildActionType.TEST, // default is BUILD\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Dedicated Coordinator Nodes for OpenSearch Domain in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure dedicated coordinator nodes for an OpenSearch domain using the `nodeOptions` property within the `capacity` configuration. It specifies the node type as `opensearch.NodeType.COORDINATOR`, enables them, sets the count to 2, and defines the instance type (`m5.large.search`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as opensearch from 'aws-cdk-lib/aws-opensearchservice';\n\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_3,\n  capacity: {\n    nodeOptions: [\n      {\n        nodeType: opensearch.NodeType.COORDINATOR,\n        nodeConfig: {\n          enabled: true,\n          count: 2,\n          type: 'm5.large.search',\n        },\n      },\n    ],\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Policy Statements\nDESCRIPTION: Adds statements to the repository's resource policy for access control.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr/README.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nrepository.addToResourcePolicy(new iam.PolicyStatement({\n  actions: ['ecr:GetDownloadUrlForLayer'],\n  principals: [new iam.AnyPrincipal()],\n}));\n```\n\n----------------------------------------\n\nTITLE: Lazified JavaScript with delayed require()\nDESCRIPTION: The transformed JavaScript code with lazy loading. The module is only loaded when the function that uses it is called, improving startup performance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/lazify/README.md#2025-04-23_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nfunction my_module_1() {\n  return require('./my-module');\n}\n\nfunction hello() {\n  return my_module_1().hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Updating IAM Principal References\nDESCRIPTION: Replace deprecated Anyone with AnyPrincipal. Use addToPrincipalPolicy instead of addToPolicy for IPrincipal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nAnyone\nprincipal.addToPolicy()\n\n// New\nAnyPrincipal\nprincipal.addToPrincipalPolicy()\n```\n\n----------------------------------------\n\nTITLE: Configuring Unsigned Basic Auth\nDESCRIPTION: Sets up an OpenSearch domain with unsigned basic authentication support.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-opensearchservice/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst domain = new Domain(this, 'Domain', {\n  version: EngineVersion.OPENSEARCH_1_0,\n  useUnsignedBasicAuth: true,\n});\n\nconst masterUserPassword = domain.masterUserPassword;\n```\n\n----------------------------------------\n\nTITLE: Importing DevOpsGuru Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS DevOpsGuru module from aws-cdk-lib for use in AWS CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-devopsguru/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as devopsguru from 'aws-cdk-lib/aws-devopsguru';\n```\n\n----------------------------------------\n\nTITLE: Importing PCA Connector SCEP Module in TypeScript\nDESCRIPTION: Demonstrates how to import the AWS PCA Connector SCEP module in a TypeScript CDK application. This import statement provides access to all L1 constructs for working with PCA Connector SCEP resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pcaconnectorscep/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pcaconnectorscep from 'aws-cdk-lib/aws-pcaconnectorscep';\n```\n\n----------------------------------------\n\nTITLE: Adding propagateTaskTagsFrom Property to FargateServiceProps Interface in TypeScript\nDESCRIPTION: Extends the FargateServiceProps interface to include the propagateTaskTagsFrom property. This property allows users to specify how tags should be propagated for Fargate-based ECS services.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FargateServiceProps extends BaseServiceOptions {\n\n  ...\n\n   /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service.\n   * Tags can only be propagated to the tasks within the service during service creation.\n   *\n   * @default  PropagatedTagSource.SERVICE\n   */\n  readonly propagateTaskTagsFrom?: PropagatedTagSource;\n}\n```\n\n----------------------------------------\n\nTITLE: Waiter Provider IAM Policy\nDESCRIPTION: Shows how to add IAM policies when using waitForAssertion() with type casting to AwsApiCall.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst apiCall = integ.assertions.awsApiCall('S3', 'listObjectsV2', {\n  Bucket: 'mybucket',\n}).waitForAssertions() as AwsApiCall;\n\napiCall.waiterProvider?.addToRolePolicy({\n  Effect: 'Allow',\n  Action: ['s3:GetObject', 's3:ListBucket'],\n  Resource: ['*'],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AppIntegrations Module with AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to import the AWS AppIntegrations module from the aws-cdk-lib in a TypeScript project, enabling the use of L1 CloudFormation resource constructs related to AWS AppIntegrations. The only dependency is the aws-cdk-lib NPM package. This import allows you to use the AppIntegrations resources in your CDK stack as you would with native CloudFormation. No parameters are required in the import. Output is the imported namespace which should be referenced in subsequent CDK code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appintegrations/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as appintegrations from 'aws-cdk-lib/aws-appintegrations';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SSM Quick Setup Module in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to import the `aws-ssmquicksetup` module from the `aws-cdk-lib`. This import allows the use of the low-level (L1) CloudFormation constructs provided by this module within an AWS CDK application. Note that higher-level (L2) constructs are not yet available for this service in the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssmquicksetup/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport * as ssmquicksetup from 'aws-cdk-lib/aws-ssmquicksetup';\n```\n\n----------------------------------------\n\nTITLE: Displaying Axios Critical Vulnerability Warning Text\nDESCRIPTION: This text snippet, found repeatedly throughout the Axios changelog under different version sections (associated with PR #6028), serves as a critical warning about the security vulnerability CVE-2023-45857. It directs users to a Snyk page (https://security.snyk.io/vuln/SNYK-JS-AXIOS-6032459) for more details.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n\n\n Critical vulnerability fix. See https://security.snyk.io/vuln/SNYK-JS-AXIOS-6032459\n\n```\n\n----------------------------------------\n\nTITLE: Defining Function Interface with Specific Metrics\nDESCRIPTION: Interface definition showing specific metric methods for AWS Lambda functions, including duration, invocations and throttles metrics.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IFunction {\n  metricDuration(options?: cloudwatch.MetricOptions): cloudwatch.Metric;\n  metricInvocations(options?: cloudwatch.MetricOptions): cloudwatch.Metric;\n  metricThrottles(options?: cloudwatch.MetricOptions): cloudwatch.Metric;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding IAM Policy to AppRunner Service\nDESCRIPTION: Adds an IAM policy statement to the AppRunner service's instance role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst service = new apprunner.Service(this, 'Service', {\n  source: apprunner.Source.fromEcrPublic({\n    imageConfiguration: { port: 8000 },\n    imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n  }),\n});\n\nservice.addToRolePolicy(new iam.PolicyStatement({\n  effect: iam.Effect.ALLOW,\n  actions: ['s3:GetObject'],\n  resources: ['*'],\n}))\n```\n\n----------------------------------------\n\nTITLE: Specifying a Custom Backup Vault for a Backup Plan and Its Rules - AWS CDK - TypeScript\nDESCRIPTION: Demonstrates how to use a custom backup vault for all plan rules or a specific rule within an AWS Backup plan via the AWS CDK in TypeScript. It shows using fromBackupVaultName to import vaults, then passing them to BackupPlan and BackupPlanRule constructors. Dependencies include BackupVault and BackupPlan CDK constructs. Result is explicit control over which vaults store recovery points.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-backup/README.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst myVault = backup.BackupVault.fromBackupVaultName(this, 'Vault1', 'myVault');\nconst otherVault = backup.BackupVault.fromBackupVaultName(this, 'Vault2', 'otherVault');\n\nconst plan = backup.BackupPlan.daily35DayRetention(this, 'Plan', myVault); // Use `myVault` for all plan rules\nplan.addRule(backup.BackupPlanRule.monthly1Year(otherVault)); // Use `otherVault` for this specific rule\n```\n\n----------------------------------------\n\nTITLE: Importing AWS EntityResolution L1 Constructs in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS EntityResolution module from the AWS CDK library in TypeScript. This import provides access to the automatically generated L1 constructs, which correspond directly to AWS CloudFormation resources for the EntityResolution service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-entityresolution/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as entityresolution from 'aws-cdk-lib/aws-entityresolution';\n```\n\n----------------------------------------\n\nTITLE: Importing Route53 Recovery Control Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS Route53 Recovery Control module in a CDK application. This import statement provides access to L1 constructs that wrap the CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53recoverycontrol/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as route53recoverycontrol from 'aws-cdk-lib/aws-route53recoverycontrol';\n```\n\n----------------------------------------\n\nTITLE: Run awslint for Specific Rule - Console Command - Bash\nDESCRIPTION: Executes 'lerna run awslint' repo-wide, targeting only a specific awslint rule identified by the rule code. Allows focused compliance tests. Arguments: replace <RULE> with actual rule name.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\nlerna run awslint -- -i <RULE>\n```\n\n----------------------------------------\n\nTITLE: Importing AWS::Rbin module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS::Rbin module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rbin/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as rbin from 'aws-cdk-lib/aws-rbin';\n```\n\n----------------------------------------\n\nTITLE: Importing ARCZonalShift Constructs with AWS CDK in TypeScript\nDESCRIPTION: This snippet shows how to import the ARCZonalShift construct module from the AWS CDK library in TypeScript. It is a required dependency to access ARCZonalShift CloudFormation (L1) constructs. No other setup is necessary besides installing the 'aws-cdk-lib' package, and the import should be present at the top of your CDK application source files before using these constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-arczonalshift/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as arczonalshift from 'aws-cdk-lib/aws-arczonalshift';\n```\n\n----------------------------------------\n\nTITLE: Definition of addWarningV2 Method for Unique ID Warnings in AWS CDK (TypeScript)\nDESCRIPTION: Defines the new `addWarningV2` method signature for adding warnings with unique identifiers and messages in AWS CDK constructs. This enables later acknowledgement or suppression by ID. Prerequisites include extending or customizing the `Annotations` class or similar; parameters include a warning ID (string) and warning message (string).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/acknowledge-warnings.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n  /**\n   * @param id the unique identifier for the warning. This can be used to acknowledge the warning\n   * @param message The warning message.\n   */\n  public addWarningV2(id: string, message: string): void\n```\n\n----------------------------------------\n\nTITLE: Deprecated RedirectResponse Class in AWS CDK\nDESCRIPTION: The RedirectResponse class and its properties are deprecated. Use ListenerAction.redirect() instead for creating redirect responses in Elastic Load Balancing v2.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated\nconst redirectResponse = new RedirectResponse({\n  statusCode: '301',\n  host: 'example.com',\n  path: '/new-path',\n  port: '443',\n  protocol: 'HTTPS',\n  query: 'newquery=true'\n});\n\n// Use this instead\nListenerAction.redirect({\n  statusCode: '301',\n  host: 'example.com',\n  path: '/new-path',\n  port: '443',\n  protocol: 'HTTPS',\n  query: 'newquery=true'\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Lambda Function with VPC Configuration in TypeScript\nDESCRIPTION: An example showing how to test Lambda VPC integration in a dedicated test. This approach tests networking configuration separately from other functionality.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'Handler', {\n  securityGroups,\n  vpc,\n  vpcSubnets,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing CodePipeline and CodePipeline Actions in TypeScript\nDESCRIPTION: This snippet shows how to import the necessary modules for working with CodePipeline and its actions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as codepipeline from 'aws-cdk-lib/aws-codepipeline';\nimport * as codepipeline_actions from 'aws-cdk-lib/aws-codepipeline-actions';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS MemoryDB module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS MemoryDB module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-memorydb/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as memorydb from 'aws-cdk-lib/aws-memorydb';\n```\n\n----------------------------------------\n\nTITLE: Implementing Actions Suppressor for Composite Alarm\nDESCRIPTION: Demonstrates how to implement action suppression for a composite alarm based on a condition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const alarm1: cloudwatch.Alarm;\ndeclare const alarm2: cloudwatch.Alarm;\ndeclare const onAlarmAction: cloudwatch.IAlarmAction;\ndeclare const onOkAction: cloudwatch.IAlarmAction;\ndeclare const actionsSuppressor: cloudwatch.Alarm;\n\nconst alarmRule = cloudwatch.AlarmRule.anyOf(alarm1, alarm2);\n\nconst myCompositeAlarm = new cloudwatch.CompositeAlarm(this, 'MyAwesomeCompositeAlarm', {\n  alarmRule,\n  actionsSuppressor,\n});\nmyCompositeAlarm.addAlarmAction(onAlarmAction);\nmyCompositeAlarm.addOkAction(onOkAction);\n```\n\n----------------------------------------\n\nTITLE: Creating a Lambda Function Target for EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a Lambda function as the target. The pipe will invoke the Lambda function with the events from an SQS queue source.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetFunction: lambda.IFunction;\n\nconst pipeTarget = new targets.LambdaFunction(targetFunction,{});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: CDK Deploy Command for Integration Test\nDESCRIPTION: Command line instruction to deploy the integration test stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncdk deploy --app 'node test/integ.my-function.js'\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Billing with Max Throughput\nDESCRIPTION: Demonstrates how to configure on-demand billing with maximum throughput settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  billing: dynamodb.Billing.onDemand({\n    maxReadRequestUnits: 100,\n    maxWriteRequestUnits: 115,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon SQS Queue as a Pipe Target using AWS CDK (TypeScript)\nDESCRIPTION: This code sets up an Amazon SQS queue as the target of an AWS Pipe with SQS as the event source using AWS CDK (TypeScript). The pipe forwards the event payloads from the source queue to the target queue. Required dependencies are the AWS CDK SQS, Pipes, and related modules. Inputs are two SQS queue constructs; output is a Pipe that connects source and target queues directly.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst pipeTarget = new targets.SqsTarget(targetQueue);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: EKS Cluster Setup and Application Deployment Commands\nDESCRIPTION: Series of kubectl commands to configure cluster access, deploy Redis and Guestbook application components, and verify service status using the Kubernetes sample guestbook application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-eks/test/MANUAL_TEST.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\naws eks update-kubeconfig --name {{ClusterName}}\n\n# File above, with substitutions\nkubectl apply -f aws-auth-cm.yaml\n\n# Check that nodes joined (may take a while)\nkubectl get nodes\n\n# Start services (will autocreate a load balancer)\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-master-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-master-service.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-slave-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-slave-service.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/guestbook-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/guestbook-service.json\n\n# Check up on service status\nkubectl get services -o wide\n```\n\n----------------------------------------\n\nTITLE: Deprecated DynamoDB Table Methods in AWS CDK\nDESCRIPTION: The metricSystemErrors() and grantListStreams() methods on ITable and Table are deprecated. Use metricSystemErrorsForOperations and grantTableListStreams for more granular permissions instead.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated\ntable.metricSystemErrors();\ntable.grantListStreams();\n\n// Use these instead\ntable.metricSystemErrorsForOperations();\ntable.grantTableListStreams();\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Connect Module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS Connect module from aws-cdk-lib to use with your CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-connect/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as connect from 'aws-cdk-lib/aws-connect';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS DataZone module in TypeScript\nDESCRIPTION: Basic import statement for accessing the AWS DataZone constructs in a CDK application. This allows you to create and configure DataZone resources in your infrastructure code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-datazone/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as datazone from 'aws-cdk-lib/aws-datazone';\n```\n\n----------------------------------------\n\nTITLE: SSH Port Forwarding for ELB Access\nDESCRIPTION: SSH command to set up port forwarding when direct access to ELB port 3000 is blocked by corporate network.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-eks/test/MANUAL_TEST.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nssh -L 3000:<ELB ADDRESS>:3000 ssh-box-somewhere.example.com\n\n# Visit http://localhost:3000/\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Contribution Process with Mermaid\nDESCRIPTION: A flowchart diagram illustrating the contribution workflow from identifying functionality to merging or closing pull requests. It shows decision points and different paths for major and minor contributions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n  A(Identify desired functionality) --> B(Consider a contribution)\n  B --> C[External packages]\n  B --> D[Relevant Issues and PRs]\n  C --> E{Is a contribution the right solution?}\n  D --> E\n  E --> |Yes|F{Is your contribution major or minor?}\n  E --> |No|G((Pursue alternative solutions))\n  F --> |Major|H(Submit an RFC to discuss)\n  F --> |Minor|I(Code your changes)\n  H --> Q{Is a contribution the right solution?}\n  I --> J(Submit your PR)\n  J --> K[PR passes checks, linters, and follows design guidelines]\n  K --> L[PR is reviewed]\n  L --> M{Should PR be approved?}\n  M --> |Yes|N((PR is approved and merged))\n  M --> |No|O{Should PR be modified or closed?}\n  O --> |Modified|I\n  O --> |Closed|P((PR is closed))\n  Q --> |Yes|I\n  Q --> |No|S((RFC is closed))\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests for AWS CDK Modules\nDESCRIPTION: Command to run integration tests for specific AWS CDK modules, such as aws-lambda. This ensures that changes work correctly in an integrated environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ cd aws-cdk/packages/@aws-cdk-testing/framework-integ\n$ yarn integ test/aws-lambda/test/integ.lambda.js --update-on-failed\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Failure with Weak References (Mermaid)\nDESCRIPTION: A sequence diagram showing the potential issues if weak references were used instead of CloudFormation's strong references. It depicts a scenario where updating a dependency (Stack1's export) causes the dependent stack (Stack2) update to fail, and subsequent rollback also fails because the original export no longer exists, leading to an unrecoverable state.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/core/adr/cross-region-stack-references.md#2025-04-23_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Note over Stack1,Stack2: Initial Deployment\n    activate Stack2\n    Note over Stack1: Create export amzn-s3-demo-bucket\n    Stack2->>+Stack1: Read export amzn-s3-demo-bucket\n    Note over Stack2: Create Function\n    deactivate Stack2\n    Note over Stack1,Stack2: Second Deployment\n    activate Stack2\n    Note over Stack1: Delete export amzn-s3-demo-bucket\n    Note over Stack1: Create export amzn-s3-demo-bucket1\n    Stack2->>+Stack1: Read export amzn-s3-demo-bucket1\n    deactivate Stack2\n    Note over Stack2: Update Function Failed!\n    Stack2-->>+Stack2: Rollback\n    activate Stack2\n    Stack2->>+Stack1: Read export amzn-s3-demo-bucket\n    Note right of Stack1: Export doesn't exist!\n    deactivate Stack2\n    Note over Stack2: Stack rollback failed!\n    Note over Stack1,Stack2: We're stuck!!  \n```\n```\n\n----------------------------------------\n\nTITLE: Importing DynamoDB Table Data from S3 in Amazon Ion Format Using AWS CDK - TypeScript\nDESCRIPTION: Illustrates initializing a DynamoDB table import from S3 using the Amazon Ion format via AWS CDK in TypeScript. Input requirements mirror earlier snippets (S3 bucket, partition key, gzip compression, key prefix), with 'inputFormat' set using 'ion()' and no extra options. Designed for table creation scenarios requiring Ion-formatted data ingestion from S3. The result is a DynamoDB table prepared for automatic import from the designated S3 location.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as s3 from 'aws-cdk-lib/aws-s3';\n\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'Stack');\n\ndeclare const bucket: s3.IBucket;\n\nnew dynamodb.Table(stack, 'Table', {\n  partitionKey: {\n    name: 'id',\n    type: dynamodb.AttributeType.STRING,\n  },\n  importSource: {\n    compressionType: dynamodb.InputCompressionType.GZIP,\n    inputFormat: dynamodb.InputFormat.ion(),\n    bucket,\n    keyPrefix: 'prefix',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: API Gateway V2 Migration\nDESCRIPTION: Details the migration of API Gateway V2 features to the dedicated aws-apigatewayv2 package. Includes CfnApi, mappings, authorizers, and CORS configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// All these components have moved to @aws-cdk/aws-apigatewayv2\nCfnApiMappingV2\nCfnApiV2\nCfnAuthorizerV2\nBodyS3LocationProperty\nCorsProperty\n// These should be imported from aws-apigatewayv2 package instead\n```\n\n----------------------------------------\n\nTITLE: Checking IPAM Pool Allocations using AWS CLI\nDESCRIPTION: This command demonstrates how to check allocations for an IPAM pool using the AWS CLI. It's useful for troubleshooting issues with IPAM pool deletion during CDK stack destruction.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\naws ec2 get-ipam-pool-allocations --ipam-pool-id <ipam-pool-id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Triggers for a Custom Config Rule in TypeScript\nDESCRIPTION: Demonstrates how to configure triggers for a custom Config rule. The rule is set to run on both configuration changes and periodically, with a maximum execution frequency of six hours.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-config/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const evalComplianceFn: lambda.Function;\n\nnew config.CustomRule(this, 'CustomRule', {\n  lambdaFunction: evalComplianceFn,\n  configurationChanges: true,\n  periodic: true,\n\n  // default is 24 hours\n  maximumExecutionFrequency: config.MaximumExecutionFrequency.SIX_HOURS,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS QBusiness Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS QBusiness module in a TypeScript project using the AWS CDK library. It allows access to QBusiness-related constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-qbusiness/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as qbusiness from 'aws-cdk-lib/aws-qbusiness';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS SSMIncidents Module - TypeScript\nDESCRIPTION: This snippet shows how to import the aws-cdk-lib/aws-ssmincidents module in a TypeScript AWS CDK application. This import enables use of AWS::SSMIncidents Level 1 constructs by making the generated CloudFormation resources available for programmatic use within CDK stacks. Prerequisites include installation of aws-cdk-lib and all required peer dependencies. This example does not instantiate any constructs directly, but is required as the first step in working with SSMIncidents resources via CDK. No parameters are needed for this import, and no output is produced beyond providing access to the constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ssmincidents/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ssmincidents from 'aws-cdk-lib/aws-ssmincidents';\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing IVS Channel\nDESCRIPTION: References an existing IVS channel using its ARN. This allows working with channels that were created outside the current CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ivs-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myChannel = ivs.Channel.fromChannelArn(this, 'Channel', myChannelArn);\n```\n\n----------------------------------------\n\nTITLE: Implementing Feature Flag Testing in TypeScript\nDESCRIPTION: Example showing how to test features with feature flags enabled in CDK application tests. Demonstrates setting up an App instance with context-based feature flags.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFeatureFlag = { [cxapi.MY_FEATURE_FLAG]: true };\nconst app = new App({\n   context: myFeatureFlag,\n}),\nconst stackUnderTest = new Stack(app);\n```\n\n----------------------------------------\n\nTITLE: Importing SQS Construct Library in TypeScript\nDESCRIPTION: Imports the necessary `aws-sqs` module from the `aws-cdk-lib` package to enable the definition of SQS resources within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sqs from 'aws-cdk-lib/aws-sqs';\n```\n\n----------------------------------------\n\nTITLE: Accessing the S3 AccessPoint ARN from an Object Lambda AccessPoint\nDESCRIPTION: Example showing how to retrieve the S3 AccessPoint ARN from an S3 Object Lambda AccessPoint. This is useful when you need to reference the underlying S3 AccessPoint in other parts of your infrastructure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-s3objectlambda-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s3objectlambda from '@aws-cdk/aws-s3objectlambda-alpha';\n\ndeclare const accessPoint: s3objectlambda.AccessPoint;\nconst s3AccessPointArn = accessPoint.s3AccessPointArn;\n```\n\n----------------------------------------\n\nTITLE: Event Handler Method Signature\nDESCRIPTION: Standard signature for event handler methods in AWS resources that emit CloudWatch events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nonXxx(id: string, target: events.IEventRuleTarget, options?: XxxOptions): cloudwatch.EventRule;\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Neptune Database Cluster\nDESCRIPTION: Demonstrates how to create a Neptune database cluster within a VPC with a specific instance type. By default, only a writer instance is provisioned.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new neptune.DatabaseCluster(this, 'Database', {\n  vpc,\n  instanceType: neptune.InstanceType.R5_LARGE,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Transitions to a Stage\nDESCRIPTION: Configures a stage with disabled transitions, requiring manual approval to proceed. This is useful for controlling deployment flow to specific environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Disable transition to a stage\ndeclare const pipeline: codepipeline.Pipeline;\n\nconst someStage = pipeline.addStage({\n  stageName: 'SomeStage',\n  transitionToEnabled: false,\n  transitionDisabledReason: 'Manual transition only', // optional reason\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon FSx CDK Module in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the Amazon FSx construct library from the AWS CDK for use in a TypeScript project. Required as a prerequisite for creating and managing FSx file systems via CDK constructs. No key parameters; this enables usage of CDK FSx APIs in downstream code. Ensure that 'aws-cdk-lib' is installed in your project dependencies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-fsx/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as fsx from 'aws-cdk-lib/aws-fsx';\n```\n\n----------------------------------------\n\nTITLE: Configuring AppStagingSynthesizer with Custom IAM Roles\nDESCRIPTION: Setup of AppStagingSynthesizer with custom IAM roles for CloudFormation execution, deployment, and lookup operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    deploymentIdentities: DeploymentIdentities.specifyRoles({\n      cloudFormationExecutionRole: BootstrapRole.fromRoleArn('arn:aws:iam::123456789012:role/Execute'),\n      deploymentRole: BootstrapRole.fromRoleArn('arn:aws:iam::123456789012:role/Deploy'),\n      lookupRole: BootstrapRole.fromRoleArn('arn:aws:iam::123456789012:role/Lookup'),\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Guardian GitHub Action in Workflow\nDESCRIPTION: Example of how to set up the Security Guardian GitHub Action in a workflow file. It specifies data directory for templates, path to rule set, summary display preference, and output format.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/security-guardian/README.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Run CFN Guard\n  uses: ./tools/@aws-cdk/security-guardian\n  with:\n    data_directory: './changed_templates'\n    rule_set_path: './tools/@aws-cdk/security-guardian/rules/trust_scope_rules.guard'\n    show_summary: 'fail'\n    output_format: 'single-line-summary'\n```\n\n----------------------------------------\n\nTITLE: Importing Route53Profiles Module in TypeScript\nDESCRIPTION: Code example showing how to import the AWS Route53Profiles module from the AWS CDK library for use in TypeScript applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53profiles/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as route53profiles from 'aws-cdk-lib/aws-route53profiles';\n```\n\n----------------------------------------\n\nTITLE: Importing AWS RUM Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS RUM module from aws-cdk-lib for use in CDK applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rum/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as rum from 'aws-cdk-lib/aws-rum';\n```\n\n----------------------------------------\n\nTITLE: Setting Up User Invitation Messages in TypeScript\nDESCRIPTION: This code configures the invitation messages for a Cognito User Pool, including email subject, body, and SMS message templates.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  // ...\n  userInvitation: {\n    emailSubject: 'Invite to join our awesome app!',\n    emailBody: 'Hello {username}, you have been invited to join our awesome app! Your temporary password is {####}',\n    smsMessage: 'Hello {username}, your temporary password for our awesome app is {####}',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Action Workflow for prlint\nDESCRIPTION: YAML configuration for setting up a GitHub Action workflow that uses the prlint action to validate pull requests. Includes steps for checkout, building the package, and running the linter.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/prlint/README.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nsteps:\n  - name: Checkout # checkout the package that contains prlint\n    uses: actions/checkout@v2\n\n  - name: Install & Build # install & build prlint\n    run: cd path/to/prlint && yarn install --frozen-lockfile && yarn build\n\n  - name: Lint\n    uses: ./path/to/prlint\n    env:\n      REPO_ROOT: ${{ github.workspace }}\n```\n\n----------------------------------------\n\nTITLE: Clean Build Commands in Shell\nDESCRIPTION: Shell commands for performing a complete clean rebuild of the CDK project, including cleaning all build artifacts and reinstalling dependencies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_57\n\nLANGUAGE: shell\nCODE:\n```\n$ git clean -fqdx .\n$ yarn install\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Running awslint from Command Line in a Module Directory\nDESCRIPTION: Example showing how to run the awslint tool in an AWS CDK module directory and the diagnostic output it produces. The example uses the @aws-cdk/aws-sns module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/awslint/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cd @aws-cdk/aws-sns\n$ npm run awslint\nwarning: [awslint:resource-interface:@aws-cdk/aws-sns.Subscription] every resource must have a resource interface \nwarning: [awslint:resource-interface:@aws-cdk/aws-sns.TopicPolicy] every resource must have a resource interface \n```\n\n----------------------------------------\n\nTITLE: Importing ResourceExplorer2 Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS ResourceExplorer2 module in a CDK application using TypeScript.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-resourceexplorer2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as resourceexplorer2 from 'aws-cdk-lib/aws-resourceexplorer2';\n```\n\n----------------------------------------\n\nTITLE: Specifying a Set Identifier for Route53 Records using AWS CDK\nDESCRIPTION: Shows how to specify a unique identifier for a Route53 record set using the setIdentifier parameter. This is used to differentiate among multiple resource record sets with the same name and type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const myZone: route53.HostedZone;\n\nnew route53.ARecord(this, 'ARecordWeighted1', {\n  zone: myZone,\n  target: route53.RecordTarget.fromIpAddresses('1.2.3.4'),\n  weight: 10,\n  setIdentifier: 'weighted-record-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating EC2 and Fargate Services with Tag Properties in TypeScript\nDESCRIPTION: Demonstrates how to create EC2 and Fargate services using the new tag propagation and ECS managed tags properties. These examples show how to set custom values for these properties when creating services.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Create Service\nconst service = new ecs.Ec2Service(stack, \"Service\", {\n  cluster,\n  taskDefinition,\n  propagateTaskTagsFrom: ecs.PropagatedTagSource.TASK_DEFINITION,\n  enableECSManagedTags: true,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst service = new ecs.FargateService(stack, \"Service\", {\n  cluster,\n  taskDefinition,\n  propagateTaskTagsFrom: ecs.PropagatedTagSource.TASK_DEFINITION,\n  enableECSManagedTags: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing VPC in CDK Stack - TypeScript\nDESCRIPTION: This TypeScript snippet imports the default VPC into an existing CDK stack using the AWS EC2 module. It is intended to reuse an existing network resource, which can accelerate development and testing workflows. Requires aws-cdk-lib.aws_ec2 and an existing default VPC in the target AWS environment. The snippet returns a Vpc construct for use in subsequent resource definitions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = ec2.Vpc.fromLookup(stack, 'Vpc', { isDefault: true });\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Shield Module in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to import the AWS Shield construct library module in a TypeScript AWS CDK project. This import makes the Shield L1 constructs available for defining AWS Shield resources within the CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-shield/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as shield from 'aws-cdk-lib/aws-shield';\n```\n\n----------------------------------------\n\nTITLE: Configuring AppStagingSynthesizer with Custom Bootstrap Region\nDESCRIPTION: Configuration of AppStagingSynthesizer with custom bootstrap region specification and default resources. Includes deployment identities configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n\n    // The following line is optional. By default it is assumed you have bootstrapped in the same\n    // region(s) as the stack(s) you are deploying.\n    deploymentIdentities: DeploymentIdentities.defaultBootstrapRoles({ bootstrapRegion: 'us-east-1' }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: AWS Lambda Function Deprecations\nDESCRIPTION: Documents deprecated features in AWS Lambda package including code handling, versioning, security groups, and runtime configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Use these instead of deprecated methods\nCode.fromAsset()           // instead of Code.asset()\nCode.fromBucket()          // instead of Code.bucket()\nCode.fromCfnParameters()   // instead of Code.cfnParameters()\nCode.fromInline()          // instead of Code.inline()\nthis.currentVersion        // instead of addVersion()\nsecurityGroups             // instead of securityGroup\narchitecture               // instead of architectures\nbundlingImage              // instead of bundlingDockerImage\n```\n\n----------------------------------------\n\nTITLE: Deprecated Protocol Enum in AWS CDK AppMesh\nDESCRIPTION: The Protocol enum in AWS AppMesh is deprecated and not intended for use outside the package. It includes HTTP, TCP, HTTP2, and GRPC protocols.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated - not for use outside package\nenum Protocol {\n  HTTP,\n  TCP,\n  HTTP2,\n  GRPC\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Size Units and Rounding (TypeScript)\nDESCRIPTION: Illustrates converting between digital storage units with the Size class and applying rounding options. Requires AWS CDK classes: Size and SizeRoundingBehavior. Accepts a Size instance and an optional conversion rounding parameter. Outputs a numeric value representing the size in the new unit. By default, conversions that are not integral will fail unless a rounding option is specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nSize.mebibytes(2).toKibibytes()                                             // yields 2048\nSize.kibibytes(2050).toMebibytes({ rounding: SizeRoundingBehavior.FLOOR })  // yields 2\n```\n\n----------------------------------------\n\nTITLE: Removing Windows Server EKS-Optimized AMI Versions from AWS CDK\nDESCRIPTION: This code snippet lists the enum values being removed from the aws-cdk-lib.aws_ec2.WindowsVersion class. These values represent specific Windows Server 2019 and 2022 EKS-optimized AMI versions that were mistakenly added to the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n# These enum values were mistakenly added.\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_CORE_EKS_OPTIMIZED_1_24_2023_11_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_CORE_EKS_OPTIMIZED_1_24_2023_12_12\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_CORE_EKS_OPTIMIZED_1_24_2024_01_09\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_CORE_EKS_OPTIMIZED_1_24_2024_02_13\n// ... [additional removed versions]\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_ENGLISH_FULL_EKS_OPTIMIZED_1_29_2023_12_19\n```\n\n----------------------------------------\n\nTITLE: Watching File Changes with Yarn - Shell Commands\nDESCRIPTION: These commands set up file watchers for CDK modules using Yarn. They use the yarn watch script and place processes in the background for parallel monitoring. This setup accelerates the code-compile-test cycle and is useful for active development on multiple modules; requires Yarn to be installed and scripts to be defined.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_16\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/aws-cdk-lib\n$ yarn watch & # runs in the background\n$ cd packages/aws-cdk\n$ yarn watch & # runs in the background\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests for AWS CDK Modules\nDESCRIPTION: Example command to run unit tests for specific AWS CDK modules, such as aws-lambda. This is useful when making changes to individual modules.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ cd aws-cdk/packages/aws-cdk-lib\n$ yarn test aws-lambda\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK Locally in a Project\nDESCRIPTION: Command to install the AWS CDK as a development dependency in a specific project rather than globally.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/pkglint/lib/banners/l1.deprecated.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev aws-cdk\n```\n\n----------------------------------------\n\nTITLE: Importing Existing VPC Link\nDESCRIPTION: Demonstrates how to import an existing VPC Link resource into a CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\n\ndeclare const vpc: ec2.Vpc;\nconst awesomeLink = apigwv2.VpcLink.fromVpcLinkAttributes(this, 'awesome-vpc-link', {\n  vpcLinkId: 'us-east-1_oiuR12Abd',\n  vpc,\n});\n```\n\n----------------------------------------\n\nTITLE: Delay with Value Resolution\nDESCRIPTION: Shows how to use delay with a value that will be resolved after the specified timeout.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\n(async() => {\n\tconst result = await delay(100, {value: ''});\n\n\t// Executed after 100 milliseconds\n\tconsole.log(result);\n\t//=> ''\n})();\n```\n\n----------------------------------------\n\nTITLE: Run awslint for a Module - yarn awslint - Bash\nDESCRIPTION: Executes 'yarn awslint' within a module, running all Design GUIDELINES checks enforced by awslint. Assumes awslint is configured and package scripts are set up. Useful for AWS Construct Library API compliance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nyarn awslint\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from S3 with Validators using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates creating an AWS AppConfig `SourcedConfiguration` from an S3 bucket file and attaching validators. It includes both a JSON schema validator (`appconfig.JsonSchemaValidator.fromFile`) and a Lambda validator (`appconfig.LambdaValidator.fromFunction`). Dependencies include `appconfig.Application`, `s3.Bucket`, and `lambda.Function` instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const bucket: s3.Bucket;\ndeclare const fn: lambda.Function;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromBucket(bucket, 'path/to/file.json'),\n  validators: [\n    appconfig.JsonSchemaValidator.fromFile('schema.json'),\n    appconfig.LambdaValidator.fromFunction(fn),\n  ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Importing PCAConnectorAD Module in TypeScript\nDESCRIPTION: Basic import statement for using the AWS PCAConnectorAD module in a CDK application. This gives access to the L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pcaconnectorad/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pcaconnectorad from 'aws-cdk-lib/aws-pcaconnectorad';\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK CLI via NPM\nDESCRIPTION: Installs the AWS CDK Command Line Interface globally using npm from a local tarball\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install -g /path/to/zip/js/aws-cdk-1.2.3.tgz\n```\n\n----------------------------------------\n\nTITLE: Executing Serial Jobs with AsyncKit on Array Input\nDESCRIPTION: Illustrates the use of AsyncKit's serial method to process an array of items sequentially. It shows the extended interface with item, key, and callback parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/asynckit/README.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar serial = require('asynckit/serial')\n  , assert = require('assert')\n  ;\n\nvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ]\n  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ]\n  , expectedTarget = [ 0, 1, 2, 3, 4, 5, 6, 7 ]\n  , target         = []\n  ;\n\nserial(source, asyncJob, function(err, result)\n{\n  assert.deepEqual(result, expectedResult);\n  assert.deepEqual(target, expectedTarget);\n});\n\n// extended interface (item, key, callback)\n// also supported for arrays\nfunction asyncJob(item, key, cb)\n{\n  target.push(key);\n\n  // it will be automatically made async\n  // even it iterator \"returns\" in the same event loop\n  cb(null, item * 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Managed Blockchain Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Managed Blockchain module in a TypeScript CDK application. It allows access to the constructs and APIs provided by the managedblockchain module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-managedblockchain/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as managedblockchain from 'aws-cdk-lib/aws-managedblockchain';\n```\n\n----------------------------------------\n\nTITLE: Installing Delay Module with NPM\nDESCRIPTION: Command to install the delay module via npm package manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install delay\n```\n\n----------------------------------------\n\nTITLE: Importing AWS VpcLattice Constructs in AWS CDK TypeScript\nDESCRIPTION: This TypeScript snippet shows how to import the aws-vpclattice construct library from the AWS CDK, enabling the use of CloudFormation-backed L1 resources within CDK applications. It assumes that the aws-cdk-lib module is already installed as a dependency in your project. The import provides access to all available VpcLattice constructs and resources. No parameters are required, and the output is a namespace variable (vpclattice) containing the relevant classes and functions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-vpclattice/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as vpclattice from 'aws-cdk-lib/aws-vpclattice';\n```\n\n----------------------------------------\n\nTITLE: Referencing Local Model Data for SageMaker with TypeScript\nDESCRIPTION: This snippet demonstrates how to reference local model data for use in a SageMaker model using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\nimport * as path from 'path';\n\nconst modelData = sagemaker.ModelData.fromAsset(path.join('path', 'to', 'artifact', 'file.tar.gz'));\n```\n\n----------------------------------------\n\nTITLE: Creating CloudWatch Alarms for DynamoDB Metrics in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a CloudWatch Alarm for a DynamoDB table metric, specifically for throttled requests on PUT operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/TABLE_V1_API.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';\n\nconst table = new dynamodb.Table(this, 'Table', {\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n});\n\nconst metric = table.metricThrottledRequestsForOperations({\n  operations: [dynamodb.Operation.PUT_ITEM],\n  period: Duration.minutes(1),\n});\n\nnew cloudwatch.Alarm(this, 'Alarm', {\n  metric: metric,\n  evaluationPeriods: 1,\n  threshold: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Sample Input Event for EventBridge Pipe in JSON\nDESCRIPTION: Shows an example of the input event structure processed by the EventBridge Pipe.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    ...\n    \"body\": \"{\\\"payload\\\": \\\"Test message.\\\"}\",\n    ...\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Adding VPC Peering Routes via AWS CLI (Bash)\nDESCRIPTION: Provides AWS CLI commands (`aws ec2 create-route`) for manually adding routes to enable traffic flow over a VPC peering connection. The first command adds a route in the requestor's route table pointing to the acceptor's CIDR via the peering connection ID. The second command (commented) shows adding the corresponding route in the acceptor's route table for bi-directional communication. Requires AWS CLI, route table IDs (`rtb-requestor`, `rtb-acceptor`), destination CIDR blocks, and the VPC peering connection ID (`pcx-xxxxxxxx`).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-ec2-alpha/README.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n# Add a route to the requestor VPC route table\naws ec2 create-route --route-table-id rtb-requestor --destination-cidr-block 10.0.0.0/16 --vpc-peering-connection-id pcx-xxxxxxxx\n\n# For bi-directional add a route in the acceptor vpc account as well\naws ec2 create-route --route-table-id rtb-acceptor --destination-cidr-block 10.1.0.0/16 --vpc-peering-connection-id pcx-xxxxxxxx\n```\n```\n\n----------------------------------------\n\nTITLE: Removing and Clearing Axios Interceptors - JavaScript\nDESCRIPTION: Shows how to remove a specific interceptor using the `eject` method, and how to clear all request or response interceptors using the `clear` method. Helpful when interceptors need to be dynamically modified during application lifecycle. Prerequisite: `axios` package and at least one interceptor already added to the instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst instance = axios.create();\nconst myInterceptor = instance.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\ninstance.interceptors.request.clear(); // Removes interceptors from requests\ninstance.interceptors.response.use(function () {/*...*/});\ninstance.interceptors.response.clear(); // Removes interceptors from responses\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK Globally using npm\nDESCRIPTION: Command to install the AWS CDK toolkit globally using npm. This allows running the CDK CLI from any directory in the terminal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/pkglint/lib/banners/l1.deprecated.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g aws-cdk\n```\n\n----------------------------------------\n\nTITLE: Configuring AssumeRole Policy for API Gateway CloudWatch Role\nDESCRIPTION: Defines the trust relationship for an API Gateway service role that allows it to push logs to CloudWatch. The policy permits the API Gateway service to assume this role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-iam/test/integ.customize-roles-restapi.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sts:AssumeRole\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Service\": \"apigateway.amazonaws.com\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Importing ConnectCampaignsV2 Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the ConnectCampaignsV2 module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-connectcampaignsv2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as connectcampaigns from 'aws-cdk-lib/aws-connectcampaignsv2';\n```\n\n----------------------------------------\n\nTITLE: Defining Inline YAML BuildSpec for CodeBuild Project in TypeScript\nDESCRIPTION: Demonstrates how to define an inline buildspec for a CodeBuild project using an object, but rendering it as YAML instead of JSON in the project configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codebuild/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst project = new codebuild.Project(this, 'MyProject', {\n  buildSpec: codebuild.BuildSpec.fromObjectToYaml({\n    version: '0.2',\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Run All awslint Modules and Aggregate Output - Console Command - Bash\nDESCRIPTION: Runs awslint via lerna in all modules, disables bail (stops on error), streams warnings/errors, and redirects output to 'awslint.txt'. Useful for capturing all linting issues at once. Requires lerna and awslint installed and configured.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\nlerna run awslint --no-bail --stream 2> awslint.txt\n```\n\n----------------------------------------\n\nTITLE: Resetting foreach.sh Session - Console Command - Bash\nDESCRIPTION: This snippet runs the 'foreach.sh --reset' command to reset the execution session, clearing any previous state or progress markers. Used when all tasks finish or when starting a new session. Requires 'scripts/foreach.sh' in the repo and proper permissions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\n$ scripts/foreach.sh --reset\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Requests Package Dependency for AWS CDK\nDESCRIPTION: Defines the requests HTTP library as a dependency with version 2.31.0. This pinned version ensures consistency across development environments and prevents compatibility issues that might arise from using different package versions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda/test/integ.lambda-sourceKMSKeyArn.js.snapshot/asset.cab53c59addd4362c71a39b96e04505d5f53fa854b2ff7cbc6cd5925f5afca9d/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Importing AWS ResilienceHub Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS ResilienceHub module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-resiliencehub/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as resiliencehub from 'aws-cdk-lib/aws-resiliencehub';\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-AZ Redshift Cluster using AWS CDK (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a Multi-AZ AWS Redshift cluster using AWS CDK for enhanced availability. It requires setting `multiAz` to `true`, using an RA3 node type (`nodeType`), specifying `MULTI_NODE` for `clusterType`, having at least two nodes (`numberOfNodes`), and deploying into a VPC (`vpc`) that spans at least three Availability Zones.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as ec2 from 'aws-cdk-lib/aws-ec2';\nimport * as redshift from 'aws-cdk-lib/aws-redshift-alpha';\nimport * as cdk from 'aws-cdk-lib';\ndeclare const vpc: ec2.IVpc; // Use IVpc as per snippet\ndeclare const stack: cdk.Stack; // Using 'stack' as per snippet context\n\nnew redshift.Cluster(stack, 'Cluster', {\n  masterUser: {\n    masterUsername: 'admin',\n  },\n  vpc, // 3 AZs are required for Multi-AZ\n  nodeType: redshift.NodeType.RA3_XLPLUS, // must be RA3 node type\n  clusterType: redshift.ClusterType.MULTI_NODE, // must be MULTI_NODE\n  numberOfNodes: 2, // must be 2 or more\n  multiAz: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Basic Axios Errors in JavaScript\nDESCRIPTION: Demonstrates the basic structure for catching and handling errors in Axios GET requests using the `.catch()` method. It shows how to differentiate between errors where the server responded with a non-2xx status (`error.response`), errors where the request was made but no response was received (`error.request`), and errors that occurred during request setup (`error.message`). The error configuration object (`error.config`) is also logged.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\naxios.get('/user/12345')\n  .catch(function (error) {\n    if (error.response) {\n      // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n      console.log(error.response.data);\n      console.log(error.response.status);\n      console.log(error.response.headers);\n    } else if (error.request) {\n      // The request was made but no response was received\n      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\n      // http.ClientRequest in node.js\n      console.log(error.request);\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.log('Error', error.message);\n    }\n    console.log(error.config);\n  });\n```\n\n----------------------------------------\n\nTITLE: Setting up SSH port forwarding for EKS application access\nDESCRIPTION: Command to create an SSH tunnel to access the deployed application when corporate networks block the required port. This forwards local port 3000 to the ELB address port 3000.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/test/MANUAL_TEST.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nssh -L 3000:<ELB ADDRESS>:3000 ssh-box-somewhere.example.com\n\n# Visit http://localhost:3000/\n```\n\n----------------------------------------\n\nTITLE: Configuring Link Verification for User Pool in TypeScript\nDESCRIPTION: This snippet shows how to set up link-based verification for a Cognito User Pool, including customizing the verification email content.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew cognito.UserPool(this, 'myuserpool', {\n  userVerification: {\n    emailStyle: cognito.VerificationEmailStyle.LINK,\n    emailSubject: 'Invite to join our awesome app!',\n    emailBody: 'You have been invited to join our awesome app! {##Verify Your Email##}',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Omics module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Omics module in a TypeScript project using the AWS CDK library.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-omics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as omics from 'aws-cdk-lib/aws-omics';\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon Pinpoint Email Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the Amazon Pinpoint Email module in a TypeScript project using AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-pinpointemail/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as pinpointemail from 'aws-cdk-lib/aws-pinpointemail';\n```\n\n----------------------------------------\n\nTITLE: Weakening MetadataEntry Type for Runtime Compatibility - Cloud Assembly Schema - AWS CDK - TypeScript\nDESCRIPTION: This code documents a schema change allowing boolean and number metadata values instead of only strings, due to previous runtime failures in the jsii type system. Code that consumes these values should now accommodate booleans and numbers at runtime; static languages already treat them as generic objects. No dependency changes, but the client must validate value-type at runtime. This affects both aws-cdk-lib.cloud_assembly_schema.MetadataEntry and aws-cdk-lib.cx_api.MetadataEntryResult.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n# In aws/aws-cdk#31041, the CDK started emitting booleans and numbers as metadata values.\n# Since these types weren't officially declared in the schema, jsii runtime type checking failed to load them.\n# The type has now weakened, and when it's used as an output any consuming code will need to account for the possibility of the value being a boolean or number.\n# In static languages, the type would already have been treated as a generic Object with required runtime checks.\n# See: https://github.com/cdklabs/cloud-assembly-schema/pull/121\nweakened:aws-cdk-lib.cloud_assembly_schema.MetadataEntry\nweakened:aws-cdk-lib.cx_api.MetadataEntryResult\n```\n\n----------------------------------------\n\nTITLE: AWS SecretsManager Deprecations\nDESCRIPTION: Lists deprecated features in AWS SecretsManager package and their recommended replacements. Includes changes to Secret handling, attachment methods, and rotation configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Use these instead of deprecated methods\nsecret.attach()               // instead of addTargetAttachment()\nfromSecretCompleteArn()       // instead of fromSecretArn()\nfromSecretPartialArn()        // instead of fromSecretArn()\nfromSecretNameV2()            // instead of fromSecretName()\napplicationArnForPartition    // instead of applicationId\nsemanticVersionForPartition   // instead of semanticVersion\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Echo Server with Delayed Response\nDESCRIPTION: Example showing how to create an HTTP server that delays its response by 1000ms using delayed-stream. The server buffers incoming request data and pipes it to the response after the delay.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/delayed-stream/Readme.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar DelayedStream = require('delayed-stream');\nvar http = require('http');\n\nhttp.createServer(function(req, res) {\n  var delayed = DelayedStream.create(req);\n\n  setTimeout(function() {\n    res.writeHead(200);\n    delayed.pipe(res);\n  }, 1000);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining VPC Configuration Props in AWS CDK TypeScript\nDESCRIPTION: Illustrates standard properties for configuring VPC placement within a construct's props interface. It includes a required `vpc` property (type `ec2.IVpc`) and an optional `vpcSubnetSelection` property (type `ec2.SubnetSelection`) to specify which subnets within the VPC should be used, often defaulting to private subnets.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/**\n * The VPC in which to run your CodeBuild project.\n */\nvpc: ec2.IVpc; // usually this is required\n\n/**\n * Which VPC subnets to use for your CodeBuild project.\n *\n * @default - uses all private subnets in your VPC\n */\nvpcSubnetSelection?: ec2.SubnetSelection;\n```\n```\n\n----------------------------------------\n\nTITLE: Deprecated TargetGroupAttributes and TargetGroupImportProps in AWS CDK\nDESCRIPTION: The defaultPort property in TargetGroupAttributes is deprecated and unused. TargetGroupImportProps is also deprecated; use TargetGroupAttributes instead.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated\nconst attrs: TargetGroupAttributes = {\n  defaultPort: 80 // This property is unused and deprecated\n};\n\n// Deprecated\nconst importProps: TargetGroupImportProps = {\n  // ...\n};\n\n// Use TargetGroupAttributes instead of TargetGroupImportProps\n```\n\n----------------------------------------\n\nTITLE: ITreeAttributes Interface Definition\nDESCRIPTION: TypeScript interface definition for constructs to provide metadata information for the construct tree, including attributes for dependencies, properties, links, and documentation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/construct-tree.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/***\n * Information that a construct will contribute towards the construct tree*\n * such as dependencies, properties, links, documentation, etc\n */\nexport interface ITreeAttributes {\n  // attributes will be added to the construct tree\n  readonly attributes: [key: string]: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging AWS CDK Module for Multiple Languages\nDESCRIPTION: Commands to package a specific AWS CDK module (aws-cdk-lib) for multiple target languages using jsii and Docker. This process generates artifacts for various programming languages supported by CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ cd <root-of-cdk-repo>\n$ docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain:1-buster-slim\ndocker$ cd packages/aws-cdk-lib\ndocker$ ../../scripts/foreach.sh --up yarn run package\ndocker$ exit\n```\n\n----------------------------------------\n\nTITLE: Specifying Identity Policy Statements for S3 Access\nDESCRIPTION: This JSON snippet defines the identity policy statements for the Lambda function's IAM role. It grants specific S3 permissions (Get, List) on a particular S3 bucket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda/test/integ.lambda-customize-roles.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": [\n      \"s3:GetObject*\",\n      \"s3:GetBucket*\",\n      \"s3:List*\"\n    ],\n    \"Effect\": \"Allow\",\n    \"Resource\": [\n      \"(integ-lambda-customize-roles/Bucket/Resource.Arn)\",\n      \"(integ-lambda-customize-roles/Bucket/Resource.Arn)/*\"\n    ]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Running Rosetta Example Extraction - Console Command - Bash\nDESCRIPTION: This snippet demonstrates how to execute the 'rosetta:extract' command in strict mode using yarn after moving into the aws-cdk-lib package directory. It requires Node.js, yarn, and that the aws-cdk-lib module is present. The command auto-extracts example code for transformation and inclusion in documentation. Nothing is compiled or transformed unless the module and package dependencies are installed. Output is for documentation-generation purposes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\n$ cd packages/aws-cdk-lib\\n$ yarn rosetta:extract --strict\n```\n\n----------------------------------------\n\nTITLE: Transforming Input for Lambda Function Target in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a Lambda function target and input transformation. This allows customizing the payload sent to the Lambda function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetFunction: lambda.IFunction;\n\nconst pipeTarget = new targets.LambdaFunction(targetFunction, {\n  inputTransformation: pipes.InputTransformation.fromObject({ body: \"\" }),\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Form Submission\nDESCRIPTION: Example of submitting form data to a web application\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nform.submit('http://example.org/', function(err, res) {\n  // res  response object (http.IncomingMessage)  //\n  res.resume();\n});\n```\n\n----------------------------------------\n\nTITLE: AWS CDK: Qualified Type Usage Example - Typescript\nDESCRIPTION: This Typescript code illustrates the recommended pattern for referencing types from other modules by prefixing them with the module namespace (here, 's3'). It shows the instantiation of a Bucket object from the aws-cdk-lib/aws-s3 package. Assumes the 's3' namespace is imported and in scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n// An example in the aws-cdk-lib library, using something from aws-cdk-lib/aws-s3\\nconst bucket = new s3.Bucket(this, 'Bucket');\\n// ...rest of the example...\n```\n\n----------------------------------------\n\nTITLE: Amazon Regional Domain Configuration\nDESCRIPTION: List of Amazon regional marketplace domains including US (.com), UK (.co.uk), France (.fr), and Germany (.de).\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-route53resolver-alpha/test/integ.firewall.js.snapshot/asset.e820b3f07bf66854be0dfd6f3ec357a10d644f2011069e5ad07d42f4f89ed35a.txt#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\namazon.com\namazon.co.uk\namazon.fr\namazon.de\n```\n\n----------------------------------------\n\nTITLE: Configuring Axios with the Fetch Adapter - JavaScript\nDESCRIPTION: Demonstrates how to configure Axios to use the fetch adapter by default for HTTP requests. Shows both inline adapter use and creating a separate Axios instance with fetch set as the adapter. Depends on Axios >= v1.7.0 and runtime environments supporting fetch. Inputs include a URL and adapter configurations; outputs are resolved Axios responses using fetch semantics.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_45\n\nLANGUAGE: javascript\nCODE:\n```\nconst {data} = axios.get(url, {\n  adapter: 'fetch' // by default ['xhr', 'http', 'fetch']\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst fetchAxios = axios.create({\n  adapter: 'fetch'\n});\n\nconst {data} = fetchAxios.get(url);\n```\n\n----------------------------------------\n\nTITLE: AxiosHeaders Constructor with Raw HTTP Headers (JavaScript)\nDESCRIPTION: Shows how to create an AxiosHeaders instance from a string of raw HTTP headers. This is useful for parsing and manipulating headers received from external sources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_41\n\nLANGUAGE: javascript\nCODE:\n```\nconst headers = new AxiosHeaders(`\nHost: www.bing.com\nUser-Agent: curl/7.54.0\nAccept: */*`);\n\nconsole.log(headers);\n\n// Object [AxiosHeaders] {\n//   host: 'www.bing.com',\n//   'user-agent': 'curl/7.54.0',\n//   accept: '*/*'\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Low-Level API to Get Regional Facts in TypeScript\nDESCRIPTION: Shows how to use the low-level API with FactName class to retrieve specific regional information from the database.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/region-info/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst staticWebsite = regionInfo.Fact.find(\n  'ap-northeast-1',\n  regionInfo.FactName.S3_STATIC_WEBSITE_ENDPOINT\n);\n// => s3-website-ap-northeast-1.amazonaws.com\n```\n\n----------------------------------------\n\nTITLE: Defining Repository Credentials Interface and Class in TypeScript\nDESCRIPTION: This snippet defines an IRepositoryCreds interface and a RepositoryCreds class for handling repository credentials. It includes methods for creating credentials from a Secrets Manager secret and binding them to a container definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-priv-registry-support.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IRepositoryCreds {\n    readonly secret: secretsManager.Secret;\n}\n\nexport class RepositoryCreds {\n  public readonly secret: secretsManager.Secret;\n\n  public static fromSecret(secret: secretsManager.Secret) {\n    this.secret = secret;\n  }\n\n  public bind(containerDefinition: ContainerDefinition): void {\n    // grant the execution role read access so the secret can be read prior to image pull\n    this.secret.grantRead(containerDefinition.taskDefinition.obtainExecutionRole());\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Progress Capturing with Axios (JavaScript)\nDESCRIPTION: Demonstrates how to capture upload and download progress with Axios in both browser and Node.js environments. This is useful for implementing progress bars or tracking long-running operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_36\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.post(url, data, {\n  onUploadProgress: function (axiosProgressEvent) {\n    /*{\n      loaded: number;\n      total?: number;\n      progress?: number; // in range [0..1]\n      bytes: number; // how many bytes have been transferred since the last trigger (delta)\n      estimated?: number; // estimated time in seconds\n      rate?: number; // upload speed in bytes\n      upload: true; // upload sign\n    }*/\n  },\n\n  onDownloadProgress: function (axiosProgressEvent) {\n    /*{\n      loaded: number;\n      total?: number;\n      progress?: number;\n      bytes: number; \n      estimated?: number;\n      rate?: number; // download speed in bytes\n      download: true; // download sign\n    }*/\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Referencing a Local Dockerfile for SageMaker Container Image with TypeScript\nDESCRIPTION: This snippet shows how to reference a local directory containing a Dockerfile for use as a SageMaker container image using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-sagemaker-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as sagemaker from '@aws-cdk/aws-sagemaker-alpha';\nimport * as path from 'path';\n\nconst image = sagemaker.ContainerImage.fromAsset(path.join('path', 'to', 'Dockerfile', 'directory'));\n```\n\n----------------------------------------\n\nTITLE: Updating CloudWatch Metric Configuration\nDESCRIPTION: Replace deprecated toAlarmConfig() and toGraphConfig() methods with toMetricConfig(). Use metric.with() to encode period and statistic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nmetric.toAlarmConfig()\nmetric.toGraphConfig()\n\n// New\nmetric.toMetricConfig()\n\n// Encoding period and statistic\nmetric.with({ period: Duration.minutes(5), statistic: 'Average' })\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Minor Version Upgrades for Neptune Instance\nDESCRIPTION: Demonstrates how to enable automatic minor version upgrades for a specific Neptune instance within a cluster, allowing per-instance upgrade settings.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew neptune.DatabaseInstance(this, 'Instance', {\n  cluster,\n  instanceType: neptune.InstanceType.R5_LARGE,\n  autoMinorVersionUpgrade: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Manipulating CloudFormation Outputs in CDK\nDESCRIPTION: Demonstrates how to access and modify CloudFormation outputs through CfnInclude. This allows changing output values or references.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnTemplate: cfn_inc.CfnInclude;\nconst output: core.CfnOutput = cfnTemplate.getOutput('MyOutput');\n\n// mutating the output\ndeclare const cfnBucket: s3.CfnBucket;\noutput.value = cfnBucket.attrArn;\n```\n\n----------------------------------------\n\nTITLE: DynamoDB Table Access Identity Policy for First Custom Role\nDESCRIPTION: Identity policy statements that grant read-only permissions to a DynamoDB table and its indexes. This policy enables operations like querying, scanning, and describing the table.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-dynamodb/test/integ.table-with-customized-role.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": [\n      \"dynamodb:BatchGetItem\",\n      \"dynamodb:GetRecords\",\n      \"dynamodb:GetShardIterator\",\n      \"dynamodb:Query\",\n      \"dynamodb:GetItem\",\n      \"dynamodb:Scan\",\n      \"dynamodb:ConditionCheckItem\",\n      \"dynamodb:DescribeTable\"\n    ],\n    \"Effect\": \"Allow\",\n    \"Resource\": [\n      \"(cdk-table-with-customized-role/Table/Resource.Arn)\",\n      \"(cdk-table-with-customized-role/Table/Resource.Arn)/index/*\"\n    ]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Defining AWS CDK Script Tests Location in Markdown\nDESCRIPTION: A simple markdown statement explaining that the directory contains tests for scripts located under the './scripts' path. This helps developers understand the purpose and organization of the test files.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/scripts/@aws-cdk/script-tests/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# script tests\n\nThis directory includes tests for scripts under `./scripts`.\n```\n\n----------------------------------------\n\nTITLE: Importing AWS MediaPackage CDK Module\nDESCRIPTION: Example showing how to import the AWS MediaPackage module in a CDK application. This allows access to MediaPackage L1 constructs for infrastructure definition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-mediapackage/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mediapackage from 'aws-cdk-lib/aws-mediapackage';\n```\n\n----------------------------------------\n\nTITLE: Deploying Flink Application in a VPC using TypeScript\nDESCRIPTION: Demonstrates how to deploy a Flink application within a specified VPC using the vpc option in the Application construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-kinesisanalytics-flink-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const bucket: s3.Bucket;\ndeclare const vpc: ec2.Vpc;\nconst flinkApp = new flink.Application(this, 'Application', {\n  code: flink.ApplicationCode.fromBucket(bucket, 'my-app.jar'),\n  runtime: flink.Runtime.FLINK_1_20,\n  vpc,\n});\n```\n\n----------------------------------------\n\nTITLE: Upgrading AWS CDK Globally\nDESCRIPTION: Command to upgrade an existing global installation of the AWS CDK toolkit to the latest version using npm.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/pkglint/lib/banners/l1.deprecated.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm update -g aws-cdk\n```\n\n----------------------------------------\n\nTITLE: Running pkglint Per-Package - Console Command - Bash\nDESCRIPTION: Runs 'lr pkglint' to lint an individual package. Assumes an 'lr' alias or wrapper is present for package-level commands. Used for fixing or diagnosing single package.json issues.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\n$ lr pkglint\n```\n\n----------------------------------------\n\nTITLE: DynamoDB Table Access Identity Policy for Second Custom Role\nDESCRIPTION: Identity policy statements for the second custom role with the same read-only permissions as the first role, but with different resource targets. This policy includes a NOVALUE placeholder for one of the resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-dynamodb/test/integ.table-with-customized-role.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": [\n      \"dynamodb:BatchGetItem\",\n      \"dynamodb:GetRecords\",\n      \"dynamodb:GetShardIterator\",\n      \"dynamodb:Query\",\n      \"dynamodb:GetItem\",\n      \"dynamodb:Scan\",\n      \"dynamodb:ConditionCheckItem\",\n      \"dynamodb:DescribeTable\"\n    ],\n    \"Effect\": \"Allow\",\n    \"Resource\": [\n      \"(cdk-table-with-customized-role2/Table/Resource.Arn)\",\n      \"(NOVALUE)\"\n    ]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Retrieving CMK ARN for EKS Cluster Encryption - AWS CDK - TypeScript\nDESCRIPTION: Retrieves the Amazon Resource Name (ARN) for the KMS key (CMK) used to encrypt an EKS cluster's secrets. Requires an eks.Cluster construct with secrets encryption enabled. The output is the ARN string.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const cluster: eks.Cluster;\nconst clusterEncryptionConfigKeyArn = cluster.clusterEncryptionConfigKeyArn;\n```\n\n----------------------------------------\n\nTITLE: EKS Cluster Cleanup Command\nDESCRIPTION: Command to clean up all Kubernetes services before cluster termination to ensure proper cleanup of AWS resources including load balancers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-eks/test/MANUAL_TEST.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl delete --all services\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect Documentation of Default Values in AWS CDK Props\nDESCRIPTION: Examples of incorrect ways to document default values, showing the issues with using 'undefined' or unclear descriptions that don't properly explain the behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * External KMS key to use for bucket encryption.\n *\n * @default undefined\n *             DO NOT - that the value is 'undefined' by default is implied. However,\n *                        what will the *behavior* be if the value is left out?\n */\nencryptionKey?: kms.IEncryptionKey;\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoTTwinMaker Constructs with AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the AWS IoTTwinMaker construct module from the aws-cdk-lib to enable the use of L1 resources within AWS CDK applications. The import is required as a prerequisite before defining AWS::IoTTwinMaker resources in TypeScript CDK code, allowing direct access to CloudFormation resource constructs. No additional dependencies are required other than the aws-cdk-lib, and the pattern follows standard module import practices in TypeScript projects.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iottwinmaker/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as iottwinmaker from 'aws-cdk-lib/aws-iottwinmaker';\n```\n\n----------------------------------------\n\nTITLE: Creating EKS Cluster with Custom Kubectl Handler - AWS CDK - TypeScript\nDESCRIPTION: Initializes an Amazon EKS cluster with a custom kubectl Lambda handler using the AWS CDK. Requires the @aws-cdk/lambda-layer-kubectl-v32 package and proper Lambda layer version compatibility. The 'kubectlLayer' is mandatory in 'kubectlProviderOptions', and the handler Lambda is granted cluster admin rights. Outputs an eks.Cluster construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { KubectlV32Layer } from '@aws-cdk/lambda-layer-kubectl-v32';\n\nnew eks.Cluster(this, 'hello-eks', {\n  version: eks.KubernetesVersion.V1_32,\n  kubectlProviderOptions: {\n    kubectlLayer: new KubectlV32Layer(this, 'kubectl'),\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Removing Obsolete EC2 Windows Versions from WindowsVersion Enum - AWS CDK - TypeScript\nDESCRIPTION: This log documents the removal of two Turkish Windows Server 2022 images from the aws_cdk_lib.aws_ec2.WindowsVersion enum. Code referencing these constants (WINDOWS_SERVER_2022_TURKISH_FULL_BASE_2024_01_16, WINDOWS_SERVER_2022_TURKISH_FULL_BASE_2024_02_14) will require migration to supported versions. No additional dependencies required, but usage of these removed values must be updated.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_TURKISH_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_TURKISH_FULL_BASE_2024_02_14\n```\n\n----------------------------------------\n\nTITLE: Updating LinuxBuildImage in AWS CodeBuild\nDESCRIPTION: Replace deprecated Ubuntu 14.04 build images with STANDARD_2_0 and specify runtime in buildspec runtime-versions section.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nLinuxBuildImage.UBUNTU_14_04_OPEN_JDK_9\n\n// New\nLinuxBuildImage.STANDARD_2_0\n// Specify runtime in buildspec runtime-versions section\n```\n\n----------------------------------------\n\nTITLE: Basic Stream Combination Example\nDESCRIPTION: Demonstrates how to combine two file streams into one using combined-stream with default settings\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/combined-stream/Readme.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar CombinedStream = require('combined-stream');\nvar fs = require('fs');\n\nvar combinedStream = CombinedStream.create();\ncombinedStream.append(fs.createReadStream('file1.txt'));\ncombinedStream.append(fs.createReadStream('file2.txt'));\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'));\n```\n\n----------------------------------------\n\nTITLE: Defining Identity Policy Statements for S3 and IAM Resources\nDESCRIPTION: IAM policy statements granting SQS send message permissions to specific S3 and IAM resources, including dynamic values and ARN patterns\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-iam/test/integ.customize-role.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sqs:SendMessage\",\n    \"Effect\": \"Allow\",\n    \"Resource\": [\n      \"arn:aws:s3:::abc/xyz/123.txt\",\n      \"(NOVALUE)\",\n      \"arn:(PARTITION):iam:(REGION):(ACCOUNT)/role/FakeRole'\",\n      \"(integ-customize-role/MyGroup/Resource.Arn)/*\",\n      \"(integ-customize-role/MyGroup/Resource.Arn)\"\n    ]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Deprecated IHttpApi Property in AWS CDK\nDESCRIPTION: The httpApiId property of IHttpApi is deprecated. Use apiId instead to get the API identifier for HTTP APIs in API Gateway v2.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// Deprecated\nconst httpApiId = httpApi.httpApiId;\n\n// Use this instead\nconst apiId = httpApi.apiId;\n```\n\n----------------------------------------\n\nTITLE: Generated CloudFormation Template with Asset Metadata\nDESCRIPTION: Example of the resulting CloudFormation resource with embedded metadata about the local asset path. This metadata enables local debugging tools to locate the function code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/code-asset-metadata.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"Type\": \"AWS::Lambda::Function\",\n  \"Properties\": {\n    \"Code\": {\n      // current asset magic\n    }\n  },\n  \"Metadata\": {\n    \"aws:asset:property\": \"Code\",\n    \"aws:asset:path\": \"/path/to/handler\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a RouteCalculator in AWS Location Service (Legacy)\nDESCRIPTION: Creates a legacy RouteCalculator resource with a specified data source. RouteCalculator resources enable finding routes and estimating travel times based on road networks and traffic information.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew location.RouteCalculator(this, 'RouteCalculator', {\n  routeCalculatorName: 'MyRouteCalculator', // optional, defaults to a generated name\n  dataSource: location.DataSource.ESRI,\n});\n```\n\n----------------------------------------\n\nTITLE: AssumeRole Policy Configuration for DynamoDB Service\nDESCRIPTION: JSON configuration of an AssumeRole policy that allows the DynamoDB service to assume this role. This policy establishes a trust relationship between the IAM role and the DynamoDB service.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-dynamodb/test/integ.table-with-customized-role.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sts:AssumeRole\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Service\": \"dynamodb.amazonaws.com\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Axios with Package Managers\nDESCRIPTION: Commands for installing Axios using different package managers including npm, yarn, bower, pnpm and bun.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install axios\n$ bower install axios\n$ yarn add axios\n$ pnpm add axios\n$ bun add axios\n```\n\n----------------------------------------\n\nTITLE: Using Step Functions as Pipe Enrichment in TypeScript\nDESCRIPTION: Creates an EventBridge Pipe that uses a Step Functions state machine as an enrichment. Only Express workflows invoked synchronously are supported by EventBridge Pipes for this enrichment type.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-enrichments-alpha/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\ndeclare const enrichmentStateMachine: stepfunctions.StateMachine;\n\nconst enrichment = new enrichments.StepFunctionsEnrichment(enrichmentStateMachine);\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SomeSource(sourceQueue),\n  enrichment,\n  target: new SomeTarget(targetQueue),\n});\n```\n\n----------------------------------------\n\nTITLE: Requiring MIME Types Module\nDESCRIPTION: Demonstrates how to import the mime-types module in a Node.js application\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar mime = require('mime-types')\n```\n\n----------------------------------------\n\nTITLE: Delay with Rejection\nDESCRIPTION: Demonstrates using delay.reject() to create a promise that rejects after a specified time with an optional error value.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\n(async () => {\n\ttry {\n\t\tawait delay.reject(100, {value: new Error('')});\n\n\t\tconsole.log('This is never executed');\n\t} catch (error) {\n\t\t// 100 milliseconds later\n\t\tconsole.log(error);\n\t\t//=> [Error: ]\n\t}\n})();\n```\n\n----------------------------------------\n\nTITLE: Importing the Neptune CDK Package in TypeScript\nDESCRIPTION: Basic import statement for the Neptune CDK package which contains primitives for setting up Neptune database clusters and instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-neptune-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as neptune from '@aws-cdk/aws-neptune-alpha';\n```\n\n----------------------------------------\n\nTITLE: Basic Axios GET Request Examples\nDESCRIPTION: Examples of making GET requests using Axios with promises and async/await syntax.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  })\n  .finally(function () {\n    // always executed\n  });\n\nasync function getUser() {\n  try {\n    const response = await axios.get('/user?ID=12345');\n    console.log(response);\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssumeRole Policy for AWS Lambda IAM Role\nDESCRIPTION: This JSON snippet defines the AssumeRole policy for the Lambda function's IAM role. It allows the Lambda service to assume this role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda/test/integ.lambda-customize-roles.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sts:AssumeRole\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Service\": \"lambda.amazonaws.com\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Introducing Experimental API with 'BetaX' Suffix in TypeScript\nDESCRIPTION: Illustrates the AWS CDK pattern for introducing new, experimental APIs by appending a `BetaX` suffix (e.g., `Beta1`) to the method or class name. This example shows `grantAwesomePowerBeta1()`, signaling that the API is in a preview state, subject to change, and intended for early feedback.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/**\n * This method grants awesome powers\n */\ngrantAwesomePowerBeta1();\n```\n```\n\n----------------------------------------\n\nTITLE: Defining ServiceDiscoveryOptions Interface for ECS Service Discovery in TypeScript\nDESCRIPTION: Interface specifying the configuration options for enabling service discovery on an ECS service. It includes options for DNS record type, TTL settings, service name, and health check configurations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-service-discovery-integration.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ServiceDiscoveryOptions {\n  /**\n   * Name of the cloudmap service to attach to the ECS Service\n   *\n   * @default CloudFormation-generated name\n   */\n  name?: string,\n\n  /**\n   * The DNS type of the record that you want AWS Cloud Map to create. Supported record types\n   * include A or SRV.\n\n   * @default: A\n   */\n  dnsRecordType?: cloudmap.DnsRecordType.A | cloudmap.DnsRecordType.SRV,\n\n  /**\n   * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this\n   * record.\n   *\n   * @default 60\n   */\n  dnsTtlSec?: number;\n\n  /**\n   * The number of 30-second intervals that you want Cloud Map to wait after receiving an\n   * UpdateInstanceCustomHealthStatus request before it changes the health status of a service instance.\n   * NOTE: This is used for a Custom HealthCheckCustomConfig\n   */\n  failureThreshold?: number,\n}\n```\n\n----------------------------------------\n\nTITLE: Github Pull Request Reference\nDESCRIPTION: Reference to pull request #6028 addressing CVE-2023-45857.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nCVE 2023 45857 ( [#6028](https://api.github.com/repos/axios/axios/pulls/6028) )\n```\n\n----------------------------------------\n\nTITLE: Importing the GameLiftStreams Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS GameLiftStreams module from the core AWS CDK library (`aws-cdk-lib`) in a TypeScript project. Importing the module as `gameliftstreams` allows access to the L1 CloudFormation constructs provided for the GameLiftStreams service within your CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-gameliftstreams/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as gameliftstreams from 'aws-cdk-lib/aws-gameliftstreams';\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon Inspector L1 Constructs with AWS CDK (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import the Inspector module from the aws-cdk-lib package to enable usage of Amazon Inspector resources in an AWS CDK project. There are no custom L2 constructs at this time, so only L1 (CloudFormation-based) resources are available. The import must be present at the beginning of your TypeScript CDK app or construct file to work with Inspector resources programmatically. This snippet has no runtime inputs or outputs and requires aws-cdk-lib as a project dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-inspector/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as inspector from 'aws-cdk-lib/aws-inspector';\n```\n\n----------------------------------------\n\nTITLE: Aurora Serverless V2 Capacity Configuration\nDESCRIPTION: JSON configuration example showing the capacity range settings for Aurora Serverless V2 instances.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rds/adr/aurora-serverless-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"MaxCapacity\": 128, // max value\n  \"MinCapacity\": 0.5 // min value\n}\n```\n\n----------------------------------------\n\nTITLE: Elastic Beanstalk Deployment Configuration\nDESCRIPTION: Sets up an Elastic Beanstalk deployment action in CodePipeline. Configures deployment to a specific environment and application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst sourceOutput = new codepipeline.Artifact();\nconst targetBucket = new s3.Bucket(this, 'MyBucket');\n\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst deployAction = new codepipeline_actions.ElasticBeanstalkDeployAction({\n  actionName: 'ElasticBeanstalkDeploy',\n  input: sourceOutput,\n  environmentName: 'envName',\n  applicationName: 'appName',\n});\n\nconst deployStage = pipeline.addStage({\n  stageName: 'Deploy',\n  actions: [deployAction],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an S3 Bucket in CloudFormation (YAML)\nDESCRIPTION: An example CloudFormation template snippet in YAML format defining a single S3 bucket resource named 'Bucket' with a specific bucket name property. This is equivalent to the JSON example.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/cloudformation-include/README.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nResources:\n  Bucket:\n    Type: AWS::S3::Bucket\n    Properties:\n      BucketName: amzn-s3-demo-bucket\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK .NET Packages\nDESCRIPTION: Installs AWS CDK NuGet packages in a .NET environment using the NuGet package manager\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nInstall-Package C:\\Path\\To\\Zip\\dotnet\\Amazon.CDK.AWS.Events.1.2.3.nupkg\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoT Analytics Module in AWS CDK TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import the AWS IoT Analytics module from the AWS CDK library (`aws-cdk-lib`). This import is necessary to access the low-level (L1) constructs provided for AWS IoT Analytics, allowing users to define resources like channels, datasets, pipelines, and datastores programmatically within their CDK application. The `aws-cdk-lib` package must be installed as a project dependency.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotanalytics/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport * as iotanalytics from 'aws-cdk-lib/aws-iotanalytics';\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Axios Default Configuration Object - JavaScript\nDESCRIPTION: Demonstrates how to define detailed default configuration parameters for Axios, including decompression, HTTP parsing behavior, transitional compatibility options, environment FormData handling, form serialization options, and rate limits for the HTTP adapter. This snippet does not execute requests but serves as a template for customizing Axios behaviors at a global or instance level. Requires `axios` and a browser or Node.js environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// - Node only (XHR cannot turn off decompression)\ndecompress: true, // default\n\n// `insecureHTTPParser` boolean.\n// Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers.\n// This may allow interoperability with non-conformant HTTP implementations.\n// Using the insecure parser should be avoided.\n// see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback\n// see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none\ninsecureHTTPParser: undefined, // default\n\n// transitional options for backward compatibility that may be removed in the newer versions\ntransitional: {\n  // silent JSON parsing mode\n  // `true`  - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour)\n  // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to 'json')\n  silentJSONParsing: true, // default value for the current Axios version\n\n  // try to parse the response string as JSON even if `responseType` is not 'json'\n  forcedJSONParsing: true,\n\n  // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts\n  clarifyTimeoutError: false,\n},\n\nenv: {\n  // The FormData class to be used to automatically serialize the payload into a FormData object\n  FormData: window?.FormData || global?.FormData\n},\n\nformSerializer: {\n    visitor: (value, key, path, helpers) => {}; // custom visitor function to serialize form values\n    dots: boolean; // use dots instead of brackets format\n    metaTokens: boolean; // keep special endings like {} in parameter key\n    indexes: boolean; // array indexes format null - no brackets, false - empty brackets, true - brackets with indexes\n},\n\n// http adapter only (node.js)\nmaxRate: [\n  100 * 1024, // 100KB/s upload limit,\n  100 * 1024  // 100KB/s download limit\n]\n```\n\n----------------------------------------\n\nTITLE: Asserting Properties for All Resources of a Type in TypeScript\nDESCRIPTION: Demonstrates using `allResourcesProperties()` to assert that *all* resources of the specified type have a `Properties` section containing the provided properties. Like `hasResourceProperties`, it performs a deep partial match by default.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.allResourcesProperties('Foo::Bar', {\n  Lorem: 'Ipsum',\n  Baz: 5,\n  Qux: [ 'Waldo', 'Fred' ],\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Handling URL-Encoded Data Server-Side with Express/body-parser\nDESCRIPTION: Provides a server-side example using Node.js and Express with the `body-parser` middleware. It shows how to configure `bodyParser.urlencoded({ extended: true })` to correctly parse incoming `application/x-www-form-urlencoded` requests, including those with nested objects serialized by Axios or the `qs` library. The parsed data is available in `req.body`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\n  var app = express();\n\n  app.use(bodyParser.urlencoded({ extended: true })); // support encoded bodies\n\n  app.post('/', function (req, res, next) {\n     // echo body as JSON\n     res.send(JSON.stringify(req.body));\n  });\n\n  server = app.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Configuring Managed Policy ARNs for API Gateway CloudWatch Role\nDESCRIPTION: Specifies the managed policy attached to the API Gateway role that grants permissions to push logs to CloudWatch. Uses the AWS-managed policy for API Gateway CloudWatch logging.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-iam/test/integ.customize-roles-restapi.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  \"arn:(PARTITION):iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs\"\n]\n```\n\n----------------------------------------\n\nTITLE: Adding Asset Metadata to L1 Resources Manually\nDESCRIPTION: Example of how to explicitly add asset metadata to L1 resources like CfnFunction when using CDK assets. This is necessary when directly using L1 constructs with local debugging tools.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/code-asset-metadata.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = new assets.ZipDirectoryAsset(this, 'Foo', {\n  path: '/foo/boom'\n});\n\nconst resource = new serverless.CfnFunction(this, 'Func', {\n    codeUri: {\n    bucket: asset.s3BucketName,\n    key: asset.s3ObjectKey\n  },\n  runtime: 'nodejs18.x',\n  handler: 'index.handler'\n});\n\nresource.addResourceMetadata(resource, 'CodeUri');\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Location Module in TypeScript\nDESCRIPTION: Simple import statement for accessing AWS Location Service resources in a CDK application. This is the entry point for working with Location Service resources via the L1 constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-location/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as location from 'aws-cdk-lib/aws-location';\n```\n\n----------------------------------------\n\nTITLE: Sample CDK App for EKS Verification - TypeScript\nDESCRIPTION: This TypeScript snippet illustrates a minimal AWS CDK app for deploying an EKS cluster. It demonstrates how to set up environment variables, import dependent modules, and use helper configuration (getClusterVersionConfig). Dependencies include aws-cdk-lib (eks, ec2), TypeScript, and correct AWS credentials. The primary input parameter is the environment, and the output is a synthesized or deployed CloudFormation stack for manual or automated verification.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  App, Stack,\n  aws_eks as eks,\n  aws_ec2 as ec2,\n} from 'aws-cdk-lib';\nimport { getClusterVersionConfig } from './integ-tests-kubernetes-version';\n\nconst app = new App();\nconst env = { region: process.env.CDK_DEFAULT_REGION, account: process.env.CDK_DEFAULT_ACCOUNT };\nconst stack = new Stack(app, 'my-test-stack', { env });\n\nconst cluster = new eks.Cluster(stack, 'Cluster', {\n  vpc,\n  ...getClusterVersionConfig(stack),\n  defaultCapacity: 0,\n});\n```\n\n----------------------------------------\n\nTITLE: Debug Commands for Unit Tests\nDESCRIPTION: Shell commands for debugging CDK unit tests using Node.js inspector with both nodeunit and jest test runners.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_59\n\nLANGUAGE: shell\nCODE:\n```\n# (For tests names test.xxx.ts)\n$ node --inspect-brk /path/to/aws-cdk/node_modules/.bin/nodeunit -t 'TESTNAME'\n\n# (For tests names xxxx.test.ts)\n$ node --inspect-brk /path/to/aws-cdk/node_modules/.bin/jest -i -t 'TESTNAME'\n```\n\n----------------------------------------\n\nTITLE: Setting Timer with Duration in Seconds in IoT Events State Action\nDESCRIPTION: Creates an Action that sets a timer with a specified duration in seconds. This code demonstrates how to create a timer when entering a state based on a condition.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-iotevents-actions-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as iotevents from '@aws-cdk/aws-iotevents-alpha';\nimport * as actions from '@aws-cdk/aws-iotevents-actions-alpha';\n\ndeclare const input: iotevents.IInput;\n\nconst state = new iotevents.State({\n  stateName: 'MyState',\n  onEnter: [{\n    eventName: 'test-event',\n    condition: iotevents.Expression.currentInput(input),\n    actions: [\n      new actions.SetTimerAction('MyTimer', {\n        duration: cdk.Duration.seconds(60),\n      }),\n    ],\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoT Things Graph Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates importing the AWS IoT Things Graph module from the AWS CDK library in TypeScript. The imported module provides access to L1 constructs, which correspond directly to AWS CloudFormation resources for AWS IoT Things Graph. No hand-written L2 constructs are available yet, so usage should follow the conventions for L1 constructs; ensure that 'aws-cdk-lib' is installed as a dependency in your project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotthingsgraph/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as iotthingsgraph from 'aws-cdk-lib/aws-iotthingsgraph';\n```\n\n----------------------------------------\n\nTITLE: Creating a Sourced Configuration from Encrypted S3 Bucket in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a sourced configuration referencing a file in an encrypted S3 bucket. KMS encryption is applied to the bucket for enhanced security.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nconst bucket = new s3.Bucket(this, 'MyBucket', {\n  versioned: true,\n  encryption: s3.BucketEncryption.KMS,\n});\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromBucket(bucket, 'path/to/file.json'),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CDK TypeScript/JavaScript Packages\nDESCRIPTION: Installs individual AWS CDK packages for TypeScript/JavaScript projects using npm from local tarballs\nSOURCE: https://github.com/aws/aws-cdk/blob/main/MANUAL_INSTALLATION.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install /path/to/zip/js/aws-lambda@1.2.3.jsii.tgz ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Defines required Python package dependencies using pip requirements format. Specifies the requests HTTP library version 2.31.0.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda/test/python-lambda-handler/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Cancelling Axios Requests with AbortController in JavaScript\nDESCRIPTION: Demonstrates the modern method (since v0.22.0) for cancelling Axios requests using the standard `AbortController` API. An `AbortController` instance is created, its `signal` is passed in the Axios request config, and the request can be cancelled later by calling `controller.abort()`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst controller = new AbortController();\n\naxios.get('/foo/bar', {\n   signal: controller.signal\n}).then(function(response) {\n   //...\n});\n// cancel the request\ncontroller.abort()\n```\n\n----------------------------------------\n\nTITLE: Automatic FormData Serialization in Axios (JavaScript)\nDESCRIPTION: Demonstrates how to use Axios to automatically serialize an object to FormData when the Content-Type header is set to multipart/form-data. This works in both browser and Node.js environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_32\n\nLANGUAGE: javascript\nCODE:\n```\nimport axios from 'axios';\n\naxios.post('https://httpbin.org/post', {x: 1}, {\n  headers: {\n    'Content-Type': 'multipart/form-data'\n  }\n}).then(({data}) => console.log(data));\n```\n\n----------------------------------------\n\nTITLE: Building and Testing an Alpha Package - yarn build/test - Bash\nDESCRIPTION: After navigating to a package directory, runs yarn build and yarn test to build and test an alpha AWS CDK package. For proper operation, node_modules and all dependencies must be installed first.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\n$ cd packages/@aws-cdk/some-package-alpha\\n$ yarn build\\n$ yarn test\n```\n\n----------------------------------------\n\nTITLE: Importing AWS ConnectCampaigns Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS ConnectCampaigns module in a CDK application. This provides access to L1 constructs that map directly to CloudFormation resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-connectcampaigns/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as connectcampaigns from 'aws-cdk-lib/aws-connectcampaigns';\n```\n\n----------------------------------------\n\nTITLE: AxiosHeaders Iteration (JavaScript)\nDESCRIPTION: Demonstrates how to iterate over an AxiosHeaders instance using a for...of loop. This is useful for inspecting or manipulating all headers in a request or response.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_40\n\nLANGUAGE: javascript\nCODE:\n```\nconst headers = new AxiosHeaders({\n  foo: '1',\n  bar: '2',\n  baz: '3'\n});\n\nfor(const [header, value] of headers) {\n  console.log(header, value);\n}\n\n// foo 1\n// bar 2\n// baz 3\n```\n\n----------------------------------------\n\nTITLE: Installing AsyncKit via npm\nDESCRIPTION: Command to install AsyncKit using npm package manager.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/asynckit/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm install --save asynckit\n```\n\n----------------------------------------\n\nTITLE: AWS CDK: Unqualified Type Usage Example - Typescript\nDESCRIPTION: This Typescript example demonstrates using an unqualified type from the documented module by directly calling a static method on the Duration class. It highlights recommended documentation style for in-module types. There are no external dependencies required, but the example assumes Duration is in scope.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\n// An example in the aws-cdk-lib library, which defines Duration\\nDuration.minutes(15);\n```\n\n----------------------------------------\n\nTITLE: Importing AWS ApplicationSignals Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the `aws-applicationsignals` module from the AWS CDK library (`aws-cdk-lib`). This import is the first step required to use the L1 constructs provided for AWS ApplicationSignals within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-applicationsignals/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as applicationsignals from 'aws-cdk-lib/aws-applicationsignals';\n```\n\n----------------------------------------\n\nTITLE: Axios Response Schema Example - JavaScript\nDESCRIPTION: Defines the structure of an Axios HTTP response object, including `data`, `status`, `statusText`, `headers`, `config`, and `request` properties. Useful for understanding how to handle and inspect responses returned from Axios requests. No external dependencies aside from Axios. This schema helps in strongly-typed environments and in developing custom response handlers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  // `data` is the response that was provided by the server\n  data: {},\n\n  // `status` is the HTTP status code from the server response\n  status: 200,\n\n  // `statusText` is the HTTP status message from the server response\n  statusText: 'OK',\n\n  // `headers` the HTTP headers that the server responded with\n  // All header names are lowercase and can be accessed using the bracket notation.\n  // Example: `response.headers['content-type']`\n  headers: {},\n\n  // `config` is the config that was provided to `axios` for the request\n  config: {},\n\n  // `request` is the request that generated this response\n  // It is the last ClientRequest instance in node.js (in redirects)\n  // and an XMLHttpRequest instance in the browser\n  request: {}\n}\n```\n\n----------------------------------------\n\nTITLE: Symlinking Local Modules with link-all.sh - Console Command - Bash\nDESCRIPTION: This snippet shows how to symlink local AWS CDK modules into the node_modules directory of another CDK app using 'link-all.sh'. Assumes the path to the cloned repo is correct and that the script is executable. Useful for development against unreleased versions.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\n$ cd <your own CDK app>\\n$ <path to the AWS CDK repo>/link-all.sh\n```\n\n----------------------------------------\n\nTITLE: Webpack Configuration for Browser Usage\nDESCRIPTION: JSON configuration for webpack to replace follow-redirects with built-in modules in browser environments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"follow-redirects/http\"  : \"http\",\n  \"follow-redirects/https\" : \"https\"\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a CloudFormation Template Parameter (AWS CDK, TypeScript)\nDESCRIPTION: This snippet uses CfnParameter to add an input parameter (type Number, default 1337) to the CloudFormation stack. Template parameters allow for customization at deployment time and integrate into the deployment UI or CLI. Additional configuration is supported via CfnParameter properties. The parameter value cannot be used at synthesis time, only at deployment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nnew CfnParameter(this, 'MyParameter', {\n  type: 'Number',\n  default: 1337,\n  // See the API reference for more configuration props\n});\n```\n\n----------------------------------------\n\nTITLE: Granting IAM permissions to a Tracker\nDESCRIPTION: Demonstrates how to grant read permissions to an IAM role for a Tracker. This allows the role to perform read operations on the tracker resource.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-location-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const role: iam.Role;\n\nconst tracker = new location.Tracker(this, 'Tracker', {\n  trackerName: 'MyTracker',\n});\n\ntracker.grantRead(role);\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Compression for Amazon Data Firehose S3 Destination in TypeScript\nDESCRIPTION: This snippet shows how to enable Snappy compression for data delivered to an S3 bucket by an Amazon Data Firehose delivery stream.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-kinesisfirehose/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Compress data delivered to S3 using Snappy\ndeclare const bucket: s3.Bucket;\nconst s3Destination = new firehose.S3Bucket(bucket, {\n  compression: firehose.Compression.SNAPPY,\n});\nnew firehose.DeliveryStream(this, 'Delivery Stream', {\n  destination: s3Destination,\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Locked Python Package Versions for AWS CDK Project\nDESCRIPTION: This code snippet defines exact versions for Python packages to ensure consistent builds. It includes core networking libraries (certifi, chardet, idna, urllib3) and the requests library, which is noted as being used by a lambda function in the project.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/test/lambda-handler/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Lock versions of pip packages\ncertifi==2024.7.4\nchardet==3.0.4\nidna==3.7\nurllib3==1.26.19\n# Requests used by this lambda\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Automatic URL-Encoding Serialization in Axios (JavaScript)\nDESCRIPTION: Illustrates Axios's automatic serialization feature. When the `Content-Type` header is explicitly set to `application/x-www-form-urlencoded`, Axios automatically encodes the provided data object, including nested arrays and objects, into the URL-encoded format before sending the POST request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nconst data = {\n  x: 1,\n  arr: [1, 2, 3],\n  arr2: [1, [2], 3],\n  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],\n};\n\nawait axios.postForm('https://postman-echo.com/post', data,\n  {headers: {'content-type': 'application/x-www-form-urlencoded'}}\n);\n```\n\nLANGUAGE: javascript\nCODE:\n```\n  {\n    x: '1',\n    'arr[]': [ '1', '2', '3' ],\n    'arr2[0]': '1',\n    'arr2[1][0]': '2',\n    'arr2[2]': '3',\n    'arr3[]': [ '1', '2', '3' ],\n    'users[0][name]': 'Peter',\n    'users[0][surname]': 'griffin',\n    'users[1][name]': 'Thomas',\n    'users[1][surname]': 'Anderson'\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing ECS Service Discovery with AWS Cloud Map in TypeScript\nDESCRIPTION: Complete example showing how to create an ECS service with Cloud Map service discovery. Demonstrates creating a VPC, Cloud Map namespace, ECS cluster, task definition, and service with service discovery enabled.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-service-discovery-integration.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst vpc = new ec2.Vpc(stack, 'Vpc', { maxAzs: 2 });\n\n// Cloud Map Namespace\nconst namespace = new servicediscovery.PrivateDnsNamespace(stack, 'MyNamespace', {\n  name: 'mydomain.com',\n  vpc,\n});\n\n// Cloud Map Service\n\nconst cloudMapService = namespace.createService('MyCloudMapService', {\n  dnsRecordType: servicediscovery.DnsRecordType.A,\n  dnsTtlSec: 300,\n  customHealthCheck: {\n    failureThreshold = 1\n  }\n});\n\n// ECS Cluster\nconst cluster = new ecs.Cluster(stack, 'EcsCluster', { vpc });\n\ncluster.addCapacity('DefaultAutoScalingGroup', {\n  instanceType: new ec2.InstanceType('t2.micro')\n});\n\ncluster.addNamespace({ name: \"foo.com\" })\n\nconst taskDefinition = new ecs.Ec2TaskDefinition(stack, 'TaskDef');\n\nconst container = taskDefinition.addContainer('web', {\n  image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  memoryLimitMiB: 256,\n});\n\ncontainer.addPortMappings({\n  containerPort: 80,\n  hostPort: 8080,\n  protocol: ecs.Protocol.Tcp\n});\n\nconst ecsService = new ecs.Ec2Service(stack, \"MyECSService\", {\n  cluster,\n  taskDefinition,\n});\n\necsService.enableServiceDiscovery(\n  dnsRecordType: servicediscovery.DnsRecordType.A,\n  dnsTtlSec: 300,\n  customHealthCheck: {\n    failureThreshold = 1\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Cancelling Axios Requests with CancelToken.source (Deprecated)\nDESCRIPTION: Shows the deprecated method (prior to v0.22.0) for cancelling Axios requests using `CancelToken.source()`. A source object is created, its `token` is passed in the config for both GET and POST requests. Calling `source.cancel()` cancels any requests associated with that token. The `.catch()` block demonstrates checking if the error was due to cancellation using `axios.isCancel()`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n  cancelToken: source.token\n}).catch(function (thrown) {\n  if (axios.isCancel(thrown)) {\n    console.log('Request canceled', thrown.message);\n  } else {\n    // handle error\n  }\n});\n\naxios.post('/user/12345', {\n  name: 'new name'\n}, {\n  cancelToken: source.token\n})\n\n// cancel the request (the message parameter is optional)\nsource.cancel('Operation canceled by the user.');\n```\n\n----------------------------------------\n\nTITLE: Implementing Tag Properties in Ec2Service Class Constructor in TypeScript\nDESCRIPTION: Updates the Ec2Service class constructor to include the new tag propagation and ECS managed tags properties. These properties are passed to the BaseService constructor with default values if not specified.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/aws-ecs/aws-ecs-tagging-support.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Ec2Service extends BaseService implements IEc2Service, elb.ILoadBalancerTarget {\n\n  ...\n\n  constructor(scope: Construct, id: string, props: Ec2ServiceProps) {\n\n    ...\n\n    super(scope, id, {\n      ...props,\n      // If daemon, desiredCount must be undefined and that's what we want. Otherwise, default to 1.\n      desiredCount: props.daemon || props.desiredCount !== undefined ? props.desiredCount : 1,\n      maxHealthyPercent: props.daemon && props.maxHealthyPercent === undefined ? 100 : props.maxHealthyPercent,\n      minHealthyPercent: props.daemon && props.minHealthyPercent === undefined ? 0 : props.minHealthyPercent,\n      launchType: LaunchType.EC2,\n      propagateTags: props.propagateTaskTagsFrom === undefined ? PropagatedTagSource.SERVICE : props.propagateTaskTagsFrom,\n      enableECSManagedTags: props.enableECSManagedTags,\n    },\n    {\n      cluster: props.cluster.clusterName,\n      taskDefinition: props.taskDefinition.taskDefinitionArn,\n      placementConstraints: Lazy.anyValue({ produce: () => this.constraints }, { omitEmptyArray: true }),\n      placementStrategies: Lazy.anyValue({ produce: () => this.strategies }, { omitEmptyArray: true }),\n      schedulingStrategy: props.daemon ? 'DAEMON' : 'REPLICA',\n    }, props.taskDefinition);\n\n    ...\n\n  }\n\n  ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning up EKS services before cluster deletion\nDESCRIPTION: Command to delete all services in the EKS cluster, which ensures proper removal of AWS resources like the load balancer. This step is critical before deleting the CloudFormation stack to prevent deletion failures.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/test/MANUAL_TEST.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl delete --all services\n\n```\n\n----------------------------------------\n\nTITLE: Installing delayed-stream via npm\nDESCRIPTION: Command to install the delayed-stream package using npm package manager\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/delayed-stream/Readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install delayed-stream\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Notifications Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the AWS Notifications module in a TypeScript project using the AWS CDK library. It allows access to the notifications-related constructs and functionality provided by the AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-notifications/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as notifications from 'aws-cdk-lib/aws-notifications';\n```\n\n----------------------------------------\n\nTITLE: Uploading Files with Axios and FormData - JavaScript\nDESCRIPTION: This snippet illustrates how to use the 'axios' HTTP client together with FormData to post file streams in a Node.js environment. It highlights the need to set multipart boundaries in headers using FormData's getHeaders method and demonstrates appending a file stream to the form. Required dependencies are 'axios', 'form-data', and Node's 'fs'; typical input is a file stream, and output is handled by resolving the promise or catching errors.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst form = new FormData();\nconst stream = fs.createReadStream(PATH_TO_FILE);\n\nform.append('image', stream);\n\n// In Node.js environment you need to set boundary in the header field 'Content-Type' by calling method `getHeaders`\nconst formHeaders = form.getHeaders();\n\naxios.post('http://example.com', form, {\n  headers: {\n    ...formHeaders,\n  },\n})\n.then(response => response)\n.catch(error => error)\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS CLI v2 with SSO in Gitpod (Shell)\nDESCRIPTION: This snippet demonstrates how to configure the AWS CLI v2 within a Gitpod environment using AWS IAM Identity Center (formerly AWS SSO) for authentication. It checks the installed AWS CLI version, initiates the SSO configuration process, logs the user in via SSO, and verifies the current AWS identity.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n# make sure AWS CLI v2 is in your $PATH\n$ aws --version\n# configure the AWS profile with SSO\n$ aws configure sso\n# login and authenticate\n$ aws sso login\n# verify your current identity\n$ aws sts get-caller-identity\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Axios Adapter in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create a custom adapter for Axios. It shows the structure of an adapter function, including handling config, making the request, and settling the Promise with the response.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/lib/adapters/README.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar settle = require('./../core/settle');\n\nmodule.exports = function myAdapter(config) {\n  // At this point:\n  //  - config has been merged with defaults\n  //  - request transformers have already run\n  //  - request interceptors have already run\n  \n  // Make the request using config provided\n  // Upon response settle the Promise\n\n  return new Promise(function(resolve, reject) {\n  \n    var response = {\n      data: responseData,\n      status: request.status,\n      statusText: request.statusText,\n      headers: responseHeaders,\n      config: config,\n      request: request\n    };\n\n    settle(resolve, reject, response);\n\n    // From here:\n    //  - response transformers will run\n    //  - response interceptors will run\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Running AWS CDK Locally\nDESCRIPTION: Command to run a locally installed CDK toolkit using npx, which executes binaries from the local node_modules directory.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/pkglint/lib/banners/l1.deprecated.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx cdk\n```\n\n----------------------------------------\n\nTITLE: Handling Axios GET Response with Promises - JavaScript\nDESCRIPTION: Shows how to perform a GET request using Axios and handle the response in a Promise chain with a `then` callback. Demonstrates accessing response properties like `data`, `status`, `statusText`, `headers`, and `config`. Prerequisite: The `axios` package must be installed and imported. Input is a GET request URL, output is logging response details to the console.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\naxios.get('/user/12345')\n  .then(function (response) {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  });\n```\n\n----------------------------------------\n\nTITLE: Sending URL-Encoded Data with qs Library and Explicit Options (ES6)\nDESCRIPTION: Provides an alternative way (using ES6 imports) to send `application/x-www-form-urlencoded` data with the `qs` library. It explicitly sets the `Content-Type` header and passes the stringified data within a comprehensive options object to the main `axios` function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nimport qs from 'qs';\nconst data = { 'bar': 123 };\nconst options = {\n  method: 'POST',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  data: qs.stringify(data),\n  url,\n};\naxios(options);\n```\n\n----------------------------------------\n\nTITLE: Executing Serial Jobs with AsyncKit on Object Input\nDESCRIPTION: Demonstrates the use of AsyncKit's serial method to process an object of named jobs sequentially. It shows the shortcut interface with item and callback parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/asynckit/README.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nvar serial = require('asynckit').serial\n  , assert = require('assert')\n  ;\n\nvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ]\n  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ]\n  , expectedTarget = [ 0, 1, 2, 3, 4, 5, 6, 7 ]\n  , target         = []\n  ;\n\nvar source         = { first: 1, one: 1, four: 4, sixteen: 16, sixtyFour: 64, thirtyTwo: 32, eight: 8, two: 2 }\n  , expectedResult = { first: 2, one: 2, four: 8, sixteen: 32, sixtyFour: 128, thirtyTwo: 64, eight: 16, two: 4 }\n  , expectedTarget = [ 1, 1, 4, 16, 64, 32, 8, 2 ]\n  , target         = []\n  ;\n\n\nserial(source, asyncJob, function(err, result)\n{\n  assert.deepEqual(result, expectedResult);\n  assert.deepEqual(target, expectedTarget);\n});\n\n// shortcut interface (item, callback)\n// works for object as well as for the arrays\nfunction asyncJob(item, cb)\n{\n  target.push(item);\n\n  // it will be automatically made async\n  // even it iterator \"returns\" in the same event loop\n  cb(null, item * 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Changelog Bug Fixes Documentation\nDESCRIPTION: Markdown entries documenting bug fixes and issue resolutions\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CHANGELOG.v2.alpha.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n### Bug Fixes\n\n* **ec2-alpha:** add multiple NATGW to the VPC using addNatGateway method ([#34094](https://github.com/aws/aws-cdk/issues/34094)) ([ccd8de7](https://github.com/aws/aws-cdk/commit/ccd8de71c02068e43d36e2445dbb5e51f4aa695b))\n* **ec2-alpha:** update default config for Subnet's `assignIpv6AddressOnCreation` ([#34116](https://github.com/aws/aws-cdk/issues/34116)) ([dff2798](https://github.com/aws/aws-cdk/commit/dff279800edd9688fa5de04766ae2667472fe861))\n```\n\n----------------------------------------\n\nTITLE: Code Coverage Exclusion Syntax\nDESCRIPTION: Example showing how to exclude specific lines from code coverage reporting using Istanbul ignore comments\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n/* istanbul ignore next */\nconsole.log('This cannot be covered')\n```\n\n----------------------------------------\n\nTITLE: Removed Windows Server Versions in AWS CDK EC2 Module\nDESCRIPTION: This snippet shows a list of Windows Server versions that have been removed from the AWS CDK EC2 module. It includes various configurations of Windows Server 2016 and 2022, with different languages, editions, and pre-installed software like SQL Server and ECS optimizations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_ENGLISH_FULL_EKS_OPTIMIZED_1_29_2024_01_09\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_ENGLISH_FULL_EKS_OPTIMIZED_1_29_2024_02_06\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2022_ENGLISH_FULL_EKS_OPTIMIZED_1_29_2024_02_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CZECH_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CZECH_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CZECH_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_CZECH_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_DUTCH_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_DUTCH_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_DUTCH_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_DUTCH_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_EXPRESS_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_EXPRESS_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_EXPRESS_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_EXPRESS_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP3_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_BASE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_BASE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_BASE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_BASE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_ECS_OPTIMIZED_2023_11_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_ECS_OPTIMIZED_2023_12_12\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_ECS_OPTIMIZED_2024_01_09\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_ECS_OPTIMIZED_2024_02_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2014_SP3_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_EXPRESS_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_EXPRESS_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_EXPRESS_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_EXPRESS_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP3_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB_2023_12_13\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB_2024_01_16\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB_2024_02_14\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2019_ENTERPRISE_2023_11_15\nremoved:aws-cdk-lib.aws_ec2.WindowsVersion.WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2019_ENTERPRISE_2023_12_13\n```\n\n----------------------------------------\n\nTITLE: Sending multipart/form-data with form-data Library in Node.js Axios\nDESCRIPTION: Demonstrates sending `multipart/form-data` from a Node.js environment using the `form-data` library. An instance of `FormData` from the library is created, and various data types (strings, buffers, file streams) are appended. This `form` object is then passed as the data payload to `axios.post()`. Axios works with this library to send the correct multipart request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nconst FormData = require('form-data');\n\nconst form = new FormData();\nform.append('my_field', 'my value');\nform.append('my_buffer', new Buffer(10));\nform.append('my_file', fs.createReadStream('/foo/bar.jpg'));\n\naxios.post('https://example.com', form)\n```\n\n----------------------------------------\n\nTITLE: Non-Pausing Stream Combination\nDESCRIPTION: Shows how to combine streams without pausing them by setting pauseStreams option to false\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/combined-stream/Readme.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar CombinedStream = require('combined-stream');\nvar fs = require('fs');\n\nvar combinedStream = CombinedStream.create({pauseStreams: false});\ncombinedStream.append(fs.createReadStream('file1.txt'));\ncombinedStream.append(fs.createReadStream('file2.txt'));\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'));\n```\n\n----------------------------------------\n\nTITLE: Configuring ECR Image Asset Version Count in TypeScript\nDESCRIPTION: Demonstrates how to customize the number of Docker image revisions stored in ECR repositories by setting imageAssetVersionCount parameter.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BucketEncryption } from 'aws-cdk-lib/aws-s3';\n\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.defaultResources({\n    appId: 'my-app-id',\n    stagingBucketEncryption: BucketEncryption.S3_MANAGED,\n    imageAssetVersionCount: 10,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: WebSocket AWS Integration with DynamoDB\nDESCRIPTION: Implements a WebSocket API integration with AWS DynamoDB. Configures a $connect route that writes new entries to a DynamoDB table when clients connect to the WebSocket API.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WebSocketAwsIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport * as iam from 'aws-cdk-lib/aws-iam';\n\nconst webSocketApi = new apigwv2.WebSocketApi(this, 'mywsapi');\nnew apigwv2.WebSocketStage(this, 'mystage', {\n  webSocketApi,\n  stageName: 'dev',\n  autoDeploy: true,\n});\n\ndeclare const apiRole: iam.Role;\ndeclare const table: dynamodb.Table;\nwebSocketApi.addRoute('$connect', {\n  integration: new WebSocketAwsIntegration('DynamodbPutItem', {\n    integrationUri: `arn:aws:apigateway:${this.region}:dynamodb:action/PutItem`,\n    integrationMethod: apigwv2.HttpMethod.POST,\n    credentialsRole: apiRole,\n    requestTemplates: {\n      'application/json': JSON.stringify({\n        TableName: table.tableName,\n        Item: {\n          id: {\n            S: '$context.requestId',\n          },\n        },\n      }),\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Lambda Function Stack Implementation\nDESCRIPTION: Implementation of a stack containing a Lambda function with configurable architecture.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/integ-tests-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface StackUnderTestProps extends StackProps {\n  architecture?: lambda.Architecture;\n}\n\nclass StackUnderTest extends Stack {\n  constructor(scope: Construct, id: string, props: StackUnderTestProps) {\n    super(scope, id, props);\n\t\n    new lambda.Function(this, 'Handler', {\n      runtime: lambda.Runtime.NODEJS_LATEST,\n      handler: 'index.handler',\n      code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),\n      architecture: props.architecture,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing combined-stream via NPM\nDESCRIPTION: Command to install the combined-stream package using npm package manager\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/combined-stream/Readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install combined-stream\n```\n\n----------------------------------------\n\nTITLE: Running Comby Migration Script (Bash)\nDESCRIPTION: Provides a Bash command to execute the `comby` tool for automated code rewriting. It uses a configuration file (`rewrite.toml`), targets TypeScript files (`.ts`) within the `test` directory, performs changes in-place, and sets a timeout. This script assists in migrating from `@aws-cdk/assert` to `@aws-cdk/assertions`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/MIGRATING.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ncomby -config ~/rewrite.toml -f .ts -d test -in-place -timeout 10\n```\n```\n\n----------------------------------------\n\nTITLE: Placeholder Comment Snippet (TypeScript/JavaScript)\nDESCRIPTION: This snippet contains a single-line comment, typically used in languages like TypeScript or JavaScript (common in AWS CDK). The comment text \"hello dear asset\" appears to be an informal note or placeholder, possibly related to managing assets within the CDK application. It does not contain executable code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3-assets/test/sample-asset-directory/sample-asset-file.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// hello dear asset\n```\n\n----------------------------------------\n\nTITLE: Granting Specific EFS Permissions to an IAM Role in TypeScript\nDESCRIPTION: Grants specific EFS permissions to an IAM role using the `.grant()` method on the FileSystem construct. This example grants the `elasticfilesystem:Backup` permission to a newly created IAM role assumed by any principal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-efs/README.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts // fixture=with-filesystem-instance\nconst role = new iam.Role(this, 'Role', {\n  assumedBy: new iam.AnyPrincipal(),\n});\n\nfileSystem.grant(role, 'elasticfilesystem:Backup');\n```\n```\n\n----------------------------------------\n\nTITLE: Critical Vulnerability Fix Notice for Axios\nDESCRIPTION: A warning message about a critical vulnerability fix in Axios, referencing CVE-2023-45857. The message includes a link to more details about the vulnerability.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n Critical vulnerability fix. See https://security.snyk.io/vuln/SNYK-JS-AXIOS-6032459\n```\n\n----------------------------------------\n\nTITLE: HTML Form Posting with Axios (Browser JavaScript)\nDESCRIPTION: Shows how to submit an HTML form using Axios, either as multipart/form-data or as JSON. This is useful for handling form submissions in single-page applications.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_35\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));\n```\n\nLANGUAGE: javascript\nCODE:\n```\nawait axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Target Groups EC2 Service in AWS CDK\nDESCRIPTION: Creates an ECS service on EC2 with multiple target groups behind an Application Load Balancer. Configures different container ports and path patterns.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecs-patterns/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cluster: ecs.Cluster;\nconst loadBalancedEc2Service = new ecsPatterns.ApplicationMultipleTargetGroupsEc2Service(this, 'Service', {\n  cluster,\n  memoryLimitMiB: 256,\n  taskImageOptions: {\n    image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n  },\n  targetGroups: [\n    {\n      containerPort: 80,\n    },\n    {\n      containerPort: 90,\n      pathPattern: 'a/b/c',\n      priority: 10,\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Changelog Breaking Changes Documentation\nDESCRIPTION: Markdown entries documenting breaking changes to experimental features\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CHANGELOG.v2.alpha.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n###  BREAKING CHANGES TO EXPERIMENTAL FEATURES\n\n* **ec2-alpha:** The logical ID for the NAT Gateway, defined using the `addNatGateways` method, will be changed, resulting in the NAT Gateway being recreated. Additionally, the domain for the Elastic IP (EIP) will be set to `vpc`, which will also trigger its recreation in the account.\n```\n\n----------------------------------------\n\nTITLE: Configuring AssumeRole Policy for SQS Service\nDESCRIPTION: IAM trust policy allowing the SQS service to assume this role\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-iam/test/integ.customize-role.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sts:AssumeRole\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Service\": \"sqs.amazonaws.com\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Importing Route53 Recovery Readiness Module in TypeScript\nDESCRIPTION: Demonstrates how to import the Route53 Recovery Readiness module into a CDK application. This allows access to the L1 constructs for Route53 Recovery Readiness resource creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-route53recoveryreadiness/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as route53recoveryreadiness from 'aws-cdk-lib/aws-route53recoveryreadiness';\n```\n\n----------------------------------------\n\nTITLE: Creating Dashboard Graph Widget\nDESCRIPTION: Shows how to create a graph widget for a CloudWatch dashboard with metrics on both axes.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudwatch/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const dashboard: cloudwatch.Dashboard;\ndeclare const executionCountMetric: cloudwatch.Metric;\ndeclare const errorCountMetric: cloudwatch.Metric;\n\ndashboard.addWidgets(new cloudwatch.GraphWidget({\n  title: \"Executions vs error rate\",\n\n  left: [executionCountMetric],\n\n  right: [errorCountMetric.with({\n    statistic: cloudwatch.Stats.AVERAGE,\n    label: \"Error rate\",\n    color: cloudwatch.Color.GREEN,\n  })]\n}));\n```\n\n----------------------------------------\n\nTITLE: Initializing AWS CDK App and Stack in TypeScript\nDESCRIPTION: Creates a new AWS CDK application instance (`cdk.App`) and a stack (`cdk.Stack`) within that application, identified as 'stack'. This is the standard prerequisite setup for defining AWS infrastructure using the CDK framework.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appmesh/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new cdk.App();\nconst stack = new cdk.Stack(app, 'stack');\n```\n\n----------------------------------------\n\nTITLE: Installing mime-db package using npm (Bash)\nDESCRIPTION: This command uses the Node Package Manager (npm) to download and install the `mime-db` library into the current project's `node_modules` directory. This makes the library's database available for use within a Node.js application. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-db/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install mime-db\n```\n\n----------------------------------------\n\nTITLE: Creating a Hosted Configuration from Inline JSON in AWS AppConfig with TypeScript\nDESCRIPTION: Creates a hosted configuration from inline JSON. The content type is automatically set to 'application/json' unless specified otherwise.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const application: appconfig.Application;\n\nnew appconfig.HostedConfiguration(this, 'MyHostedConfiguration', {\n  application,\n  content: appconfig.ConfigurationContent.fromInlineJson('{}'),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Pipeline Execution Mode using AWS CDK (TypeScript)\nDESCRIPTION: This code configures the executionMode property of a pipeline in AWS CDK (TypeScript) to enable parallel executions (ExecutionMode.PARALLEL), which allows multiple pipeline executions at once. ExecutionMode can only be used with pipelineType V2. No actions or triggers are required for this minimal example. Requires codepipeline module. The pipeline will support concurrent execution flows.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nnew codepipeline.Pipeline(this, 'Pipeline', {\n  pipelineType: codepipeline.PipelineType.V2,\n  executionMode: codepipeline.ExecutionMode.PARALLEL,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting and Getting HTTP Headers with AxiosHeaders - TypeScript\nDESCRIPTION: Demonstrates various overloads of the set and get methods on AxiosHeaders for manipulating HTTP headers. Highlights the effects of the rewrite argument, parsing header values using matcher functions, and handling complex header retrieval and parsing logic. Requires Axios and its type definitions; input parameters include header names, values, and optional parsing functions. Outputs include direct header value retrieval, parsed objects, and mutated header values based on user callbacks.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nset(headerName, value: Axios, rewrite?: boolean);\nset(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);\nset(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);\n```\n\nLANGUAGE: typescript\nCODE:\n```\n  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;\n  get(headerName: string, parser: RegExp): RegExpExecArray | null;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst headers = new AxiosHeaders({\n  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'\n});\n\nconsole.log(headers.get('Content-Type')); \n// multipart/form-data; boundary=Asrf456BGe4h\n\nconsole.log(headers.get('Content-Type', true)); // parse key-value pairs from a string separated with \\s,;= delimiters:\n// [Object: null prototype] {\n//   'multipart/form-data': undefined,\n//    boundary: 'Asrf456BGe4h'\n// }\n\n\nconsole.log(headers.get('Content-Type', (value, name, headers) => {\n  return String(value).replace(/a/g, 'ZZZ');\n}));\n// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h\n\nconsole.log(headers.get('Content-Type', /boundary=(\\w+)/)?.[0]);\n// boundary=Asrf456BGe4h\n```\n\n----------------------------------------\n\nTITLE: Docker Image Asset with Build Arguments\nDESCRIPTION: Creates a Docker image asset with custom build arguments and build invalidation settings for proxy configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-ecr-assets/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DockerImageAsset } from 'aws-cdk-lib/aws-ecr-assets';\n\nconst asset = new DockerImageAsset(this, 'MyBuildImage', {\n  directory: path.join(__dirname, 'my-image'),\n  buildArgs: {\n    HTTP_PROXY: 'http://10.20.30.2:1234',\n  },\n  invalidation: {\n    buildArgs: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Invoicing Module in TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the AWS Invoicing module from the AWS CDK library (`aws-cdk-lib`). It makes the L1 constructs for AWS::Invoicing available under the `invoicing` alias for use in CDK applications. This is the entry point for utilizing the CloudFormation-level resources for AWS Invoicing within a CDK stack.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-invoicing/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts nofixture\nimport * as invoicing from 'aws-cdk-lib/aws-invoicing';\n```\n```\n\n----------------------------------------\n\nTITLE: List All awslint Rules - yarn awslint list - Bash\nDESCRIPTION: Runs 'yarn awslint list' to print available awslint rules with metadata. No arguments required. Assumes awslint is present in the module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\nyarn awslint list\n```\n\n----------------------------------------\n\nTITLE: Lint All Modules with awslint via foreach.sh - Console Command - Bash\nDESCRIPTION: Runs the 'scripts/foreach.sh' script with 'yarn awslint' to execute awslint across all modules in order. For repo-wide API compliance checks. Prerequisites: fetch, build, and dependency setup completed.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\nscripts/foreach.sh yarn awslint\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Response Handling in SDKv3 (TypeScript)\nDESCRIPTION: This snippet illustrates how SDKv3 requires manual consumption of the response stream when retrieving an object from S3 to free the socket.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-custom-resource-sdk-adapter/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// consume the stream to free the socket\nconst get = await s3.getObject({ ... }); // object .Body has unconsumed stream\nconst str = await get.Body.transformToString(); // consumes the stream\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Jobs with AsyncKit on Object Input\nDESCRIPTION: Shows how to use AsyncKit's parallel method to process an object of named jobs asynchronously. It demonstrates the full value, key, callback interface.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/asynckit/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar parallel = require('asynckit/parallel')\n  , assert   = require('assert')\n  ;\n\nvar source         = { first: 1, one: 1, four: 4, sixteen: 16, sixtyFour: 64, thirtyTwo: 32, eight: 8, two: 2 }\n  , expectedResult = { first: 2, one: 2, four: 8, sixteen: 32, sixtyFour: 128, thirtyTwo: 64, eight: 16, two: 4 }\n  , expectedTarget = [ 1, 1, 2, 4, 8, 16, 32, 64 ]\n  , expectedKeys   = [ 'first', 'one', 'two', 'four', 'eight', 'sixteen', 'thirtyTwo', 'sixtyFour' ]\n  , target         = []\n  , keys           = []\n  ;\n\nparallel(source, asyncJob, function(err, result)\n{\n  assert.deepEqual(result, expectedResult);\n  assert.deepEqual(target, expectedTarget);\n  assert.deepEqual(keys, expectedKeys);\n});\n\n// supports full value, key, callback (shortcut) interface\nfunction asyncJob(item, key, cb)\n{\n  // different delays (in ms) per item\n  var delay = item * 25;\n\n  // pretend different jobs take different time to finish\n  // and not in consequential order\n  var timeoutId = setTimeout(function() {\n    keys.push(key);\n    target.push(item);\n    cb(null, item * 2);\n  }, delay);\n\n  // allow to cancel \"leftover\" jobs upon error\n  // return function, invoking of which will abort this job\n  return clearTimeout.bind(null, timeoutId);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Asynchronous Lambda Function Invocation in EventBridge Pipe\nDESCRIPTION: Creates an EventBridge Pipe with a Lambda function target set to asynchronous invocation mode. This uses FIRE_AND_FORGET invocation type instead of the default synchronous behavior.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-targets-alpha/README.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetFunction: lambda.IFunction;\n\nconst pipeTarget = new targets.LambdaFunction(targetFunction, {\n  invocationType: targets.LambdaFunctionInvocationType.FIRE_AND_FORGET,\n});\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n    source: new SqsSource(sourceQueue),\n    target: pipeTarget\n});\n```\n\n----------------------------------------\n\nTITLE: Documenting Change in Lambda FilterRule Return Type - AWS CDK - TypeScript\nDESCRIPTION: This snippet clarifies that the null() method previously returned an empty array ([]), which led to invalid filter rules, and now returns [null] instead. As a result, the return type was changed from string[] to any. There are no dependencies but consumers must note the function may now return arrays containing null, not just strings. Inputs and outputs are strictly related to method return values; downstream code must be aware of the type shift.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n# null() return a [] which is invalid filter rule. It should return [null].\n# Hence the return type changes from string[] to any\nchange-return-type:aws-cdk-lib.aws_lambda.FilterRule.null\n```\n\n----------------------------------------\n\nTITLE: Implementing Interface Property with Error-Throwing Getter in TypeScript\nDESCRIPTION: Provides a TypeScript example of implementing an interface property (`count`) using a getter within a class. If the required underlying value (`_count`) wasn't provided during instantiation, the getter throws a descriptive runtime error, guiding the user on how to resolve the issue (e.g., by providing the 'count' during object creation). This avoids returning potentially misleading default values.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nclass SomeClass implements ICountable {\n  constructor(private readonly _count?: number) {\n  }\n\n  public get count(): number {\n    if (this._count === undefined) {\n      //  DO: throw a descriptive error that tells the user what to do\n      throw new Error('This operation requires that a \\'count\\' is specified when SomeClass is created.');\n      //  DO NOT: just throw an error like 'count is missing'\n    }\n    return this._count;\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Basic HTTP GET Request with Redirect Handling\nDESCRIPTION: Demonstrates how to make a basic HTTP GET request that automatically follows redirects using the follow-redirects module.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { http, https } = require('follow-redirects');\n\nhttp.get('http://bit.ly/900913', response => {\n  response.on('data', chunk => {\n    console.log(chunk);\n  });\n}).on('error', err => {\n  console.error(err);\n});\n```\n\n----------------------------------------\n\nTITLE: Sending URL-Encoded Data with qs Library in Axios (JavaScript)\nDESCRIPTION: Shows how to send data in `application/x-www-form-urlencoded` format using the `qs` library for broader compatibility, especially with older browsers (if polyfilled) or when dealing with nested objects. The `qs.stringify()` method is used to encode the data object before sending it in an Axios POST request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nconst qs = require('qs');\naxios.post('/foo', qs.stringify({ 'bar': 123 }));\n```\n\n----------------------------------------\n\nTITLE: Asset Comment in AWS CDK\nDESCRIPTION: A simple comment line related to asset handling in AWS CDK\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-s3-assets/test/sample-asset-directory/sample-asset-file.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// hello dear asset\n```\n\n----------------------------------------\n\nTITLE: AWS Service Catalog Deployment\nDESCRIPTION: Implements deployment to AWS Service Catalog using CodePipeline. Configures deployment of CloudFormation templates to an existing Service Catalog product.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst cdkBuildOutput = new codepipeline.Artifact();\nconst serviceCatalogDeployAction = new codepipeline_actions.ServiceCatalogDeployActionBeta1({\n  actionName: 'ServiceCatalogDeploy',\n  templatePath: cdkBuildOutput.atPath(\"Sample.template.json\"),\n  productVersionName: \"Version - \" + Date.now.toString,\n  productVersionDescription: \"This is a version from the pipeline with a new description.\",\n  productId: \"prod-XXXXXXXX\",\n});\n```\n\n----------------------------------------\n\nTITLE: Concurrent Requests with Axios\nDESCRIPTION: Example of making multiple concurrent HTTP requests using Promise.all with Axios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\nPromise.all([getUserAccount(), getUserPermissions()])\n  .then(function (results) {\n    const acct = results[0];\n    const perm = results[1];\n  });\n```\n\n----------------------------------------\n\nTITLE: Asserting All CloudFormation Outputs with Wildcard in TypeScript\nDESCRIPTION: Demonstrates using `hasOutput()` with `*` as the logical ID to assert that *all* Outputs in the template match the provided properties structure.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntemplate.hasOutput('*', {\n  Value: 'Bar',\n  Export: { Name: 'ExportBaz' },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using Node-Bundle Programmatically with TypeScript\nDESCRIPTION: Example of how to use the node-bundle tool programmatically in TypeScript. This shows how to create a Bundle instance with specific configuration options and call the pack method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/tools/@aws-cdk/node-bundle/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Bundle } from '@aws-cdk/node-bundle';\n\nconst bundle = new Bundle({\n  packageDir: process.cwd(),\n  allowedLicenses: ['Apache-2.0', 'MIT'],\n});\n\nbundle.pack();\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Stream Usage\nDESCRIPTION: Demonstrates how to use HTTP response stream with form-data\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar FormData = require('form-data');\nvar http = require('http');\n\nvar form = new FormData();\n\nhttp.request('http://nodejs.org/images/logo.png', function(response) {\n  form.append('my_field', 'my value');\n  form.append('my_buffer', new Buffer(10));\n  form.append('my_logo', response);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring CloudTrail SNS Notifications using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure an AWS CloudTrail trail to send notifications to an Amazon SNS topic upon delivery of new log files to S3. It involves creating an SNS topic using `sns.Topic` and passing it to the `Trail` construct via the `snsTopic` property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudtrail/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'TrailTopic');\nconst trail = new cloudtrail.Trail(this, 'CloudTrail', {\n  snsTopic: topic,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Customizing Axios Instances - JavaScript\nDESCRIPTION: Demonstrates how to create custom Axios instances with specific configuration (e.g., baseURL or headers). Allows fine-grained control over defaults on a per-instance basis instead of global. Requires `axios` to be imported and any required authentication tokens to be defined. Outputs a new Axios instance tailored for a particular set of requests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Set config defaults when creating the instance\nconst instance = axios.create({\n  baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n```\n\n----------------------------------------\n\nTITLE: Defining a GameLift FleetIQ Game Server Group with Multiple Instance Types (TypeScript)\nDESCRIPTION: This code defines a GameLift FleetIQ GameServerGroup in TypeScript using AWS CDK, specifying a group name, multiple instance types, a launch template, and a target VPC. All resources (launchTemplate and VPC) need to be predeclared. The result is a game server group supporting high-availability and variability in instance types for flexible scaling.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-gamelift-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare const launchTemplate: ec2.ILaunchTemplate;\ndeclare const vpc: ec2.IVpc;\n\nnew gamelift.GameServerGroup(this, 'Game server group', {\n  gameServerGroupName: 'sample-gameservergroup-name',\n  instanceDefinitions: [{\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n  },\n  {\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n  }],\n  launchTemplate: launchTemplate,\n  vpc: vpc\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic SNS Topic with Display Name in AWS CDK (TypeScript)\nDESCRIPTION: This snippet shows how to define a basic Amazon SNS topic in a CDK stack, optionally adding a display name for custom identification purposes. The only dependency required is the sns construct from aws-cdk-lib. The snippet demonstrates specifying properties on topic creation, with the displayName key being used for setting a custom name that will appear in the AWS Console. Expects a CDK stack context as 'this' and outputs a Topic construct instance.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sns/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst topic = new sns.Topic(this, 'Topic', {\n  displayName: 'Customer subscription topic',\n});\n```\n\n----------------------------------------\n\nTITLE: Request Stream Integration\nDESCRIPTION: Shows how to use request library stream with form-data\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar FormData = require('form-data');\nvar request = require('request');\n\nvar form = new FormData();\n\nform.append('my_field', 'my value');\nform.append('my_buffer', new Buffer(10));\nform.append('my_logo', request('http://nodejs.org/images/logo.png'));\n```\n\n----------------------------------------\n\nTITLE: Setting Termination Protection After Stack Creation - TypeScript\nDESCRIPTION: Shows how to enable termination protection on a previously instantiated AWS CDK Stack by assigning the terminationProtection property after object creation. This method requires the stack to have been created and allows enabling or disabling termination protection post-construction. Assumes the stack is instantiated and modifies its behavior to protect it from deletion.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nconst stack = new Stack(app, 'StackName', {});\nstack.terminationProtection = true;\n```\n\n----------------------------------------\n\nTITLE: Importing an existing Deployment Configuration in TypeScript\nDESCRIPTION: Imports an existing EC2/on-premise deployment configuration using the fromServerDeploymentConfigName static method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codedeploy/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst deploymentConfig = codedeploy.ServerDeploymentConfig.fromServerDeploymentConfigName(\n  this,\n  'ExistingDeploymentConfiguration',\n  'MyExistingDeploymentConfiguration',\n);\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to an SQS Queue with EventBridge Scheduler using AWS CDK in TypeScript\nDESCRIPTION: This snippet illustrates how to send a message to an Amazon SQS queue using EventBridge Scheduler and AWS CDK. It defines a FIFO SQS queue requiring content-based deduplication, sets up an `SqsSendMessage` target with a text payload and a `messageGroupId`, and creates a schedule to trigger this target every minute. Using a FIFO queue necessitates specifying `messageGroupId` and enabling `contentBasedDeduplication`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-scheduler-targets/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst payload = 'test';\nconst messageGroupId = 'id';\nconst queue = new sqs.Queue(this, 'MyQueue', {\n  fifo: true,\n  contentBasedDeduplication: true,\n});\n\nconst target = new targets.SqsSendMessage(queue, {\n    input: ScheduleTargetInput.fromText(payload),\n    messageGroupId,\n});\n\nnew Schedule(this, 'Schedule', {\n    schedule: ScheduleExpression.rate(Duration.minutes(1)),\n    target\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Axios Status Code Validation in JavaScript\nDESCRIPTION: Shows how to use the `validateStatus` configuration option in an Axios GET request to override the default error handling behavior. Instead of treating only 2xx status codes as successful, this example defines a function that considers any status code less than 500 as a successful response, preventing Axios from throwing an error for codes in the 3xx and 4xx ranges.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\naxios.get('/user/12345', {\n  validateStatus: function (status) {\n    return status < 500; // Resolve only if the status code is less than 500\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving High-Level CertificateAuthority Interface from Low-Level Resource in AWS CDK (TypeScript)\nDESCRIPTION: Shows how to obtain a high-level CertificateAuthority instance from a low-level CfnCertificateAuthority object in AWS CDK by using its attrArn attribute in the fromCertificateAuthorityArn method. This allows passing resources to higher-level CDK constructs even when they were initially declared via low-level CFN constructs. Requires a declared cfnCertificateAuthority (of type acmpca.CfnCertificateAuthority) with a populated Arn.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-acmpca/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const cfnCertificateAuthority: acmpca.CfnCertificateAuthority;\n\nconst certificateAuthority = acmpca.CertificateAuthority.fromCertificateAuthorityArn(this, 'CertificateAuthority',\n  cfnCertificateAuthority.attrArn);\n```\n\n----------------------------------------\n\nTITLE: Implementing Merged APIs in AppSync\nDESCRIPTION: TypeScript code showing how to merge multiple AppSync APIs into a single API using AWS CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appsync/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\n\n// first source API\nconst firstApi = new appsync.GraphqlApi(this, 'FirstSourceAPI', {\n  name: 'FirstSourceAPI',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.merged-api-1.graphql')),\n});\n\n// second source API\nconst secondApi = new appsync.GraphqlApi(this, 'SecondSourceAPI', {\n  name: 'SecondSourceAPI',\n  definition: appsync.Definition.fromFile(path.join(__dirname, 'appsync.merged-api-2.graphql')),\n});\n\n// Merged API\nconst mergedApi = new appsync.GraphqlApi(this, 'MergedAPI', {\n  name: 'MergedAPI',\n  definition: appsync.Definition.fromSourceApis({\n    sourceApis: [\n      {\n        sourceApi: firstApi,\n        mergeType: appsync.MergeType.MANUAL_MERGE,\n      },\n      {\n        sourceApi: secondApi,\n        mergeType: appsync.MergeType.AUTO_MERGE,\n      }\n    ],\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Resource ID and Asserting Related Properties in TypeScript\nDESCRIPTION: Demonstrates finding a unique resource by its type and properties using `getResourceId()`, then using the returned logical ID in a subsequent assertion (`hasResourceProperties()`) to check properties of a related resource (e.g., a bucket policy referencing the bucket). `getResourceId()` expects exactly one match.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Assert that a certain bucket denies unsecure communication\nconst bucket = template.getResourceId('AWS::S3::Bucket', {\n  Properties: {\n    BucketName: 'my-bucket',\n  }\n})\n\ntemplate.hasResourceProperties('AWS::S3::BucketPolicy', {\n  Bucket: {\n    Ref: bucket,\n  },\n  PolicyDocument: {\n    Statement: [\n      {\n        Effect: 'Deny',\n        Action: 's3:*',\n        Principal: { AWS: '*' },\n        Condition: { Bool: { 'aws:SecureTransport': 'false' } },\n      },\n    ],\n  }\n})\n\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up EKS cluster and deploying sample application with kubectl\nDESCRIPTION: A series of kubectl commands to configure the EKS cluster, verify node joining, and deploy a multi-tier guestbook application with Redis backends. Includes commands to monitor service status and LoadBalancer creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/test/MANUAL_TEST.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\naws eks update-kubeconfig --name {{ClusterName}}\n\n# File above, with substitutions\nkubectl apply -f aws-auth-cm.yaml\n\n# Check that nodes joined (may take a while)\nkubectl get nodes\n\n# Start services (will autocreate a load balancer)\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-master-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-master-service.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-slave-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/redis-slave-service.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/guestbook-controller.json\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/master/guestbook-go/guestbook-service.json\n\n# Check up on service status\nkubectl get services -o wide\n```\n\n----------------------------------------\n\nTITLE: Overriding Axios Config Defaults Order of Precedence - JavaScript\nDESCRIPTION: Illustrates how Axios merges configuration values using a specific order of precedence: library defaults, instance defaults, then per-request config, with latter overriding former. Example shows modifying timeout values at the instance and per-request level. Dependencies: `axios` package. Useful for advanced configuration management.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Create an instance using the config defaults provided by the library\n// At this point the timeout config value is `0` as is the default for the library\nconst instance = axios.create();\n\n// Override timeout default for the library\n// Now all requests using this instance will wait 2.5 seconds before timing out\ninstance.defaults.timeout = 2500;\n\n// Override timeout for this request as it's known to take a long time\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS S3ObjectLambda Constructs - AWS CDK - TypeScript\nDESCRIPTION: Imports the S3ObjectLambda construct library module from 'aws-cdk-lib/aws-s3objectlambda' in a TypeScript project, enabling use of L1 resources related to AWS S3ObjectLambda within the AWS Cloud Development Kit (CDK). Prerequisites include installing the AWS CDK libraries with S3ObjectLambda support. This sets up the environment so that you can define and use S3ObjectLambda resources as you would in AWS CloudFormation. Limitations: no custom (L2) constructs are provided as of now.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-s3objectlambda/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as s3objectlambda from 'aws-cdk-lib/aws-s3objectlambda';\n```\n\n----------------------------------------\n\nTITLE: Specifying VPC for EKS Cluster\nDESCRIPTION: Creates an EKS cluster in a specific VPC with custom subnet selection for the control plane ENIs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const vpc: ec2.Vpc;\n\nnew eks.Cluster(this, 'HelloEKS', {\n  version: eks.KubernetesVersion.V1_32,\n  vpc,\n  vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }],\n});\n```\n\n----------------------------------------\n\nTITLE: Clearing and Normalizing Headers with AxiosHeaders - TypeScript\nDESCRIPTION: Shows how to use clear and normalize methods on AxiosHeaders to manage and deduplicate HTTP headers with pattern matching. Demonstrates resetting header states, normalizing and formatting header names, and combining duplicates. Requires AxiosHeaders and input objects with possible duplicate or patterned keys. Outputs demonstrate the effect of normalization and clearing operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nconst headers = new AxiosHeaders({\n  'foo': '1',\n  'x-foo': '2',\n  'x-bar': '3',\n});\n\nconsole.log(headers.clear(/^x-/)); // true\n\nconsole.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }\n```\n\n----------------------------------------\n\nTITLE: Watching and Compiling TypeScript App - Shell Commands\nDESCRIPTION: These commands are used to watch and compile the sample TypeScript application into JavaScript, either using Yarn or the TypeScript compiler directly in watch mode. The prerequisites are that TypeScript is installed via yarn or npm, and the script is run from the appropriate directory. The result is that any changes to sample.ts are recompiled to sample.js in real time.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_19\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/@aws-cdk-testing/framework-integ\n$ yarn watch\nor\n$ npx tsc --watch\n```\n\n----------------------------------------\n\nTITLE: AWS CDK: Using Declare for Compilation-Only Variables - Typescript\nDESCRIPTION: This Typescript snippet exemplifies usage of the 'declare' keyword for variables needed for successful TypeScript compilation but not essential for demonstrating example intent. It's commonly used in AWS CDK documentation to ensure code snippets compile. No external dependencies are needed; suitable for docs and sample code.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\n// An example about adding a stage to a pipeline in the aws-cdk-lib/pipelines library\\ndeclare const pipeline: pipelines.CodePipeline;\\ndeclare const myStage: Stage;\\npipeline.addStage(myStage);\n```\n\n----------------------------------------\n\nTITLE: Implementing Construct Namespacing in TypeScript\nDESCRIPTION: Example showing how to create separate construct namespaces for private and public subnets using the Construct class. This pattern helps maintain unique logical IDs without concatenation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst privateSubnets = new Construct(this, 'PrivateSubnets');\nconst publicSubnets = new Construct(this, 'PublishSubnets');\n\nfor (const az of availabilityZones) {\n  new Subnet(privateSubnets, az);\n  new Subnet(publicSubnets, az, { public: true });\n}\n```\n\n----------------------------------------\n\nTITLE: MIME Type Lookup Examples\nDESCRIPTION: Examples showing how to lookup content-types for different file extensions and paths\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmime.lookup('json') // 'application/json'\nmime.lookup('.md') // 'text/markdown'\nmime.lookup('file.html') // 'text/html'\nmime.lookup('folder/file.js') // 'application/javascript'\nmime.lookup('folder/.htaccess') // false\n\nmime.lookup('cats') // false\n```\n\n----------------------------------------\n\nTITLE: Submitting Form Data with node-fetch - JavaScript\nDESCRIPTION: This example shows how to use the 'node-fetch' library to submit form data using a FormData instance in Node.js. The snippet appends a field to a FormData object and sends it with a POST request. Dependencies include 'node-fetch' and the 'form-data' package; the response is parsed as JSON, and the result is printed to the console.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar form = new FormData();\n\nform.append('a', 1);\n\nfetch('http://example.com', { method: 'POST', body: form })\n    .then(function(res) {\n        return res.json();\n    }).then(function(json) {\n        console.log(json);\n    });\n```\n\n----------------------------------------\n\nTITLE: Applying Permissions Boundary to All IAM Roles in a Stage - TypeScript\nDESCRIPTION: Explains how to set up a permissions boundary on every IAM role or user created within a specific AWS CDK Stage by passing the permissionsBoundary prop to the Stage constructor. This example uses PermissionsBoundary.fromName and a Qualifier string for the policy name. Requires aws-cdk-lib, knowledge of Stages, and valid boundary policy creation.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/README.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nconst prodStage = new Stage(app, 'ProdStage', {\n  permissionsBoundary: PermissionsBoundary.fromName('cdk-${Qualifier}-PermissionsBoundary'),\n});\n```\n\n----------------------------------------\n\nTITLE: Cancelling Axios Requests with CancelToken Constructor (Deprecated)\nDESCRIPTION: Illustrates another deprecated method for request cancellation using the `CancelToken` constructor directly. An executor function is passed to the constructor, which receives a `cancel` function as an argument. This `cancel` function is stored and can be called later to cancel the associated Axios request.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    // An executor function receives a cancel function as a parameter\n    cancel = c;\n  })\n});\n\n// cancel the request\ncancel();\n```\n\n----------------------------------------\n\nTITLE: Text Input Transformation for EventBridge Pipe\nDESCRIPTION: Shows how to create a static text transformation for pipe events.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-pipes-alpha/README.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const sourceQueue: sqs.Queue;\ndeclare const targetQueue: sqs.Queue;\n\nconst targetInputTransformation = pipes.InputTransformation.fromText('My static text');\n\nconst pipe = new pipes.Pipe(this, 'Pipe', {\n  source: new SqsSource(sourceQueue),\n  target: new SqsTarget(targetQueue, {\n    inputTransformation: targetInputTransformation, \n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Input Type Coercion Difference in SDKv2 (TypeScript)\nDESCRIPTION: This snippet shows how SDKv2 silently converts string values to numbers for certain parameters, allowing the API call to succeed even with mismatched types.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-custom-resource-sdk-adapter/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst codedeploy = new AWS.CodeDeploy({ region: 'eu-west-1' });\n\nconst input: AWS.CodeDeploy.CreateDeploymentConfigInput = {\n  deploymentConfigName: 'testtest',\n  computePlatform: 'Lambda',\n  trafficRoutingConfig: {\n      type: \"TimeBasedLinear\",\n      timeBasedLinear: {\n      linearInterval: \"1\" as any, // The type says 'number' but we're forcing strings here\n      linearPercentage:\"5\" as any,\n    },\n  },\n};\n\n// Following call happily succeeds\nconsole.log(await codedeploy.createDeploymentConfig(input).promise());\n```\n\n----------------------------------------\n\nTITLE: Configuring Canary Schedule with Cron in AWS CDK (TypeScript)\nDESCRIPTION: Demonstrates how to configure a Synthetics Canary to run based on a cron expression using `synthetics.Schedule.cron`. This example sets the canary to run at 12am, 8am, and 4pm UTC every day. This is used within the `schedule` property of the `synthetics.Canary` construct.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst schedule = synthetics.Schedule.cron({\n  hour: '0,8,16', // Run at 12am, 8am, 4pm UTC every day\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Test Header in Markdown\nDESCRIPTION: Simple markdown heading using '#' syntax for level 1 heading.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-codecommit/test/asset-test/test.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Test\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Delay Module\nDESCRIPTION: Demonstrates basic usage of the delay module to pause execution for 100 milliseconds between function calls.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\n(async () => {\n\tbar();\n\n\tawait delay(100);\n\n\t// Executed 100 milliseconds later\n\tbaz();\n})();\n```\n\n----------------------------------------\n\nTITLE: Accessing mime-db database JSON via CDN (URL)\nDESCRIPTION: This URL provides direct access to the raw `db.json` file hosted on the jsDelivr CDN, fetched directly from the `mime-db` GitHub repository. It's intended for direct use, potentially in browser environments, although using a specific release tag instead of `master` is recommended for stability.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-db/README.md#2025-04-23_snippet_1\n\nLANGUAGE: url\nCODE:\n```\nhttps://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json\n```\n\n----------------------------------------\n\nTITLE: Defining Standard `grant` Method in AWS CDK TypeScript\nDESCRIPTION: Shows the signature for the mandatory `grant` method required on resource interfaces (defined in `IResource`). This method takes an `iam.IGrantable` (the principal receiving permissions) and a variable number of action strings, applies the necessary IAM policy statements, and returns an `iam.Grant` object representing the permission grant.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ngrant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n```\n```\n\n----------------------------------------\n\nTITLE: Running Module-wide Commands with foreach.sh - Console Command - Bash\nDESCRIPTION: This bash snippet demonstrates how to invoke the 'foreach.sh' script with a generic command across all AWS CDK repository modules in dependency order. The script operates on the directory of each module in turn. Prerequisites include the existence of the 'scripts/foreach.sh' script and all modules properly bootstrapped.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\n$ scripts/foreach.sh COMMAND\n```\n\n----------------------------------------\n\nTITLE: Asserting Stack Tags in AWS CDK Template Testing\nDESCRIPTION: Shows how to use the Tags class to assert the presence and values of tags applied to CDK stacks, including support for various Matchers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/assertions/README.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst tags = Tags.fromStack(stack);\n\n// using a default 'objectLike' Matcher\ntags.hasValues({\n  'tag-name': 'tag-value',\n});\n\n// ... with Matchers embedded\ntags.hasValues({\n  'tag-name': Match.stringLikeRegexp('value'),\n});\n\n// or another object Matcher at the top level\ntags.hasValues(Match.objectEquals({\n  'tag-name': Match.anyValue(),\n}));\n\n// no tags present\nTags.fromStack(stack).hasNone();\n\n// don't use absent() at the top level, it won't work\nexpect(() => { Tags.fromStack(stack).hasValues(Match.absent()); }).toThrow(/will never match/i);\n```\n\n----------------------------------------\n\nTITLE: Configuring Provider URLs with CDK Tokens\nDESCRIPTION: Shows how to configure role mappings with CDK Tokens and mapping keys for Cognito User Pools.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito-identitypool/README.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UserPool, UserPoolClient } from 'aws-cdk-lib/aws-cognito';\nimport { IdentityPoolProviderUrl } from 'aws-cdk-lib/aws-cognito-identitypool';\n\ndeclare const userPool: UserPool;\ndeclare const userPoolClient: UserPoolClient;\nnew IdentityPool(this, 'myidentitypool', {\n  identityPoolName: 'myidentitypool',\n  roleMappings: [{\n    mappingKey: 'cognito',\n    providerUrl: IdentityPoolProviderUrl.userPool(userPool, userPoolClient),\n    useToken: true,\n  }],\n});\n```\n\n----------------------------------------\n\nTITLE: Building Specific AWS CDK Package\nDESCRIPTION: Command to build a specific package (aws-cdk-lib) and its dependencies using Lerna. This is useful when working on changes that only affect a single package.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ npx lerna run build --scope=aws-cdk-lib\n```\n\n----------------------------------------\n\nTITLE: Running All Integration Tests for a Module - Shell Commands\nDESCRIPTION: These commands run all integration tests in a given directory, specifically for aws-eks, using Yarn from the framework-integ root. All dependencies must be installed and directory paths must be valid. Outputs are the results of the integration test suite.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_25\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/@aws-cdk-testing/framework-integ\n$ yarn integ --directory test/aws-eks/test\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing WebSocket API in TypeScript (CDK)\nDESCRIPTION: This snippet demonstrates how to reference an existing WebSocket API within a CDK application using its ID. The `WebSocketApi.fromWebSocketApiAttributes` static method is used to import the API based on its `webSocketId`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst webSocketApi = apigwv2.WebSocketApi.fromWebSocketApiAttributes(this, 'mywsapi', { webSocketId: 'api-1234' });\n```\n```\n\n----------------------------------------\n\nTITLE: Locking Python Package Versions for AWS CDK Lambda\nDESCRIPTION: Defines exact versions of Python packages required for a Lambda function, including requests and its dependencies (certifi, chardet, idna, urllib3). The version pinning ensures consistent behavior across deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/test/lambda-handler-custom-build/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Lock versions of pip packages\ncertifi==2024.7.4\nchardet==3.0.4\nidna==3.7\nurllib3==1.26.19\n# Requests used by this lambda\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Disabling Application Manager URL Output in ApplicationAssociator\nDESCRIPTION: Shows how to create an ApplicationAssociator with the Application Manager console URL output disabled. By default, this URL is included as a stack output.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-servicecatalogappregistry-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new App();\nconst associatedApp = new appreg.ApplicationAssociator(app, 'AssociatedApplication', {\n  applications: [appreg.TargetApplication.createApplicationStack({\n    applicationName: 'MyAssociatedApplication',\n    // 'Application containing stacks deployed via CDK.' is the default\n    applicationDescription: 'Associated Application description',\n    stackName: 'MyAssociatedApplicationStack',\n    // Disables emitting Application Manager url as output\n    emitApplicationManagerUrlAsOutput: false,\n    // AWS Account and Region that are implied by the current CLI configuration is the default\n    env: { account: '123456789012', region: 'us-east-1' },\n  })],\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Domain URL with Mapping Key\nDESCRIPTION: Shows how to retrieve the complete domain URL including the mapping key for an API stage.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2/README.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const apiDemo: apigwv2.HttpApi;\nconst demoDomainUrl = apiDemo.defaultStage?.domainUrl;\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Unit Test using Jest - Shell Commands\nDESCRIPTION: This set of commands uses Jest via npx to run a targeted unit test for aws-eks. The command should be executed from the aws-cdk-lib directory, and the test path must be valid. Outputs are the test results for the specific file.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_24\n\nLANGUAGE: console\nCODE:\n```\n$ cd packages/aws-cdk-lib\n$ npx jest aws-eks/test/name.test.js\n```\n\n----------------------------------------\n\nTITLE: Cross-Account ECS Service Deployment\nDESCRIPTION: Sets up ECS deployment to an existing service in a different account using the service ARN format. Shows configuration for cross-account deployment scenarios.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-codepipeline-actions/README.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\n\nconst service = ecs.BaseService.fromServiceArnWithCluster(this, 'EcsService',\n  'arn:aws:ecs:us-east-1:123456789012:service/myClusterName/myServiceName'\n);\nconst pipeline = new codepipeline.Pipeline(this, 'MyPipeline');\nconst buildOutput = new codepipeline.Artifact();\n// add source and build stages to the pipeline as usual...\nconst deployStage = pipeline.addStage({\n  stageName: 'Deploy',\n  actions: [\n    new codepipeline_actions.EcsDeployAction({\n      actionName: 'DeployAction',\n      service: service,\n      input: buildOutput,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Staging Resources Factory in TypeScript\nDESCRIPTION: Shows how to implement a custom IStagingResourcesFactory and use it with AppStagingSynthesizer.customFactory() to provide a custom staging stack for each environment.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/app-staging-synthesizer-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nclass CustomFactory implements IStagingResourcesFactory {\n  public obtainStagingResources(stack: Stack, context: ObtainStagingResourcesContext) {\n    const myApp = App.of(stack);\n\n    return new CustomStagingStack(myApp!, `CustomStagingStack-${context.environmentString}`, {});\n  }\n}\n\nconst app = new App({\n  defaultStackSynthesizer: AppStagingSynthesizer.customFactory({\n    factory: new CustomFactory(),\n    oncePerEnv: true, // by default\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating AppConfig Sourced Configuration from CodePipeline using AWS CDK in TypeScript\nDESCRIPTION: This snippet illustrates creating an AWS AppConfig `SourcedConfiguration` using an artifact from an AWS CodePipeline pipeline as the configuration source. It requires instances of `appconfig.Application` and `codepipeline.Pipeline`. The location is defined using `appconfig.ConfigurationSource.fromPipeline()`.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-appconfig/README.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ndeclare const application: appconfig.Application;\ndeclare const pipeline: codepipeline.Pipeline;\n\nnew appconfig.SourcedConfiguration(this, 'MySourcedConfiguration', {\n  application,\n  location: appconfig.ConfigurationSource.fromPipeline(pipeline),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Using the Extended CDK Bootstrap Command with Trust Relationships\nDESCRIPTION: Example of using the enhanced bootstrap command with the new --trust flag for specifying trusted AWS account IDs and the --cloudformation-execution-policies flag for specifying managed policy ARNs to attach to the CloudFormation Execution Role.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/cdk-bootstrap.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cdk bootstrap \\\n    [--trust accountId[,otherAccountId]...] \\\n    [--cloudformation-execution-policies policyArn[,otherPolicyArn]...] \\\n    aws://account/region\n```\n\n----------------------------------------\n\nTITLE: Importing Amazon GuardDuty Constructs - AWS CDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the Amazon GuardDuty module in a TypeScript AWS CDK application. By importing 'aws-cdk-lib/aws-guardduty', users can access the automatically generated L1 constructs for GuardDuty resources. There are no L2 (handwritten) constructs yet, so users should use the L1 constructs in accordance with CloudFormation resource documentation. The import is essential when defining GuardDuty resources or integrating GuardDuty in CDK stacks.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-guardduty/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as guardduty from 'aws-cdk-lib/aws-guardduty';\n```\n\n----------------------------------------\n\nTITLE: Creating AWS EKS auth ConfigMap in YAML\nDESCRIPTION: YAML definition for an aws-auth ConfigMap that enables worker nodes to join the EKS cluster. The ConfigMap maps IAM roles to Kubernetes users and groups for authorization.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/test/MANUAL_TEST.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aws-auth\n  namespace: kube-system\ndata:\n  mapRoles: |\n    - rolearn: <ROLE ARN>\n      username: system:node:{{EC2PrivateDNSName}}\n      groups:\n        - system:bootstrappers\n        - system:nodes\n```\n\n----------------------------------------\n\nTITLE: Testing Lambda Function with Event Sources in TypeScript\nDESCRIPTION: An example showing how to test Lambda event source configuration in a dedicated test. This isolates event handling functionality for focused testing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'Handler', {\n  events,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring EKS Cluster Logging in TypeScript\nDESCRIPTION: This snippet shows how to enable different types of cluster logging for an EKS cluster. It demonstrates using the clusterLogging property to enable API, Authenticator, and Scheduler logs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-eks-v2-alpha/README.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nconst cluster = new eks.Cluster(this, 'Cluster', {\n  // ...\n  version: eks.KubernetesVersion.V1_32,\n  clusterLogging: [\n    eks.ClusterLoggingTypes.API,\n    eks.ClusterLoggingTypes.AUTHENTICATOR,\n    eks.ClusterLoggingTypes.SCHEDULER,\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AWS Comprehend in TypeScript for AWS CDK\nDESCRIPTION: Demonstrates how to import the AWS Comprehend module in a CDK application. This is the basic import statement needed to start using Comprehend resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-comprehend/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as comprehend from 'aws-cdk-lib/aws-comprehend';\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Docker Image for Go Function Bundling\nDESCRIPTION: Demonstrates how to use a custom Docker image for bundling a Go function instead of the default Lambda-compatible image. This allows for specialized build environments with custom dependencies.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-go-alpha/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew go.GoFunction(this, 'handler', {\n  entry: 'app/cmd/api',\n  bundling: {\n    dockerImage: DockerImage.fromBuild('/path/to/Dockerfile'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Point-in-Time Recovery with TableV2 in TypeScript\nDESCRIPTION: This snippet demonstrates how to enable point-in-time recovery for a DynamoDB table using the TableV2 construct, including setting a custom recovery period.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-dynamodb/README.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = new dynamodb.TableV2(this, 'Table', {\n  partitionKey: { name: 'pk', type: dynamodb.AttributeType.STRING },\n  pointInTimeRecoverySpecification: {\n    pointInTimeRecoveryEnabled: true,\n    recoveryPeriodInDays: 4,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Breaking Changes Documentation Format\nDESCRIPTION: Template for documenting breaking changes in pull requests. Breaking changes must be listed before the separator and follow a specific format to be included in the CHANGELOG.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_27\n\nLANGUAGE: markdown\nCODE:\n```\nBREAKING CHANGE: Description of what broke and how to achieve this behavior now\n* **module-name:** Another breaking change\n* **module-name:** Yet another breaking change\n\n---\n\n*By submitting this pull request, I confirm that my contribution is made under the terms of the Apache-2.0 license*\n\n---\n```\n\n----------------------------------------\n\nTITLE: Referencing AWS CDK Bootstrap Template in YAML\nDESCRIPTION: This snippet points to the location of the AWS CDK bootstrap template used by the CLI command. The template is crucial for setting up the initial AWS environment for CDK deployments.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/design/cdk-bootstrap.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# The bootstrap template used by the CLI command can be found in the\n# [`aws-cdk-cli` package](https://github.com/aws/aws-cdk-cli/blob/main/packages/aws-cdk/lib/api/bootstrap/bootstrap-template.yaml).\n```\n\n----------------------------------------\n\nTITLE: Folder Structure for Python Scripts in AWS Synthetics\nDESCRIPTION: Shows the required folder structure for Python scripts when supplying code via fromAsset() or fromBucket(). The canary expects Python files to be placed in a specific directory.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-synthetics/README.md#2025-04-23_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\ncanary/\n python/\n     <filename>.py\n```\n\n----------------------------------------\n\nTITLE: Importing RedshiftServerless Module in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the RedshiftServerless module from the AWS CDK library in a TypeScript project. It allows access to RedshiftServerless constructs and resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-redshiftserverless/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as redshiftserverless from 'aws-cdk-lib/aws-redshiftserverless';\n```\n\n----------------------------------------\n\nTITLE: Creating Python Shell Job with Required Parameters in AWS CDK\nDESCRIPTION: Demonstrates how to create a basic Python Shell Job in AWS Glue with only the required parameters - role and script.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-glue-alpha/README.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as cdk from 'aws-cdk-lib';\nimport * as iam from 'aws-cdk-lib/aws-iam';\ndeclare const stack: cdk.Stack;\ndeclare const role: iam.IRole;\ndeclare const script: glue.Code;\nnew glue.PythonShellJob(stack, 'ImportedJob', { role, script });\n```\n\n----------------------------------------\n\nTITLE: Granting IAM Permissions to User Pool in TypeScript\nDESCRIPTION: This code shows how to grant specific IAM permissions to a role for interacting with a Cognito User Pool using the CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cognito/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst userPool = new cognito.UserPool(this, 'myuserpool');\nconst role = new iam.Role(this, 'role', {\n  assumedBy: new iam.ServicePrincipal('foo'),\n});\nuserPool.grant(role, 'cognito-idp:AdminCreateUser');\n```\n\n----------------------------------------\n\nTITLE: Exporting GitHub Token for Automation Setup in Bash\nDESCRIPTION: Sets the GitHub token as an environment variable to authorize API requests. The token needs 'read:org' and 'project' scopes for accessing project data.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/scripts/prioritization/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport GH_TOKEN=\"YOUR GITHUB TOKEN\"\n```\n\n----------------------------------------\n\nTITLE: Content-Type Header Creation Examples\nDESCRIPTION: Examples demonstrating how to create full content-type headers with charset parameters\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmime.contentType('markdown') // 'text/x-markdown; charset=utf-8'\nmime.contentType('file.json') // 'application/json; charset=utf-8'\nmime.contentType('text/html') // 'text/html; charset=utf-8'\nmime.contentType('text/html; charset=iso-8859-1') // 'text/html; charset=iso-8859-1'\n\n// from a full path\nmime.contentType(path.extname('/path/to/file.json')) // 'application/json; charset=utf-8'\n```\n\n----------------------------------------\n\nTITLE: Defining a Python Lambda Function in AWS CDK\nDESCRIPTION: Creates a new Python Lambda function with specified entry point, runtime, and optional index and handler parameters.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnew python.PythonFunction(this, 'MyFunction', {\n  entry: '/path/to/my/function', // required\n  runtime: Runtime.PYTHON_3_8, // required\n  index: 'my_index.py', // optional, defaults to 'index.py'\n  handler: 'my_exported_func', // optional, defaults to 'handler'\n});\n```\n\n----------------------------------------\n\nTITLE: HTTPS Request with Response URL Inspection\nDESCRIPTION: Shows how to make an HTTPS request and inspect the final redirected URL using the responseUrl property.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst request = https.request({\n  host: 'bitly.com',\n  path: '/UHfDGO',\n}, response => {\n  console.log(response.responseUrl);\n  // 'http://duckduckgo.com/robots.txt'\n});\nrequest.end();\n```\n\n----------------------------------------\n\nTITLE: Importing AWS IoTFleetHub Module using AWS CDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the 'aws-iotfleethub' module from the AWS CDK library in a TypeScript project. This import statement is required when defining or referencing AWS IoTFleetHub resources using the AWS Cloud Development Kit. It assumes that the 'aws-cdk-lib' package is installed as a dependency and that your TypeScript project is configured to use the AWS CDK. No parameters are required for this import; it simply brings all exported features of the module into the local namespace.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-iotfleethub/README.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as iotfleethub from 'aws-cdk-lib/aws-iotfleethub';\n```\n\n----------------------------------------\n\nTITLE: Testing Lambda Function with Filesystem Configuration in TypeScript\nDESCRIPTION: An example showing how to test Lambda filesystem integration in a dedicated test. This approach isolates specific functionality that warrants separate testing.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/INTEGRATION_TESTS.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew lambda.Function(this, 'Handler', {\n  filesystem,\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Delay Instance Creation\nDESCRIPTION: Shows how to create a custom delay instance with specific timer functions, useful when working with timer stubbing libraries.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\nconst customDelay = delay.createWithTimers({clearTimeout, setTimeout});\n\n(async() => {\n\tconst result = await customDelay(100, {value: ''});\n\n\t// Executed after 100 milliseconds\n\tconsole.log(result);\n\t//=> ''\n})();\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependency for AWS CDK Project\nDESCRIPTION: Defines the required Python package dependency for an AWS CDK project. It specifies the requests library version 2.32.0, which is a popular HTTP library for making API requests in Python.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lambda/test/python-lambda-handler/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nrequests==2.32.0\n```\n\n----------------------------------------\n\nTITLE: Legacy OAI Configuration for S3 Origin\nDESCRIPTION: Shows the deprecated setup using S3Origin with Origin Access Identity (OAI)\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-cloudfront-origins/README.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst myBucket = new s3.Bucket(this, 'myBucket');\nconst s3Origin = new origins.S3Origin(myBucket);\nconst distribution = new cloudfront.Distribution(this, 'myDist', {\n  defaultBehavior: { origin: s3Origin },\n});\n```\n\n----------------------------------------\n\nTITLE: Per-Request Options Configuration\nDESCRIPTION: Demonstrates setting per-request options including custom redirect handling and authentication logic.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst url = require('url');\nconst { http, https } = require('follow-redirects');\n\nconst options = url.parse('http://bit.ly/900913');\noptions.maxRedirects = 10;\noptions.beforeRedirect = (options, response, request) => {\n  if (options.hostname === \"example.com\") {\n    options.auth = \"user:password\";\n  }\n};\nhttp.request(options);\n```\n\n----------------------------------------\n\nTITLE: Deprecated NetworkLoadBalancer and NetworkTargetGroup Methods in AWS CDK\nDESCRIPTION: The NetworkLoadBalancer.metricUnHealthyHostCount() and NetworkTargetGroup.import() methods are deprecated. Use NetworkTargetGroup.metricUnHealthyHostCount and fromTargetGroupAttributes instead.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nNetworkLoadBalancer.metricUnHealthyHostCount() // Deprecated\nNetworkTargetGroup.metricUnHealthyHostCount() // Use this instead\n\nNetworkTargetGroup.import() // Deprecated\nNetworkTargetGroup.fromTargetGroupAttributes() // Use this instead\n```\n\n----------------------------------------\n\nTITLE: Configuring Connections for Redshift Cluster in TypeScript\nDESCRIPTION: This snippet demonstrates how to configure connections for a Redshift cluster by allowing access from any IPv4 address on the default port.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-redshift-alpha/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncluster.connections.allowDefaultPortFromAnyIpv4('Open to the world');\n```\n\n----------------------------------------\n\nTITLE: Importing RolesAnywhere Module in TypeScript\nDESCRIPTION: Example showing how to import the AWS RolesAnywhere module in a CDK application. This import statement provides access to L1 constructs for working with RolesAnywhere resources.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-rolesanywhere/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as rolesanywhere from 'aws-cdk-lib/aws-rolesanywhere';\n```\n\n----------------------------------------\n\nTITLE: Lazy Stream Loading with Callbacks\nDESCRIPTION: Demonstrates how to add streams using callbacks for lazy loading and resource management\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/combined-stream/Readme.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar CombinedStream = require('combined-stream');\nvar fs = require('fs');\n\nvar combinedStream = CombinedStream.create();\ncombinedStream.append(function(next) {\n  next(fs.createReadStream('file1.txt'));\n});\ncombinedStream.append(function(next) {\n  next(fs.createReadStream('file2.txt'));\n});\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'));\n```\n\n----------------------------------------\n\nTITLE: Delay with Abort Signal\nDESCRIPTION: Demonstrates how to abort a delay using AbortController and AbortSignal.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\n(async () => {\n\tconst abortController = new AbortController();\n\n\tsetTimeout(() => {\n\t\tabortController.abort();\n\t}, 500);\n\n\ttry {\n\t\tawait delay(1000, {signal: abortController.signal});\n\t} catch (error) {\n\t\t// 500 milliseconds later\n\t\tconsole.log(error.name)\n\t\t//=> 'AbortError'\n\t}\n})();\n```\n\n----------------------------------------\n\nTITLE: Setting Global Options for Follow Redirects\nDESCRIPTION: Example of setting global configuration options like maxRedirects and maxBodyLength for all requests.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/follow-redirects/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst followRedirects = require('follow-redirects');\nfollowRedirects.maxRedirects = 10;\nfollowRedirects.maxBodyLength = 20 * 1024 * 1024; // 20 MB\n```\n\n----------------------------------------\n\nTITLE: API Gateway Domain Configuration\nDESCRIPTION: CloudFormation resource properties for configuring API Gateway domain names including SSL certificates and endpoint types.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/deprecated_apis.txt#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface DomainNameConfigurationProperty {\n  readonly certificateArn?: string;\n  readonly certificateName?: string;\n  readonly endpointType?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AWS AppTest Module in AWS CDK TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to import the `aws-apptest` module from the `aws-cdk-lib`. This import is the first step required to use the L1 CloudFormation constructs for AWS AppTest within an AWS CDK application.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apptest/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as apptest from 'aws-cdk-lib/aws-apptest';\n```\n\n----------------------------------------\n\nTITLE: Updating WindowsBuildImage in AWS CodeBuild\nDESCRIPTION: Replace deprecated Windows Server Core 2016 base image with WINDOWS_BASE_2_0.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/DEPRECATED_APIs.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Old (deprecated)\nWindowsBuildImage.WIN_SERVER_CORE_2016_BASE\n\n// New\nWindowsBuildImage.WINDOWS_BASE_2_0\n```\n\n----------------------------------------\n\nTITLE: Early Delay Settlement\nDESCRIPTION: Shows how to clear a delay early using the .clear() method.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.latest.js.snapshot/asset.2729d9b4af60cbbbe3182f0002dec1747647eedd8de3761325aa38f7ddf73f24/node_modules/delay/readme.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst delay = require('delay');\n\n(async () => {\n\tconst delayedPromise = delay(1000, {value: 'Done'});\n\n\tsetTimeout(() => {\n\t\tdelayedPromise.clear();\n\t}, 500);\n\n\t// 500 milliseconds later\n\tconsole.log(await delayedPromise);\n\t//=> 'Done'\n})();\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS LookoutVision Module in TypeScript\nDESCRIPTION: Shows how to import the AWS LookoutVision module in a CDK project. This is the basic import statement needed before using any LookoutVision constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-lookoutvision/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as lookoutvision from 'aws-cdk-lib/aws-lookoutvision';\n```\n\n----------------------------------------\n\nTITLE: Example Badge Markdown\nDESCRIPTION: Markdown code showing the stability badge implementation for experimental CDK constructs.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/example-construct-library/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n![cdk-constructs: Experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)\n```\n\n----------------------------------------\n\nTITLE: Importing AppRunner Module in TypeScript\nDESCRIPTION: Basic import statement for the AWS AppRunner alpha module in CDK.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-apprunner-alpha/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as apprunner from '@aws-cdk/aws-apprunner-alpha';\n```\n\n----------------------------------------\n\nTITLE: Type Change Example in Manifest Load\nDESCRIPTION: Example showing how adding artifact types breaks the load() type signature due to union type expansion\nSOURCE: https://github.com/aws/aws-cdk/blob/main/allowed-breaking-changes.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst x: A | B = Manifest.load();\n```\n\n----------------------------------------\n\nTITLE: MIME Charset Lookup Example\nDESCRIPTION: Example demonstrating how to lookup the default charset for a content-type\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nmime.charset('text/markdown') // 'UTF-8'\n```\n\n----------------------------------------\n\nTITLE: Installing MIME Types Module via NPM\nDESCRIPTION: Command to install the mime-types package using npm package manager\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/mime-types/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install mime-types\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Integration Test - Shell Command\nDESCRIPTION: This shell command runs a single, specified integration test using Yarn from the framework-integ directory. Requires that the specified .js test file exists and all dependencies are available. Outputs a result for only that individual test case.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_26\n\nLANGUAGE: console\nCODE:\n```\n$ yarn integ test/aws-eks/test/integ.name.js\n```\n\n----------------------------------------\n\nTITLE: Asset Comment Line in JavaScript\nDESCRIPTION: A basic single line comment indicating asset-related content.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-s3-assets/test/integ.assets.refs.lit.js.snapshot/asset.6b84b87243a4a01c592d78e1fd3855c4bfef39328cd0a450cc97e81717fea2a2/sample-asset-file.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// hello dear asset\n```\n\n----------------------------------------\n\nTITLE: Building AWS CDK Repository\nDESCRIPTION: Command to build the entire AWS CDK repository using Lerna. This process may take some time as it builds all modules in the monorepo.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ npx lerna run build --skip-nx-cache\n```\n\n----------------------------------------\n\nTITLE: Custom FormData Serialization in Axios (Node.js)\nDESCRIPTION: Shows how to use a custom FormData implementation in Node.js with Axios, allowing for more complex data structures including Buffers.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\nvar FormData = require('form-data');\n\naxios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {\n  headers: {\n    'Content-Type': 'multipart/form-data'\n  }\n}).then(({data}) => console.log(data));\n```\n\n----------------------------------------\n\nTITLE: Sending URL-Encoded Data with Node.js querystring Module\nDESCRIPTION: Demonstrates sending `application/x-www-form-urlencoded` data specifically in older Node.js environments using the built-in `querystring` module. The `querystring.stringify()` method encodes the data object for the POST request. Note that `qs` is generally preferred for nested objects.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/axios/README.md#2025-04-23_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nconst querystring = require('querystring');\naxios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));\n```\n\n----------------------------------------\n\nTITLE: Configuring AssumeRole Policy for SNS Service Role\nDESCRIPTION: Defines the trust relationship for an SNS service role. The policy permits the SNS service to assume this role for executing SNS-related operations.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-iam/test/integ.customize-roles-restapi.js.snapshot/iam-policy-report.txt#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Action\": \"sts:AssumeRole\",\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"Service\": \"sns.amazonaws.com\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Installing Form-Data Package\nDESCRIPTION: Command to install the form-data package via npm\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/form-data/Readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save form-data\n```\n\n----------------------------------------\n\nTITLE: Manual Stream Event Release\nDESCRIPTION: Example demonstrating how to manually release buffered events using resume() method instead of pipe(). This approach gives more control over when buffered events are emitted.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk-testing/framework-integ/test/aws-lambda-nodejs/test/integ.dependencies-pnpm.js.snapshot/asset.78d43382e519a4bce684a187408c96399e462c8a1ac7dfb615458896dd6918ed/node_modules/delayed-stream/Readme.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar delayed = DelayedStream.create(req);\n\nsetTimeout(function() {\n  // Emit all buffered events and resume underlaying source\n  delayed.resume();\n}, 1000);\n```\n\n----------------------------------------\n\nTITLE: Error Message for Finch Directory Access\nDESCRIPTION: Example error message when Finch temporary directory is not properly mapped in the VM configuration.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\nlstat /private/var/folders/zx/d5wln9n10sn0tcj1v9798f1c0000gr/T/jsii-kernel-9VYgrO/node_modules/@aws-cdk/aws-lambda-python-alpha/lib/Containerfile: no such file or directory\n```\n\n----------------------------------------\n\nTITLE: Finch Configuration for Directory Mapping\nDESCRIPTION: YAML configuration to add additional directory mappings to Finch VM for temporary directory access.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/README.md#2025-04-23_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nadditional_directories:\n  - path: /private/var/folders/\n  - path: /var/folders/\n```\n\n----------------------------------------\n\nTITLE: Pinning Python Package Versions for AWS Lambda Function\nDESCRIPTION: Defines exact versions of HTTP-related Python packages to ensure consistent dependency resolution for a Lambda function. The packages listed (certifi, chardet, idna, urllib3) are common dependencies for the 'requests' library, which is noted as being used by the Lambda function.\nSOURCE: https://github.com/aws/aws-cdk/blob/main/packages/@aws-cdk/aws-lambda-python-alpha/test/lambda-handler-project/shared/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Lock versions of pip packages\ncertifi==2024.7.4\nchardet==3.0.4\nidna==3.7\nurllib3==1.26.19\n# Requests used by this lambda\n```"
  }
]