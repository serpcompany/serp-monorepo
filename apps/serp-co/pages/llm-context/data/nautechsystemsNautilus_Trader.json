[
  {
    "owner": "nautechsystems",
    "repo": "nautilus_trader",
    "content": "TITLE: Order State Queries using Cache - Python\nDESCRIPTION: This snippet demonstrates how to query order states using the Nautilus Trader `Cache`.  It shows how to retrieve orders based on their current state (open, closed, emulated, inflight) and check the state of a specific order by its client order ID.  `client_order_id` must be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Get orders by their current state\nopen_orders = self.cache.orders_open()          # Orders currently active at the venue\nclosed_orders = self.cache.orders_closed()      # Orders that have completed their lifecycle\nemulated_orders = self.cache.orders_emulated()  # Orders being simulated locally by the system\ninflight_orders = self.cache.orders_inflight()  # Orders submitted (or modified) to venue, but not yet confirmed\n\n# Check specific order states\nexists = self.cache.order_exists(client_order_id)            # Checks if an order with the given ID exists in the cache\nis_open = self.cache.is_order_open(client_order_id)          # Checks if an order is currently open\nis_closed = self.cache.is_order_closed(client_order_id)      # Checks if an order is closed\nis_emulated = self.cache.is_order_emulated(client_order_id)  # Checks if an order is being simulated locally\nis_inflight = self.cache.is_order_inflight(client_order_id)  # Checks if an order is submitted or modified, but not yet confirmed\n```\n\n----------------------------------------\n\nTITLE: Defining Custom GreeksData Class in Python\nDESCRIPTION: This code defines a custom data class, `GreeksData`, inheriting from `nautilus_trader.core.Data`.  It includes methods for serialization (to/from dict/bytes), catalog integration (to/from pyarrow), and schema definition.  The class also includes properties for accessing timestamps and implements a custom `__repr__` method.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\nfrom nautilus_trader.core import Data\nfrom nautilus_trader.core.datetime import unix_nanos_to_iso8601\nfrom nautilus_trader.model import DataType\nfrom nautilus_trader.serialization.base import register_serializable_type\nfrom nautilus_trader.serialization.arrow.serializer import register_arrow\nimport pyarrow as pa\n\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos, unix_nanos_to_dt, format_iso8601\n\n\nclass GreeksData(Data):\n    def __init__(\n        self, instrument_id: InstrumentId = InstrumentId.from_str(\"ES.GLBX\"),\n        ts_event: int = 0,\n        ts_init: int = 0,\n        delta: float = 0.0,\n    ) -> None:\n        self.instrument_id = instrument_id\n        self._ts_event = ts_event\n        self._ts_init = ts_init\n        self.delta = delta\n\n    def __repr__(self):\n        return (f\"GreeksData(ts_init={unix_nanos_to_iso8601(self._ts_init)}, instrument_id={self.instrument_id}, delta={self.delta:.2f})\")\n\n    @property\n    def ts_event(self):\n        return self._ts_event\n\n    @property\n    def ts_init(self):\n        return self._ts_init\n\n    def to_dict(self):\n        return {\n            \"instrument_id\": self.instrument_id.value,\n            \"ts_event\": self._ts_event,\n            \"ts_init\": self._ts_init,\n            \"delta\": self.delta,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        return GreeksData(InstrumentId.from_str(data[\"instrument_id\"]), data[\"ts_event\"], data[\"ts_init\"], data[\"delta\"])\n\n    def to_bytes(self):\n        return msgspec.msgpack.encode(self.to_dict())\n\n    @classmethod\n    def from_bytes(cls, data: bytes):\n        return cls.from_dict(msgspec.msgpack.decode(data))\n\n    def to_catalog(self):\n        return pa.RecordBatch.from_pylist([self.to_dict()], schema=GreeksData.schema())\n\n    @classmethod\n    def from_catalog(cls, table: pa.Table):\n        return [GreeksData.from_dict(d) for d in table.to_pylist()]\n\n    @classmethod\n    def schema(cls):\n        return pa.schema(\n            {\n                \"instrument_id\": pa.string(),\n                \"ts_event\": pa.int64(),\n                \"ts_init\": pa.int64(),\n                \"delta\": pa.float64(),\n            }\n        )\n```\n\n----------------------------------------\n\nTITLE: Creating a Trailing Stop Market Order in Python\nDESCRIPTION: This code snippet demonstrates how to create a Trailing-Stop-Market order using the Nautilus Trader framework. The order is placed on the Binance Futures exchange to sell 10 ETHUSD-PERP COIN_M margined Perpetual Futures Contracts. It triggers at a price of 5,000 USD and trails at an offset of 1% (in basis points) away from the current last traded price. Requires the nautilus_trader library.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nfrom decimal import Decimal\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model.enums import TrailingOffsetType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import TrailingStopMarketOrder\n\norder: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(\n    instrument_id=InstrumentId.from_str(\"ETHUSD-PERP.BINANCE\"),\n    order_side=OrderSide.SELL,\n    quantity=Quantity.from_int(10),\n    trigger_price=Price.from_str(\"5_000\"),\n    trigger_type=TriggerType.LAST_PRICE,  # <-- optional (default DEFAULT)\n    trailing_offset=Decimal(100),\n    trailing_offset_type=TrailingOffsetType.BASIS_POINTS,\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    expire_time=None,  # <-- optional (default None)\n    reduce_only=True,  # <-- optional (default False)\n    tags=[\"TRAILING_STOP-1\"],  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing the on_start Handler in Python\nDESCRIPTION: This code snippet shows a typical `on_start` handler method implementation within a Nautilus Trader strategy. It demonstrates registering indicators, requesting historical data, and subscribing to live data feeds. Crucial steps in setting up a strategy for live trading and backtesting.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\n    \"\"\"\n    Actions to be performed on strategy start.\n    \"\"\"\n    self.instrument = self.cache.instrument(self.instrument_id)\n    if self.instrument is None:\n        self.log.error(f\"Could not find instrument for {self.instrument_id}\")\n        self.stop()\n        return\n\n    # Register the indicators for updating\n    self.register_indicator_for_bars(self.bar_type, self.fast_ema)\n    self.register_indicator_for_bars(self.bar_type, self.slow_ema)\n\n    # Get historical data\n    self.request_bars(self.bar_type)\n\n    # Subscribe to live data\n    self.subscribe_bars(self.bar_type)\n    self.subscribe_quote_ticks(self.instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Event Handling in Python\nDESCRIPTION: This code snippet demonstrates how to define a generic event handler within a Nautilus Trader strategy. This handler receives all event messages which arrive at the strategy, including those for which no other specific handler exists, providing a catch-all mechanism for event processing.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core.message import Event\n\ndef on_event(self, event: Event) -> None:\n```\n\n----------------------------------------\n\nTITLE: Configuring Trading Node for Binance Integration\nDESCRIPTION: This Python code snippet shows how to configure a `TradingNode` to include Binance data and execution clients. It demonstrates setting the API key, secret, account type, and other optional parameters like custom base URLs and Binance US support within the `TradingNodeConfig` object. The account type specifies whether to use spot, margin, USDT futures, or coin futures.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.live.node import TradingNode\n\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"BINANCE\": {\n            \"api_key\": \"YOUR_BINANCE_API_KEY\",\n            \"api_secret\": \"YOUR_BINANCE_API_SECRET\",\n            \"account_type\": \"spot\",  # {spot, margin, usdt_future, coin_future}\n            \"base_url_http\": None,  # Override with custom endpoint\n            \"base_url_ws\": None,  # Override with custom endpoint\n            \"us\": False,  # If client is for Binance US\n        },\n    },\n    exec_clients={\n        \"BINANCE\": {\n            \"api_key\": \"YOUR_BINANCE_API_KEY\",\n            \"api_secret\": \"YOUR_BINANCE_API_SECRET\",\n            \"account_type\": \"spot\",  # {spot, margin, usdt_future, coin_future}\n            \"base_url_http\": None,  # Override with custom endpoint\n            \"base_url_ws\": None,  # Override with custom endpoint\n            \"us\": False,  # If client is for Binance US\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Submitting Orders with Position IDs for Hedge Mode (Python)\nDESCRIPTION: This snippet shows how to submit orders with specific position IDs (LONG or SHORT suffixes) to indicate the position direction when using Binance Futures Hedge mode.  This is achieved by appending `-LONG` or `-SHORT` to the instrument ID when creating the `PositionId`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass EMACrossHedgeMode(Strategy):\n    ...,  # Omitted\n    def buy(self) -> None:\n        \"\"\"\n        Users simple buy method (example).\n        \"\"\"\n        order: MarketOrder = self.order_factory.market(\n            instrument_id=self.instrument_id,\n            order_side=OrderSide.BUY,\n            quantity=self.instrument.make_qty(self.trade_size),\n            # time_in_force=TimeInForce.FOK,\n        )\n\n        # LONG suffix is recognized as a long position by Binance adapter.\n        position_id = PositionId(f\"{self.instrument_id}-LONG\")\n        self.submit_order(order, position_id)\n\n    def sell(self) -> None:\n        \"\"\"\n        Users simple sell method (example).\n        \"\"\"\n        order: MarketOrder = self.order_factory.market(\n            instrument_id=self.instrument_id,\n            order_side=OrderSide.SELL,\n            quantity=self.instrument.make_qty(self.trade_size),\n            # time_in_force=TimeInForce.FOK,\n        )\n        # SHORT suffix is recognized as a short position by Binance adapter.\n        position_id = PositionId(f\"{self.instrument_id}-SHORT\")\n        self.submit_order(order, position_id)\n```\n\n----------------------------------------\n\nTITLE: Submitting a LIMIT BUY Order for Emulation (Python)\nDESCRIPTION: This snippet demonstrates how to submit a `LIMIT` BUY order for emulation using the `order_factory.limit()` method and the `submit_order()` method. It requires importing `OrderSide`, `TriggerType`, and `LimitOrder` from `nautilus_trader.model`. Emulation is triggered by specifying `emulation_trigger`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model.orders import LimitOrder\n\n\ndef buy(self) -> None:\n    \"\"\"\n    Users simple buy method (example).\n    \"\"\"\n    order: LimitOrder = self.order_factory.limit(\n        instrument_id=self.instrument_id,\n        order_side=OrderSide.BUY,\n        quantity=self.instrument.make_qty(self.trade_size),\n        price=self.instrument.make_price(5000.00),\n        emulation_trigger=TriggerType.LAST_PRICE,\n    )\n\n    self.submit_order(order)\n```\n\n----------------------------------------\n\nTITLE: Triggering Orders with Synthetic Instrument Prices (Python)\nDESCRIPTION: This example demonstrates how to submit a new emulated order triggered by synthetic instrument prices.  The order is retained in the emulator until triggered by synthetic quotes, and then submitted as a MARKET order.  It involves specifying the `trigger_instrument_id` as the synthetic instrument's ID.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\norder = self.strategy.order_factory.limit(\n    instrument_id=ETHUSDT_BINANCE.id,\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_str(\"1.5\"),\n    price=Price.from_str(\"30000.00000000\"),  # <-- Synthetic instrument price\n    emulation_trigger=TriggerType.DEFAULT,\n    trigger_instrument_id=self._synthetic_id,  # <-- Synthetic instrument identifier\n)\n\nself.strategy.submit_order(order)\n```\n\n----------------------------------------\n\nTITLE: Processing DataFrame into QuoteTick objects\nDESCRIPTION: This snippet processes the pandas DataFrame into a list of `QuoteTick` objects using the `QuoteTickDataWrangler`. It initializes the wrangler with a default EUR/USD instrument and then uses it to process the DataFrame into `QuoteTick` objects which are compatible with Nautilus Trader. This is a crucial step in converting raw data to the format required by Nautilus.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Process quotes using a wrangler\nEURUSD = TestInstrumentProvider.default_fx_ccy(\"EUR/USD\")\nwrangler = QuoteTickDataWrangler(EURUSD)\n\nticks = wrangler.process(df)\n\n# Preview: see first 2 ticks\nticks[0:2]\n```\n\n----------------------------------------\n\nTITLE: Requesting Raw and Aggregated Historical Bars in Nautilus (Python)\nDESCRIPTION: This code demonstrates how to request historical bars, both raw and aggregated, using the `request_bars()` method and `request_aggregated_bars()` method. It provides examples for requesting raw 1-minute bars and 5-minute bars aggregated from 1-minute bars.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Request raw 1-minute bars (aggregated from TradeTick objects as indicated by LAST price type)\nself.request_bars(BarType.from_str(\"6EH4.XCME-1-MINUTE-LAST-EXTERNAL\"))\n\n# Request 5-minute bars aggregated from 1-minute bars\nself.request_bars(BarType.from_str(\"6EH4.XCME-5-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL\"))\n```\n\nLANGUAGE: python\nCODE:\n```\n# Request bars that are aggregated from historical trade ticks\nself.request_aggregated_bars(BarType.from_str(\"6EH4.XCME-100-VOLUME-LAST-INTERNAL\"))\n\n# Request bars that are aggregated from other bars\nself.request_aggregated_bars(BarType.from_str(\"6EH4.XCME-5-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL\"))\n```\n\n----------------------------------------\n\nTITLE: Creating a Market Order with OrderFactory in Python\nDESCRIPTION: This code snippet demonstrates how to create a Market order using the OrderFactory in Nautilus Trader. It specifies the instrument, order side (BUY), quantity, time in force (IOC), reduce-only flag, and optional tags. This order will be executed immediately at the best available price on the specified instrument.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import MarketOrder\n\norder: MarketOrder = self.order_factory.market(\n    instrument_id=InstrumentId.from_str(\"AUD/USD.IDEALPRO\"),\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_int(100_000),\n    time_in_force=TimeInForce.IOC,  # <-- optional (default GTC)\n    reduce_only=False,  # <-- optional (default False)\n    tags=[\"ENTRY\"],  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Storing Shared Data in Cache - Python\nDESCRIPTION: This code demonstrates how to store data in the Cache within a Nautilus Trader strategy so that it can be accessed by other strategies. It prepares data to be shared and stores it in the Cache using a descriptive key, leveraging Python's `pickle` module for serialization.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\n\nclass MyStrategy(Strategy):\n    def on_start(self):\n        # Prepare data you want to share with other strategies\n        shared_data = {\n            \"last_reset\": self.clock.timestamp_ns(),\n            \"trading_enabled\": True,\n            # Include any other fields that you want other strategies to read\n        }\n\n        # Store it in the cache with a descriptive key\n        # This way, multiple strategies can call self.cache.get(\"shared_strategy_info\")\n        # to retrieve the same data\n        self.cache.add(\"shared_strategy_info\", pickle.dumps(shared_data))\n```\n\n----------------------------------------\n\nTITLE: Creating a Stop-Market Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Stop-Market order in Nautilus Trader. It sets up a SELL order for 1 BTC on Binance Spot/Margin, triggered at a price of 100,000 USDT using the last price as the trigger type. It uses the StopMarketOrder class, setting parameters such as instrument_id, order_side, quantity, trigger_price, trigger_type, time_in_force, expire_time, reduce_only, and tags.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import StopMarketOrder\n\norder: StopMarketOrder = self.order_factory.stop_market(\n    instrument_id=InstrumentId.from_str(\"BTCUSDT.BINANCE\"),\n    order_side=OrderSide.SELL,\n    quantity=Quantity.from_int(1),\n    trigger_price=Price.from_int(100_000),\n    trigger_type=TriggerType.LAST_PRICE,  # <-- optional (default DEFAULT)\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    expire_time=None,  # <-- optional (default None)\n    reduce_only=False,  # <-- optional (default False)\n    tags=None,  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Market Orders on dYdX with Price Slippage Protection in Python\nDESCRIPTION: This Python code snippet shows how to create a market order on dYdX with price slippage protection by specifying a maximum acceptable price. This is achieved by setting the `market_order_price` tag within the `DYDXOrderTags`, ensuring the order executes only if the market price is within the defined limit.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\norder = self.order_factory.market(\n    instrument_id=self.instrument_id,\n    order_side=OrderSide.BUY,\n    quantity=self.instrument.make_qty(self.trade_size),\n    time_in_force=TimeInForce.IOC,\n    tags=[DYDXOrderTags(is_short_term_order=True, market_order_price=Price.from_str(\"10_000\")).value],\n)\n```\n\n----------------------------------------\n\nTITLE: Loading AAPL Trade Data with DatabentoDataLoader\nDESCRIPTION: This snippet loads AAPL trade data from a Databento DBN file into Nautilus Trader's `TradeTick` objects using `DatabentoDataLoader`. An InstrumentId is provided to eliminate the need for symbology mapping. `as_legacy_cython` is set to `False` for better performance when writing to the catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ninstrument_id = InstrumentId.from_str(\"AAPL.XNAS\")\n\ntrades = loader.from_dbn_file(\n    path=path,\n    instrument_id=instrument_id,\n    as_legacy_cython=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Position Access using Cache - Python\nDESCRIPTION: These snippets demonstrate how to access position data using the `Cache` object in Nautilus Trader.  It shows how to retrieve a specific position by its ID, get positions by their state (all, open, closed), and filter positions based on venue, instrument ID, strategy ID, and position side. Requires `PositionId` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Get a specific position by its ID\nposition = self.cache.position(PositionId(\"P-123\"))\n\n# Get positions by their state\nall_positions = self.cache.positions()            # All positions in the system\nopen_positions = self.cache.positions_open()      # All currently open positions\nclosed_positions = self.cache.positions_closed()  # All closed positions\n\n# Get positions filtered by various criteria\nvenue_positions = self.cache.positions(venue=venue)                       # Positions for a specific venue\ninstrument_positions = self.cache.positions(instrument_id=instrument_id)  # Positions for a specific instrument\nstrategy_positions = self.cache.positions(strategy_id=strategy_id)        # Positions for a specific strategy\nlong_positions = self.cache.positions(side=PositionSide.LONG)             # All long positions\n```\n\n----------------------------------------\n\nTITLE: Defining a Standard BarType using from_str in Python\nDESCRIPTION: This code snippet demonstrates how to define a standard BarType object in NautilusTrader using the `from_str` method. The example creates a BarType for AAPL trades (last price) on Nasdaq (XNAS) using a 5-minute interval aggregated from trades locally by Nautilus. This requires the `BarType` class to be imported or available in the current scope.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nbar_type = BarType.from_str(\"AAPL.XNAS-5-MINUTE-LAST-INTERNAL\")\n```\n\n----------------------------------------\n\nTITLE: Handling Historical and Live Bar Data in Nautilus Strategy (Python)\nDESCRIPTION: This code snippet illustrates the required handlers in your strategy class to receive historical data from `request_bars()` and live bar data from `subscribe_bars()`. It emphasizes that indicators registered with `register_indicator_for_bars` are automatically updated with historical data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef on_historical_data(self, data):\n    # Processes batches of historical bars from request_bars()\n    # Note: indicators registered with register_indicator_for_bars\n    # are updated automatically with historical data\n    pass\n\ndef on_bar(self, bar):\n    # Processes individual bars in real-time from subscribe_bars()\n    # Indicators registered with this bar type will update automatically and they will be updated before this handler is called\n    pass\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging for a Trading Node - Python\nDESCRIPTION: This snippet demonstrates how to configure logging for a trading node in Nautilus Trader using the `LoggingConfig` and `TradingNodeConfig` classes. It sets the log level for stdout/stderr and files, specifies the log file format, and filters logs for a specific component. Dependencies include `nautilus_trader.config`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/logging.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import LoggingConfig\nfrom nautilus_trader.config import TradingNodeConfig\n\nconfig_node = TradingNodeConfig(\n    trader_id=\"TESTER-001\",\n    logging=LoggingConfig(\n        log_level=\"INFO\",\n        log_level_file=\"DEBUG\",\n        log_file_format=\"json\",\n        log_component_levels={ \"Portfolio\": \"INFO\" },\n    ),\n    ... # Omitted\n)\n```\n\n----------------------------------------\n\nTITLE: Portfolio Information Functions (Python)\nDESCRIPTION: This code block showcases the methods available for accessing account and positional information through the `Portfolio` object.  It imports necessary modules from `nautilus_trader`. It outlines function signatures for retrieving balances, margins, P&L, exposures, and position details, as well as methods for checking position status (long, short, flat).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport decimal\n\nfrom nautilus_trader.accounting.accounts.base import Account\nfrom nautilus_trader.model import Venue\nfrom nautilus_trader.model import Currency\nfrom nautilus_trader.model import Money\nfrom nautilus_trader.model import InstrumentId\n\ndef account(self, venue: Venue) -> Account\n\ndef balances_locked(self, venue: Venue) -> dict[Currency, Money]\ndef margins_init(self, venue: Venue) -> dict[Currency, Money]\ndef margins_maint(self, venue: Venue) -> dict[Currency, Money]\ndef unrealized_pnls(self, venue: Venue) -> dict[Currency, Money]\ndef realized_pnls(self, venue: Venue) -> dict[Currency, Money]\ndef net_exposures(self, venue: Venue) -> dict[Currency, Money]\n\ndef unrealized_pnl(self, instrument_id: InstrumentId) -> Money\ndef realized_pnl(self, instrument_id: InstrumentId) -> Money\ndef net_exposure(self, instrument_id: InstrumentId) -> Money\ndef net_position(self, instrument_id: InstrumentId) -> decimal.Decimal\n\ndef is_net_long(self, instrument_id: InstrumentId) -> bool\ndef is_net_short(self, instrument_id: InstrumentId) -> bool\ndef is_flat(self, instrument_id: InstrumentId) -> bool\ndef is_completely_flat(self) -> bool\n```\n\n----------------------------------------\n\nTITLE: Basic Order Access using Cache - Python\nDESCRIPTION: These code snippets illustrate how to access order data using the `Cache` object in Nautilus Trader. It shows how to retrieve a specific order by its client order ID, get all orders, and filter orders based on venue, strategy ID, and instrument ID. Requires `ClientOrderId` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Get a specific order by its client order ID\norder = self.cache.order(ClientOrderId(\"O-123\"))\n\n# Get all orders in the system\norders = self.cache.orders()\n\n# Get orders filtered by specific criteria\norders_for_venue = self.cache.orders(venue=venue)                       # All orders for a specific venue\norders_for_strategy = self.cache.orders(strategy_id=strategy_id)        # All orders for a specific strategy\norders_for_instrument = self.cache.orders(instrument_id=instrument_id)  # All orders for an instrument\n```\n\n----------------------------------------\n\nTITLE: Defining Stateful Actions Handlers in Python\nDESCRIPTION: This code snippet shows the method signatures for defining stateful action handlers within a Nautilus Trader strategy. These handlers are triggered by lifecycle state changes of the strategy, such as starting, stopping, resuming, and resetting. They're used for tasks like initializing the strategy, cleaning up resources, and saving/loading state.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\ndef on_stop(self) -> None:\ndef on_resume(self) -> None:\ndef on_reset(self) -> None:\ndef on_dispose(self) -> None:\ndef on_degrade(self) -> None:\ndef on_fault(self) -> None:\ndef on_save(self) -> dict[str, bytes]:  # Returns user-defined dictionary of state to be saved\ndef on_load(self, state: dict[str, bytes]) -> None:\n```\n\n----------------------------------------\n\nTITLE: Adding a CASH Account in Nautilus Trader (Python)\nDESCRIPTION: This code snippet demonstrates how to add a CASH account for trading on Binance Spot using the Nautilus Trader engine. It specifies the venue code and sets the account type to AccountType.CASH. This account type is suitable for spot trading with direct asset ownership.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/backtesting.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import AccountType\n\n\nengine.add_venue(\n    venue_code=\"BINANCE\",\n    account_type=AccountType.CASH,   #  CASH | MARGIN | BETTING\n    ...\n)\n```\n\n----------------------------------------\n\nTITLE: Loading and processing CSV tick data in Python\nDESCRIPTION: This snippet loads a CSV file into a Pandas DataFrame, renames the columns to 'timestamp', 'bid_price', and 'ask_price'. It then creates an instrument EUR/USD and uses a `QuoteTickDataWrangler` to process the DataFrame into a list of `QuoteTick` objects. This involves parsing and transforming the raw data into the desired format.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Here we just take the first data file found and load into a pandas DataFrame\ndf = CSVTickDataLoader.load(raw_files[0], index_col=0, datetime_format=\"%Y%m%d %H%M%S%f\")\ndf.columns = [\"timestamp\", \"bid_price\", \"ask_price\"]\n\n# Process quotes using a wrangler\nEURUSD = TestInstrumentProvider.default_fx_ccy(\"EUR/USD\")\nwrangler = QuoteTickDataWrangler(EURUSD)\n\nticks = wrangler.process(df)\n```\n\n----------------------------------------\n\nTITLE: Adding Execution Algorithm to Engine - Python\nDESCRIPTION: This snippet demonstrates how to instantiate a custom execution algorithm (TWAPExecAlgorithm) and add it to the trading engine. The execution algorithm will handle the execution of orders based on specific parameters.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nexec_algorithm = TWAPExecAlgorithm()\nengine.add_exec_algorithm(exec_algorithm)\n```\n\n----------------------------------------\n\nTITLE: Querying Orders for Exec Algorithm - Python\nDESCRIPTION: This code defines the function signature to query orders for a specific execution algorithm based on various filter criteria, such as execution algorithm ID, venue, instrument ID, strategy ID, and side. It returns a list of orders matching the criteria.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef orders_for_exec_algorithm(\n    self,\n    exec_algorithm_id: ExecAlgorithmId,\n    venue: Venue | None = None,\n    instrument_id: InstrumentId | None = None,\n    strategy_id: StrategyId | None = None,\n    side: OrderSide = OrderSide.NO_ORDER_SIDE,\n) -> list[Order]:\n```\n\n----------------------------------------\n\nTITLE: Importing required modules - Python\nDESCRIPTION: This snippet imports the necessary modules from the NautilusTrader library for setting up and running a backtest. These modules include classes for the backtest engine, configurations, strategies, execution algorithms, data models, and persistence.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.backtest.engine import BacktestEngineConfig\nfrom nautilus_trader.examples.algorithms.twap import TWAPExecAlgorithm\nfrom nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAP\nfrom nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAPConfig\nfrom nautilus_trader.model import BarType\nfrom nautilus_trader.model import Money\nfrom nautilus_trader.model import TraderId\nfrom nautilus_trader.model import Venue\nfrom nautilus_trader.model.currencies import ETH\nfrom nautilus_trader.model.currencies import USDT\nfrom nautilus_trader.model.enums import AccountType\nfrom nautilus_trader.model.enums import OmsType\nfrom nautilus_trader.persistence.wranglers import TradeTickDataWrangler\nfrom nautilus_trader.test_kit.providers import TestDataProvider\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Discovering Instruments - Binance Futures Testnet\nDESCRIPTION: This code snippet demonstrates how to discover available instruments on the Binance Futures testnet using the `BinanceFuturesInstrumentProvider`. It initializes the HTTP client, connects to the Binance API, creates the instrument provider, and loads all available instruments.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.binance.common.enums import BinanceAccountType\nfrom nautilus_trader.adapters.binance.factories import get_cached_binance_http_client\nfrom nautilus_trader.adapters.binance.futures.providers import BinanceFuturesInstrumentProvider\nfrom nautilus_trader.common.component import LiveClock\n\n\nclock = LiveClock()\naccount_type = BinanceAccountType.USDT_FUTURE\n\nclient = get_cached_binance_http_client(\n    loop=asyncio.get_event_loop(),\n    clock=clock,\n    account_type=account_type,\n    key=os.getenv(\"BINANCE_FUTURES_TESTNET_API_KEY\"),\n    secret=os.getenv(\"BINANCE_FUTURES_TESTNET_API_SECRET\"),\n    is_testnet=True,\n)\nawait client.connect()\n\nprovider = BinanceFuturesInstrumentProvider(\n    client=client,\n    account_type=BinanceAccountType.USDT_FUTURE,\n)\n\nawait provider.load_all_async()\n```\n\n----------------------------------------\n\nTITLE: Submitting a MARKET BUY Order to a TWAP Execution Algorithm (Python)\nDESCRIPTION: This snippet demonstrates how to submit a `MARKET` BUY order to a TWAP execution algorithm using `order_factory.market()` and `submit_order()`. It requires importing `OrderSide`, `TimeInForce`, and `ExecAlgorithmId` from `nautilus_trader.model`. Specifying `exec_algorithm_id` routes the order to the given execution algorithm.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model import ExecAlgorithmId\n\n\ndef buy(self) -> None:\n    \"\"\"\n    Users simple buy method (example).\n    \"\"\"\n    order: MarketOrder = self.order_factory.market(\n        instrument_id=self.instrument_id,\n        order_side=OrderSide.BUY,\n        quantity=self.instrument.make_qty(self.trade_size),\n        time_in_force=TimeInForce.FOK,\n        exec_algorithm_id=ExecAlgorithmId(\"TWAP\"),\n        exec_algorithm_params={\"horizon_secs\": 20, \"interval_secs\": 2.5},\n    )\n\n    self.submit_order(order)\n```\n\n----------------------------------------\n\nTITLE: Registering Parquet Files with DataFusion\nDESCRIPTION: Registers the Parquet files with the DataFusion context, assigning them table names (`trade_0` and `bar_0`). This allows the files to be queried using SQL.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Run this cell once (otherwise will error)\nctx.register_parquet(\"trade_0\", trade_tick_path)\nctx.register_parquet(\"bar_0\", bar_path)\n```\n\n----------------------------------------\n\nTITLE: Finding Instrument By ID\nDESCRIPTION: This snippet illustrates how to retrieve an instrument from the central cache using its ID in Nautilus Trader.  It imports the InstrumentId class and then retrieves the instrument by its instrument ID.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model import InstrumentId\n\ninstrument_id = InstrumentId.from_str(\"ETHUSDT-PERP.BINANCE\")\ninstrument = self.cache.instrument(instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Fetching Execution Objects from Cache (Python)\nDESCRIPTION: This snippet demonstrates how to fetch individual order and position objects from the cache using `cache.order()` and `cache.position()`. It requires `client_order_id` and `position_id` variables to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\norder = self.cache.order(client_order_id)\nposition = self.cache.position(position_id)\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Bar Data from Cache\nDESCRIPTION: This code snippet demonstrates different ways to access bar data from the Cache. It covers fetching all cached bars, the most recent bar, a specific historical bar by index, and checking for bar availability and count. The code assumes access to the `self.cache` object.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Get a list of all cached bars for a bar type\nbars = self.cache.bars(bar_type)  # Returns List[Bar] or an empty list if no bars found\n\n# Get the most recent bar\nlatest_bar = self.cache.bar(bar_type)  # Returns Bar or None if no such object exists\n\n# Get a specific historical bar by index (0 = most recent)\nsecond_last_bar = self.cache.bar(bar_type, index=1)  # Returns Bar or None if no such object exists\n\n# Check if bars exist and get count\nbar_count = self.cache.bar_count(bar_type)  # Returns number of bars in cache for the specified bar type\nhas_bars = self.cache.has_bars(bar_type)    # Returns bool indicating if any bars exist for the specified bar type\n```\n\n----------------------------------------\n\nTITLE: Running the backtest node\nDESCRIPTION: This snippet initializes and runs the `BacktestNode` with the configured backtest run. It creates a `BacktestNode` instance with a list containing the `config` object. It then calls the `run()` method to start the backtest simulation. The results of the backtest are stored in the `results` variable.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnode = BacktestNode(configs=[config])\n\nresults = node.run()\nresults\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Building a Trading Node\nDESCRIPTION: This code snippet demonstrates how to instantiate a `TradingNode` with a configuration, register client factories for data and execution using `CoinbaseIntxLiveDataClientFactory` and `CoinbaseIntxLiveExecClientFactory` respectively, and finally build the node. `COINBASE_INTX` likely refers to a constant identifying the Coinbase International exchange.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factories with the node\nnode.add_data_client_factory(COINBASE_INTX, CoinbaseIntxLiveDataClientFactory)\nnode.add_exec_client_factory(COINBASE_INTX, CoinbaseIntxLiveExecClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader from source with uv\nDESCRIPTION: This command installs NautilusTrader from source using uv, including the `ibapi` and `docker` dependencies. The `--extra` flag specifies the extra dependencies to be installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nuv sync --extra ib --extra docker\n```\n\n----------------------------------------\n\nTITLE: Strategy Configuration Definition\nDESCRIPTION: This code defines a strategy configuration class `MyStrategyConfig` inheriting from `StrategyConfig`. It includes fields for instrument ID, bar type, fast and slow EMA periods, trade size, and an order ID tag. This configuration is used to parameterize the strategy.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\nfrom nautilus_trader.config import StrategyConfig\nfrom nautilus_trader.model import Bar, BarType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.trading.strategy import Strategy\n\n\n# Configuration definition\nclass MyStrategyConfig(StrategyConfig):\n    instrument_id: InstrumentId   # example value: \"ETHUSDT-PERP.BINANCE\"\n    bar_type: BarType             # example value: \"ETHUSDT-PERP.BINANCE-15-MINUTE[LAST]-EXTERNAL\"\n    fast_ema_period: int = 10\n    slow_ema_period: int = 20\n    trade_size: Decimal\n    order_id_tag: str\n```\n\n----------------------------------------\n\nTITLE: Configuring Backtest with ParquetDataCatalog in Python\nDESCRIPTION: This snippet configures a backtest run by defining venue configurations, data configurations, and strategy configurations. Venue configurations specify the trading venue, account type, and starting balances. Data configurations specify the catalog path, data class (QuoteTick), instrument ID, and time range. Strategy configurations specify the strategy to use, its configuration path, and specific configuration parameters such as the instrument ID, bar type, EMA periods, and trade size.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ninstrument = catalog.instruments()[0]\n\nvenue_configs = [\n    BacktestVenueConfig(\n        name=\"SIM\",\n        oms_type=\"HEDGING\",\n        account_type=\"MARGIN\",\n        base_currency=\"USD\",\n        starting_balances=[\"1000000 USD\"],\n    ),\n]\n\ndata_configs = [\n    BacktestDataConfig(\n        catalog_path=str(catalog.path),\n        data_cls=QuoteTick,\n        instrument_id=instrument.id,\n        start_time=start,\n        end_time=end,\n    ),\n]\n\nstrategies = [\n    ImportableStrategyConfig(\n        strategy_path=\"nautilus_trader.examples.strategies.ema_cross:EMACross\",\n        config_path=\"nautilus_trader.examples.strategies.ema_cross:EMACrossConfig\",\n        config={\n            \"instrument_id\": instrument.id,\n            \"bar_type\": BarType.from_str(f\"{instrument.id.value}-15-MINUTE-BID-INTERNAL\"),\n            \"fast_ema_period\": 10,\n            \"slow_ema_period\": 20,\n            \"trade_size\": Decimal(1_000_000),\n        },\n    ),\n]\n\nconfig = BacktestRunConfig(\n    engine=BacktestEngineConfig(strategies=strategies),\n    data=data_configs,\n    venues=venue_configs,\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Indicators Before Requesting Data in Nautilus (Python)\nDESCRIPTION: This example highlights the importance of registering indicators before requesting historical data. It shows the correct order of operations to ensure indicators are properly updated with historical data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Correct order\nself.register_indicator_for_bars(bar_type, self.ema)\nself.request_bars(bar_type)\n\n# Incorrect order\nself.request_bars(bar_type)  # Indicator won't receive historical data\nself.register_indicator_for_bars(bar_type, self.ema)\n```\n\n----------------------------------------\n\nTITLE: Trade-to-Bar Aggregation Definition in Nautilus Trader (Python)\nDESCRIPTION: This code defines a bar type that aggregates from TradeTick objects using the LAST price type. It then requests historical bars and subscribes to live bars of this type, demonstrating how to receive aggregated data in `on_historical_data` and `on_bar` handlers respectively.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\n    # Define a bar type for aggregating from TradeTick objects\n    # Uses price_type=LAST which indicates TradeTick data as source\n    bar_type = BarType.from_str(\"6EH4.XCME-50-VOLUME-LAST-INTERNAL\")\n\n    # Request historical data (will receive bars in on_historical_data handler)\n    self.request_bars(bar_type)\n\n    # Subscribe to live data (will receive bars in on_bar handler)\n    self.subscribe_bars(bar_type)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Actor with Configuration in Python\nDESCRIPTION: This code snippet demonstrates how to define a custom actor in Nautilus Trader, including defining a custom configuration class inheriting from ActorConfig. It shows how to specify configuration parameters like instrument ID and bar type, and how to use these parameters within the actor's methods. The actor subscribes to bars when started and increments a counter when a bar is received.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/actors.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import ActorConfig\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Bar, BarType\nfrom nautilus_trader.common.actor import Actor\n\n\nclass MyActorConfig(ActorConfig):\n    instrument_id: InstrumentId   # example value: \"ETHUSDT-PERP.BINANCE\"\n    bar_type: BarType             # example value: \"ETHUSDT-PERP.BINANCE-15-MINUTE[LAST]-INTERNAL\"\n    lookback_period: int = 10\n\n\nclass MyActor(Actor):\n    def __init__(self, config: MyActorConfig) -> None:\n        super().__init__(config)\n\n        # Custom state variables\n        self.count_of_processed_bars: int = 0\n\n    def on_start(self) -> None:\n        # Subscribe to all incoming bars\n        self.subscribe_bars(self.config.bar_type)   # You can access configuration directly via `self.config`\n\n    def on_bar(self, bar: Bar):\n        self.count_of_processed_bars += 1\n```\n\n----------------------------------------\n\nTITLE: Running the Backtest - Python\nDESCRIPTION: This snippet demonstrates how to run the backtest using the BacktestEngine's .run() method. This will initiate the backtest process over the data provided.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Run the engine (from start to end of data)\nengine.run()\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with Bybit dependencies using uv\nDESCRIPTION: This command installs `nautilus_trader` from source using `uv` and includes the `bybit` extra dependencies. The `--extra bybit` flag specifies that the `bybit` dependencies should also be installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/bybit.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv sync --extra bybit\n```\n\n----------------------------------------\n\nTITLE: Quote-to-Bar Aggregation Definition in Nautilus Trader (Python)\nDESCRIPTION: This snippet demonstrates creating bars from QuoteTick objects using ASK, BID, and MID prices. It defines three different bar types and then requests historical and subscribes to live data for the ASK bar type, showing how to work with quote-based data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\n    # Create 1-minute bars from ASK prices (in QuoteTick objects)\n    bar_type_ask = BarType.from_str(\"6EH4.XCME-1-MINUTE-ASK-INTERNAL\")\n\n    # Create 1-minute bars from BID prices (in QuoteTick objects)\n    bar_type_bid = BarType.from_str(\"6EH4.XCME-1-MINUTE-BID-INTERNAL\")\n\n    # Create 1-minute bars from MID prices (middle between ASK and BID prices in QuoteTick objects)\n    bar_type_mid = BarType.from_str(\"6EH4.XCME-1-MINUTE-MID-INTERNAL\")\n\n    # Request historical data and subscribe to live data\n    self.request_bars(bar_type_ask)    # Historical bars processed in on_historical_data\n    self.subscribe_bars(bar_type_ask)  # Live bars processed in on_bar\n```\n\n----------------------------------------\n\nTITLE: Configuring dYdX Testnet Clients in TradingNode\nDESCRIPTION: This Python code demonstrates how to configure dYdX data and execution clients to connect to the dYdX testnet within a Nautilus Trader TradingNode. By setting the `is_testnet` option to `True`, the clients will use the testnet environment for trading and data ingestion.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"DYDX\": {\n            \"wallet_address\": \"YOUR_DYDX_WALLET_ADDRESS\",\n            \"is_testnet\": True,\n        },\n    },\n    exec_clients={\n        \"DYDX\": {\n            \"wallet_address\": \"YOUR_DYDX_WALLET_ADDRESS\",\n            \"subaccount\": \"YOUR_DYDX_SUBACCOUNT_NUMBER\"\n            \"mnemonic\": \"YOUR_MNEMONIC\",\n            \"is_testnet\": True,\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Reading data from ParquetDataCatalog (Python)\nDESCRIPTION: This code shows how to read order book deltas from a `ParquetDataCatalog` for a specific instrument and time range. It uses `dt_to_unix_nanos` to convert timestamps to nanoseconds and retrieves the data using the `order_book_deltas` method. Requires the `nautilus_trader` library, `pandas`, and `pytz`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos\nimport pandas as pd\n\n\nstart = dt_to_unix_nanos(pd.Timestamp(\"2020-01-03\", tz=pytz.utc))\nend =  dt_to_unix_nanos(pd.Timestamp(\"2020-01-04\", tz=pytz.utc))\n\ndeltas = catalog.order_book_deltas(instrument_ids=[instrument.id.value], start=start, end=end)\n```\n\n----------------------------------------\n\nTITLE: Configuring backtest strategies\nDESCRIPTION: This code snippet defines the configuration for the backtest strategies. It creates a list containing an `ImportableStrategyConfig` object, specifying the strategy path, configuration path, and configuration parameters. The strategy used is `EMACross` from the examples, with parameters such as the instrument ID, bar type, EMA periods, and trade size.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nstrategies = [\n    ImportableStrategyConfig(\n        strategy_path=\"nautilus_trader.examples.strategies.ema_cross:EMACross\",\n        config_path=\"nautilus_trader.examples.strategies.ema_cross:EMACrossConfig\",\n        config={\n            \"instrument_id\": instrument.id,\n            \"bar_type\": \"EUR/USD.SIM-15-MINUTE-BID-INTERNAL\",\n            \"fast_ema_period\": 10,\n            \"slow_ema_period\": 20,\n            \"trade_size\": Decimal(1_000_000),\n        },\n    ),\n]\n```\n\n----------------------------------------\n\nTITLE: Bar-to-Bar Aggregation Definition in Nautilus Trader (Python)\nDESCRIPTION: This example shows how to create 5-minute bars from existing 1-minute bars. The bar type string specifies the target bar type and the source bar type after the @ symbol. It also demonstrates requesting historical and subscribing to live data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\n    # Create 5-minute bars from 1-minute bars (Bar objects)\n    # Format: target_bar_type@source_bar_type\n    # Note: price type (LAST) is only needed on the left target side, not on the source side\n    bar_type = BarType.from_str(\"6EH4.XCME-5-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL\")\n\n    # Request historical data (processed in on_historical_data(...) handler)\n    self.request_bars(bar_type)\n\n    # Subscribe to live updates (processed in on_bar(...) handler)\n    self.subscribe_bars(bar_type)\n```\n\n----------------------------------------\n\nTITLE: Configuring MessageBus with Database Backing (Python)\nDESCRIPTION: This snippet demonstrates how to configure the `MessageBus` in Nautilus Trader with a database backing (specifically Redis), encoding, timestamp format, and other stream settings. It shows how to create a `MessageBusConfig` object, configure various parameters like database settings, encoding type (JSON), timestamp formatting (ISO 8601), buffer interval, auto-trimming, and type filtering using the `types_filter` parameter for `QuoteTick` and `TradeTick`. This configuration enables external publishing of messages through the message bus.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n...  # Other config omitted\nmessage_bus=MessageBusConfig(\n    database=DatabaseConfig(),\n    encoding=\"json\",\n    timestamps_as_iso8601=True,\n    buffer_interval_ms=100,\n    autotrim_mins=30,\n    use_trader_prefix=True,\n    use_trader_id=True,\n    use_instance_id=False,\n    streams_prefix=\"streams\",\n    types_filter=[QuoteTick, TradeTick],\n)\n...\n```\n\n----------------------------------------\n\nTITLE: Building IBContracts for Options Instruments within a Range\nDESCRIPTION: This code snippet demonstrates how to create an `IBContract` instance to load Options Instruments within a specific expiry range. It sets `secType` to \"IND\", `symbol` to \"SPX\", `exchange` to \"CBOE\", and `build_options_chain` to `True`. `min_expiry_days` and `max_expiry_days` limit the loaded options contracts by expiry.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfor_loading_instrument_range = IBContract(\n    secType=\"IND\",\n    symbol=\"SPX\",\n    exchange=\"CBOE\",\n    build_options_chain=True,\n    min_expiry_days=0,\n    max_expiry_days=30,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Per-Contract Fee Model in Python\nDESCRIPTION: This code snippet demonstrates how to create a custom fee model in Nautilus Trader by inheriting from the `FeeModel` base class.  It calculates the total commission by multiplying a fixed per-contract fee by the number of contracts traded. The `get_commission(...)` method receives information about the order, fill quantity, fill price and instrument.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nclass PerContractFeeModel(FeeModel):\n    def __init__(self, commission: Money):\n        super().__init__()\n        self.commission = commission\n\n    def get_commission(self, Order_order, Quantity_fill_qty, Price_fill_px, Instrument_instrument):\n        total_commission = Money(self.commission * Quantity_fill_qty, self.commission.currency)\n        return total_commission\n```\n\n----------------------------------------\n\nTITLE: Implementing Instrument Provider in Python\nDESCRIPTION: This code snippet demonstrates how to implement an InstrumentProvider for NautilusTrader. The InstrumentProvider is responsible for supplying instrument definitions, including loading all available instruments and specific instruments by ID. It inherits from `InstrumentProvider` and overrides the `load_all_async`, `load_ids_async`, and `load_async` methods.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/adapters.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.common.providers import InstrumentProvider\nfrom nautilus_trader.model import InstrumentId\n\nclass TemplateInstrumentProvider(InstrumentProvider):\n    \"\"\"\n    An example template of an ``InstrumentProvider`` showing the minimal methods which must be implemented for an integration to be complete.\n    \"\"\"\n\n    async def load_all_async(self, filters: dict | None = None) -> None:\n        raise NotImplementedError(\"method `load_all_async` must be implemented in the subclass\")\n\n    async def load_ids_async(self, instrument_ids: list[InstrumentId], filters: dict | None = None) -> None:\n        raise NotImplementedError(\"method `load_ids_async` must be implemented in the subclass\")\n\n    async def load_async(self, instrument_id: InstrumentId, filters: dict | None = None) -> None:\n        raise NotImplementedError(\"method `load_async` must be implemented in the subclass\")\n```\n\n----------------------------------------\n\nTITLE: Modifying an Order (Python)\nDESCRIPTION: This snippet demonstrates how to modify an existing order using the `modify_order()` method. It imports `Quantity` from `nautilus_trader.model`. At least one value must differ from the original order for the command to be valid.  Modifying an order is only allowed when the order is emulated or supported by a venue.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model import Quantity\n\n\nnew_quantity: Quantity = Quantity.from_int(5)\nself.modify_order(order, new_quantity)\n```\n\n----------------------------------------\n\nTITLE: Configure Backtest with Order Book Data\nDESCRIPTION: This code snippet configures the backtest using data from the catalog, specifying the instrument, data class, and backtest parameters.  It defines `BacktestDataConfig`, `BacktestVenueConfig`, and `ImportableStrategyConfig` to set up the backtest environment, including data sources, venue settings, and the trading strategy to be used.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ninstrument = catalog.instruments()[0]\nbook_type = \"L2_MBP\"  # Ensure data book type matches venue book type\n\ndata_configs = [BacktestDataConfig(\n        catalog_path=CATALOG_PATH,\n        data_cls=OrderBookDelta,\n        instrument_id=instrument.id,\n        # start_time=start,  # Run across all data\n        # end_time=end,  # Run across all data\n    )\n]\n\nvenues_configs = [\n    BacktestVenueConfig(\n        name=\"BINANCE\",\n        oms_type=\"NETTING\",\n        account_type=\"CASH\",\n        base_currency=None,\n        starting_balances=[\"20 BTC\", \"100000 USDT\"],\n        book_type=book_type,  # <-- Venues book type\n    )\n]\n\nstrategies = [\n    ImportableStrategyConfig(\n        strategy_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalance\",\n        config_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalanceConfig\",\n        config={\n            \"instrument_id\": instrument.id,\n            \"book_type\": book_type,\n            \"max_trade_size\": Decimal(\"1.000\"),\n            \"min_seconds_between_triggers\": 1.0,\n        },\n    ),\n]\n\n# NautilusTrader currently exceeds the rate limit for Jupyter notebook logging (stdout output),\n# this is why the `log_level` is set to \"ERROR\". If you lower this level to see\n# more logging then the notebook will hang during cell execution. A fix is currently\n# being investigated which involves either raising the configured rate limits for\n# Jupyter, or throttling the log flushing from Nautilus.\n# https://github.com/jupyterlab/jupyterlab/issues/12845\n# https://github.com/deshaw/jupyterlab-limit-output\nconfig = BacktestRunConfig(\n    engine=BacktestEngineConfig(\n        strategies=strategies,\n        logging=LoggingConfig(log_level=\"ERROR\"),\n    ),\n    data=data_configs,\n    venues=venues_configs,\n)\n\nconfig\n```\n\n----------------------------------------\n\nTITLE: Creating GreeksTestData with customdataclass in Python\nDESCRIPTION: This code snippet shows the usage of the `@customdataclass` decorator to create a custom data class. It defines `GreeksTestData` inheriting from `Data` with `instrument_id` and `delta` attributes, and instantiates it with specific values.  The decorator provides default implementations for serialization and other features.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.custom import customdataclass\n\n\n@customdataclass\nclass GreeksTestData(Data):\n    instrument_id: InstrumentId = InstrumentId.from_str(\"ES.GLBX\")\n    delta: float = 0.0\n\n\nGreeksTestData(\n    instrument_id=InstrumentId.from_str(\"CL.GLBX\"),\n    delta=1000.0,\n    ts_event=1,\n    ts_init=2,\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Historical Bars from Cache\nDESCRIPTION: This code snippet demonstrates how to access historical bar data from the Cache within a strategy's `on_bar` method. It retrieves the last, previous, and third-last bars using `self.cache.bar()` method, illustrating indexed access to historical market data. Requires the `Bar` class and the `self.cache` attribute from the `Strategy` class.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef on_bar(self, bar: Bar) -> None:\n    # Current bar is provided in the parameter 'bar'\n\n    # Get historical bars from Cache\n    last_bar = self.cache.bar(self.bar_type, index=0)        # Last bar (practically the same as the 'bar' parameter)\n    previous_bar = self.cache.bar(self.bar_type, index=1)    # Previous bar\n    third_last_bar = self.cache.bar(self.bar_type, index=2)  # Third last bar\n\n    # Get current position information\n    if self.last_position_opened_id is not None:\n        position = self.cache.position(self.last_position_opened_id)\n        if position.is_open:\n            # Check position details\n            current_pnl = position.unrealized_pnl\n\n    # Get all open orders for our instrument\n    open_orders = self.cache.orders_open(instrument_id=self.instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Handling Orders in Execution Algorithm - Python\nDESCRIPTION: This snippet shows the structure of the `on_order` method, which is called when an order is received by the execution algorithm. It provides the entry point for handling primary orders and spawning secondary orders based on the algorithm's logic.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.orders.base import Order\n\ndef on_order(self, order: Order) -> None:\n    # Handle the order here\n```\n\n----------------------------------------\n\nTITLE: Instrument Provider Configuration - Load Specific Instruments\nDESCRIPTION: This snippet demonstrates how to configure an `InstrumentProvider` to load only specific instruments on startup. This is achieved by providing a list of `InstrumentId` values in the `load_ids` parameter of the `InstrumentProviderConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nInstrumentProviderConfig(load_ids=[\"BTCUSDT-PERP.BINANCE\", \"ETHUSDT-PERP.BINANCE\"])\n```\n\n----------------------------------------\n\nTITLE: Adding a Venue - Python\nDESCRIPTION: This snippet demonstrates how to add a venue (simulated Binance Spot exchange) to the BacktestEngine. The venue is configured with an OMS type, account type, and starting balances in USDT and ETH. This simulates a real trading environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Add a trading venue (multiple venues possible)\nBINANCE = Venue(\"BINANCE\")\nengine.add_venue(\n    venue=BINANCE,\n    oms_type=OmsType.NETTING,\n    account_type=AccountType.CASH,  # Spot CASH account (not for perpetuals or futures)\n    base_currency=None,  # Multi-currency account\n    starting_balances=[Money(1_000_000.0, USDT), Money(10.0, ETH)],\n)\n```\n\n----------------------------------------\n\nTITLE: Filtering Message Types in MessageBus Configuration (Python)\nDESCRIPTION: This code snippet illustrates how to configure the `MessageBus` to filter out specific types of messages from external publication.  It imports the necessary classes (`MessageBusConfig`, `TradeTick`, `QuoteTick`) and then creates a `MessageBusConfig` instance, specifying `QuoteTick` and `TradeTick` in the `types_filter`. This prevents these types of messages from being serialized and written to the external stream, which is useful for managing the amount of data published externally.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import MessageBusConfig\nfrom nautilus_trader.data import TradeTick\nfrom nautilus_trader.data import QuoteTick\n\n# Create a MessageBusConfig instance with types filtering\nmessage_bus = MessageBusConfig(\n    types_filter=[QuoteTick, TradeTick]\n)\n\n```\n\n----------------------------------------\n\nTITLE: Configuring and Adding EMA Cross Strategy\nDESCRIPTION: This code snippet configures and adds a simple `EMACross` strategy to the backtest engine. It defines the instrument ID, bar type, fast and slow EMA periods, and trade size. The strategy is then instantiated and added to the engine.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Configure your strategy\nconfig = EMACrossConfig(\n    instrument_id=USDJPY_SIM.id,\n    bar_type=BarType.from_str(\"USD/JPY.SIM-5-MINUTE-BID-INTERNAL\"),\n    fast_ema_period=10,\n    slow_ema_period=20,\n    trade_size=Decimal(1_000_000),\n)\n\n# Instantiate and add your strategy\nstrategy = EMACross(config=config)\nengine.add_strategy(strategy=strategy)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries in Python\nDESCRIPTION: This snippet imports necessary libraries for data manipulation, backtesting, catalog management, and testing within the Nautilus Trader framework. It includes modules for file system operations, dataframes, decimal arithmetic, backtest node configuration, data catalog interaction, data wrangling, and instrument providers.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport shutil\nfrom decimal import Decimal\nfrom pathlib import Path\n\nimport pandas as pd\n\nfrom nautilus_trader.backtest.node import BacktestDataConfig\nfrom nautilus_trader.backtest.node import BacktestEngineConfig\nfrom nautilus_trader.backtest.node import BacktestNode\nfrom nautilus_trader.backtest.node import BacktestRunConfig\nfrom nautilus_trader.backtest.node import BacktestVenueConfig\nfrom nautilus_trader.config import ImportableStrategyConfig\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos\nfrom nautilus_trader.model import BarType\nfrom nautilus_trader.model import QuoteTick\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\nfrom nautilus_trader.persistence.wranglers import QuoteTickDataWrangler\nfrom nautilus_trader.test_kit.providers import CSVTickDataLoader\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Requesting AAPL Trade Data from Databento API\nDESCRIPTION: This snippet requests historical trade data for AAPL from the Databento API for January 2024. It checks if the data already exists on disk and requests it only if it doesn't. It also specifies the path to save the downloaded data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\npath = DATABENTO_DATA_DIR / \"aapl-xnas-202401.trades.dbn.zst\"\n\nif not path.exists():\n    # Request data\n    client.timeseries.get_range(\n        dataset=\"XNAS.ITCH\",\n        symbols=[\"AAPL\"],\n        schema=\"trades\",\n        start=\"2024-01\",\n        path=path,  # <-- Passing a `path` parameter\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing uv with Curl\nDESCRIPTION: This command installs the `uv` package manager using a shell script downloaded via `curl`. The script automates the installation process.  `uv` can install packages from source faster than pip.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n\n----------------------------------------\n\nTITLE: Historical and Real-time Data Handling with Actors in Python\nDESCRIPTION: This code illustrates how to handle both historical and real-time data within a Nautilus Trader actor. It showcases requesting historical bars using `request_bars()` and subscribing to real-time bars using `subscribe_bars()`. The example demonstrates how to implement the `on_historical_data()` and `on_bar()` callbacks to process the respective data streams.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/actors.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.common.actor import Actor\nfrom nautilus_trader.config import ActorConfig\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.model.data import Bar, BarType\nfrom nautilus_trader.model.identifiers import ClientId, InstrumentId\n\n\nclass MyActorConfig(ActorConfig):\n    instrument_id: InstrumentId  # example value: \"AAPL.XNAS\"\n    bar_type: BarType            # example value: \"AAPL.XNAS-1-MINUTE-LAST-EXTERNAL\"\n\n\nclass MyActor(Actor):\n    def __init__(self, config: MyActorConfig) -> None:\n        super().__init__(config)\n        self.bar_type = config.bar_type\n\n    def on_start(self) -> None:\n        # Request historical data - will be processed by on_historical_data() handler\n        self.request_bars(\n            bar_type=self.bar_type,\n            # Many optional parameters\n            start=None,            # datetime, optional\n            end=None,              # datetime, optional\n            callback=None,         # called with the request ID when the response has completed\n            update_catalog=False,  # bool, default False\n            params=None,           # dict[str, Any], optional\n        )\n\n        # Subscribe to real-time data - will be processed by on_bar() handler\n        self.subscribe_bars(\n            bar_type=self.bar_type,\n            # Many optional parameters\n            client_id=None,       # ClientId, optional\n            await_partial=False,  # bool, default False\n            params=None,          # dict[str, Any], optional\n        )\n\n    def on_historical_data(self, data: Data) -> None:\n        # Handle historical data (from requests)\n        if isinstance(data, Bar):\n            self.log.info(f\"Received historical bar: {data}\")\n\n    def on_bar(self, bar: Bar) -> None:\n        # Handle real-time bar updates (from subscriptions)\n        self.log.info(f\"Received real-time bar: {bar}\")\n```\n\n----------------------------------------\n\nTITLE: Adding a Strategy - Python\nDESCRIPTION: This snippet demonstrates how to add a trading strategy (EMACrossTWAP) to the BacktestEngine. A strategy configuration is created, and the strategy is then initialized and added to the engine. The strategy uses a bar type, trade size, EMA periods, and TWAP settings.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Configure your strategy\nstrategy_config = EMACrossTWAPConfig(\n    instrument_id=ETHUSDT_BINANCE.id,\n    bar_type=BarType.from_str(\"ETHUSDT.BINANCE-250-TICK-LAST-INTERNAL\"),\n    trade_size=Decimal(\"0.10\"),\n    fast_ema_period=10,\n    slow_ema_period=20,\n    twap_horizon_secs=10.0,\n    twap_interval_secs=2.5,\n)\n\n# Instantiate and add your strategy\nstrategy = EMACrossTWAP(config=strategy_config)\nengine.add_strategy(strategy=strategy)\n```\n\n----------------------------------------\n\nTITLE: Querying Quote Ticks from Catalog in Python\nDESCRIPTION: This snippet defines a start and end timestamp, then queries the catalog for quote ticks for the EURUSD instrument within the specified time range. It retrieves a subset of the stored tick data based on instrument ID and time.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nstart = dt_to_unix_nanos(pd.Timestamp(\"2020-01-03\", tz=\"UTC\"))\nend =  dt_to_unix_nanos(pd.Timestamp(\"2020-01-04\", tz=\"UTC\"))\n\nticks = catalog.quote_ticks(instrument_ids=[EURUSD.id.value], start=start, end=end)\nticks[:10]\n```\n\n----------------------------------------\n\nTITLE: Creating and Building Trading Node with Binance Factories\nDESCRIPTION: This Python code snippet demonstrates how to create a `TradingNode` instance, register the `BinanceLiveDataClientFactory` and `BinanceLiveExecClientFactory` to handle data and execution clients, and then build the node. This setup integrates the Binance adapter into the Nautilus Trader framework for live trading.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.binance.factories import BinanceLiveDataClientFactory\nfrom nautilus_trader.adapters.binance.factories import BinanceLiveExecClientFactory\nfrom nautilus_trader.live.node import TradingNode\n\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factories with the node\nnode.add_data_client_factory(\"BINANCE\", BinanceLiveDataClientFactory)\nnode.add_exec_client_factory(\"BINANCE\", BinanceLiveExecClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Process Order Book Deltas with Wrangler\nDESCRIPTION: This code snippet processes the loaded order book snapshot and update DataFrames using an `OrderBookDeltaDataWrangler` to convert them into `OrderBookDelta` objects. It sorts the deltas by `ts_init` to ensure non-decreasing timestamps and displays the first 10 deltas.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nBTCUSDT_BINANCE = TestInstrumentProvider.btcusdt_binance()\nwrangler = OrderBookDeltaDataWrangler(BTCUSDT_BINANCE)\n\ndeltas = wrangler.process(df_snap)\ndeltas += wrangler.process(df_update)\ndeltas.sort(key=lambda x: x.ts_init)  # Ensure data is non-decreasing by `ts_init`\ndeltas[:10]\n```\n\n----------------------------------------\n\nTITLE: Loading and Wrangling Trade Data - Python\nDESCRIPTION: This snippet demonstrates how to load trade data from a CSV file using a TestDataProvider, initialize an instrument, and then wrangle the data into a list of Nautilus TradeTick objects using a TradeTickDataWrangler. This processed data is then ready to be added to the BacktestEngine.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Load stub test data\nprovider = TestDataProvider()\ntrades_df = provider.read_csv_ticks(\"binance/ethusdt-trades.csv\")\n\n# Initialize the instrument which matches the data\nETHUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()\n\n# Process into Nautilus objects\nwrangler = TradeTickDataWrangler(instrument=ETHUSDT_BINANCE)\nticks = wrangler.process(trades_df)\n```\n\n----------------------------------------\n\nTITLE: Configuration for Data and Execution Clients in Python\nDESCRIPTION: This code defines configuration classes for both live data and execution clients.  `TemplateDataClientConfig` and `TemplateExecClientConfig` inherit from `LiveDataClientConfig` and `LiveExecClientConfig` respectively. They specify required attributes for API authentication and connection details: `api_key`, `api_secret`, and `base_url`. These configurations are used to initialize and manage connections to data providers and venues.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/adapters.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import LiveDataClientConfig, LiveExecClientConfig\n\nclass TemplateDataClientConfig(LiveDataClientConfig):\n    \"\"\"\n    Configuration for ``TemplateDataClient`` instances.\n    \"\"\"\n\n    api_key: str\n    api_secret: str\n    base_url: str\n\nclass TemplateExecClientConfig(LiveExecClientConfig):\n    \"\"\"\n    Configuration for ``TemplateExecClient`` instances.\n    \"\"\"\n\n    api_key: str\n    api_secret: str\n    base_url: str\n```\n\n----------------------------------------\n\nTITLE: Adding Instruments and Data to Backtest Engine\nDESCRIPTION: This code snippet adds an instrument (USD/JPY) and its corresponding data to the backtest engine. It uses a `QuoteTickDataWrangler` to process bid and ask side bar data into quote ticks, which are then added to the engine. The data is read from CSV files using `TestDataProvider`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Add instruments\nUSDJPY_SIM = TestInstrumentProvider.default_fx_ccy(\"USD/JPY\", SIM)\nengine.add_instrument(USDJPY_SIM)\n\n# Add data\nwrangler = QuoteTickDataWrangler(instrument=USDJPY_SIM)\nticks = wrangler.process_bar_data(\n    bid_data=provider.read_csv_bars(\"fxcm/usdjpy-m1-bid-2013.csv\"),\n    ask_data=provider.read_csv_bars(\"fxcm/usdjpy-m1-ask-2013.csv\"),\n)\nengine.add_data(ticks)\n```\n\n----------------------------------------\n\nTITLE: Reading DBN Data from File\nDESCRIPTION: This snippet demonstrates how to load DBN data directly from a file using `db.DBNStore.from_file(path)`. It assumes that a DBN file exists at the specified path. The method reads the file contents and creates a DBNStore object. Then converts data from DBNStore format to a pandas DataFrame.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nloaded_dbn_data = db.DBNStore.from_file(path)\nloaded_dbn_data.to_df()\n```\n\n----------------------------------------\n\nTITLE: Writing DBN Data to ParquetDataCatalog in Python\nDESCRIPTION: This code demonstrates how to load DBN data from a file and write it to a `ParquetDataCatalog` in Nautilus Trader. It specifies `as_legacy_cython=False` to optimize for pyo3 (Rust) objects, which are then efficiently written to the catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the catalog interface\n# (will use the `NAUTILUS_PATH` env var as the path)\ncatalog = ParquetDataCatalog.from_env()\n\ninstrument_id = InstrumentId.from_str(\"TSLA.XNAS\")\n\n# Decode data to pyo3 objects\nloader = DatabentoDataLoader()\ntrades = loader.from_dbn_file(\n    path=TEST_DATA_DIR / \"databento\" / \"temp\" / \"tsla-xnas-20240107-20240206.trades.dbn.zst\",\n    instrument_id=instrument_id,\n    as_legacy_cython=False,  # This is an optimization for writing to the catalog\n)\n\n# Write data\ncatalog.write_data(trades)\n```\n\n----------------------------------------\n\nTITLE: Creating a Trailing Stop Limit Order in Python\nDESCRIPTION: This code snippet shows how to create a Trailing-Stop-Limit order using the Nautilus Trader framework. The order is placed on the Currenex FX ECN to buy 1,250,000 AUD using USD at a limit price of 0.71000 USD.  It activates at 0.72000 USD and trails at a stop offset of 0.00100 USD away from the current ask price, active until further notice. Requires the nautilus_trader library.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nfrom decimal import Decimal\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model.enums import TrailingOffsetType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import TrailingStopLimitOrder\n\norder: TrailingStopLimitOrder = self.order_factory.trailing_stop_limit(\n    instrument_id=InstrumentId.from_str(\"AUD/USD.CURRENEX\"),\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_int(1_250_000),\n    price=Price.from_str(\"0.71000\"),\n    trigger_price=Price.from_str(\"0.72000\"),\n    trigger_type=TriggerType.BID_ASK,  # <-- optional (default DEFAULT)\n    limit_offset=Decimal(\"0.00050\"),\n    trailing_offset=Decimal(\"0.00100\"),\n    trailing_offset_type=TrailingOffsetType.PRICE,\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    expire_time=None,  # <-- optional (default None)\n    reduce_only=True,  # <-- optional (default False)\n    tags=[\"TRAILING_STOP\"],  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Loading Bybit OrderBook data\nDESCRIPTION: This snippet constructs the data path, loads raw order book data from a zip file using the `BybitOrderBookDeltaDataLoader`, and limits the number of rows read.  It relies on the `pandas` library and `BybitOrderBookDeltaDataLoader` class from `nautilus_trader`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata_path = Path(DATA_DIR).expanduser() / \"Data\" / \"Bybit\"\nraw_files = list(data_path.iterdir())\nassert raw_files, f\"Unable to find any histdata files in directory {data_path}\"\nraw_files\n```\n\nLANGUAGE: python\nCODE:\n```\n# We'll use orderbook depth 500 data provided by Bybit with limit of 1000000 rows\npath_update = data_path / \"2024-12-01_XRPUSDT_ob500.data.zip\"\nnrows = 1_000_000\ndf_raw = BybitOrderBookDeltaDataLoader.load(path_update, nrows=nrows)\ndf_raw.head()\n```\n\n----------------------------------------\n\nTITLE: Defining IB Contracts\nDESCRIPTION: This section provides examples of how to define IBContract objects for various asset types, including stocks, bonds, options, CFDs, futures, forex, and crypto. These contracts are used to specify the instruments to be traded or for which to retrieve data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nIBContract(secType='STK', exchange='SMART', primaryExchange='ARCA', symbol='SPY')\n\n# Bond\nIBContract(secType='BOND', secIdType='ISIN', secId='US03076KAA60')\n\n# Option\nIBContract(secType='STK', exchange='SMART', primaryExchange='ARCA', symbol='SPY', lastTradeDateOrContractMonth='20251219', build_options_chain=True)\n\n# CFD\nIBContract(secType='CFD', symbol='IBUS30')\n\n# Future\nIBContract(secType='CONTFUT', exchange='CME', symbol='ES', build_futures_chain=True)\n\n# Forex\nIBContract(secType='CASH', exchange='IDEALPRO', symbol='EUR', currency='GBP')\n\n# Crypto\nIBContract(secType='CRYPTO', symbol='ETH', exchange='PAXOS', currency='USD')\n```\n\n----------------------------------------\n\nTITLE: Canceling All Orders (Python)\nDESCRIPTION: This snippet shows how to cancel all orders using the `cancel_all_orders()` method. It does not take any input parameters.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nself.cancel_all_orders()\n```\n\n----------------------------------------\n\nTITLE: Publishing Custom Data (Python)\nDESCRIPTION: This snippet demonstrates how to publish a custom data type (`MyDataPoint`) using the message bus in Nautilus Trader. It involves creating a `DataType` object with the custom data class and optional metadata, then calling `self.publish_data` to send the data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nself.publish_data(\n    DataType(MyDataPoint, metadata={\"some_optional_category\": 1}),\n    MyDataPoint(...),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Order Management Handlers in Python\nDESCRIPTION: This code snippet shows the method signatures for defining order management handlers within a Nautilus Trader strategy. These handlers receive events related to orders, allowing the strategy to react to order state changes such as acceptance, rejection, cancellation, and fills. `OrderEvent` messages are passed to handlers in a specific sequence.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.events import OrderAccepted\nfrom nautilus_trader.model.events import OrderCanceled\nfrom nautilus_trader.model.events import OrderCancelRejected\nfrom nautilus_trader.model.events import OrderDenied\nfrom nautilus_trader.model.events import OrderEmulated\nfrom nautilus_trader.model.events import OrderEvent\nfrom nautilus_trader.model.events import OrderExpired\nfrom nautilus_trader.model.events import OrderFilled\nfrom nautilus_trader.model.events import OrderInitialized\nfrom nautilus_trader.model.events import OrderModifyRejected\nfrom nautilus_trader.model.events import OrderPendingCancel\nfrom nautilus_trader.model.events import OrderPendingUpdate\nfrom nautilus_trader.model.events import OrderRejected\nfrom nautilus_trader.model.events import OrderReleased\nfrom nautilus_trader.model.events import OrderSubmitted\nfrom nautilus_trader.model.events import OrderTriggered\nfrom nautilus_trader.model.events import OrderUpdated\n\ndef on_order_initialized(self, event: OrderInitialized) -> None:\ndef on_order_denied(self, event: OrderDenied) -> None:\ndef on_order_emulated(self, event: OrderEmulated) -> None:\ndef on_order_released(self, event: OrderReleased) -> None:\ndef on_order_submitted(self, event: OrderSubmitted) -> None:\ndef on_order_rejected(self, event: OrderRejected) -> None:\ndef on_order_accepted(self, event: OrderAccepted) -> None:\ndef on_order_canceled(self, event: OrderCanceled) -> None:\ndef on_order_expired(self, event: OrderExpired) -> None:\ndef on_order_triggered(self, event: OrderTriggered) -> None:\ndef on_order_pending_update(self, event: OrderPendingUpdate) -> None:\ndef on_order_pending_cancel(self, event: OrderPendingCancel) -> None:\ndef on_order_modify_rejected(self, event: OrderModifyRejected) -> None:\ndef on_order_cancel_rejected(self, event: OrderCancelRejected) -> None:\ndef on_order_updated(self, event: OrderUpdated) -> None:\ndef on_order_filled(self, event: OrderFilled) -> None:\ndef on_order_event(self, event: OrderEvent) -> None:  # All order event messages are eventually passed to this handler\n```\n\n----------------------------------------\n\nTITLE: Creating a Market-To-Limit Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Market-To-Limit order in Nautilus Trader. It sets up a BUY order for 200,000 USD using JPY on the Interactive Brokers IdealPro Forex ECN. It uses the MarketToLimitOrder class, and sets parameters such as instrument_id, order_side, quantity, time_in_force, reduce_only, display_qty, and tags.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import MarketToLimitOrder\n\norder: MarketToLimitOrder = self.order_factory.market_to_limit(\n    instrument_id=InstrumentId.from_str(\"USD/JPY.IDEALPRO\"),\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_int(200_000),\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    reduce_only=False,  # <-- optional (default False)\n    display_qty=None,  # <-- optional (default None which indicates full display)\n    tags=None,  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Strategy Class in Python\nDESCRIPTION: This code snippet demonstrates how to initialize a strategy class in Nautilus Trader by inheriting from the `Strategy` class and calling the superclass constructor. This initialization is crucial for setting up the strategy and making it functional within the Nautilus Trader environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.trading.strategy import Strategy\n\nclass MyStrategy(Strategy):\n    def __init__(self) -> None:\n        super().__init__()  # <-- the super class must be called to initialize the strategy\n```\n\n----------------------------------------\n\nTITLE: Configuring a backtest run\nDESCRIPTION: This snippet creates a `BacktestRunConfig` object, which consolidates the configurations for the engine, data, and venues. It uses the previously defined `strategies`, `data_configs`, and `venue_configs` to configure the backtest run.  This object serves as a central configuration for the entire backtest process.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nconfig = BacktestRunConfig(\n    engine=BacktestEngineConfig(strategies=strategies),\n    data=data_configs,\n    venues=venue_configs,\n)\n```\n\n----------------------------------------\n\nTITLE: Instrument Access from Cache - Python\nDESCRIPTION: These snippets demonstrate how to access instrument data using the Nautilus Trader's `Cache`. It shows how to retrieve a specific instrument by its ID, get all instruments, and filter instruments based on venue and underlying asset. Requires `instrument_id` and `venue` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Get instrument information\ninstrument = self.cache.instrument(instrument_id) # Retrieve a specific instrument by its ID\nall_instruments = self.cache.instruments()        # Retrieve all instruments in the cache\n\n# Get filtered instruments\nvenue_instruments = self.cache.instruments(venue=venue)              # Instruments for a specific venue\ninstruments_by_underlying = self.cache.instruments(underlying=\"ES\")  # Instruments by underlying\n\n# Get instrument identifiers\ninstrument_ids = self.cache.instrument_ids()                   # Get all instrument IDs\nvenue_instrument_ids = self.cache.instrument_ids(venue=venue)  # Get instrument IDs for a specific venue\n```\n\n----------------------------------------\n\nTITLE: Strategy Implementation with Configuration\nDESCRIPTION: This code defines a strategy class `MyStrategy` that utilizes the `MyStrategyConfig`. It initializes the parent `Strategy` class, defines custom state variables, and overrides the `on_start` and `on_bar` methods to subscribe to bar data and update the count of processed bars.  Configuration parameters are accessed via `self.config`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Strategy definition\nclass MyStrategy(Strategy):\n    def __init__(self, config: MyStrategyConfig) -> None:\n        # Always initialize the parent Strategy class\n        # After this, configuration is stored and available via `self.config`\n        super().__init__(config)\n\n        # Custom state variables\n        self.time_started = None\n        self.count_of_processed_bars: int = 0\n\n    def on_start(self) -> None:\n        self.time_started = self.clock.utc_now()    # Remember time, when strategy started\n        self.subscribe_bars(self.config.bar_type)   # See how configuration data are exposed via `self.config`\n\n    def on_bar(self, bar: Bar):\n        self.count_of_processed_bars += 1           # Update count of processed bars\n```\n\n----------------------------------------\n\nTITLE: Formatting Long Method Parameters in Python\nDESCRIPTION: This code snippet demonstrates the recommended formatting style for methods with many parameters in Python. It emphasizes aligning arguments at the next logical indent, placing the closing parenthesis on a new line, and using a trailing comma after the last argument. This formatting enhances readability and simplifies future modifications.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/coding_standards.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nlong_method_with_many_params(\n    some_arg1,\n    some_arg2,\n    some_arg3,  # <-- trailing comma\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring backtest venues\nDESCRIPTION: This code snippet defines the configuration for the backtest venues. It creates a list containing a `BacktestVenueConfig` object, specifying the venue name, OMS type, account type, base currency, and starting balance.  This configuration is used when setting up the backtest environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nvenue_configs = [\n    BacktestVenueConfig(\n        name=\"SIM\",\n        oms_type=\"HEDGING\",\n        account_type=\"MARGIN\",\n        base_currency=\"USD\",\n        starting_balances=[\"1_000_000 USD\"],\n    ),\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Binance Clients for Futures Hedge Mode (Python)\nDESCRIPTION: This snippet demonstrates how to configure both data and execution clients for Binance Futures Hedge mode.  It configures the `account_type` to `BinanceAccountType.USDT_FUTURE` and sets the `use_reduce_only` option to `False` in the `BinanceExecClientConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"BINANCE\": BinanceDataClientConfig(\n            api_key=None,  # 'BINANCE_API_KEY' env var\n            api_secret=None,  # 'BINANCE_API_SECRET' env var\n            account_type=BinanceAccountType.USDT_FUTURE,\n            base_url_http=None,  # Override with custom endpoint\n            base_url_ws=None,  # Override with custom endpoint\n        ),\n    },\n    exec_clients={\n        \"BINANCE\": BinanceExecClientConfig(\n            api_key=None,  # 'BINANCE_API_KEY' env var\n            api_secret=None,  # 'BINANCE_API_SECRET' env var\n            account_type=BinanceAccountType.USDT_FUTURE,\n            base_url_http=None,  # Override with custom endpoint\n            base_url_ws=None,  # Override with custom endpoint\n            use_reduce_only=False,  # Must be disabled for Hedge mode\n        ),\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Default FX Currency Pair\nDESCRIPTION: This snippet demonstrates how to initialize a default FX currency pair using the TestInstrumentProvider in Nautilus Trader. It imports the provider and then creates an AUD/USD instrument.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n\naudusd = TestInstrumentProvider.default_fx_ccy(\"AUD/USD\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Databento Historical Client with API Key\nDESCRIPTION: This snippet initializes a Databento historical data client using the `databento` library. It demonstrates the recommended practice of using the `DATABENTO_API_KEY` environment variable for authentication. The client is then used for subsequent data requests.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport databento as db\n\n\nclient = db.Historical()  # This will use the DATABENTO_API_KEY environment variable (recommended best practice)\n```\n\n----------------------------------------\n\nTITLE: Configuring backtest data\nDESCRIPTION: This code snippet defines the configuration for the backtest data. It creates a list containing a `BacktestDataConfig` object, specifying the catalog path, data class (`QuoteTick`), instrument ID, start time, and end time. This configuration is used when setting up the backtest environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndata_configs = [\n    BacktestDataConfig(\n        catalog_path=str(CATALOG_PATH),\n        data_cls=QuoteTick,\n        instrument_id=instrument.id,\n        start_time=start,\n        end_time=end,\n    ),\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Interactive Brokers Instrument Provider\nDESCRIPTION: This code configures the InteractiveBrokersInstrumentProvider, which is used to fetch instrument data from Interactive Brokers. The configuration allows customization of symbology method, futures/options chain building, and loading specific instrument IDs or contracts.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig\nfrom nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod\n\n\ninstrument_provider_config = InteractiveBrokersInstrumentProviderConfig(\n    symbology_method=SymbologyMethod.IB_SIMPLIFIED,\n    build_futures_chain=False,  # Set to True if fetching futures\n    build_options_chain=False,  # Set to True if fetching options\n    min_expiry_days=10,         # Relevant for futures/options with expiration\n    max_expiry_days=60,         # Relevant for futures/options with expiration\n    load_ids=frozenset(\n        [\n            \"EUR/USD.IDEALPRO\",\n            \"BTC/USD.PAXOS\",\n            \"SPY.ARCA\",\n            \"V.NYSE\",\n            \"YMH24.CBOT\",\n            \"CLZ27.NYMEX\",\n            \"ESZ27.CME\",\n        ],\n    ),\n    load_contracts=frozenset(\n        [\n            IBContract(secType='STK', symbol='SPY', exchange='SMART', primaryExchange='ARCA'),\n            IBContract(secType='STK', symbol='AAPL', exchange='SMART', primaryExchange='NASDAQ')\n        ]\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Interactive Brokers Data Client\nDESCRIPTION: This code configures the InteractiveBrokersDataClient, which is used to stream and retrieve market data from Interactive Brokers. The configuration allows customization of the IB Gateway port, handling of revised bars, trading hours preferences, and market data type.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum\nfrom nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig\n\n\ndata_client_config = InteractiveBrokersDataClientConfig(\n    ibg_port=4002,\n    handle_revised_bars=False,\n    use_regular_trading_hours=True,\n    market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,  # Default is REALTIME if not set\n    instrument_provider=instrument_provider_config,\n    dockerized_gateway=dockerized_gateway_config,\n)\n```\n\n----------------------------------------\n\nTITLE: Running Tardis Replay in Python\nDESCRIPTION: This Python script demonstrates how to run a Tardis Machine replay using the `nautilus_pyo3` module.  It defines an asynchronous `run` function that resolves the configuration filepath and passes it to `nautilus_pyo3.run_tardis_machine_replay`. The script then uses `asyncio.run` to execute the `run` function.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom nautilus_trader.core import nautilus_pyo3\n\n\nasync def run():\n    config_filepath = Path(\"YOUR_CONFIG_FILEPATH\")\n    await nautilus_pyo3.run_tardis_machine_replay(str(config_filepath.resolve()))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n\n```\n\n----------------------------------------\n\nTITLE: Adding Execution Algorithm - Python\nDESCRIPTION: This snippet shows how to add a TWAP execution algorithm to the BacktestEngine. The execution algorithm is instantiated (using defaults) and added to the engine, allowing for order execution simulation during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Instantiate and add your execution algorithm\nexec_algorithm = TWAPExecAlgorithm()  # Using defaults\nengine.add_exec_algorithm(exec_algorithm)\n```\n\n----------------------------------------\n\nTITLE: Implementing LiveMarketDataClient in Python\nDESCRIPTION: This code snippet illustrates how to implement a LiveMarketDataClient for NautilusTrader. The LiveMarketDataClient manages market-specific data like order books and trades. It inherits from `LiveMarketDataClient` and overrides methods for connecting, disconnecting, subscribing/unsubscribing to instruments and order book deltas, resetting, and disposing resources.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/adapters.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.live.data_client import LiveMarketDataClient\nfrom nautilus_trader.model import BarType, DataType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model.enums import BookType\n\nclass TemplateLiveMarketDataClient(LiveMarketDataClient):\n    \"\"\"\n    An example of a ``LiveMarketDataClient`` highlighting the overridable abstract methods.\n    \"\"\"\n\n    async def _connect(self) -> None:\n        raise NotImplementedError(\"method `_connect` must be implemented in the subclass\")\n\n    async def _disconnect(self) -> None:\n        raise NotImplementedError(\"method `_disconnect` must be implemented in the subclass\")\n\n    def reset(self) -> None:\n        raise NotImplementedError(\"method `reset` must be implemented in the subclass\")\n\n    def dispose(self) -> None:\n        raise NotImplementedError(\"method `dispose` must be implemented in the subclass\")\n\n    async def _subscribe_instruments(self) -> None:\n        raise NotImplementedError(\"method `_subscribe_instruments` must be implemented in the subclass\")\n\n    async def _unsubscribe_instruments(self) -> None:\n        raise NotImplementedError(\"method `_unsubscribe_instruments` must be implemented in the subclass\")\n\n    async def _subscribe_order_book_deltas(self, instrument_id: InstrumentId, book_type: BookType, depth: int | None = None, kwargs: dict | None = None) -> None:\n        raise NotImplementedError(\"method `_subscribe_order_book_deltas` must be implemented in the subclass\")\n\n    async def _unsubscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:\n        raise NotImplementedError(\"method `_unsubscribe_order_book_deltas` must be implemented in the subclass\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving Shared Data from Cache - Python\nDESCRIPTION: This code illustrates how a Nautilus Trader strategy can retrieve shared data stored in the Cache by another strategy. It loads the data from the Cache using the same key used for storage and deserializes it using Python's `pickle` module. A check is performed to handle cases where the data is not available.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\n\nclass AnotherStrategy(Strategy):\n    def on_start(self):\n        # Load the shared data from the same key\n        data_bytes = self.cache.get(\"shared_strategy_info\")\n        if data_bytes is not None:\n            shared_data = pickle.loads(data_bytes)\n            self.log.info(f\"Shared data retrieved: {shared_data}\")\n```\n\n----------------------------------------\n\nTITLE: Loading Data with BinanceDataLoader and OrderBookDeltaWrangler (Python)\nDESCRIPTION: This example demonstrates how to load Binance order book delta data from a CSV file, process it using the OrderBookDeltaDataWrangler, and convert it into a list of Nautilus OrderBookDelta objects. It requires the `nautilus_trader` library and assumes the existence of a test data directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader import TEST_DATA_DIR\nfrom nautilus_trader.adapters.binance.loaders import BinanceOrderBookDeltaDataLoader\nfrom nautilus_trader.persistence.wranglers import OrderBookDeltaDataWrangler\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n\n\n# Load raw data\ndata_path = TEST_DATA_DIR / \"binance\" / \"btcusdt-depth-snap.csv\"\ndf = BinanceOrderBookDeltaDataLoader.load(data_path)\n\n# Set up a wrangler\ninstrument = TestInstrumentProvider.btcusdt_binance()\nwrangler = OrderBookDeltaDataWrangler(instrument)\n\n# Process to a list `OrderBookDelta` Nautilus objects\ndeltas = wrangler.process(df)\n```\n\n----------------------------------------\n\nTITLE: Writing data to ParquetDataCatalog in Python\nDESCRIPTION: This snippet writes the instrument EURUSD and the list of QuoteTick objects `ticks` to the ParquetDataCatalog. It stores the instrument definition and the processed tick data into the catalog for later use in backtesting.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Write instrument and ticks to catalog\ncatalog.write_data([EURUSD])\ncatalog.write_data(ticks)\n```\n\n----------------------------------------\n\nTITLE: Creating ParquetDataCatalog in Python\nDESCRIPTION: This snippet defines the path for the ParquetDataCatalog, removes the directory if it exists, creates a new directory, and instantiates a `ParquetDataCatalog` object pointing to the created directory. This sets up the data storage location for the backtesting environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nCATALOG_PATH = os.getcwd() + \"/catalog\"\n\n# Clear if it already exists, then create fresh\nif os.path.exists(CATALOG_PATH):\n    shutil.rmtree(CATALOG_PATH)\nos.mkdir(CATALOG_PATH)\n\n# Create a catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n```\n\n----------------------------------------\n\nTITLE: Listing raw data files from the specified directory\nDESCRIPTION: This snippet retrieves a list of files from the `DATA_DIR` and asserts that the directory is not empty. It uses pathlib to iterate through the directory and list the raw data files, ensuring the data is available for subsequent processing.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = Path(DATA_DIR).expanduser()\nraw_files = list(path.iterdir())\nassert raw_files, f\"Unable to find any histdata files in directory {path}\"\nraw_files\n```\n\n----------------------------------------\n\nTITLE: Generating Account Report\nDESCRIPTION: This code snippet generates an account report for the specified venue (SIM) using the `generate_account_report` method. This report provides a summary of the account's performance during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_account_report(SIM)\n```\n\n----------------------------------------\n\nTITLE: Implementing LiveDataClient in Python\nDESCRIPTION: This code snippet shows how to implement a LiveDataClient for NautilusTrader. The LiveDataClient handles data feeds not related to market data, such as news or custom data streams. It inherits from `LiveDataClient` and overrides methods for connecting, disconnecting, subscribing, unsubscribing, requesting data, resetting, and disposing resources.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/adapters.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.live.data_client import LiveDataClient\nfrom nautilus_trader.model import DataType\nfrom nautilus_trader.core import UUID4\n\nclass TemplateLiveDataClient(LiveDataClient):\n    \"\"\"\n    An example of a ``LiveDataClient`` highlighting the overridable abstract methods.\n    \"\"\"\n\n    async def _connect(self) -> None:\n        raise NotImplementedError(\"method `_connect` must be implemented in the subclass\")\n\n    async def _disconnect(self) -> None:\n        raise NotImplementedError(\"method `_disconnect` must be implemented in the subclass\")\n\n    def reset(self) -> None:\n        raise NotImplementedError(\"method `reset` must be implemented in the subclass\")\n\n    def dispose(self) -> None:\n        raise NotImplementedError(\"method `dispose` must be implemented in the subclass\")\n\n    async def _subscribe(self, data_type: DataType) -> None:\n        raise NotImplementedError(\"method `_subscribe` must be implemented in the subclass\")\n\n    async def _unsubscribe(self, data_type: DataType) -> None:\n        raise NotImplementedError(\"method `_unsubscribe` must be implemented in the subclass\")\n\n    async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:\n        raise NotImplementedError(\"method `_request` must be implemented in the subclass\")\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running a Trading Node with IB\nDESCRIPTION: This code demonstrates how to configure a TradingNode for live trading with Interactive Brokers, including setting up the data and execution client configurations, and running the node.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.common import IB_VENUE\nfrom nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory\nfrom nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory\nfrom nautilus_trader.config import LiveDataEngineConfig\nfrom nautilus_trader.config import LoggingConfig\nfrom nautilus_trader.config import TradingNodeConfig\nfrom nautilus_trader.live.node import TradingNode\n\n\n# ... [continuing from prior example code] ...\n\n# Configure the trading node\nconfig_node = TradingNodeConfig(\n    trader_id=\"TESTER-001\",\n    logging=LoggingConfig(log_level=\"INFO\"),\n    data_clients={\"IB\": data_client_config},\n    exec_clients={\"IB\": exec_client_config},\n    data_engine=LiveDataEngineConfig(\n        time_bars_timestamp_on_close=False,  # Use opening time as `ts_event`, as per IB standard\n        validate_data_sequence=True,         # Discards bars received out of sequence\n    ),\n)\n\nnode = TradingNode(config=config_node)\nnode.add_data_client_factory(\"IB\", InteractiveBrokersLiveDataClientFactory)\nnode.add_exec_client_factory(\"IB\", InteractiveBrokersLiveExecClientFactory)\nnode.build()\nnode.portfolio.set_specific_venue(IB_VENUE)\n\nif __name__ == \"__main__\":\n    try:\n        node.run()\n    finally:\n        # Stop and dispose of the node with SIGINT/CTRL+C\n        node.dispose()\n```\n\n----------------------------------------\n\nTITLE: Defining the data directory for raw data files\nDESCRIPTION: This code snippet defines the variable `DATA_DIR` which specifies the directory containing the raw CSV data files downloaded from histdata.com.  It is important to set this variable correctly so the program can find the data to load into the catalog. Ensure the path is properly expanded to the user's home directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nDATA_DIR = \"~/Downloads/Data/\"\n```\n\n----------------------------------------\n\nTITLE: Adding a Venue to the Backtest Engine\nDESCRIPTION: This code snippet adds a simulated FX ECN venue to the backtest engine.  It configures the venue with hedging OMS type, margin account type, no base currency (multi-currency account), starting balances in USD and JPY, the configured fill model, and the FX rollover interest module.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nSIM = Venue(\"SIM\")\nengine.add_venue(\n    venue=SIM,\n    oms_type=OmsType.HEDGING,  # Venue will generate position IDs\n    account_type=AccountType.MARGIN,\n    base_currency=None,  # Multi-currency account\n    starting_balances=[Money(1_000_000, USD), Money(10_000_000, JPY)],\n    fill_model=fill_model,\n    modules=[fx_rollover_interest],\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Interactive Brokers Execution Client\nDESCRIPTION: This code configures the InteractiveBrokersExecutionClient, which is used to execute trades and manage orders through Interactive Brokers. The configuration includes the IB Gateway port, account ID, instrument provider, and routing configuration.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig\nfrom nautilus_trader.config import RoutingConfig\n\n\nexec_client_config = InteractiveBrokersExecClientConfig(\n    ibg_port=4002,\n    account_id=\"DU123456\",  # Must match the connected IB Gateway/TWS\n    dockerized_gateway=dockerized_gateway_config,\n    instrument_provider=instrument_provider_config,\n    routing=RoutingConfig(\n        default=True,\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Requesting Cost Quote from Databento API\nDESCRIPTION: This snippet requests a cost estimate for a specific data request from the Databento API using the `get_cost` method. It specifies the dataset, symbols, stype_in, schema, start time, and end time. The response provides the cost in USD (fractional cents).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Request cost quote (USD) - this endpoint is 'free'\nclient.metadata.get_cost(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ES.n.0\"],\n    stype_in=\"continuous\",\n    schema=\"mbp-10\",\n    start=\"2023-12-06T14:30:00\",\n    end=\"2023-12-06T20:30:00\",\n)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for backtesting\nDESCRIPTION: This code snippet imports the required modules from Nautilus Trader and other libraries such as pandas for data manipulation and pathlib for file path handling. These imports are essential for setting up and running a backtest using Nautilus Trader.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport shutil\nfrom decimal import Decimal\nfrom pathlib import Path\n\nimport pandas as pd\n\nfrom nautilus_trader.backtest.node import BacktestDataConfig\nfrom nautilus_trader.backtest.node import BacktestEngineConfig\nfrom nautilus_trader.backtest.node import BacktestNode\nfrom nautilus_trader.backtest.node import BacktestRunConfig\nfrom nautilus_trader.backtest.node import BacktestVenueConfig\nfrom nautilus_trader.config import ImportableStrategyConfig\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos\nfrom nautilus_trader.model import QuoteTick\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\nfrom nautilus_trader.persistence.wranglers import QuoteTickDataWrangler\nfrom nautilus_trader.test_kit.providers import CSVTickDataLoader\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Creating a TradingNode and adding Bybit client factories\nDESCRIPTION: This code snippet demonstrates how to instantiate a `TradingNode`, register the `BybitLiveDataClientFactory` and `BybitLiveExecClientFactory`, and build the node. This sets up the necessary components for live trading with Bybit.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/bybit.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.bybit.factories import BybitLiveDataClientFactory\nfrom nautilus_trader.adapters.bybit.factories import BybitLiveExecClientFactory\nfrom nautilus_trader.live.node import TradingNode\n\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factories with the node\nnode.add_data_client_factory(\"BYBIT\", BybitLiveDataClientFactory)\nnode.add_exec_client_factory(\"BYBIT\", BybitLiveExecClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Run the Configured Backtest\nDESCRIPTION: This code snippet creates a `BacktestNode` with the configured backtest settings and then runs the backtest using `node.run()`.  The result of the backtest is stored in the `result` variable.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nnode = BacktestNode(configs=[config])\n\nresult = node.run()\n```\n\n----------------------------------------\n\nTITLE: Registering dYdX Client Factories with TradingNode\nDESCRIPTION: This Python code snippet shows how to register the dYdX data and execution client factories with a Nautilus Trader TradingNode. This registration allows the TradingNode to create and manage dYdX clients during its lifecycle.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.dydx.factories import DYDXLiveDataClientFactory\nfrom nautilus_trader.adapters.dydx.factories import DYDXLiveExecClientFactory\nfrom nautilus_trader.live.node import TradingNode\n\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factories with the node\nnode.add_data_client_factory(\"DYDX\", DYDXLiveDataClientFactory)\nnode.add_exec_client_factory(\"DYDX\", DYDXLiveExecClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Instrument provider configuration in Python\nDESCRIPTION: This code configures the instrument provider.  The first example loads all instruments from specified venues, requiring filtering for desired exchanges. The second example loads specific instruments using their IDs.  Instruments must be available in the cache for subscriptions.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import InstrumentProviderConfig\n\n# See supported venues https://nautilustrader.io/docs/nightly/integrations/tardis#venues\nvenues = {\"BINANCE\", \"BYBIT\"}\nfilters = {\"venues\": frozenset(venues)}\ninstrument_provider_config = InstrumentProviderConfig(load_all=True, filters=filters)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import InstrumentProviderConfig\n\ninstrument_ids = [\n    InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\"),  # Will use the 'binance-futures' exchange\n    InstrumentId.from_str(\"BTCUSDT.BINANCE\"),  # Will use the 'binance' exchange\n]\ninstrument_provider_config = InstrumentProviderConfig(load_ids=instrument_ids)\n```\n\n----------------------------------------\n\nTITLE: Configuring a Fill Model with Custom Probabilities - Python\nDESCRIPTION: This code snippet demonstrates how to create and configure a custom FillModel in Nautilus Trader. It shows how to set the probabilities for filling limit orders (`prob_fill_on_limit`) and experiencing slippage (`prob_slippage`). The custom FillModel is then injected into the BacktestEngine configuration.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/backtesting.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.backtest.models import FillModel\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.backtest.engine import BacktestEngineConfig\n\n# Create a custom fill model with your desired probabilities\nfill_model = FillModel(\n    prob_fill_on_limit=0.2,    # Chance a limit order fills when price matches (applied to bars/trades/quotes + L1/L2/L3 orderbook)\n    prob_fill_on_stop=0.95,    # [DEPRECATED] Will be removed in a future version, use `prob_slippage` instead\n    prob_slippage=0.5,         # Chance of 1-tick slippage (applied to bars/trades/quotes + L1 orderbook only)\n    random_seed=None,          # Optional: Set for reproducible results\n)\n\n# Add the fill model to your engine configuration\nengine = BacktestEngine(\n    config=BacktestEngineConfig(\n        trader_id=\"TESTER-001\",\n        fill_model=fill_model,  # Inject your custom fill model here\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Time Series Data using Databento get_range\nDESCRIPTION: This snippet retrieves time series data from Databento using the `get_range` method, which streams the data directly into the application. It configures parameters such as the dataset, symbols (ESM2), schema (ohlcv-1h), start time, end time, and an optional limit on the number of results. The retrieved data is returned in DBNStore format, containing historical market data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndata = client.timeseries.get_range(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],            # ES (S&P contract) expiring in June 2022\n    schema=\"ohlcv-1h\",           # Hourly bars\n    start=\"2022-06-01T00:00:00\",\n    end=\"2022-06-03T00:10:00\",\n    limit=5,                    # Optional limit on count of results\n)\n\n# Data are received in DBNStore format\ndata\n```\n\n----------------------------------------\n\nTITLE: Initializing Databento Historical Client in Python\nDESCRIPTION: This snippet demonstrates how to initialize the Databento Historical client using an API key.  The API key is required for authentication. Replace the placeholder API key with a valid key. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport databento as db\n\n\n# Establish connection and authenticate\nAPI_KEY = \"db-8VWGBis54s4ewGVciMRakNxLCJKen\"   # put your API key here (existing key is just example, not real)\nclient = db.Historical(API_KEY)\n```\n\n----------------------------------------\n\nTITLE: Resetting the Engine - Python\nDESCRIPTION: This snippet demonstrates how to reset the BacktestEngine for repeated runs with different configurations. This clears the state but retains data and components, allowing for efficient backtesting of multiple scenarios.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# For repeated backtest runs make sure to reset the engine\nengine.reset()\n```\n\n----------------------------------------\n\nTITLE: Configuring Backtest Run\nDESCRIPTION: This snippet defines the configuration for the backtest run, including data, venues, and strategy configurations. It creates `BacktestDataConfig`, `BacktestVenueConfig`, and `ImportableStrategyConfig` objects, then combines them into a `BacktestRunConfig` for the backtest node.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ninstrument = catalog.instruments()[0]\nbook_type = \"L2_MBP\"  # Ensure data book type matches venue book type\n\ndata_configs = [\n    BacktestDataConfig(\n        catalog_path=CATALOG_PATH,\n        data_cls=OrderBookDelta,\n        instrument_id=instrument.id,\n        # start_time=start,  # Run across all data\n        # end_time=end,  # Run across all data\n    )\n]\n\nvenues_configs = [\n    BacktestVenueConfig(\n        name=\"BYBIT\",\n        oms_type=\"NETTING\",\n        account_type=\"CASH\",\n        base_currency=None,\n        starting_balances=[\"200000 XRP\", \"100000 USDT\"],\n        book_type=book_type,  # <-- Venues book type\n    )\n]\n\nstrategies = [\n    ImportableStrategyConfig(\n        strategy_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalance\",\n        config_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalanceConfig\",\n        config={\n            \"instrument_id\": instrument.id,\n            \"book_type\": book_type,\n            \"max_trade_size\": Decimal(\"1.000\"),\n            \"min_seconds_between_triggers\": 1.0,\n        },\n    ),\n]\n\n# NautilusTrader currently exceeds the rate limit for Jupyter notebook logging (stdout output),\n# this is why the `log_level` is set to \"ERROR\". If you lower this level to see\n# more logging then the notebook will hang during cell execution. A fix is currently\n# being investigated which involves either raising the configured rate limits for\n# Jupyter, or throttling the log flushing from Nautilus.\n# https://github.com/jupyterlab/jupyterlab/issues/12845\n# https://github.com/deshaw/jupyterlab-limit-output\nconfig = BacktestRunConfig(\n    engine=BacktestEngineConfig(\n        strategies=strategies,\n        logging=LoggingConfig(log_level=\"ERROR\"),\n    ),\n    data=data_configs,\n    venues=venues_configs,\n)\n\nconfig\n```\n\n----------------------------------------\n\nTITLE: Position Statistics from Cache - Python\nDESCRIPTION: This code snippet demonstrates how to retrieve position statistics using the Nautilus Trader's `Cache`. It shows how to get counts of positions in different states (open, closed, total) and filter position counts by position side and instrument ID. Requires `PositionSide` and `instrument_id` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Get position counts in different states\nopen_count = self.cache.positions_open_count()      # Number of currently open positions\nclosed_count = self.cache.positions_closed_count()  # Number of closed positions\ntotal_count = self.cache.positions_total_count()    # Total number of positions in the system\n\n# Get filtered position counts\nlong_positions_count = self.cache.positions_open_count(side=PositionSide.LONG)              # Number of open long positions\ninstrument_positions_count = self.cache.positions_total_count(instrument_id=instrument_id)  # Number of positions for a given instrument\n```\n\n----------------------------------------\n\nTITLE: Setting a Timer (Python)\nDESCRIPTION: This snippet demonstrates how to set a timer using the `clock.set_timer()` method.  A `TimeEvent` will be generated at regular intervals until the timer expires or is cancelled. It requires the `pandas` library for handling time deltas. The `self.clock` attribute provides access to the Clock instance. The name and interval arguments are required.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nself.clock.set_timer(\n    name=\"MyTimer1\",\n    interval=pd.Timedelta(minutes=1),\n)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Instrument Updates\nDESCRIPTION: This snippet shows how to subscribe to changes for a specific instrument in Nautilus Trader using its ID. Assumes `self` has a `subscribe_instrument` method. Requires an instrument ID to subscribe.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nself.subscribe_instrument(instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Creating a Stop-Limit Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Stop-Limit order in Nautilus Trader. It creates a BUY order for 50,000 GBP on Currenex FX ECN, with a limit price of 1.3000 USD, triggered when the market hits 1.30010 USD based on the bid price, expiring on June 6th, 2022. It employs the StopLimitOrder class and configures parameters like instrument_id, order_side, quantity, price, trigger_price, trigger_type, time_in_force, expire_time, post_only, reduce_only, and tags. It also imports the pandas library for timestamp handling.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import StopLimitOrder\n\norder: StopLimitOrder = self.order_factory.stop_limit(\n    instrument_id=InstrumentId.from_str(\"GBP/USD.CURRENEX\"),\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_int(50_000),\n    price=Price.from_str(\"1.30000\"),\n    trigger_price=Price.from_str(\"1.30010\"),\n    trigger_type=TriggerType.BID,  # <-- optional (default DEFAULT)\n    time_in_force=TimeInForce.GTD,  # <-- optional (default GTC)\n    expire_time=pd.Timestamp(\"2022-06-06T12:00\"),\n    post_only=True,  # <-- optional (default False)\n    reduce_only=False,  # <-- optional (default False)\n    tags=None,  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Market Data Strategy Initialization and Bar Handling - Python\nDESCRIPTION: This code snippet demonstrates a simple market data strategy within Nautilus Trader.  It initializes the strategy by subscribing to 1-minute bars for a specific instrument and then processes incoming bar data, accessing recent bars, quote, and trade information for analysis. The `instrument_id` should be formatted like \"EUR/USD.FXCM\".\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass MarketDataStrategy(Strategy):\n    def on_start(self):\n        # Subscribe to 1-minute bars\n        self.bar_type = BarType.from_str(f\"{self.instrument_id}-1-MINUTE-LAST-EXTERNAL\")  # example of instrument_id = \"EUR/USD.FXCM\"\n        self.subscribe_bars(self.bar_type)\n\n    def on_bar(self, bar: Bar) -> None:\n        bars = self.cache.bars(self.bar_type)[:3]\n        if len(bars) < 3:   # Wait until we have at least 3 bars\n            return\n\n        # Access last 3 bars for analysis\n        current_bar = bars[0]    # Most recent bar\n        prev_bar = bars[1]       # Second to last bar\n        prev_prev_bar = bars[2]  # Third to last bar\n\n        # Get latest quote and trade\n        latest_quote = self.cache.quote_tick(self.instrument_id)\n        latest_trade = self.cache.trade_tick(self.instrument_id)\n\n        if latest_quote is not None:\n            current_spread = latest_quote.ask_price - latest_quote.bid_price\n            self.log.info(f\"Current spread: {current_spread}\")\n```\n\n----------------------------------------\n\nTITLE: Running BacktestNode in Python\nDESCRIPTION: This snippet creates a BacktestNode with the configured backtest run configurations and executes the backtest. It then retrieves the results of the backtest run.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnode = BacktestNode(configs=[config])\n\n[result] = node.run()\n```\n\n----------------------------------------\n\nTITLE: Configuring a TradingNode with Bybit data and execution clients\nDESCRIPTION: This code snippet demonstrates how to configure a live `TradingNode` to include Bybit data and execution clients. It showcases setting API keys, secrets, base URLs, product types, and testnet flag within the `TradingNodeConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/bybit.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.bybit.common.enums import BybitProductType\nfrom nautilus_trader.live.node import TradingNode\n\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"BYBIT\": {\n            \"api_key\": \"YOUR_BYBIT_API_KEY\",\n            \"api_secret\": \"YOUR_BYBIT_API_SECRET\",\n            \"base_url_http\": None,  # Override with custom endpoint\n            \"product_types\": [BybitProductType.LINEAR]\n            \"testnet\": False,\n        },\n    },\n    exec_clients={\n        \"BYBIT\": {\n            \"api_key\": \"YOUR_BYBIT_API_KEY\",\n            \"api_secret\": \"YOUR_BYBIT_API_SECRET\",\n            \"base_url_http\": None,  # Override with custom endpoint\n            \"product_types\": [BybitProductType.LINEAR]\n            \"testnet\": False,\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring dYdX Data and Execution Clients in TradingNode\nDESCRIPTION: This Python code shows how to configure dYdX data and execution clients within a Nautilus Trader TradingNode. It demonstrates setting wallet address, subaccount, mnemonic, and testnet status in the configuration for both data and execution clients.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.live.node import TradingNode\n\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"DYDX\": {\n            \"wallet_address\": \"YOUR_DYDX_WALLET_ADDRESS\",\n            \"is_testnet\": False,\n        },\n    },\n    exec_clients={\n        \"DYDX\": {\n            \"wallet_address\": \"YOUR_DYDX_WALLET_ADDRESS\",\n            \"subaccount\": \"YOUR_DYDX_SUBACCOUNT_NUMBER\"\n            \"mnemonic\": \"YOUR_MNEMONIC\",\n            \"is_testnet\": False,\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Composite BarType using from_str in Python\nDESCRIPTION: This code snippet demonstrates how to define a composite BarType object in NautilusTrader using the `from_str` method.  The example creates a BarType for AAPL trades (last price) on Nasdaq (XNAS) using a 5-minute interval aggregated locally by Nautilus, from 1-minute interval bars aggregated externally. This requires the `BarType` class to be imported or available in the current scope.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbar_type = BarType.from_str(\"AAPL.XNAS-5-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL\")\n```\n\n----------------------------------------\n\nTITLE: Requesting Historical Data from Databento API\nDESCRIPTION: This snippet requests historical time series data from the Databento API using the `timeseries.get_range` method. It checks if the data already exists on disk. If not, it makes the request, specifying the dataset, symbols, stype_in, schema, start time, end time, and the file path for saving the data.  Passing a `path` parameter will ensure the data is written to disk.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npath = DATABENTO_DATA_DIR / \"es-front-glbx-mbp10.dbn.zst\"\n\nif not path.exists():\n    # Request data\n    client.timeseries.get_range(\n        dataset=\"GLBX.MDP3\",\n        symbols=[\"ES.n.0\"],\n        stype_in=\"continuous\",\n        schema=\"mbp-10\",\n        start=\"2023-12-06T14:30:00\",\n        end=\"2023-12-06T20:30:00\",\n        path=path,  # <-- Passing a `path` parameter will ensure the data is written to disk\n    )\n```\n\n----------------------------------------\n\nTITLE: Requesting Historical and Subscribing to Live Bars in Nautilus (Python)\nDESCRIPTION: This code showcases how to use `request_bars()` to load historical data and `subscribe_bars()` to establish a real-time data feed. It outlines the typical workflow of first requesting historical data to initialize the strategy, then subscribing to real-time updates and registering the indicator for updates.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef on_start(self) -> None:\n    # Define bar type\n    bar_type = BarType.from_str(\"6EH4.XCME-5-MINUTE-LAST-INTERNAL\")\n\n    # Request historical data to initialize indicators\n    # These bars will be delivered to the on_historical_data(...) handler in strategy\n    self.request_bars(bar_type)\n\n    # Subscribe to real-time updates\n    # New bars will be delivered to the on_bar(...) handler in strategy\n    self.subscribe_bars(bar_type)\n\n    # Register indicators to receive bar updates (they will be automatically updated)\n    self.register_indicator_for_bars(bar_type, self.my_indicator)\n```\n\n----------------------------------------\n\nTITLE: Requesting and Saving Historical Data with IB\nDESCRIPTION: This code demonstrates how to use the HistoricInteractiveBrokersClient to request and save historical instrument and bar data from Interactive Brokers. It retrieves data for a specified contract, bar specifications, and time range, then saves the data to a ParquetDataCatalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nfrom nautilus_trader.adapters.interactive_brokers.common import IBContract\nfrom nautilus_trader.adapters.interactive_brokers.historic import HistoricInteractiveBrokersClient\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\n\n\nasync def main():\n    contract = IBContract(\n        secType=\"STK\",\n        symbol=\"AAPL\",\n        exchange=\"SMART\",\n        primaryExchange=\"NASDAQ\",\n    )\n    client = HistoricInteractiveBrokersClient()\n\n    instruments = await client.request_instruments(\n        contracts=[contract],\n    )\n\n    bars = await client.request_bars(\n        bar_specifications=[\"1-HOUR-LAST\", \"30-MINUTE-MID\"],\n        end_date_time=datetime.datetime(2023, 11, 6, 16, 30),\n        tz_name=\"America/New_York\",\n        duration=\"1 D\",\n        contracts=[contract],\n    )\n\n    catalog = ParquetDataCatalog(\"./catalog\")\n    catalog.write_data(instruments)\n    catalog.write_data(bars)\n```\n\n----------------------------------------\n\nTITLE: Creating Backtest Run Configuration\nDESCRIPTION: This snippet creates a BacktestRunConfig object that combines the engine configuration, venue information, and data. This configuration object encapsulates all the necessary parameters for a backtest run.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nconfig = BacktestRunConfig(\n    engine=engine,\n    venues=[venue],\n    data=[data],\n)\n```\n\n----------------------------------------\n\nTITLE: Coinbase International Trading Node Configuration\nDESCRIPTION: This Python code snippet demonstrates how to configure a TradingNode for Coinbase International in NautilusTrader, including configuring instrument providers for both data and execution clients. It is important to set `load_all=True` to load instruments.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.coinbase_intx.constants import COINBASE_INTX\nfrom nautilus_trader.live.node import TradingNode\n\nconfig = TradingNodeConfig(\n    ...,  # Further config omitted\n    data_clients={\n        COINBASE_INTX: CoinbaseIntxDataClientConfig(\n            instrument_provider=InstrumentProviderConfig(load_all=True),\n        ),\n    },\n    exec_clients={\n        COINBASE_INTX: CoinbaseIntxExecClientConfig(\n            instrument_provider=InstrumentProviderConfig(load_all=True),\n        ),\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Loading Tardis CSV data in Python\nDESCRIPTION: This code snippet demonstrates how to load Tardis-format CSV data using the `TardisCSVDataLoader` in Python. It requires specifying the price precision and size precision, and optionally an instrument ID, to properly parse the CSV data into Nautilus data structures. The snippet loads delta data from a specified filepath, optionally limiting the number of rows loaded.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.tardis.loaders import TardisCSVDataLoader\nfrom nautilus_trader.model import InstrumentId\n\n\ninstrument_id = InstrumentId.from_str(\"BTC-PERPETUAL.DERIBIT\")\nloader = TardisCSVDataLoader(\n    price_precision=1,\n    size_precision=0,\n    instrument_id=instrument_id,\n)\n\nfilepath = Path(\"YOUR_CSV_DATA_PATH\")\nlimit = None\n\ndeltas = loader.load_deltas(filepath, limit)\n```\n\n----------------------------------------\n\nTITLE: Generating Backtest Reports\nDESCRIPTION: These snippets demonstrate how to generate order fill, position, and account reports after the backtest has completed. They access the `BacktestEngine` and use its `trader` property to generate the reports using `generate_order_fills_report`, `generate_positions_report`, and `generate_account_report`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.model import Venue\n\n\nengine: BacktestEngine = node.get_engine(config.id)\n\nengine.trader.generate_order_fills_report()\n```\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_positions_report()\n```\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_account_report(Venue(\"BYBIT\"))\n```\n\n----------------------------------------\n\nTITLE: Setting a Time Alert (Python)\nDESCRIPTION: This snippet demonstrates how to set a time alert using the `clock.set_time_alert()` method.  A `TimeEvent` will be dispatched at the specified alert time. It requires the `pandas` library for handling time deltas. The `self.clock` attribute provides access to the Clock instance. The name and alert_time arguments are required.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nself.clock.set_time_alert(\n    name=\"MyTimeAlert1\",\n    alert_time=self.clock.utc_now() + pd.Timedelta(minutes=1),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Venue with Adaptive Bar Ordering - Python\nDESCRIPTION: This code snippet shows how to configure a venue in Nautilus Trader to use adaptive bar ordering. It enables the `bar_adaptive_high_low_ordering` parameter, which dynamically adjusts the order of high and low prices based on the relationship between the open price and the high/low prices of the bar.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/backtesting.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Configure venue with adaptive bar ordering\nengine.add_venue(\n    venue=venue,\n    oms_type=OmsType.NETTING,\n    bar_adaptive_high_low_ordering=True,  # Enable adaptive ordering of High/Low bar prices\n)\n```\n\n----------------------------------------\n\nTITLE: Requesting Cost Quote for AAPL Trades from Databento API\nDESCRIPTION: This snippet requests a cost estimate for AAPL trade data from the Databento API for January 2024. It specifies the dataset, symbol, schema, and start time.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Request cost quote (USD) - this endpoint is 'free'\nclient.metadata.get_cost(\n    dataset=\"XNAS.ITCH\",\n    symbols=[\"AAPL\"],\n    schema=\"trades\",\n    start=\"2024-01\",\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Consumer Node for External Stream and Client ID\nDESCRIPTION: This code snippet configures a consumer node to receive messages from the 'binance' stream and publish them onto its internal message bus. It defines 'BINANCE_EXT' as an external client using the `LiveDataEngineConfig`, preventing duplicate data commands. The `MessageBusConfig` is set up to subscribe to the 'binance' stream using `external_streams`. The `timeout` parameter in `DatabaseConfig` sets the database timeout.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndata_engine=LiveDataEngineConfig(\n    external_clients=[ClientId(\"BINANCE_EXT\")],\n),\nmessage_bus=MessageBusConfig(\n    database=DatabaseConfig(timeout=2),\n    external_streams=[\"binance\"],  # <---\n),\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Custom Data (Python)\nDESCRIPTION: This snippet demonstrates how to subscribe to a custom data type (`MyDataPoint`) within an actor or strategy in Nautilus Trader. It uses `self.subscribe_data` with a `DataType` object specifying the custom data class and optional metadata, along with a `ClientId` to route the data subscription.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nself.subscribe_data(\n    data_type=DataType(MyDataPoint,\n    metadata={\"some_optional_category\": 1}),\n    client_id=ClientId(\"MY_ADAPTER\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Reading Data from Nautilus Data Catalog\nDESCRIPTION: This snippet reads order book depth data from the Nautilus data catalog using `catalog.order_book_depth10()`. It then prints the length of the retrieved data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Test reading from catalog\ndepths = catalog.order_book_depth10()\nlen(depths)\n```\n\n----------------------------------------\n\nTITLE: BacktestDataConfig with Custom Data (Python)\nDESCRIPTION: This snippet demonstrates how to pass extra metadata information to a `BacktestDataConfig` configuration object in order to enrich and describe custom data objects used in a backtesting context.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import BacktestDataConfig\n\ndata_config = BacktestDataConfig(\n    catalog_path=str(catalog.path),\n    data_cls=MyDataPoint,\n    metadata={\"some_optional_category\": 1},\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Instruments from the Parquet Data Catalog\nDESCRIPTION: This snippet demonstrates how to retrieve a list of instruments stored in the Parquet Data Catalog.  It calls the `instruments()` method on the catalog instance, which returns a list of all instruments available in the catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Get list of all instruments in catalog\ncatalog.instruments()\n```\n\n----------------------------------------\n\nTITLE: Write Instrument and Ticks to Data Catalog\nDESCRIPTION: This code snippet writes the instrument and the processed order book deltas (`deltas`) to the Parquet data catalog using the `catalog.write_data()` method.  This persists the data for later use in backtesting.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Write instrument and ticks to catalog\ncatalog.write_data([BTCUSDT_BINANCE])\ncatalog.write_data(deltas)\n```\n\n----------------------------------------\n\nTITLE: Set Up Parquet Data Catalog for Data Storage\nDESCRIPTION: This code snippet sets up a Parquet data catalog for storing instrument and tick data. It first defines the catalog path, removes the catalog if it already exists, creates a new directory for the catalog, and then instantiates a `ParquetDataCatalog` object.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nCATALOG_PATH = os.getcwd() + \"/catalog\"\n\n# Clear if it already exists, then create fresh\nif os.path.exists(CATALOG_PATH):\n    shutil.rmtree(CATALOG_PATH)\nos.mkdir(CATALOG_PATH)\n\n# Create a catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader from Source with Binance Dependencies\nDESCRIPTION: This command installs `nautilus_trader` from source using the uv package manager. The `--extra binance` flag ensures that all dependencies required for the Binance integration are included.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuv sync --extra binance\n```\n\n----------------------------------------\n\nTITLE: Creating Price And Quantity\nDESCRIPTION: This snippet demonstrates how to create valid prices and quantities based on given values, using the instrument object in Nautilus Trader. It retrieves the instrument from the cache and then uses `make_price` and `make_qty` methods.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ninstrument = self.cache.instrument(instrument_id)\n\nprice = instrument.make_price(0.90500)\nquantity = instrument.make_qty(150)\n```\n\n----------------------------------------\n\nTITLE: Writing DBN Data to CSV\nDESCRIPTION: This snippet demonstrates how to export DBN data to a CSV file using the `to_csv` method.  It configures parameters such as the dataset, symbols (ESM2), schema (ohlcv-1h), start time, and limit on the number of results.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndbn_data = client.timeseries.get_range(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],\n    schema=\"ohlcv-1h\",\n    start=\"2022-06-06\",\n    limit=3\n)\n\n# Export to CSV file\ndbn_data.to_csv(\"GLBX-ESM2-20220606-ohlcv-1h.csv\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Data Class (Python)\nDESCRIPTION: This snippet defines a custom data class `MyDataPoint` that inherits from the `Data` base class in Nautilus Trader. It includes example user-defined fields (label, x, y, z) and the required `ts_event` and `ts_init` properties for timestamping data events. This custom data type can then be used in backtesting and live trading.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core import Data\n\n\nclass MyDataPoint(Data):\n    \"\"\"\n    This is an example of a user-defined data class, inheriting from the base class `Data`.\n\n    The fields `label`, `x`, `y`, and `z` in this class are examples of arbitrary user data.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str,\n        x: int,\n        y: int,\n        z: int,\n        ts_event: int,\n        ts_init: int,\n    ) -> None:\n        self.label = label\n        self.x = x\n        self.y = y\n        self.z = z\n        self._ts_event = ts_event\n        self._ts_init = ts_init\n\n    @property\n    def ts_event(self) -> int:\n        \"\"\"\n        UNIX timestamp (nanoseconds) when the data event occurred.\n\n        Returns\n        -------\n        int\n\n        \"\"\"\n        return self._ts_event\n\n    @property\n    def ts_init(self) -> int:\n        \"\"\"\n        UNIX timestamp (nanoseconds) when the object was initialized.\n\n        Returns\n        -------\n        int\n\n        \"\"\"\n        return self._ts_init\n```\n\n----------------------------------------\n\nTITLE: Configuring Producer Node Message Bus for External Stream\nDESCRIPTION: This code snippet configures the MessageBus of a producer node to publish to a 'binance' stream. The `use_trader_id`, `use_trader_prefix`, and `use_instance_id` settings are set to `False` to create a simple and predictable stream key. The `streams_prefix` is set to 'binance', which defines the stream name for publishing data. The `autotrim_mins` parameter specifies how long messages are retained.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmessage_bus=MessageBusConfig(\n    database=DatabaseConfig(timeout=2),\n    use_trader_id=False,\n    use_trader_prefix=False,\n    use_instance_id=False,\n    streams_prefix=\"binance\",  # <---\n    stream_per_topic=False,\n    autotrim_mins=30,\n),\n```\n\n----------------------------------------\n\nTITLE: MessageBus Publish/Subscribe Example - Python\nDESCRIPTION: This snippet illustrates a publish/subscribe pattern using the MessageBus in Nautilus Trader. It defines a custom event `Each10thBarEvent`, subscribes to a topic, publishes an event, and defines a handler to process the received event.  This is a lower-level approach that requires manual handling of topic names and event types.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.core.message import Event\n\n# Define a custom event\nclass Each10thBarEvent(Event):\n    TOPIC = \"each_10th_bar\"  # Topic name\n    def __init__(self, bar):\n        self.bar = bar\n\n# Subscribe in a component (in Strategy)\nself.msgbus.subscribe(Each10thBarEvent.TOPIC, self.on_each_10th_bar)\n\n# Publish an event (in Strategy)\nevent = Each10thBarEvent(bar)\nself.msgbus.publish(Each10thBarEvent.TOPIC, event)\n\n# Handler (in Strategy)\ndef on_each_10th_bar(self, event: Each10thBarEvent):\n    self.log.info(f\"Received 10th bar: {event.bar}\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Data from Cache (Python)\nDESCRIPTION: This snippet demonstrates how to fetch data (quote ticks, trade ticks, and bars) from the cache using the `cache` attribute. It assumes that an `instrument_id` attribute is assigned and a `bar_type` variable is defined. Access to recent market data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nlast_quote = self.cache.quote_tick(self.instrument_id)\nlast_trade = self.cache.trade_tick(self.instrument_id)\nlast_bar = self.cache.bar(bar_type)\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies with uv\nDESCRIPTION: This command uses uv to install all development and test dependencies defined in the project. The `--active` flag activates the virtual environment, `--all-groups` installs all dependency groups, and `--all-extras` installs all extras. uv is the recommended tool for managing python virtual environments and dependencies.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuv sync --active --all-groups --all-extras\n```\n\n----------------------------------------\n\nTITLE: Running the Backtest\nDESCRIPTION: This code snippet initiates the backtest run.  The `engine.run()` method executes the backtest using the configured settings, data, and strategies.  Once completed, a post-analysis report is logged to the console.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nengine.run()\n```\n\n----------------------------------------\n\nTITLE: Loading CSV data into a Pandas DataFrame\nDESCRIPTION: This code snippet loads the first CSV data file into a pandas DataFrame. It uses the `CSVTickDataLoader` to read the data, specify column names, and parse the timestamp column.  The resulting DataFrame contains the timestamp, bid price, and ask price, and is sorted by timestamp.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Here we just take the first data file found and load into a pandas DataFrame\ndf = CSVTickDataLoader.load(\n    file_path=raw_files[0],                                   # Input 1st CSV file\n    index_col=0,                                              # Use 1st column in data as index for dataframe\n    header=None,                                              # There are no column names in CSV files\n    names=[\"timestamp\", \"bid_price\", \"ask_price\", \"volume\"],  # Specify names to individual columns\n    usecols=[\"timestamp\", \"bid_price\", \"ask_price\"],          # Read only these columns from CSV file into dataframe\n    parse_dates=[\"timestamp\"],                                # Specify columns containing date/time\n    date_format=\"%Y%m%d %H%M%S%f\",                            # Format for parsing datetime\n)\n\n# Let's make sure data are sorted by timestamp\ndf = df.sort_index()\n\n# Preview of loaded dataframe\ndf.head(2)\n```\n\n----------------------------------------\n\nTITLE: Generate Account Report for Venue\nDESCRIPTION: This code snippet generates an account report for a specific venue (\"BINANCE\") using `engine.trader.generate_account_report(Venue(\"BINANCE\"))`.  This report provides a summary of the account's performance and balances at the specified venue during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_account_report(Venue(\"BINANCE\"))\n```\n\n----------------------------------------\n\nTITLE: Adding FX Rollover Interest Module\nDESCRIPTION: This code snippet adds an FX rollover interest module to the backtest engine. It reads interest rate data from a CSV file using the `TestDataProvider`, configures the `FXRolloverInterestModule`, and initializes it.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprovider = TestDataProvider()\ninterest_rate_data = provider.read_csv(\"short-term-interest.csv\")\nconfig = FXRolloverInterestConfig(interest_rate_data)\nfx_rollover_interest = FXRolloverInterestModule(config=config)\n```\n\n----------------------------------------\n\nTITLE: Custom Data Storage/Retrieval in Cache - Python\nDESCRIPTION: This code snippet demonstrates how to store and retrieve custom data in the Nautilus Trader's `Cache`. It shows how to add data with a key and retrieve it later. The stored data is treated as bytes. The code is intended to be called from within Strategy methods.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Call this code inside Strategy methods (`self` refers to Strategy)\n\n# Store data\nself.cache.add(key=\"my_key\", value=b\"some binary data\")\n\n# Retrieve data\nstored_data = self.cache.get(\"my_key\")  # Returns bytes or None\n```\n\n----------------------------------------\n\nTITLE: Generating Reports - Python\nDESCRIPTION: This snippet showcases how to generate account, order fills, and positions reports using the BacktestEngine's trader component. These reports provide insights into the backtest's performance and trading activity.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_account_report(BINANCE)\n```\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_order_fills_report()\n```\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_positions_report()\n```\n\n----------------------------------------\n\nTITLE: Accessing Price from Cache\nDESCRIPTION: This snippet demonstrates how to access a specific price from the cache using price type. Price can be either BID, ASK, MID or LAST. This requires `instrument_id` and `PriceType` from `nautilus_trader.core.rust.model`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core.rust.model import PriceType\n\n# Get current price by type; Returns Price or None.\nprice = self.cache.price(\n    instrument_id=instrument_id,\n    price_type=PriceType.MID,  # Options: BID, ASK, MID, LAST\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing BacktestDataConfig for Streaming Data (Python)\nDESCRIPTION: This snippet demonstrates how to initialize a `BacktestDataConfig` object for streaming data in Nautilus Trader. It specifies the data catalog path, data class, instrument ID, and start/end times for the backtest. The `OrderBookDelta` data class is used as an example.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import BacktestDataConfig\nfrom nautilus_trader.model import OrderBookDelta\n\n\ndata_config = BacktestDataConfig(\n    catalog_path=str(catalog.path),\n    data_cls=OrderBookDelta,\n    instrument_id=instrument.id,\n    start_time=start,\n    end_time=end,\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Positions Report\nDESCRIPTION: This code snippet generates a positions report using the `generate_positions_report` method. This report shows the positions held during the backtest, including their entry and exit prices, sizes, and durations.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_positions_report()\n```\n\n----------------------------------------\n\nTITLE: Loading Data from DBN File with DatabentoDataLoader\nDESCRIPTION: This snippet loads data from a Databento DBN file into Nautilus Trader objects using `DatabentoDataLoader.from_dbn_file`. It specifies the path to the DBN file, an `instrument_id` for faster data loading, and sets `as_legacy_cython=False` for optimized performance.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npath = DATABENTO_DATA_DIR / \"es-front-glbx-mbp10.dbn.zst\"\ninstrument_id = InstrumentId.from_str(\"ES.n.0\")  # This should be the raw symbol (update)\n\ndepth10 = loader.from_dbn_file(\n    path=path,\n    instrument_id=instrument_id,\n    as_legacy_cython=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Exploring Available Data in Catalog\nDESCRIPTION: This snippet explores the available order book delta data within a specific time range. It retrieves the data using `catalog.order_book_deltas()` and prints the number of deltas and the first 10 elements.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Explore the available data in the catalog\nstart = dt_to_unix_nanos(pd.Timestamp(\"2022-11-01\", tz=\"UTC\"))\nend =  dt_to_unix_nanos(pd.Timestamp(\"2022-11-04\", tz=\"UTC\"))\n\ndeltas = catalog.order_book_deltas(start=start, end=end)\nprint(len(deltas))\ndeltas[:10]\n```\n\n----------------------------------------\n\nTITLE: Defining Position Management Handlers in Python\nDESCRIPTION: This code snippet shows the method signatures for defining position management handlers within a Nautilus Trader strategy. These handlers receive events related to positions, allowing the strategy to react to position state changes such as opening, changing, and closing. `PositionEvent` messages are passed to handlers in a specific sequence.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.events import PositionChanged\nfrom nautilus_trader.model.events import PositionClosed\nfrom nautilus_trader.model.events import PositionEvent\nfrom nautilus_trader.model.events import PositionOpened\n\ndef on_position_opened(self, event: PositionOpened) -> None:\ndef on_position_changed(self, event: PositionChanged) -> None:\ndef on_position_closed(self, event: PositionClosed) -> None:\ndef on_position_event(self, event: PositionEvent) -> None:  # All position event messages are eventually passed to this handler\n```\n\n----------------------------------------\n\nTITLE: Setting up Parquet Data Catalog\nDESCRIPTION: This snippet creates a `ParquetDataCatalog` to store the processed order book data. It clears any existing catalog at the specified path before creating a new one.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nCATALOG_PATH = os.getcwd() + \"/catalog\"\n\n# Clear if it already exists, then create fresh\nif os.path.exists(CATALOG_PATH):\n    shutil.rmtree(CATALOG_PATH)\nos.mkdir(CATALOG_PATH)\n\n# Create a catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n```\n\n----------------------------------------\n\nTITLE: Requesting instruments in Python\nDESCRIPTION: This code snippet demonstrates how to request instrument definitions using the `TardisHttpClient` in Python. It uses the `instrument` and `instruments` methods to retrieve specific instruments or all instruments from a given exchange. An asynchronous function is used to handle the HTTP requests.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom nautilus_trader.core import nautilus_pyo3\n\n\nasync def run():\n    http_client = nautilus_pyo3.TardisHttpClient()\n\n    instrument = await http_client.instrument(\"bitmex\", \"xbtusd\")\n    print(f\"Received: {instrument}\")\n\n    instruments = await http_client.instruments(\"bitmex\")\n    print(f\"Received: {len(instruments)} instruments\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run())\n```\n\n----------------------------------------\n\nTITLE: Processing OrderBook deltas\nDESCRIPTION: This snippet processes the raw order book data using the `OrderBookDeltaDataWrangler`. It initializes the wrangler with a test instrument definition (`XRPUSDT_BYBIT`) and ensures that the resulting deltas are sorted by timestamp (`ts_init`).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nXRPUSDT_BYBIT = TestInstrumentProvider.xrpusdt_linear_bybit()\nwrangler = OrderBookDeltaDataWrangler(XRPUSDT_BYBIT)\n\ndeltas = wrangler.process(df_raw)\ndeltas.sort(key=lambda x: x.ts_init)  # Ensure data is non-decreasing by `ts_init`\ndeltas[:10]\n```\n\n----------------------------------------\n\nTITLE: Writing Data to the Nautilus Data Catalog\nDESCRIPTION: This snippet writes data to the Nautilus data catalog using the `catalog.write_data` method. It passes the data (e.g., `depth10`) to be written.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Write data to catalog (this takes ~20 seconds or ~250,000/second for writing MBP-10 at the moment)\ncatalog.write_data(depth10)\n```\n\n----------------------------------------\n\nTITLE: Requesting Instrument from Provider\nDESCRIPTION: This code shows how the data client retrieves the actual `Instrument` object, via its `InstrumentProvider`, after receiving a `RequestInstrument`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# nautilus_trader/adapters/binance/data.py\n\nasync def _request_instrument(self, request: RequestInstrument) -> None:\n    instrument: Instrument | None = self._instrument_provider.find(request.instrument_id)\n\n    if instrument is None:\n        self._log.error(f\"Cannot find instrument for {request.instrument_id}\")\n        return\n\n    self._handle_instrument(instrument, request.id, request.params)\n```\n\n----------------------------------------\n\nTITLE: Accessing Quote Ticks from Cache\nDESCRIPTION: This code snippet demonstrates how to access quote tick data from the Cache. It shows how to retrieve lists of quotes, the latest quote, a specific quote by index, and how to check for the number of quotes available. It assumes access to the `self.cache` object and requires the `instrument_id`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Get quotes\nquotes = self.cache.quote_ticks(instrument_id)                     # Returns List[QuoteTick] or an empty list if no quotes found\nlatest_quote = self.cache.quote_tick(instrument_id)                # Returns QuoteTick or None if no such object exists\nsecond_last_quote = self.cache.quote_tick(instrument_id, index=1)  # Returns QuoteTick or None if no such object exists\n\n# Check quote availability\nquote_count = self.cache.quote_tick_count(instrument_id)  # Returns the number of quotes in cache for this instrument\nhas_quotes = self.cache.has_quote_ticks(instrument_id)    # Returns bool indicating if any quotes exist for this instrument\n```\n\n----------------------------------------\n\nTITLE: Generate Positions Report\nDESCRIPTION: This code snippet generates a positions report using `engine.trader.generate_positions_report()`. This report details the positions held throughout the backtest, including entry and exit points, quantities, and profit/loss.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_positions_report()\n```\n\n----------------------------------------\n\nTITLE: Strategy Instantiation with Configuration\nDESCRIPTION: This code instantiates the `MyStrategyConfig` with specific values for the instrument ID, bar type, trade size, and order ID tag. It then passes this configuration to the `MyStrategy` constructor to create a strategy instance.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Instantiate configuration with specific values. By setting:\n#   - InstrumentId - we parameterize the instrument the strategy will trade.\n#   - BarType - we parameterize bar-data, that strategy will trade.\nconfig = MyStrategyConfig(\n    instrument_id=InstrumentId.from_str(\"ETHUSDT-PERP.BINANCE\"),\n    bar_type=BarType.from_str(\"ETHUSDT-PERP.BINANCE-15-MINUTE[LAST]-EXTERNAL\"),\n    trade_size=Decimal(1),\n    order_id_tag=\"001\",\n)\n\n# Pass configuration to our trading strategy.\nstrategy = MyStrategy(config=config)\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Fee Model in Venue Setup (Python)\nDESCRIPTION: This code shows how to use a custom fee model when setting up a venue in Nautilus Trader. It demonstrates how to inject the `PerContractFeeModel` into the `engine.add_venue` function.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nengine.add_venue(\n    venue=venue,\n    oms_type=OmsType.NETTING,\n    account_type=AccountType.MARGIN,\n    base_currency=USD,\n    fee_model=PerContractFeeModel(Money(2.50, USD)),  # Our custom fee-model injected here: 2.50 USD / per 1 filled contract\n    starting_balances=[Money(1_000_000, USD)],\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.data_client module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.data_client` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.data_client\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Requesting instruments in Rust\nDESCRIPTION: This code snippet demonstrates how to request instrument definitions in Rust using the `TardisHttpClient`.  It retrieves both single instruments and collections of instruments from a specified exchange using asynchronous calls.  A Tardis API key is required for interacting with the Tardis instrument metadata API.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse nautilus_adapters::tardis::{enums::Exchange, http::client::TardisHttpClient};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::DEBUG)\n        .init();\n\n    let client = TardisHttpClient::new(None, None, None).unwrap();\n\n    // Nautilus instrument definitions\n    let resp = client.instruments(Exchange::Bitmex).await;\n    println!(\"Received: {resp:?}\");\n\n    let resp = client.instrument(Exchange::Bitmex, \"ETHUSDT\").await;\n    println!(\"Received: {resp:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Data Client Request Handler\nDESCRIPTION: This snippet demonstrates the `request_instrument` handler in a `LiveMarketDataClient`, which receives a `RequestInstrument` and creates a task to process it asynchronously.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# nautilus_trader/live/data_client.py\n\ndef request_instrument(self, request: RequestInstrument) -> None:\n    self.create_task(self._request_instrument(request))\n```\n\n----------------------------------------\n\nTITLE: Creating a Market-If-Touched Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Market-If-Touched order in Nautilus Trader. It creates a SELL order for 10 ETHUSDT-PERP contracts on the Binance Futures exchange, triggered at a price of 10,000 USDT based on the last price. It uses the MarketIfTouchedOrder class, setting parameters such as instrument_id, order_side, quantity, trigger_price, trigger_type, time_in_force, expire_time, reduce_only, and tags.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import MarketIfTouchedOrder\n\norder: MarketIfTouchedOrder = self.order_factory.market_if_touched(\n    instrument_id=InstrumentId.from_str(\"ETHUSDT-PERP.BINANCE\"),\n    order_side=OrderSide.SELL,\n    quantity=Quantity.from_int(10),\n    trigger_price=Price.from_str(\"10_000.00\"),\n    trigger_type=TriggerType.LAST_PRICE,  # <-- optional (default DEFAULT)\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    expire_time=None,  # <-- optional (default None)\n    reduce_only=False,  # <-- optional (default False)\n    tags=[\"ENTRY\"],  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Databento DBN Data as Pandas DataFrame\nDESCRIPTION: This snippet reads a Databento DBN file from disk using `DBNStore.from_file` and converts it to a pandas DataFrame using `to_df`. This allows for easy inspection and analysis of the data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndata = DBNStore.from_file(path)\n\ndf = data.to_df()\ndf\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Portfolio Statistic (WinRate) in Python\nDESCRIPTION: This code snippet demonstrates how to create a custom portfolio statistic by inheriting from the `PortfolioStatistic` base class. It implements the `calculate_from_realized_pnls` method to calculate the win rate from a series of realized PnLs. It includes preconditions for handling `None` or empty series.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/portfolio.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.analysis.statistic import PortfolioStatistic\n\n\nclass WinRate(PortfolioStatistic):\n    \"\"\"\n    Calculates the win rate from a realized PnLs series.\n    \"\"\"\n\n    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Any | None:\n        # Preconditions\n        if realized_pnls is None or realized_pnls.empty:\n            return 0.0\n\n        # Calculate statistic\n        winners = [x for x in realized_pnls if x > 0.0]\n        losers = [x for x in realized_pnls if x <= 0.0]\n\n        return len(winners) / float(max(1, (len(winners) + len(losers))))\n```\n\n----------------------------------------\n\nTITLE: Querying Quote Ticks from the Data Catalog\nDESCRIPTION: This snippet queries `QuoteTick` objects from the data catalog within a specified time range.  It converts start and end dates to nanosecond timestamps using `dt_to_unix_nanos`, and then calls the `quote_ticks` method on the catalog with the instrument ID and time range to retrieve the selected quote ticks.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Query quote-ticks from catalog\nstart = dt_to_unix_nanos(pd.Timestamp(\"2024-10-01\", tz=\"UTC\"))\nend =  dt_to_unix_nanos(pd.Timestamp(\"2024-10-15\", tz=\"UTC\"))\nselected_quote_ticks = catalog.quote_ticks(instrument_ids=[EURUSD.id.value], start=start, end=end)\n\n# Preview first\nselected_quote_ticks[:2]\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive in reStructuredText to automatically generate documentation for the `nautilus_trader.backtest` module. It extracts docstrings and other information to create API documentation.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest\n```\n\n----------------------------------------\n\nTITLE: Creating a Limit Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Limit order in Nautilus Trader. It sets up a SELL order for 20 ETHUSDT-PERP contracts on Binance Futures at a limit price of 5000 USDT.  It utilizes the LimitOrder class and specifies parameters such as instrument_id, order_side, quantity, price, time_in_force, expire_time, post_only, reduce_only, display_qty, and tags.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import LimitOrder\n\norder: LimitOrder = self.order_factory.limit(\n    instrument_id=InstrumentId.from_str(\"ETHUSDT-PERP.BINANCE\"),\n    order_side=OrderSide.SELL,\n    quantity=Quantity.from_int(20),\n    price=Price.from_str(\"5_000.00\"),\n    time_in_force=TimeInForce.GTC,  # <-- optional (default GTC)\n    expire_time=None,  # <-- optional (default None)\n    post_only=True,  # <-- optional (default False)\n    reduce_only=False,  # <-- optional (default False)\n    display_qty=None,  # <-- optional (default None which indicates full display)\n    tags=None,  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Betfair Client Factories with TradingNode\nDESCRIPTION: This code demonstrates how to register Betfair data and execution client factories with a `TradingNode`. It instantiates the node, registers the factories using the \"BETFAIR\" key, and then builds the node to incorporate the configured clients.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/betfair.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.adapters.betfair.factories import BetfairLiveDataClientFactory\nfrom nautilus_trader.adapters.betfair.factories import BetfairLiveExecClientFactory\nfrom nautilus_trader.live.node import TradingNode\n\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factories with the node\nnode.add_data_client_factory(\"BETFAIR\", BetfairLiveDataClientFactory)\nnode.add_exec_client_factory(\"BETFAIR\", BetfairLiveExecClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader with IB and Docker dependencies\nDESCRIPTION: This command installs the latest `nautilus_trader` package along with the `ibapi` and optional `docker` dependencies using pip. The `-U` flag ensures that the package is upgraded to the latest version if it's already installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install -U \"nautilus_trader[ib,docker]\"\n```\n\n----------------------------------------\n\nTITLE: Establishing a connection to DockerizedIBGateway\nDESCRIPTION: This Python code snippet demonstrates how to establish a connection to a Dockerized Interactive Brokers Gateway using `DockerizedIBGatewayConfig` and `DockerizedIBGateway` classes. It configures the gateway with username, password, and trading mode, then starts the gateway and checks its status.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.config import DockerizedIBGatewayConfig\nfrom nautilus_trader.adapters.interactive_brokers.gateway import DockerizedIBGateway\n\ngateway_config = DockerizedIBGatewayConfig(\n    username=\"test\",\n    password=\"test\",\n    trading_mode=\"paper\",\n)\n\n# This may take a short while to start up, especially the first time\ngateway = DockerizedIBGateway(\n    config=gateway_config\n)\ngateway.start()\n\n# Confirm you are logged in\nprint(gateway.is_logged_in(gateway.container))\n\n# Inspect the logs\nprint(gateway.container.logs())\n```\n\n----------------------------------------\n\nTITLE: Generating Order Fills Report\nDESCRIPTION: This code snippet generates a report on order fills using the `generate_order_fills_report` method. This report details the filled orders during the backtest, including the prices and sizes at which they were filled.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_order_fills_report()\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame Schema (Bars)\nDESCRIPTION: Displays the schema of the DataFrame resulting from the SQL query on the bar data. This shows the column names and data types.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndf.schema()\n```\n\n----------------------------------------\n\nTITLE: Adding Databento Data Client Factory to TradingNode in Python\nDESCRIPTION: This code demonstrates how to add the `DatabentoLiveDataClientFactory` to a `TradingNode` in Nautilus Trader.  It involves instantiating the node, registering the client factory, and building the node to integrate the Databento data feed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.databento.factories import DatabentoLiveDataClientFactory\nfrom nautilus_trader.live.node import TradingNode\n\n# Instantiate the live trading node with a configuration\nnode = TradingNode(config=config)\n\n# Register the client factory with the node\nnode.add_data_client_factory(DATABENTO, DatabentoLiveDataClientFactory)\n\n# Finally build the node\nnode.build()\n```\n\n----------------------------------------\n\nTITLE: Defining Data Handling Handlers in Python\nDESCRIPTION: This code snippet shows the method signatures for defining data handling handlers within a Nautilus Trader strategy. These handlers receive data updates, including market data and custom user-defined data, which is crucial for implementing trading logic based on real-time and historical information.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core import Data\nfrom nautilus_trader.model import OrderBook\nfrom nautilus_trader.model import Bar\nfrom nautilus_trader.model import QuoteTick\nfrom nautilus_trader.model import TradeTick\nfrom nautilus_trader.model import OrderBookDeltas\nfrom nautilus_trader.model import InstrumentClose\nfrom nautilus_trader.model import InstrumentStatus\nfrom nautilus_trader.model.instruments import Instrument\n\ndef on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:\ndef on_order_book(self, order_book: OrderBook) -> None:\ndef on_quote_tick(self, tick: QuoteTick) -> None:\ndef on_trade_tick(self, tick: TradeTick) -> None:\ndef on_bar(self, bar: Bar) -> None:\ndef on_instrument(self, instrument: Instrument) -> None:\ndef on_instrument_status(self, data: InstrumentStatus) -> None:\ndef on_instrument_close(self, data: InstrumentClose) -> None:\ndef on_historical_data(self, data: Data) -> None:\ndef on_data(self, data: Data) -> None:  # Custom data passed to this handler\ndef on_signal(self, signal: Data) -> None:  # Custom signals passed to this handler\n```\n\n----------------------------------------\n\nTITLE: Documenting Base Catalog (automodule directive)\nDESCRIPTION: This snippet leverages the Sphinx `automodule` directive to document the `nautilus_trader.persistence.catalog.base` module. Options such as `:show-inheritance:`, `:inherited-members:`, `:members:`, and `:member-order:` control the level of detail and organization of the generated documentation, including inheritance information and member listings sorted by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/persistence.md#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.persistence.catalog.base\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Defining a Synthetic Instrument (Python)\nDESCRIPTION: This code snippet demonstrates how to create a new synthetic instrument with an actor/strategy in Nautilus Trader, representing a spread between Bitcoin and Ethereum spot prices on Binance.  It assumes that spot instruments for `BTCUSDT.BINANCE` and `ETHUSDT.BINANCE` are already present in the cache. It shows setting a formula for the price calculation and subscribing to the instrument's quote ticks.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.model.instruments import SyntheticInstrument\n\nbtcusdt_binance_id = InstrumentId.from_str(\"BTCUSDT.BINANCE\")\nethusdt_binance_id = InstrumentId.from_str(\"ETHUSDT.BINANCE\")\n\n# Define the synthetic instrument\nsynthetic = SyntheticInstrument(\n    symbol=Symbol(\"BTC-ETH:BINANCE\"),\n    price_precision=8,\n    components=[\n        btcusdt_binance_id,\n        ethusdt_binance_id,\n    ],\n    formula=f\"{btcusdt_binance_id} - {ethusdt_binance_id}\",\n    ts_event=self.clock.timestamp_ns(),\n    ts_init=self.clock.timestamp_ns(),\n)\n\n# Recommended to store the synthetic instruments ID somewhere\nself._synthetic_id = synthetic.id\n\n# Add the synthetic instrument for use by other components\nself.add_synthetic(synthetic)\n\n# Subscribe to quotes for the synthetic instrument\nself.subscribe_quote_ticks(self._synthetic_id)\n```\n\n----------------------------------------\n\nTITLE: Running Backtest with BacktestNode\nDESCRIPTION: This snippet demonstrates how to use the BacktestNode class to run a backtest. It initializes the BacktestNode with a list of configurations and then executes the backtest synchronously, returning a list of BacktestResult objects.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.backtest.results import BacktestResult\n\n\nnode = BacktestNode(configs=[config])\n\n # Runs one or many configs synchronously\nresults: list[BacktestResult] = node.run()\n```\n\n----------------------------------------\n\nTITLE: Creating a Directory for Databento Data\nDESCRIPTION: This snippet creates a directory to store the raw Databento DBN data. It uses `Path` from `pathlib` to define the directory path and `mkdir` to create the directory if it doesn't exist. The `exist_ok=True` argument ensures that the code doesn't raise an error if the directory already exists.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDATABENTO_DATA_DIR = Path(\"databento\")\nDATABENTO_DATA_DIR.mkdir(exist_ok=True)\n```\n\n----------------------------------------\n\nTITLE: Initializing BacktestEngine with Config\nDESCRIPTION: This code snippet initializes the `BacktestEngine` with a specified configuration. The configuration includes the trader ID, logging level, and risk engine settings. A key feature is the ability to bypass pre-trade risk checks which is useful for backtesting purposes.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Initialize a backtest configuration\nconfig = BacktestEngineConfig(\n    trader_id=\"BACKTESTER-001\",\n    logging=LoggingConfig(log_level=\"ERROR\"),\n    risk_engine=RiskEngineConfig(\n        bypass=True,  # Example of bypassing pre-trade risk checks for backtests\n    ),\n)\n\n# Build backtest engine\nengine = BacktestEngine(config=config)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Imbalance Data via Generic Method in Python\nDESCRIPTION: This code subscribes to the `imbalance` schema for a specific instrument (`AAPL.XNAS`) using the lower-level generic methods for custom data types. It demonstrates how to use `DataType` with metadata for subscribing to Databento's custom data types in Nautilus Trader.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.databento import DATABENTO_CLIENT_ID\nfrom nautilus_trader.adapters.databento import DatabentoImbalance\nfrom nautilus_trader.model import DataType\n\ninstrument_id = InstrumentId.from_str(\"AAPL.XNAS\")\nself.subscribe_data(\n    data_type=DataType(DatabentoImbalance, metadata={\"instrument_id\": instrument_id}),\n    client_id=DATABENTO_CLIENT_ID,\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Portfolio Balances Locked\nDESCRIPTION: This snippet shows how to view the total blocked funds (sum of maintenance margins for open positions) using the `balances_locked` method in your strategy.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nself.portfolio.balances_locked(venue)\n```\n\n----------------------------------------\n\nTITLE: Documenting Order Events with automodule\nDESCRIPTION: This snippet uses the `automodule` directive with specific options to document the `nautilus_trader.model.events.order` module. It displays inheritance, inherited members, lists all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/events.md#_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.events.order\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Creating a Nautilus Parquet Data Catalog\nDESCRIPTION: This snippet creates a `ParquetDataCatalog` at the specified path. It first removes any existing catalog at the same path, then creates a new directory. The catalog is then initialized.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nCATALOG_PATH = Path.cwd() / \"catalog\"\n\n# Clear if it already exists\nif CATALOG_PATH.exists():\n    shutil.rmtree(CATALOG_PATH)\nCATALOG_PATH.mkdir()\n\n# Create a catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n```\n\n----------------------------------------\n\nTITLE: Adding Instrument and Data - Python\nDESCRIPTION: This snippet shows how to add the instrument (ETHUSDT_BINANCE) and the processed trade tick data to the BacktestEngine. This step is crucial for providing the backtest engine with the necessary market information to simulate trading.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Add instrument(s)\nengine.add_instrument(ETHUSDT_BINANCE)\n\n# Add data\nengine.add_data(ticks)\n```\n\n----------------------------------------\n\nTITLE: Configuring Betfair Clients in TradingNodeConfig\nDESCRIPTION: This code snippet demonstrates how to configure Betfair data and execution clients within a `TradingNodeConfig` object. It shows how to set the account currency and provides placeholders for environment variables containing Betfair credentials (username, password, app key, and certificate directory).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/betfair.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.config import TradingNodeConfig\n\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"BETFAIR\": {\n            \"account_currency\": \"AUD\",\n            # username=None, # 'BETFAIR_USERNAME' env var\n            # password=None, # 'BETFAIR_PASSWORD' env var\n            # app_key=None, # 'BETFAIR_APP_KEY' env var\n            # certs_dir=None, # 'BETFAIR_CERTS_DIR' env var\n        },\n    },\n    exec_clients={\n        \"BETFAIR\": {\n            \"account_currency\": \"AUD\",\n            # username=None, # 'BETFAIR_USERNAME' env var\n            # password=None, # 'BETFAIR_PASSWORD' env var\n            # app_key=None, # 'BETFAIR_APP_KEY' env var\n            # certs_dir=None, # 'BETFAIR_CERTS_DIR' env var\n        },\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Generate Order Fills Report\nDESCRIPTION: This code snippet retrieves the `BacktestEngine` from the `BacktestNode` and generates an order fills report using `engine.trader.generate_order_fills_report()`. This report provides detailed information about the executed orders and their corresponding fills during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.model import Venue\n\n\nengine: BacktestEngine = node.get_engine(config.id)\n\nengine.trader.generate_order_fills_report()\n```\n\n----------------------------------------\n\nTITLE: Instrument Provider Configuration - Load All Instruments\nDESCRIPTION: This snippet demonstrates how to configure an `InstrumentProvider` to automatically load all instruments on startup. This is achieved by setting the `load_all` parameter to `True` in the `InstrumentProviderConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import InstrumentProviderConfig\n\nInstrumentProviderConfig(load_all=True)\n```\n\n----------------------------------------\n\nTITLE: Checking Dataset Condition with Databento API in Python\nDESCRIPTION: This snippet shows how to check the condition of a dataset for a specific date range using the Databento API. It calls the `get_dataset_condition()` method with the dataset name, start date, and end date. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconditions = client.metadata.get_dataset_condition(\n    dataset=\"GLBX.MDP3\",\n    start_date=\"2022-06-06\",\n    end_date=\"2022-06-10\",\n)\n\nconditions\n```\n\n----------------------------------------\n\nTITLE: Order Statistics from Cache - Python\nDESCRIPTION: This code snippet shows how to retrieve order statistics using the Nautilus Trader's `Cache`. It demonstrates how to get counts of orders in different states (open, closed, emulated, inflight, total) and how to filter order counts by order side and venue. Requires `OrderSide` and `venue` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Get counts of orders in different states\nopen_count = self.cache.orders_open_count()          # Number of open orders\nclosed_count = self.cache.orders_closed_count()      # Number of closed orders\nemulated_count = self.cache.orders_emulated_count()  # Number of emulated orders\ninflight_count = self.cache.orders_inflight_count()  # Number of inflight orders\ntotal_count = self.cache.orders_total_count()        # Total number of orders in the system\n\n# Get filtered order counts\nbuy_orders_count = self.cache.orders_open_count(side=OrderSide.BUY)  # Number of currently open BUY orders\nvenue_orders_count = self.cache.orders_total_count(venue=venue)      # Total number of orders for a given venue\n```\n\n----------------------------------------\n\nTITLE: Writing Data to Catalog\nDESCRIPTION: This snippet writes the instrument definition (`XRPUSDT_BYBIT`) and the processed order book deltas (`deltas`) to the `ParquetDataCatalog` for later use in the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Write instrument and ticks to catalog\ncatalog.write_data([XRPUSDT_BYBIT])\ncatalog.write_data(deltas)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.loser_avg module (reStructuredText)\nDESCRIPTION: This snippet imports the `loser_avg` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_6\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.loser_avg\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Estimating Data Costs with Databento\nDESCRIPTION: This snippet estimates the cost of retrieving data for a specific dataset, symbols, schema, and time range using the Databento client's `get_cost` method. It sets the dataset, symbols (ESM2, representing an S&P contract), schema (ohlcv-1h, hourly bars), start date, and end date. The output is the estimated cost in US dollars.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncost = client.metadata.get_cost(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],\n    schema=\"ohlcv-1h\",  # 1 hour bars ; only time-ranges that are multiplies of 10-minutes (cannot be used for 1-min bars)\n    start=\"2022-01-06\", # including start\n    end=\"2022-01-07\"    # excluding end\n)\n\ncost\n```\n\n----------------------------------------\n\nTITLE: Defining Parquet File Paths\nDESCRIPTION: Defines the paths to the Parquet files containing trade tick and bar data. These paths are used later to register the files with DataFusion and read them with PyArrow.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntrade_tick_path = \"../../tests/test_data/nautilus/trades.parquet\"\nbar_path = \"../../tests/test_data/nautilus/bars.parquet\"\n```\n\n----------------------------------------\n\nTITLE: Reading DBN Data from Bytes\nDESCRIPTION: This snippet reads data from a DBN byte stream using `db.DBNStore.from_bytes()`. It first retrieves time series data using `client.timeseries.get_range()` and then converts that data to pandas dataframe. After that, it simulates reading the data from a byte stream (achieved by saving and re-loading from a file). This demonstrates the process of loading DBN-encoded data from a byte stream.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndbn_data = client.timeseries.get_range(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],\n    schema=\"ohlcv-1h\",\n    start=\"2022-06-06\",\n    limit=3\n)\n\ndbn_data.to_df()\n```\n\nLANGUAGE: python\nCODE:\n```\n# Save streamed data to file - recommended suffix is: `*.dbn.zst`\npath = \"./GLBX-ESM2-20220606.ohlcv-1h.dbn.zst\"\ndbn_data.to_file(path)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Load data from previously saved file and create DBN object again\nwith open(path, \"rb\") as saved:\n    loaded_dbn_data = db.DBNStore.from_bytes(saved)\n\nloaded_dbn_data.to_df()\n```\n\n----------------------------------------\n\nTITLE: Writing DBN Data to JSON\nDESCRIPTION: This snippet demonstrates how to export DBN data to a JSON file using the `to_json` method.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Export to pandas DataFrame\ndbn_data.to_json(\"GLBX-ESM2-20220606-ohlcv-1h.json\")\n```\n\n----------------------------------------\n\nTITLE: Requesting Statistics Data via Generic Method in Python\nDESCRIPTION: This code requests the previous day's `statistics` schema for a parent symbol (`ES.FUT.GLBX`) using generic methods for custom data types. It shows how to specify metadata, including the start date, when requesting custom Databento data in Nautilus Trader.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.databento import DATABENTO_CLIENT_ID\nfrom nautilus_trader.adapters.databento import DatabentoStatisics\nfrom nautilus_trader.model import DataType\n\ninstrument_id = InstrumentId.from_str(\"ES.FUT.GLBX\")\nmetadata = {\n    \"instrument_id\": instrument_id,\n    \"start\": \"2024-03-06\",\n}\nself.request_data(\n    data_type=DataType(DatabentoImbalance, metadata=metadata),\n    client_id=DATABENTO_CLIENT_ID,\n)\n```\n\n----------------------------------------\n\nTITLE: Converting DBN Data to Pandas DataFrame\nDESCRIPTION: This snippet demonstrates how to export DBN data to a pandas DataFrame using the `to_df` method. \nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Export to pandas DataFrame\ndbn_data.to_df()\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.expectancy module (reStructuredText)\nDESCRIPTION: This snippet imports the `expectancy` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_4\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.expectancy\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Publishing and Subscribing to Signal Data (Python)\nDESCRIPTION: This snippet demonstrates publishing and subscribing to signal data using the `MessageBus` from an actor or strategy in Nautilus Trader. `publish_signal` is used to publish and `subscribe_signal` to subscribe to the signal. The `on_signal` method is used to process the signal when received.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nself.publish_signal(\"signal_name\", value, ts_event)\nself.subscribe_signal(\"signal_name\")\n\ndef on_signal(self, signal):\n    print(\"Signal\", data)\n```\n\n----------------------------------------\n\nTITLE: Actor-Based Data Publish/Subscribe Example - Python\nDESCRIPTION: This snippet demonstrates how to publish and subscribe to structured trading data between Actors using the `Data` class or `@customdataclass` in Nautilus Trader.  It defines a `GreeksData` class, publishes data using `publish_data`, subscribes to data using `subscribe_data`, and handles the received data in the `on_data` handler. Proper event ordering through timestamps is crucial for backtest accuracy.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.model.custom import customdataclass\n\n@customdataclass\nclass GreeksData(Data):\n    delta: float\n    gamma: float\n\n# Publish data (in Actor / Strategy)\ndata = GreeksData(delta=0.75, gamma=0.1, ts_event=1_630_000_000_000_000_000, ts_init=1_630_000_000_000_000_000)\nself.publish_data(GreeksData, data)\n\n# Subscribe to receiving data  (in Actor / Strategy)\nself.subscribe_data(GreeksData)\n\n# Handler (this is static callback function with fixed name)\ndef on_data(self, data: Data):\n    if isinstance(data, GreeksData):\n        self.log.info(f\"Delta: {data.delta}, Gamma: {data.gamma}\")\n```\n\n----------------------------------------\n\nTITLE: Fetching instruments from catalog in Python\nDESCRIPTION: This snippet fetches all instruments from the ParquetDataCatalog as a check to ensure data was written correctly. It retrieves the stored instrument definitions from the catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Fetch all instruments from catalog (as a check)\ncatalog.instruments()\n```\n\n----------------------------------------\n\nTITLE: Querying Trade Data with DataFusion\nDESCRIPTION: Executes a SQL query against the `trade_0` table (registered from the trades Parquet file). The query selects all columns and orders the results by the `ts_init` column.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nquery = \"SELECT * FROM trade_0 ORDER BY ts_init\"\ndf = ctx.sql(query)\n```\n\n----------------------------------------\n\nTITLE: Configuring UUID Client Order IDs in Strategy\nDESCRIPTION: This Python code snippet shows how to configure a strategy to use UUID4 values for client order IDs, which is required by Coinbase International. Setting `use_uuid_client_order_ids=True` ensures compliance with Coinbase International's API.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstrat_config = TOBQuoterConfig(\n    use_uuid_client_order_ids=True,  # <-- Necessary for Coinbase Intx\n    instrument_id=instrument_id,\n    external_order_claims=[instrument_id],\n    ...,  # Further config omitted\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Schemas for Dataset with Databento API in Python\nDESCRIPTION: This snippet demonstrates how to retrieve a list of available schemas for a specific dataset using the Databento API.  It uses the `list_schemas()` method with the dataset name as an argument to fetch the schemas. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nschemas = client.metadata.list_schemas(dataset=\"GLBX.MDP3\")\nschemas\n```\n\n----------------------------------------\n\nTITLE: Load Binance Order Book Data Files\nDESCRIPTION: This code snippet constructs the full paths to the Binance order book data files (snapshot and updates) and loads them into Pandas DataFrames using the `BinanceOrderBookDeltaDataLoader`. It asserts that data files exist in the specified directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata_path = Path(DATA_DIR).expanduser() / \"Data\" / \"Binance\"\nraw_files = list(data_path.iterdir())\nassert raw_files, f\"Unable to find any histdata files in directory {data_path}\"\nraw_files\n```\n\n----------------------------------------\n\nTITLE: Publishing Custom Messages Directly - Python\nDESCRIPTION: This snippet shows how to publish a custom message directly to the message bus within an Actor or Strategy class.  It demonstrates specifying a topic as a string and any Python object as the message payload. This requires direct access to the `self.msgbus` reference.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nself.msgbus.publish(\"MyTopic\", \"MyMessage\")\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Venue Instrument Updates\nDESCRIPTION: This snippet demonstrates how to subscribe to all instrument changes for a specific venue in Nautilus Trader. It imports the Venue class and then subscribes to all instruments for a given venue.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model import Venue\n\nbinance = Venue(\"BINANCE\")\nself.subscribe_instruments(binance)\n```\n\n----------------------------------------\n\nTITLE: Running the Backtest\nDESCRIPTION: This snippet initializes and runs the backtest using the configured `BacktestNode`. The `result` variable stores the outcome of the backtest run. It relies on the `BacktestNode` class from `nautilus_trader`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnode = BacktestNode(configs=[config])\n\nresult = node.run()\n```\n\nLANGUAGE: python\nCODE:\n```\nresult\n```\n\n----------------------------------------\n\nTITLE: Executing a Nautilus Trader Example\nDESCRIPTION: This code snippet demonstrates how to execute an example script from the `examples` directory using the python interpreter. The script shown is located within the `backtest` directory and executes a crypto EMA cross strategy with ETHUSDT trade ticks data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/examples/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npython backtest/crypto_ema_cross_ethusdt_trade_ticks.py\n```\n\n----------------------------------------\n\nTITLE: Database Configuration for Cache Persistence\nDESCRIPTION: This code snippet shows how to configure a database for persistence of the Cache data. It configures a Redis database with specified host, port, and timeout, within the `CacheConfig`. Requires importing `DatabaseConfig` from `nautilus_trader.config`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import DatabaseConfig\n\nconfig = CacheConfig(\n    database=DatabaseConfig(\n        type=\"redis\",      # Database type\n        host=\"localhost\",  # Database host\n        port=6379,         # Database port\n        timeout=2,         # Connection timeout (seconds)\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Postgres with psql\nDESCRIPTION: This command connects to the Postgres database using the `psql` command-line client. It specifies the host, port, and user. The user will be prompted for the password defined in the docker-compose file. This step is necessary to create the `nautilus` database.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npsql -h localhost -p 5432 -U postgres\n```\n\n----------------------------------------\n\nTITLE: Converting DBNStore to Pandas DataFrame\nDESCRIPTION: This snippet demonstrates converting data from DBNStore format to a pandas DataFrame. It first assumes that `data` is a DBNStore object populated with time series data. The `.to_df()` method is then used to convert this data into a pandas DataFrame, which provides a tabular format for easier analysis and manipulation. Finally, the length of dataframe is printed and the DataFrame is displayed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Convert DBN format to pandas-dataframe\ndf = data.to_df()\n\n# Preview\nprint(len(df))\ndf\n```\n\n----------------------------------------\n\nTITLE: Displaying backtest results in Python\nDESCRIPTION: This snippet displays the results of the backtest run. The backtest results contain the performance metrics and other relevant information about the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nresult\n```\n\n----------------------------------------\n\nTITLE: Cache Configuration Options\nDESCRIPTION: This code snippet demonstrates the various configurable options available in the `CacheConfig` class.  It showcases parameters like `database`, `encoding`, `timestamps_as_iso8601`, `tick_capacity`, and `bar_capacity`. Requires importing `CacheConfig` from `nautilus_trader.config`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import CacheConfig\n\ncache_config = CacheConfig(\n    database: DatabaseConfig | None = None,  # Database configuration for persistence\n    encoding: str = \"msgpack\",               # Data encoding format ('msgpack' or 'json')\n    timestamps_as_iso8601: bool = False,     # Store timestamps as ISO8601 strings\n    buffer_interval_ms: int | None = None,   # Buffer interval for batch operations\n    use_trader_prefix: bool = True,          # Use trader prefix in keys\n    use_instance_id: bool = False,           # Include instance ID in keys\n    flush_on_start: bool = False,            # Clear database on startup\n    drop_instruments_on_reset: bool = True,  # Clear instruments on reset\n    tick_capacity: int = 10_000,             # Maximum ticks stored per instrument\n    bar_capacity: int = 10_000,              # Maximum bars stored per each bar-type\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Bar Types from Cache\nDESCRIPTION: This snippet shows how to get all available bar types for an instrument. This requires `instrument_id`, `PriceType` and `AggregationSource` from `nautilus_trader.core.rust.model`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Get all available bar types for an instrument; Returns List[BarType].\nbar_types = self.cache.bar_types(\n    instrument_id=instrument_id,\n    price_type=PriceType.LAST,  # Options: BID, ASK, MID, LAST\n    aggregation_source=AggregationSource.EXTERNAL,\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Coinbase International Portfolios with Python\nDESCRIPTION: This Python script lists available portfolios from Coinbase International using the REST API. It requires the `nautilus_trader` library and outputs portfolio details, including the `portfolio_id` needed for trading.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython nautilus_trader/adapters/coinbase_intx/scripts/list_portfolios.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Instrument Provider to Suppress Warnings (Python)\nDESCRIPTION: This snippet shows how to configure the instrument provider to suppress warnings that may arise when parsing certain Binance instruments. It sets the `log_warnings` option to `False` within the `InstrumentProviderConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import InstrumentProviderConfig\n\ninstrument_provider=InstrumentProviderConfig(\n    load_all=True,\n    log_warnings=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Custom Data in on_data (Python)\nDESCRIPTION: This snippet shows how to handle received custom data within the `on_data` method of an actor or strategy in Nautilus Trader. It checks the type of the received `data` object using `isinstance` and performs actions based on the data type.  This is necessary because `on_data` acts as a flexible handler for all custom data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef on_data(self, data: Data) -> None:\n    # First check the type of data\n    if isinstance(data, MyDataPoint):\n        # Do something with the data\n```\n\n----------------------------------------\n\nTITLE: Explore Available Data in Catalog by Time Range\nDESCRIPTION: This code snippet explores the available order book deltas within a specified time range in the catalog. It defines the start and end timestamps, retrieves the deltas using `catalog.order_book_deltas()`, prints the length of the retrieved deltas, and displays the first 10 deltas.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Explore the available data in the catalog\nstart = dt_to_unix_nanos(pd.Timestamp(\"2022-11-01\", tz=\"UTC\"))\nend =  dt_to_unix_nanos(pd.Timestamp(\"2022-11-04\", tz=\"UTC\"))\n\ndeltas = catalog.order_book_deltas(start=start, end=end)\nprint(len(deltas))\ndeltas[:10]\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader from PyPI using pip (Python)\nDESCRIPTION: This command installs the latest version of the nautilus_trader package from the Python Package Index (PyPI) using pip. The `-U` flag upgrades the package if it's already installed. It assumes Python and pip are already installed and configured in the user's environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U nautilus_trader\n```\n\n----------------------------------------\n\nTITLE: Creating DataFusion Context\nDESCRIPTION: Creates a `SessionContext` object from the `datafusion` library. This context is used to register Parquet files and execute SQL queries against them.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create a context\nctx = datafusion.SessionContext()\n```\n\n----------------------------------------\n\nTITLE: Displaying the Number of Trade Ticks\nDESCRIPTION: This snippet displays the total number of `TradeTick` objects retrieved from the data catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nlen(trades)\n```\n\n----------------------------------------\n\nTITLE: Documenting nautilus_trader.risk.engine module\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.risk.engine` module. It shows inheritance, includes inherited members, lists all members, and orders the members by source code.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/risk.md#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.risk.engine\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Starting Specific Services with Docker Compose\nDESCRIPTION: This command starts specific services (e.g., Postgres) defined in the `docker-compose.yml` file in detached mode (`-d`). This allows for selectively starting services required for specific development tasks.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up -d postgres\n```\n\n----------------------------------------\n\nTITLE: Building Project with Make\nDESCRIPTION: This command builds the project using the Makefile. The Makefile provides a simplified interface for common build tasks. The command `make build` executes the build steps defined in the Makefile.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake build\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.modules module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.modules` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.modules\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Iterating over DBN Data with a for loop\nDESCRIPTION: This snippet demonstrates how to iterate over DBN data using a standard Python `for` loop.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Let's load some data first\ndbn_data = client.timeseries.get_range(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],\n    schema=\"ohlcv-1h\",\n    start=\"2022-06-06\",\n    limit=3\n)\n\n# Contains 3 hourly bars\ndbn_data.to_df()\n```\n\nLANGUAGE: python\nCODE:\n```\n# We can use DBN data in for-cycle:\nfor bar in dbn_data:\n    print(bar)   # print full bar data\n    break        # intentionally break to see only 1st bar\n```\n\nLANGUAGE: python\nCODE:\n```\nfor bar in dbn_data:\n    print(f\"Bar open: {bar.open}\")  # print only bar-open information\n    break                           # intentionally break to see only 1st bar\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Greeks Data in Rust\nDESCRIPTION: This snippet demonstrates how to subscribe to greeks data using the `GreeksCalculator` within the `MyActor`. It also shows how to implement the `DataActor` trait to handle received greeks data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/crates/common/src/greeks.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl MyActor {\n    pub fn subscribe_to_greeks(&self, underlying: &str) {\n        // Subscribe to greeks data\n        self.greeks_calculator.subscribe_greeks(underlying, None);\n    }\n}\n\nimpl DataActor for MyActor {\n    fn on_start(&mut self) -> anyhow::Result<()> {\n        // Subscribe to greeks data for SPY\n        self.subscribe_to_greeks(\"SPY\");\n        Ok(())\n    }\n\n    fn on_data(&mut self, data: &dyn std::any::Any) -> anyhow::Result<()> {\n        // Handle received data\n        if let Some(greeks_data) = data.downcast_ref::<GreeksData>() {\n            println!(\"Received greeks data: {:?}\", greeks_data);\n        }\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame (Trades)\nDESCRIPTION: Displays the DataFrame resulting from the SQL query on the trade data. This shows the actual data in a tabular format.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndf\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.exchange module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.exchange` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.exchange\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Writing AAPL Trade Data to Nautilus Catalog\nDESCRIPTION: This snippet writes the loaded AAPL `TradeTick` objects to the Nautilus data catalog. The data is organized into a file per month using the `basename_template` parameter.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Write data to catalog\ncatalog.write_data(trades, basename_template=\"2024-01\")\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader from Nautech Systems index (Python)\nDESCRIPTION: This command installs the latest version of the nautilus_trader package from the Nautech Systems package index. The `-U` flag upgrades the package if it's already installed. The `--index-url` flag specifies the package index to use. This assumes Python and pip are already installed and configured in the user's environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -U nautilus_trader --index-url=https://packages.nautechsystems.io/simple\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus CLI\nDESCRIPTION: This command installs the Nautilus CLI using the Makefile target `install-cli`. The CLI is used for managing the PostgreSQL database and handling various trading operations. Requires Rust's cargo to be properly configured.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmake install-cli\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with dYdX dependencies from source using uv\nDESCRIPTION: This command installs the dydx dependencies when installing from source using uv. It utilizes the `--extra` flag to include the dydx-specific components during installation.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuv install --extra dydx\n```\n\n----------------------------------------\n\nTITLE: Accessing Trade Ticks from Cache\nDESCRIPTION: This code snippet demonstrates how to access trade tick data from the Cache. It includes examples for retrieving lists of trades, the latest trade, a specific trade by index, and for checking trade availability and counts. It assumes access to the `self.cache` object and the availability of `instrument_id`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Get trades\ntrades = self.cache.trade_ticks(instrument_id)         # Returns List[TradeTick] or an empty list if no trades found\nlatest_trade = self.cache.trade_tick(instrument_id)    # Returns TradeTick or None if no such object exists\nsecond_last_trade = self.cache.trade_tick(instrument_id, index=1)  # Returns TradeTick or None if no such object exists\n\n# Check trade availability\ntrade_count = self.cache.trade_tick_count(instrument_id)  # Returns the number of trades in cache for this instrument\nhas_trades = self.cache.has_trade_ticks(instrument_id)    # Returns bool indicating if any trades exist\n```\n\n----------------------------------------\n\nTITLE: Converting DBN Data to NumPy Array\nDESCRIPTION: This snippet demonstrates converting DBN data to a NumPy N-dimensional array using the `to_ndarray` method.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Export to numpy-array\nndarray = dbn_data.to_ndarray()\nndarray\n```\n\n----------------------------------------\n\nTITLE: Creating and populating a Parquet Data Catalog\nDESCRIPTION: This code snippet creates a `ParquetDataCatalog` and populates it with instrument and tick data.  It first defines the path for the catalog, clears any existing catalog at that path, and then creates a new catalog. It then writes the EUR/USD instrument and the processed `QuoteTick` objects to the catalog. This catalog will be used to load the data for backtesting.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nCATALOG_PATH = Path.cwd() / \"catalog\"\n\n# Clear if it already exists, then create fresh\nif CATALOG_PATH.exists():\n    shutil.rmtree(CATALOG_PATH)\nCATALOG_PATH.mkdir(parents=True)\n\n# Create a catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n\n# Write instrument to the catalog\ncatalog.write_data([EURUSD])\n\n# Write ticks to catalog\ncatalog.write_data(ticks)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Logger Directly - Python\nDESCRIPTION: This snippet shows how to initialize and use a `Logger` object directly in Nautilus Trader. It requires calling `init_logging()` to activate the logging system and ensures the `LogGuard` returned by `init_logging()` remains active. The logger instance is then created using `Logger(\"MyLogger\")`. Dependencies include `nautilus_trader.common.component`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/logging.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.common.component import init_logging\nfrom nautilus_trader.common.component import Logger\n\nlog_guard = init_logging()\nlogger = Logger(\"MyLogger\")\n```\n\n----------------------------------------\n\nTITLE: Querying Orders for Exec Spawn - Python\nDESCRIPTION: This code defines the function signature to query orders for a specific execution spawn ID. It returns a list of orders associated with the given execution spawn ID, including the primary order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef orders_for_exec_spawn(self, exec_spawn_id: ClientOrderId) -> list[Order]:\n```\n\n----------------------------------------\n\nTITLE: Writing data to ParquetDataCatalog (Python)\nDESCRIPTION: This snippet demonstrates how to write a list of `OrderBookDelta` objects (deltas) to the `ParquetDataCatalog`. It leverages the `write_data` method of the catalog to persist the data in the Nautilus-specific Parquet format. Requires an initialized `ParquetDataCatalog` and a list of `OrderBookDelta` objects.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncatalog.write_data(deltas)\n```\n\n----------------------------------------\n\nTITLE: Defining the data directory path in Python\nDESCRIPTION: This snippet defines a variable `DATA_DIR` which specifies the location of the data files.  This path is used later for accessing the historical data. It's set to a directory within the user's Downloads folder.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nDATA_DIR = \"~/Downloads/Data/\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Greeks using GreeksCalculator in Rust\nDESCRIPTION: This snippet shows how to use the `GreeksCalculator` to calculate greeks for a given instrument within the `MyActor`. It includes example parameters for the calculation, such as interest rate, dividend yield, and shocks.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/crates/common/src/greeks.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse nautilus_model::{\n    data::greeks::GreeksData,\n    identifiers::InstrumentId,\n};\n\nimpl MyActor {\n    pub fn calculate_greeks(&self, instrument_id: InstrumentId) -> anyhow::Result<GreeksData> {\n        // Example parameters\n        let flat_interest_rate = 0.0425;\n        let flat_dividend_yield = None;\n        let spot_shock = 0.0;\n        let vol_shock = 0.0;\n        let time_to_expiry_shock = 0.0;\n        let use_cached_greeks = false;\n        let cache_greeks = true;\n        let publish_greeks = true;\n        let ts_event = self.core.clock.borrow().timestamp_ns();\n        let position = None;\n        let percent_greeks = false;\n        let index_instrument_id = None;\n        let beta_weights = None;\n\n        // Calculate greeks\n        self.greeks_calculator.instrument_greeks(\n            instrument_id,\n            Some(flat_interest_rate),\n            flat_dividend_yield,\n            Some(spot_shock),\n            Some(vol_shock),\n            Some(time_to_expiry_shock),\n            Some(use_cached_greeks),\n            Some(cache_greeks),\n            Some(publish_greeks),\n            Some(ts_event),\n            position,\n            Some(percent_greeks),\n            index_instrument_id,\n            beta_weights,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering TWAP Execution Algorithm in Python\nDESCRIPTION: This snippet demonstrates how to initialize and register a Time-Weighted Average Price (TWAP) execution algorithm directly with a BacktestEngine in Nautilus Trader.  It assumes that the engine is already initialized. This is useful for integrating custom execution logic into the trading system.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAP\nfrom nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAPConfig\n```\n\n----------------------------------------\n\nTITLE: Writing DBN Data to Parquet\nDESCRIPTION: This snippet demonstrates how to export DBN data to a Parquet file using the `to_parquet` method.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Export to Apache Parquet file\ndbn_data.to_parquet(\"GLBX-ESM2-20220606-ohlcv-1h.parquet\")\n```\n\n----------------------------------------\n\nTITLE: Docker Run Command\nDESCRIPTION: This command runs the NautilusTrader JupyterLab Docker container, mapping port 8888 on the host machine to port 8888 in the container. This allows access to the JupyterLab interface through a web browser.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/index.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ndocker run -p 8888:8888 ghcr.io/nautechsystems/jupyterlab:nightly\n```\n\n----------------------------------------\n\nTITLE: Importing IBContract\nDESCRIPTION: This code snippet imports the `IBContract` class from the `nautilus_trader.adapters.interactive_brokers.common` module. This class is used to define contract details for trading with Interactive Brokers.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom nautilus_trader.adapters.interactive_brokers.common import IBContract\n```\n\n----------------------------------------\n\nTITLE: Reading AAPL Trade Data from Nautilus Catalog\nDESCRIPTION: This snippet retrieves the `TradeTick` objects for the AAPL instrument_id from the Nautilus data catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ntrades = catalog.trade_ticks([instrument_id])\n```\n\n----------------------------------------\n\nTITLE: Documenting Trading Module with automodule\nDESCRIPTION: This snippet uses the `automodule` directive in reStructuredText to generate documentation for the `nautilus_trader.trading` module. It automatically extracts documentation from the module's docstrings and generates API documentation.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/trading.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.trading\n```\n\n----------------------------------------\n\nTITLE: Installing Wheel File\nDESCRIPTION: This command installs a NautilusTrader binary wheel (.whl) file using pip.  `<file-name>.whl` should be replaced with the actual name of the downloaded wheel file. This method is useful for installing from a local file downloaded from a GitHub Release.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\npip install <file-name>.whl\n```\n\n----------------------------------------\n\nTITLE: Reading Bar Data with PyArrow\nDESCRIPTION: Reads the bar data Parquet file into a PyArrow table. This provides an alternative way to access the data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntable = pq.read_table(bar_path)\ntable.schema\n```\n\n----------------------------------------\n\nTITLE: Creating Short-Term Orders on dYdX with specified block duration in Python\nDESCRIPTION: This Python code snippet demonstrates how to construct a short-term limit order on dYdX with a specified number of blocks the order is active. It uses the `num_blocks_open` parameter within `DYDXOrderTags` to define the order's lifespan.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.dydx.common.common import DYDXOrderTags\n\norder: LimitOrder = self.order_factory.limit(\n    instrument_id=self.instrument_id,\n    order_side=OrderSide.BUY,\n    quantity=self.instrument.make_qty(self.trade_size),\n    price=self.instrument.make_price(price),\n    time_in_force=TimeInForce.GTD,\n    expire_time=self.clock.utc_now() + pd.Timedelta(seconds=5),\n    post_only=True,\n    emulation_trigger=self.emulation_trigger,\n    tags=[DYDXOrderTags(is_short_term_order=True, num_blocks_open=5).value],\n)\n```\n\n----------------------------------------\n\nTITLE: Reading Gzipped CSV File with Pandas\nDESCRIPTION: This code snippet demonstrates how to read a gzipped CSV file directly into a pandas DataFrame. It uses the `pd.read_csv` function to read the file, specifying the file path, header row, and disabling the index column. The file is assumed to be gzipped and is handled transparently by pandas.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/tests/test_data/xcme/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\ndf = pd.read_csv(\n    \"6EH4.XCME_1min_bars_20240101_20240131.csv.gz\",  # update path as needed\n    header=0,\n    index_col=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame Schema (Trades)\nDESCRIPTION: Displays the schema of the DataFrame resulting from the SQL query on the trade data. This shows the column names and data types.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndf.schema()\n```\n\n----------------------------------------\n\nTITLE: Listing Datasets with Databento API in Python\nDESCRIPTION: This snippet retrieves a list of available datasets from Databento. It uses the `list_datasets()` method of the Databento client to fetch the datasets and prints the result. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndatasets = client.metadata.list_datasets()\ndatasets\n```\n\n----------------------------------------\n\nTITLE: Creating Long-Term Orders on dYdX with Python\nDESCRIPTION: This Python code snippet demonstrates how to construct a long-term (stateful) limit order on dYdX using the Nautilus Trader framework. It includes setting the `is_short_term_order` tag to `False` within the `DYDXOrderTags` to ensure the order persists beyond the current block.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.dydx.common.common import DYDXOrderTags\n\norder: LimitOrder = self.order_factory.limit(\n    instrument_id=self.instrument_id,\n    order_side=OrderSide.BUY,\n    quantity=self.instrument.make_qty(self.trade_size),\n    price=self.instrument.make_price(price),\n    time_in_force=TimeInForce.GTD,\n    expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),\n    post_only=True,\n    emulation_trigger=self.emulation_trigger,\n    tags=[DYDXOrderTags(is_short_term_order=False).value],\n)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Binance Futures Mark Price Updates (Python)\nDESCRIPTION: This snippet demonstrates how to subscribe to `BinanceFuturesMarkPriceUpdate` data streams, which include funding rate information. It involves using the `subscribe_data` method with a `DataType` specifying the custom data type and instrument metadata.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate\nfrom nautilus_trader.model import DataType\nfrom nautilus_trader.model import ClientId\n\n# In your `on_start` method\nself.subscribe_data(\n    data_type=DataType(BinanceFuturesMarkPriceUpdate, metadata={\"instrument_id\": self.instrument.id}),\n    client_id=ClientId(\"BINANCE\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Statistic with PortfolioAnalyzer in Python\nDESCRIPTION: This code snippet shows how to register a custom portfolio statistic, in this case the `WinRate` statistic, with a trader's `PortfolioAnalyzer`. It instantiates the custom statistic and then calls the `register_statistic` method on the `PortfolioAnalyzer` to add the statistic.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/portfolio.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstat = WinRate()\n\nengine.portfolio.analyzer.register_statistic(stat)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for backtesting\nDESCRIPTION: This code snippet imports all the necessary modules from the Nautilus Trader library required to set up and run a backtest. These modules include components for configuring the backtest engine, handling fill models, managing FX rollover interest, defining instruments and currencies, and implementing a simple EMA cross strategy.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.backtest.engine import BacktestEngineConfig\nfrom nautilus_trader.backtest.models import FillModel\nfrom nautilus_trader.backtest.modules import FXRolloverInterestConfig\nfrom nautilus_trader.backtest.modules import FXRolloverInterestModule\nfrom nautilus_trader.config import LoggingConfig\nfrom nautilus_trader.config import RiskEngineConfig\nfrom nautilus_trader.examples.strategies.ema_cross import EMACross\nfrom nautilus_trader.examples.strategies.ema_cross import EMACrossConfig\nfrom nautilus_trader.model import BarType\nfrom nautilus_trader.model import Money\nfrom nautilus_trader.model import Venue\nfrom nautilus_trader.model.currencies import JPY\nfrom nautilus_trader.model.currencies import USD\nfrom nautilus_trader.model.enums import AccountType\nfrom nautilus_trader.model.enums import OmsType\nfrom nautilus_trader.persistence.wranglers import QuoteTickDataWrangler\nfrom nautilus_trader.test_kit.providers import TestDataProvider\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Tardis Machine Configuration Example\nDESCRIPTION: This is an example configuration file in JSON format, used for running Tardis Machine replays. It specifies the WebSocket URL, output path (set to null, defaulting to environment variable), and replay options including exchange, symbols, data types, and time range.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tardis_ws_url\": \"ws://localhost:8001\",\n  \"output_path\": null,\n  \"options\": [\n    {\n      \"exchange\": \"bitmex\",\n      \"symbols\": [\n        \"xbtusd\",\n        \"ethusd\"\n      ],\n      \"data_types\": [\n        \"trade\"\n      ],\n      \"from\": \"2019-10-01\",\n      \"to\": \"2019-10-02\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Recompiling Project after Changes\nDESCRIPTION: This command recompiles the project after changes to `.rs`, `.pyx`, or `.pxd` files. It uses uv to run the `build.py` script, which handles the build process. The `--no-sync` flag prevents uv from automatically syncing dependencies during the build.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nuv run --no-sync python build.py\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader from PyPI\nDESCRIPTION: This command installs the latest version of NautilusTrader from the Python Package Index (PyPI) using pip.  The -U flag ensures that pip upgrades the package if it is already installed. This method retrieves binary wheels or sdist packages.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U nautilus_trader\n```\n\n----------------------------------------\n\nTITLE: Advanced Bar-to-Bar Aggregation in Nautilus Trader (Python)\nDESCRIPTION: This demonstrates a more advanced aggregation setup, creating a chain of aggregations from TradeTick objects to 1-minute bars, then to 5-minute bars, and finally to hourly bars. It uses the @ symbol in the bar type string to specify the source bar for each aggregation level.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# First create 1-minute bars from TradeTick objects (LAST indicates TradeTick source)\nprimary_bar_type = BarType.from_str(\"6EH4.XCME-1-MINUTE-LAST-INTERNAL\")\n\n# Then create 5-minute bars from 1-minute bars\n# Note the @1-MINUTE-INTERNAL part identifying the source bars\nintermediate_bar_type = BarType.from_str(\"6EH4.XCME-5-MINUTE-LAST-INTERNAL@1-MINUTE-INTERNAL\")\n\n# Then create hourly bars from 5-minute bars\n# Note the @5-MINUTE-INTERNAL part identifying the source bars\nhourly_bar_type = BarType.from_str(\"6EH4.XCME-1-HOUR-LAST-INTERNAL@5-MINUTE-INTERNAL\")\n```\n\n----------------------------------------\n\nTITLE: Persisting GreeksData with ParquetDataCatalog in Python\nDESCRIPTION: This code demonstrates how to persist `GreeksData` using Nautilus Trader's `ParquetDataCatalog`. It registers the data type for arrow serialization and provides functions to write `GreeksData` to a parquet file. It relies on `nautilus_trader.persistence.catalog.ParquetDataCatalog` to manage the file system interaction.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nregister_arrow(GreeksData, GreeksData.schema(), GreeksData.to_catalog, GreeksData.from_catalog)\n\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\ncatalog = ParquetDataCatalog('.')\n\ncatalog.write_data([GreeksData()])\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.risk_return_ratio module (reStructuredText)\nDESCRIPTION: This snippet imports the `risk_return_ratio` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_14\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.risk_return_ratio\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Defining data directory path\nDESCRIPTION: This snippet defines the path to the data directory, defaulting to the user's Downloads folder. This path is used to locate the Bybit order book data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Path to your data directory, using user /Downloads as an example\nDATA_DIR = \"~/Downloads\"\n```\n\n----------------------------------------\n\nTITLE: Installing from Source with Betfair Extra\nDESCRIPTION: This command installs the `nautilus_trader` package from source using uv, including the `betfair` extra dependencies. This ensures that all necessary Betfair-related components are installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/betfair.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nuv sync --extra betfair\n```\n\n----------------------------------------\n\nTITLE: Configuring Binance Client for Testnet (Python)\nDESCRIPTION: This snippet demonstrates how to configure both data and execution clients to connect to the Binance testnet by setting the `testnet` option to `True`. It requires providing a testnet API key and secret.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        \"BINANCE\": {\n            \"api_key\": \"YOUR_BINANCE_TESTNET_API_KEY\",\n            \"api_secret\": \"YOUR_BINANCE_TESTNET_API_SECRET\",\n            \"account_type\": \"spot\",  # {spot, margin, usdt_future}\n            \"testnet\": True,  # If client uses the testnet\n        },\n    },\n    exec_clients={\n        \"BINANCE\": {\n            \"api_key\": \"YOUR_BINANCE_TESTNET_API_KEY\",\n            \"api_secret\": \"YOUR_BINANCE_TESTNET_API_SECRET\",\n            \"account_type\": \"spot\",  # {spot, margin, usdt_future}\n            \"testnet\": True,  # If client uses the testnet\n        },\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies in Debug Mode with Make\nDESCRIPTION: This command installs the project in debug mode using the Makefile. Compiling in debug mode is faster and suitable for frequent iteration during development. The command `make install-debug` executes the corresponding build steps defined in the Makefile.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake install-debug\n```\n\n----------------------------------------\n\nTITLE: VSCode Rust Analyzer Configuration\nDESCRIPTION: This JSON snippet configures the Rust analyzer in VSCode. It sets various options, including restarting the server on config changes, specifying linked projects, enabling all features, disabling workspace checks, and setting extra environment variables. Ensure to replace `<path-to-your-virtual-environment>` with the actual path.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n    \"rust-analyzer.restartServerOnConfigChange\": true,\n    \"rust-analyzer.linkedProjects\": [\n        \"Cargo.toml\"\n    ],\n    \"rust-analyzer.cargo.features\": \"all\",\n    \"rust-analyzer.check.workspace\": false,\n    \"rust-analyzer.check.extraEnv\": {\n        \"VIRTUAL_ENV\": \"<path-to-your-virtual-environment>/.venv\",\n        \"CC\": \"clang\",\n        \"CXX\": \"clang++\"\n    },\n    \"rust-analyzer.cargo.extraEnv\": {\n        \"VIRTUAL_ENV\": \"<path-to-your-virtual-environment>/.venv\",\n        \"CC\": \"clang\",\n        \"CXX\": \"clang++\"\n    },\n    \"rust-analyzer.runnables.extraEnv\": {\n        \"VIRTUAL_ENV\": \"<path-to-your-virtual-environment>/.venv\",\n        \"CC\": \"clang\",\n        \"CXX\": \"clang++\"\n    },\n    \"rust-analyzer.check.features\": \"all\",\n    \"rust-analyzer.testExplorer\": true\n```\n\n----------------------------------------\n\nTITLE: Initialize BacktestEngine - Python\nDESCRIPTION: This snippet shows how to initialize a BacktestEngine with a custom configuration. A BacktestEngineConfig object is created with a specified trader_id.  The engine is then instantiated using this configuration.  This allows for customization of the backtest environment.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Configure backtest engine\nconfig = BacktestEngineConfig(trader_id=TraderId(\"BACKTESTER-001\"))\n\n# Build the backtest engine\nengine = BacktestEngine(config=config)\n```\n\n----------------------------------------\n\nTITLE: Display Backtest Result\nDESCRIPTION: This code snippet displays the result of the backtest.  The content of the `result` variable depends on the backtest execution and contains information about the performance and outcome of the simulated trading activity.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nresult\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.returns_avg module (reStructuredText)\nDESCRIPTION: This snippet imports the `returns_avg` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_10\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.returns_avg\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Accessing an instrument from the catalog\nDESCRIPTION: This code shows how to access the first instrument available in the data catalog. The first instrument in the returned list is assigned to the `instrument` variable.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# See 1st instrument from catalog\ninstrument = catalog.instruments()[0]\ninstrument\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Polygon Keys\nDESCRIPTION: These commands set the `POLYGON_PRIVATE_KEY` and `POLYGON_PUBLIC_KEY` environment variables in the current terminal session. These variables are used by the `set_allowances.py` script to sign and send transactions to the Polygon network.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/polymarket.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport POLYGON_PRIVATE_KEY=\"YOUR_PRIVATE_KEY\"\nexport POLYGON_PUBLIC_KEY=\"YOUR_PUBLIC_KEY\"\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.sharpe_ratio module (reStructuredText)\nDESCRIPTION: This snippet imports the `sharpe_ratio` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_15\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.sharpe_ratio\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Writing DBN Data to File\nDESCRIPTION: This snippet demonstrates how to export DBN data to a DBN file using the `to_file` method.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Export to DBN file\ndbn_data.to_file(\"GLBX-ESM2-20220606.ohlcv-1h.dbn.zst\")\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader with Extras\nDESCRIPTION: This command installs NautilusTrader from PyPI along with optional 'extras' dependencies, specified within square brackets.  The -U flag upgrades the package if it is already installed.  Extras provide dependencies required for specific integrations.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -U \"nautilus_trader[docker,ib]\"\n```\n\n----------------------------------------\n\nTITLE: Profiling with Memray CLI\nDESCRIPTION: This command invokes a script (tests/mem_leak_tests/memray_backtest.py) using the Memray CLI with a live port for the profiler dashboard. It initiates the memory profiling process.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/tests/mem_leak_tests/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmemray run --live-port 8100 --live-remote tests/mem_leak_tests/memray_backtest.py\n```\n\n----------------------------------------\n\nTITLE: Adding DBN Data to BacktestEngine in Python\nDESCRIPTION: This code demonstrates how to load DBN data from a file and add it to a `BacktestEngine` in Nautilus Trader. It includes adding an instrument to the engine and loading trades data from the DBN file. It utilizes the DatabentoDataLoader for decoding.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Add instrument\nTSLA_NASDAQ = TestInstrumentProvider.equity(symbol=\"TSLA\")\nengine.add_instrument(TSLA_NASDAQ)\n\n# Decode data to legacy Cython objects\nloader = DatabentoDataLoader()\ntrades = loader.from_dbn_file(\n    path=TEST_DATA_DIR / \"databento\" / \"temp\" / \"tsla-xnas-20240107-20240206.trades.dbn.zst\",\n    instrument_id=TSLA_NASDAQ.id,\n)\n\n# Add data\nengine.add_data(trades)\n```\n\n----------------------------------------\n\nTITLE: DataFrame Cleanup and Transformation - Python\nDESCRIPTION: This snippet transforms time-series data into a Pandas DataFrame. It resets the index, renames columns, drops irrelevant columns, reorders columns, converts the timestamp to the Bratislava timezone, and adjusts the timestamp by adding one minute. It requires the Pandas and pytz libraries.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Cleanup and view data as DataFrame\ndf = (\n    data.to_df()\n    .reset_index()\n    .rename(columns={\"ts_event\": \"datetime\"})\n    .drop(columns=[\"rtype\", \"publisher_id\", \"instrument_id\"])\n\n    # Nice order of columns\n    .reindex(columns=[\"symbol\", \"datetime\", \"open\", \"high\", \"low\", \"close\", \"volume\"])\n\n    # Localize datetime to Bratislava\n    .assign(datetime = lambda df: pd.to_datetime(df[\"datetime\"], utc=True))  # Mark as UTC datetime\n    .assign(datetime = lambda df: df[\"datetime\"].dt.tz_convert(pytz.timezone(\"Europe/Bratislava\")))  # Convert to Bratislava timezone\n\n    # Add 1-minute, so datetime represents closing time of the bar (not opening time)\n    .assign(datetime = lambda df: df[\"datetime\"] + timedelta(minutes=1))\n)\n\n# Preview\nprint(len(df))\ndf.head(3)\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.engine module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.engine` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.engine\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Example Coinbase International Portfolio Output\nDESCRIPTION: This is an example output from the `list_portfolios.py` script, showing the structure of the portfolio details returned by the Coinbase International API.  The `portfolio_id` is used to configure the execution client.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n[{'borrow_disabled': False,\n  'cross_collateral_enabled': False,\n  'is_default': False,\n  'is_lsp': False,\n  'maker_fee_rate': '-0.00008',\n  'name': 'hrp5587988499',\n  'portfolio_id': '3mnk59ap-1-22',  # Your portfolio ID\n  'portfolio_uuid': 'dd0958ad-0c9d-4445-a812-1870fe40d0e1',\n  'pre_launch_trading_enabled': False,\n  'taker_fee_rate': '0.00012',\n  'trading_lock': False,\n  'user_uuid': 'd4fbf7ea-9515-1068-8d60-4de91702c108'}]\n```\n\n----------------------------------------\n\nTITLE: Querying Bar Data with DataFusion\nDESCRIPTION: Executes a SQL query against the `bar_0` table (registered from the bars Parquet file). The query selects all columns and orders the results by the `ts_init` column.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nquery = \"SELECT * FROM bar_0 ORDER BY ts_init\"\ndf = ctx.sql(query)\n```\n\n----------------------------------------\n\nTITLE: Pulling Docker Image\nDESCRIPTION: This command is used to download the latest Nautilus Trader JupyterLab Docker image. It ensures that the image is compatible with the Linux/AMD64 platform.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull ghcr.io/nautechsystems/jupyterlab:nightly --platform linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Load Order Book Updates from CSV (Limited Rows)\nDESCRIPTION: This code snippet loads order book updates from a CSV file into a Pandas DataFrame, limiting the number of rows to 1 million using the `nrows` parameter to save time. `BinanceOrderBookDeltaDataLoader.load()` is used to read the data, and the head of the loaded DataFrame is displayed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Then we'll load the order book updates, to save time here we're limiting to 1 million rows\npath_update = data_path / \"BTCUSDT_T_DEPTH_2022-11-01_depth_update.csv\"\nnrows = 1_000_000\ndf_update = BinanceOrderBookDeltaDataLoader.load(path_update, nrows=nrows)\ndf_update.head()\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Development Wheel\nDESCRIPTION: This command installs a specific development wheel version of NautilusTrader from the Nautech Systems package index. The version number is explicitly specified.  The `--index-url` flag specifies the location of the package index.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install nautilus_trader==1.208.0a20241212 --index-url=https://packages.nautechsystems.io/simple\n```\n\n----------------------------------------\n\nTITLE: Enabling Rust Logging\nDESCRIPTION: This bash command sets the `RUST_LOG` environment variable to `debug`, enabling debug-level logging for Rust applications.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport RUST_LOG=debug\n```\n\n----------------------------------------\n\nTITLE: Documenting Writer (automodule directive)\nDESCRIPTION: This snippet demonstrates documenting the `nautilus_trader.persistence.writer` module, responsible for writing data to persistent storage, using Sphinx's `automodule` directive. The directive includes options to show inheritance, inherited members, all members, and orders them based on their appearance in the source code.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/persistence.md#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.persistence.writer\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Documenting Trading Filters Module\nDESCRIPTION: This snippet documents the `nautilus_trader.trading.filters` module using `automodule`.  It includes directives to show inheritance, inherited members, all members, and orders members by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/trading.md#_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.trading.filters\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with Binance Dependencies\nDESCRIPTION: This command installs the latest version of the `nautilus_trader` package along with the necessary dependencies for Binance integration using pip.  It upgrades the package if it's already installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -U \"nautilus_trader[binance]\"\n```\n\n----------------------------------------\n\nTITLE: Nautilus Trader Model Toctree\nDESCRIPTION: This snippet uses the `toctree` directive in reStructuredText to create a table of contents for the Nautilus Trader model documentation. It includes links to sub-documents such as book.md, data.md, events.md, identifiers.md, instruments.md, objects.md, orders.md, position.md, and tick_scheme.md.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/index.md#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :glob:\n   :titlesonly:\n   :hidden:\n\n   book.md\n   data.md\n   events.md\n   identifiers.md\n   instruments.md\n   objects.md\n   orders.md\n   position.md\n   tick_scheme.md\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader Pre-release\nDESCRIPTION: This command installs the latest available pre-release version (including development wheels) of NautilusTrader from the Nautech Systems package index.  The `--pre` flag allows pip to consider pre-release versions. The -U flag ensures that pip upgrades the package if it is already installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -U nautilus_trader --pre --index-url=https://packages.nautechsystems.io/simple\n```\n\n----------------------------------------\n\nTITLE: Configuring PYO3_PYTHON variable\nDESCRIPTION: This snippet configures the `PYO3_PYTHON` variable in the `.cargo/config.toml` file to point to the Python interpreter within the virtual environment. This is useful for Rust developers to reduce recompile times, particularly when using IDEs with Rust analyzer. The git commands avoid tracking local modifications.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nPYTHON_PATH=$(which python)\necho -e \"\\n[env]\\nPYO3_PYTHON = \\\"$PYTHON_PATH\\\"\" >> .cargo/config.toml\n```\n\n----------------------------------------\n\nTITLE: Getting Record Count from Databento\nDESCRIPTION: This snippet retrieves the number of records for a given dataset, symbols, schema, and time range using the Databento client's `get_record_count` method.  It specifies the dataset, symbols (ESM2, representing an S&P contract), schema (ohlcv-1h, hourly bars), start date, and end date. The result is the count of records that match the specified criteria.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nrecord_count = client.metadata.get_record_count(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],   # ES (S&P contract) expiring in June 2022\n    schema=\"ohlcv-1h\",  # 1 hour bars ; only time-ranges that are multiplies of 10-minutes (cannot be used for 1-min bars)\n    start=\"2022-01-06\", # including start\n    end=\"2022-01-07\"    # excluding end\n)\n\n# There is one hour break on the exchange, so 23 hourly bars are OK\nrecord_count\n```\n\n----------------------------------------\n\nTITLE: Caching GreeksData in Python\nDESCRIPTION: This code snippet illustrates how to cache `GreeksData` using a key derived from the instrument ID.  It defines a function to generate the cache key, and functions to add and retrieve `GreeksData` from the cache by converting the object to bytes before storing and converting back when retrieving. It assumes `self.cache` is an accessible cache object with `add` and `get` methods.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndef greeks_key(instrument_id: InstrumentId):\n    return f\"{instrument_id}_GREEKS\"\n\ndef cache_greeks(self, greeks_data: GreeksData):\n    self.cache.add(greeks_key(greeks_data.instrument_id), greeks_data.to_bytes())\n\ndef greeks_from_cache(self, instrument_id: InstrumentId):\n    return GreeksData.from_bytes(self.cache.get(greeks_key(instrument_id)))\n```\n\n----------------------------------------\n\nTITLE: Generating Module Documentation with automodule\nDESCRIPTION: This snippet uses the `automodule` directive in reStructuredText to automatically generate documentation for the `nautilus_trader.model.events` module. It includes information about the module's classes, functions, and other members.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/events.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.events\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.winner_avg module (reStructuredText)\nDESCRIPTION: This snippet imports the `winner_avg` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_18\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.winner_avg\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Convert JSON to High-Precision Parquet (Bash)\nDESCRIPTION: This bash command converts a JSON file back to Parquet format, specifically for high-precision (128-bit) schema. It uses the `to_parquet` utility and the `--features high-precision` flag to enable the high-precision conversion.  The command is executed from the root of the `nautilus_core/persistence/` crate directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --features high-precision --bin to_parquet trades.json\n```\n\n----------------------------------------\n\nTITLE: Loading Tardis CSV data in Rust\nDESCRIPTION: This code snippet demonstrates how to load Tardis-format CSV data using Rust.  It uses the `nautilus_adapters::tardis::csv::load_deltas` function. The code requires specifying the file path, price precision, and size precision. An instrument ID and a limit on the number of records to load can optionally be provided.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::Path;\n\nuse nautilus_adapters::tardis;\nuse nautilus_model::identifiers::InstrumentId;\n\n#[tokio::main]\nasync fn main() {\n    // You must specify precisions and the CSV filepath\n    let price_precision = 1;\n    let size_precision = 0;\n    let filepath = Path::new(\"YOUR_CSV_DATA_PATH\");\n\n    // Optionally specify an instrument ID and/or limit\n    let instrument_id = InstrumentId::from(\"BTC-PERPETUAL.DERIBIT\");\n    let limit = None;\n\n    // Consider propagating any parsing error depending on your workflow\n    let _deltas = tardis::csv::load_deltas(\n        filepath,\n        price_precision,\n        size_precision,\n        Some(instrument_id),\n        limit,\n    )\n    .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.reporter module (reStructuredText)\nDESCRIPTION: This snippet imports the `reporter` submodule and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.reporter\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Basic MyActor setup with GreeksCalculator in Rust\nDESCRIPTION: This snippet demonstrates the basic setup of a `MyActor` struct that integrates the `GreeksCalculator`. It shows how to create a new `GreeksCalculator` instance within an actor, sharing the same clock and cache.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/crates/common/src/greeks.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::sync::Arc;\n\nuse nautilus_common::{\n    actor::{\n        data_actor::{DataActor, DataActorConfig, DataActorCore},\n        Actor,\n    },\n    cache::Cache,\n    clock::LiveClock,\n    greeks::GreeksCalculator,\n    msgbus::MessagingSwitchboard,\n};\n\nstruct MyActor {\n    core: DataActorCore,\n    greeks_calculator: GreeksCalculator,\n}\n\nimpl MyActor {\n    pub fn new(\n        config: DataActorConfig,\n        cache: Rc<RefCell<Cache>>,\n        clock: Rc<RefCell<LiveClock>>,\n        switchboard: Arc<MessagingSwitchboard>,\n    ) -> Self {\n        let core = DataActorCore::new(config, cache.clone(), clock.clone(), switchboard.clone());\n\n        // Create the GreeksCalculator with the same clock and cache\n        let greeks_calculator = GreeksCalculator::new(\n            cache,\n            clock,\n        );\n\n        Self {\n            core,\n            greeks_calculator,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available Versions\nDESCRIPTION: This command retrieves and lists available versions of NautilusTrader from the Nautech Systems package index. It uses `curl` to fetch the index HTML, `grep` to extract the version links, `awk` to remove fragment identifiers, and `sort` to order the versions.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s https://packages.nautechsystems.io/simple/nautilus-trader/index.html | grep -oP '(?<=<a href=\"))[^\"]+(?=\")' | awk -F'#' '{print $1}' | sort\n```\n\n----------------------------------------\n\nTITLE: Accessing BacktestEngine from BacktestNode\nDESCRIPTION: This snippet retrieves the BacktestEngine used internally by the BacktestNode using the configuration ID. This allows access to additional reports and information generated during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.backtest.engine import BacktestEngine\nfrom nautilus_trader.model import Venue\n\n\nengine: BacktestEngine = node.get_engine(config.id)\n\nengine.trader.generate_order_fills_report()\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.returns_avg_win module (reStructuredText)\nDESCRIPTION: This snippet imports the `returns_avg_win` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_12\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.returns_avg_win\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.long_ratio module (reStructuredText)\nDESCRIPTION: This snippet imports the `long_ratio` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_5\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.long_ratio\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.winner_min module (reStructuredText)\nDESCRIPTION: This snippet imports the `winner_min` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_20\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.winner_min\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.results module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.results` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.results\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Building Project in Debug Mode with Make\nDESCRIPTION: This command compiles the project in debug mode using the Makefile. Compiling in debug mode is faster and suitable for frequent iteration during development. The command `make build-debug` executes the corresponding debug build steps defined in the Makefile.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmake build-debug\n```\n\n----------------------------------------\n\nTITLE: Creating the Nautilus Database\nDESCRIPTION: This SQL command creates the `nautilus` database in Postgres. This database will be used by the Nautilus Trader application. This command is executed after connecting to the Postgres server as the `postgres` administrator.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nCREATE DATABASE nautilus;\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with Betfair Dependencies\nDESCRIPTION: This command installs the `nautilus_trader` package along with its Betfair dependencies using pip. The `-U` flag ensures that the package is upgraded to the latest version if it is already installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/betfair.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install -U \"nautilus_trader[betfair]\"\n```\n\n----------------------------------------\n\nTITLE: Generating Positions Report\nDESCRIPTION: This snippet generates a positions report from the BacktestEngine's trader. This report provides information about the positions held during the backtest.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_positions_report()\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.returns_volatility module (reStructuredText)\nDESCRIPTION: This snippet imports the `returns_volatility` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_13\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.returns_volatility\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Convert Parquet to JSON using to_json (Bash)\nDESCRIPTION: This bash command converts a Parquet file to JSON format using the `to_json` utility. It automatically detects the data type from the filename. The command is executed from the root of the `nautilus_core/persistence/` crate directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --bin to_json trades.parquet\n```\n\n----------------------------------------\n\nTITLE: Publishing and Receiving GreeksData via MessageBus in Python\nDESCRIPTION: This code demonstrates how to publish and subscribe to `GreeksData` using Nautilus Trader's `MessageBus`. It registers the data type for serialization and provides functions to publish data and handle received data. The `publish_data` and `subscribe_data` methods are assumed to be part of the class where these functions are defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nregister_serializable_type(GreeksData, GreeksData.to_dict, GreeksData.from_dict)\n\ndef publish_greeks(self, greeks_data: GreeksData):\n    self.publish_data(DataType(GreeksData), greeks_data)\n\ndef subscribe_to_greeks(self):\n    self.subscribe_data(DataType(GreeksData))\n\ndef on_data(self, data):\n    if isinstance(GreeksData):\n        print(\"Data\", data)\n```\n\n----------------------------------------\n\nTITLE: Load Initial Order Book Snapshot from CSV\nDESCRIPTION: This code snippet loads the initial order book snapshot from a CSV file into a Pandas DataFrame using `BinanceOrderBookDeltaDataLoader.load()`. The `path_snap` variable specifies the path to the snapshot file and the head of the loaded DataFrame is displayed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# First we'll load the initial order book snapshot\npath_snap = data_path / \"BTCUSDT_T_DEPTH_2022-11-01_depth_snap.csv\"\ndf_snap = BinanceOrderBookDeltaDataLoader.load(path_snap)\ndf_snap.head()\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.execution_client module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.execution_client` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.execution_client\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Requesting Instrument Data - Actor Method\nDESCRIPTION: This code snippet shows the `request_instrument` method within an `Actor` class, which is used to request instrument data from a `DataClient`. It constructs a `RequestInstrument` object with the instrument ID and sends it to the client.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# nautilus_trader/common/actor.pyx\n\ncpdef void request_instrument(self, InstrumentId instrument_id, ClientId client_id=None):\n    \"\"\"\n    Request `Instrument` data for the given instrument ID.\n\n    Parameters\n    ----------\n    instrument_id : InstrumentId\n        The instrument ID for the request.\n    client_id : ClientId, optional\n        The specific client ID for the command.\n        If ``None`` then will be inferred from the venue in the instrument ID.\n    \"\"\"\n    Condition.not_none(instrument_id, \"instrument_id\")\n\n    cdef RequestInstrument request = RequestInstrument(\n        instrument_id=instrument_id,\n        start=None,\n        end=None,\n        client_id=client_id,\n        venue=instrument_id.venue,\n        callback=self._handle_instrument_response,\n        request_id=UUID4(),\n        ts_init=self._clock.timestamp_ns(),\n        params=None,\n    )\n\n    self._send_data_req(request)\n```\n\n----------------------------------------\n\nTITLE: Running Tardis Replay with Cargo\nDESCRIPTION: This bash command runs a Tardis replay using the cargo tool.  It invokes the tardis-replay binary with the specified path to the configuration file.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --bin tardis-replay <path_to_your_config>\n```\n\n----------------------------------------\n\nTITLE: Handling Instrument Updates\nDESCRIPTION: This snippet shows how to define an `on_instrument` method to handle instrument updates in Nautilus Trader. This method is called when an instrument is updated in the `DataEngine`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef on_instrument(instrument: Instrument) -> None:\n    # Take some action on an instrument update\n    pass\n```\n\n----------------------------------------\n\nTITLE: Displaying DataFrame (Bars)\nDESCRIPTION: Displays the DataFrame resulting from the SQL query on the bar data. This shows the actual data in a tabular format.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndf\n```\n\n----------------------------------------\n\nTITLE: Running Tardis Replay in Rust\nDESCRIPTION: This Rust program demonstrates how to run a Tardis Machine replay from a configuration file. It initializes a tracing subscriber for logging, reads the configuration filepath, and then calls the `run_tardis_machine_replay_from_config` function from the `nautilus_adapters` crate to start the replay.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, path::PathBuf};\n\nuse nautilus_adapters::tardis::replay::run_tardis_machine_replay_from_config;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::DEBUG)\n        .init();\n\n    let config_filepath = PathBuf::from(\"YOUR_CONFIG_FILEPATH\");\n    run_tardis_machine_replay_from_config(&config_filepath).await;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.auction module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.auction` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.auction\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with Bybit dependencies\nDESCRIPTION: This command installs the latest version of the `nautilus_trader` package along with the necessary `bybit` dependencies using pip. The `-U` flag ensures that any existing installations are updated.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/bybit.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U \"nautilus_trader[bybit]\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Clang (PowerShell)\nDESCRIPTION: This PowerShell command adds the Clang compiler to the system's PATH environment variable. This enables the system to find and use the Clang compiler, which is often required for building software from source.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\n[System.Environment]::SetEnvironmentVariable('path', \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Tools\\Llvm\\x64\\bin\\;\" + $env:Path,\"User\")\n```\n\n----------------------------------------\n\nTITLE: Installing Rustup (Linux/macOS)\nDESCRIPTION: This command installs Rustup, the Rust toolchain installer, on Linux and macOS systems.  It downloads and executes a shell script from the Rustup website.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://sh.rustup.rs -sSf | sh\n```\n\n----------------------------------------\n\nTITLE: Generating Account Report\nDESCRIPTION: This snippet generates an account report for a specific venue (SIM in this case) from the BacktestEngine's trader. This report provides information about the account's performance during the backtest for the given venue.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nengine.trader.generate_account_report(Venue(\"SIM\"))\n```\n\n----------------------------------------\n\nTITLE: Documenting Parquet Catalog (automodule directive)\nDESCRIPTION: This snippet utilizes the Sphinx `automodule` directive to document the `nautilus_trader.persistence.catalog.parquet` module responsible for handling Parquet data catalogs. It specifies the inclusion of inheritance details, inherited members, all members, and source-ordered member listing within the generated documentation using directives.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/persistence.md#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.persistence.catalog.parquet\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Astro Nvim Rust Analyzer Configuration\nDESCRIPTION: This Lua snippet configures the Rust analyzer in Astro Nvim (Neovim + AstroLSP).  It sets various options, including restarting the server on config changes, specifying linked projects, enabling all features, disabling workspace checks, and setting extra environment variables. Ensure to replace `<path-to-your-virtual-environment>` with the actual path.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_14\n\nLANGUAGE: lua\nCODE:\n```\n    config = {\n      rust_analyzer = {\n        settings = {\n          [\"rust-analyzer\"] = {\n            restartServerOnConfigChange = true,\n            linkedProjects = { \"Cargo.toml\" },\n            cargo = {\n              features = \"all\",\n              extraEnv = {\n                VIRTUAL_ENV = \"<path-to-your-virtual-environment>/.venv\",\n                CC = \"clang\",\n                CXX = \"clang++\",\n              },\n            },\n            check = {\n              workspace = false,\n              command = \"check\",\n              features = \"all\",\n              extraEnv = {\n                VIRTUAL_ENV = \"<path-to-your-virtual-environment>/.venv\",\n                CC = \"clang\",\n                CXX = \"clang++\",\n              },\n            },\n            runnables = {\n              extraEnv = {\n                VIRTUAL_ENV = \"<path-to-your-virtual-environment>/.venv\",\n                CC = \"clang\",\n                CXX = \"clang++\",\n              },\n            },\n            testExplorer = true,\n          },\n        },\n      },\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Table Schema (Trades)\nDESCRIPTION: Displays the schema of the PyArrow table containing the trade data. This shows the column names and data types.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntable.schema\n```\n\n----------------------------------------\n\nTITLE: Accessing Order Book from Cache\nDESCRIPTION: This code snippet shows how to access the order book data from the Cache. It demonstrates how to retrieve the current order book, check for the existence of an order book, and get the count of order book updates. It assumes access to the `self.cache` object and requires `instrument_id`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Get current order book\nbook = self.cache.order_book(instrument_id)  # Returns OrderBook or None if no such object exists\n\n# Check if order book exists\nhas_book = self.cache.has_order_book(instrument_id)  # Returns bool indicating if an order book exists\n\n# Get count of order book updates\nupdate_count = self.cache.book_update_count(instrument_id)  # Returns the number of updates received\n```\n\n----------------------------------------\n\nTITLE: Documenting Trading Controller Module\nDESCRIPTION: This snippet documents the `nautilus_trader.trading.controller` module using `automodule`. It includes directives to show inheritance, inherited members, all members, and orders members by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/trading.md#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.trading.controller\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Configuring Backtest Engine\nDESCRIPTION: This snippet configures the backtest engine with a strategy, specifying the strategy path, configuration path, and configuration parameters such as instrument ID, fast period, and slow period. It also sets the logging level to ERROR.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/quickstart.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nengine = BacktestEngineConfig(\n    strategies=[\n        ImportableStrategyConfig(\n            strategy_path=\"__main__:MACDStrategy\",\n            config_path=\"__main__:MACDConfig\",\n            config={\n              \"instrument_id\": instruments[0].id,\n              \"fast_period\": 12,\n              \"slow_period\": 26,\n            },\n        )\n    ],\n    logging=LoggingConfig(log_level=\"ERROR\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.sortino_ratio module (reStructuredText)\nDESCRIPTION: This snippet imports the `sortino_ratio` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_16\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.sortino_ratio\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Enabling High-Precision Mode (128-bit) - Bash\nDESCRIPTION: This snippet demonstrates how to enable high-precision mode (128-bit) for Nautilus Trader. It sets the `HIGH_PRECISION` environment variable to `true` and then executes the `make install-debug` command.  This configuration option affects the precision of value types within the application.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nexport HIGH_PRECISION=true\nmake install-debug\n```\n\n----------------------------------------\n\nTITLE: Retrieving Dataset Range with Databento API in Python\nDESCRIPTION: This snippet demonstrates how to retrieve the available date range for a specific dataset using the Databento API.  It uses the `get_dataset_range()` method with the dataset name as an argument. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\navailable_range = client.metadata.get_dataset_range(dataset=\"GLBX.MDP3\")\navailable_range\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader from Nautech Package Index\nDESCRIPTION: This command installs the latest stable release of NautilusTrader from the Nautech Systems package index.  The `--index-url` flag specifies the location of the package index.  The -U flag ensures that pip upgrades the package if it is already installed.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -U nautilus_trader --index-url=https://packages.nautechsystems.io/simple\n```\n\n----------------------------------------\n\nTITLE: Registering Serializable Types in Nautilus Trader (Python)\nDESCRIPTION: This code snippet shows how to register custom types for serialization within Nautilus Trader's message bus. It defines the function signature for `register_serializable_type`, including the parameters for the class to register, a function to convert the object to a dictionary, and a function to instantiate the object from a dictionary. This allows users to serialize and deserialize their own data structures when using external publishing with the message bus.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef register_serializable_type(\n    cls,\n    to_dict: Callable[[Any], dict[str, Any]],\n    from_dict: Callable[[dict[str, Any]], Any],\n):\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Installing DataFusion\nDESCRIPTION: This command installs the DataFusion library using pip, which is required for querying Parquet files.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install datafusion\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Engines with LogGuard - Python\nDESCRIPTION: This snippet demonstrates how to use a `LogGuard` when running multiple engines sequentially in the same process to prevent logging errors. The `LogGuard` is obtained from the first engine and reused for subsequent engines. Each engine is safely disposed of after its backtest completes. The loop variable `number_of_backtests` defines how many times the backtest is run.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/logging.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlog_guard = None  # Initialize LogGuard reference\n\nfor i in range(number_of_backtests):\n    engine = setup_engine(...)\n\n    # Assign reference to LogGuard\n    if log_guard is None:\n        log_guard = engine.get_log_guard()\n\n    # Add actors and execute the engine\n    actors = setup_actors(...)\n    engine.add_actors(actors)\n    engine.run()\n    engine.dispose()  # Dispose safely\n```\n\n----------------------------------------\n\nTITLE: GreeksData Stub Definition in Python\nDESCRIPTION: This stub definition provides type hints for `GreeksData`, allowing IDEs to provide better code completion and suggestions.  It defines the class structure, attributes, and the constructor signature, including type hints and default values.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core import Data\nfrom nautilus_trader.model import InstrumentId\n\n\nclass GreeksData(Data):\n    instrument_id: InstrumentId\n    delta: float\n\n    def __init__(\n        self,\n        ts_event: int = 0,\n        ts_init: int = 0,\n        instrument_id: InstrumentId = InstrumentId.from_str(\"ES.GLBX\"),\n        delta: float = 0.0,\n  ) -> GreeksData: ...\n```\n\n----------------------------------------\n\nTITLE: Connecting to Memray Profiler Dashboard\nDESCRIPTION: This command connects to the Memray profiler dashboard from another shell, using the specified port (8100). This allows you to view and analyze the memory profiling results.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/tests/mem_leak_tests/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmemray live 8100\n```\n\n----------------------------------------\n\nTITLE: Installing Clang (Linux)\nDESCRIPTION: This command installs Clang, a C language frontend for LLVM, on Debian-based Linux systems using the apt package manager. Clang is needed for building from source.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install clang\n```\n\n----------------------------------------\n\nTITLE: Handling Binance Futures Mark Price Updates in `on_data` (Python)\nDESCRIPTION: This snippet shows how to handle received `BinanceFuturesMarkPriceUpdate` objects within the `on_data` method. It includes a type check to ensure that the received data is of the expected type before processing it.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/binance.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.core import Data\n\ndef on_data(self, data: Data):\n    # First check the type of data\n    if isinstance(data, BinanceFuturesMarkPriceUpdate):\n        # Do something with the data\n```\n\n----------------------------------------\n\nTITLE: Documenting Wranglers (automodule directive)\nDESCRIPTION: This code snippet employs the Sphinx `automodule` directive to document the `nautilus_trader.persistence.wranglers` module, which likely contains data transformation and manipulation functions. It uses options to display inheritance, inherited members, all members, and order members by their source code location.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/persistence.md#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.persistence.wranglers\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Convert JSON to New Schema Parquet (Bash)\nDESCRIPTION: This bash command converts a JSON file back to Parquet format using the `to_parquet` utility, generating a Parquet file with the new schema. The `--features high-precision` flag is added if using a high-precision schema. The command is executed from the root of the `nautilus_core/persistence/` crate directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --features high-precision --bin to_parquet trades.json\n```\n\n----------------------------------------\n\nTITLE: Running Redis in Docker\nDESCRIPTION: This command starts a Redis server in a Docker container. It pulls the latest Redis image from Docker Hub (if not already present), runs the container in detached mode, names the container 'redis', and maps the container's port 6379 to the host's port 6379.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d --name redis -p 6379:6379 redis:latest\n```\n\n----------------------------------------\n\nTITLE: Cache vs Portfolio Example - Python\nDESCRIPTION: This code shows how to access position history and net exposure via the cache and portfolio objects. The cache is used to find position history from an event, whereas the portfolio is used to determine the current net exposure.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass MyStrategy(Strategy):\n    def on_position_changed(self, event: PositionEvent) -> None:\n        # Use Cache when you need historical perspective\n        position_history = self.cache.position_snapshots(event.position_id)\n\n        # Use Portfolio when you need current real-time state\n        current_exposure = self.portfolio.net_exposure(event.instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis module (reStructuredText)\nDESCRIPTION: This snippet imports the main analysis module. The `automodule` directive tells Sphinx to automatically generate documentation from the module's docstrings.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis\n```\n\n----------------------------------------\n\nTITLE: Configuring Cache Capacity\nDESCRIPTION: This code snippet shows how to configure the `Cache` using `CacheConfig` within `BacktestEngineConfig` and `TradingNodeConfig`.  It sets the `tick_capacity` and `bar_capacity` parameters, defining the maximum number of ticks and bars to be stored. It requires the imports of `CacheConfig`, `BacktestEngineConfig`, and `TradingNodeConfig` from `nautilus_trader.config`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.config import CacheConfig, BacktestEngineConfig, TradingNodeConfig\n\n# For backtesting\nengine_config = BacktestEngineConfig(\n    cache=CacheConfig(\n        tick_capacity=10_000,  # Store last 10,000 ticks per instrument\n        bar_capacity=5_000,    # Store last 5,000 bars per bar type\n    ),\n)\n\n# For live trading\nnode_config = TradingNodeConfig(\n    cache=CacheConfig(\n        tick_capacity=10_000,\n        bar_capacity=5_000,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Databento Data Client in Python\nDESCRIPTION: This snippet shows how to configure a live `TradingNode` to include a Databento data client.  It outlines the configuration parameters for the Databento client, including API key, gateways, and instrument settings, within the `TradingNodeConfig`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.databento import DATABENTO\nfrom nautilus_trader.live.node import TradingNode\n\nconfig = TradingNodeConfig(\n    ...,  # Omitted\n    data_clients={\n        DATABENTO: {\n            \"api_key\": None,  # 'DATABENTO_API_KEY' env var\n            \"http_gateway\": None,  # Override for the default HTTP historical gateway\n            \"live_gateway\": None,  # Override for the default raw TCP real-time gateway\n            \"instrument_provider\": InstrumentProviderConfig(load_all=True),\n            \"instrument_ids\": None,  # Nautilus instrument IDs to load on start\n            \"parent_symbols\": None,  # Databento parent symbols to load on start\n        },\n    },\n    ..., # Omitted\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting nautilus_trader.risk.sizing module\nDESCRIPTION: This snippet utilizes the `automodule` directive to generate documentation for the `nautilus_trader.risk.sizing` module. It shows inheritance, includes inherited members, lists all members, and orders members by source code.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/risk.md#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.risk.sizing\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for backtesting\nDESCRIPTION: This code snippet imports all necessary modules for the backtesting process, including modules for data loading, backtest configuration, data wrangling, catalog creation, and instrument definitions. It leverages the Nautilus Trader framework.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport shutil\nfrom decimal import Decimal\nfrom pathlib import Path\n\nimport pandas as pd\n\nfrom nautilus_trader.adapters.bybit.loaders import BybitOrderBookDeltaDataLoader\nfrom nautilus_trader.backtest.node import BacktestDataConfig\nfrom nautilus_trader.backtest.node import BacktestEngineConfig\nfrom nautilus_trader.backtest.node import BacktestNode\nfrom nautilus_trader.backtest.node import BacktestRunConfig\nfrom nautilus_trader.backtest.node import BacktestVenueConfig\nfrom nautilus_trader.config import ImportableStrategyConfig\nfrom nautilus_trader.config import LoggingConfig\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos\nfrom nautilus_trader.model import OrderBookDelta\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\nfrom nautilus_trader.persistence.wranglers import OrderBookDeltaDataWrangler\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Exporting data to DBNStore - Python\nDESCRIPTION: This snippet exports data to a file in the DBNStore format, utilizing the zstd compression algorithm.  It takes the data object and saves it to a file named according to dataset, symbol, start/end dates and the schema. This results in a compressed binary format.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndata.to_file(f\"{dataset}_{symbol}_{start}-{end}.{schema}.dbn.zst\")\n```\n\n----------------------------------------\n\nTITLE: Nautilus Trader Model Automodule\nDESCRIPTION: This snippet uses the `automodule` directive in reStructuredText to automatically generate documentation for the `nautilus_trader.model` module. This includes class, function, and variable documentation extracted from the module's source code.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/index.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model\n```\n\n----------------------------------------\n\nTITLE: Documenting nautilus_trader.risk module\nDESCRIPTION: This snippet uses the `automodule` directive in reStructuredText to automatically generate documentation for the `nautilus_trader.risk` module. It includes all classes, functions, and variables defined within the module.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/risk.md#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.risk\n```\n\n----------------------------------------\n\nTITLE: Documenting Trading Trader Module\nDESCRIPTION: This snippet documents the `nautilus_trader.trading.trader` module using `automodule`. It includes directives to show inheritance, inherited members, all members, and orders members by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/trading.md#_snippet_4\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.trading.trader\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Define Data Directory for Binance Data\nDESCRIPTION: This code snippet defines the path to the directory containing the Binance order book data, using the user's Downloads directory as an example.  The `DATA_DIR` variable is used in subsequent code snippets to load data files.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Path to your data directory, using user /Downloads as an example\nDATA_DIR = \"~/Downloads\"\n```\n\n----------------------------------------\n\nTITLE: Running the set_allowances.py Script\nDESCRIPTION: This command executes the `set_allowances.py` script, which automates the process of approving allowances for Polymarket's smart contracts. This script is essential for allowing the Polymarket contracts to interact with your funds when executing trades.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/polymarket.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython nautilus_trader/adapters/polymarket/scripts/set_allowances.py\n```\n\n----------------------------------------\n\nTITLE: Implementing a Live Execution Client in Python\nDESCRIPTION: This code defines an abstract `TemplateLiveExecutionClient` class that inherits from `LiveExecutionClient`.  It demonstrates the methods that must be implemented by a subclass to handle order management (submit, modify, cancel) and report generation (order status, fills, position status). It raises `NotImplementedError` for each method, forcing subclasses to provide concrete implementations.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/adapters.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.execution.messages import BatchCancelOrders, CancelAllOrders, CancelOrder, ModifyOrder, SubmitOrder\nfrom nautilus_trader.execution.reports import FillReport, OrderStatusReport, PositionStatusReport\nfrom nautilus_trader.live.execution_client import LiveExecutionClient\nfrom nautilus_trader.model import ClientOrderId, InstrumentId, VenueOrderId\n\nclass TemplateLiveExecutionClient(LiveExecutionClient):\n    \"\"\"\n    An example of a ``LiveExecutionClient`` highlighting the method requirements.\n    \"\"\"\n\n    async def _connect(self) -> None:\n        raise NotImplementedError(\"method `_connect` must be implemented in the subclass\")\n\n    async def _disconnect(self) -> None:\n        raise NotImplementedError(\"method `_disconnect` must be implemented in the subclass\")\n\n    async def _submit_order(self, command: SubmitOrder) -> None:\n        raise NotImplementedError(\"method `_submit_order` must be implemented in the subclass\")\n\n    async def _modify_order(self, command: ModifyOrder) -> None:\n        raise NotImplementedError(\"method `_modify_order` must be implemented in the subclass\")\n\n    async def _cancel_order(self, command: CancelOrder) -> None:\n        raise NotImplementedError(\"method `_cancel_order` must be implemented in the subclass\")\n\n    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:\n        raise NotImplementedError(\"method `_cancel_all_orders` must be implemented in the subclass\")\n\n    async def _batch_cancel_orders(self, command: BatchCancelOrders) -> None:\n        raise NotImplementedError(\"method `_batch_cancel_orders` must be implemented in the subclass\")\n\n    async def generate_order_status_report(\n        self, instrument_id: InstrumentId, client_order_id: ClientOrderId | None = None, venue_order_id: VenueOrderId | None = None\n    ) -> OrderStatusReport | None:\n        raise NotImplementedError(\"method `generate_order_status_report` must be implemented in the subclass\")\n\n    async def generate_order_status_reports(\n        self, instrument_id: InstrumentId | None = None, start: pd.Timestamp | None = None, end: pd.Timestamp | None = None, open_only: bool = False\n    ) -> list[OrderStatusReport]:\n        raise NotImplementedError(\"method `generate_order_status_reports` must be implemented in the subclass\")\n\n    async def generate_fill_reports(\n        self, instrument_id: InstrumentId | None = None, venue_order_id: VenueOrderId | None = None, start: pd.Timestamp | None = None, end: pd.Timestamp | None = None\n    ) -> list[FillReport]:\n        raise NotImplementedError(\"method `generate_fill_reports` must be implemented in the subclass\")\n\n    async def generate_position_status_reports(\n        self, instrument_id: InstrumentId | None = None, start: pd.Timestamp | None = None, end: pd.Timestamp | None = None\n    ) -> list[PositionStatusReport]:\n        raise NotImplementedError(\"method `generate_position_status_reports` must be implemented in the subclass\")\n```\n\n----------------------------------------\n\nTITLE: Installing NautilusTrader with Polymarket Dependencies\nDESCRIPTION: This command installs the latest version of the `nautilus_trader` package along with the required `polymarket` dependencies using pip. It ensures that all necessary packages are installed for the Polymarket integration to function correctly.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/polymarket.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U \"nautilus_trader[polymarket]\"\n```\n\n----------------------------------------\n\nTITLE: Position State Queries from Cache - Python\nDESCRIPTION: This code shows how to query position states using the Nautilus Trader `Cache`. It covers checking if a position exists, if it's open or closed, and retrieving orders related to a specific position or the position associated with a specific order. Requires `position_id` and `client_order_id` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Check position states\nexists = self.cache.position_exists(position_id)        # Checks if a position with the given ID exists\nis_open = self.cache.is_position_open(position_id)      # Checks if a position is open\nis_closed = self.cache.is_position_closed(position_id)  # Checks if a position is closed\n\n# Get position and order relationships\norders = self.cache.orders_for_position(position_id)       # All orders related to a specific position\nposition = self.cache.position_for_order(client_order_id)  # Find the position associated with a specific order\n```\n\n----------------------------------------\n\nTITLE: Installing from Source Using uv\nDESCRIPTION: This command installs the `nautilus_trader` package from source using the uv package manager, including the `polymarket` extra dependencies. This approach is useful when working directly with the source code and requiring the Polymarket integration.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/polymarket.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv sync --extra polymarket\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.win_rate module (reStructuredText)\nDESCRIPTION: This snippet imports the `win_rate` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_17\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.win_rate\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Configuring EMACrossTWAP Strategy - Python\nDESCRIPTION: This code configures an EMACrossTWAP strategy, specifying parameters such as instrument ID, bar type, trade size, EMA periods, and TWAP horizon and interval. These parameters dictate the strategy's behavior, including order splitting.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/execution.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nconfig = EMACrossTWAPConfig(\n    instrument_id=ETHUSDT_BINANCE.id,\n    bar_type=BarType.from_str(\"ETHUSDT.BINANCE-250-TICK-LAST-INTERNAL\"),\n    trade_size=Decimal(\"0.05\"),\n    fast_ema_period=10,\n    slow_ema_period=20,\n    twap_horizon_secs=10.0,  # <-- execution algorithm param\n    twap_interval_secs=2.5,  # <-- execution algorithm param\n)\n\n# Instantiate and add your strategy\nstrategy = EMACrossTWAP(config=config)\n```\n\n----------------------------------------\n\nTITLE: Actor-Based Signal Publish/Subscribe Example - Python\nDESCRIPTION: This snippet shows how to publish and subscribe to simple notifications (signals) within the Actor framework in Nautilus Trader. It defines signal constants, subscribes to signals using `subscribe_signal`, publishes a signal using `publish_signal`, and handles the received signal in the `on_signal` handler.  Signals are lightweight and suitable for simple alerts or status updates.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/message_bus.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Define signal constants for better organization (optional but recommended)\nimport types\nsignals = types.SimpleNamespace()\nsignals.NEW_HIGHEST_PRICE = \"NewHighestPriceReached\"\nsignals.NEW_LOWEST_PRICE = \"NewLowestPriceReached\"\n\n# Subscribe to signals (in Actor/Strategy)\nself.subscribe_signal(signals.NEW_HIGHEST_PRICE)\nself.subscribe_signal(signals.NEW_LOWEST_PRICE)\n\n# Publish a signal (in Actor/Strategy)\nself.publish_signal(\n    name=signals.NEW_HIGHEST_PRICE,\n    value=signals.NEW_HIGHEST_PRICE,  # value can be the same as name for simplicity\n    ts_event=bar.ts_event,  # timestamp from triggering event\n)\n\n# Handler (this is static callback function with fixed name)\ndef on_signal(self, signal):\n    # IMPORTANT: We match against signal.value, not signal.name\n    match signal.value:\n        case signals.NEW_HIGHEST_PRICE:\n            self.log.info(\n                f\"New highest price was reached. | \"\n                f\"Signal value: {signal.value} | \"\n                f\"Signal time: {unix_nanos_to_dt(signal.ts_event)}\",\n                color=LogColor.GREEN\n            )\n        case signals.NEW_LOWEST_PRICE:\n            self.log.info(\n                f\"New lowest price was reached. | \"\n                f\"Signal value: {signal.value} | \"\n                f\"Signal time: {unix_nanos_to_dt(signal.ts_event)}\",\n                color=LogColor.RED\n            )\n```\n\n----------------------------------------\n\nTITLE: Loading AAPL Trade Data from DBN to Pandas DataFrame\nDESCRIPTION: This snippet loads AAPL trade data from a DBN file into a Pandas DataFrame for inspection.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndata = DBNStore.from_file(path)\n\ndf = data.to_df()\ndf\n```\n\n----------------------------------------\n\nTITLE: Listing raw data files in Python\nDESCRIPTION: This snippet constructs the full path to the raw data directory, iterates through its contents, and asserts that there are files present. It lists the files found in the specified directory, checking for the existence of historical data files.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/loading_external_data.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npath = Path(DATA_DIR).expanduser() / \"HISTDATA\"\nraw_files = list(path.iterdir())\nassert raw_files, f\"Unable to find any histdata files in directory {path}\"\nraw_files\n```\n\n----------------------------------------\n\nTITLE: Documenting Persistence Module (automodule directive)\nDESCRIPTION: This snippet uses the Sphinx `automodule` directive to automatically generate documentation for the `nautilus_trader.persistence` Python module.  It extracts the module's structure and docstrings to create comprehensive API documentation.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/persistence.md#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.persistence\n```\n\n----------------------------------------\n\nTITLE: Building IBContracts for Options Instruments with Expiry\nDESCRIPTION: This code snippet demonstrates how to create an `IBContract` instance to load Options Instruments with a specific expiry date.  It sets `secType` to \"IND\", `symbol` to \"SPX\", `exchange` to \"CBOE\", and `build_options_chain` to `True`. The `lastTradeDateOrContractMonth` is set to a specific date to filter the options.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/ib.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfor_loading_instrument_expiry = IBContract(\n    secType=\"IND\",\n    symbol=\"SPX\",\n    exchange=\"CBOE\",\n    build_options_chain=True,\n    lastTradeDateOrContractMonth='20240718',\n)\n```\n\n----------------------------------------\n\nTITLE: Data Engine Request Handling\nDESCRIPTION: This code demonstrates how the `DataEngine` handles a `RequestInstrument`. It routes the request to the appropriate `DataClient` and calls the `request_instrument` method on that client.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/adapters.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# nautilus_trader/data/engine.pyx\n\nself._msgbus.register(endpoint=\"DataEngine.request\", handler=self.request)\n\ncpdef void request(self, RequestData request):\n    self._handle_request(request)\n\ncpdef void _handle_request(self, RequestData request):\n    cdef DataClient client = self._clients.get(request.client_id)\n\n    if client is None:\n        client = self._routing_map.get(request.venue, self._default_client)\n\n    if isinstance(request, RequestInstrument):\n        self._handle_request_instrument(client, request)\n\ncpdef void _handle_request_instrument(self, DataClient client, RequestInstrument request):\n    client.request_instrument(request)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.profit_factor module (reStructuredText)\nDESCRIPTION: This snippet imports the `profit_factor` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_9\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.profit_factor\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Creating a Limit-If-Touched Order - Nautilus Trader Python\nDESCRIPTION: This snippet demonstrates how to create a Limit-If-Touched order in Nautilus Trader. It creates a BUY order for 5 BTCUSDT-PERP contracts on the Binance Futures exchange, with a limit price of 30,100 USDT, triggered when the market hits 30,150 USDT based on the last price, expiring on June 6th, 2022. It utilizes the LimitIfTouched class and sets parameters such as instrument_id, order_side, quantity, price, trigger_price, trigger_type, time_in_force, expire_time, post_only, reduce_only, and tags.  It imports the pandas library for timestamp handling.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/orders.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nfrom nautilus_trader.model.enums import OrderSide\nfrom nautilus_trader.model.enums import TimeInForce\nfrom nautilus_trader.model.enums import TriggerType\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.model import Price\nfrom nautilus_trader.model import Quantity\nfrom nautilus_trader.model import LimitIfTouched\n\norder: LimitIfTouched = self.order_factory.limit_if_touched(\n    instrument_id=InstrumentId.from_str(\"BTCUSDT-PERP.BINANCE\"),\n    order_side=OrderSide.BUY,\n    quantity=Quantity.from_int(5),\n    price=Price.from_str(\"30_100\"),\n    trigger_price=Price.from_str(\"30_150\"),\n    trigger_type=TriggerType.LAST_PRICE,  # <-- optional (default DEFAULT)\n    time_in_force=TimeInForce.GTD,  # <-- optional (default GTC)\n    expire_time=pd.Timestamp(\"2022-06-06T12:00\"),\n    post_only=True,  # <-- optional (default False)\n    reduce_only=False,  # <-- optional (default False)\n    tags=[\"TAKE_PROFIT\"],  # <-- optional (default None)\n)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.loser_min module (reStructuredText)\nDESCRIPTION: This snippet imports the `loser_min` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_8\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.loser_min\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Running Tardis Machine with Docker\nDESCRIPTION: This command starts the `tardis-machine` server using Docker, mapping ports 8000 and 8001 and setting the TM_API_KEY environment variable. The server is started in detached mode (-d).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/tardis.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 8000:8000 -p 8001:8001 -e \"TM_API_KEY=YOUR_API_KEY\" -d tardisdev/tardis-machine\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.returns_avg_loss module (reStructuredText)\nDESCRIPTION: This snippet imports the `returns_avg_loss` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_11\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.returns_avg_loss\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.loser_max module (reStructuredText)\nDESCRIPTION: This snippet imports the `loser_max` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_7\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.loser_max\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Downloading 1-min 6E data\nDESCRIPTION: This snippet provides an example of downloading 1-minute data for the 6E symbol (Euro FX futures) using the Databento client. It configures settings for the dataset, symbol, symbology type, schema, and time range. It calculates the cost of the data using `get_cost` and then downloads the data using `get_range`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\n\nimport pandas as pd\nimport pytz\n\n\npd.set_option(\"display.max_columns\", None)\npd.set_option(\"display.max_rows\", None)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Settings\ndataset=\"GLBX.MDP3\"\nsymbol=\"6E.v.0\"\nstype_in=\"continuous\"\nschema=\"ohlcv-1m\"\nstart=\"2025-01-01\"\nend=\"2025-01-05\"\n```\n\nLANGUAGE: python\nCODE:\n```\n# Check costs in dollars\ncost = client.metadata.get_cost(\n    dataset=dataset,\n    symbols=[symbol],\n    stype_in=stype_in,\n    schema=schema,\n    start=start,\n    end=end,\n)\n\nprint(f\"{cost:.2f}$\")\n```\n\nLANGUAGE: python\nCODE:\n```\n# Download data\ndata = client.timeseries.get_range(\n    dataset=dataset,\n    symbols=[symbol],\n    stype_in=stype_in,\n    schema=schema,\n    start=start,\n    end=end,\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.models module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.models` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.models\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Starting Services with Docker Compose\nDESCRIPTION: This command starts the services defined in the `docker-compose.yml` file in detached mode (`-d`). This sets up the Nautilus working environment, including Postgres, Redis, and pgAdmin. The docker-compose file is located in the `.docker` directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Configuring a Fill Model\nDESCRIPTION: This code snippet configures a `FillModel` for the backtest. The fill model simulates the execution of orders by specifying the probability of a fill on limit and stop orders, as well as the probability of slippage. A random seed is also specified for reproducibility.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_fx_bars.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfill_model = FillModel(\n    prob_fill_on_limit=0.2,\n    prob_fill_on_stop=0.95,\n    prob_slippage=0.5,\n    random_seed=42,\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Order Book Module Documentation\nDESCRIPTION: This reStructuredText snippet uses the `automodule` directive to automatically generate documentation for the `nautilus_trader.model.book` module. It includes options to display inheritance, inherited members, all members, and sorts them by their source code order. This automates the creation of API documentation for the specified module.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/book.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.book\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Confirm Instrument Writing to Catalog\nDESCRIPTION: This code snippet confirms that the instrument was successfully written to the data catalog by calling `catalog.instruments()`.  This method retrieves all instruments stored in the catalog.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Confirm the instrument was written\ncatalog.instruments()\n```\n\n----------------------------------------\n\nTITLE: Account Access from Cache - Python\nDESCRIPTION: This code snippet shows how to access account information using the Nautilus Trader's `Cache`. It demonstrates retrieving accounts by ID or venue, retrieving the account ID for a venue, and retrieving all accounts in the cache. Requires `account_id` and `venue` to be defined.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Access account information\naccount = self.cache.account(account_id)       # Retrieve account by ID\naccount = self.cache.account_for_venue(venue)  # Retrieve account for a specific venue\naccount_id = self.cache.account_id(venue)      # Retrieve account ID for a venue\naccounts = self.cache.accounts()               # Retrieve all accounts in the cache\n```\n\n----------------------------------------\n\nTITLE: Converting pyo3 Price to Cython Price in Python\nDESCRIPTION: This snippet demonstrates how to convert a pyo3 `Price` object to a legacy Cython `Price` object. It's used for compatibility between the Rust-based Databento adapter and Cython-based Nautilus Trader components, particularly when dealing with price data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/databento.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprice = Price.from_raw(pyo3_price.raw, pyo3_price.precision)\n```\n\n----------------------------------------\n\nTITLE: Defining Instrument Constructor\nDESCRIPTION: This snippet shows how to define an Instrument using its constructor in Nautilus Trader. It imports the Instrument class and then instantiates it with necessary parameters. The parameters needed for instantiation are not provided in the snippet, the user must define them.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model.instruments import Instrument\n\ninstrument = Instrument(...)  # <-- provide all necessary parameters\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Nautilus Trader Data Catalog\nDESCRIPTION: This snippet imports necessary libraries for creating and managing a Nautilus Trader data catalog. It includes modules for file manipulation (`shutil`, `Path`), data loading (`DatabentoDataLoader`), and catalog management (`ParquetDataCatalog`).\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport shutil\nfrom pathlib import Path\n\nfrom nautilus_trader.adapters.databento.loaders import DatabentoDataLoader\nfrom nautilus_trader.model import InstrumentId\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\n```\n\n----------------------------------------\n\nTITLE: Creating TradingNode and Client Factories\nDESCRIPTION: This Python code demonstrates how to create a TradingNode and add the Coinbase International live data and execution client factories. This step is necessary to enable live trading with Coinbase International within NautilusTrader.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/coinbase_intx.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.coinbase_intx.constants import COINBASE_INTX\nfrom nautilus_trader.adapters.coinbase_intx.factories import CoinbaseIntxLiveDataClientFactory\nfrom nautilus_trader.adapters.coinbase_intx.factories import CoinbaseIntxLiveExecClientFactory\nfrom nautilus_trader.live.node import TradingNode\n```\n\n----------------------------------------\n\nTITLE: Listing Publishers with Databento API in Python\nDESCRIPTION: This snippet demonstrates how to retrieve a list of data publishers using the Databento API. It initializes the Databento client, calls the `list_publishers()` method, and prints the first five publishers. The `databento` library is a dependency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npublishers = client.metadata.list_publishers()\n\n# Show only first five from long list\npublishers[:5]\n```\n\n----------------------------------------\n\nTITLE: Getting Catalog Path as String\nDESCRIPTION: This snippet converts the catalog path to a string. The string representation of catalog path is used for configuring backtest data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_high_level.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nstr(CATALOG_PATH)\n```\n\n----------------------------------------\n\nTITLE: Getting Current UTC Timestamp as pandas Timestamp (Python)\nDESCRIPTION: This snippet demonstrates how to retrieve the current UTC timestamp as a timezone-aware pandas Timestamp using the `clock.utc_now()` method. It requires the `pandas` library to be imported. The `self.clock` attribute provides access to the Clock instance.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\n\nnow: pd.Timestamp = self.clock.utc_now()\n```\n\n----------------------------------------\n\nTITLE: Canceling a Batch of Orders (Python)\nDESCRIPTION: This snippet demonstrates how to cancel a batch of orders using the `cancel_orders()` method. It requires importing `Order` from `nautilus_trader.model`.  The input `my_order_list` must be a list of `Order` objects.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.model import Order\n\n\nmy_order_list: list[Order] = [order1, order2, order3]\nself.cancel_orders(my_order_list)\n```\n\n----------------------------------------\n\nTITLE: Getting Current UTC Timestamp as Nanoseconds (Python)\nDESCRIPTION: This snippet demonstrates how to retrieve the current UTC timestamp as the number of nanoseconds since the UNIX epoch using the `clock.timestamp_ns()` method. The `self.clock` attribute provides access to the Clock instance.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nunix_nanos: int = self.clock.timestamp_ns()\n```\n\n----------------------------------------\n\nTITLE: Import Dependencies for Backtesting with NautilusTrader\nDESCRIPTION: This code snippet imports necessary modules from standard libraries and the NautilusTrader library, including modules for file system operations, data manipulation with Pandas, Binance data loading, backtest configurations, core data structures, data persistence, and test utilities.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport shutil\nfrom decimal import Decimal\nfrom pathlib import Path\n\nimport pandas as pd\n\nfrom nautilus_trader.adapters.binance.loaders import BinanceOrderBookDeltaDataLoader\nfrom nautilus_trader.backtest.node import BacktestDataConfig\nfrom nautilus_trader.backtest.node import BacktestEngineConfig\nfrom nautilus_trader.backtest.node import BacktestNode\nfrom nautilus_trader.backtest.node import BacktestRunConfig\nfrom nautilus_trader.backtest.node import BacktestVenueConfig\nfrom nautilus_trader.config import ImportableStrategyConfig\nfrom nautilus_trader.config import LoggingConfig\nfrom nautilus_trader.core.datetime import dt_to_unix_nanos\nfrom nautilus_trader.model import OrderBookDelta\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\nfrom nautilus_trader.persistence.wranglers import OrderBookDeltaDataWrangler\nfrom nautilus_trader.test_kit.providers import TestInstrumentProvider\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies with Make\nDESCRIPTION: This command uses the Makefile to install the project with development and test dependencies. The Makefile provides a simplified interface for common build tasks. The command `make install` internally manages the installation process defined in the Makefile.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Running Docker Container\nDESCRIPTION: This command runs the Nautilus Trader JupyterLab Docker container and exposes the Jupyter port (8888) to the host machine. This allows access to the Jupyter notebook server through a web browser.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/index.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 8888:8888 ghcr.io/nautechsystems/jupyterlab:nightly\n```\n\n----------------------------------------\n\nTITLE: Setting up the Pre-Commit Hook\nDESCRIPTION: This command installs the pre-commit hook, which automatically runs checks, auto-formatters, and linting tools at commit time. This helps to enforce code quality and consistency. The `pre-commit install` command sets up the necessary Git hooks.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/environment_setup.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Resolving Symbols with Databento\nDESCRIPTION: This snippet resolves a list of symbols from one symbology type to another using the Databento client's `resolve` method. The example demonstrates converting a raw symbol (ESM2) to an instrument ID. It requires specifying the dataset, input symbol(s), input symbology type (stype_in), output symbology type (stype_out), start date, and end date. The output is a dictionary containing the resolved symbol information.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_overview.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nresult = client.symbology.resolve(\n    dataset=\"GLBX.MDP3\",\n    symbols=[\"ESM2\"],\n    stype_in=\"raw_symbol\",\n    stype_out=\"instrument_id\",\n    start_date=\"2022-06-01\",\n    end_date=\"2022-06-30\",\n)\n\nresult\n```\n\n----------------------------------------\n\nTITLE: Canceling an Individual Order (Python)\nDESCRIPTION: This snippet shows how to cancel an individual order using the `cancel_order()` method.  It takes an `order` object as input, which should be a pre-existing order object.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/strategies.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nself.cancel_order(order)\n```\n\n----------------------------------------\n\nTITLE: Currency Loading from Cache - Python\nDESCRIPTION: This code snippet shows how to load currency data using the Nautilus Trader's `Cache`. It demonstrates how to load currency data for a specific currency, in this case, USD.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/cache.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Get currency information\ncurrency = self.cache.load_currency(\"USD\")  # Loads currency data for USD\n```\n\n----------------------------------------\n\nTITLE: Initializing Databento Data Loader\nDESCRIPTION: This snippet initializes a `DatabentoDataLoader`, which is used to decode and load data from Databento DBN files into Nautilus Trader objects.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nloader = DatabentoDataLoader()\n```\n\n----------------------------------------\n\nTITLE: Initial Margin Calculation\nDESCRIPTION: This snippet presents the formula for calculating the initial margin in Nautilus Trader. It includes notional value, leverage, margin rate, and taker fee.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Initial margin calculation\nmargin_init = (notional_value / leverage * margin_init) + (notional_value / leverage * taker_fee)\n```\n\n----------------------------------------\n\nTITLE: Enabling Cargo (Linux/macOS)\nDESCRIPTION: This command enables `cargo` (Rust's package manager and build system) in the current shell by sourcing the environment configuration script provided by Rustup.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsource $HOME/.cargo/env\n```\n\n----------------------------------------\n\nTITLE: Disposing of the Engine - Python\nDESCRIPTION: This snippet demonstrates how to dispose of the BacktestEngine object. This frees up resources once the backtest and analysis are complete.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/backtest_low_level.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Once done, good practice to dispose of the object if the script continues\nengine.dispose()\n```\n\n----------------------------------------\n\nTITLE: Docker Image Pull Command\nDESCRIPTION: This command pulls the latest NautilusTrader JupyterLab Docker image from GitHub Container Registry.  It specifies the platform as linux/amd64.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/index.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndocker pull ghcr.io/nautechsystems/jupyterlab:nightly --platform linux/amd64\n```\n\n----------------------------------------\n\nTITLE: Running the create_api_key.py Script\nDESCRIPTION: This command executes the `create_api_key.py` script, which generates API credentials required for interacting with the Polymarket CLOB API. These credentials are used for authentication and authorization when sending requests to the Polymarket platform.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/polymarket.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython nautilus_trader/adapters/polymarket/scripts/create_api_key.py\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing NautilusTrader from Source\nDESCRIPTION: This set of commands clones the NautilusTrader repository from GitHub, navigates to the project directory, and installs dependencies using uv. `--depth 1` creates a shallow clone, fetching only the latest commit.  `uv sync --all-extras` installs all optional dependencies.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --branch develop --depth 1 https://github.com/nautechsystems/nautilus_trader\ncd nautilus_trader\nuv sync --all-extras\n```\n\n----------------------------------------\n\nTITLE: Confirming Instrument in Catalog\nDESCRIPTION: This snippet confirms the instrument was successfully written to the catalog by retrieving it.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_bybit_orderbook.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Confirm the instrument was written\ncatalog.instruments()\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries\nDESCRIPTION: Imports the necessary libraries: `datafusion` for querying Parquet files and `pyarrow.parquet` for reading Parquet files into PyArrow tables.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport datafusion\nimport pyarrow.parquet as pq\n```\n\n----------------------------------------\n\nTITLE: Updating a Synthetic Instrument's Formula (Python)\nDESCRIPTION: This code shows how to update a synthetic instrument's formula at runtime. It retrieves the synthetic instrument from the cache, updates the formula, and then updates the synthetic instrument within the system.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n# Recover the synthetic instrument from the cache (assuming `synthetic_id` was assigned)\nsynthetic = self.cache.synthetic(self._synthetic_id)\n\n# Update the formula, here is a simple example of just taking the average\nnew_formula = \"(BTCUSDT.BINANCE + ETHUSDT.BINANCE) / 2\"\nsynthetic.change_formula(new_formula)\n\n# Now update the synthetic instrument\nself.update_synthetic(synthetic)\n```\n\n----------------------------------------\n\nTITLE: Installing Nautilus Trader with dYdX dependencies\nDESCRIPTION: This command installs the latest nautilus_trader package along with the dydx dependencies using pip. It ensures that all necessary components for interacting with the dYdX exchange are included in the installation.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/integrations/dydx.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -U \"nautilus_trader[dydx]\"\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for DBN Data Handling\nDESCRIPTION: This snippet imports necessary libraries for handling Databento DBN data format. It includes `Path` from `pathlib` for file path manipulation and `DBNStore` from `databento` for reading DBN files.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/databento_data_catalog.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\n\nfrom databento import DBNStore\n```\n\n----------------------------------------\n\nTITLE: Maintenance Margin Calculation\nDESCRIPTION: This snippet shows the formula for calculating the maintenance margin in Nautilus Trader. It includes notional value, leverage, margin rate, and taker fee.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Maintenance margin calculation\nmargin_maint = (notional_value / leverage * margin_maint) + (notional_value / leverage * taker_fee)\n```\n\n----------------------------------------\n\nTITLE: Documenting Trading Strategy Module\nDESCRIPTION: This snippet documents the `nautilus_trader.trading.strategy` module using `automodule`. It includes directives to show inheritance, inherited members, all members, and orders members by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/trading.md#_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.trading.strategy\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit hook\nDESCRIPTION: This code snippet shows how to install pre-commit, which is used to automatically run code checks, formatters, and linters before each commit. This helps to ensure code quality and consistency.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Installing Memray via PyPI\nDESCRIPTION: This command installs the Memray package using pip. Memray is a memory profiler used for performance testing, but is not a development dependency due to lack of Windows support.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/tests/mem_leak_tests/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install memray\n```\n\n----------------------------------------\n\nTITLE: Convert Old Schema Parquet to JSON (Bash)\nDESCRIPTION: This bash command converts a Parquet file with an older schema to JSON format using the `to_json` utility. The `--features high-precision` flag is included if the source data uses a high-precision (128-bit) schema. The command is executed from the root of the `nautilus_core/persistence/` crate directory.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --bin to_json trades.parquet\n```\n\n----------------------------------------\n\nTITLE: Documenting backtest.node module in Nautilus Trader (Python)\nDESCRIPTION: This snippet uses the `automodule` directive to generate documentation for the `nautilus_trader.backtest.node` module. It also configures the documentation to show inheritance, inherited members, all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/backtest.md#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: nautilus_trader.backtest.node\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Reading Trade Data with PyArrow\nDESCRIPTION: Reads the trade data Parquet file into a PyArrow table. This provides an alternative way to access the data.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/parquet_explorer.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntable = pq.read_table(trade_tick_path)\n```\n\n----------------------------------------\n\nTITLE: Automodule Directive for Position - ReStructuredText\nDESCRIPTION: This snippet uses the `automodule` directive in ReStructuredText to generate documentation for the `nautilus_trader.model.position` module. It includes options to show inheritance, inherited members, all members, and order members by source code order. This is used to automatically document Python modules within the Sphinx documentation system.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/position.md#_snippet_0\n\nLANGUAGE: ReStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.position\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Debugging Rust Tests Configuration\nDESCRIPTION: This configuration modifies the run configuration of a parameterized Rust test in IntelliJ IDEA to enable debugging. It involves removing `-- --exact` from the end of the test string and appending `::case_n`, where `n` corresponds to the desired test case's index, starting at 1. This is necessary due to how `rstest` expands tests into modules with functions named `case_n`.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/developer_guide/testing.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\ntest --package nautilus-model --lib data::bar::tests::test_get_time_bar_start::case_1\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.analyzer module (reStructuredText)\nDESCRIPTION: This snippet imports the `analyzer` submodule and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.analyzer\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Enabling Standard-Precision Mode (64-bit) - Bash\nDESCRIPTION: This snippet demonstrates how to enable standard-precision mode (64-bit) for Nautilus Trader. It sets the `HIGH_PRECISION` environment variable to `false` and then executes the `make install-debug` command. This is the default precision mode if the `HIGH_PRECISION` variable is not explicitly set.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/getting_started/installation.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nexport HIGH_PRECISION=false\nmake install-debug\n```\n\n----------------------------------------\n\nTITLE: Documenting Position Events with automodule\nDESCRIPTION: This snippet uses the `automodule` directive with specific options to document the `nautilus_trader.model.events.position` module. It displays inheritance, inherited members, lists all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/events.md#_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.events.position\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Documenting Account Events with automodule\nDESCRIPTION: This snippet uses the `automodule` directive with specific options to document the `nautilus_trader.model.events.account` module. It displays inheritance, inherited members, lists all members, and orders them by source code order.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/model/events.md#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.model.events.account\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistic module (reStructuredText)\nDESCRIPTION: This snippet imports the `statistic` submodule and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistic\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Discovering Exchange Specific Instruments\nDESCRIPTION: This snippet shows how to discover exchange-specific instruments using an adapter's InstrumentProvider. It imports the BinanceSpotInstrumentProvider, initializes it, loads all instruments, and then finds a specific instrument by its ID.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/instruments.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nautilus_trader.adapters.binance.spot.providers import BinanceSpotInstrumentProvider\nfrom nautilus_trader.model import InstrumentId\n\nprovider = BinanceSpotInstrumentProvider(client=binance_http_client)\nawait self.provider.load_all_async()\n\nbtcusdt = InstrumentId.from_str(\"BTCUSDT.BINANCE\")\ninstrument = provider.find(btcusdt)\n```\n\n----------------------------------------\n\nTITLE: Importing nautilus_trader.analysis.statistics.winner_max module (reStructuredText)\nDESCRIPTION: This snippet imports the `winner_max` submodule within the statistics package and configures the documentation generator.  `show-inheritance`, `inherited-members`, `members`, and `member-order` control which members are shown and how they are ordered.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/api_reference/analysis.md#_snippet_19\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: nautilus_trader.analysis.statistics.winner_max\n   :show-inheritance:\n   :inherited-members:\n   :members:\n   :member-order: bysource\n```\n\n----------------------------------------\n\nTITLE: Initializing ParquetDataCatalog (Python)\nDESCRIPTION: This code shows how to initialize a `ParquetDataCatalog` from a given path. It creates a new instance of the catalog, assuming that pre-existing data might already be written to disk at the specified path. The `nautilus_trader` library is required.\nSOURCE: https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/concepts/data.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom nautilus_trader.persistence.catalog import ParquetDataCatalog\n\n\nCATALOG_PATH = Path.cwd() / \"catalog\"\n\n# Create a new catalog instance\ncatalog = ParquetDataCatalog(CATALOG_PATH)\n```"
  }
]