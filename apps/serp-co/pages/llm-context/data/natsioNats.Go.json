[
  {
    "owner": "nats-io",
    "repo": "nats.go",
    "content": "TITLE: Basic NATS Operations in Go\nDESCRIPTION: Demonstrates fundamental NATS operations including connecting, publishing, subscribing (async/sync/channel-based), requests/replies, and connection management.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/nats-io/nats.go\"\n\n// Connect to a server\nnc, _ := nats.Connect(nats.DefaultURL)\n\n// Simple Publisher\nnc.Publish(\"foo\", []byte(\"Hello World\"))\n\n// Simple Async Subscriber\nnc.Subscribe(\"foo\", func(m *nats.Msg) {\n    fmt.Printf(\"Received a message: %s\\n\", string(m.Data))\n})\n\n// Responding to a request message\nnc.Subscribe(\"request\", func(m *nats.Msg) {\n    m.Respond([]byte(\"answer is 42\"))\n})\n\n// Simple Sync Subscriber\nsub, err := nc.SubscribeSync(\"foo\")\nm, err := sub.NextMsg(timeout)\n\n// Channel Subscriber\nch := make(chan *nats.Msg, 64)\nsub, err := nc.ChanSubscribe(\"foo\", ch)\nmsg := <- ch\n\n// Unsubscribe\nsub.Unsubscribe()\n\n// Drain\nsub.Drain()\n\n// Requests\nmsg, err := nc.Request(\"help\", []byte(\"help me\"), 10*time.Millisecond)\n\n// Replies\nnc.Subscribe(\"help\", func(m *nats.Msg) {\n    nc.Publish(m.Reply, []byte(\"I can help!\"))\n})\n\n// Drain connection (Preferred for responders)\n// Close() not needed if this is called.\nnc.Drain()\n\n// Close connection\nnc.Close()\n```\n\n----------------------------------------\n\nTITLE: Basic JetStream Usage in Go\nDESCRIPTION: Demonstrates creating a stream, publishing messages, creating a consumer, and receiving messages using different methods including fetch, consume callback, and message iterator.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/nats-io/nats.go\"\n    \"github.com/nats-io/nats.go/jetstream\"\n)\n\nfunc main() {\n    // In the `jetstream` package, almost all API calls rely on `context.Context` for timeout/cancellation handling\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n    nc, _ := nats.Connect(nats.DefaultURL)\n\n    // Create a JetStream management interface\n    js, _ := jetstream.New(nc)\n\n    // Create a stream\n    s, _ := js.CreateStream(ctx, jetstream.StreamConfig{\n        Name:     \"ORDERS\",\n        Subjects: []string{\"ORDERS.*\"},\n    })\n\n    // Publish some messages\n    for i := 0; i < 100; i++ {\n        js.Publish(ctx, \"ORDERS.new\", []byte(\"hello message \"+strconv.Itoa(i)))\n        fmt.Printf(\"Published hello message %d\\n\", i)\n    }\n\n    // Create durable consumer\n    c, _ := s.CreateOrUpdateConsumer(ctx, jetstream.ConsumerConfig{\n        Durable:   \"CONS\",\n        AckPolicy: jetstream.AckExplicitPolicy,\n    })\n\n    // Get 10 messages from the consumer\n    messageCounter := 0\n    msgs, err := c.Fetch(10)\n    if err != nil {\n        // handle error\n    }\n\n    for msg := range msgs.Messages() {\n        msg.Ack()\n        fmt.Printf(\"Received a JetStream message via fetch: %s\\n\", string(msg.Data()))\n        messageCounter++\n    }\n\n    fmt.Printf(\"received %d messages\\n\", messageCounter)\n\n    if msgs.Error() != nil {\n        fmt.Println(\"Error during Fetch(): \", msgs.Error())\n    }\n\n    // Receive messages continuously in a callback\n    cons, _ := c.Consume(func(msg jetstream.Msg) {\n        msg.Ack()\n        fmt.Printf(\"Received a JetStream message via callback: %s\\n\", string(msg.Data()))\n        messageCounter++\n    })\n    defer cons.Stop()\n\n    // Iterate over messages continuously\n    it, _ := c.Messages()\n    for i := 0; i < 10; i++ {\n        msg, _ := it.Next()\n        msg.Ack()\n        fmt.Printf(\"Received a JetStream message via iterator: %s\\n\", string(msg.Data()))\n        messageCounter++\n    }\n    it.Stop()\n\n    // block until all 100 published messages have been processed\n    for messageCounter < 100 {\n        time.Sleep(10 * time.Millisecond)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Keys in a KV Bucket with JetStream in Go\nDESCRIPTION: Demonstrates how to list all keys in a JetStream KV bucket. This example creates a KeyValue bucket named 'profiles', adds three key-value pairs, and then uses ListKeys to retrieve and display all keys in the bucket.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_19\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nkv, _ := js.CreateKeyValue(ctx, jetstream.KeyValueConfig{Bucket: \"profiles\"})\n\nkv.Put(ctx, \"sue.color\", []byte(\"blue\"))\nkv.Put(ctx, \"sue.age\", []byte(\"43\"))\nkv.Put(ctx, \"bucket\", []byte(\"profiles\"))\n\nkeys, _ := kv.ListKeys(ctx)\n\n// Prints all 3 keys\nfor key := range keys.Keys() {\n    fmt.Println(key)\n}\n```\n\n----------------------------------------\n\nTITLE: JetStream Basic Usage in Go\nDESCRIPTION: Shows how to use JetStream, NATS' built-in persistence system, including connecting, creating contexts, and consuming messages.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// connect to nats server\nnc, _ := nats.Connect(nats.DefaultURL)\n\n// create jetstream context from nats connection\njs, _ := jetstream.New(nc)\n\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\n// get existing stream handle\nstream, _ := js.Stream(ctx, \"foo\")\n\n// retrieve consumer handle from a stream\ncons, _ := stream.Consumer(ctx, \"cons\")\n\n// consume messages from the consumer in callback\ncc, _ := cons.Consume(func(msg jetstream.Msg) {\n    fmt.Println(\"Received jetstream message: \", string(msg.Data()))\n    msg.Ack()\n})\ndefer cc.Stop()\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic NATS Microservice in Go\nDESCRIPTION: Demonstrates how to create a basic NATS microservice using the micro package, including connecting to NATS, defining a request handler, and configuring the service.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nnc, _ := nats.Connect(nats.DefaultURL)\n\n// request handler\nechoHandler := func(req micro.Request) {\n    req.Respond(req.Data())\n}\n\nsrv, err := micro.AddService(nc, micro.Config{\n    Name:        \"EchoService\",\n    Version:     \"1.0.0\",\n    // base handler\n    Endpoint: &micro.EndpointConfig{\n        Subject: \"svc.echo\",\n        Handler: micro.HandlerFunc(echoHandler),\n    },\n})\n```\n\n----------------------------------------\n\nTITLE: Basic CRUD Operations with JetStream KeyValue Store in Go\nDESCRIPTION: Demonstrates basic Create, Read, Update, and Delete operations with JetStream KeyValue bucket. Shows how to create a bucket, set and get values, update values with revision checks, and handle deletion of keys and buckets.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_17\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\n\n// Create a new bucket. Bucket name is required and has to be unique within a JetStream account.\nkv, _ := js.CreateKeyValue(ctx, jetstream.KeyValueConfig{Bucket: \"profiles\"})\n\n// Set a value for a given key\n// Put will either create or update a value for a given key\nkv.Put(ctx, \"sue.color\", []byte(\"blue\"))\n\n// Get an entry for a given key\n// Entry contains key/value, but also metadata (revision, timestamp, etc.)) \nentry, _ := kv.Get(ctx, \"sue.color\")\n\n// Prints `sue.color @ 1 -> \"blue\"`\nfmt.Printf(\"%s @ %d -> %q\\n\", entry.Key(), entry.Revision(), string(entry.Value()))\n\n// Update a value for a given key\n// Update will fail if the key does not exist or the revision has changed\nkv.Update(ctx, \"sue.color\", []byte(\"red\"), 1)\n\n// Create will fail if the key already exists\n_, err := kv.Create(ctx, \"sue.color\", []byte(\"purple\"))\nfmt.Println(err) // prints `nats: key exists`\n\n// Delete a value for a given key.\n// Delete is not destructive, it will add a delete marker for a given key\n// and all previous revisions will still be available\nkv.Delete(ctx, \"sue.color\")\n\n// getting a deleted key will return an error\n_, err = kv.Get(ctx, \"sue.color\")\nfmt.Println(err) // prints `nats: key not found`\n\n// A bucket can be deleted once it is no longer needed\njs.DeleteKeyValue(ctx, \"profiles\")\n```\n\n----------------------------------------\n\nTITLE: Listing JetStream Consumers and Consumer Names\nDESCRIPTION: This snippet shows how to list all consumers on a stream and how to list just consumer names. It demonstrates iterating through results and handling potential errors that might occur during the listing operation.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// list consumers\nconsumers := s.ListConsumers(ctx)\nfor cons := range consumers.Info() {\n    fmt.Println(cons.Name)\n}\nif consumers.Err() != nil {\n    fmt.Println(\"Unexpected error occurred\")\n}\n\n// list consumer names\nnames := s.ConsumerNames(ctx)\nfor name := range names.Name() {\n    fmt.Println(name)\n}\nif names.Err() != nil {\n    fmt.Println(\"Unexpected error occurred\")\n}\n```\n\n----------------------------------------\n\nTITLE: Basic JetStream Operations in Go\nDESCRIPTION: Demonstrates core JetStream functionality including connecting to NATS, publishing messages synchronously and asynchronously, and creating different types of consumers (async, sync durable, and pull consumers).\nSOURCE: https://github.com/nats-io/nats.go/blob/main/legacy_jetstream.md#2025-04-19_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/nats-io/nats.go\"\n\n// Connect to NATS\nnc, _ := nats.Connect(nats.DefaultURL)\n\n// Create JetStream Context\njs, _ := nc.JetStream(nats.PublishAsyncMaxPending(256))\n\n// Simple Stream Publisher\njs.Publish(\"ORDERS.scratch\", []byte(\"hello\"))\n\n// Simple Async Stream Publisher\nfor i := 0; i < 500; i++ {\n    js.PublishAsync(\"ORDERS.scratch\", []byte(\"hello\"))\n}\nselect {\ncase <-js.PublishAsyncComplete():\ncase <-time.After(5 * time.Second):\n    fmt.Println(\"Did not resolve in time\")\n}\n\n// Simple Async Ephemeral Consumer\njs.Subscribe(\"ORDERS.*\", func(m *nats.Msg) {\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(m.Data))\n})\n\n// Simple Sync Durable Consumer (optional SubOpts at the end)\nsub, err := js.SubscribeSync(\"ORDERS.*\", nats.Durable(\"MONITOR\"), nats.MaxDeliver(3))\nm, err := sub.NextMsg(timeout)\n\n// Simple Pull Consumer\nsub, err := js.PullSubscribe(\"ORDERS.*\", \"MONITOR\")\nmsgs, err := sub.Fetch(10)\n\n// Unsubscribe\nsub.Unsubscribe()\n\n// Drain\nsub.Drain()\n```\n\n----------------------------------------\n\nTITLE: Stream Management Operations in Go\nDESCRIPTION: Shows how to create, update, retrieve, and delete streams using the jetstream package. Also demonstrates listing streams and stream names.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_1\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\n\n// create a stream (this is an idempotent operation)\ns, _ := js.CreateStream(ctx, jetstream.StreamConfig{\n    Name:     \"ORDERS\",\n    Subjects: []string{\"ORDERS.*\"},\n})\n\n// update a stream\ns, _ = js.UpdateStream(ctx, jetstream.StreamConfig{\n    Name:        \"ORDERS\",\n    Subjects:    []string{\"ORDERS.*\"},\n    Description: \"updated stream\",\n})\n\n// get stream handle\ns, _ = js.Stream(ctx, \"ORDERS\")\n\n// delete a stream\njs.DeleteStream(ctx, \"ORDERS\")\n\n// list streams\nstreams := js.ListStreams(ctx)\nfor s := range streams.Info() {\n    fmt.Println(s.Config.Name)\n}\nif streams.Err() != nil {\n    fmt.Println(\"Unexpected error occurred\")\n}\n\n// list stream names\nnames := js.StreamNames(ctx)\nfor name := range names.Name() {\n    fmt.Println(name)\n}\nif names.Err() != nil {\n    fmt.Println(\"Unexpected error occurred\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing JetStream Consumers at JetStream Level\nDESCRIPTION: This snippet demonstrates how to create, update, fetch, and delete JetStream consumers at the JetStream interface level. It shows various operations like creating durable and ephemeral consumers, updating consumers, and deleting them.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_3\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\n\n// create a consumer (this is an idempotent operation)\n// an error will be returned if consumer already exists and has different configuration.\ncons, _ := js.CreateConsumer(ctx, \"ORDERS\", jetstream.ConsumerConfig{\n    Durable: \"foo\",\n    AckPolicy: jetstream.AckExplicitPolicy,\n})\n\n// create an ephemeral pull consumer by not providing `Durable`\nephemeral, _ := js.CreateConsumer(ctx, \"ORDERS\", jetstream.ConsumerConfig{\n    AckPolicy: jetstream.AckExplicitPolicy,\n})\n\n\n// consumer can also be created using CreateOrUpdateConsumer\n// this method will either create a consumer if it does not exist\n// or update existing consumer (if possible)\ncons2 := js.CreateOrUpdateConsumer(ctx, \"ORDERS\", jetstream.ConsumerConfig{\n    Name: \"bar\",\n})\n\n// consumers can be updated\n// an error will be returned if consumer with given name does not exist\n// or an illegal property is to be updated (e.g. AckPolicy)\nupdated, _ := js.UpdateConsumer(ctx, \"ORDERS\", jetstream.ConsumerConfig{\n    AckPolicy: jetstream.AckExplicitPolicy,\n    Description: \"updated consumer\"\n})\n\n// get consumer handle\ncons, _ = js.Consumer(ctx, \"ORDERS\", \"foo\")\n\n// delete a consumer\njs.DeleteConsumer(ctx, \"ORDERS\", \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Checking KV Bucket Status with JetStream in Go\nDESCRIPTION: Demonstrates how to check the status of a JetStream KV bucket. This includes retrieving the bucket name, the number of values stored, and the total size of all values in bytes.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_21\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nkv, _ := js.CreateKeyValue(ctx, jetstream.KeyValueConfig{Bucket: \"profiles\"})\n\nkv.Put(ctx, \"sue.color\", []byte(\"blue\"))\nkv.Put(ctx, \"sue.age\", []byte(\"43\"))\nkv.Put(ctx, \"bucket\", []byte(\"profiles\"))\n\nstatus, _ := kv.Status(ctx)\n\nfmt.Println(status.Bucket()) // prints `profiles`\nfmt.Println(status.Values()) // prints `3`\nfmt.Println(status.Bytes()) // prints the size of all values in bytes\n```\n\n----------------------------------------\n\nTITLE: NATS Wildcard Subscriptions in Go\nDESCRIPTION: Shows how to use wildcard subscriptions in NATS, including both partial wildcards (*) and full wildcards (>).\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// \"*\" matches any token, at any level of the subject.\nnc.Subscribe(\"foo.*.baz\", func(m *Msg) {\n    fmt.Printf(\"Msg received on [%s] : %s\\n\", m.Subject, string(m.Data));\n})\n\nnc.Subscribe(\"foo.bar.*\", func(m *Msg) {\n    fmt.Printf(\"Msg received on [%s] : %s\\n\", m.Subject, string(m.Data));\n})\n\n// \">\" matches any length of the tail of a subject, and can only be the last token\n// E.g. 'foo.>' will match 'foo.bar', 'foo.bar.baz', 'foo.foo.bar.bax.22'\nnc.Subscribe(\"foo.>\", func(m *Msg) {\n    fmt.Printf(\"Msg received on [%s] : %s\\n\", m.Subject, string(m.Data));\n})\n\n// Matches all of the above\nnc.Publish(\"foo.bar.baz\", []byte(\"Hello World\"))\n```\n\n----------------------------------------\n\nTITLE: NATS Queue Groups in Go\nDESCRIPTION: Demonstrates how to use queue groups for load balancing messages across multiple subscribers.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// All subscriptions with the same queue name will form a queue group.\n// Each message will be delivered to only one subscriber per queue group,\n// using queuing semantics. You can have as many queue groups as you wish.\n// Normal subscribers will continue to work as expected.\n\nnc.QueueSubscribe(\"foo\", \"job_workers\", func(_ *Msg) {\n  received += 1;\n})\n```\n\n----------------------------------------\n\nTITLE: Synchronous Publishing to JetStream in Go\nDESCRIPTION: Shows how to publish messages synchronously to a JetStream stream, with examples of both PublishMsg and Publish methods. The code demonstrates publishing a message and handling the acknowledgment response.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_14\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\n\n// Publish message on subject ORDERS.new\n// Given subject has to belong to a stream\nack, err := js.PublishMsg(ctx, &nats.Msg{\n    Data:    []byte(\"hello\"),\n    Subject: \"ORDERS.new\",\n})\nfmt.Printf(\"Published msg with sequence number %d on stream %q\", ack.Sequence, ack.Stream)\n\n// A helper method accepting subject and data as parameters\nack, err = js.Publish(ctx, \"ORDERS.new\", []byte(\"hello\"))\n```\n\n----------------------------------------\n\nTITLE: Fanout Request Pattern Implementation in NATS Microservice\nDESCRIPTION: Demonstrates how to send a request to multiple services and handle all the responses, useful for implementing fanout patterns.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nsub, _ := nc.SubscribeSync(\"rply\")\nnc.PublishRequest(\"svc.echo\", \"rply\", nil)\nfor start := time.Now(); time.Since(start) < 5*time.Second; {\n  msg, err := sub.NextMsg(1 * time.Second)\n  if err != nil {\n    break\n  }\n  fmt.Println(\"Received \", string(msg.Data))\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Publishing to JetStream in Go\nDESCRIPTION: Demonstrates how to publish messages asynchronously to a JetStream stream using PublishMsgAsync and PublishAsync methods. The code shows how to handle acknowledgments using the returned future object.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_16\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\n\n// publish message and do not wait for ack\nackF, err := js.PublishMsgAsync(ctx, &nats.Msg{\n    Data:    []byte(\"hello\"),\n    Subject: \"ORDERS.new\",\n})\n\n// block and wait for ack\nselect {\ncase ack := <-ackF.Ok():\n    fmt.Printf(\"Published msg with sequence number %d on stream %q\", ack.Sequence, ack.Stream)\ncase err := <-ackF.Err():\n    fmt.Println(err)\n}\n\n// similarly to synchronous publish, there is a helper method accepting subject and data\nackF, err = js.PublishAsync(\"ORDERS.new\", []byte(\"hello\"))\n```\n\n----------------------------------------\n\nTITLE: Continuous Message Consumption with Callbacks in NATS.go\nDESCRIPTION: This snippet shows how to continuously consume messages from a JetStream consumer using a callback function. It demonstrates how to set up a filtered consumer that receives messages only from a specific subject and how to properly clean up resources.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_10\n\nLANGUAGE: go\nCODE:\n```\ncons, _ := js.CreateOrUpdateConsumer(\"ORDERS\", jetstream.ConsumerConfig{\n    AckPolicy: jetstream.AckExplicitPolicy,\n    // receive messages from ORDERS.A subject only\n    FilterSubject: \"ORDERS.A\"\n}))\n\nconsContext, _ := c.Consume(func(msg jetstream.Msg) {\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(msg.Data()))\n})\ndefer consContext.Stop()\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Messages with JetStream Consumer in Go\nDESCRIPTION: Demonstrates how to iterate over incoming messages using the Messages() method on a JetStream consumer. This approach allows for continuous processing of messages from a stream with built-in acknowledgment.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_11\n\nLANGUAGE: go\nCODE:\n```\niter, _ := cons.Messages()\nfor {\n    msg, err := iter.Next()\n    // Next can return error, e.g. when iterator is closed or no heartbeats were received\n    if err != nil {\n        //handle error\n    }\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(msg.Data()))\n    msg.Ack()\n}\niter.Stop()\n```\n\n----------------------------------------\n\nTITLE: Updating Object Metadata in JetStream Object Store in Go\nDESCRIPTION: Shows how to update metadata of objects in a JetStream Object Store bucket. Demonstrates adding a description to an object and renaming an object by changing its name in the metadata.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_24\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nos, _ := js.CreateObjectStore(ctx, jetstream.ObjectStoreConfig{Bucket: \"configs\"})\n\nos.PutString(ctx, \"config\", \"data\")\n\n// update metadata of the object to e.g. add a description\nos.UpdateMeta(ctx, \"config\", jetstream.ObjectMeta{Name: \"config\", Description: \"this is a config\"})\n\n// object can be moved under a new name (unless it already exists)\nos.UpdateMeta(ctx, \"config\", jetstream.ObjectMeta{Name: \"config-1\", Description: \"updated config\"})\n```\n\n----------------------------------------\n\nTITLE: Basic CRUD Operations with JetStream Object Store in Go\nDESCRIPTION: Shows basic CRUD operations on a JetStream Object Store bucket. Demonstrates creating a bucket, putting objects using various methods (raw strings, bytes, and files), retrieving objects, and deleting both objects and buckets.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_22\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\n\n// Create a new bucket. Bucket name is required and has to be unique within a JetStream account.\nos, _ := js.CreateObjectStore(ctx, jetstream.ObjectStoreConfig{Bucket: \"configs\"})\n\nconfig1 := bytes.NewBufferString(\"first config\")\n// Put an object in a bucket. Put expects an object metadata and a reader\n// to read the object data from.\nos.Put(ctx, jetstream.ObjectMeta{Name: \"config-1\"}, config1)\n\n// Objects can also be created using various helper methods\n\n// 1. As raw strings\nos.PutString(ctx, \"config-2\", \"second config\")\n\n// 2. As raw bytes\nos.PutBytes(ctx, \"config-3\", []byte(\"third config\"))\n\n// 3. As a file\nos.PutFile(ctx, \"config-4.txt\")\n\n// Get an object\n// Get returns a reader and object info\n// Similar to Put, Get can also be used with helper methods\n// to retrieve object data as a string, bytes or to save it to a file\nobject, _ := os.Get(ctx, \"config-1\")\ndata, _ := io.ReadAll(object)\ninfo, _ := object.Info()\n\n// Prints `configs.config-1 -> \"first config\"`\nfmt.Printf(\"%s.%s -> %q\\n\", info.Bucket, info.Name, string(data))\n\n// Delete an object.\n// Delete will remove object data from stream, but object metadata will be kept\n// with a delete marker.\nos.Delete(ctx, \"config-1\")\n\n// getting a deleted object will return an error\n_, err := os.Get(ctx, \"config-1\")\nfmt.Println(err) // prints `nats: object not found`\n\n// A bucket can be deleted once it is no longer needed\njs.DeleteObjectStore(ctx, \"configs\")\n```\n\n----------------------------------------\n\nTITLE: Watching for Changes in JetStream KeyValue Store\nDESCRIPTION: Demonstrates how to watch for changes on keys in a JetStream KeyValue bucket. The watcher pattern allows for receiving notifications when keys are created, updated, or deleted, with options for controlling the behavior of the watcher.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_18\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nkv, _ := js.CreateKeyValue(ctx, jetstream.KeyValueConfig{Bucket: \"profiles\"})\n\nkv.Put(ctx, \"sue.color\", []byte(\"blue\"))\n\n// A watcher can be created to watch for changes on a given key or the whole bucket\n// By default, watcher will return most recent values for all matching keys.\n// Watcher can be configured to only return updates by using jetstream.UpdatesOnly() option.\nwatcher, _ := kv.Watch(ctx, \"sue.*\")\ndefer watcher.Stop()\n\nkv.Put(ctx, \"sue.age\", []byte(\"43\"))\nkv.Put(ctx, \"sue.color\", []byte(\"red\"))\n\n// First, the watcher sends most recent values for all matching keys.\n// In this case, it will send a single entry for `sue.color`.\nentry := <-watcher.Updates()\n// Prints `sue.color @ 1 -> \"blue\"`\nfmt.Printf(\"%s @ %d -> %q\\n\", entry.Key(), entry.Revision(), string(entry.Value()))\n\n// After all current values have been sent, watcher will send nil on the channel.\nentry = <-watcher.Updates()\nif entry != nil {\n    fmt.Println(\"Unexpected entry received\")\n}\n\n// After that, watcher will send updates when changes occur\n// In this case, it will send an entry for `sue.color` and `sue.age`.\n\nentry = <-watcher.Updates()\n// Prints `sue.age @ 2 -> \"43\"`\nfmt.Printf(\"%s @ %d -> %q\\n\", entry.Key(), entry.Revision(), string(entry.Value()))\n\nentry = <-watcher.Updates()\n// Prints `sue.color @ 3 -> \"red\"`\nfmt.Printf(\"%s @ %d -> %q\\n\", entry.Key(), entry.Revision(), string(entry.Value()))\n```\n\n----------------------------------------\n\nTITLE: Connecting to NATS Cluster with Various Options in Go\nDESCRIPTION: Demonstrates different ways to connect to a NATS cluster, including setting reconnect options, custom handlers, and authentication methods. It shows how to configure connection parameters and handle events like disconnects and reconnects.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nvar servers = \"nats://localhost:1222, nats://localhost:1223, nats://localhost:1224\"\n\nnc, err := nats.Connect(servers)\n\n// Optionally set ReconnectWait and MaxReconnect attempts.\n// This example means 10 seconds total per backend.\nnc, err = nats.Connect(servers, nats.MaxReconnects(5), nats.ReconnectWait(2 * time.Second))\n\n// You can also add some jitter for the reconnection.\n// This call will add up to 500 milliseconds for non TLS connections and 2 seconds for TLS connections.\n// If not specified, the library defaults to 100 milliseconds and 1 second, respectively.\nnc, err = nats.Connect(servers, nats.ReconnectJitter(500*time.Millisecond, 2*time.Second))\n\n// You can also specify a custom reconnect delay handler. If set, the library will invoke it when it has tried\n// all URLs in its list. The value returned will be used as the total sleep time, so add your own jitter.\n// The library will pass the number of times it went through the whole list.\nnc, err = nats.Connect(servers, nats.CustomReconnectDelay(func(attempts int) time.Duration {\n    return someBackoffFunction(attempts)\n}))\n\n// Optionally disable randomization of the server pool\nnc, err = nats.Connect(servers, nats.DontRandomize())\n\n// Setup callbacks to be notified on disconnects, reconnects and connection closed.\nnc, err = nats.Connect(servers,\n\tnats.DisconnectErrHandler(func(nc *nats.Conn, err error) {\n\t\tfmt.Printf(\"Got disconnected! Reason: %q\\n\", err)\n\t}),\n\tnats.ReconnectHandler(func(nc *nats.Conn) {\n\t\tfmt.Printf(\"Got reconnected to %v!\\n\", nc.ConnectedUrl())\n\t}),\n\tnats.ClosedHandler(func(nc *nats.Conn) {\n\t\tfmt.Printf(\"Connection closed. Reason: %q\\n\", nc.LastError())\n\t})\n)\n\n// When connecting to a mesh of servers with auto-discovery capabilities,\n// you may need to provide a username/password or token in order to connect\n// to any server in that mesh when authentication is required.\n// Instead of providing the credentials in the initial URL, you will use\n// new option setters:\nnc, err = nats.Connect(\"nats://localhost:4222\", nats.UserInfo(\"foo\", \"bar\"))\n\n// For token based authentication:\nnc, err = nats.Connect(\"nats://localhost:4222\", nats.Token(\"S3cretT0ken\"))\n\n// You can even pass the two at the same time in case one of the server\n// in the mesh requires token instead of user name and password.\nnc, err = nats.Connect(\"nats://localhost:4222\",\n    nats.UserInfo(\"foo\", \"bar\"),\n    nats.Token(\"S3cretT0ken\"))\n\n// Note that if credentials are specified in the initial URLs, they take\n// precedence on the credentials specified through the options.\n// For instance, in the connect call below, the client library will use\n// the user \"my\" and password \"pwd\" to connect to localhost:4222, however,\n// it will use username \"foo\" and password \"bar\" when (re)connecting to\n// a different server URL that it got as part of the auto-discovery.\nnc, err = nats.Connect(\"nats://my:pwd@localhost:4222\", nats.UserInfo(\"foo\", \"bar\"))\n```\n\n----------------------------------------\n\nTITLE: Retrieving NATS Microservice Information\nDESCRIPTION: Shows how to retrieve detailed configuration information about a specific service instance using the INFO endpoint.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nnats req '$SRV.INFO.EchoService.x3Yuiq7g7MoxhXdxk7i4K7' '' | jq\n\n13:04:19 Sending request on \"$SRV.INFO.EchoService.x3Yuiq7g7MoxhXdxk7i4K7\"\n13:04:19 Received with rtt 318.875µs\n{\n  \"name\": \"EchoService\",\n  \"id\": \"x3Yuiq7g7MoxhXdxk7i4K7\",\n  \"version\": \"1.0.0\",\n  \"metadata\": {},\n  \"type\": \"io.nats.micro.v1.info_response\",\n  \"description\": \"\",\n  \"endpoints\": [\n    {\n      \"name\": \"default\",\n      \"subject\": \"svc.echo\",\n      \"queue_group\": \"q\",\n      \"metadata\": null\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: NATS Authentication with Nkeys and Credentials\nDESCRIPTION: Examples of different authentication methods including user credentials, JWT, and Nkeys with various implementation approaches.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nnc, err := nats.Connect(url, nats.UserCredentials(\"user.creds\"))\n\nnc, err := nats.Connect(url, nats.UserCredentials(\"user.jwt\", \"user.nk\"))\n\nnc, err := nats.Connect(url, nats.UserJWT(jwtCB, sigCB))\n\nopt, err := nats.NkeyOptionFromSeed(\"seed.txt\")\nnc, err := nats.Connect(serverUrl, opt)\n\n// Direct\nnc, err := nats.Connect(serverUrl, nats.Nkey(pubNkey, sigCB))\n```\n\n----------------------------------------\n\nTITLE: NATS TLS Configuration in Go\nDESCRIPTION: Demonstrates various TLS configuration options including self-signed certificates, client certificates, and custom TLS configuration.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// tls as a scheme will enable secure connections by default. This will also verify the server name.\nnc, err := nats.Connect(\"tls://nats.demo.io:4443\")\n\n// If you are using a self-signed certificate, you need to have a tls.Config with RootCAs setup.\n// We provide a helper method to make this case easier.\nnc, err = nats.Connect(\"tls://localhost:4443\", nats.RootCAs(\"./configs/certs/ca.pem\"))\n\n// If the server requires client certificate, there is an helper function for that too:\ncert := nats.ClientCert(\"./configs/certs/client-cert.pem\", \"./configs/certs/client-key.pem\")\nnc, err = nats.Connect(\"tls://localhost:4443\", cert)\n\n// You can also supply a complete tls.Config\n\ncertFile := \"./configs/certs/client-cert.pem\"\nkeyFile := \"./configs/certs/client-key.pem\"\ncert, err := tls.LoadX509KeyPair(certFile, keyFile)\nif err != nil {\n    t.Fatalf(\"error parsing X509 certificate/key pair: %v\", err)\n}\n\nconfig := &tls.Config{\n    ServerName: \topts.Host,\n    Certificates: \t[]tls.Certificate{cert},\n    RootCAs:    \tpool,\n    MinVersion: \ttls.VersionTLS12,\n}\n\nnc, err = nats.Connect(\"nats://localhost:4443\", nats.Secure(config))\nif err != nil {\n\tt.Fatalf(\"Got an error on Connect with Secure Options: %+v\\n\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Context with NATS in Go 1.7+\nDESCRIPTION: Demonstrates how to use context support in NATS.go for Go 1.7 and above. It shows examples of using context for timeouts in requests and synchronous subscribers.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nnc, err := nats.Connect(nats.DefaultURL)\n\n// Request with context\nmsg, err := nc.RequestWithContext(ctx, \"foo\", []byte(\"bar\"))\n\n// Synchronous subscriber with context\nsub, err := nc.SubscribeSync(\"foo\")\nmsg, err := sub.NextMsgWithContext(ctx)\n```\n\n----------------------------------------\n\nTITLE: Stream-Specific Operations in Go\nDESCRIPTION: Demonstrates stream-specific operations such as purging messages, retrieving messages by sequence number or subject, and getting stream information.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// remove all messages from a stream\n_ = s.Purge(ctx)\n\n// remove all messages from a stream that are stored on a specific subject\n_ = s.Purge(ctx, jetstream.WithPurgeSubject(\"ORDERS.new\"))\n\n// remove all messages up to specified sequence number\n_ = s.Purge(ctx, jetstream.WithPurgeSequence(100))\n\n// remove messages, but keep 10 newest\n_ = s.Purge(ctx, jetstream.WithPurgeKeep(10))\n\n// get message from stream with sequence number == 100\nmsg, _ := s.GetMsg(ctx, 100)\n\n// get last message from \"ORDERS.new\" subject\nmsg, _ = s.GetLastMsgForSubject(ctx, \"ORDERS.new\")\n\n// delete a message with sequence number == 100\n_ = s.DeleteMsg(ctx, 100)\n\n// Fetches latest stream info from server\ninfo, _ := s.Info(ctx)\nfmt.Println(info.Config.Name)\n\n// Returns the most recently fetched StreamInfo, without making an API call to the server\ncachedInfo := s.CachedInfo()\nfmt.Println(cachedInfo.Config.Name)\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing JetStream Consumers at Stream Level\nDESCRIPTION: This snippet shows how to create, fetch, and delete JetStream consumers at the Stream interface level. It demonstrates getting a stream handle and then performing consumer operations through that handle.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// Create a JetStream management interface\njs, _ := jetstream.New(nc)\n\n// get stream handle\nstream, _ := js.Stream(ctx, \"ORDERS\")\n\n// create consumer\ncons, _ := stream.CreateConsumer(ctx, jetstream.ConsumerConfig{\n    Durable:   \"foo\",\n    AckPolicy: jetstream.AckExplicitPolicy,\n})\n\n// get consumer handle\ncons, _ = stream.Consumer(ctx, \"ORDERS\", \"foo\")\n\n// delete a consumer\nstream.DeleteConsumer(ctx, \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Consumer Information in NATS.go\nDESCRIPTION: This snippet demonstrates how to fetch consumer information, both by making a server request and by accessing cached information. It shows how to access the ConsumerInfo object to view configuration details.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// Fetches latest consumer info from server\ninfo, _ := cons.Info(ctx)\nfmt.Println(info.Config.Durable)\n\n// Returns the most recently fetched ConsumerInfo, without making an API call to the server\ncachedInfo := cons.CachedInfo()\nfmt.Println(cachedInfo.Config.Durable)\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered Consumers in NATS.go\nDESCRIPTION: This snippet demonstrates how to create an ordered consumer, which processes messages in the exact order they were stored in the stream. Ordered consumers provide consistent message ordering and resilience to consumer deletion.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_7\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\n\n// create a consumer (this is an idempotent operation)\ncons, _ := js.OrderedConsumer(ctx, \"ORDERS\", jetstream.OrderedConsumerConfig{\n    // Filter results from \"ORDERS\" stream by specific subject\n    FilterSubjects: []string{\"ORDERS.A\"},\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Messages with Batch Size Limit from JetStream\nDESCRIPTION: This snippet shows how to fetch a defined number of messages or bytes from a JetStream consumer. It demonstrates both Fetch and FetchBytes methods, which allow retrieving messages with a configurable timeout and handling any errors that might occur.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// receive up to 10 messages from the stream\nmsgs, err := c.Fetch(10)\nif err != nil {\n    // handle error\n}\n\nfor msg := range msgs.Messages() {\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(msg.Data()))\n}\n\nif msgs.Error() != nil {\n    // handle error\n}\n\n// receive up to 1024 B of data\nmsgs, err := c.FetchBytes(1024)\nif err != nil {\n// handle error\n}\n\nfor msg := range msgs.Messages() {\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(msg.Data()))\n}\n\nif msgs.Error() != nil {\n    // handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Messages without Waiting from JetStream\nDESCRIPTION: This snippet demonstrates how to fetch messages from a JetStream consumer without waiting for new messages if the entire batch is not available. It shows how to use FetchNoWait to retrieve only messages that are immediately available.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// FetchNoWait will not wait for new messages if the whole batch is not available at the time of sending request.\nmsgs, err := c.FetchNoWait(10)\nif err != nil {\n// handle error\n}\n\nfor msg := range msgs.Messages() {\n    fmt.Printf(\"Received a JetStream message: %s\\n\", string(msg.Data()))\n}\n\nif msgs.Error() != nil {\n    // handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Buffer Size in JetStream Consumer\nDESCRIPTION: Shows how to configure a JetStream consumer to limit the number of messages or bytes stored in memory. This allows for better memory management when consuming large volumes of messages.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// a maximum of 10 messages or 1024 bytes will be stored in memory (whichever is encountered first)\niter, _ := cons.Messages(jetstream.PullMaxMessages(10), jetstream.PullMaxBytes(1024))\n```\n\n----------------------------------------\n\nTITLE: Implementing a Work Queue with JetStream in Go\nDESCRIPTION: Demonstrates how to implement a work queue pattern using JetStream's Messages() method to fetch messages one by one, with controlled concurrency through a semaphore to limit the number of concurrent workers.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n// PullMaxMessages determines how many messages will be sent to the client in a single pull request\niter, _ := cons.Messages(jetstream.PullMaxMessages(1))\nnumWorkers := 5\nsem := make(chan struct{}, numWorkers)\nfor {\n    sem <- struct{}{}\n    go func() {\n        defer func() {\n            <-sem\n        }()\n        msg, err := iter.Next()\n        if err != nil {\n            // handle err\n        }\n        fmt.Printf(\"Processing msg: %s\\n\", string(msg.Data()))\n        doWork()\n        msg.Ack()\n    }()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Headers in JetStream Publish Operations\nDESCRIPTION: Demonstrates different ways to set headers when publishing messages to JetStream. Headers can be set directly on the nats.Msg object or using option functions in both Publish and PublishMsg methods.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_15\n\nLANGUAGE: go\nCODE:\n```\n// All 3 implementations are work identically \nack, err := js.PublishMsg(ctx, &nats.Msg{\n    Data:    []byte(\"hello\"),\n    Subject: \"ORDERS.new\",\n    Header: nats.Header{\n        \"Nats-Msg-Id\": []string{\"id\"},\n    },\n})\n\nack, err = js.PublishMsg(ctx, &nats.Msg{\n    Data:    []byte(\"hello\"),\n    Subject: \"ORDERS.new\",\n}, jetstream.WithMsgID(\"id\"))\n\nack, err = js.Publish(ctx, \"ORDERS.new\", []byte(\"hello\"), jetstream.WithMsgID(\"id\"))\n```\n\n----------------------------------------\n\nTITLE: Importing NATS Micro Package in Go\nDESCRIPTION: Shows how to import the NATS micro package in a Go application.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/nats-io/nats.go/micro\"\n```\n\n----------------------------------------\n\nTITLE: Purging Keys from a KV Bucket with JetStream in Go\nDESCRIPTION: Shows how to purge keys from a JetStream KV bucket using Purge and PurgeDeletes operations. Purge removes all keys but keeps the latest revision with a delete marker, while PurgeDeletes removes all keys with a delete marker.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_20\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nkv, _ := js.CreateKeyValue(ctx, jetstream.KeyValueConfig{Bucket: \"profiles\"})\n\nkv.Put(ctx, \"sue.color\", []byte(\"blue\"))\nkv.Put(ctx, \"sue.age\", []byte(\"43\"))\nkv.Put(ctx, \"bucket\", []byte(\"profiles\"))\n\n// Purge will remove all keys from a bucket.\n// The latest revision of each key will be kept\n// with a delete marker, all previous revisions will be removed\n// permanently.\nkv.Purge(ctx)\n\n// PurgeDeletes will remove all keys from a bucket\n// with a delete marker.\nkv.PurgeDeletes(ctx)\n```\n\n----------------------------------------\n\nTITLE: Watching for Changes in JetStream Object Store in Go\nDESCRIPTION: Demonstrates how to watch for changes on objects in a JetStream Object Store bucket. Shows how to set up a watcher that initially returns all objects and then sends updates when changes occur. Includes examples of different watcher configuration options.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_23\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nos, _ := js.CreateObjectStore(ctx, jetstream.ObjectStoreConfig{Bucket: \"configs\"})\n\nos.PutString(ctx, \"config-1\", \"first config\")\n\n// By default, watcher will return most recent values for all objects in a bucket.\n// Watcher can be configured to only return updates by using jetstream.UpdatesOnly() option.\nwatcher, _ := os.Watch(ctx)\ndefer watcher.Stop()\n\n// create a second object\nos.PutString(ctx, \"config-2\", \"second config\")\n\n// update metadata of the first object\nos.UpdateMeta(ctx, \"config-1\", jetstream.ObjectMeta{Name: \"config-1\", Description: \"updated config\"})\n\n// First, the watcher sends most recent values for all matching objects.\n// In this case, it will send a single entry for `config-1`.\nobject := <-watcher.Updates()\n// Prints `configs.config-1 -> \"\"`\nfmt.Printf(\"%s.%s -> %q\\n\", object.Bucket, object.Name, object.Description)\n\n// After all current values have been sent, watcher will send nil on the channel.\nobject = <-watcher.Updates()\nif object != nil {\n    fmt.Println(\"Unexpected object received\")\n}\n\n// After that, watcher will send updates when changes occur\n// In this case, it will send an entry for `config-2` and `config-1`.\nobject = <-watcher.Updates()\n// Prints `configs.config-2 -> \"\"`\nfmt.Printf(\"%s.%s -> %q\\n\", object.Bucket, object.Name, object.Description)\n\nobject = <-watcher.Updates()\n// Prints `configs.config-1 -> \"updated config\"`\nfmt.Printf(\"%s.%s -> %q\\n\", object.Bucket, object.Name, object.Description)\n```\n\n----------------------------------------\n\nTITLE: Listing Objects in JetStream Object Store in Go\nDESCRIPTION: Demonstrates how to list all objects in a JetStream Object Store bucket. This example creates a bucket, adds three objects, and then uses the List method to retrieve and display information about all objects in the bucket.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_25\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nos, _ := js.CreateObjectStore(ctx, jetstream.ObjectStoreConfig{Bucket: \"configs\"})\n\nos.PutString(ctx, \"config-1\", \"cfg1\")\nos.PutString(ctx, \"config-2\", \"cfg1\")\nos.PutString(ctx, \"config-3\", \"cfg1\")\n\n// List will return information about all objects in a bucket\nobjects, _ := os.List(ctx)\n\n// Prints all 3 objects\nfor _, object := range objects {\n    fmt.Println(object.Name)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Object Store Status in JetStream in Go\nDESCRIPTION: Shows how to check the status of a JetStream Object Store bucket. This includes retrieving the bucket name and the total size of the bucket in bytes.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#2025-04-19_snippet_26\n\nLANGUAGE: go\nCODE:\n```\njs, _ := jetstream.New(nc)\nctx := context.Background()\nos, _ := js.CreateObjectStore(ctx, jetstream.ObjectStoreConfig{Bucket: \"configs\"})\n\nos.PutString(ctx, \"config-1\", \"cfg1\")\nos.PutString(ctx, \"config-2\", \"cfg1\")\nos.PutString(ctx, \"config-3\", \"cfg1\")\n\nstatus, _ := os.Status(ctx)\n\nfmt.Println(status.Bucket()) // prints `configs`\nfmt.Println(status.Size()) // prints the size of the bucket in bytes\n```\n\n----------------------------------------\n\nTITLE: Sending NATS Request to Microservice\nDESCRIPTION: Shows how to use the NATS CLI to send a request to the echo microservice and the expected response.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnats req svc.echo \"hello!\"\n```\n\n----------------------------------------\n\nTITLE: NATS Microservice Response Example\nDESCRIPTION: Shows the expected output when sending a request to a NATS microservice, including request timing information.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n17:37:32 Sending request on \"svc.echo\"\n17:37:32 Received with rtt 365.875µs\nhello!\n```\n\n----------------------------------------\n\nTITLE: Adding Endpoints to NATS Microservice\nDESCRIPTION: Demonstrates how to add additional endpoints to an existing NATS microservice after it has been created.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nsrv, _ := micro.AddService(nc, config)\n\n// endpoint will be registered under \"svc.add\" subject\nerr = srv.AddEndpoint(\"svc.add\", micro.HandlerFunc(add))\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Endpoint Subjects in NATS Microservice\nDESCRIPTION: Shows how to create an endpoint with a name that differs from its subject by using the WithEndpointSubject option.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// endpoint will be registered under \"svc.add\" subject\nerr = srv.AddEndpoint(\"Adder\", micro.HandlerFunc(echoHandler), micro.WithEndpointSubject(\"svc.add\"))\n```\n\n----------------------------------------\n\nTITLE: Creating Endpoint Groups in NATS Microservice\nDESCRIPTION: Demonstrates how to organize endpoints into groups with a common subject prefix, making it easier to manage related endpoints.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nsrv, _ := micro.AddService(nc, config)\n\nnumbersGroup := srv.AddGroup(\"numbers\")\n\n// endpoint will be registered under \"numbers.add\" subject\n_ = numbersGroup.AddEndpoint(\"add\", micro.HandlerFunc(addHandler))\n// endpoint will be registered under \"numbers.multiply\" subject\n_ = numbersGroup.AddEndpoint(\"multiply\", micro.HandlerFunc(multiplyHandler))\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Services with Custom Queue Groups\nDESCRIPTION: Shows how to create multiple service instances with different queue groups to implement patterns like fanout or hedged requests.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfor i := 0; i < 5; i++ {\n  srv, _ := micro.AddService(nc, micro.Config{\n    Name:        \"EchoService\",\n    Version:     \"1.0.0\",\n    QueueGroup:  fmt.Sprintf(\"q-%d\", i),\n    // base handler\n    Endpoint: &micro.EndpointConfig{\n        Subject: \"svc.echo\",\n        Handler: micro.HandlerFunc(echoHandler),\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Queue Groups at Multiple Levels\nDESCRIPTION: Shows how to customize queue groups at the service, group, and endpoint levels, demonstrating the inheritance pattern.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n  srv, _ := micro.AddService(nc, micro.Config{\n    Name:        \"EchoService\",\n    Version:     \"1.0.0\",\n    QueueGroup:  \"q1\",\n  })\n\n  g := srv.AddGroup(\"g\", micro.WithGroupQueueGroup(\"q2\"))\n\n  // will be registered with queue group 'q2' from parent group\n  g.AddEndpoint(\"bar\", micro.HandlerFunc(func(r micro.Request) {}))\n\n  // will be registered with queue group 'q3'\n  g.AddEndpoint(\"bar\", micro.HandlerFunc(func(r micro.Request) {}), micro.WithEndpointQueueGroup(\"q3\"))\n```\n\n----------------------------------------\n\nTITLE: Disabling Queue Groups in NATS Microservices\nDESCRIPTION: Demonstrates how to disable queue groups at different levels (service, group, endpoint) to use standard NATS subscriptions instead.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n  // disable queue group for the service\n  srv, _ := micro.AddService(nc, micro.Config{\n    Name:              \"EchoService\",\n    Version:           \"1.0.0\",\n    QueueGroupDisabled: true,\n  })\n\n  // create a group with queue group disabled\n  srv.AddGroup(\"g\", micro.WithEndpointQueueGroupDisabled())\n\n  // create an endpoint with queue group disabled\n  srv.AddEndpoint(\"bar\", micro.HandlerFunc(func(r micro.Request) {}), micro.WithEndpointQueueGroupDisabled())\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Service Instances for Testing\nDESCRIPTION: Shows how to create multiple instances of the same microservice for testing discovery and monitoring features.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nnc, _ := nats.Connect(\"nats://localhost:4222\")\nechoHandler := func(req micro.Request) {\n    req.Respond(req.Data())\n}\n\nconfig := micro.Config{\n    Name:    \"EchoService\",\n    Version: \"1.0.0\",\n    Endpoint: &micro.EndpointConfig{\n        Subject: \"svc.echo\",\n        Handler: micro.HandlerFunc(echoHandler),\n    },\n}\nfor i := 0; i < 3; i++ {\n    srv, err := micro.AddService(nc, config)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer srv.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Discovering NATS Microservice IDs\nDESCRIPTION: Shows how to use the built-in discovery feature to find all instances of a service by querying the PING endpoint.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nnats req '$SRV.PING.EchoService' '' --replies=3\n\n13:03:04 Sending request on \"$SRV.PING.EchoService\"\n13:03:04 Received with rtt 1.302208ms\n{\"name\":\"EchoService\",\"id\":\"x3Yuiq7g7MoxhXdxk7i4K7\",\"version\":\"1.0.0\",\"metadata\":{},\"type\":\"io.nats.micro.v1.ping_response\"}\n\n13:03:04 Received with rtt 1.317ms\n{\"name\":\"EchoService\",\"id\":\"x3Yuiq7g7MoxhXdxk7i4Kt\",\"version\":\"1.0.0\",\"metadata\":{},\"type\":\"io.nats.micro.v1.ping_response\"}\n\n13:03:04 Received with rtt 1.320291ms\n{\"name\":\"EchoService\",\"id\":\"x3Yuiq7g7MoxhXdxk7i4Lf\",\"version\":\"1.0.0\",\"metadata\":{},\"type\":\"io.nats.micro.v1.ping_response\"}\n```\n\n----------------------------------------\n\nTITLE: Retrieving NATS Microservice Statistics\nDESCRIPTION: Shows how to get runtime statistics for a specific service instance using the STATS endpoint, including request counts and processing times.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/micro/README.md#2025-04-19_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nnats req '$SRV.STATS.EchoService.x3Yuiq7g7MoxhXdxk7i4K7' '' | jq\n\n13:04:46 Sending request on \"$SRV.STATS.EchoService.x3Yuiq7g7MoxhXdxk7i4K7\"\n13:04:46 Received with rtt 678.25µs\n{\n  \"name\": \"EchoService\",\n  \"id\": \"x3Yuiq7g7MoxhXdxk7i4K7\",\n  \"version\": \"1.0.0\",\n  \"metadata\": {},\n  \"type\": \"io.nats.micro.v1.stats_response\",\n  \"started\": \"2024-09-24T11:02:55.564771Z\",\n  \"endpoints\": [\n    {\n      \"name\": \"default\",\n      \"subject\": \"svc.echo\",\n      \"queue_group\": \"q\",\n      \"num_requests\": 0,\n      \"num_errors\": 0,\n      \"last_error\": \"\",\n      \"processing_time\": 0,\n      \"average_processing_time\": 0\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NATS Go Client\nDESCRIPTION: Commands to install the NATS Go client library and server using go get. Shows how to get the latest version or a specific version.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# To get the latest released Go client:\ngo get github.com/nats-io/nats.go@latest\n\n# To get a specific version:\ngo get github.com/nats-io/nats.go@v1.41.2\n\n# Note that the latest major version for NATS Server is v2:\ngo get github.com/nats-io/nats-server/v2@latest\n```\n\n----------------------------------------\n\nTITLE: Advanced NATS Usage in Go\nDESCRIPTION: Shows advanced NATS features including connection retry handling, message flushing, auto-unsubscribe, and multiple connections.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/README.md#2025-04-19_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Normally, the library will return an error when trying to connect and\n// there is no server running. The RetryOnFailedConnect option will set\n// the connection in reconnecting state if it failed to connect right away.\nnc, err := nats.Connect(nats.DefaultURL,\n    nats.RetryOnFailedConnect(true),\n    nats.MaxReconnects(10),\n    nats.ReconnectWait(time.Second),\n    nats.ReconnectHandler(func(_ *nats.Conn) {\n        // Note that this will be invoked for the first asynchronous connect.\n    }))\nif err != nil {\n    // Should not return an error even if it can't connect, but you still\n    // need to check in case there are some configuration errors.\n}\n\n// Flush connection to server, returns when all messages have been processed.\nnc.Flush()\nfmt.Println(\"All clear!\")\n\n// FlushTimeout specifies a timeout value as well.\nerr := nc.FlushTimeout(1*time.Second)\nif err != nil {\n    fmt.Println(\"All clear!\")\n} else {\n    fmt.Println(\"Flushed timed out!\")\n}\n\n// Auto-unsubscribe after MAX_WANTED messages received\nconst MAX_WANTED = 10\nsub, err := nc.Subscribe(\"foo\")\nsub.AutoUnsubscribe(MAX_WANTED)\n\n// Multiple connections\nnc1 := nats.Connect(\"nats://host1:4222\")\nnc2 := nats.Connect(\"nats://host2:4222\")\n\nnc1.Subscribe(\"foo\", func(m *Msg) {\n    fmt.Printf(\"Received a message: %s\\n\", string(m.Data))\n})\n\nnc2.Publish(\"foo\", []byte(\"Hello World!\"));\n```\n\n----------------------------------------\n\nTITLE: JetStream Stream and Consumer Management in Go\nDESCRIPTION: Shows how to perform administrative tasks with JetStream including creating and updating streams, managing consumers, and cleanup operations.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/legacy_jetstream.md#2025-04-19_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/nats-io/nats.go\"\n\n// Connect to NATS\nnc, _ := nats.Connect(nats.DefaultURL)\n\n// Create JetStream Context\njs, _ := nc.JetStream()\n\n// Create a Stream\njs.AddStream(&nats.StreamConfig{\n    Name:     \"ORDERS\",\n    Subjects: []string{\"ORDERS.*\"},\n})\n\n// Update a Stream\njs.UpdateStream(&nats.StreamConfig{\n    Name:     \"ORDERS\",\n    MaxBytes: 8,\n})\n\n// Create a Consumer\njs.AddConsumer(\"ORDERS\", &nats.ConsumerConfig{\n    Durable: \"MONITOR\",\n})\n\n// Delete Consumer\njs.DeleteConsumer(\"ORDERS\", \"MONITOR\")\n\n// Delete Stream\njs.DeleteStream(\"ORDERS\")\n```\n\n----------------------------------------\n\nTITLE: Updating Testing Dependencies for nats-io/nats.go\nDESCRIPTION: This command updates the testing dependencies using go_test.mod file to avoid changing the main go.mod in a PR.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/CONTRIBUTING.md#2025-04-19_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo mod tidy -modfile=go_test.mod\n```\n\n----------------------------------------\n\nTITLE: Running Tests for nats-io/nats.go\nDESCRIPTION: This command runs the tests using the go_test.mod file for managing testing dependencies.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/CONTRIBUTING.md#2025-04-19_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo test ./... -modfile=go_test.mod\n```\n\n----------------------------------------\n\nTITLE: Displaying External Dependencies Table in Markdown\nDESCRIPTION: This code snippet presents a markdown table listing the external dependencies of the NATS.go project. It includes the dependency names and their corresponding license types.\nSOURCE: https://github.com/nats-io/nats.go/blob/main/dependencies.md#2025-04-19_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n| Dependency                        | License      |\n|-----------------------------------|--------------|\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| Go                                | BSD 3-Clause |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| github.com/golang/protobuf/proto  | BSD-3-Clause |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| github.com/klauspost/compress     | BSD-3-Clause |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| github.com/nats-io/nats-server/v2 | Apache-2.0   |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| github.com/nats-io/nkeys          | Apache-2.0   |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| github.com/nats-io/nuid           | Apache-2.0   |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| go.uber.org/goleak                | MIT          |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| golang.org/x/text                 | BSD-3-Clause |\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n| google.golang.org/protobuf        | BSD-3-Clause |\n```"
  }
]