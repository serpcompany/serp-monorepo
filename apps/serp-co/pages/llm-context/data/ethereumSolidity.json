[
  {
    "owner": "ethereum",
    "repo": "solidity",
    "content": "TITLE: Defining and Using Custom Errors in Solidity\nDESCRIPTION: This code snippet demonstrates how to define a custom error `InsufficientBalance` in Solidity and how to use it with both the `revert` statement and the `require` function. The error takes two parameters: `available` and `required`, representing the available balance and the requested amount, respectively.  The `transferWithRevertError` function uses `revert` with the custom error, while `transferWithRequireError` uses `require` with the same custom error. The `pragma` statement specifies the Solidity compiler version to use.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/errors.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.27;\n\n/// Insufficient balance for transfer. Needed `required` but only\n/// `available` available.\n/// @param available balance available.\n/// @param required requested amount to transfer.\nerror InsufficientBalance(uint256 available, uint256 required);\n\ncontract TestToken {\n    mapping(address => uint) balance;\n    function transferWithRevertError(address to, uint256 amount) public {\n        if (amount > balance[msg.sender])\n            revert InsufficientBalance({\n                available: balance[msg.sender],\n                required: amount\n            });\n        balance[msg.sender] -= amount;\n        balance[to] += amount;\n    }\n    function transferWithRequireError(address to, uint256 amount) public {\n        require(amount <= balance[msg.sender], InsufficientBalance(balance[msg.sender], amount));\n        balance[msg.sender] -= amount;\n        balance[to] += amount;\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Mutex with Modifiers in Solidity\nDESCRIPTION: This code demonstrates how to implement a mutex using a modifier in Solidity. The `noReentrancy` modifier prevents reentrant calls to a function by setting a `locked` flag. It requires that `locked` is false, sets `locked` to true before executing the function, and sets it back to false afterward, preventing recursive calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/function-modifiers.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\ncontract Mutex {\n    bool locked;\n    modifier noReentrancy() {\n        require(\n            !locked,\n            \"Reentrant call.\"\n        );\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /// This function is protected by a mutex, which means that\n    /// reentrant calls from within `msg.sender.call` cannot call `f` again.\n    /// The `return 7` statement assigns 7 to the return value but still\n    /// executes the statement `locked = false` in the modifier.\n    function f() public noReentrancy returns (uint) {\n        (bool success,) = msg.sender.call(\"\");\n        require(success);\n        return 7;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Solidity Version Pragma Example\nDESCRIPTION: This code snippet demonstrates how to use the version pragma in Solidity to specify a minimum compiler version and prevent compilation with incompatible future versions.  This ensures that the code compiles as intended and avoids unexpected behavior due to language changes.  It uses the `^` operator for a range of compatible versions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.5.2;\n```\n\n----------------------------------------\n\nTITLE: Solidity: Try/Catch Example\nDESCRIPTION: This Solidity code demonstrates the use of `try`/`catch` to handle errors in external function calls.  The `rate` function attempts to call `feed.getData(token)` and catches different error types: `Error` (revert with a reason string), `Panic` (panic errors like division by zero), and a generic `bytes` catch for other errors.  It increments an error counter and returns a success status based on whether the call succeeded or was caught.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\n\ninterface DataFeed { function getData(address token) external returns (uint value); }\n\ncontract FeedConsumer {\n  DataFeed feed;\n  uint errorCount;\n  function rate(address token) public returns (uint value, bool success) {\n    // Permanently disable the mechanism if there are\n    // more than 10 errors.\n    require(errorCount < 10);\n    try feed.getData(token) returns (uint v) {\n      return (v, true);\n    } catch Error(string memory /*reason*/) {\n      // This is executed in case\n      // revert was called inside getData\n      // and a reason string was provided.\n      errorCount++;\n      return (0, false);\n    } catch Panic(uint /*errorCode*/) {\n      // This is executed in case of a panic,\n      // i.e. a serious error like division by zero\n      // or overflow. The error code can be used\n      // to determine the kind of error.\n      errorCount++;\n      return (0, false);\n    } catch (bytes memory /*lowLevelData*/) {\n      // This is executed in case revert() was used.\n      errorCount++;\n      return (0, false);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Vulnerability Example 2\nDESCRIPTION: This code snippet demonstrates another reentrancy vulnerability. It is similar to the first example, but uses `call` with `{value: ...}` which forwards all remaining gas, potentially allowing a more complex attack.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract Fund {\n    /// @dev Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    /// Withdraw your share.\n    function withdraw() public {\n        (bool success,) = msg.sender.call{value: shares[msg.sender]}(\"\");\n        if (success)\n            shares[msg.sender] = 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Attack Wallet Contract Exploiting tx.origin in Solidity\nDESCRIPTION: This code demonstrates an attack contract that exploits the vulnerable wallet contract using `tx.origin`. The `TxAttackWallet` contract receives Ether and then calls the `transferTo` function of the `TxUserWallet` contract, bypassing the intended authorization check because `tx.origin` will still be the owner's address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ninterface TxUserWallet {\n    function transferTo(address payable dest, uint amount) external;\n}\n\ncontract TxAttackWallet {\n    address payable owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    receive() external payable {\n        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Prevention using Checks-Effects-Interactions Pattern\nDESCRIPTION: This code snippet demonstrates how to prevent reentrancy vulnerabilities using the Checks-Effects-Interactions pattern. The `withdraw` function first reads the caller's share, then resets the share to zero (Effects), and finally transfers the Ether (Interaction). This prevents a malicious contract from calling back into `withdraw` before the share is reset.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Fund {\n    /// @dev Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    /// Withdraw your share.\n    function withdraw() public {\n        uint share = shares[msg.sender];\n        shares[msg.sender] = 0;\n        payable(msg.sender).transfer(share);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Base Constructor Arguments in Inheritance (Solidity)\nDESCRIPTION: This Solidity snippet illustrates different ways to pass arguments to base contract constructors during inheritance. It showcases direct specification in the inheritance list, modifier-style invocation in the derived constructor, and the use of abstract contracts when arguments are not fully specified.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base {\n    uint x;\n    constructor(uint x_) { x = x_; }\n}\n\n// Either directly specify in the inheritance list...\ncontract Derived1 is Base(7) {\n    constructor() {}\n}\n\n// or through a \"modifier\" of the derived constructor...\ncontract Derived2 is Base {\n    constructor(uint y) Base(y * y) {}\n}\n\n// or declare abstract...\nabstract contract Derived3 is Base {\n}\n\n// and have the next concrete derived contract initialize it.\ncontract DerivedFromDerived is Derived3 {\n    constructor() Base(10 + 10) {}\n}\n```\n\n----------------------------------------\n\nTITLE: SimplePaymentChannel Contract Solidity\nDESCRIPTION: This Solidity contract implements a simple payment channel. It allows a sender to escrow Ether and authorize payments to a recipient via signed messages. It includes functionality for closing the channel by the recipient, extending the expiration by the sender, and claiming a timeout by the sender.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Frozeable {\n    bool private _frozen = false;\n\n    modifier notFrozen() {\n        require(!_frozen, \"Inactive Contract.\");\n        _;\n    }\n\n    function freeze() internal {\n        _frozen = true;\n    }\n}\n\ncontract SimplePaymentChannel is Frozeable {\n    address payable public sender;    // The account sending payments.\n    address payable public recipient; // The account receiving the payments.\n    uint256 public expiration;        // Timeout in case the recipient never closes.\n\n    constructor (address payable recipientAddress, uint256 duration)\n        payable\n    {\n        sender = payable(msg.sender);\n        recipient = recipientAddress;\n        expiration = block.timestamp + duration;\n    }\n\n    /// the recipient can close the channel at any time by presenting a\n    /// signed amount from the sender. the recipient will be sent that amount,\n    /// and the remainder will go back to the sender\n    function close(uint256 amount, bytes memory signature)\n        external\n        notFrozen\n    {\n        require(msg.sender == recipient);\n        require(isValidSignature(amount, signature));\n\n        recipient.transfer(amount);\n        freeze();\n        sender.transfer(address(this).balance);\n    }\n\n    /// the sender can extend the expiration at any time\n    function extend(uint256 newExpiration)\n        external\n        notFrozen\n    {\n        require(msg.sender == sender);\n        require(newExpiration > expiration);\n\n        expiration = newExpiration;\n    }\n\n    /// if the timeout is reached without the recipient closing the channel,\n    /// then the Ether is released back to the sender.\n    function claimTimeout()\n        external\n        notFrozen\n    {\n        require(block.timestamp >= expiration);\n        freeze();\n        sender.transfer(address(this).balance);\n    }\n\n    function isValidSignature(uint256 amount, bytes memory signature)\n        internal\n        view\n        returns (bool)\n    {\n        bytes32 message = prefixed(keccak256(abi.encodePacked(this, amount)));\n        // check that the signature is from the payment sender\n        return recoverSigner(message, signature) == sender;\n    }\n\n    /// All functions below this are just taken from the chapter\n    /// 'creating and verifying signatures' chapter.\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unchecked Arithmetic Block - Solidity\nDESCRIPTION: Introduces the `unchecked { ... }` block in Solidity 0.8.0. This block disables arithmetic overflow/underflow checks, which are enabled by default. Using unchecked blocks allows developers to optimize gas costs where overflow/underflow is impossible.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nunchecked { ... }\n```\n\n----------------------------------------\n\nTITLE: Data Location and Assignment Example in Solidity\nDESCRIPTION: This Solidity contract demonstrates data location and assignment behavior. It shows how assignments between storage and memory create copies, while assignments within the same storage location create references. The example also illustrates limitations on modifying storage variables.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    // The data location of x is storage.\n    // This is the only place where the\n    // data location can be omitted.\n    uint[] x;\n\n    // The data location of memoryArray is memory.\n    function f(uint[] memory memoryArray) public {\n        x = memoryArray; // works, copies the whole array to storage\n        uint[] storage y = x; // works, assigns a pointer, data location of y is storage\n        y[7]; // fine, returns the 8th element\n        y.pop(); // fine, modifies x through y\n        delete x; // fine, clears the array, also modifies y\n        // The following does not work; it would need to create a new temporary /\n        // unnamed array in storage, but storage is \"statically\" allocated:\n        // y = memoryArray;\n        // Similarly, \"delete y\" is not valid, as assignments to local variables\n        // referencing storage objects can only be made from existing storage objects.\n        // It would \"reset\" the pointer, but there is no sensible location it could point to.\n        // For more details see the documentation of the \"delete\" operator.\n        // delete y;\n        g(x); // calls g, handing over a reference to x\n        h(x); // calls h and creates an independent, temporary copy in memory\n    }\n\n    function g(uint[] storage) internal pure {}\n    function h(uint[] memory) public pure {}\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition and Usage in Solidity\nDESCRIPTION: This Solidity code defines a struct `Funder` outside of a contract and another struct `Campaign` inside a contract. The `CrowdFunding` contract demonstrates how to create, access, and modify struct instances within mappings and storage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_12\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n// Defines a new type with two fields.\n// Declaring a struct outside of a contract allows\n// it to be shared by multiple contracts.\n// Here, this is not really needed.\nstruct Funder {\n    address addr;\n    uint amount;\n}\n\ncontract CrowdFunding {\n    // Structs can also be defined inside contracts, which makes them\n    // visible only there and in derived contracts.\n    struct Campaign {\n        address payable beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping(uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping(uint => Campaign) campaigns;\n\n    function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; // campaignID is return variable\n        // We cannot use \"campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)\"\n        // because the right hand side creates a memory-struct \"Campaign\" that contains a mapping.\n        Campaign storage c = campaigns[campaignID];\n        c.beneficiary = beneficiary;\n        c.fundingGoal = goal;\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        // Creates a new temporary memory struct, initialised with the given values\n        // and copies it over to storage.\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        c.beneficiary.transfer(amount);\n        return true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Balances Library in Solidity\nDESCRIPTION: This Solidity library defines a `move` function to transfer funds between addresses, ensuring balances remain non-negative and that the total supply remains constant. It requires a `mapping(address => uint256) storage balances` to track account balances, and uses `require` statements to enforce balance constraints before and after the transfer.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/modular.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\nlibrary Balances {\n    function move(mapping(address => uint256) storage balances, address from, address to, uint amount) internal {\n        require(balances[from] >= amount);\n        require(balances[to] + amount >= balances[to]);\n        balances[from] -= amount;\n        balances[to] += amount;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterable Mapping Implementation\nDESCRIPTION: This code demonstrates a library `IterableMapping` that implements iterable functionality on top of Solidity mappings. It uses structs to store data, keys, and deletion flags. The `User` contract shows how to use the library to insert data and iterate over it to compute the sum of all stored values.  It requires Solidity version ^0.8.8 or higher for type keyword.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/mapping-types.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\nstruct IndexValue { uint keyIndex; uint value; }\nstruct KeyFlag { uint key; bool deleted; }\n\nstruct itmap {\n    mapping(uint => IndexValue) data;\n    KeyFlag[] keys;\n    uint size;\n}\n\ntype Iterator is uint;\n\nlibrary IterableMapping {\n    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\n        uint keyIndex = self.data[key].keyIndex;\n        self.data[key].value = value;\n        if (keyIndex > 0)\n            return true;\n        else {\n            keyIndex = self.keys.length;\n            self.keys.push();\n            self.data[key].keyIndex = keyIndex + 1;\n            self.keys[keyIndex].key = key;\n            self.size++;\n            return false;\n        }\n    }\n\n    function remove(itmap storage self, uint key) internal returns (bool success) {\n        uint keyIndex = self.data[key].keyIndex;\n        if (keyIndex == 0)\n            return false;\n        delete self.data[key];\n        self.keys[keyIndex - 1].deleted = true;\n        self.size --;\n    }\n\n    function contains(itmap storage self, uint key) internal view returns (bool) {\n        return self.data[key].keyIndex > 0;\n    }\n\n    function iterateStart(itmap storage self) internal view returns (Iterator) {\n        return iteratorSkipDeleted(self, 0);\n    }\n\n    function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {\n        return Iterator.unwrap(iterator) < self.keys.length;\n    }\n\n    function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {\n        return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);\n    }\n\n    function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {\n        uint keyIndex = Iterator.unwrap(iterator);\n        key = self.keys[keyIndex].key;\n        value = self.data[key].value;\n    }\n\n    function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\n            keyIndex++;\n        return Iterator.wrap(keyIndex);\n    }\n}\n\n// How to use it\ncontract User {\n    // Just a struct holding our data.\n    itmap data;\n    // Apply library functions to the data type.\n    using IterableMapping for itmap;\n\n    // Insert something\n    function insert(uint k, uint v) public returns (uint size) {\n        // This calls IterableMapping.insert(data, k, v)\n        data.insert(k, v);\n        // We can still access members of the struct,\n        // but we should take care not to mess with them.\n        return data.size;\n    }\n\n    // Computes the sum of all stored data.\n    function sum() public view returns (uint s) {\n        for (\n            Iterator i = data.iterateStart();\n            data.iterateValid(i);\n            i = data.iterateNext(i)\n        ) {\n            (, uint value) = data.iterateGet(i);\n            s += value;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Update Function Call Syntax in Solidity\nDESCRIPTION: Updates the syntax for specifying Ether and gas in external function and contract creation calls in Solidity. The old syntax using `.gas()` and `.value()` is replaced with a new syntax using curly braces `{}` to encapsulate gas and value parameters.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nx.f{gas: 10000, value: 2 ether}(arg1, arg2)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Set Library in Solidity\nDESCRIPTION: This code snippet demonstrates how to implement a `Set` library in Solidity using a `struct` to hold the data and `storage` references to modify the calling contract's state. It shows how to insert, remove, and check the presence of elements in the set. The library functions are called from a contract, showcasing the use of `DELEGATECALL`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/libraries.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n\n// We define a new struct datatype that will be used to\n// hold its data in the calling contract.\nstruct Data {\n    mapping(uint => bool) flags;\n}\n\nlibrary Set {\n    // Note that the first parameter is of type \"storage\n    // reference\" and thus only its storage address and not\n    // its contents is passed as part of the call.  This is a\n    // special feature of library functions.  It is idiomatic\n    // to call the first parameter `self`, if the function can\n    // be seen as a method of that object.\n    function insert(Data storage self, uint value)\n        public\n        returns (bool)\n    {\n        if (self.flags[value])\n            return false; // already there\n        self.flags[value] = true;\n        return true;\n    }\n\n    function remove(Data storage self, uint value)\n        public\n        returns (bool)\n    {\n        if (!self.flags[value])\n            return false; // not there\n        self.flags[value] = false;\n        return true;\n    }\n\n    function contains(Data storage self, uint value)\n        public\n        view\n        returns (bool)\n    {\n        return self.flags[value];\n    }\n}\n\n\ncontract C {\n    Data knownValues;\n\n    function register(uint value) public {\n        // The library functions can be called without a\n        // specific instance of the library, since the\n        // \"instance\" will be the current contract.\n        require(Set.insert(knownValues, value));\n    }\n    // In this contract, we can also directly access knownValues.flags, if we want.\n}\n```\n\n----------------------------------------\n\nTITLE: Using Super for Correct Inheritance Call\nDESCRIPTION: This code snippet demonstrates the correct way to call base contract functions in a multiple inheritance scenario using the `super` keyword. `super` ensures that the functions are called in the correct order according to the inheritance hierarchy, avoiding the issue of bypassing intermediate logic.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Owned {\n    address payable owner;\n    constructor() { owner = payable(msg.sender); }\n}\n\ncontract Emittable is Owned {\n    event Emitted();\n\n    function emitEvent() virtual public {\n        if (msg.sender == owner) {\n            emit Emitted();\n        }\n    }\n}\n\ncontract Base1 is Emittable {\n    event Base1Emitted();\n    function emitEvent() public virtual override {\n        /* Here, we emit an event to simulate some Base1 logic */\n        emit Base1Emitted();\n        super.emitEvent();\n    }\n}\n\n\ncontract Base2 is Emittable {\n    event Base2Emitted();\n    function emitEvent() public virtual override {\n        /* Here, we emit an event to simulate some Base2 logic */\n        emit Base2Emitted();\n        super.emitEvent();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    event FinalEmitted();\n    function emitEvent() public override(Base1, Base2) {\n        /* Here, we emit an event to simulate some Final logic */\n        emit FinalEmitted();\n        super.emitEvent();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Contract Creation with Salt in Solidity\nDESCRIPTION: This Solidity code demonstrates how to create a contract using a salt value to derive the contract address. It computes the address from the creating contract's address, the salt, the creation bytecode, and constructor arguments. The nonce is not used, allowing for pre-computation of the contract address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ncontract D {\n    uint public x;\n    constructor(uint a) {\n        x = a;\n    }\n}\n\ncontract C {\n    function createDSalted(bytes32 salt, uint arg) public {\n        // This complicated expression just tells you how the address\n        // can be pre-computed. It is just there for illustration.\n        // You actually only need ``new D{salt: salt}(arg)``.\n        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            address(this),\n            salt,\n            keccak256(abi.encodePacked(\n                type(D).creationCode,\n                abi.encode(arg)\n            ))\n        )))));\n\n        D d = new D{salt: salt}(arg);\n        require(address(d) == predictedAddress);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Remote Purchase Contract in Solidity\nDESCRIPTION: This Solidity contract implements a safe remote purchase system using an escrow mechanism. Both buyer and seller deposit funds, and the contract manages the exchange based on state transitions triggered by specific actions. The contract ensures that funds are locked until the buyer confirms receipt of the item, providing security for both parties.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/safe-remote.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract Purchase {\n    uint public value;\n    address payable public seller;\n    address payable public buyer;\n\n    enum State { Created, Locked, Release, Inactive }\n    // The state variable has a default value of the first member, `State.created`\n    State public state;\n\n    modifier condition(bool condition_) {\n        require(condition_);\n        _;\n    }\n\n    /// Only the buyer can call this function.\n    error OnlyBuyer();\n    /// Only the seller can call this function.\n    error OnlySeller();\n    /// The function cannot be called at the current state.\n    error InvalidState();\n    /// The provided value has to be even.\n    error ValueNotEven();\n\n    modifier onlyBuyer() {\n        if (msg.sender != buyer)\n            revert OnlyBuyer();\n        _;\n    }\n\n    modifier onlySeller() {\n        if (msg.sender != seller)\n            revert OnlySeller();\n        _;\n    }\n\n    modifier inState(State state_) {\n        if (state != state_)\n            revert InvalidState();\n        _;\n    }\n\n    event Aborted();\n    event PurchaseConfirmed();\n    event ItemReceived();\n    event SellerRefunded();\n\n    // Ensure that `msg.value` is an even number.\n    // Division will truncate if it is an odd number.\n    // Check via multiplication that it wasn't an odd number.\n    constructor() payable {\n        seller = payable(msg.sender);\n        value = msg.value / 2;\n        if ((2 * value) != msg.value)\n            revert ValueNotEven();\n    }\n\n    /// Abort the purchase and reclaim the ether.\n    /// Can only be called by the seller before\n    /// the contract is locked.\n    function abort()\n        external\n        onlySeller\n        inState(State.Created)\n    {\n        emit Aborted();\n        state = State.Inactive;\n        // We use transfer here directly. It is\n        // reentrancy-safe, because it is the\n        // last call in this function and we\n        // already changed the state.\n        seller.transfer(address(this).balance);\n    }\n\n    /// Confirm the purchase as buyer.\n    /// Transaction has to include `2 * value` ether.\n    /// The ether will be locked until confirmReceived\n    /// is called.\n    function confirmPurchase()\n        external\n        inState(State.Created)\n        condition(msg.value == (2 * value))\n        payable\n    {\n        emit PurchaseConfirmed();\n        buyer = payable(msg.sender);\n        state = State.Locked;\n    }\n\n    /// Confirm that you (the buyer) received the item.\n    /// This will release the locked ether.\n    function confirmReceived()\n        external\n        onlyBuyer\n        inState(State.Locked)\n    {\n        emit ItemReceived();\n        // It is important to change the state first because\n        // otherwise, the contracts called using `send` below\n        // can call in again here.\n        state = State.Release;\n\n        buyer.transfer(value);\n    }\n\n    /// This function refunds the seller, i.e.\n    /// pays back the locked funds of the seller.\n    function refundSeller()\n        external\n        onlySeller\n        inState(State.Release)\n    {\n        emit SellerRefunded();\n        // It is important to change the state first because\n        // otherwise, the contracts called using `send` below\n        // can call in again here.\n        state = State.Inactive;\n\n        seller.transfer(3 * value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Constant and Immutable Variables in Solidity\nDESCRIPTION: This code demonstrates the declaration and usage of `constant` and `immutable` variables in a Solidity contract. `constant` variables must be assigned a value at compile time, while `immutable` variables can be assigned during construction. It showcases the assignment of different types like `uint`, `string`, `bytes32`, and `address` to these variables, including the use of `msg.sender` and external contract balance during construction for `immutable` variables.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/constant-state-variables.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.21;\n\nuint constant X = 32**22 + 8;\n\ncontract C {\n    string constant TEXT = \"abc\";\n    bytes32 constant MY_HASH = keccak256(\"abc\");\n    uint immutable decimals = 18;\n    uint immutable maxBalance;\n    address immutable owner = msg.sender;\n\n    constructor(uint decimals_, address ref) {\n        if (decimals_ != 0)\n            // Immutables are only immutable when deployed.\n            // At construction time they can be assigned to any number of times.\n            decimals = decimals_;\n\n        // Assignments to immutables can even access the environment.\n        maxBalance = ref.balance;\n    }\n\n    function isBalanceTooHigh(address other) public view returns (bool) {\n        return other.balance > maxBalance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Lock with Transient Storage in Solidity\nDESCRIPTION: This example demonstrates using transient storage to implement a reentrancy lock in a Solidity contract. The `locked` variable, declared as `bool transient`, is used to prevent reentrant calls to the `claimGift` function.  The modifier `nonReentrant` checks if the lock is set, sets it before executing the function body, and then resets it after execution. This pattern ensures only one execution of `claimGift` can occur within a single transaction, preventing potential vulnerabilities.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/transient-storage.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.28;\n\ncontract Generosity {\n    mapping(address => bool) sentGifts;\n    bool transient locked;\n\n    modifier nonReentrant {\n        require(!locked, \"Reentrancy attempt\");\n        locked = true;\n        _;\n        // Unlocks the guard, making the pattern composable.\n        // After the function exits, it can be called again, even in the same transaction.\n        locked = false;\n    }\n\n    function claimGift() nonReentrant public {\n        require(address(this).balance >= 1 ether);\n        require(!sentGifts[msg.sender]);\n        (bool success, ) = msg.sender.call{value: 1 ether}(\"\");\n        require(success);\n\n        // In a reentrant function, doing this last would open up the vulnerability\n        sentGifts[msg.sender] = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Type Min/Max Access\nDESCRIPTION: Demonstrates how to access the minimum and maximum values for an integer type in Solidity. This can be useful for range checking and understanding the limits of integer arithmetic.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(X).min\n```\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(X).max\n```\n\n----------------------------------------\n\nTITLE: Setting EVM Version for Solidity Compilation\nDESCRIPTION: This snippet illustrates how to specify the EVM version for Solidity compilation. The `evmVersion` option affects type checking and code generation, allowing targeting specific EVM versions like `cancun`.  Other available versions include `homestead`, `tangerineWhistle`, `spuriousDragon`, `byzantium`, `constantinople`, `petersburg`, `istanbul`, `berlin`, `london`, `paris`, `shanghai`, `cancun`, `prague`, and `osaka`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"evmVersion\": \"cancun\"\n}\n```\n\n----------------------------------------\n\nTITLE: Withdraw Overbid in Solidity\nDESCRIPTION: This function allows users to withdraw their funds if they were overbid. The function checks if there are any pending returns for the caller. The `pendingReturns` balance for the caller is set to zero before the transfer to prevent re-entrancy issues. Callable anytime after being overbid.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction withdraw() external {\n            uint amount = pendingReturns[msg.sender];\n            if (amount > 0) {\n                // It is important to set this to zero because the recipient\n                // can call this function again as part of the receiving call\n                // before `transfer` returns (see the remark above about\n                // conditions -> effects -> interaction).\n                pendingReturns[msg.sender] = 0;\n\n                payable(msg.sender).transfer(amount);\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Array Members and Dynamic Array Operations Solidity\nDESCRIPTION: This code provides comprehensive examples of working with array members like `length`, `push`, and `pop` in Solidity. It showcases how to modify storage arrays, use `push` and `pop` to change the size of arrays, and use struct types containing arrays.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract ArrayContract {\n    uint[2**20] aLotOfIntegers;\n    // Note that the following is not a pair of dynamic arrays but a\n    // dynamic array of pairs (i.e. of fixed size arrays of length two).\n    // In Solidity, T[k] and T[] are always arrays with elements of type T,\n    // even if T itself is an array.\n    // Because of that, bool[2][] is a dynamic array of elements\n    // that are bool[2]. This is different from other languages, like C.\n    // Data location for all state variables is storage.\n    bool[2][] pairsOfFlags;\n\n    // newPairs is stored in memory\n    function setAllFlagPairs(bool[2][] memory newPairs) public {\n        // assignment to a storage array performs a copy of ``newPairs`` and\n        // replaces the complete array ``pairsOfFlags``.\n        pairsOfFlags = newPairs;\n    }\n\n    struct StructType {\n        uint[] contents;\n        uint moreInfo;\n    }\n    StructType s;\n\n    function f(uint[] memory c) public {\n        // stores a reference to ``s`` in ``g``\n        StructType storage g = s;\n        // also changes ``s.moreInfo``.\n        g.moreInfo = 2;\n        // assigns a copy because ``g.contents``\n        // is not a local variable, but a member of\n        // a local variable.\n        g.contents = c;\n    }\n\n    function setFlagPair(uint index, bool flagA, bool flagB) public {\n        // access to a non-existing index will throw an exception\n        pairsOfFlags[index][0] = flagA;\n        pairsOfFlags[index][1] = flagB;\n    }\n\n    function changeFlagArraySize(uint newSize) public {\n        // using push and pop is the only way to change the\n        // length of an array\n        if (newSize < pairsOfFlags.length) {\n            while (pairsOfFlags.length > newSize)\n                pairsOfFlags.pop();\n        } else if (newSize > pairsOfFlags.length) {\n            while (pairsOfFlags.length < newSize)\n                pairsOfFlags.push();\n        }\n    }\n\n    function clear() public {\n        // these clear the arrays completely\n        delete pairsOfFlags;\n        delete aLotOfIntegers;\n        // identical effect here\n        pairsOfFlags = new bool[2][](0);\n    }\n\n    bytes byteData;\n\n    function byteArrays(bytes memory data) public {\n        // byte arrays (\"bytes\") are different as they are stored without padding,\n        // but can be treated identical to \"uint8[]\"\n        byteData = data;\n        for (uint i = 0; i < 7; i++)\n            byteData.push();\n        byteData[3] = 0x08;\n        delete byteData[2];\n    }\n\n    function addFlag(bool[2] memory flag) public returns (uint) {\n        pairsOfFlags.push(flag);\n        return pairsOfFlags.length;\n    }\n\n    function createMemoryArray(uint size) public pure returns (bytes memory) {\n        // Dynamic memory arrays are created using `new`:\n        uint[2][] memory arrayOfPairs = new uint[2][](size);\n\n        // Inline arrays are always statically-sized and if you only\n        // use literals, you have to provide at least one type.\n        arrayOfPairs[0] = [uint(1), 2];\n\n        // Create a dynamic byte array:\n        bytes memory b = new bytes(200);\n        for (uint i = 0; i < b.length; i++)\n            b[i] = bytes1(uint8(i));\n\n```\n\n----------------------------------------\n\nTITLE: Reverting Transactions with Error Details in Solidity\nDESCRIPTION: This snippet demonstrates how to use the `revert` statement in Solidity to abort and revert all changes in a transaction. It also shows how to provide error details using custom errors like `InsufficientBalance` to help debug failures. The error name and additional data will be supplied to the caller.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nif (senderBalance < amount) {\n    revert InsufficientBalance();\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity: Revert and Require Example\nDESCRIPTION: This Solidity code snippet demonstrates two equivalent ways to revert a transaction based on a condition: using an `if` statement with `revert` and using the `require` function.  Both approaches check if the provided amount exceeds half of the message value and revert with the same error message if the condition is met. The `withdraw` function demonstrates reverting with a custom error.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nif (amount > msg.value / 2 ether)\n  revert(\"Not enough Ether provided.\");\n// Alternative way to do it:\nrequire(\n  amount <= msg.value / 2 ether,\n  \"Not enough Ether provided.\"\n);\n// Perform the purchase.\nfunction withdraw() public {\n  if (msg.sender != owner)\n    revert Unauthorized();\n\n  payable(msg.sender).transfer(address(this).balance);\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Mappings and Storage in Solidity\nDESCRIPTION: This code demonstrates the behavior of mappings within arrays in Solidity when attempting to delete them. The `Map` contract shows that deleting the array does not erase the data stored in the mappings, highlighting a potential issue when needing to completely clear storage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Map {\n    mapping(uint => uint)[] array;\n\n    function allocate(uint newMaps) public {\n        for (uint i = 0; i < newMaps; i++)\n            array.push();\n    }\n\n    function writeMap(uint map, uint key, uint value) public {\n        array[map][key] = value;\n    }\n\n    function readMap(uint map, uint key) public view returns (uint) {\n        return array[map][key];\n    }\n\n    function eraseMaps() public {\n        delete array;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifier with Arguments in Solidity\nDESCRIPTION: This code defines a modifier `costs` that takes a `uint` argument `price`. The modifier checks if `msg.value` (the amount of Ether sent with the transaction) is greater than or equal to `price`, and if so, executes the function body. This allows enforcing a minimum payment for function execution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/function-modifiers.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\ncontract priced {\n    // Modifiers can receive arguments:\n    modifier costs(uint price) {\n        if (msg.value >= price) {\n            _;\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Integer Overflow Example in Solidity\nDESCRIPTION: This code demonstrates an integer overflow in Solidity when using `uint8`. When the result of adding x and y exceeds the maximum value that `uint8` can hold, it overflows.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nuint8 x = 255;\nuint8 y = 1;\nreturn x + y;\n```\n\n----------------------------------------\n\nTITLE: Solidity Getter Function Example\nDESCRIPTION: This code demonstrates the automatically generated getter functions for public state variables in Solidity. The `Caller` contract accesses the `data` variable of contract `C` using the generated getter function `c.data()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    uint public data = 42;\n}\n\ncontract Caller {\n    C c = new C();\n    function f() public view returns (uint) {\n        return c.data();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: View Function in Solidity\nDESCRIPTION: This code presents a `view` function `f` in the contract `C`.  View functions promise not to modify the state. Requires Solidity version >=0.5.0 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    function f(uint a, uint b) public view returns (uint) {\n        return a * (b + 42) + block.timestamp;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unchecked Arithmetic in Solidity\nDESCRIPTION: This Solidity code demonstrates the use of an `unchecked` block to allow arithmetic operations to wrap on underflow or overflow, mimicking the behavior prior to Solidity 0.8.0. This is useful when wrapping arithmetic is specifically desired.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_11\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\ncontract C {\n    function f(uint a, uint b) pure public returns (uint) {\n        // This subtraction will wrap on underflow.\n        unchecked { return a - b; }\n    }\n    function g(uint a, uint b) pure public returns (uint) {\n\n```\n\n----------------------------------------\n\nTITLE: Immutable State Variables Declaration - Solidity\nDESCRIPTION: Introduces the `immutable` keyword for state variables, allowing them to be assigned only in the constructor. The value is stored directly in the code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_17\n\nLANGUAGE: Solidity\nCODE:\n```\nstate variables can be marked ``immutable`` which causes them to be read-only, but assignable in the constructor. The value will be stored directly in the code.\n```\n\n----------------------------------------\n\nTITLE: Overflow Check in Solidity\nDESCRIPTION: This contract demonstrates a basic overflow check. The SMTChecker, when configured with the `underflow,overflow` target, reports a potential overflow in the `add` function because the result might exceed the maximum value of a `uint`. The example includes the necessary pragma and license identifier.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Overflow {\n    uint immutable x;\n    uint immutable y;\n\n    function add(uint x_, uint y_) internal pure returns (uint) {\n        return x_ + y_;\n    }\n\n    constructor(uint x_, uint y_) {\n        (x, y) = (x_, y_);\n    }\n\n    function stateAdd() public view returns (uint) {\n        return add(x, y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function with timedTransitions and Stage Check in Solidity\nDESCRIPTION: This `bid` function is payable and utilizes modifiers to enforce stage restrictions and timed transitions. The `timedTransitions` modifier is invoked before the `atStage` modifier to ensure stage transitions occur first. This demonstrates how modifiers can be chained to control execution flow.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction bid()\n            public\n            payable\n            timedTransitions\n            atStage(Stages.AcceptingBlindedBids)\n        {\n            // We will not implement that here\n        }\n```\n\n----------------------------------------\n\nTITLE: Nested Mappings Example\nDESCRIPTION: This code demonstrates a nested mapping, commonly used in ERC20 token contracts to manage allowances. '_allowances' is a mapping from an address to another mapping (address to uint256), representing the amount an address is allowed to spend on behalf of another address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/mapping-types.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MappingExample {\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: Allowance not high enough.\");\n        _allowances[sender][msg.sender] -= amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: Not enough funds.\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(address sender, address recipient, uint256 amount);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory-Safe Assembly Annotation via Comment\nDESCRIPTION: This assembly block is annotated as memory-safe using a special comment, which is supported for backward compatibility with older Solidity compiler versions. This annotation is deprecated in favor of using the dialect string directly within the assembly block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\n/// @solidity memory-safe-assembly\nassembly {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: ERC20 Token Implementation in Yul\nDESCRIPTION: This Yul code snippet implements a complete ERC20 token contract. It includes functionalities like `balanceOf`, `totalSupply`, `transfer`, `transferFrom`, `approve`, `allowance`, and `mint`. It demonstrates how to manage token balances, allowances, and ownership using storage operations and calldata decoding within the Yul language.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_65\n\nLANGUAGE: Yul\nCODE:\n```\nobject \"Token\" {\n    code {\n        // Store the creator in slot zero.\n        sstore(0, caller())\n\n        // Deploy the contract\n        datacopy(0, dataoffset(\"runtime\"), datasize(\"runtime\"))\n        return(0, datasize(\"runtime\"))\n    }\n    object \"runtime\" {\n        code {\n            // Protection against sending Ether\n            require(iszero(callvalue()))\n\n            // Dispatcher\n            switch selector()\n            case 0x70a08231 /* \"balanceOf(address)\" */ {\n                returnUint(balanceOf(decodeAsAddress(0)))\n            }\n            case 0x18160ddd /* \"totalSupply()\" */ {\n                returnUint(totalSupply())\n            }\n            case 0xa9059cbb /* \"transfer(address,uint256)\" */ {\n                transfer(decodeAsAddress(0), decodeAsUint(1))\n                returnTrue()\n            }\n            case 0x23b872dd /* \"transferFrom(address,address,uint256)\" */ {\n                transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))\n                returnTrue()\n            }\n            case 0x095ea7b3 /* \"approve(address,uint256)\" */ {\n                approve(decodeAsAddress(0), decodeAsUint(1))\n                returnTrue()\n            }\n            case 0xdd62ed3e /* \"allowance(address,address)\" */ {\n                returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))\n            }\n            case 0x40c10f19 /* \"mint(address,uint256)\" */ {\n                mint(decodeAsAddress(0), decodeAsUint(1))\n                returnTrue()\n            }\n            default {\n                revert(0, 0)\n            }\n\n            function mint(account, amount) {\n                require(calledByOwner())\n\n                mintTokens(amount)\n                addToBalance(account, amount)\n                emitTransfer(0, account, amount)\n            }\n            function transfer(to, amount) {\n                executeTransfer(caller(), to, amount)\n            }\n            function approve(spender, amount) {\n                revertIfZeroAddress(spender)\n                setAllowance(caller(), spender, amount)\n                emitApproval(caller(), spender, amount)\n            }\n            function transferFrom(from, to, amount) {\n                decreaseAllowanceBy(from, caller(), amount)\n                executeTransfer(from, to, amount)\n            }\n\n            function executeTransfer(from, to, amount) {\n                revertIfZeroAddress(to)\n                deductFromBalance(from, amount)\n                addToBalance(to, amount)\n                emitTransfer(from, to, amount)\n            }\n\n\n            /* ---------- calldata decoding functions ----------- */\n            function selector() -> s {\n                s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)\n            }\n\n            function decodeAsAddress(offset) -> v {\n                v := decodeAsUint(offset)\n                if iszero(iszero(and(v, not(0xffffffffffffffffffffffffffffffffffffffff)))) {\n                    revert(0, 0)\n                }\n            }\n            function decodeAsUint(offset) -> v {\n                let pos := add(4, mul(offset, 0x20))\n                if lt(calldatasize(), add(pos, 0x20)) {\n                    revert(0, 0)\n                }\n                v := calldataload(pos)\n            }\n            /* ---------- calldata encoding functions ---------- */\n            function returnUint(v) {\n                mstore(0, v)\n                return(0, 0x20)\n            }\n            function returnTrue() {\n                returnUint(1)\n            }\n\n            /* -------- events ---------- */\n            function emitTransfer(from, to, amount) {\n                let signatureHash := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n                emitEvent(signatureHash, from, to, amount)\n            }\n            function emitApproval(from, spender, amount) {\n                let signatureHash := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n                emitEvent(signatureHash, from, spender, amount)\n            }\n            function emitEvent(signatureHash, indexed1, indexed2, nonIndexed) {\n                mstore(0, nonIndexed)\n                log3(0, 0x20, signatureHash, indexed1, indexed2)\n            }\n\n            /* -------- storage layout ---------- */\n            function ownerPos() -> p { p := 0 }\n            function totalSupplyPos() -> p { p := 1 }\n            function accountToStorageOffset(account) -> offset {\n                offset := add(0x1000, account)\n            }\n            function allowanceStorageOffset(account, spender) -> offset {\n                offset := accountToStorageOffset(account)\n                mstore(0, offset)\n                mstore(0x20, spender)\n                offset := keccak256(0, 0x40)\n            }\n\n            /* -------- storage access ---------- */\n            function owner() -> o {\n                o := sload(ownerPos())\n            }\n            function totalSupply() -> supply {\n                supply := sload(totalSupplyPos())\n            }\n            function mintTokens(amount) {\n                sstore(totalSupplyPos(), safeAdd(totalSupply(), amount))\n            }\n            function balanceOf(account) -> bal {\n                bal := sload(accountToStorageOffset(account))\n            }\n            function addToBalance(account, amount) {\n                let offset := accountToStorageOffset(account)\n                sstore(offset, safeAdd(sload(offset), amount))\n            }\n            function deductFromBalance(account, amount) {\n                let offset := accountToStorageOffset(account)\n                let bal := sload(offset)\n                require(lte(amount, bal))\n                sstore(offset, sub(bal, amount))\n            }\n            function allowance(account, spender) -> amount {\n                amount := sload(allowanceStorageOffset(account, spender))\n            }\n            function setAllowance(account, spender, amount) {\n                sstore(allowanceStorageOffset(account, spender), amount)\n            }\n            function decreaseAllowanceBy(account, spender, amount) {\n                let offset := allowanceStorageOffset(account, spender)\n                let currentAllowance := sload(offset)\n                require(lte(amount, currentAllowance))\n                sstore(offset, sub(currentAllowance, amount))\n            }\n\n            /* ---------- utility functions ---------- */\n            function lte(a, b) -> r {\n                r := iszero(gt(a, b))\n            }\n            function gte(a, b) -> r {\n                r := iszero(lt(a, b))\n            }\n            function safeAdd(a, b) -> r {\n                r := add(a, b)\n                if or(lt(r, a), lt(r, b)) { revert(0, 0) }\n            }\n            function calledByOwner() -> cbo {\n                cbo := eq(owner(), caller())\n            }\n            function revertIfZeroAddress(addr) {\n                require(addr)\n            }\n            function require(condition) {\n                if iszero(condition) { revert(0, 0) }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inheriting from an Abstract Contract in Solidity\nDESCRIPTION: This snippet shows how to inherit from an abstract contract (`Feline`) and implement its abstract function (`utterance()`). The `Cat` contract inherits from `Feline` and provides a concrete implementation for the `utterance()` function, overriding the virtual function from the base contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/abstract-contracts.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract Feline {\n    function utterance() public pure virtual returns (bytes32);\n}\n\ncontract Cat is Feline {\n    function utterance() public pure override returns (bytes32) { return \"miaow\"; }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Compiler Version Compatibility in Solidity\nDESCRIPTION: This snippet demonstrates how to specify the compiler version a Solidity source file is compatible with using the `pragma` keyword. This is crucial for ensuring code behaves as expected across different compiler versions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_30\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.4.0;\n```\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity >=0.4.0 <0.4.8;\n```\n\n----------------------------------------\n\nTITLE: Defining a Token Interface in Solidity\nDESCRIPTION: This snippet demonstrates how to define a basic interface called `Token` in Solidity. It includes an `enum`, a `struct`, and a function declaration.  All functions in an interface must be declared as `external`. The interface defines the basic structure and functions of a token contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/interfaces.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ninterface Token {\n    enum TokenType { Fungible, NonFungible }\n    struct Coin { string obverse; string reverse; }\n    function transfer(address recipient, uint amount) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Solidity Contract with Custom Error\nDESCRIPTION: This Solidity code defines a contract `TestToken` with a custom error `InsufficientBalance`. The `transfer` function always reverts with this error, demonstrating how to define and use custom errors in Solidity. The return data is encoded in the same way as a function call to `InsufficientBalance(uint256,uint256)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\ncontract TestToken {\n    error InsufficientBalance(uint256 available, uint256 required);\n    function transfer(address /*to*/, uint amount) public pure {\n        revert InsufficientBalance(0, amount);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Modifier in Solidity\nDESCRIPTION: This code defines a basic modifier `onlyOwner` that restricts function execution to the contract owner. It checks if `msg.sender` is equal to the `owner` and executes the function body (denoted by `_;`) if the condition is met, otherwise it throws an exception.  The contract `owned` demonstrates how to define a modifier, which is then used in a derived contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/function-modifiers.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\ncontract owned {\n    constructor() { owner = payable(msg.sender); }\n    address payable owner;\n\n    // This contract only defines a modifier but does not use\n    // it: it will be used in derived contracts.\n    // The function body is inserted where the special symbol\n    // `_;` in the definition of a modifier appears.\n    // This means that if the owner calls this function, the\n    // function is executed and otherwise, an exception is\n    // thrown.\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Proxy Contract with Permissionless Proxy in Solidity\nDESCRIPTION: This code demonstrates how to use a permissionless proxy to prevent a proxy contract from having any permissions itself. It defines two contracts: `ProxyWithMoreFunctionality` which delegates calls to `PermissionlessProxy`, and `PermissionlessProxy` which simply forwards calls to the target address using `addr.call(payload)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\ncontract ProxyWithMoreFunctionality {\n    PermissionlessProxy proxy;\n\n    function callOther(address addr, bytes memory payload) public\n            returns (bool, bytes memory) {\n        return proxy.callOther(addr, payload);\n    }\n    // Other functions and other functionality\n}\n\n// This is the full contract, it has no other functionality and\n// requires no privileges to work.\ncontract PermissionlessProxy {\n    function callOther(address addr, bytes memory payload) public\n            returns (bool, bytes memory) {\n        return addr.call(payload);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding External Functions with State Variables (Solidity)\nDESCRIPTION: This Solidity code demonstrates how a public state variable can override an external function if the parameter and return types match the getter function of the variable. This provides an alternative way to modify contract behavior through state management.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract A\n{\n    function f() external view virtual returns(uint) { return 5; }\n}\n\ncontract B is A\n{\n    uint public override f;\n}\n```\n\n----------------------------------------\n\nTITLE: Mutex Contract with Reentrancy Protection in Solidity\nDESCRIPTION: This Solidity code defines a `Mutex` contract that uses a lock to prevent reentrancy. It has a `set` function to set the value of `x` and a `run` function that calls an external `unknown` contract. The `mutex` modifier ensures that the contract is locked during the external call, preventing reentrant calls from modifying `x`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.8.0;\n\n    interface Unknown {\n        function run() external;\n    }\n\n    contract Mutex {\n        uint x;\n        bool lock;\n\n        Unknown immutable unknown;\n\n        constructor(Unknown u) {\n            require(address(u) != address(0));\n            unknown = u;\n        }\n\n        modifier mutex {\n            require(!lock);\n            lock = true;\n            _;\n            lock = false;\n        }\n\n        function set(uint x_) mutex public {\n            x = x_;\n        }\n\n        function run() mutex public {\n            uint xPre = x;\n            unknown.run();\n            assert(xPre == x);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Contract Inheritance Example\nDESCRIPTION: This example demonstrates basic contract inheritance in Solidity, including the use of `is` to inherit from another contract, `virtual` keyword for functions that can be overridden, and `override` keyword for functions that override base contract functions. It also showcases multiple inheritance and calling base contract functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Owned {\n    address payable owner;\n    constructor() { owner = payable(msg.sender); }\n}\n\n// Use `is` to derive from another contract. Derived\n// contracts can access all non-private members including\n// internal functions and state variables. These cannot be\n// accessed externally via `this`, though.\ncontract Emittable is Owned {\n    event Emitted();\n\n    // The keyword `virtual` means that the function can change\n    // its behavior in derived classes (\"overriding\").\n    function emitEvent() virtual public {\n        if (msg.sender == owner)\n            emit Emitted();\n    }\n}\n\n// These abstract contracts are only provided to make the\n// interface known to the compiler. Note the function\n// without body. If a contract does not implement all\n// functions it can only be used as an interface.\nabstract contract Config {\n    function lookup(uint id) public virtual returns (address adr);\n}\n\nabstract contract NameReg {\n    function register(bytes32 name) public virtual;\n    function unregister() public virtual;\n}\n\n// Multiple inheritance is possible. Note that `Owned` is\n// also a base class of `Emittable`, yet there is only a single\n// instance of `Owned` (as for virtual inheritance in C++).\ncontract Named is Owned, Emittable {\n    constructor(bytes32 name) {\n        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n        NameReg(config.lookup(1)).register(name);\n    }\n\n    // Functions can be overridden by another function with the same name and\n    // the same number/types of inputs. If the overriding function has different\n    // types of output parameters, that causes an error.\n    // Both local and message-based function calls take these overrides\n    // into account.\n    // If you want the function to override, you need to use the\n    // `override` keyword. You need to specify the `virtual` keyword again\n    // if you want this function to be overridden again.\n    function emitEvent() public virtual override {\n        if (msg.sender == owner) {\n            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n            NameReg(config.lookup(1)).unregister();\n            // It is still possible to call a specific\n            // overridden function.\n            Emittable.emitEvent();\n        }\n    }\n}\n\n\n// If a constructor takes an argument, it needs to be\n// provided in the header or modifier-invocation-style at\n// the constructor of the derived contract (see below).\ncontract PriceFeed is Owned, Emittable, Named(\"GoldFeed\") {\n    uint info;\n\n    function updateInfo(uint newInfo) public {\n        if (msg.sender == owner) info = newInfo;\n    }\n\n    // Here, we only specify `override` and not `virtual`.\n    // This means that contracts deriving from `PriceFeed`\n    // cannot change the behavior of `emitEvent` anymore.\n    function emitEvent() public override(Emittable, Named) { Named.emitEvent(); }\n    function get() public view returns(uint r) { return info; }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Array Getter Function Example\nDESCRIPTION: This code demonstrates how to retrieve elements from a public array using the generated getter function. It also shows how to define a custom function to return the entire array, since the getter only provides access to individual elements.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract arrayExample {\n    // public state variable\n    uint[] public myArray;\n\n    // Getter function generated by the compiler\n    /*\n    function myArray(uint i) public view returns (uint) {\n        return myArray[i];\n    }\n    */\n\n    // function that returns entire array\n    function getArray() public view returns (uint[] memory) {\n        return myArray;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Vulnerability Example 1\nDESCRIPTION: This code snippet demonstrates a reentrancy vulnerability in a Solidity contract. The `withdraw` function sends Ether to the caller and then resets the caller's share.  A malicious contract could call back into `withdraw` before the share is reset, allowing it to withdraw multiple times.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract Fund {\n    /// @dev Mapping of ether shares of the contract.\n    mapping(address => uint) shares;\n    /// Withdraw your share.\n    function withdraw() public {\n        if (payable(msg.sender).send(shares[msg.sender]))\n            shares[msg.sender] = 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function with multiple modifiers (timedTransitions, atStage, transitionNext) in Solidity\nDESCRIPTION: This function `h` uses three modifiers: `timedTransitions`, `atStage`, and `transitionNext`. It first checks timed transitions, then the current stage.  If both checks pass, the function executes, and finally transitions to the next stage. The order of modifiers is crucial.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction h()\n            public\n            timedTransitions\n            atStage(Stages.AreWeDoneYet)\n            transitionNext\n        {\n        }\n```\n\n----------------------------------------\n\nTITLE: Solidity VendingMachine Contract Using Revert and Require\nDESCRIPTION: This Solidity contract demonstrates how to use `revert` statements and `require` to handle errors, including using custom errors and string descriptions. It showcases different ways to trigger reverts based on conditions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\ncontract VendingMachine {\n    address owner;\n    error Unauthorized();\n    function buy(uint amount) public payable {\n\n```\n\n----------------------------------------\n\nTITLE: Reveal Blinded Bids in Solidity\nDESCRIPTION: This function enables users to reveal their blinded bids. It validates the revealed bids against the stored blinded bids. Correctly revealed invalid bids are refunded, and if the bid is the highest, the bidder is registered as the highest bidder. The refund amount is transferred to the bidder. This is callable only after the bidding end and before the reveal end.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction reveal(\n            uint[] calldata values,\n            bool[] calldata fakes,\n            bytes32[] calldata secrets\n        )\n            external\n            onlyAfter(biddingEnd)\n            onlyBefore(revealEnd)\n        {\n            uint length = bids[msg.sender].length;\n            require(values.length == length);\n            require(fakes.length == length);\n            require(secrets.length == length);\n\n            uint refund;\n            for (uint i = 0; i < length; i++) {\n                Bid storage bidToCheck = bids[msg.sender][i];\n                (uint value, bool fake, bytes32 secret) = \n                        (values[i], fakes[i], secrets[i]);\n                if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {\n                    // Bid was not actually revealed.\n                    // Do not refund deposit.\n                    continue;\n                }\n                refund += bidToCheck.deposit;\n                if (!fake && bidToCheck.deposit >= value) {\n                    if (placeBid(msg.sender, value))\n                        refund -= value;\n                }\n                // Make it impossible for the sender to re-claim\n                // the same deposit.\n                bidToCheck.blindedBid = bytes32(0);\n            }\n            payable(msg.sender).transfer(refund);\n        }\n```\n\n----------------------------------------\n\nTITLE: Assertion Violation Example in Solidity\nDESCRIPTION: This Solidity contract demonstrates an assertion violation by requiring the array length to be at least 5 and asserting that the maximum element is *strictly greater* than every element in the array. When the input array consists of identical elements (e.g., [0, 0, 0, 0, 0]), the assertion fails. The SMTChecker reports this violation, showcasing its ability to identify flawed logic.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Max {\n    function max(uint[] memory a) public pure returns (uint) {\n        require(a.length >= 5);\n        uint m = 0;\n        for (uint i = 0; i < a.length; ++i)\n            if (a[i] > m)\n                m = a[i];\n\n        for (uint i = 0; i < a.length; ++i)\n            assert(m > a[i]);\n\n        return m;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Contract Interaction via Call in Solidity\nDESCRIPTION: This snippet shows how to interact with a contract using the `call` function in Solidity. It encodes a function call using `abi.encodeWithSignature` and then uses `call` to execute the function on the target contract. The success status and return data are captured.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nbytes memory payload = abi.encodeWithSignature(\"register(string)\", \"MyName\");\n(bool success, bytes memory returnData) = address(nameReg).call(payload);\nrequire(success);\n```\n\n----------------------------------------\n\nTITLE: Blind Auction Contract in Solidity\nDESCRIPTION: This Solidity contract implements a blind auction.  Bidders submit a hash of their bid (blindedBid) and a deposit. After the bidding phase, bidders reveal their bids. The contract verifies the revealed bid against the provided hash and determines the highest valid bid. The contract includes mechanisms to prevent bids made after the bidding end and to handle situations where the auction has already ended.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract BlindAuction {\n    struct Bid {\n        bytes32 blindedBid;\n        uint deposit;\n    }\n\n    address payable public beneficiary;\n    uint public biddingEnd;\n    uint public revealEnd;\n    bool public ended;\n\n    mapping(address => Bid[]) public bids;\n\n    address public highestBidder;\n    uint public highestBid;\n\n    // Allowed withdrawals of previous bids\n    mapping(address => uint) pendingReturns;\n\n    event AuctionEnded(address winner, uint highestBid);\n\n    // Errors that describe failures.\n\n    /// The function has been called too early.\n    /// Try again at `time`.\n    error TooEarly(uint time);\n    /// The function has been called too late.\n    /// It cannot be called after `time`.\n    error TooLate(uint time);\n    /// The function auctionEnd has already been called.\n    error AuctionEndAlreadyCalled();\n\n    // Modifiers are a convenient way to validate inputs to\n    // functions. `onlyBefore` is applied to `bid` below:\n    // The new function body is the modifier's body where\n    // `_` is replaced by the old function body.\n    modifier onlyBefore(uint time) {\n        if (block.timestamp >= time) revert TooLate(time);\n        _;\n    }\n    modifier onlyAfter(uint time) {\n        if (block.timestamp <= time) revert TooEarly(time);\n        _;\n    }\n\n    constructor(\n        uint biddingTime,\n        uint revealTime,\n        address payable beneficiaryAddress\n    ) {\n        beneficiary = beneficiaryAddress;\n        biddingEnd = block.timestamp + biddingTime;\n        revealEnd = biddingEnd + revealTime;\n    }\n\n    /// Place a blinded bid with `blindedBid` =\n```\n\n----------------------------------------\n\nTITLE: Implementing a BigInt Library in Solidity\nDESCRIPTION: This code snippet demonstrates how to implement a `BigInt` library in Solidity using `memory` types and internal functions to avoid the overhead of external function calls. It includes functions for creating a `bigint` from a `uint`, adding two `bigint` values, and accessing individual limbs of the `bigint`. The library is used in a contract to perform arithmetic operations on large integers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/libraries.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nstruct bigint {\n    uint[] limbs;\n}\n\nlibrary BigInt {\n    function fromUint(uint x) internal pure returns (bigint memory r) {\n        r.limbs = new uint[](1);\n        r.limbs[0] = x;\n    }\n\n    function add(bigint memory a, bigint memory b) internal pure returns (bigint memory r) {\n        r.limbs = new uint[](max(a.limbs.length, b.limbs.length));\n        uint carry = 0;\n        for (uint i = 0; i < r.limbs.length; ++i) {\n            uint limbA = limb(a, i);\n            uint limbB = limb(b, i);\n            unchecked {\n                r.limbs[i] = limbA + limbB + carry;\n\n                if (limbA + limbB < limbA || (limbA + limbB == type(uint).max && carry > 0))\n                    carry = 1;\n                else\n                    carry = 0;\n            }\n        }\n        if (carry > 0) {\n            // too bad, we have to add a limb\n            uint[] memory newLimbs = new uint[](r.limbs.length + 1);\n            uint i;\n            for (i = 0; i < r.limbs.length; ++i)\n                newLimbs[i] = r.limbs[i];\n            newLimbs[i] = carry;\n            r.limbs = newLimbs;\n        }\n    }\n\n    function limb(bigint memory a, uint index) internal pure returns (uint) {\n        return index < a.limbs.length ? a.limbs[index] : 0;\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        return a > b ? a : b;\n    }\n}\n\ncontract C {\n    using BigInt for bigint;\n\n    function f() public pure {\n        bigint memory x = BigInt.fromUint(7);\n        bigint memory y = BigInt.fromUint(type(uint).max);\n        bigint memory z = x.add(y);\n        assert(z.limb(1) > 0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Contract Creation and Interaction Example in Solidity\nDESCRIPTION: This Solidity code demonstrates the creation of contracts, including constructors, and inter-contract communication. It features two contracts: `OwnedToken` which represents a token with an owner and a name, and `TokenCreator` which can create `OwnedToken` contracts and perform operations on them.  The `OwnedToken` constructor initializes the owner, creator, and name.  The `TokenCreator` contract has functions to create a new `OwnedToken` contract, change the name of a `OwnedToken`, and check if a token transfer should proceed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/creating-contracts.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract OwnedToken {\n    // `TokenCreator` is a contract type that is defined below.\n    // It is fine to reference it as long as it is not used\n    // to create a new contract.\n    TokenCreator creator;\n    address owner;\n    bytes32 name;\n\n    // This is the constructor which registers the\n    // creator and the assigned name.\n    constructor(bytes32 name_) {\n        // State variables are accessed via their name\n        // and not via e.g. `this.owner`. Functions can\n        // be accessed directly or through `this.f`,\n        // but the latter provides an external view\n        // to the function. Especially in the constructor,\n        // you should not access functions externally,\n        // because the function does not exist yet.\n        // See the next section for details.\n        owner = msg.sender;\n\n        // We perform an explicit type conversion from `address`\n        // to `TokenCreator` and assume that the type of\n        // the calling contract is `TokenCreator`, there is\n        // no real way to verify that.\n        // This does not create a new contract.\n        creator = TokenCreator(msg.sender);\n        name = name_;\n    }\n\n    function changeName(bytes32 newName) public {\n        // Only the creator can alter the name.\n        // We compare the contract based on its\n        // address which can be retrieved by\n        // explicit conversion to address.\n        if (msg.sender == address(creator))\n            name = newName;\n    }\n\n    function transfer(address newOwner) public {\n        // Only the current owner can transfer the token.\n        if (msg.sender != owner) return;\n\n        // We ask the creator contract if the transfer\n        // should proceed by using a function of the\n        // `TokenCreator` contract defined below. If\n        // the call fails (e.g. due to out-of-gas),\n        // the execution also fails here.\n        if (creator.isTokenTransferOK(owner, newOwner))\n            owner = newOwner;\n    }\n}\n\n\ncontract TokenCreator {\n    function createToken(bytes32 name)\n        public\n        returns (OwnedToken tokenAddress)\n    {\n        // Create a new `Token` contract and return its address.\n        // From the JavaScript side, the return type\n        // of this function is `address`, as this is\n        // the closest type available in the ABI.\n        return new OwnedToken(name);\n    }\n\n    function changeName(OwnedToken tokenAddress, bytes32 name) public {\n        // Again, the external type of `tokenAddress` is\n        // simply `address`.\n        tokenAddress.changeName(name);\n    }\n\n    // Perform checks to determine if transferring a token to the\n    // `OwnedToken` contract should proceed\n    function isTokenTransferOK(address currentOwner, address newOwner)\n        public\n        pure\n        returns (bool ok)\n    {\n        // Check an arbitrary condition to see if transfer should proceed\n        return keccak256(abi.encodePacked(currentOwner, newOwner))[0] == 0x7f;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity: Enum Definition and Usage\nDESCRIPTION: Provides a complete example of enum definition and usage in Solidity. It shows how to declare an enum, define enum members, access enum values, and retrieve the smallest and largest values of the enum.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\ncontract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    ActionChoices choice;\n    ActionChoices constant defaultChoice = ActionChoices.GoStraight;\n\n    function setGoStraight() public {\n        choice = ActionChoices.GoStraight;\n    }\n\n    // Since enum types are not part of the ABI, the signature of \"getChoice\"\n    // will automatically be changed to \"getChoice() returns (uint8)\"\n    // for all matters external to Solidity.\n    function getChoice() public view returns (ActionChoices) {\n        return choice;\n    }\n\n    function getDefaultChoice() public pure returns (uint) {\n        return uint(defaultChoice);\n    }\n\n    function getLargestValue() public pure returns (ActionChoices) {\n        return type(ActionChoices).max;\n    }\n\n    function getSmallestValue() public pure returns (ActionChoices) {\n```\n\n----------------------------------------\n\nTITLE: Address Payable Conversion\nDESCRIPTION: Demonstrates explicit conversion from `address` to `address payable` in Solidity. Only expressions of type `address` and contract type can be converted to the type `address payable` via the explicit conversion `payable(...)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\npayable(<address>)\n```\n\n----------------------------------------\n\nTITLE: Signing a Payment with web3.js in JavaScript\nDESCRIPTION: This JavaScript function creates a signature for a payment, including the recipient's address, amount, nonce, and contract address. It uses the `ethereumjs-abi` library to mimic Solidity's `keccak256` function applied to arguments encoded using `abi.encodePacked`. This signature prevents replay attacks and cross-contract replay attacks.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// recipient is the address that should be paid.\n// amount, in wei, specifies how much ether should be sent.\n// nonce can be any unique number to prevent replay attacks\n// contractAddress is used to prevent cross-contract replay attacks\nfunction signPayment(recipient, amount, nonce, contractAddress, callback) {\n    var hash = \"0x\" + abi.soliditySHA3(\n        [\"address\", \"uint256\", \"uint256\", \"address\"],\n        [recipient, amount, nonce, contractAddress]\n    ).toString(\"hex\");\n\n    web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);\n}\n```\n\n----------------------------------------\n\nTITLE: Ether Denominations in Solidity\nDESCRIPTION: Demonstrates the usage of ether subdenominations (wei, gwei, ether) in Solidity. It shows how these suffixes are used to specify amounts of Ether and their equivalent values. The code asserts the equivalence of 1 wei, 1 gwei, and 1 ether to their corresponding values in Wei.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nassert(1 wei == 1);\nassert(1 gwei == 1e9);\nassert(1 ether == 1e18);\n```\n\n----------------------------------------\n\nTITLE: ReceiverPays Smart Contract in Solidity\nDESCRIPTION: This Solidity smart contract implements a micropayment channel. It includes functions for claiming payments, shutting down the contract, splitting signatures, recovering the signer, and generating a prefixed hash. It uses inline assembly to efficiently split the signature into its components.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Owned {\n    address payable owner;\n    constructor() {\n        owner = payable(msg.sender);\n    }\n}\n\ncontract Freezable is Owned {\n    bool private _frozen = false;\n\n    modifier notFrozen() {\n        require(!_frozen, \"Inactive Contract.\");\n        _;\n    }\n\n    function freeze() internal {\n        if (msg.sender == owner)\n            _frozen = true;\n    }\n}\n\ncontract ReceiverPays is Freezable {\n    mapping(uint256 => bool) usedNonces;\n\n    constructor() payable {}\n\n    function claimPayment(uint256 amount, uint256 nonce, bytes memory signature)\n        external\n        notFrozen\n    {\n        require(!usedNonces[nonce]);\n        usedNonces[nonce] = true;\n\n        // this recreates the message that was signed on the client\n        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));\n        require(recoverSigner(message, signature) == owner);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// freeze the contract and reclaim the leftover funds.\n    function shutdown()\n        external\n        notFrozen\n    {\n        require(msg.sender == owner);\n        freeze();\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /// signature methods.\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dangling References with Bytes Array in Solidity\nDESCRIPTION: This Solidity code demonstrates a potential issue when using `.push()` on a `bytes` array, which may switch from short to long layout in storage. The example shows how this can lead to a dangling reference if the array is simultaneously accessed by index in the same statement.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\n// This will report a warning\ncontract C {\n    bytes x = \"012345678901234567890123456789\";\n\n    function test() external returns(uint) {\n        (x.push(), x.push()) = (0x01, 0x02);\n        return x.length;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering Ethereum Address with ecrecover\nDESCRIPTION: Recovers the address associated with the public key from an elliptic curve signature. It returns zero on error. The function parameters correspond to ECDSA values of the signature: r, s, and v.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\necrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly Opcode Calls in Solidity v0.6.0\nDESCRIPTION: Shows how to call opcodes without arguments in inline assembly in Solidity v0.6.0. Opcodes that do not take arguments are now represented as \"built-in functions\" and require parentheses.  For example, `gas` is now `gas()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    function getGasLeft() public view returns (uint) {\n        uint gasLeft;\n        assembly {\n            gasLeft := gas()\n        }\n        return gasLeft;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Public Mapping Getter\nDESCRIPTION: This code demonstrates how Solidity automatically creates a getter function for public mappings.  The MappingExample contract defines a public mapping 'balances' from address to uint. The MappingUser contract calls the getter function of the MappingExample contract to retrieve the balance for a specific address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/mapping-types.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract MappingExample {\n    mapping(address => uint) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n\ncontract MappingUser {\n    function f() public returns (uint) {\n        MappingExample m = new MappingExample();\n        m.update(100);\n        return m.balances(address(this));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: External Function Types with Oracle in Solidity\nDESCRIPTION: This example demonstrates the use of external function types to implement an Oracle pattern in Solidity. The `Oracle` contract accepts a function of type `function(uint) external callback` as a parameter in its `query` function.  The `OracleUser` contract then defines a callback function `oracleResponse` and passes it to the `Oracle` to receive the response.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_19\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract Oracle {\n    struct Request {\n        bytes data;\n        function(uint) external callback;\n    }\n\n    Request[] private requests;\n    event NewRequest(uint);\n\n    function query(bytes memory data, function(uint) external callback) public {\n        requests.push(Request(data, callback));\n        emit NewRequest(requests.length - 1);\n    }\n\n    function reply(uint requestID, uint response) public {\n        // Here goes the check that the reply comes from a trusted source\n        requests[requestID].callback(response);\n    }\n}\n\n\ncontract OracleUser {\n    Oracle constant private ORACLE_CONST = Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract\n    uint private exchangeRate;\n\n    function buySomething() public {\n        ORACLE_CONST.query(\"USD\", this.oracleResponse);\n    }\n\n    function oracleResponse(uint response) public {\n        require(\n            msg.sender == address(ORACLE_CONST),\n            \"Only oracle can call this.\"\n        );\n        exchangeRate = response;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fallback and Receive Functions in Solidity v0.6.0\nDESCRIPTION: Illustrates the use of `fallback` and `receive` functions in Solidity v0.6.0.  The `receive` function is called when the call data is empty, and is implicitly `payable`. The `fallback` function is called when no other function matches.  If the receive function does not exist the fallback function also handles calls with empty call data. Transactions sending value to a non-payable fallback will revert.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    receive() external payable {\n        // Called when msg.data is empty and ether is sent\n    }\n\n    fallback() external {\n        // Called when no other function matches\n    }\n\n    fallback() external payable {\n        // Called when no other function matches and ether is sent\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Issue with Direct Base Contract Call\nDESCRIPTION: This code snippet illustrates a problem with directly calling a base contract function in a multiple inheritance scenario when overriding functions. Calling `Emittable.emitEvent()` directly bypasses the intermediate base contract logic, resulting in an incorrect execution sequence.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Owned {\n    address payable owner;\n    constructor() { owner = payable(msg.sender); }\n}\n\ncontract Emittable is Owned {\n    event Emitted();\n\n    function emitEvent() virtual public {\n        if (msg.sender == owner) {\n            emit Emitted();\n        }\n    }\n}\n\ncontract Base1 is Emittable {\n    event Base1Emitted();\n    function emitEvent() public virtual override {\n        /* Here, we emit an event to simulate some Base1 logic */\n        emit Base1Emitted();\n        Emittable.emitEvent();\n    }\n}\n\ncontract Base2 is Emittable {\n    event Base2Emitted();\n    function emitEvent() public virtual override {\n        /* Here, we emit an event to simulate some Base2 logic */\n        emit Base2Emitted();\n        Emittable.emitEvent();\n    }\n}\n\ncontract Final is Base1, Base2 {\n    event FinalEmitted();\n    function emitEvent() public override(Base1, Base2) {\n        /* Here, we emit an event to simulate some Final logic */\n        emit FinalEmitted();\n        Base2.emitEvent();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Documentation Example\nDESCRIPTION: Illustrates the use of NatSpec tags within a Solidity contract for documenting its functionality, parameters, and return values. It covers the basic contract structure and shows how to use comments for external and public functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/natspec-format.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.2 < 0.9.0;\n\n/// @title A simulator for trees\n/// @author Larry A. Gardner\n/// @notice You can use this contract for only the most basic simulation\n/// @dev All function calls are currently implemented without side effects\n/// @custom:experimental This is an experimental contract.\ncontract Tree {\n    /// @notice Calculate tree age in years, rounded up, for live trees\n    /// @dev The Alexandr N. Tetearing algorithm could increase precision\n    /// @param rings The number of rings from dendrochronological sample\n    /// @return Age in years, rounded up for partial years\n    /// @return Name of the tree\n    function age(uint256 rings) external virtual pure returns (uint256, string memory) {\n        return (rings + 1, \"tree\");\n    }\n\n    /// @notice Returns the amount of leaves the tree has.\n    /// @dev Returns only a fixed number.\n    function leaves() external virtual pure returns(uint256) {\n        return 2;\n    }\n}\n\ncontract Plant {\n    function leaves() external virtual pure returns(uint256) {\n        return 3;\n    }\n}\n\ncontract KumquatTree is Tree, Plant {\n    function age(uint256 rings) external override pure returns (uint256, string memory) {\n        return (rings + 2, \"Kumquat\");\n    }\n\n    /// Return the amount of leaves that this specific kind of tree has\n    /// @inheritdoc Tree\n    function leaves() external override(Tree, Plant) pure returns(uint256) {\n        return 3;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Subcurrency Contract in Solidity\nDESCRIPTION: This contract implements a basic cryptocurrency. It allows the contract creator to mint new coins and anyone to send coins to each other. The contract uses Solidity version 0.8.26 and introduces concepts like addresses, mappings, events, constructors, and error handling.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.26;\n\n// This will only compile via IR\ncontract Coin {\n    // The keyword \"public\" makes variables\n    // accessible from other contracts\n    address public minter;\n    mapping(address => uint) public balances;\n\n    // Events allow clients to react to specific\n    // contract changes you declare\n    event Sent(address from, address to, uint amount);\n\n    // Constructor code is only run when the contract\n    // is created\n    constructor() {\n        minter = msg.sender;\n    }\n\n    // Sends an amount of newly created coins to an address\n    // Can only be called by the contract creator\n    function mint(address receiver, uint amount) public {\n        require(msg.sender == minter);\n        balances[receiver] += amount;\n    }\n\n    // Errors allow you to provide information about\n    // why an operation failed. They are returned\n    // to the caller of the function.\n    error InsufficientBalance(uint requested, uint available);\n\n    // Sends an amount of existing coins\n    // from any caller to an address\n    function send(address receiver, uint amount) public {\n        require(amount <= balances[msg.sender], InsufficientBalance(amount, balances[msg.sender]));\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        emit Sent(msg.sender, receiver, amount);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Insecure Wallet Contract Using tx.origin in Solidity\nDESCRIPTION: This code demonstrates a vulnerable wallet contract that uses `tx.origin` for authorization, which can be exploited by an attacker. The `TxUserWallet` contract checks if `tx.origin` matches the owner's address before transferring funds, but this can be bypassed by an attack contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/security-considerations.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// THIS CONTRACT CONTAINS A BUG - DO NOT USE\ncontract TxUserWallet {\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferTo(address payable dest, uint amount) public {\n        // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin\n        require(tx.origin == owner);\n        dest.transfer(amount);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modular Arithmetic Functions\nDESCRIPTION: Illustrates the use of `addmod` and `mulmod` for performing modular addition and multiplication with arbitrary intermediate precision, preventing overflows.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_41\n\nLANGUAGE: Solidity\nCODE:\n```\naddmod\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nmulmod\n```\n\n----------------------------------------\n\nTITLE: Braces for Contracts/Libraries/Functions/Structs - Solidity\nDESCRIPTION: This snippet demonstrates the correct placement of braces for contracts, libraries, functions, and structs in Solidity. The opening brace should be on the same line as the declaration, preceded by a space, and the closing brace should be on its own line at the same indentation level.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Coin {\n    struct Bank {\n        address owner;\n        uint balance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Operators for User-Defined Types in Solidity\nDESCRIPTION: This code shows how to define custom operators for a user-defined value type using the `using for` directive. It defines the `UFixed16x2` type and overloads the `+` (addition) and `/` (division) operators for this type. The overloaded operators are defined as `pure` functions and must take the user-defined type as input and return it as output.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/using-for.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ntype UFixed16x2 is uint16;\n\nusing {\n    add as +,\n    div as /\n} for UFixed16x2 global;\n\nuint32 constant SCALE = 100;\n\nfunction add(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {\n    return UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));\n}\n\nfunction div(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {\n    uint32 a32 = UFixed16x2.unwrap(a);\n    uint32 b32 = UFixed16x2.unwrap(b);\n    uint32 result32 = a32 * SCALE / b32;\n    require(result32 <= type(uint16).max, \"Divide overflow\");\n    return UFixed16x2.wrap(uint16(a32 * SCALE / b32));\n}\n\ncontract Math {\n    function avg(UFixed16x2 a, UFixed16x2 b) public pure returns (UFixed16x2) {\n        return (a + b) / UFixed16x2.wrap(200);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Call with Named Parameters in Solidity\nDESCRIPTION: This snippet shows how to call a function with named parameters in Solidity. The parameters are passed within curly braces `{}` and can be specified in any order, as long as the names match the function declaration.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract C {\n    mapping(uint => uint) data;\n\n    function f() public {\n        set({value: 2, key: 3});\n    }\n\n    function set(uint key, uint value) public {\n        data[key] = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Define and Use User-Defined Value Type in Solidity\nDESCRIPTION: This code defines a user-defined value type `UFixed256x18` based on `uint256` to represent a fixed-point number with 18 decimal places. It provides a library `FixedMath` for performing arithmetic operations on this custom type. The library includes functions for addition, multiplication, floor calculation, and conversion from `uint256` to `UFixed256x18`. Requires Solidity version 0.8.8 or higher.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_15\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\n// Represent a 18 decimal, 256 bit wide fixed point type using a user-defined value type.\ntype UFixed256x18 is uint256;\n\n/// A minimal library to do fixed point operations on UFixed256x18.\nlibrary FixedMath {\n    uint constant multiplier = 10**18;\n\n    /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked\n    /// arithmetic on uint256.\n    function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));\n    }\n    /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked\n    /// arithmetic on uint256.\n    function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);\n    }\n    /// Take the floor of a UFixed256x18 number.\n    /// @return the largest integer that does not exceed `a`.\n    function floor(UFixed256x18 a) internal pure returns (uint256) {\n        return UFixed256x18.unwrap(a) / multiplier;\n    }\n    /// Turns a uint256 into a UFixed256x18 of the same value.\n    /// Reverts if the integer is too large.\n    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(a * multiplier);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Settings for Solidity Compilation\nDESCRIPTION: This snippet shows how to configure debugging settings for Solidity compilation. The `revertStrings` option controls how revert reason strings are treated, with options like `default`, `strip`, `debug`, and `verboseDebug`.  The `debugInfo` option specifies which extra debug information to include in comments, such as `location` and `snippet`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"debug\": {\n    \"revertStrings\": \"default\",\n    \"debugInfo\": [\"location\", \"snippet\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Event in Solidity\nDESCRIPTION: This Solidity code snippet defines a contract with an event named `Deposit`. The event has three parameters: `from` (indexed), `id` (indexed), and `value`. The `deposit` function emits the event when called.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/events.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.4.21 <0.9.0;\n\n    contract ClientReceipt {\n        event Deposit(\n            address indexed from,\n            bytes32 indexed id,\n            uint value\n        );\n\n        function deposit(bytes32 id) public payable {\n            // Events are emitted using `emit`, followed by\n            // the name of the event and the arguments\n            // (if any) in parentheses. Any such invocation\n            // (even deeply nested) can be detected from\n            // the JavaScript API by filtering for `Deposit`.\n            emit Deposit(msg.sender, id, msg.value);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Using push() for Dynamic Storage Arrays in Solidity v0.6.0\nDESCRIPTION: Demonstrates how to use `push()` for dynamic storage arrays in Solidity v0.6.0. The `push(value)` function no longer returns the new length; use `array.length` to access it.  To increase length without adding an element, use `array.push()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    uint[] public myArray;\n\n    function addElement(uint value) public {\n        myArray.push(value);\n        // uint newLength = myArray.push(value); // No longer returns the new length\n        uint newLength = myArray.length; // Access the length via .length\n    }\n\n    function increaseLength() public {\n        myArray.push(); // Increase length by one\n    }\n\n    function decreaseLength() public {\n        myArray.pop(); // Decrease length by one\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listening to Events with Web3.js\nDESCRIPTION: This JavaScript code snippet demonstrates how to listen for the `Deposit` event emitted by the `ClientReceipt` contract using the web3.js library. It shows two ways to watch for event changes: using `watch` and passing a callback directly to the event constructor.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/events.rst#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nvar abi = /* abi as generated by the compiler */;\n    var ClientReceipt = web3.eth.contract(abi);\n    var clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* address */);\n\n    var depositEvent = clientReceipt.Deposit();\n\n    // watch for changes\n    depositEvent.watch(function(error, result){\n        // result contains non-indexed arguments and topics\n        // given to the `Deposit` call.\n        if (!error)\n            console.log(result);\n    });\n\n\n    // Or pass a callback to start watching immediately\n    var depositEvent = clientReceipt.Deposit(function(error, result) {\n        if (!error)\n            console.log(result);\n    });\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Interaction Example\nDESCRIPTION: This example illustrates how contract interaction is affected by visibility specifiers. It shows that contract `D` cannot access the private function `f` or the internal function `compute` of contract `C`, while contract `E` can access the internal function `compute` because it inherits from `C`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    uint private data;\n\n    function f(uint a) private pure returns(uint b) { return a + 1; }\n    function setData(uint a) public { data = a; }\n    function getData() public view returns(uint) { return data; }\n    function compute(uint a, uint b) internal pure returns (uint) { return a + b; }\n}\n\n// This will not compile\ncontract D {\n    function readData() public {\n        C c = new C();\n        uint local = c.f(7); // error: member `f` is not visible\n        c.setData(3);\n        local = c.getData();\n        local = c.compute(3, 5); // error: member `compute` is not visible\n    }\n}\n\ncontract E is C {\n    function g() public {\n        C c = new C();\n        uint val = compute(3, 5); // access to internal member (from derived to parent contract)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Contract Declaration in Solidity\nDESCRIPTION: This snippet demonstrates how to declare an abstract contract in Solidity using the `abstract` keyword. The `Feline` contract contains a function `utterance()` that is declared but not implemented, making the contract abstract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/abstract-contracts.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract Feline {\n    function utterance() public virtual returns (bytes32);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Address Code in Solidity\nDESCRIPTION: Retrieves the code at the address. Returns the code as a `bytes memory` array, which can be empty if no code is deployed at that address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.code (bytes memory)\n```\n\n----------------------------------------\n\nTITLE: Simple Open Auction Contract in Solidity\nDESCRIPTION: This Solidity contract implements a simple open auction.  Bidders submit bids with Ether, and the highest bidder's address and bid amount are tracked.  Previous bidders can withdraw their bids if outbid.  After the auction ends, the highest bid is transferred to the beneficiary. It demonstrates the use of events, errors, and natspec comments for improved contract interaction and documentation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract SimpleAuction {\n    // Parameters of the auction. Times are either\n    // absolute unix timestamps (seconds since 1970-01-01)\n    // or time periods in seconds.\n    address payable public beneficiary;\n    uint public auctionEndTime;\n\n    // Current state of the auction.\n    address public highestBidder;\n    uint public highestBid;\n\n    // Allowed withdrawals of previous bids\n    mapping(address => uint) pendingReturns;\n\n    // Set to true at the end, disallows any change.\n    // By default initialized to `false`.\n    bool ended;\n\n    // Events that will be emitted on changes.\n    event HighestBidIncreased(address bidder, uint amount);\n    event AuctionEnded(address winner, uint amount);\n\n    // Errors that describe failures.\n\n    // The triple-slash comments are so-called natspec\n    // comments. They will be shown when the user\n    // is asked to confirm a transaction or\n    // when an error is displayed.\n\n    /// The auction has already ended.\n    error AuctionAlreadyEnded();\n    /// There is already a higher or equal bid.\n    error BidNotHighEnough(uint highestBid);\n    /// The auction has not ended yet.\n    error AuctionNotYetEnded();\n    /// The function auctionEnd has already been called.\n    error AuctionEndAlreadyCalled();\n\n    /// Create a simple auction with `biddingTime`\n    /// seconds bidding time on behalf of the\n    /// beneficiary address `beneficiaryAddress`.\n    constructor(\n        uint biddingTime,\n        address payable beneficiaryAddress\n    ) {\n        beneficiary = beneficiaryAddress;\n        auctionEndTime = block.timestamp + biddingTime;\n    }\n\n    /// Bid on the auction with the value sent\n    /// together with this transaction.\n    /// The value will only be refunded if the\n    /// auction is not won.\n    function bid() external payable {\n        // No arguments are necessary, all\n        // information is already part of\n        // the transaction. The keyword payable\n        // is required for the function to\n        // be able to receive Ether.\n\n        // Revert the call if the bidding\n        // period is over.\n        if (block.timestamp > auctionEndTime)\n            revert AuctionAlreadyEnded();\n\n        // If the bid is not higher, send the\n        // Ether back (the revert statement\n        // will revert all changes in this\n        // function execution including\n        // it having received the Ether).\n        if (msg.value <= highestBid)\n            revert BidNotHighEnough(highestBid);\n\n        if (highestBid != 0) {\n            // Sending back the Ether by simply using\n            // highestBidder.send(highestBid) is a security risk\n            // because it could execute an untrusted contract.\n            // It is always safer to let the recipients\n            // withdraw their Ether themselves.\n            pendingReturns[highestBidder] += highestBid;\n        }\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    /// Withdraw a bid that was overbid.\n    function withdraw() external returns (bool) {\n        uint amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            pendingReturns[msg.sender] = 0;\n\n            // msg.sender is not of type `address payable` and must be\n            // explicitly converted using `payable(msg.sender)` in order\n            // use the member function `send()`.\n            if (!payable(msg.sender).send(amount)) {\n                // No need to call throw here, just reset the amount owing\n                pendingReturns[msg.sender] = amount;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// End the auction and send the highest bid\n    /// to the beneficiary.\n    function auctionEnd() external {\n        // It is a good guideline to structure functions that interact\n        // with other contracts (i.e. they call functions or send Ether)\n        // into three phases:\n        // 1. checking conditions\n        // 2. performing actions (potentially changing conditions)\n        // 3. interacting with other contracts\n        // If these phases are mixed up, the other contract could call\n        // back into the current contract and modify the state or cause\n        // effects (ether payout) to be performed multiple times.\n        // If functions called internally include interaction with external\n        // contracts, they also have to be considered interaction with\n        // external contracts.\n\n        // 1. Conditions\n        if (block.timestamp < auctionEndTime)\n            revert AuctionNotYetEnded();\n        if (ended)\n            revert AuctionEndAlreadyCalled();\n\n        // 2. Effects\n        ended = true;\n        emit AuctionEnded(highestBidder, highestBid);\n\n        // 3. Interaction\n        beneficiary.transfer(highestBid);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory Arrays Solidity\nDESCRIPTION: This code demonstrates how to allocate memory arrays with dynamic lengths using the `new` operator in Solidity. It shows how to create both `uint[]` and `bytes` arrays in memory, and how to assert their lengths.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f(uint len) public pure {\n        uint[] memory a = new uint[](7);\n        bytes memory b = new bytes(len);\n        assert(a.length == 7);\n        assert(b.length == len);\n        a[6] = 8;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Ordering by Visibility - Solidity\nDESCRIPTION: This snippet shows the recommended order of functions within a Solidity contract, grouped by visibility (constructor, receive, fallback, external, public, internal, private). View and pure functions should be placed last within each visibility grouping.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ncontract A {\n    constructor() {\n        // ...\n    }\n\n    receive() external payable {\n        // ...\n    }\n\n    fallback() external {\n        // ...\n    }\n\n    // External functions\n    // ...\n\n    // External functions that are view\n    // ...\n\n    // External functions that are pure\n    // ...\n\n    // Public functions\n    // ...\n\n    // Internal functions\n    // ...\n\n    // Private functions\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Storage Array Push\nDESCRIPTION: This snippet shows the use of `.push()` to add elements to the end of dynamic storage arrays. Storage arrays are persistent arrays that are stored on the blockchain.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_42\n\nLANGUAGE: Solidity\nCODE:\n```\n.push()\n```\n\n----------------------------------------\n\nTITLE: Destructuring Assignments in Solidity\nDESCRIPTION: This Solidity code demonstrates destructuring assignments and returning multiple values using tuples. It shows how to assign values from a returned tuple to new or pre-existing variables, and how to omit elements in the assignment.  It also covers swapping values using tuple assignment.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    uint index;\n\n    function f() public pure returns (uint, bool, uint) {\n        return (7, true, 2);\n    }\n\n    function g() public {\n        // Variables declared with type and assigned from the returned tuple,\n        // not all elements have to be specified (but the number must match).\n        (uint x, , uint y) = f();\n        // Common trick to swap values -- does not work for non-value storage types.\n        (x, y) = (y, x);\n        // Components can be left out (also for variable declarations).\n        (index, , ) = f(); // Sets the index to 7\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Values from a Solidity Function\nDESCRIPTION: This code shows a contract `Simple` with a function `arithmetic` that takes two unsigned integers as input and returns their sum and product.  It demonstrates the use of named return variables. Requires Solidity version >=0.4.16 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    {\n        sum = a + b;\n        product = a * b;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a State Variable in Solidity\nDESCRIPTION: This code snippet demonstrates the declaration of a state variable within a Solidity contract. The `storedData` variable of type `uint` is declared, which will be stored in the contract's storage.  The SPDX license identifier and pragma solidity directive are also included.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract SimpleStorage {\n    uint storedData; // State variable\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: End Auction in Solidity\nDESCRIPTION: This function concludes the auction and transfers the highest bid to the beneficiary. It emits an `AuctionEnded` event. It can only be called after the reveal end and ensures the auction hasn't already ended.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction auctionEnd()\n            external\n            onlyAfter(revealEnd)\n        {\n            if (ended) revert AuctionEndAlreadyCalled();\n            emit AuctionEnded(highestBidder, highestBid);\n            ended = true;\n            beneficiary.transfer(highestBid);\n        }\n```\n\n----------------------------------------\n\nTITLE: Selecting Compiler Outputs in Solidity\nDESCRIPTION: This snippet shows how to select desired outputs based on file and contract names during Solidity compilation. The `outputSelection` option allows specifying which outputs to generate, such as `abi`, `ast`, `metadata`, `evm.bytecode`, and `evm.bytecode.opcodes`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"outputSelection\": {\n    \"*\": {\n      \"*\": [\n        \"metadata\", \"evm.bytecode\"\n        , \"evm.bytecode.sourceMap\"\n      ],\n      \"\": [\n        \"ast\"\n      ]\n    },\n    \"def\": {\n      \"MyContract\": [ \"abi\", \"evm.bytecode.opcodes\" ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Complex Getter Function Example\nDESCRIPTION: This example illustrates getter functions for complex data structures including structs, mappings and arrays. It shows what is included in automatically generated getter functions and what is omitted, in particular the mapping and the arrays inside a struct cannot be accessed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Complex {\n    struct Data {\n        uint a;\n        bytes3 b;\n        mapping(uint => uint) map;\n        uint[3] c;\n        uint[] d;\n        bytes e;\n    }\n    mapping(uint => mapping(bool => Data[])) public data;\n}\n```\n\n----------------------------------------\n\nTITLE: Sign Message using web3.eth.personal.sign JavaScript\nDESCRIPTION: This JavaScript function signs a given message using the web3.eth.personal.sign method. It takes the message, the account to sign with, and a callback function as parameters. The callback receives the signed message.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction signMessage(message, callback) {\n    web3.eth.personal.sign(\n        \"0x\" + message.toString(\"hex\"),\n        web3.eth.defaultAccount,\n        callback\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Selective Import with Renaming\nDESCRIPTION: This code snippet demonstrates how to import specific symbols from another Solidity file and rename them during the import process. This allows managing naming conflicts and creating aliases for better code readability and maintainability. The imported symbols are available as `alias` and `symbol2`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nimport {symbol1 as alias, symbol2} from \"filename\";\n```\n\n----------------------------------------\n\nTITLE: type(I).interfaceId - Solidity\nDESCRIPTION: Added support for EIP 165 interface identifiers with `type(I).interfaceId`. This allows contracts to query if other contracts support specific interfaces.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_22\n\nLANGUAGE: Solidity\nCODE:\n```\nAdd support for EIP 165 interface identifiers with `type(I).interfaceId`.\n```\n\n----------------------------------------\n\nTITLE: JSON Representation of Solidity Contract ABI\nDESCRIPTION: This JSON represents the ABI of the `Test` contract defined in the previous snippet. It includes definitions for an error (`InsufficientBalance`), two events (`Event`, `Event2`), and a function (`foo`). This illustrates how Solidity contracts are represented in JSON format for ABI interaction.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[{\n    \"type\":\"error\",\n    \"inputs\": [{\"name\":\"available\",\"type\":\"uint256\"},{\"name\":\"required\",\"type\":\"uint256\"}],\n    \"name\":\"InsufficientBalance\"\n    }, {\n    \"type\":\"event\",\n    \"inputs\": [{\"name\":\"a\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"b\",\"type\":\"bytes32\",\"indexed\":false}],\n    \"name\":\"Event\"\n    }, {\n    \"type\":\"event\",\n    \"inputs\": [{\"name\":\"a\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"b\",\"type\":\"bytes32\",\"indexed\":false}],\n    \"name\":\"Event2\"\n    }, {\n    \"type\":\"function\",\n    \"inputs\": [{\"name\":\"a\",\"type\":\"uint256\"}],\n    \"name\":\"foo\",\n    \"outputs\": []\n    }]\n```\n\n----------------------------------------\n\nTITLE: Solidity Visibility Example\nDESCRIPTION: This example showcases different visibility specifiers in Solidity, including private, internal, and public. It demonstrates how these specifiers affect the accessibility of functions and state variables from within the contract and from other contracts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f(uint a) private pure returns (uint b) { return a + 1; }\n    function setData(uint a) internal { data = a; }\n    uint public data;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Modifiers in Multiple Inheritance (Solidity)\nDESCRIPTION: This Solidity example demonstrates overriding a modifier when inheriting from multiple base contracts.  The `override` keyword must specify all direct base contracts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base1\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Base2\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Inherited is Base1, Base2\n{\n    modifier foo() override(Base1, Base2) {_;}\n}\n```\n\n----------------------------------------\n\nTITLE: Remove Public Keyword from Constructors in Solidity\nDESCRIPTION: Removes the `public` keyword from constructors in Solidity. To prevent a contract from being created, mark it as `abstract` instead.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nabstract\n```\n\n----------------------------------------\n\nTITLE: Access Return Data from call, delegatecall, staticcall in Solidity\nDESCRIPTION: Illustrates how to access the return data from `.call()`, `.delegatecall()`, and `.staticcall()` functions by changing `bool success = otherContract.call(\"f\")` to `(bool success, bytes memory data) = otherContract.call(\"f\")` in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n(bool success, bytes memory data) = otherContract.call(\"f\")\n```\n\n----------------------------------------\n\nTITLE: Creating Contracts via `new` in Solidity\nDESCRIPTION: This example showcases how to create a new contract instance using the `new` keyword in Solidity.  It demonstrates how to pass arguments to the constructor of the created contract and how to send Ether along with the contract creation using the `value` option.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ncontract D {\n    uint public x;\n    constructor(uint a) payable {\n        x = a;\n    }\n}\n\ncontract C {\n    D d = new D(4); // will be executed as part of C's constructor\n\n    function createD(uint arg) public {\n        D newD = new D(arg);\n        newD.x();\n    }\n\n    function createAndEndowD(uint arg, uint amount) public payable {\n        // Send ether along with the creation\n        D newD = new D{value: amount}(arg);\n        newD.x();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Definition and Inheritance (Solidity)\nDESCRIPTION: This Solidity code demonstrates how constructors are defined and inherited in Solidity.  Base contract constructors must be called from derived contracts, either directly in the inheritance list or through modifier-style invocation. If a derived contract does not initialize all base contracts, it must be declared `abstract`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nabstract contract A {\n    uint public a;\n\n    constructor(uint a_) {\n        a = a_;\n    }\n}\n\ncontract B is A(1) {\n    constructor() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Free Function in Solidity\nDESCRIPTION: This code defines a free function `sum` in Solidity that calculates the sum of elements in an array. It also includes a contract `ArrayExample` that calls this free function.  Free functions are `internal` by default and their code is included in contracts that call them. Requires Solidity version >=0.7.1 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\nfunction sum(uint[] memory arr) pure returns (uint s) {\n    for (uint i = 0; i < arr.length; i++)\n        s += arr[i];\n}\n\ncontract ArrayExample {\n    bool found;\n    function f(uint[] memory arr) public {\n        // This calls the free function internally.\n        // The compiler will add its code to the contract.\n        uint s = sum(arr);\n        require(s >= 10);\n        found = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Vector Sum using Inline Assembly in Solidity\nDESCRIPTION: This Solidity library demonstrates how to calculate the sum of elements in a uint array using inline assembly to bypass array bounds checks for optimization. `sumAsm` iterates using Solidity `for` loop, while `sumPureAsm` does the entire computation in the `assembly` block itself.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\n\nlibrary VectorSum {\n    // This function is less efficient because the optimizer currently fails to\n    // remove the bounds checks in array access.\n    function sumSolidity(uint[] memory data) public pure returns (uint sum) {\n        for (uint i = 0; i < data.length; ++i)\n            sum += data[i];\n    }\n\n    // We know that we only access the array in bounds, so we can avoid the check.\n    // 0x20 needs to be added to an array because the first slot contains the\n    // array length.\n    function sumAsm(uint[] memory data) public pure returns (uint sum) {\n        for (uint i = 0; i < data.length; ++i) {\n            assembly {\n                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))\n            }\n        }\n    }\n\n    // Same as above, but accomplish the entire code within inline assembly.\n    function sumPureAsm(uint[] memory data) public pure returns (uint sum) {\n        assembly {\n            // Load the length (first 32 bytes)\n            let len := mload(data)\n\n            // Skip over the length field.\n            //\n            // Keep temporary variable so it can be incremented in place.\n            //\n            // NOTE: incrementing data would result in an unusable\n            //       data variable after this assembly block\n            let dataElementLocation := add(data, 0x20)\n\n            // Iterate until the bound is not met.\n            for\n                { let end := add(dataElementLocation, mul(len, 0x20)) }\n                lt(dataElementLocation, end)\n                { dataElementLocation := add(dataElementLocation, 0x20) }\n            {\n                sum := add(sum, mload(dataElementLocation))\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion: Combining Integer and Bytes in Solidity\nDESCRIPTION: Explains how to convert between integers and fixed-size byte arrays of different sizes using intermediate conversions in Solidity.  It showcases padding and truncation techniques for creating desired conversion outcomes, involving both integer and byte types. This helps achieve the correct truncation or padding when converting between integer and fixed-size byte arrays with differing sizes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\nbytes2 a = 0x1234;\nuint32 b = uint16(a); // b will be 0x00001234\nuint32 c = uint32(bytes4(a)); // c will be 0x12340000\nuint8 d = uint8(uint16(a)); // d will be 0x34\nuint8 e = uint8(bytes1(a)); // e will be 0x12\n```\n\n----------------------------------------\n\nTITLE: Array Assignments in Solidity\nDESCRIPTION: This Solidity code demonstrates the behavior of assignments for arrays, distinguishing between memory and storage data locations. It highlights that assigning a storage array to a memory array creates a copy, while modifying a storage array directly modifies the original.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract C {\n    uint[20] x;\n\n    function f() public {\n        g(x);\n        h(x);\n    }\n\n    function g(uint[20] memory y) internal pure {\n        y[2] = 3;\n    }\n\n    function h(uint[20] storage y) internal {\n        y[3] = 4;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Struct Member Access in Solidity\nDESCRIPTION: This example demonstrates how to directly access and modify members of a struct in Solidity using the `campaigns[campaignID].amount = 0` syntax.  This directly modifies the state variable `campaigns` at the given `campaignID`. No specific dependencies or prerequisites are needed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\ncampaigns[campaignID].amount = 0\n```\n\n----------------------------------------\n\nTITLE: Low-Level Delegatecall in Solidity\nDESCRIPTION: Issues a low-level `DELEGATECALL` with the given payload. It returns a success condition and return data. Forwards all available gas, which is adjustable.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.delegatecall(bytes memory) returns (bool, bytes memory)\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion: Padding Bytes in Solidity\nDESCRIPTION: Demonstrates explicit conversion from a smaller to a larger fixed-size byte array in Solidity, showing how it's padded on the right with zeros. The `bytes2` value `0x1234` is converted to `bytes4`, resulting in `0x12340000`. This illustrates that converting to a larger fixed-size byte array will append zero bytes to the end of the original value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\nbytes2 a = 0x1234;\nbytes4 b = bytes4(a); // b will be 0x12340000\nassert(a[0] == b[0]);\nassert(a[1] == b[1]);\n```\n\n----------------------------------------\n\nTITLE: Maximum Element Search and Assertion in Solidity\nDESCRIPTION: This Solidity contract finds the maximum element in an array and asserts that the maximum element is greater than or equal to every element in the array.  The SMTChecker automatically attempts to prove the safety of loop increments and the assertion. Requires Solidity >= 0.8.0\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Max {\n    function max(uint[] memory a) public pure returns (uint) {\n        uint m = 0;\n        for (uint i = 0; i < a.length; ++i)\n            if (a[i] > m)\n                m = a[i];\n\n        for (uint i = 0; i < a.length; ++i)\n            assert(m >= a[i]);\n\n        return m;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Array Slices in Solidity\nDESCRIPTION: This code demonstrates how array slices can be used to ABI-decode data passed in function parameters. The `forward` function shows how to extract a function signature and arguments from the `payload` using array slices and `abi.decode`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_11\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.5 <0.9.0;\ncontract Proxy {\n    /// @dev Address of the client contract managed by proxy i.e., this contract\n    address client;\n\n    constructor(address client_) {\n        client = client_;\n    }\n\n    /// Forward call to \"setOwner(address)\" that is implemented by client\n    /// after doing basic validation on the address argument.\n    function forward(bytes calldata payload) external {\n        bytes4 sig = bytes4(payload[:4]);\n        // Due to truncating behavior, bytes4(payload) performs identically.\n        // bytes4 sig = bytes4(payload);\n        if (sig == bytes4(keccak256(\"setOwner(address)\"))) {\n            address owner = abi.decode(payload[4:], (address));\n            require(owner != address(0), \"Address of owner cannot be zero.\");\n        }\n        (bool status,) = client.delegatecall(payload);\n        require(status, \"Forwarded call failed.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Function Modifiers (Solidity)\nDESCRIPTION: This Solidity code shows how to override function modifiers in derived contracts. The base modifier must be declared `virtual`, and the overriding modifier must use the `override` keyword.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Inherited is Base\n{\n    modifier foo() override {_;}\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract with Event and Error Definitions\nDESCRIPTION: This Solidity code defines a contract `Test` with events `Event` and `Event2`, and an error `InsufficientBalance`.  It also includes a function `foo` that emits an event, and initializes a `bytes32` variable.  This example showcases how events and errors can be incorporated into a contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n\ncontract Test {\n    constructor() { b = hex\"12345678901234567890123456789012\"; }\n    event Event(uint indexed a, bytes32 b);\n    event Event2(uint indexed a, bytes32 b);\n    error InsufficientBalance(uint256 available, uint256 required);\n    function foo(uint a) public { emit Event(a, b); }\n    bytes32 b;\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Token Contract Example with External Transfer\nDESCRIPTION: This Solidity code demonstrates a token contract and a test contract using external calls for token transfer. The `TokenCorrect` contract implements the `Token` interface, and the `Test` contract's `property_transfer` function calls the `transfer` function of the `TokenCorrect` contract to move tokens between addresses.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_15\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ninterface Token {\n    function balanceOf(address _a) external view returns (uint);\n    function transfer(address _to, uint _amt) external;\n}\n\ncontract TokenCorrect is Token {\n    mapping (address => uint) balance;\n    constructor(address _a, uint _b) {\n        balance[_a] = _b;\n    }\n    function balanceOf(address _a) public view override returns (uint) {\n        return balance[_a];\n    }\n    function transfer(address _to, uint _amt) public override {\n        require(balance[msg.sender] >= _amt);\n        balance[msg.sender] -= _amt;\n        balance[_to] += _amt;\n    }\n}\n\ncontract Test {\n    function property_transfer(address _token, address _to, uint _amt) public {\n        require(_to != address(this));\n\n        TokenCorrect t = TokenCorrect(_token);\n\n        uint xPre = t.balanceOf(address(this));\n        require(xPre >= _amt);\n        uint yPre = t.balanceOf(_to);\n\n        t.transfer(_to, _amt);\n        uint xPost = t.balanceOf(address(this));\n        uint yPost = t.balanceOf(_to);\n\n        assert(xPost == xPre - _amt);\n        assert(yPost == yPre + _amt);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Functions in Solidity v0.6.0\nDESCRIPTION: Demonstrates the use of `virtual` and `override` keywords when overriding functions in Solidity v0.6.0. Functions intended to be overridden must be marked with `virtual`, and overriding functions must use the `override` keyword.  For multiple inheritance, all base contracts defining the overridden function must be listed in parentheses after `override`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.6.0;\n\ncontract Base {\n    function foo() public virtual {\n        // ...\n    }\n}\n\ncontract Derived is Base {\n    function foo() public override {\n        // ...\n    }\n}\n\ncontract Base1 {\n    function bar() public virtual {}\n}\n\ncontract Base2 {\n    function bar() public virtual {}\n}\n\ncontract Derived2 is Base1, Base2 {\n    function bar() public override(Base1, Base2) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Address Balance in Solidity\nDESCRIPTION: Retrieves the balance of an address in Wei.  The `<address>.balance` member provides the current balance of the given address. The balance is represented as a `uint256`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.balance (uint256)\n```\n\n----------------------------------------\n\nTITLE: Pure Function in Solidity\nDESCRIPTION: This code demonstrates a `pure` function `f` within the contract `C`. Pure functions promise not to read from or modify the state.  Requires Solidity version >=0.5.0 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    function f(uint a, uint b) public pure returns (uint) {\n        return a * (b + 42);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Ether with Contract Call in Solidity\nDESCRIPTION: This snippet shows how to send Ether along with a contract call using the `value` modifier in Solidity. This is used when calling functions that require Ether to be sent as part of the transaction, like payable functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\naddress(nameReg).call{value: 1 ether}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n```\n\n----------------------------------------\n\nTITLE: Sending Ether to an Address in Solidity\nDESCRIPTION: Sends a specified amount of Wei to an address and returns a boolean indicating success or failure. It forwards a fixed gas stipend of 2300 gas.  It's an `address payable` member function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\n<address payable>.send(uint256 amount) returns (bool)\n```\n\n----------------------------------------\n\nTITLE: External Function Type Address Access in Solidity v0.6.0\nDESCRIPTION: Shows how to access the address of an external function type in Solidity v0.6.0.  Instead of converting the function type directly to an address using `address(f)`, you must now use the `address` member, i.e., `f.address`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/060-breaking-changes.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    function getAddress(function() external returns (uint) f) public view returns (address) {\n        return f.address;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bytes Array Conversion in Solidity\nDESCRIPTION: Illustrates explicit conversion of `bytes` arrays and `bytes` calldata slices to fixed `bytes` types (`bytes1` to `bytes32`) in Solidity. It details truncation for longer arrays and padding with zeros for shorter arrays. The example shows how to handle conversions between dynamic and fixed-size byte arrays and slices.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.5;\n\ncontract C {\n    bytes s = \"abcdefgh\";\n    function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {\n        require(c.length == 16, \"\");\n        bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen\n        b = bytes16(s);  // padded on the right, so result is \"abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0\"\n        bytes3 b1 = bytes3(s); // truncated, b1 equals to \"abc\"\n        b = bytes16(c[:8]);  // also padded with zeros\n        return (b, b1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Concatenation Example in Solidity\nDESCRIPTION: This Solidity contract demonstrates string concatenation using `string.concat`. It concatenates a storage string, a calldata bytes string, a literal string, and a memory string.  The example shows how to convert bytes to string, and also checks that the concatenated string has the expected length.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ncontract C {\n    string s = \"Storage\";\n    function f(bytes calldata bc, string memory sm, bytes16 b) public view {\n        string memory concatString = string.concat(s, string(bc), \"Literal\", sm);\n        assert((bytes(s).length + bc.length + 7 + bytes(sm).length) == bytes(concatString).length);\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Functions in Multiple Inheritance (Solidity)\nDESCRIPTION: This Solidity snippet demonstrates how to explicitly override a function when inheriting from multiple base contracts that define the same function. It requires specifying the base contracts in the `override` keyword.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base1\n{\n    function foo() virtual public {}\n}\n\ncontract Base2\n{\n    function foo() virtual public {}\n}\n\ncontract Inherited is Base1, Base2\n{\n    // Derives from multiple bases defining foo(), so we must explicitly\n    // override it\n    function foo() public override(Base1, Base2) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion: Padding Integer in Solidity\nDESCRIPTION: Demonstrates explicit conversion from a smaller to a larger integer type in Solidity, where the value is padded on the left with zeros. The `uint16` value `0x1234` is converted to `uint32`, resulting in `0x00001234`. This shows how smaller integer values can be safely promoted to larger integer types without changing their numerical value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\nuint16 a = 0x1234;\nuint32 b = uint32(a); // b will be 0x00001234 now\nassert(a == b);\n```\n\n----------------------------------------\n\nTITLE: Memory Location Tracking with Non-Overlapping Memory Writes in Yul\nDESCRIPTION: This example illustrates how the optimizer can retain knowledge about memory locations when writes to other locations are provably non-overlapping. This allows for Keccak-256 hashes to be evaluated even after intervening memory writes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_1\n\nLANGUAGE: yul\nCODE:\n```\nlet x := calldataload(0)\nmstore(x, 100)\n// Current knowledge memory location x -> 100\nlet y := add(x, 32)\n// Does not clear the knowledge that x -> 100, since y does not write to [x, x + 32)\nmstore(y, 200)\n// This Keccak-256 can now be evaluated\nlet value := keccak256(x, 32)\n```\n\n----------------------------------------\n\nTITLE: Transfer Ether in Solidity\nDESCRIPTION: This snippet demonstrates how to transfer Ether from one address to another using the `transfer` function in Solidity. It checks if the sender has sufficient balance before attempting the transfer. The transfer will revert if the balance of the current contract is not large enough or if the transfer is rejected by the receiving account.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\naddress payable x = payable(0x123);\naddress myAddress = address(this);\nif (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);\n```\n\n----------------------------------------\n\nTITLE: Multiple Inheritance Linearization Error (Solidity)\nDESCRIPTION: This Solidity code demonstrates a case where multiple inheritance results in a linearization error.  The order in which base contracts are listed in the `is` directive is crucial; conflicting override requests can lead to compilation failure.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract X {}\ncontract A is X {}\n// This will not compile\ncontract C is A, X {}\n```\n\n----------------------------------------\n\nTITLE: Solidity Import Statement\nDESCRIPTION: This code snippet demonstrates the basic syntax for importing all global symbols from another Solidity file. This is discouraged due to potential namespace pollution. The `filename` part is an import path, not a direct filesystem path.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"filename\";\n```\n\n----------------------------------------\n\nTITLE: Introduce blobbasefee Global Variable Solidity\nDESCRIPTION: This snippet introduces the global `block.blobbasefee` variable in Solidity. This variable allows smart contracts to retrieve the blob base fee of the current block, which is relevant for EIP-4844 and related blob transactions. This enables dynamic gas cost calculations within smart contracts based on network conditions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nIntroduce global ``block.blobbasefee`` for retrieving the blob base fee of the current block.\n```\n\n----------------------------------------\n\nTITLE: Accessing Contract Code with Inline Assembly in Solidity\nDESCRIPTION: This Solidity library function `at` uses inline assembly to retrieve the bytecode of a contract at a given address. It leverages `extcodesize` to get the code size, allocates memory using `mload` and `mstore`, and then uses `extcodecopy` to copy the bytecode into memory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\nlibrary GetCode {\n    function at(address addr) public view returns (bytes memory code) {\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(addr)\n            // allocate output byte array - this could also be done without assembly\n            // by using code = new bytes(size)\n            code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(addr, add(code, 0x20), 0, size)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unchecked Arithmetic Block\nDESCRIPTION: Shows how to use the `unchecked` block in Solidity to disable overflow and underflow checks for integer arithmetic. This can improve gas efficiency but introduces the risk of unexpected behavior if overflows occur.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nunchecked { assert(-x == x); }\n```\n\n----------------------------------------\n\nTITLE: Initializing Dynamically-Sized Arrays Solidity\nDESCRIPTION: This code demonstrates how to initialize a dynamically-sized array in Solidity by assigning values to individual elements.  It creates a `uint[] memory` array of size 3 and assigns values to its elements.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure {\n        uint[] memory x = new uint[](3);\n        x[0] = 1;\n        x[1] = 3;\n        x[2] = 4;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity: String Literal with Escape Characters\nDESCRIPTION: Illustrates the use of escape characters within a string literal, including newline, double quote, single quote, backslash, and character sequences. The example demonstrates how these escape sequences are interpreted to form a string of a specific length.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\n\"\\n\\\"\\'\\\\abc\\\ndef\"\n```\n\n----------------------------------------\n\nTITLE: Using For with Libraries to Extend Built-in Types in Solidity\nDESCRIPTION: This code demonstrates how to use the `using for` directive with a library to extend a built-in type, `uint[]`.  The `indexOf` function from the `Search` library is attached to the `uint[]` type, allowing it to be called as a member function on arrays of unsigned integers. This effectively extends the functionality of the built-in `uint[]` type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/using-for.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.13;\n\nlibrary Search {\n    function indexOf(uint[] storage self, uint value)\n        public\n        view\n        returns (uint)\n    {\n        for (uint i = 0; i < self.length; i++)\n            if (self[i] == value) return i;\n        return type(uint).max;\n    }\n}\nusing Search for uint[];\n\ncontract C {\n    uint[] data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function replace(uint from, uint to) public {\n        // This performs the library function call\n        uint index = data.indexOf(from);\n        if (index == type(uint).max)\n            data.push(to);\n        else\n            data[index] = to;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling msg.value in Payable Function (Solidity)\nDESCRIPTION: This snippet shows how to handle `msg.value` in a `payable` function in Solidity. It adds the received `msg.value` along with the converted `uint` value to a state variable `myNumber`.  The function must be declared `payable` to access `msg.value`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\nmyNumber += y + msg.value;\n```\n\n----------------------------------------\n\nTITLE: Accessing Contract Creation Code via Type Information\nDESCRIPTION: Retrieves the creation bytecode of the contract.  Uses the `type(C).creationCode` syntax where `C` is a contract type. Cannot be accessed from the contract itself or derived contracts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_17\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(C).creationCode\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Example with Storage and Transient Storage Variables\nDESCRIPTION: This snippet defines a Solidity contract named `A` that showcases a variety of state variables, including value types (uint, address), reference types (arrays, strings, bytes), mappings, and structs. It also includes both persistent storage variables and transient (memory) storage variables, allowing for demonstration of differences in storage layout.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.28;\ncontract A {\n    struct S {\n        uint128 a;\n        uint128 b;\n        uint[2] staticArray;\n        uint[] dynArray;\n    }\n\n    uint x;\n    uint transient y;\n    uint w;\n    uint transient z;\n\n    S s;\n    address addr;\n    address transient taddr;\n    mapping(uint => mapping(address => bool)) map;\n    uint[] array;\n    string s1;\n    bytes b1;\n}\n```\n\n----------------------------------------\n\nTITLE: Bytes to Uint Conversion in Solidity\nDESCRIPTION: This code snippet demonstrates how to convert a `bytes` type to a `uint` type in Solidity. It involves padding the `bytes` type to a common size (bytes4) and then converting it to `uint32`. This ensures consistent conversion.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nbytes4 x4 = bytes4(x); // Padding happens on the right\nuint32 y = uint32(x4); // Conversion is consistent\n```\n\n----------------------------------------\n\nTITLE: Adjusting Gas Limit for Contract Call in Solidity\nDESCRIPTION: This snippet demonstrates how to adjust the gas limit for a contract call using the `gas` modifier in Solidity. This allows specifying a specific amount of gas to be used for the call, which is necessary when dealing with complex function executions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\naddress(nameReg).call{gas: 1000000}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n```\n\n----------------------------------------\n\nTITLE: Variable Scoping in Solidity\nDESCRIPTION: This Solidity code illustrates variable scoping rules, similar to C99. Variables are visible from their declaration until the end of the smallest block. Variables outside code blocks (functions, contracts) are visible even before declaration. The code shows examples of variable shadowing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\ncontract C {\n    function minimalScoping() pure public {\n        {\n            uint same;\n            same = 1;\n        }\n\n        {\n            uint same;\n            same = 3;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declare a Fixed-Size Array in Solidity\nDESCRIPTION: This example shows how a fixed-size array of uint8 is declared in Solidity.  In storage, this array occupies a single 32-byte slot. However, in memory, it takes up 128 bytes because each of the four uint8 elements occupies 32 bytes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_memory.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\nuint8[4] a;\n```\n\n----------------------------------------\n\nTITLE: Example Solidity Contract with External Call\nDESCRIPTION: This Solidity code demonstrates a contract that makes an external call to another contract. The SMTChecker, by default, does not trust that the compile-time available code is the same as the runtime code. It highlights the scenario where external contract's `x` may have unexpected values.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_13\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.8.0;\n\n    contract Ext {\n        uint public x;\n        function setX(uint _x) public { x = _x; }\n    }\n    contract MyContract {\n        function callExt(Ext _e) public {\n            _e.setX(42);\n            assert(_e.x() == 42);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Call Function with ABI Encoding in Solidity\nDESCRIPTION: Illustrates how to change a function call with multiple arguments using `.call()` to use `.call(abi.encodeWithSignature(...))` for value types in Solidity. This ensures explicit encoding of arguments for external function calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nx.call(abi.encodeWithSignature(\"f(uint256)\", a, b))\n```\n\n----------------------------------------\n\nTITLE: NatSpec: Example of NatSpec Documentation in Solidity\nDESCRIPTION: This snippet demonstrates the use of NatSpec comments in Solidity to document contracts, functions, and their parameters.  It provides a simple storage contract with NatSpec annotations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_32\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\n/// @author The Solidity Team\n/// @title A simple storage example\ncontract SimpleStorage {\n    uint storedData;\n\n    /// Store `x`.\n    /// @param x the new value to store\n    /// @dev stores the number in the state variable `storedData`\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    /// Return the stored value.\n    /// @dev retrieves the value of the state variable `storedData`\n    /// @return the stored value\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Token Contract in Solidity\nDESCRIPTION: This Solidity contract implements a basic token with transfer, transferFrom, approve, and balanceOf functionalities, utilizing the `Balances` library for safe balance management. It maintains mappings for balances and allowances, emits `Transfer` and `Approval` events, and includes external functions for user interaction. The contract demonstrates how to integrate a library to handle core functionality.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/modular.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract Token {\n    mapping(address => uint256) balances;\n    using Balances for *;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    event Transfer(address from, address to, uint amount);\n    event Approval(address owner, address spender, uint amount);\n\n    function transfer(address to, uint amount) external returns (bool success) {\n        balances.move(msg.sender, to, amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n\n    }\n\n    function transferFrom(address from, address to, uint amount) external returns (bool success) {\n        require(allowed[from][msg.sender] >= amount);\n        allowed[from][msg.sender] -= amount;\n        balances.move(from, to, amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint tokens) external returns (bool success) {\n        require(allowed[msg.sender][spender] == 0, \"\");\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function balanceOf(address tokenOwner) external view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Fallback Function Example\nDESCRIPTION: This example showcases a `fallback` function in Solidity. The first contract `Test` has a non-payable fallback function that sets the state variable `x` to 1. Sending Ether to this contract will cause an exception. The second contract `TestPayable` demonstrates a payable fallback function and a receive function, showing how to handle plain Ether transfers and calls with data. The `Caller` contract calls both test contracts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ncontract Test {\n    uint x;\n    // This function is called for all messages sent to\n    // this contract (there is no other function).\n    // Sending Ether to this contract will cause an exception,\n    // because the fallback function does not have the `payable`\n    // modifier.\n    fallback() external { x = 1; }\n}\n\ncontract TestPayable {\n    uint x;\n    uint y;\n    // This function is called for all messages sent to\n    // this contract, except plain Ether transfers\n    // (there is no other function except the receive function).\n    // Any call with non-empty calldata to this contract will execute\n    // the fallback function (even if Ether is sent along with the call).\n    fallback() external payable { x = 1; y = msg.value; }\n\n    // This function is called for plain Ether transfers, i.e.\n    // for every call with empty calldata.\n    receive() external payable { x = 2; y = msg.value; }\n}\n\ncontract Caller {\n    function callTest(Test test) public returns (bool) {\n        (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1.\n\n        // address(test) will not allow to call ``send`` directly, since ``test`` has no payable\n        // fallback function.\n        // It has to be converted to the ``address payable`` type to even allow calling ``send`` on it.\n        address payable testPayable = payable(address(test));\n\n        // If someone sends Ether to that contract,\n        // the transfer will fail, i.e. this returns false here.\n        return testPayable.send(2 ether);\n    }\n\n    function callTestPayable(TestPayable test) public returns (bool) {\n        (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1 and test.y becoming 0.\n        (success,) = address(test).call{value: 1}(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1 and test.y becoming 1.\n\n        // If someone sends Ether to that contract, the receive function in TestPayable will be called.\n        // Since that function writes to storage, it takes more gas than is available with a\n        // simple ``send`` or ``transfer``. Because of that, we have to use a low-level call.\n        (success,) = address(test).call{value: 2 ether}(\"\");\n        require(success);\n        // results in test.x becoming == 2 and test.y becoming 2 ether.\n\n        return true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ABI Encoding of Array Data Structure\nDESCRIPTION: This snippet illustrates the encoding structure of nested dynamic arrays in Ethereum's ABI. It shows the offset and data organization for an array of arrays, demonstrating how lengths and values are positioned in the encoded data.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_1\n\nLANGUAGE: none\nCODE:\n```\n0 - a                                                                - offset of [1, 2]\n1 - b                                                                - offset of [3]\n2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for [1, 2]\n3 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1\n4 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2\n5 - 0000000000000000000000000000000000000000000000000000000000000001 - count for [3]\n6 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3\n```\n\n----------------------------------------\n\nTITLE: Solidity Compiler Output - Contracts\nDESCRIPTION: This code segment outlines the structure of the `contracts` section within the Solidity compiler output.  It encompasses contract-level outputs, including the ABI, metadata, documentation, intermediate representations (IR), storage layout, and EVM-related information like bytecode, assembly, gas estimates and function debug data. The output includes both optimized and unoptimized versions of the IR.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n{\n      // This contains the contract-level outputs.\n      // It can be limited/filtered by the outputSelection settings.\n      \"contracts\": {\n        \"sourceFile.sol\": {\n          // If the language used has no contract names, this field should equal to an empty string.\n          \"ContractName\": {\n            // The Ethereum Contract ABI. If empty, it is represented as an empty array.\n            // See https://docs.soliditylang.org/en/develop/abi-spec.html\n            \"abi\": [],\n            // See the Metadata Output documentation (serialised JSON string)\n            \"metadata\": \"{/* ... */}\",\n            // User documentation (natspec)\n            \"userdoc\": {},\n            // Developer documentation (natspec)\n            \"devdoc\": {},\n            // Intermediate representation before optimization (string)\n            \"ir\": \"\",\n            // AST of intermediate representation before optimization\n            \"irAst\":  {/* ... */},\n            // Intermediate representation after optimization (string)\n            \"irOptimized\": \"\",\n            // AST of intermediate representation after optimization\n            \"irOptimizedAst\": {/* ... */},\n            // See the Storage Layout documentation.\n            \"storageLayout\": {\"storage\": [/* ... */], \"types\": {/* ... */} },\n            // See the Storage Layout documentation.\n            \"transientStorageLayout\": {\"storage\": [/* ... */], \"types\": {/* ... */} },\n            // EVM-related outputs\n            \"evm\": {\n              // Assembly (string)\n              \"assembly\": \"\",\n              // Old-style assembly (object)\n              \"legacyAssembly\": {},\n              // Bytecode and related details.\n              \"bytecode\": {\n                // Debugging data at the level of functions.\n                \"functionDebugData\": {\n                  // Now follows a set of functions including compiler-internal and\n                  // user-defined function. The set does not have to be complete.\n                  \"@mint_13\": { // Internal name of the function\n                    \"entryPoint\": 128, // Byte offset into the bytecode where the function starts (optional)\n                    \"id\": 13, // AST ID of the function definition or null for compiler-internal functions (optional)\n                    \"parameterSlots\": 2, // Number of EVM stack slots for the function parameters (optional)\n                    \"returnSlots\": 1 // Number of EVM stack slots for the return values (optional)\n                  }\n                },\n                // The bytecode as a hex string.\n                \"object\": \"00fe\",\n                // Opcodes list (string)\n                \"opcodes\": \"\",\n                // The source mapping as a string. See the source mapping definition.\n                \"sourceMap\": \"\",\n                // Array of sources generated by the compiler. Currently only\n                // contains a single Yul file.\n                \"generatedSources\": [{\n                  // Yul AST\n                  \"ast\": {/* ... */},\n                  // Source file in its text form (may contain comments)\n                  \"contents\":\"{ function abi_decode(start, end) -> data { data := calldataload(start) } }\",\n                  // Source file ID, used for source references, same \"namespace\" as the Solidity source files\n                  \"id\": 2,\n                  \"language\": \"Yul\",\n                  \"name\": \"#utility.yul\"\n                }],\n                // If given, this is an unlinked object.\n                \"linkReferences\": {\n                  \"libraryFile.sol\": {\n                    // Byte offsets into the bytecode.\n                    // Linking replaces the 20 bytes located there.\n                    \"Library1\": [\n                      { \"start\": 0, \"length\": 20 },\n                      { \"start\": 200, \"length\": 20 }\n                    ]\n                  }\n                }\n              },\n              \"deployedBytecode\": {\n                /* ..., */ // The same layout as above.\n                \"immutableReferences\": {\n                  // There are two references to the immutable with AST ID 3, both 32 bytes long. One is\n                  // at bytecode offset 42, the other at bytecode offset 80.\n                  \"3\": [{ \"start\": 42, \"length\": 32 }, { \"start\": 80, \"length\": 32 }]\n                }\n              },\n              // The list of function hashes\n              \"methodIdentifiers\": {\n                \"delegate(address)\": \"5c19a95c\"\n              },\n              // Function gas estimates\n              \"gasEstimates\": {\n                \"creation\": {\n                  \"codeDepositCost\": \"420000\",\n                  \"executionCost\": \"infinite\",\n                  \"totalCost\": \"infinite\"\n                },\n                \"external\": {\n                  \"delegate(address)\": \"25000\"\n                },\n                \"internal\": {\n                  \"heavyLifting()\": \"infinite\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Formatting Control Structures - Solidity\nDESCRIPTION: Shows the recommended formatting style for `if`, `while`, and `for` control structures in Solidity.  The opening brace should be preceded by a single space, and the `else` statement should be on the same line as the closing brace of the preceding `if` block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\nif (...) {\n    ...\n}\n\nfor (...) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in Solidity\nDESCRIPTION: This code snippet shows how to define a function within a Solidity contract, and also how to define a helper function outside of a contract. The `bid` function is declared as `public payable`. A helper function `helper` which takes `uint x` as argument and returns `x * 2` is also defined.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\ncontract SimpleAuction {\n    function bid() public payable { // Function\n        // ...\n    }\n}\n\n// Helper function defined outside of a contract\nfunction helper(uint x) pure returns (uint) {\n    return x * 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Address to Payable Address Conversion Library (Solidity)\nDESCRIPTION: This Solidity library provides a function to explicitly convert a regular `address` to a `payable address`. It uses a `pure` function to perform the conversion by casting the `address` to `uint160` and then back to `address payable`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_17\n\nLANGUAGE: Solidity\nCODE:\n```\nlibrary AddressMakePayable {\n    function makePayable(address x) internal pure returns (address payable) {\n        return address(uint160(x));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Transient Storage for Multiplier in Solidity\nDESCRIPTION: This Solidity contract demonstrates a potential pitfall when using transient storage for values that should persist across multiple calls within a transaction.  The `multiplier` is stored in transient storage.  If `setMultiplier` and `multiply` are called in separate transactions, the `multiplier` will be reset to zero between calls, leading to unexpected results. This illustrates a potential issue with composability when using transient storage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/transient-storage.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.28;\n\ncontract MulService {\n    uint transient multiplier;\n    function setMultiplier(uint mul) external {\n        multiplier = mul;\n    }\n\n    function multiply(uint value) external view returns (uint) {\n        return value * multiplier;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Values Directly in Solidity\nDESCRIPTION: This code showcases a function `arithmetic` that returns the sum and product of two unsigned integers using a direct `return` statement. This is an alternative way to return multiple values.  Requires Solidity version >=0.4.16 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    {\n        return (a + b, a * b);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Contract Runtime Code\nDESCRIPTION: This Yul code snippet demonstrates basic runtime code within a Yul contract. It stores the string \"Hello, World!\" at memory location `0` and returns the location and size of the stored string.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_63\n\nLANGUAGE: Yul\nCODE:\n```\nmstore(0, \"Hello, World!\")\nreturn(0, 0x20)\n```\n\n----------------------------------------\n\nTITLE: Combining Gas and Value for Contract Call in Solidity\nDESCRIPTION: This snippet demonstrates how to combine both the `gas` and `value` modifiers in a single contract call in Solidity. This allows specifying both the gas limit and the amount of Ether to send, providing fine-grained control over the transaction execution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\naddress(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n```\n\n----------------------------------------\n\nTITLE: Accessing State Variables with Inline Assembly in Solidity\nDESCRIPTION: This Solidity contract shows how to access and modify state variables (specifically a transient variable and a uint) within an inline assembly block. It accesses the storage slot of variable `b` using `b.slot` and the storage slot of variable `a` using `a.slot` and modifies the values via `sload` and `tstore`\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.28 <0.9.0;\n\n// This will report a warning\ncontract C {\n    bool transient a;\n    uint b;\n    function f(uint x) public returns (uint r) {\n        assembly {\n            // We ignore the storage slot offset, we know it is zero\n            // in this special case.\n            r := mul(x, sload(b.slot))\n            tstore(a.slot, true)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Address Payable Conversion in Solidity\nDESCRIPTION: Shows how to convert an `address` to `address payable` via `uint160` in Solidity. It highlights the separation of `address` and `address payable` types.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nuint160(addr)\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Interaction and State Variable Calls\nDESCRIPTION: This Solidity code illustrates potential issues with state variable calls of contract type outside the analyzed contract. It demonstrates how external calls to a contract's state variable (e.g., `B.a`) can lead to inconsistencies during SMTChecker analysis, especially concerning storage tracking and assumptions about state changes between transactions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_16\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract A {\n    uint public x;\n    address immutable public owner;\n    constructor() {\n        owner = msg.sender;\n    }\n    function setX(uint _x) public {\n        require(msg.sender == owner);\n        x = _x;\n    }\n}\n\ncontract B {\n    A a;\n    constructor() {\n        a = new A();\n        assert(a.x() == 0); // (1) should hold\n    }\n    function g() public view {\n        assert(a.owner() == address(this)); // (2) should hold\n        assert(a.x() == 0); // (3) should hold, but fails due to a false positive\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing with sha256 in Solidity\nDESCRIPTION: Computes the SHA-256 hash of the input. This function takes a bytes memory array as input and returns a bytes32 value representing the SHA-256 hash.  It's a precompiled contract, so Out-of-Gas errors might occur on private blockchains if it hasn't been called before.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nsha256(bytes memory) returns (bytes32)\n```\n\n----------------------------------------\n\nTITLE: Yul Stand-Alone Usage Example\nDESCRIPTION: This JSON configuration shows how to use Yul in its stand-alone form with the Solidity compiler using the `--strict_assembly` flag or the standard-json interface.  It compiles the Yul code `{ sstore(0, 1) }` which stores the value 1 at storage location 0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n \"language\": \"Yul\",\n \"sources\": { \"input.yul\": { \"content\": \"{ sstore(0, 1) }\" } },\n \"settings\": {\n \"outputSelection\": { \"*\": { \"*\": [\"*\"], \"\": [ \"*\" ] } },\n \"optimizer\": { \"enabled\": true, \"details\": { \"yul\": true } }\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Overflow Prevention in Solidity using require\nDESCRIPTION: This Solidity contract demonstrates how to prevent overflows by adding `require` statements. By checking if the input values `x` and `y` are less than the maximum value of `uint128`, it ensures that the addition will not result in an overflow, and the SMTChecker will not report any warnings.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Overflow {\n    uint immutable x;\n    uint immutable y;\n\n    function add(uint x_, uint y_) internal pure returns (uint) {\n        return x_ + y_;\n    }\n\n    constructor(uint x_, uint y_) {\n        (x, y) = (x_, y_);\n    }\n\n    function stateAdd() public view returns (uint) {\n        require(x < type(uint128).max);\n        require(y < type(uint128).max);\n        return add(x, y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Catch Panic from External Call - Solidity\nDESCRIPTION: Introduces the ability to use ``catch Panic(uint code)`` to catch a panic failure from an external call. This feature enhances error handling capabilities when interacting with external contracts by allowing specific handling of panic errors.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\ncatch Panic(uint code)\n```\n\n----------------------------------------\n\nTITLE: Solidity Constructor Execution Order in Inheritance\nDESCRIPTION: This code demonstrates how constructor execution order is determined by inheritance linearization in Solidity. It shows that constructors are executed in the linearized order, regardless of the order they are called in the inheriting contract's constructor. The example includes three derived contracts (Derived1, Derived2, Derived3) inheriting from Base1 and Base2, showcasing different constructor call orders but consistent execution based on inheritance order.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base1 {\n    constructor() {}\n}\n\ncontract Base2 {\n    constructor() {}\n}\n\n// Constructors are executed in the following order:\n//  1 - Base1\n//  2 - Base2\n//  3 - Derived1\ncontract Derived1 is Base1, Base2 {\n    constructor() Base1() Base2() {}\n}\n\n// Constructors are executed in the following order:\n//  1 - Base2\n//  2 - Base1\n//  3 - Derived2\ncontract Derived2 is Base2, Base1 {\n    constructor() Base2() Base1() {}\n}\n\n// Constructors are still executed in the following order:\n//  1 - Base2\n//  2 - Base1\n//  3 - Derived3\ncontract Derived3 is Base2, Base1 {\n    constructor() Base1() Base2() {}\n}\n```\n\n----------------------------------------\n\nTITLE: ABI Encoding of Root Dynamic Arrays\nDESCRIPTION: This snippet illustrates the encoding structure of root dynamic arrays in Ethereum's ABI. It shows how arrays like ``[[1, 2], [3]]`` and ``[\"one\", \"two\", \"three\"]`` are encoded, including offsets and counts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_3\n\nLANGUAGE: none\nCODE:\n```\n0x2289b18c                                                            - function signature\n 0 - f                                                                - offset of [[1, 2], [3]]\n 1 - g                                                                - offset of [\"one\", \"two\", \"three\"]\n 2 - 0000000000000000000000000000000000000000000000000000000000000002 - count for [[1, 2], [3]]\n 3 - 0000000000000000000000000000000000000000000000000000000000000040 - offset of [1, 2]\n 4 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset of [3]\n 5 - 0000000000000000000000000000000000000000000000000000000000000002 - count for [1, 2]\n 6 - 0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1\n 7 - 0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2\n 8 - 0000000000000000000000000000000000000000000000000000000000000001 - count for [3]\n 9 - 0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3\n10 - 0000000000000000000000000000000000000000000000000000000000000003 - count for [\"one\", \"two\", \"three\"]\n11 - 0000000000000000000000000000000000000000000000000000000000000060 - offset for \"one\"\n12 - 00000000000000000000000000000000000000000000000000000000000000a0 - offset for \"two\"\n13 - 00000000000000000000000000000000000000000000000000000000000000e0 - offset for \"three\"\n14 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \"one\"\n15 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of \"one\"\n16 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \"two\"\n17 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of \"two\"\n18 - 0000000000000000000000000000000000000000000000000000000000000005 - count for \"three\"\n19 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of \"three\"\n```\n\n----------------------------------------\n\nTITLE: Memory-Safe Assembly Block Annotation\nDESCRIPTION: This Solidity assembly block is annotated as \"memory-safe\", indicating that it respects Solidity's memory model.  This allows the compiler to perform optimizations. The block may access memory allocated by the user, memory allocated by Solidity, the scratch space, and temporary memory after the free memory pointer.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\nassembly (\"memory-safe\") {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Triggering an Event in Solidity\nDESCRIPTION: This code snippet demonstrates how to define and trigger an event in Solidity. The `HighestBidIncreased` event is defined with parameters `bidder` (address) and `amount` (uint).  The event is triggered within the `bid` function using `emit HighestBidIncreased(msg.sender, msg.value)`.  The `pragma solidity` version is also specified.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nevent HighestBidIncreased(address bidder, uint amount); // Event\n\ncontract SimpleAuction {\n    function bid() public payable {\n        // ...\n        emit HighestBidIncreased(msg.sender, msg.value); // Triggering event\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Import with Base Path\nDESCRIPTION: This example demonstrates how a base path affects Solidity import resolution when remapping is involved. The base path provides the initial location to search for the imported file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_16\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"util.sol\" as util; // source unit name: util.sol\n```\n\n----------------------------------------\n\nTITLE: External Function Call with Value and Gas in Solidity\nDESCRIPTION: This example illustrates how to make an external function call to another contract and send Ether along with gas. It includes the use of the `payable` modifier on the called function. Note that explicit gas limits are generally discouraged because gas costs can change in the future.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ncontract InfoFeed {\n    function info() public payable returns (uint ret) { return 42; }\n}\n\ncontract Consumer {\n    InfoFeed feed;\n    function setFeed(InfoFeed addr) public { feed = addr; }\n    function callFeed() public { feed.info{value: 10, gas: 800}(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Storage Location Declaration in Solidity\nDESCRIPTION: Shows how to explicitly declare the data location for variables of struct, array, or mapping types, and function parameters or return variables in Solidity. Example: change `uint[] x = z` to `uint[] storage x = z`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nuint[] storage x = z\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f(uint[][] memory x)\n```\n\n----------------------------------------\n\nTITLE: Solidity Sharer Contract Using Assert and Require\nDESCRIPTION: This Solidity contract demonstrates the use of `require` to validate input conditions and `assert` to check internal state. It shows how exceptions are handled during Ether transfers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Sharer {\n    function sendHalf(address payable addr) public payable returns (uint balance) {\n        require(msg.value % 2 == 0, \"Even value required.\");\n        uint balanceBeforeTransfer = address(this).balance;\n        addr.transfer(msg.value / 2);\n        // Since transfer throws an exception on failure and\n        // cannot call back here, there should be no way for us to\n        // still have half of the Ether.\n        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);\n        return address(this).balance;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract with Inline Assembly\nDESCRIPTION: This Solidity contract demonstrates the difference in return values between the old and new code generators when using inline assembly. The function `f` takes a uint8, performs a bitwise NOT operation, assigns the result to an assembly variable r1, and then assigns the same value to a Solidity variable r2.  The difference arises because the old code generator doesn't clean up after the bitwise NOT operation, while the new one does.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\ncontract C {\n    function f(uint8 a) public pure returns (uint r1, uint r2)\n    {\n        a = ~a;\n        assembly {\n            r1 := a\n        }\n        r2 = a;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Scoping Example in Solidity\nDESCRIPTION: This Solidity code shows an example that will not compile because of incorrect scoping.  Prior to Solidity 0.5.0, the code would have compiled, but the current scoping rules disallow using a variable before it's declared within a function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n// This will not compile\ncontract C {\n    function f() pure public returns (uint) {\n        x = 2;\n        uint x;\n        return x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Function Pointer Properties in Solidity with Inline Assembly\nDESCRIPTION: This Solidity contract demonstrates how to create a function pointer and assign its address and selector using inline assembly. The `combineToFunctionPointer` function takes a new address and selector as input and assigns them to the function pointer's respective properties within the assembly block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.10 <0.9.0;\n\ncontract C {\n    // Assigns a new selector and address to the return variable @fun\n    function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {\n        assembly {\n            fun.selector := newSelector\n            fun.address  := newAddress\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Timed Transitions Modifier in Solidity\nDESCRIPTION: This modifier enforces timed transitions between different stages of a smart contract. It checks the current stage and block timestamp, transitioning to the next stage if the time condition is met. The modifier's placement is crucial as it ensures the guards take the new stage into account.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nmodifier timedTransitions() {\n            if (stage == Stages.AcceptingBlindedBids &&\n                        block.timestamp >= creationTime + 10 days)\n                nextStage();\n            if (stage == Stages.RevealBids &&\n                    block.timestamp >= creationTime + 12 days)\n                nextStage();\n            // The other stages transition by transaction\n            _;\n        }\n```\n\n----------------------------------------\n\nTITLE: Solidity Metadata JSON Example\nDESCRIPTION: This example shows the structure of a Solidity contract's metadata JSON file. It includes details about the compiler, source code language, contract output (ABI, NatSpec), compiler settings, and source files. The metadata can be used for contract interaction and verification.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/metadata.rst#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // Required: Details about the compiler, contents are specific\n  // to the language.\n  \"compiler\": {\n    // Optional: Hash of the compiler binary which produced this output\n    \"keccak256\": \"0x123...\",\n    // Required for Solidity: Version of the compiler\n    \"version\": \"0.8.2+commit.661d1103\"\n  },\n  // Required: Source code language, basically selects a \"sub-version\"\n  // of the specification\n  \"language\": \"Solidity\",\n  // Required: Generated information about the contract.\n  \"output\": {\n    // Required: ABI definition of the contract. See \"Contract ABI Specification\"\n    \"abi\": [/* ... */],\n    // Required: NatSpec developer documentation of the contract. See https://docs.soliditylang.org/en/latest/natspec-format.html for details.\n    \"devdoc\": {\n      // Contents of the @author NatSpec field of the contract\n      \"author\": \"John Doe\",\n      // Contents of the @dev NatSpec field of the contract\n      \"details\": \"Interface of the ERC20 standard as defined in the EIP. See https://eips.ethereum.org/EIPS/eip-20 for details\",\n      \"errors\": {\n        \"MintToZeroAddress()\" : {\n          \"details\": \"Cannot mint to zero address\"\n        }\n      },\n      \"events\": {\n        \"Transfer(address,address,uint256)\": {\n          \"details\": \"Emitted when `value` tokens are moved from one account (`from`) toanother (`to`).\",\n          \"params\": {\n            \"from\": \"The sender address\",\n            \"to\": \"The receiver address\",\n            \"value\": \"The token amount\"\n          }\n        }\n      },\n      \"kind\": \"dev\",\n      \"methods\": {\n        \"transfer(address,uint256)\": {\n          // Contents of the @dev NatSpec field of the method\n          \"details\": \"Returns a boolean value indicating whether the operation succeeded. Must be called by the token holder address\",\n          // Contents of the @param NatSpec fields of the method\n          \"params\": {\n            \"_value\": \"The amount tokens to be transferred\",\n            \"_to\": \"The receiver address\"\n          },\n          // Contents of the @return NatSpec field.\n          \"returns\": {\n            // Return var name (here \"success\") if exists. \"_0\" as key if return var is unnamed\n            \"success\": \"a boolean value indicating whether the operation succeeded\"\n          }\n        }\n      },\n      \"stateVariables\": {\n        \"owner\": {\n          // Contents of the @dev NatSpec field of the state variable\n          \"details\": \"Must be set during contract creation. Can then only be changed by the owner\"\n        }\n      },\n      // Contents of the @title NatSpec field of the contract\n      \"title\": \"MyERC20: an example ERC20\",\n      \"version\": 1 // NatSpec version\n    },\n    // Required: NatSpec user documentation of the contract. See \"NatSpec Format\"\n    \"userdoc\": {\n      \"errors\": {\n        \"ApprovalCallerNotOwnerNorApproved()\": [\n          {\n            \"notice\": \"The caller must own the token or be an approved operator.\"\n          }\n        ]\n      },\n      \"events\": {\n        \"Transfer(address,address,uint256)\": {\n          \"notice\": \"`_value` tokens have been moved from `from` to `to`\"\n        }\n      },\n      \"kind\": \"user\",\n      \"methods\": {\n        \"transfer(address,uint256)\": {\n          \"notice\": \"Transfers `_value` tokens to address `_to`\"\n        }\n      },\n      \"version\": 1 // NatSpec version\n    }\n  },\n  // Required: Compiler settings.\n  // Reflects the settings in the JSON input during compilation, except:\n  // - Different format: \"libraries\" field\n  // - Added field in metadata.settings: \"compilationTarget\"\n  // - Not in metadata.settings: \"stopAfter\", \"debug.debugInfo\", \"outputSelection\"\n  // See the standard JSON input's \"settings\" field docs for the rest.\n  \"settings\": {\n    // Required for Solidity: File path and the name of the contract or library this\n    // metadata is created for. This field is not present in the standard JSON input settings.\n    \"compilationTarget\": {\n      \"myDirectory/myFile.sol\": \"MyContract\"\n    },\n    // Required for Solidity: Addresses for libraries used.\n    // Note that metadata has a different format for \"libraries\" field than the standard JSON input.\n    // metadata format = { \"MyLib.sol:MyLib\": \"0x123123...\" }\n    // standard JSON input format = { \"MyLib.sol\": { \"MyLib\": \"0x123123...\" } }\n    \"libraries\": {\n      \"MyLib.sol:MyLib\": \"0x123123...\"\n    },\n    // ...\n    // ...\n    // ...\n    // The rest of the fields and their defaults same as in std JSON input.\n  },\n  // Required: Compilation source files/source units, keys are file paths\n  \"sources\": {\n    \"settable\": {\n      // Required (unless \"url\" is used): literal contents of the source file\n      \"content\": \"contract settable is owned { uint256 private x = 0; function set(uint256 _x) public { if (msg.sender == owner) x = _x; } }\",\n      // Required: keccak256 hash of the source file\n      \"keccak256\": \"0x234...\"\n    },\n    \"myDirectory/myFile.sol\": {\n      // Required: keccak256 hash of the source file\n      \"keccak256\": \"0x123...\",\n      // Optional: SPDX license identifier as given in the source file\n      \"license\": \"MIT\",\n      // Required (unless \"content\" is used, see above): Sorted URL(s)\n      // to the source file, protocol is more or less arbitrary, but an\n      // IPFS URL is recommended\n      \"urls\": [ \"bzz-raw://7d7a...\", \"dweb:/ipfs/QmN...\" ]\n    }\n  },\n  // Required: The version of the metadata format\n  \"version\": 1\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Function Call Example in Solidity\nDESCRIPTION: This example demonstrates an internal function call within a Solidity contract. The function `f` calls `g`, and `g` calls `f` recursively. Internal function calls are translated into simple jumps inside the EVM, making them efficient for passing memory references.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n// This will report a warning\ncontract C {\n    function g(uint a) public pure returns (uint ret) { return a + f(); }\n    function f() internal pure returns (uint ret) { return g(7) + f(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting If-Else Blocks - Solidity\nDESCRIPTION: Illustrates the recommended style for `if`-`else` and `if`-`else if` blocks in Solidity. The `else` or `else if` keywords should be placed on the same line as the closing brace of the preceding `if` block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_12\n\nLANGUAGE: solidity\nCODE:\n```\nif (x < 3) {\n    x += 1;\n} else if (x > 7) {\n    x -= 1;\n} else {\n    x = 5;\n}\n\n\nif (x < 3)\n    x += 1;\nelse\n    x -= 1;\n```\n\n----------------------------------------\n\nTITLE: Temporary Dangling References in Tuple Assignments in Solidity\nDESCRIPTION: This Solidity code demonstrates temporary dangling references that can occur in tuple assignments when complex expressions are used.  It shows that modifying a storage array within a tuple assignment can lead to unexpected behavior when the left-hand side of the assignment relies on the initial state of that array.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ncontract C {\n    uint[] s;\n    uint[] t;\n    constructor() {\n        // Push some initial values to the storage arrays.\n        s.push(0x07);\n        t.push(0x03);\n    }\n\n    function g() internal returns (uint[] storage) {\n        s.pop();\n        return t;\n    }\n\n    function f() public returns (uint[] memory) {\n        // The following will first evaluate ``s.push()`` to a reference to a new element\n        // at index 1. Afterwards, the call to ``g`` pops this new element, resulting in\n        // the left-most tuple element to become a dangling reference. The assignment still\n        // takes place and will write outside the data area of ``s``.\n        (s.push(), g()[0]) = (0x42, 0x17);\n        // A subsequent push to ``s`` will reveal the value written by the previous\n        // statement, i.e. the last element of ``s`` at the end of this function will have\n        // the value ``0x42``.\n        s.push();\n        return s;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Assign Eliminator Example in Yul\nDESCRIPTION: Illustrates how the UnusedAssignEliminator removes unnecessary assignments in Yul code. The SSA transform often generates assignments of the form `a := a_i` which might be redundant.  The UnusedAssignEliminator identifies and removes these assignments, simplifying the code and improving efficiency.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_13\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a := 1\n        a := mload(a)\n        a := sload(a)\n        sstore(a, 1)\n    }\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a_1 := 1\n        let a := a_1\n        let a_2 := mload(a_1)\n        a := a_2\n        let a_3 := sload(a_2)\n        a := a_3\n        sstore(a_3, 1)\n    }\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a_1 := 1\n        let a_2 := mload(a_1)\n        let a_3 := sload(a_2)\n        sstore(a_3, 1)\n    }\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Example for Storage Layout\nDESCRIPTION: This example shows a Solidity contract with various data types, including structs, mappings, arrays, strings, and bytes. It is used to illustrate the storage layout in Solidity and how different data types are stored in contract storage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\n\ncontract C {\n    struct S { uint16 a; uint16 b; uint256 c; }\n    uint x;\n    mapping(uint => mapping(uint => S)) data;\n}\n```\n\n----------------------------------------\n\nTITLE: Inheriting and Using Modifiers in Solidity\nDESCRIPTION: This code shows how to inherit and use modifiers in Solidity. The `Register` contract inherits the `priced` and `owned` contracts, using the `costs` modifier for the `register` function and the `onlyOwner` modifier for the `changePrice` function.  It also demonstrates the importance of including the `payable` keyword to allow a function to receive Ether.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/function-modifiers.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\ncontract Register is priced, owned {\n    mapping(address => bool) registeredAddresses;\n    uint price;\n\n    constructor(uint initialPrice) { price = initialPrice; }\n\n    // It is important to also provide the\n    // `payable` keyword here, otherwise the function will\n    // automatically reject all Ether sent to it.\n    function register() public payable costs(price) {\n        registeredAddresses[msg.sender] = true;\n    }\n\n    // This contract inherits the `onlyOwner` modifier from\n    // the `owned` contract. As a result, calls to `changePrice` will\n    // only take effect if they are made by the stored owner.\n    function changePrice(uint price_) public onlyOwner {\n        price = price_;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: JSON ABI Representation of Solidity Contract with Tuple Types\nDESCRIPTION: This JSON represents the ABI of the `Test` contract defined in the previous snippet, which includes tuple types. It specifically shows how the input parameters of function `f` are represented, including the nested structure of the `S` struct with its tuple components. This demonstrates the ABI structure for handling complex types.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\n      {\n        \"name\": \"f\",\n        \"type\": \"function\",\n        \"inputs\": [\n          {\n            \"name\": \"s\",\n            \"type\": \"tuple\",\n            \"components\": [\n              {\n                \"name\": \"a\",\n                \"type\": \"uint256\"\n              },\n              {\n                \"name\": \"b\",\n                \"type\": \"uint256[]\"\n              },\n              {\n                \"name\": \"c\",\n                \"type\": \"tuple[]\",\n                \"components\": [\n                  {\n                    \"name\": \"x\",\n                    \"type\": \"uint256\"\n                  },\n                  {\n                    \"name\": \"y\",\n                    \"type\": \"uint256\"\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            \"name\": \"t\",\n            \"type\": \"tuple\",\n            \"components\": [\n              {\n                \"name\": \"x\",\n                \"type\": \"uint256\"\n              },\n              {\n                \"name\": \"y\",\n                \"type\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"a\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"outputs\": []\n      }\n    ]\n```\n\n----------------------------------------\n\nTITLE: Using For with File-Level Functions in Solidity\nDESCRIPTION: This code demonstrates the usage of the `using for` directive with file-level functions to attach functions to a user-defined struct `Data`. The `insert`, `remove`, and `contains` functions are attached to the `Data` struct, allowing them to be called as member functions. The example also shows how to import and use the `using` directive from another module.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/using-for.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.13;\n\nstruct Data { mapping(uint => bool) flags; }\n// Now we attach functions to the type.\n// The attached functions can be used throughout the rest of the module.\n// If you import the module, you have to\n// repeat the using directive there, for example as\n//   import \"flags.sol\" as Flags;\n//   using {Flags.insert, Flags.remove, Flags.contains}\n//     for Flags.Data;\nusing {insert, remove, contains} for Data;\n\nfunction insert(Data storage self, uint value)\n    returns (bool)\n{\n    if (self.flags[value])\n        return false; // already there\n    self.flags[value] = true;\n    return true;\n}\n\nfunction remove(Data storage self, uint value)\n    returns (bool)\n{\n    if (!self.flags[value])\n        return false; // not there\n    self.flags[value] = false;\n    return true;\n}\n\nfunction contains(Data storage self, uint value)\n    view\n    returns (bool)\n{\n    return self.flags[value];\n}\n\n\ncontract C {\n    Data knownValues;\n\n    function register(uint value) public {\n        // Here, all variables of type Data have\n        // corresponding member functions.\n        // The following function call is identical to\n        // `Set.insert(knownValues, value)`\n        require(knownValues.insert(value));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory-Unsafe Assembly: Direct Memory Assignment\nDESCRIPTION: This example shows memory unsafety because the assembly code directly assigns a memory location (0x40) to a Solidity `bytes` variable `x`, bypassing Solidity's memory management. Then, it attempts to access a memory location using `x[0x20] = 0x42;`, which is outside the managed memory space and potentially causes a conflict.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\nbytes memory x;\nassembly {\n  x := 0x40\n}\nx[0x20] = 0x42;\n```\n\n----------------------------------------\n\nTITLE: Simple Storage Contract in Solidity\nDESCRIPTION: This contract demonstrates a simple storage mechanism. It defines a state variable `storedData` and provides functions to set and retrieve its value. The contract is written in Solidity and uses version 0.4.16 or higher but less than 0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract SimpleStorage {\n    uint storedData;\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Type Conversion in Solidity\nDESCRIPTION: Demonstrates implicit type conversion in Solidity, where a `uint8` is implicitly converted to a `uint16` before addition, and then the `uint16` result is implicitly converted to a `uint32` for assignment.  This happens automatically because no information is lost during these conversions. The example highlights how the compiler manages type compatibility during arithmetic operations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\nuint8 y;\nuint16 z;\nuint32 x = y + z;\n```\n\n----------------------------------------\n\nTITLE: Configuring Model Checker in Solidity\nDESCRIPTION: This snippet demonstrates how to configure the model checker for Solidity contracts.  It showcases configurations for contracts to be analyzed, division/modulo operation encoding, engine selection, external call handling, invariant reporting, and output options.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_11\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"modelChecker\":\n  {\n    \"contracts\":\n    {\n      \"source1.sol\": [\"contract1\"],\n      \"source2.sol\": [\"contract2\", \"contract3\"]\n    },\n    \"divModNoSlacks\": false,\n    \"engine\": \"chc\",\n    \"extCalls\": \"trusted\",\n    \"invariants\": [\"contract\", \"reentrancy\"],\n    \"showProvedSafe\": true,\n    \"showUnproved\": true,\n    \"showUnsupported\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: UnusedStoreEliminator Example Yul\nDESCRIPTION: This example shows how the UnusedStoreEliminator removes redundant sstore operations.  In this case, sstore(c, 1) and if c { sstore(c, 2) } are removed because sstore(c, 3) overwrites them.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_17\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let c := calldataload(0)\n        sstore(c, 1)\n        if c {\n            sstore(c, 2)\n        }\n        sstore(c, 3)\n    }\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let c := calldataload(0)\n        if c { }\n        sstore(c, 3)\n    }\n```\n\n----------------------------------------\n\nTITLE: Accessing Address Codehash in Solidity\nDESCRIPTION: Retrieves the codehash of the address. Returns the codehash as a `bytes32` value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.codehash (bytes32)\n```\n\n----------------------------------------\n\nTITLE: Function Declaration in Yul: Power Function\nDESCRIPTION: This Yul example defines a `power` function that calculates the power of a base number using the square-and-multiply algorithm. It utilizes a `switch` statement for conditional execution based on the exponent value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_13\n\nLANGUAGE: yul\nCODE:\n```\n{\n    function power(base, exponent) -> result {\n        switch exponent\n        case 0 { result := 1 }\n        case 1 { result := base }\n        default {\n            result := power(mul(base, base), div(exponent, 2))\n            switch mod(exponent, 2)\n                case 1 { result := mul(base, result) }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replace now with block.timestamp in Solidity\nDESCRIPTION: Replaces the deprecated global variable `now` with `block.timestamp` in Solidity code.  This change clarifies that the timestamp is a property of the block and does not change during transaction processing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nblock.timestamp\n```\n\n----------------------------------------\n\nTITLE: Solidity Receive Function Example\nDESCRIPTION: This snippet demonstrates a simple `receive` function in Solidity. This function is automatically called when Ether is sent to the contract without any calldata. It emits an event with the sender's address and the amount of Ether received. It uses Solidity version 0.6.0 or higher.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n// This contract keeps all Ether sent to it with no way\n// to get it back.\ncontract Sink {\n    event Received(address, uint);\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory-Safe Assembly: Returndata Copy with Offset\nDESCRIPTION: This assembly snippet is memory safe because it copies returndata to memory starting from the free memory pointer (`p`), which is considered a valid memory region for temporary storage. It retrieves the current free memory pointer, copies the returndata to that location, and then reverts with data from that location.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\nassembly (\"memory-safe\") {\n  let p := mload(0x40)\n  returndatacopy(p, 0, returndatasize())\n  revert(p, returndatasize())\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Contract to Address Conversion in Solidity\nDESCRIPTION: Demonstrates the necessity of explicitly converting contract types to addresses before using address members in Solidity. Example: change `c.transfer(...)` to `address(c).transfer(...)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\naddress(c).transfer(...)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\naddress(c).balance\n```\n\n----------------------------------------\n\nTITLE: Visibility Specifiers in Solidity 0.5.0\nDESCRIPTION: This snippet highlights the necessity of explicitly declaring visibility specifiers (public, external) for functions in Solidity 0.5.0. It applies to functions, fallback functions and interface functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_26\n\nLANGUAGE: Solidity\nCODE:\n```\nAdd ``public`` to every function and ``external`` to every fallback or interface function that does not specify its visibility already.\nMake your fallback functions ``external``.\n```\n\n----------------------------------------\n\nTITLE: Single and Multi-line Comments in Solidity\nDESCRIPTION: This snippet demonstrates the syntax for single-line and multi-line comments in Solidity. Single-line comments start with `//` and continue until the end of the line. Multi-line comments are enclosed within `/*` and `*/` and can span multiple lines.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\n// This is a single-line comment.\n\n/*\nThis is a\nmulti-line comment.\n*/\n```\n\n----------------------------------------\n\nTITLE: Robot Contract Definition in Solidity\nDESCRIPTION: This Solidity contract defines a `Robot` with `x` and `y` coordinates and functions to move the robot. It includes a `wall` modifier to ensure the robot stays within boundaries and an `inv` function to assert an invariant (x + y) % 2 == 0. The SMTChecker can prove this invariant holds.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\ncontract Robot {\n        int x = 0;\n        int y = 0;\n\n        modifier wall {\n            require(x > type(int128).min && x < type(int128).max);\n            require(y > type(int128).min && y < type(int128).max);\n            _;\n        }\n\n        function moveLeftUp() wall public {\n            --x;\n            ++y;\n        }\n\n        function moveLeftDown() wall public {\n            --x;\n            --y;\n        }\n\n        function moveRightUp() wall public {\n            ++x;\n            ++y;\n        }\n\n        function moveRightDown() wall public {\n            ++x;\n            --y;\n        }\n\n        function inv() public view {\n            assert((x + y) % 2 == 0);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Reaching Specific Position with Assertion\nDESCRIPTION: This Solidity function `reach_2_4` is used to trick the SMTChecker to find a path to a specific location (2, 4) by asserting that this location is unreachable. When the SMTChecker disproves the assertion, it provides a trace showing how to reach the position.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\nfunction reach_2_4() public view {\n        assert(!(x == 2 && y == 4));\n    }\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion Between Unrelated Contract Types in Solidity\nDESCRIPTION: Illustrates how to convert between unrelated contract types by first converting to `address` in Solidity.  Example: `A(address(b))`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nA(address(b))\n```\n\n----------------------------------------\n\nTITLE: Transition Next Modifier in Solidity\nDESCRIPTION: This modifier executes the function and then transitions to the next stage of the state machine. The `_` placeholder indicates where the function's code will be executed, and `nextStage()` is called afterwards to advance the stage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nmodifier transitionNext()\n        {\n            _;\n            nextStage();\n        }\n```\n\n----------------------------------------\n\nTITLE: Solidity ABI Coder Pragma v2\nDESCRIPTION: This snippet shows how to select the new ABI coder (v2) in Solidity using the `pragma abicoder v2` directive.  This allows encoding and decoding of arbitrarily nested arrays and structs.  It includes more extensive validation and safety checks and is the default coder since Solidity 0.8.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\npragma abicoder v2\n```\n\n----------------------------------------\n\nTITLE: Getting Function Selector in Solidity\nDESCRIPTION: This code snippet demonstrates how to obtain the function selector of a library function in Solidity using the `.selector` member. The function selector represents the first four bytes of the Keccak256 hash of the function signature, used for function dispatch.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/libraries.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.14 <0.9.0;\n\nlibrary L {\n    function f(uint256) external {}\n}\n\ncontract C {\n    function g() public pure returns (bytes4) {\n        return L.f.selector;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Low-Level Call in Solidity\nDESCRIPTION: Issues a low-level `CALL` with the given payload to an address. Returns a success condition and return data. Forwards all available gas, which is adjustable.  It's a member function for any `address`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.call(bytes memory) returns (bool, bytes memory)\n```\n\n----------------------------------------\n\nTITLE: Solver Selection via CLI Option\nDESCRIPTION: This snippet shows how to select SMT solvers using the command-line interface (CLI) option. This allows users to specify which solvers the model checker should use for analysis.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_17\n\nLANGUAGE: Text\nCODE:\n```\n--model-checker-solvers {all,cvc5,eld,smtlib2,z3}\n```\n\n----------------------------------------\n\nTITLE: Yul Power Function Implementation (Recursive)\nDESCRIPTION: This code snippet demonstrates how to implement a power function in Yul using recursion. It uses `switch` statements for base cases and a recursive call for the general case. It computes base raised to the exponent.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_0\n\nLANGUAGE: Yul\nCODE:\n```\n{\n function power(base, exponent) -> result\n {\n switch exponent\n case 0 { result := 1 }\n case 1 { result := base }\n default\n {\n result := power(mul(base, base), div(exponent, 2))\n switch mod(exponent, 2)\n case 1 { result := mul(base, result) }\n }\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity: String Literal Assignment\nDESCRIPTION: Shows how a string literal is interpreted in its raw byte form when assigned to a bytes32 type. It illustrates the implicit conversion of string literals to fixed-size byte arrays.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Using standard JSON interface with Docker\nDESCRIPTION: This snippet shows how to use the standard JSON interface with the Solidity compiler running in a Docker container. It takes input from `input.json` and writes the output to `output.json` without mounting directories, given that the JSON input is self-contained.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run ethereum/solc:stable --standard-json < input.json > output.json\n```\n\n----------------------------------------\n\nTITLE: Solidity: Unicode String Literal\nDESCRIPTION: Demonstrates the use of unicode string literals, which can contain any valid UTF-8 sequence. The example shows how to define a unicode string literal using the 'unicode' keyword.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\nstring memory a = unicode\"Hello \";\n```\n\n----------------------------------------\n\nTITLE: Setting EVM Version Using solc\nDESCRIPTION: This code snippet shows how to specify the Ethereum Virtual Machine (EVM) version for compilation using the `solc` commandline compiler. The `<VERSION>` placeholder should be replaced with a valid EVM version such as `berlin` or `london`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsolc --evm-version <VERSION> contract.sol\n```\n\n----------------------------------------\n\nTITLE: Solidity Function Overloading Example\nDESCRIPTION: This code demonstrates function overloading in Solidity. The `A` contract defines two functions named `f` with different parameter lists: one takes a `uint`, and the other takes a `uint` and a `bool`. The compiler will choose the correct function based on the arguments provided during the call. It uses Solidity version 0.4.16 or higher.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract A {\n    function f(uint value) public pure returns (uint out) {\n        out = value;\n    }\n\n    function f(uint value, bool really) public pure returns (uint out) {\n        if (really)\n            out = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Low-Level Staticcall in Solidity\nDESCRIPTION: Issues a low-level `STATICCALL` with the given payload. It returns a success condition and return data. Forwards all available gas, which is adjustable.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\n<address>.staticcall(bytes memory) returns (bool, bytes memory)\n```\n\n----------------------------------------\n\nTITLE: Configuring Metadata Settings for Solidity Compilation\nDESCRIPTION: This snippet shows how to configure metadata settings for Solidity compilation. The `appendCBOR` option controls whether the CBOR metadata is appended to the bytecode. The `useLiteralContent` option determines whether to use only literal content and not URLs. The `bytecodeHash` option specifies the hash method to use for the metadata hash.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"metadata\": {\n    \"appendCBOR\": true,\n    \"useLiteralContent\": true,\n    \"bytecodeHash\": \"ipfs\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Two-Dimensional Array Literals Solidity\nDESCRIPTION: This code demonstrates the use of two-dimensional array literals in Solidity. It highlights the need to explicitly specify the base type for the inner arrays to ensure type compatibility. The example shows creating a `uint24[2][4] memory` array.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure returns (uint24[2][4] memory) {\n        uint24[2][4] memory x = [[uint24(0x1), 1], [0xffffff, 2], [uint24(0xff), 3], [uint24(0xffff), 4]];\n        // The following does not work, because some of the inner arrays are not of the right type.\n        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];\n        return x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Allowed Paths for Solidity Compiler\nDESCRIPTION: This command-line example shows how to use the `--allow-paths` option when invoking the Solidity compiler. It allows importing files from specified directories, enhancing security by limiting file system access during compilation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n--allow-paths=../utils/,/tmp/libraries\n```\n\n----------------------------------------\n\nTITLE: Generating NatSpec Documentation\nDESCRIPTION: Shows how to use the `solc` command-line compiler to generate user and developer documentation in JSON format from a Solidity contract file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/natspec-format.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nsolc --userdoc --devdoc ex1.sol\n```\n\n----------------------------------------\n\nTITLE: For Loop in Yul: Sum of Memory Area\nDESCRIPTION: This Yul snippet demonstrates a `for` loop used to compute the sum of values in a specific area of memory. It iterates from 0 to 0x100, incrementing by 0x20 each time, and accumulating the values loaded from memory at each offset.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_11\n\nLANGUAGE: yul\nCODE:\n```\n{\n    let x := 0\n    for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {\n        x := add(x, mload(i))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Modifier in Solidity\nDESCRIPTION: This code snippet defines a function modifier called `onlySeller` in Solidity. It checks if the message sender is the seller. If not, it reverts the transaction with an error message.  The modifier is used to restrict access to the `abort` function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Purchase {\n    address public seller;\n\n    modifier onlySeller() { // Modifier\n        require(\n            msg.sender == seller,\n            \"Only seller can call this.\"\n        );\n        _;\n    }\n\n    function abort() public view onlySeller { // Modifier usage\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ERC20 Token Interface in Solidity\nDESCRIPTION: This snippet defines the interface for a standard ERC20 token. It includes functions for checking allowances, approving transfers, retrieving balances, determining decimals, and managing total supply. It also features methods for increasing/decreasing allowances, transferring tokens, and initiating transfers from one address to another.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20                           allowance(address,address)\nERC20                           approve(address,uint256)\nERC20                           balanceOf(address)\nERC20                           decimals()\nERC20                           decreaseAllowance(address,uint256)\nERC20                           increaseAllowance(address,uint256)\nERC20                           name()\nERC20                           symbol()\nERC20                           totalSupply()\nERC20                           transfer(address,uint256)\nERC20                           transferFrom(address,address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Encode Packed Arguments with keccak256 in Solidity\nDESCRIPTION: Shows how to change `keccak256(a, b, c)` to `keccak256(abi.encodePacked(a, b, c))` in Solidity. This enforces explicit packing of arguments for hashing functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nkeccak256(abi.encodePacked(a, b, c))\n```\n\n----------------------------------------\n\nTITLE: Transferring Ether to an Address in Solidity\nDESCRIPTION: Sends a specified amount of Wei to an address. It reverts on failure and forwards a fixed gas stipend of 2300 gas.  It's an `address payable` member function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\n<address payable>.transfer(uint256 amount)\n```\n\n----------------------------------------\n\nTITLE: Binding Library Functions to Types\nDESCRIPTION: This snippet demonstrates how to bind library functions to types using the `using` keyword.  This allows you to call library functions as if they were methods of the type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_40\n\nLANGUAGE: Solidity\nCODE:\n```\nusing x for y\n```\n\n----------------------------------------\n\nTITLE: Pseudo-SSA Transformation Example in Yul\nDESCRIPTION: Illustrates the pseudo-SSA transformation process. This transformation introduces new variables to represent reassignments, creating a static single assignment-like form, but avoids explicit phi functions. It shows how a Yul code snippet is transformed by introducing numbered variables to track value changes within the control flow.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_10\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a := calldataload(0)\n        let b := calldataload(0x20)\n        if gt(a, 0) {\n            b := mul(b, 0x20)\n        }\n        a := add(a, 1)\n        sstore(a, add(b, 0x20))\n    }\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let _1 := 0\n        let a_9 := calldataload(_1)\n        let a := a_9\n        let _2 := 0x20\n        let b_10 := calldataload(_2)\n        let b := b_10\n        let _3 := 0\n        let _4 := gt(a_9, _3)\n        if _4\n        {\n            let _5 := 0x20\n            let b_11 := mul(b_10, _5)\n            b := b_11\n        }\n        let b_12 := b\n        let _6 := 1\n        let a_13 := add(a_9, _6)\n        let _7 := 0x20\n        let _8 := add(b_12, _7)\n        sstore(a_13, _8)\n    }\n```\n\n----------------------------------------\n\nTITLE: Solidity Import Example\nDESCRIPTION: This code snippet demonstrates how to import other Solidity files using relative paths. The example shows how to import a file located in a subdirectory and a file located in a parent directory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"./math/math.sol\";\nimport \"contracts/tokens/token.sol\";\n```\n\n----------------------------------------\n\nTITLE: Solidity Compiler Input JSON Example\nDESCRIPTION: This JSON object provides a sample input structure for the Solidity compiler.  It defines the language, source files, and compiler settings including optimizer configuration, remappings, and stopAfter setting. The source files can either contain the literal content or URLs for import.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  // Required: Source code language. Currently supported are \"Solidity\", \"Yul\", \"SolidityAST\" (experimental), \"EVMAssembly\" (experimental).\n  \"language\": \"Solidity\",\n  // Required\n  \"sources\":\n  {\n    // The keys here are the \"global\" names of the source files,\n    // imports can use other files via remappings (see below).\n    \"myFile.sol\":\n    {\n      // Optional: keccak256 hash of the source file\n      // It is used to verify the retrieved content if imported via URLs.\n      \"keccak256\": \"0x123...\",\n      // Required (unless \"content\" is used, see below): URL(s) to the source file.\n      // URL(s) should be imported in this order and the result checked against the\n      // keccak256 hash (if available). If the hash doesn't match or none of the\n      // URL(s) result in success, an error should be raised.\n      // Using the commandline interface only filesystem paths are supported.\n      // With the JavaScript interface the URL will be passed to the user-supplied\n      // read callback, so any URL supported by the callback can be used.\n      \"urls\":\n      [\n        \"bzzr://56ab...\",\n        \"ipfs://Qma...\",\n        \"/tmp/path/to/file.sol\"\n        // If files are used, their directories should be added to the command-line via\n        // `--allow-paths <path>`.\n      ]\n    },\n    \"settable\":\n    {\n      // Optional: keccak256 hash of the source file\n      \"keccak256\": \"0x234...\",\n      // Required (unless \"urls\" is used): literal contents of the source file\n      \"content\": \"contract settable is owned { uint256 private x = 0; function set(uint256 _x) public { if (msg.sender == owner) x = _x; } }\"\n    },\n    \"myFile.sol_json.ast\":\n    {\n      // If language is set to \"SolidityAST\", an AST needs to be supplied under the \"ast\" key\n      // and there can be only one source file present.\n      // The format is the same as used by the `ast` output.\n      // Note that importing ASTs is experimental and in particular that:\n      // - importing invalid ASTs can produce undefined results and\n      // - no proper error reporting is available on invalid ASTs.\n      // Furthermore, note that the AST import only consumes the fields of the AST as\n      // produced by the compiler in \"stopAfter\": \"parsing\" mode and then re-performs\n      // analysis, so any analysis-based annotations of the AST are ignored upon import.\n      \"ast\": { ... }\n    },\n    \"myFile_evm.json\":\n    {\n      // If language is set to \"EVMAssembly\", an EVM Assembly JSON object needs to be supplied\n      // under the \"assemblyJson\" key and there can be only one source file present.\n      // The format is the same as used by the `evm.legacyAssembly` output or `--asm-json`\n      // output on the command line.\n      // Note that importing EVM assembly is experimental.\n      \"assemblyJson\":\n      {\n        \".code\": [ ... ],\n        \".data\": { ... }, // optional\n        \"sourceList\": [ ... ] // optional (if no `source` node was defined in any `.code` object)\n      }\n    }\n  },\n  // Optional\n  \"settings\":\n  {\n    // Optional: Stop compilation after the given stage. Currently only \"parsing\" is valid here\n    \"stopAfter\": \"parsing\",\n    // Optional: List of remappings\n    \"remappings\": [ \":g=/dir\" ],\n    // Optional: Optimizer settings\n    \"optimizer\": {\n      // Turn on the optimizer. Optional. Default: false.\n      // NOTE: The state of the optimizer is fully determined by the 'details' dict and this setting\n      // only affects its defaults - when enabled, all components default to being enabled.\n      // The opposite is not true - there are several components that always default to being\n      // enabled an can only be explicitly disabled via 'details'.\n      // WARNING: Before version 0.8.6 omitting this setting was not equivalent to setting\n      // it to false and would result in all components being disabled instead.\n      // WARNING: Enabling optimizations for EVMAssembly input is allowed but not necessary under normal\n      // circumstances. It forces the opcode-based optimizer to run again and can produce bytecode that\n      // is not reproducible from metadata.\n      \"enabled\": true,\n      // Optimize for how many times you intend to run the code. Optional. Default: 200.\n      // Lower values will optimize more for initial deployment cost, higher\n      // values will optimize more for high-frequency usage.\n      \"runs\": 200,\n      // State of all optimizer components. Optional.\n      // Default values are determined by whether the optimizer is enabled or not.\n      // Note that the 'enabled' setting only affects the defaults here and has no effect when\n      // all values are provided explicitly.\n      \"details\": {\n        // Peephole optimizer (opcode-based). Optional. Default: true.\n        // Default for EVMAssembly input: false when optimization is not enabled.\n        // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here.\n        \"peephole\": true,\n        // Inliner (opcode-based). Optional. Default: true when optimization is enabled.\n        \"inliner\": false,\n        // Unused JUMPDEST remover (opcode-based). Optional. Default: true.\n        // Default for EVMAssembly input: false when optimization is not enabled.\n        // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here.\n        \"jumpdestRemover\": true,\n        // Literal reordering (codegen-based). Optional. Default: true when optimization is enabled.\n        // Moves literals to the right of commutative binary operators during code generation, helping exploit associativity.\n        \"orderLiterals\": false,\n        // Block deduplicator (opcode-based). Optional. Default: true when optimization is enabled.\n        // Unifies assembly code blocks that share content.\n        \"deduplicate\": false,\n        // Common subexpression elimination (opcode-based). Optional. Default: true when optimization is enabled.\n        // This is the most complicated step but can also provide the largest gain.\n        \"cse\": false,\n        // Constant optimizer (opcode-based). Optional. Default: true when optimization is enabled.\n        // Tries to find better representations of literal numbers and strings, that satisfy the\n        // size/cost trade-off determined by the 'runs' setting.\n        \"constantOptimizer\": false,\n        // Unchecked loop increment (codegen-based). Optional. Default: true.\n        // Use unchecked arithmetic when incrementing the counter of 'for' loops under certain circumstances.\n        // NOTE: Always runs (even with optimization disabled) unless explicitly turned off here.\n        \"simpleCounterForLoopUncheckedIncrement\": true,\n        // Yul optimizer. Optional. Default: true when optimization is enabled.\n        // Used to optimize the IR produced by the Yul IR-based pipeline as well as inline assembly\n        // and utility Yul code generated by the compiler.\n        // NOTE: Before Solidity 0.6.0 the default was false.\n        \"yul\": false,\n        // Tuning options for the Yul optimizer. Optional.\n        \"yulDetails\": {\n\n```\n\n----------------------------------------\n\nTITLE: Assertion Verification in Solidity\nDESCRIPTION: This Solidity contract demonstrates how to use assertions to verify that a function `f` is monotonically increasing. The `inv` function checks if for every pair `(a, b)` such that `b > a`, then `f(b) > f(a)`. The SMTChecker proves that the property is correct, confirming the function's monotonic behavior.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Monotonic {\n    function f(uint x) internal pure returns (uint) {\n        require(x < type(uint128).max);\n        return x * 42;\n    }\n\n    function inv(uint a, uint b) public pure {\n        require(b > a);\n        assert(f(b) > f(a));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing known Solidity compiler bugs in JSON format\nDESCRIPTION: This snippet includes a JSON formatted list of known security relevant bugs in the Solidity compiler. The JSON file contains an array of objects, one for each bug, with fields such as uid, name, summary, description, link, introduced, fixed, publish, severity, conditions, and check. The file is hosted in the GitHub repository.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/bugs.rst#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n{ // This is a placeholder, the actual JSON content is in bugs.json\n  \"uid\": \"SOL-2016-1\",\n  \"name\": \"Integer Overflow\",\n  \"summary\": \"Integer overflow in some arithmetic operations.\",\n  \"description\": \"Integer overflow can occur when performing arithmetic operations.\",\n  \"link\": \"https://example.com/integer_overflow\",\n  \"introduced\": \"0.3.0\",\n  \"fixed\": \"0.4.0\",\n  \"publish\": \"2016-01-01\",\n  \"severity\": \"high\",\n  \"conditions\": {\n    \"optimizer\": false,\n    \"evmVersion\": \">=constantinople\"\n  },\n  \"check\": {\n    \"source-regex\": \"assembly { add(x,y) }\",\n    \"ast-compact-json-path\": \"$.nodes[?(@.nodeType == 'BinaryOperation' && @.operator == '+')]\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Operator\nDESCRIPTION: Demonstrates the use of the conditional operator (ternary operator) in Solidity. This allows for concise conditional expressions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_37\n\nLANGUAGE: Solidity\nCODE:\n```\nx ? y : z\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries in Solidity Compilation\nDESCRIPTION: This snippet shows how to specify the addresses of libraries for Solidity compilation. The `libraries` option allows linking libraries used in the contract. The top-level key is the source file name where the library is used, and the second-level key is the library name with its corresponding address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"libraries\": {\n    \"myFile.sol\": {\n      \"MyLib\": \"0x123123...\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Salt for Contract Creations (CREATE2) - Solidity\nDESCRIPTION: Introduces the ability to specify a salt for contract creations, enabling the use of the `CREATE2` opcode. This is achieved using the syntax `new C{salt: 0x1234, value: 1 ether}(arg1, arg2)`.  The salt is combined with the contract's bytecode and the deployer's address to create a predictable address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_20\n\nLANGUAGE: Solidity\nCODE:\n```\nAllow specifying the ``salt`` for contract creations and thus the ``create2`` opcode using ``new C{salt: 0x1234, value: 1 ether}(arg1, arg2)``.\n```\n\n----------------------------------------\n\nTITLE: Fine: Function Returning Dynamic Array of Fixed-Size Arrays (Solidity)\nDESCRIPTION: Shows a correct way to define a function returning a dynamic array `uint[ 2 ] [ ]  a` of fixed-size arrays with spaces.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() public pure returns (uint[ 2 ] [ ]  a) { }\n```\n\n----------------------------------------\n\nTITLE: Using Pre-0.5.0 Library\nDESCRIPTION: This snippet shows how to use a pre-0.5.0 library in a newer Solidity contract.  The library's functions are declared without implementation, and the library's address must be provided during linking. Note the pragma statement prevents compilation with Solidity 0.6.0 and later.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_12\n\nLANGUAGE: solidity\nCODE:\n```\n// This will not compile after 0.6.0\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.5.0;\n\nlibrary OldLibrary {\n    function someFunction(uint8 a) public returns(bool);\n}\n\ncontract NewContract {\n    function f(uint8 a) public returns (bool) {\n        return OldLibrary.someFunction(a);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Function Call Evaluation\nDESCRIPTION: This snippet shows the formal evaluation function `E` for a Yul function call. It evaluates the arguments, creates a new local state with the argument values bound to the function parameters, executes the function's block, and returns the returned values from the function's local state.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_53\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <fname(arg1, ..., argn)>: FunctionCall) =\n    G1, L1, vn = E(G, L, argn)\n    ...\n    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)\n    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)\n    Let <function fname (param1, ..., paramn) -> ret1, ..., retm block>\n    be the function of name $fname visible at the point of the call.\n    Let L' be a new local state such that\n    L'[$parami] = vi and L'[$reti] = 0 for all i.\n    Let G'', L'', mode = E(Gn, L', block)\n    G'', Ln, L''[$ret1], ..., L''[$retm]\n```\n\n----------------------------------------\n\nTITLE: Inlining Example - After Inlining\nDESCRIPTION: This demonstrates the assembly after function inlining, where the call to function 'f' has been replaced with the function body. A jump instruction is now present to return from the inlined code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ntag_return\n...body of function f...\njump\ntag_return:\n...opcodes after call to f...\n\ntag_f:\n...body of function f...\njump      // out\n```\n\n----------------------------------------\n\nTITLE: Configuring SMTChecker Solvers and Targets in Solidity\nDESCRIPTION: This snippet demonstrates how to configure the SMTChecker within a Solidity project. It shows how to select specific solvers (cvc5, smtlib2, z3), define targets to check (underflow, overflow, assert), and set a timeout for SMT queries.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n          // Choose which solvers should be used, if available.\n          // See the Formal Verification section for the solvers description.\n          \"solvers\": [\"cvc5\", \"smtlib2\", \"z3\"],\n          // Choose which targets should be checked: constantCondition,\n          // underflow, overflow, divByZero, balance, assert, popEmptyArray, outOfBounds.\n          // If the option is not given all targets are checked by default,\n          // except underflow/overflow for Solidity >=0.8.7.\n          // See the Formal Verification section for the targets description.\n          \"targets\": [\"underflow\", \"overflow\", \"assert\"],\n          // Timeout for each SMT query in milliseconds.\n          // If this option is not given, the SMTChecker will use a deterministic\n          // resource limit by default.\n          // A given timeout of 0 means no resource/time restrictions for any query.\n          \"timeout\": 20000\n        }\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract with Tuple Types\nDESCRIPTION: This Solidity code defines a contract `Test` using tuple types within structs. Structs `S` and `T` are defined, and functions `f` and `g` use these structs as parameters and return values respectively. The `pragma abicoder v2;` directive is necessary to use struct types in external function calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_7\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5 <0.9.0;\npragma abicoder v2;\n\ncontract Test {\n    struct S { uint a; uint[] b; T[] c; }\n    struct T { uint x; uint y; }\n    function f(S memory, T memory, uint) public pure {}\n    function g() public pure returns (S memory, T memory, uint) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Function with timedTransitions and Stage Check in Solidity\nDESCRIPTION: This `reveal` function utilizes modifiers to enforce stage restrictions and timed transitions. The `timedTransitions` modifier is invoked before the `atStage` modifier to ensure stage transitions occur first.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction reveal()\n            public\n            timedTransitions\n            atStage(Stages.RevealBids)\n        {\n        }\n```\n\n----------------------------------------\n\nTITLE: Allocate Memory in Yul Assembly\nDESCRIPTION: This Yul assembly function allocates memory by reading the current free memory pointer, storing the new free memory pointer (incremented by the requested length), and returning the original free memory pointer as the allocated memory position. It requires the `length` argument, which specifies the amount of memory to allocate in bytes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_4\n\nLANGUAGE: yul\nCODE:\n```\nfunction allocate(length) -> pos {\n  pos := mload(0x40)\n  mstore(0x40, add(pos, length))\n}\n```\n\n----------------------------------------\n\nTITLE: Omitted Names in Function Definitions in Solidity\nDESCRIPTION: This example demonstrates the ability to omit names for parameters and return values in Solidity function definitions.  The unnamed items are still present on the stack but inaccessible by name. The 'return' statement can be used to return a value even if the return value is unnamed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract C {\n    // omitted name for parameter\n    function func(uint k, uint) public pure returns(uint) {\n        return k;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Verbatim Example\nDESCRIPTION: This code shows an example of using the `verbatim` function in Yul to embed bytecode that multiplies the input by two, while ensuring the optimizer does not modify the constant two. The function `verbatim_1i_1o` specifies one input and one output.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_60\n\nLANGUAGE: Yul\nCODE:\n```\nlet x := calldataload(0)\nlet double := verbatim_1i_1o(hex\"600202\", x)\n```\n\n----------------------------------------\n\nTITLE: Adding Payable Modifier to Functions\nDESCRIPTION: This snippet shows how to add the `payable` modifier to a function in Solidity.  This modifier is required for functions that are intended to receive Ether.  Failure to include it will cause the function to throw when Ether is sent to it.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_31\n\nLANGUAGE: Solidity\nCODE:\n```\npayable\n```\n\n----------------------------------------\n\nTITLE: State Variable Initialization Order in Inheritance (Solidity)\nDESCRIPTION: Demonstrates how the order of state variable initialization changes with the IR-based codegen, particularly in inherited contracts. The example showcases a scenario where the initial value of a state variable depends on the result of a constructor in another contract, leading to different outcomes based on the codegen method. Key functionality involves contract inheritance and state variable initialization.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1;\n\ncontract A {\n    uint x;\n    constructor() {\n        x = 42;\n    }\n    function f() public view returns(uint256) {\n        return x;\n    }\n}\ncontract B is A {\n    uint public y = f();\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Errors and Revert Statement\nDESCRIPTION: Supports custom errors via the `error` keyword and introduces the `revert` statement. This feature allows developers to define and use custom error types, providing more informative error messages when reverting transactions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\nerror\nrevert\n```\n\n----------------------------------------\n\nTITLE: Implicit Function Overriding with Common Base (Solidity)\nDESCRIPTION: This Solidity example showcases implicit function overriding when a function is defined in a common base contract.  No explicit `override` keyword is required because the inheritance path is clear and unambiguous.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract A { function f() public pure{} }\ncontract B is A {}\ncontract C is A {}\n// No explicit override required\ncontract D is B, C {}\n```\n\n----------------------------------------\n\nTITLE: Variable Typing and Multiple Variable Declaration in Yul\nDESCRIPTION: This Yul snippet demonstrates the intended syntax for declaring variables with specific types (u32, u256). It illustrates how to declare and assign multiple variables in one statement, receiving values from a function call that returns multiple values. Note that this example will not compile because u32 and u256 types are not implemented.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_7\n\nLANGUAGE: yul\nCODE:\n```\n// This will not compile (u32 and u256 type not implemented yet)\n{\n    let zero:u32 := 0:u32\n    let v:u256, t:u32 := f()\n    let x, y := g()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Pre-0.5.0 Contract with Interface\nDESCRIPTION: This snippet demonstrates how to use the interface defined above to interact with a deployed pre-0.5.0 contract. It shows how a new contract can call functions in the old contract, leveraging the interface to ensure compatibility.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_11\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ninterface OldContract {\n    function someOldFunction(uint8 a) external;\n    function anotherOldFunction() external returns (bool);\n}\n\ncontract NewContract {\n    function doSomething(OldContract a) public returns (bool) {\n        a.someOldFunction(0x42);\n        return a.anotherOldFunction();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Payment Channel Signature using EthereumJS-Util in JavaScript\nDESCRIPTION: This JavaScript code uses the `ethereumjs-util` library to verify the signature of a payment channel message.  It requires `ethereumjs` which should be installed separately. It constructs a prefixed message, recovers the signer, and compares it to the expected signer to validate the signature. The `constructPaymentMessage` function is assumed to be defined elsewhere.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// this mimics the prefixing behavior of the eth_sign JSON-RPC method.\nfunction prefixed(hash) {\n    return ethereumjs.ABI.soliditySHA3(\n        [\"string\", \"bytes32\"],\n        [\"\\x19Ethereum Signed Message:\\n32\", hash]\n    );\n}\n\nfunction recoverSigner(message, signature) {\n    var split = ethereumjs.Util.fromRpcSig(signature);\n    var publicKey = ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);\n    var signer = ethereumjs.Util.pubToAddress(publicKey).toString(\"hex\");\n    return signer;\n}\n\nfunction isValidSignature(contractAddress, amount, signature, expectedSigner) {\n    var message = prefixed(constructPaymentMessage(contractAddress, amount));\n    var signer = recoverSigner(message, signature);\n    return signer.toLowerCase() ==\n        ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();\n}\n```\n\n----------------------------------------\n\nTITLE: Introduce blobhash Function Solidity\nDESCRIPTION: This snippet introduces the global `blobhash(uint)` function in Solidity.  This function retrieves versioned hashes of blobs associated with a transaction. It's analogous to the Yul builtin `blobhash()` and is used to access data from blob transactions, a feature introduced with EIP-4844.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nIntroduce global function ``blobhash(uint)`` for retrieving versioned hashes of blobs, akin to the homonymous Yul builtin.\n```\n\n----------------------------------------\n\nTITLE: Adding Ethereum PPA for Ubuntu\nDESCRIPTION: This snippet demonstrates how to add the Ethereum PPA to an Ubuntu system and install the latest stable version of the Solidity compiler. It requires root privileges.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install solc\n```\n\n----------------------------------------\n\nTITLE: Inlining Example - Function Call Assembly\nDESCRIPTION: This example shows the typical assembly structure generated for calling an internal Solidity function, which includes tags for return and function entry points, and jump instructions to navigate between them. The Inliner optimizer step aims to replace these jumps with the function body directly.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ntag_return\ntag_f\njump      // in\ntag_return:\n  ...opcodes after call to f...\n\ntag_f:\n  ...body of function f...\n  jump      // out\n```\n\n----------------------------------------\n\nTITLE: EVM Yul Built-in: add(x, y)\nDESCRIPTION: This snippet presents the Yul built-in function `add(x, y)`. It performs addition of two values, returning the sum (`x + y`). It's available since the Frontier version of the EVM.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_58\n\nLANGUAGE: none\nCODE:\n```\nadd(x, y)               |     | F | x + y\n```\n\n----------------------------------------\n\nTITLE: Import Syntax Example\nDESCRIPTION: Demonstrates the ECMAScript6 style import syntax for importing other Solidity files.  This includes aliasing and importing specific variables from other contracts or libraries.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_36\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"abc.sol\" as d\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nimport {x, y} from \"abc.sol\"\n```\n\n----------------------------------------\n\nTITLE: Function with timedTransitions and atStage modifier in Solidity\nDESCRIPTION: This function `i` applies `timedTransitions` and `atStage` modifiers. It checks for time-based stage changes and verifies the contract is in the `Finished` stage before executing. This demonstrates the use of modifiers for complex condition checks.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction i()\n            public\n            timedTransitions\n            atStage(Stages.Finished)\n        {\n        }\n```\n\n----------------------------------------\n\nTITLE: Solidity Function Type Declaration Syntax\nDESCRIPTION: This code snippet shows the declaration syntax for function types in Solidity. It highlights the parameter types, internal/external keyword, state mutability modifiers (pure, view, payable), and return types. If the function type should not return anything, the whole `returns (<return types>)` part has to be omitted.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_16\n\nLANGUAGE: solidity\nCODE:\n```\nfunction (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]\n```\n\n----------------------------------------\n\nTITLE: SMTChecker Assertion Violation Counterexample\nDESCRIPTION: This is example output from the SMTChecker showing an assertion violation in the `reach_2_4` function. It includes the final state of `x` and `y` and the transaction trace leading to that state, demonstrating how the SMTChecker can pinpoint the exact execution path causing the assertion failure.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nWarning: CHC: Assertion violation happens here.\n    Counterexample:\n    x = 2, y = 4\n\n    Transaction trace:\n    Robot.constructor()\n    State: x = 0, y = 0\n    Robot.moveLeftUp()\n    State: x = (- 1), y = 1\n    Robot.moveRightUp()\n    State: x = 0, y = 2\n    Robot.moveRightUp()\n    State: x = 1, y = 3\n    Robot.moveRightUp()\n    State: x = 2, y = 4\n    Robot.reach_2_4()\n      --> r.sol:35:4:\n       |\n    35 |            assert(!(x == 2 && y == 4));\n       |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Updating keccak256() syntax in Solidity 0.5.0\nDESCRIPTION: This snippet demonstrates the necessary changes for using `keccak256()` function in Solidity 0.5.0. It requires explicit packing of arguments using `abi.encodePacked()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_25\n\nLANGUAGE: Solidity\nCODE:\n```\nChange every ``keccak256(a, b, c)`` to ``keccak256(abi.encodePacked(a, b, c))``.\n```\n\n----------------------------------------\n\nTITLE: Invalid Array Assignment Solidity\nDESCRIPTION: This code demonstrates an invalid assignment where a fixed-size memory array is assigned to a dynamically-sized memory array. It highlights the type error that occurs when trying to convert `uint[3] memory` to `uint[] memory`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\n// This will not compile.\ncontract C {\n    function f() public {\n        // The next line creates a type error because uint[3] memory\n        // cannot be converted to uint[] memory.\n        uint[] memory x = [uint(1), 3, 4];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Reassignment in Yul\nDESCRIPTION: This Yul example shows how to re-assign values to variables after their initial declaration using the `:=` operator. It also demonstrates how to assign multiple variables simultaneously from a function that returns multiple values.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_8\n\nLANGUAGE: yul\nCODE:\n```\nlet v := 0\n// re-assign v\nv := 2\nlet t := add(v, 2)\nfunction f() -> a, b { }\n// assign multiple values\nv, t := f()\n```\n\n----------------------------------------\n\nTITLE: Adding nightly Ethereum PPA for Ubuntu\nDESCRIPTION: This snippet demonstrates how to add the Ethereum PPA for nightly builds to an Ubuntu system and install the development version of the Solidity compiler. It requires root privileges.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo add-apt-repository ppa:ethereum/ethereum-dev\nsudo apt-get update\nsudo apt-get install solc\n```\n\n----------------------------------------\n\nTITLE: Function Overriding and Mutability Example\nDESCRIPTION: This example shows how to override functions in Solidity, including changing visibility from `external` to `public` and changing mutability to a more strict type (`view` to `pure`). Note that `payable` cannot be changed to any other mutability.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/inheritance.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base\n{\n    function foo() virtual external view {}\n}\n\ncontract Middle is Base {}\n\ncontract Inherited is Middle\n{\n    function foo() override public pure {}\n}\n```\n\n----------------------------------------\n\nTITLE: More Import Examples\nDESCRIPTION: Shows more import examples.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nsolc ./=a/ /project/=b/ /project/contract.sol # source unit name: /project/contract.sol\n```\n\n----------------------------------------\n\nTITLE: Call Function with Empty Bytes Argument in Solidity\nDESCRIPTION: Demonstrates how to change `.call()` functions with no arguments to include an empty bytes argument `.call(\"\")` in Solidity. This change makes explicit the argument concatenation within `.call()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n.call(\"\")\n```\n\n----------------------------------------\n\nTITLE: Time Units in Solidity\nDESCRIPTION: Illustrates the usage of time units (seconds, minutes, hours, days, weeks) in Solidity.  These suffixes are applied to literal numbers to specify durations. It is important to use these units carefully for calendar calculations due to the complexities of leap seconds and varying lengths of years and days.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f(uint start, uint daysAfter) public {\n    if (block.timestamp >= start + daysAfter * 1 days) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Library Functions\nDESCRIPTION: Demonstrates the use of internal library functions called via inlining. This allows for code reuse within a contract without the overhead of external function calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_33\n\nLANGUAGE: Solidity\nCODE:\n```\n// Allow internal library functions to be called (by \"inlining\")\n```\n\n----------------------------------------\n\nTITLE: Selecting Yul Optimizations via CLI\nDESCRIPTION: This command demonstrates how to specify a custom sequence of Yul optimizer steps using the `--yul-optimizations` option in the Solidity compiler. This allows fine-grained control over the optimization process.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsolc --optimize --ir-optimized --yul-optimizations 'dhfoD[xarrscLMcCTU]uljmul:fDnTOcmu'\n```\n\n----------------------------------------\n\nTITLE: MultiSend Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for sending multiple transactions in a single call. This interface allows for batching transactions, reducing gas costs and improving efficiency. The `multiSend` function takes a byte array as input, which encodes the multiple transactions to be executed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_29\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface MultiSend {\n  function multiSend(bytes calldata transactions) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapped Function Calls - Solidity\nDESCRIPTION: This snippet demonstrates the proper way to format long function calls that exceed the maximum line length in Solidity. Each argument should be on its own line with a single indent, and the closing parenthesis should be on its own line.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nthisFunctionCallIsReallyLong(\n    longArgument1,\n    longArgument2,\n    longArgument3\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Storage Layout with Inheritance and Custom Base Slot in Solidity\nDESCRIPTION: This Solidity code defines a smart contract `C` that inherits from contracts `A` and `B`, utilizing a custom storage layout specified with `layout at 42`.  The example illustrates how state variables from inherited contracts are arranged in storage, considering storage packing and custom slot offsets.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.29;\n\nstruct S {\n    int32 x;\n    bool y;\n}\n\ncontract A {\n    uint a;\n    uint128 transient b;\n    uint constant c = 10;\n    uint immutable d = 12;\n}\n\ncontract B {\n    uint8[] e;\n    mapping(uint => S) f;\n    uint16 g;\n    uint16 h;\n    bytes16 transient i;\n    S s;\n    int8 k;\n}\n\ncontract C is A, B layout at 42 {\n    bytes21 l;\n    uint8[10] m;\n    bytes5[8] n;\n    bytes5 o;\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Break Statement Example\nDESCRIPTION: This code demonstrates the usage of the `break` statement within nested for loops in Yul. The `break` statement terminates the innermost loop, allowing execution to continue with the outer loop. The example clarifies where the `break` statement can be placed within the control flow structures.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_39\n\nLANGUAGE: yul\nCODE:\n```\nfor {} true { for {} true {} { break } }\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Assignment\nDESCRIPTION: This example shows how to destructure a tuple and assign its elements to individual variables.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_45\n\nLANGUAGE: Solidity\nCODE:\n```\n(x,y,) = (1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Internal Function Types with Libraries in Solidity\nDESCRIPTION: This example illustrates the use of internal function types within Solidity libraries. It demonstrates how to create reusable functions (map, reduce, range) that operate on arrays, using an internal function `f` passed as an argument. The `Pyramid` contract then utilizes these functions with a `using ArrayUtils for *;` statement.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_18\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\nlibrary ArrayUtils {\n    // internal functions can be used in internal library functions because\n    // they will be part of the same code context\n    function map(uint[] memory self, function (uint) pure returns (uint) f)\n        internal\n        pure\n        returns (uint[] memory r)\n    {\n        r = new uint[](self.length);\n        for (uint i = 0; i < self.length; i++) {\n            r[i] = f(self[i]);\n        }\n    }\n\n    function reduce(\n        uint[] memory self,\n        function (uint, uint) pure returns (uint) f\n    )\n        internal\n        pure\n        returns (uint r)\n    {\n        r = self[0];\n        for (uint i = 1; i < self.length; i++) {\n            r = f(r, self[i]);\n        }\n    }\n\n    function range(uint length) internal pure returns (uint[] memory r) {\n        r = new uint[](length);\n        for (uint i = 0; i < r.length; i++) {\n            r[i] = i;\n        }\n    }\n}\n\n\ncontract Pyramid {\n    using ArrayUtils for *;\n\n    function pyramid(uint l) public pure returns (uint) {\n        return ArrayUtils.range(l).map(square).reduce(sum);\n    }\n\n    function square(uint x) internal pure returns (uint) {\n        return x * x;\n    }\n\n    function sum(uint x, uint y) internal pure returns (uint) {\n        return x + y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Function Overloading\nDESCRIPTION: This Solidity code demonstrates function overloading. Two functions named `f` are defined, one accepting a `uint8` argument and the other accepting a `uint256` argument. Both functions simply assign the input value to an output variable of the same type and return it.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f(uint8 val) public pure returns (uint8 out) {\n            out = val;\n        }\n\n        function f(uint256 val) public pure returns (uint256 out) {\n            out = val;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Public State Variable Getter Function in Solidity\nDESCRIPTION: This code snippet shows how the compiler automatically generates a getter function for public state variables of type address. It allows external contracts to access the value of the state variable.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction minter() external view returns (address) { return minter; }\n```\n\n----------------------------------------\n\nTITLE: Yul Linker Symbol Usage\nDESCRIPTION: This example demonstrates how to use the `linkersymbol` function in Yul to represent an address literal that will be substituted by the linker. It shows how to define a linker symbol and how it corresponds to the `--libraries` option used during linking.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_59\n\nLANGUAGE: Yul\nCODE:\n```\nlet a := linkersymbol(\"file.sol:Math\")\n```\n\n----------------------------------------\n\nTITLE: Function Modifier Order - Solidity\nDESCRIPTION: Shows the suggested order of modifiers in a function declaration: Visibility, Mutability, Virtual, Override, and Custom modifiers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_14\n\nLANGUAGE: solidity\nCODE:\n```\nfunction balance(uint from) public view override returns (uint)  {\n    return balanceOf[from];\n}\n\nfunction increment(uint x) public pure onlyOwner returns (uint) {\n    return x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: TestHandler Interface Definition (Solidity)\nDESCRIPTION: Defines a test function interface. This might be used for contract testing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_35\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface TestHandler {\n  function dudududu() external;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting EVM Version in Standard JSON Interface\nDESCRIPTION: This JSON snippet demonstrates how to set the EVM version within the standard JSON interface of the Solidity compiler. The `evmVersion` key in the `settings` field specifies the desired EVM version. Replace `<VERSION>` with a valid EVM version string.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"sources\": {/* ... */},\n  \"settings\": {\n    \"optimizer\": {/* ... */},\n    \"evmVersion\": \"<VERSION>\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapped Event Definitions and Emitters - Solidity\nDESCRIPTION: This snippet demonstrates the correct formatting for long event definitions and emitters in Solidity. Each argument should be on its own line with a single indent.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nevent LongAndLotsOfArgs(\n    address sender,\n    address recipient,\n    uint256 publicKey,\n    uint256 amount,\n    bytes32[] options\n);\n\nemit LongAndLotsOfArgs(\n    sender,\n    recipient,\n    publicKey,\n    amount,\n    options\n);\n```\n\n----------------------------------------\n\nTITLE: For Loop as While Loop in Yul\nDESCRIPTION: This Yul example showcases how a `for` loop can be used as a `while` loop by leaving the initialization and post-iteration parts empty. It calculates the sum of values in memory, similar to the previous example, but using a `while` loop structure.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_12\n\nLANGUAGE: yul\nCODE:\n```\n{\n    let x := 0\n    let i := 0\n    for { } lt(i, 0x100) { } {     // while(i < 0x100)\n        x := add(x, mload(i))\n        i := add(i, 0x20)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion: Truncating Integer in Solidity\nDESCRIPTION: Shows explicit conversion from a larger to a smaller integer type in Solidity, resulting in the truncation of higher-order bits.  The `uint32` value `0x12345678` is converted to `uint16`, resulting in `0x5678`. This demonstrates potential data loss during explicit conversions that reduce the size of the data type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nuint32 a = 0x12345678;\nuint16 b = uint16(a); // b will be 0x5678 now\n```\n\n----------------------------------------\n\nTITLE: Repeat Using Statements in Derived Contracts in Solidity\nDESCRIPTION: Clarifies that `using A for B` statements in Solidity only affect the contract where they are mentioned.  The statement must be repeated in all derived contracts that utilize the feature.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nusing A for B\n```\n\n----------------------------------------\n\nTITLE: Reference Types and Aliasing in Solidity\nDESCRIPTION: This Solidity code illustrates how the SMTChecker deals with aliasing of reference types. When a local reference or state variable of reference type is assigned, the SMTChecker erases knowledge about variables of the same type and data location. This behavior is demonstrated through assignments to memory and storage references, affecting assertion results.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_20\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Aliasing\n{\n    uint[] array1;\n    uint[][] array2;\n    function f(\n        uint[] memory a,\n        uint[] memory b,\n        uint[][] memory c,\n        uint[] storage d\n    ) internal {\n        array1[0] = 42;\n        a[0] = 2;\n        c[0][0] = 2;\n        b[0] = 1;\n        // Erasing knowledge about memory references should not\n        // erase knowledge about state variables.\n        assert(array1[0] == 42;\n        // However, an assignment to a storage reference will erase\n        // storage knowledge accordingly.\n        d[0] = 2;\n        // Fails as false positive because of the assignment above.\n        assert(array1[0] == 42;\n        // Fails because `a == b` is possible.\n        assert(a[0] == 2;\n        // Fails because `c[i] == b` is possible.\n        assert(c[0][0] == 2;\n        assert(d[0] == 2;\n        assert(b[0] == 1;\n    }\n    function g(\n        uint[] memory a,\n        uint[] memory b,\n        uint[][] memory c,\n        uint x\n    ) public {\n        f(a, b, c, array2[x]);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inlining Example - Fully Inlined\nDESCRIPTION: The fully inlined assembly, where the call to function 'f' has been replaced with its body, and the original function definition has been removed. This results in more efficient execution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n...body of function f...\n...opcodes after call to f...\n```\n\n----------------------------------------\n\nTITLE: Contract B Bytecode and Metadata\nDESCRIPTION: This snippet contains the bytecode and metadata for the Solidity contract 'B'. The bytecode represents the compiled contract, ready for deployment on the Ethereum network. The metadata provides crucial information, including the compiler version, Application Binary Interface (ABI), and the source code's cryptographic hash, enabling interaction and verification of the contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/library_inherited2_sol_cli_output.txt#_snippet_1\n\nLANGUAGE: Binary\nCODE:\n```\n608060405234801561001057600080fd5b506101cc806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80630423a13214610030575b600080fd5b61004a6004803603810190610045919061009d565b610060565b60405161005791906100d5565b60405180910390f35b600061006b82610072565b9050919050565b6000602a8261008191906100f0565b9050919050565b6000813590506100978161017f565b92915050565b6000602082840312156100af57600080fd5b60006100bd84828501610088565b91505092915050565b6100cf81610146565b82525050565b60006020820190506100ea60008301846100c6565b92915050565b60006100fb82610146565b915061010683610146565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561013b5761013a610150565b5b828201905092915050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b61018881610146565b811461019357600080fd5b5056fea2646970667358221220104c345633313efe410492448844d96d78452c3044ce126b5e041b7fbeaa790064736f6c63430008000033\n```\n\nLANGUAGE: Metadata\nCODE:\n```\n{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"syntaxTests/scoping/library_inherited2.sol\":\"B\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"syntaxTests/scoping/library_inherited2.sol\":{\"keccak256\":\"0xd0619f00638fdfea187368965615dbd599fead93dd14b6558725e85ec7011d96\",\"urls\":[\"bzz-raw://ec7af066be66a223f0d25ba3bf9ba6dc103e1a57531a66a38a5ca2b6ce172f55\",\"dweb:/ipfs/QmW1NrqQNhnY1Tkgr3Z9oM8buCGLUJCJVCDTVejJTT5Vet\"]}},\"version\":1}\n```\n\n----------------------------------------\n\nTITLE: Solidity Compiler Output - Sources\nDESCRIPTION: This snippet details the structure of the `sources` section in the Solidity compiler output. It includes information about each source file, such as its ID (used in source maps) and the Abstract Syntax Tree (AST) representation of the code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n{\n      // This contains the file-level outputs.\n      // It can be limited/filtered by the outputSelection settings.\n      \"sources\": {\n        \"sourceFile.sol\": {\n          // Identifier of the source (used in source maps)\n          \"id\": 1,\n          // The AST object\n          \"ast\": {}\n        }\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: BytesX to uintY Conversion in Solidity\nDESCRIPTION: Illustrates how to convert between `bytesX` and `uintY` by adjusting the size within the type before conversion in Solidity. It highlights the need to convert `bytes4` to `bytes8` before converting to `uint64`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nbytes8(bytes4_variable)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nuint64(bytes8(bytes4_variable))\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Example\nDESCRIPTION: This example demonstrates a Solidity contract named `Foo` with three functions: `bar`, `baz`, and `sam`. The `bar` function takes a `bytes3[2]` array, `baz` takes a `uint32` and a `bool` and returns a `bool`, and `sam` takes a `bytes`, a `bool`, and a `uint[]` array. The code is annotated with `// SPDX-License-Identifier: GPL-3.0` to declare the license and specifies the Solidity compiler version with `pragma solidity >=0.4.16 <0.9.0;`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Foo {\n    function bar(bytes3[2] memory) public pure {}\n    function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }\n    function sam(bytes memory, bool, uint[] memory) public pure {}\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Verbatim Builtin Function\nDESCRIPTION: Adds the `verbatim` builtin function to Yul, enabling the injection of arbitrary bytecode. This feature provides a low-level mechanism for fine-grained control over code generation, allowing developers to include custom bytecode sequences directly within their Yul code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_9\n\nLANGUAGE: Yul\nCODE:\n```\nverbatim\n```\n\n----------------------------------------\n\nTITLE: SignMessageLib Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for signing and verifying messages. This facilitates off-chain signing of messages, which can then be verified on-chain. This is used in secure multi-signature wallets.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_32\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface SignMessageLib {\n  function getMessageHash(bytes calldata message) external view returns (bytes32);\n  function signMessage(bytes calldata message) external view returns (bytes memory);\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Compilation with Base and Include Paths (Bash)\nDESCRIPTION: This example shows how to compile a Solidity contract using the `solc` command-line compiler, specifying base and include paths to locate dependencies.  It demonstrates how to inform the compiler where to find external libraries such as those installed via npm.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\nsolc contract.sol \\\n    --base-path . \\\n    --include-path node_modules/ \\\n    --include-path /usr/local/lib/node_modules/\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion: Truncating Bytes in Solidity\nDESCRIPTION: Illustrates explicit conversion between fixed-size byte arrays in Solidity, demonstrating truncation when converting to a smaller type. The `bytes2` value `0x1234` is converted to `bytes1`, resulting in `0x12`. This highlights how converting to a smaller fixed-size byte array will discard the trailing bytes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\nbytes2 a = 0x1234;\nbytes1 b = bytes1(a); // b will be 0x12\n```\n\n----------------------------------------\n\nTITLE: Sign Payment JavaScript\nDESCRIPTION: This JavaScript function orchestrates the signing of a payment. It calls `constructPaymentMessage` to create the message, then uses `signMessage` to sign it, requiring the contract address, amount in wei, and a callback to handle the signature.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfunction signPayment(contractAddress, amount, callback) {\n    var message = constructPaymentMessage(contractAddress, amount);\n    signMessage(message, callback);\n}\n```\n\n----------------------------------------\n\nTITLE: If Statement in Yul\nDESCRIPTION: This Yul snippet demonstrates the usage of an `if` statement for conditional code execution. It checks if the size of the calldata is less than 4 bytes and, if true, reverts the transaction.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_9\n\nLANGUAGE: yul\nCODE:\n```\nif lt(calldatasize(), 4) { revert(0, 0) }\n```\n\n----------------------------------------\n\nTITLE: Solidity Direct Imports Example\nDESCRIPTION: This code snippet shows examples of direct imports in Solidity. Direct imports use the specified path as the source unit name.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"/project/lib/util.sol\";         // source unit name: /project/lib/util.sol\nimport \"lib/util.sol\";                  // source unit name: lib/util.sol\nimport \"@openzeppelin/address.sol\";     // source unit name: @openzeppelin/address.sol\nimport \"https://example.com/token.sol\"; // source unit name: https://example.com/token.sol\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration and Scope in Yul\nDESCRIPTION: This Yul code snippet demonstrates variable declaration using the `let` keyword, showcasing variable scope within a block. It includes loading data from calldata, performing arithmetic operations, storing data to storage, and the deallocation of variables at the end of their scope.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_6\n\nLANGUAGE: yul\nCODE:\n```\n{\n    let zero := 0\n    let v := calldataload(zero)\n    {\n        let y := add(sload(v), 1)\n        v := y\n    } // y is \"deallocated\" here\n    sstore(v, zero)\n} // v and zero are \"deallocated\" here\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Switch Statement Evaluation (With Default)\nDESCRIPTION: This code defines the formal evaluation function `E` for a Yul `switch` statement with a default case. It evaluates the condition, then compares it against each case's literal value. If a match is found, it evaluates the corresponding statement; otherwise, it evaluates the default statement.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_51\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn default st'>: Switch) =\n    let G0, L0, v = E(G, L, condition)\n    // i = 1 .. n\n    // Evaluate literals, context doesn't matter\n    let _, _, v1 = E(G0, L0, l1)\n    ...\n    let _, _, vn = E(G0, L0, ln)\n    if there exists smallest i such that vi = v:\n        E(G0, L0, sti)\n    else:\n        E(G0, L0, st')\n```\n\n----------------------------------------\n\nTITLE: Pre-0.5.0 Solidity Contract\nDESCRIPTION: This snippet demonstrates a Solidity contract written for a version prior to 0.5.0. It uses features that are no longer allowed in newer versions, such as implicit mutability and the `constant` keyword for view functions. This code will not compile with Solidity v0.5.0 or later without modifications.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.4.25;\n// This will report a warning until version 0.4.25 of the compiler\n// This will not compile after 0.5.0\ncontract OldContract {\n    function someOldFunction(uint8 a) {\n        //...\n    }\n    function anotherOldFunction() constant returns (bool) {\n        //...\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Update Inline Assembly Storage Access in Solidity\nDESCRIPTION: Updates the syntax for accessing slot and offset of storage pointer variables in inline assembly in Solidity. Replace the `_slot` and `_offset` suffixes with `.slot` and `.offset` respectively.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nx.slot\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nx.offset\n```\n\n----------------------------------------\n\nTITLE: Interface Inheritance in Solidity\nDESCRIPTION: This snippet illustrates how interfaces can inherit from other interfaces in Solidity. It defines two parent interfaces, `ParentA` and `ParentB`, each with a `test` function. A third interface, `SubInterface`, inherits from both `ParentA` and `ParentB`.  It is necessary to redefine and override the inherited function to ensure compatibility between the parent meanings.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/interfaces.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ninterface ParentA {\n    function test() external returns (uint256);\n}\n\ninterface ParentB {\n    function test() external returns (uint256);\n}\n\ninterface SubInterface is ParentA, ParentB {\n    // Must redefine test in order to assert that the parent\n    // meanings are compatible.\n    function test() external override(ParentA, ParentB) returns (uint256);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Yul Intermediate Representation (IR) in Solidity\nDESCRIPTION: This snippet demonstrates how to enable the Yul intermediate representation (IR) during Solidity compilation. Setting `viaIR` to `true` changes the compilation pipeline to use the Yul IR.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"viaIR\": true\n}\n```\n\n----------------------------------------\n\nTITLE: SSA Transformation Example in Yul\nDESCRIPTION: Shows the SSA transformation process in Yul. This transformation replaces repeated assignments to variables by declarations of new variables, effectively creating a static single assignment form. It helps in optimizing code by making it easier to track variable values and perform transformations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_12\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a := 1\n        mstore(a, 2)\n        a := 3\n    }\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let a_1 := 1\n        let a := a_1\n        mstore(a_1, 2)\n        let a_3 := 3\n        a := a_3\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Executable isoltest\nDESCRIPTION: This snippet defines an executable named `isoltest` and lists all the source files that are part of this executable. It also sets a compile definition `ISOLTEST` and links against various libraries including `evmc`, `libsolc`, `solidity`, `yulInterpreter`, `evmasm`, Boost and Threads.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(isoltest\n\tisoltest.cpp\n\tIsolTestOptions.cpp\n\t../Common.cpp\n\t../CommonSyntaxTest.cpp\n\t../EVMHost.cpp\n\t../TestCase.cpp\n\t../TestCaseReader.cpp\n\t../libevmasm/EVMAssemblyTest.cpp\n\t../libevmasm/PlainAssemblyParser.cpp\n\t../libsolidity/util/BytesUtils.cpp\n\t../libsolidity/util/Common.cpp\n\t../libsolidity/util/ContractABIUtils.cpp\n\t../libsolidity/util/TestFileParser.cpp\n\t../libsolidity/util/TestFunctionCall.cpp\n\t../libsolidity/GasTest.cpp\n\t../libsolidity/MemoryGuardTest.cpp\n\t../libsolidity/NatspecJSONTest.cpp\n\t../libsolidity/OptimizedIRCachingTest.cpp\n\t../libsolidity/OptimizedIRCachingTest.h\n\t../libsolidity/SyntaxTest.cpp\n\t../libsolidity/SemanticTest.cpp\n\t../libsolidity/AnalysisFramework.cpp\n\t../libsolidity/SolidityExecutionFramework.cpp\n\t../ExecutionFramework.cpp\n\t../libsolidity/ABIJsonTest.cpp\n\t../libsolidity/ASTJSONTest.cpp\n\t../libsolidity/ASTPropertyTest.cpp\n\t../libsolidity/FunctionDependencyGraphTest.cpp\n\t../libsolidity/SMTCheckerTest.cpp\n\t../libyul/Common.cpp\n\t../libyul/ControlFlowGraphTest.cpp\n\t../libyul/SSAControlFlowGraphTest.cpp\n\t../libyul/ControlFlowSideEffectsTest.cpp\n\t../libyul/EVMCodeTransformTest.cpp\n\t../libyul/FunctionSideEffects.cpp\n\t../libyul/ObjectCompilerTest.cpp\n\t../libyul/SyntaxTest.cpp\n\t../libyul/StackShufflingTest.cpp\n\t../libyul/StackLayoutGeneratorTest.cpp\n\t../libyul/YulOptimizerTest.cpp\n\t../libyul/YulOptimizerTestCommon.cpp\n\t../libyul/YulInterpreterTest.cpp\n)\ntarget_compile_definitions(isoltest PRIVATE ISOLTEST)\ntarget_link_libraries(isoltest PRIVATE evmc libsolc solidity yulInterpreter evmasm Boost::boost Boost::program_options Boost::unit_test_framework Threads::Threads)\n```\n\n----------------------------------------\n\nTITLE: Unused Parameter Removal Example Yul\nDESCRIPTION: This snippet demonstrates the removal of unused parameters from a function and the creation of a new \"linking\" function to maintain compatibility.  The inliner should be run afterwards to replace references to the original function with the new one.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_16\n\nLANGUAGE: yul\nCODE:\n```\nfunction f(a,b) -> x { x := div(a,b) }\n    function f2(a,b,c) -> x, y { x := f(a,b) }\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly Access to Internal Functions\nDESCRIPTION: This demonstrates how inline assembly can access internal functions as jump labels. This allows for fine-grained control over the execution flow and optimization.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_34\n\nLANGUAGE: Solidity\nCODE:\n```\n// Inline assembly has access to internal functions (as jump labels)\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Break/Continue Evaluation\nDESCRIPTION: This snippet provides the formal evaluation function `E` for Yul `break` and `continue` statements. These statements simply return the current global and local states along with their respective modes, signaling the control flow to be altered by the enclosing loop or switch.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_47\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, break: BreakContinue) =\n    G, L, break\nE(G, L, continue: BreakContinue) =\n    G, L, continue\n```\n\n----------------------------------------\n\nTITLE: Buggy: Exponentiation with Type Conversion (Solidity)\nDESCRIPTION: Shows a potentially problematic exponentiation where the exponent `y` is explicitly converted to a `uint8` before the exponentiation operation `**` with `x`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nx ** uint8(y)\n```\n\n----------------------------------------\n\nTITLE: Solidity Relative Imports Example\nDESCRIPTION: This example demonstrates how the Solidity compiler resolves relative import paths based on the location of the importing source unit. It shows the resulting source unit names after applying the import resolution algorithm.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"./util/./util.sol\";         // source unit name: lib/src/../util/util.sol\nimport \"./util//util.sol\";          // source unit name: lib/src/../util/util.sol\nimport \"../util/../array/util.sol\"; // source unit name: lib/src/array/util.sol\nimport \"../.././../util.sol\";       // source unit name: util.sol\nimport \"../../.././../util.sol\";    // source unit name: util.sol\n```\n\n----------------------------------------\n\nTITLE: Defining ERC1155 Token Interface in Solidity\nDESCRIPTION: These are interface definitions for the ERC1155 Token contract, including methods for getting balances, minting tokens, and transferring tokens safely. The 'mint' function includes gas estimations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nERC1155Token                    balanceOf(address,uint256)\nERC1155Token                    mint(address,uint256,uint256,bytes)\nERC1155Token                    safeTransferFrom(address,address,uint256,uint256,bytes)\n```\n\n----------------------------------------\n\nTITLE: Deleting Data in Solidity\nDESCRIPTION: This Solidity contract demonstrates the usage of the `delete` keyword on different data types. It shows how `delete` affects local variables, storage variables, arrays, and aliases to storage objects.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/operators.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract DeleteExample {\n    uint data;\n    uint[] dataArray;\n\n    function f() public {\n        uint x = data;\n        delete x; // sets x to 0, does not affect data\n        delete data; // sets data to 0, does not affect x\n        uint[] storage y = dataArray;\n        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also\n        // y is affected which is an alias to the storage object\n        // On the other hand: \"delete y\" is not valid, as assignments to local variables\n        // referencing storage objects can only be made from existing storage objects.\n        assert(y.length == 0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Introduce mcopy Builtin Yul\nDESCRIPTION: This snippet introduces the `mcopy()` builtin in Yul. This builtin is for efficiently copying data between memory areas. The `mcopy` builtin is designed to be cheaper than traditional memory load/store loops, improving gas efficiency, particularly in situations involving large data copies.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nYul: Introduce builtin ``mcopy()`` for cheaply copying data between memory areas.\n```\n\n----------------------------------------\n\nTITLE: Solidity Compilation with Allowed Paths (Bash)\nDESCRIPTION: This example demonstrates using the `--allow-paths` option with the Solidity compiler. It shows how to whitelist additional directories from which the compiler is allowed to load files, enhancing security when importing from non-standard locations. The example also includes remapping.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\ncd /home/user/project/\nsolc token/contract.sol \\\n    lib/util.sol=libs/util.sol \\\n    --base-path=token/ \\\n    --include-path=/lib/\n```\n\n----------------------------------------\n\nTITLE: Example Solidity Contract\nDESCRIPTION: Shows an example solidity contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_19\n\nLANGUAGE: solidity\nCODE:\n```\n:caption: /project/contract.sol\n```\n\n----------------------------------------\n\nTITLE: Fine: Modifier with Fixed-Size Nested Array Parameter (Solidity)\nDESCRIPTION: Demonstrates using a modifier `m` with a fixed-size nested array `uint[2][2]` parameter.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() m(uint[2][2]) { }\n```\n\n----------------------------------------\n\nTITLE: Storage Struct Deletion Behavior (Solidity)\nDESCRIPTION: Illustrates how deleting storage structs now sets the entire storage slot to zero, including padding space.  The example highlights the change in behavior regarding padding space within structs during deletion, which can affect contract upgrades that rely on that padding space. The `delete` operation clears the full slot where the struct resides.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1;\n\ncontract C {\n    struct S {\n        uint64 y;\n        uint64 z;\n    }\n    S s;\n    function f() public {\n        // ...\n        delete s;\n        // s occupies only first 16 bytes of the 32 bytes slot\n        // delete will write zero to the full slot\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Long Function Declarations - Solidity\nDESCRIPTION: Illustrates the recommended formatting for long function declarations in Solidity. Each argument should be on its own line at the same indentation level as the function body. The closing parenthesis and opening bracket should be on their own line as well.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_15\n\nLANGUAGE: solidity\nCODE:\n```\nfunction thisFunctionHasLotsOfArguments(\n    address a,\n    address b,\n    address c,\n    address d,\n    address e,\n    address f\n)\n    public\n{\n    doSomething();\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Contract Runtime Code via Type Information\nDESCRIPTION: Retrieves the runtime bytecode of the contract.  Uses the `type(C).runtimeCode` syntax where `C` is a contract type. The same restrictions as .creationCode apply.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_18\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(C).runtimeCode\n```\n\n----------------------------------------\n\nTITLE: Define solc_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This snippet defines an executable named `solc_ossfuzz` using specified source files. It links the executable with `libsolc` and `evmasm` libraries. Additionally, it sets the `LINK_FLAGS` property to the value of `${LIB_FUZZING_ENGINE}`, which is likely used to enable fuzzing engine features.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(solc_ossfuzz\n            solc_ossfuzz.cpp\n            ../fuzzer_common.cpp\n            ../../TestCaseReader.cpp\n    )\n    target_link_libraries(solc_ossfuzz PRIVATE libsolc evmasm)\n    set_target_properties(solc_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(solc_ossfuzz\n            solc_ossfuzz.cpp\n            ../fuzzer_common.cpp\n            )\n    target_link_libraries(solc_ossfuzz PRIVATE libsolc evmasm)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Function Modifier Implementation Differences (Solidity)\nDESCRIPTION: Demonstrates how function modifiers are implemented differently, especially with multiple placeholder evaluations. The snippet highlights the behavior changes in function parameters and return variables when modifiers are used multiple times, affecting the visibility of value changes across executions. The core functionality involves the use of function modifiers and parameter handling.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\ncontract C {\n    function f(uint a) public pure mod() returns (uint r) {\n        r = a++;\n    }\n    modifier mod() { _; _; }\n}\n```\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\ncontract C {\n    bool active = true;\n    modifier mod()\n    {\n        _;\n        active = false;\n        _;\n    }\n    function foo() external mod() returns (uint ret)\n    {\n        if (active)\n            ret = 1; // Same as ``return 1``\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SMTChecker Overflow Warning\nDESCRIPTION: This text snippet shows a warning produced by the SMTChecker when an overflow is detected. It displays the overflow condition, the values of x and y that trigger it, and the transaction trace leading to the overflow within the smart contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nWarning: CHC: Overflow (resulting value larger than 2**256 - 1) happens here.\nCounterexample:\nx = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935\n = 0\n\nTransaction trace:\nOverflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)\nState: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935\nOverflow.stateAdd()\n    Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call\n --> o.sol:9:20:\n  |\n9 |             return x_ + y_;\n  |                    ^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Updating call() syntax in Solidity 0.5.0\nDESCRIPTION: This snippet shows how the `.call()` syntax needs to be updated when migrating from older versions of Solidity to version 0.5.0. It showcases changes needed for both function calls without arguments and calls with arguments.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_24\n\nLANGUAGE: Solidity\nCODE:\n```\nChange every ``.call()`` to a ``.call(\"\")`` and every ``.call(signature, a, b, c)`` to use ``.call(abi.encodeWithSignature(signature, a, b, c))`` (the last one only works for value types).\n```\n\n----------------------------------------\n\nTITLE: Remapping Imports for Solidity Compilation\nDESCRIPTION: This command-line example demonstrates how to use import remapping with the Solidity compiler, including specifying a base path. It redirects imports from a virtual directory to a local directory, allowing the compiler to locate the necessary files.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsolc github.com/ethereum/dapp-bin/=dapp-bin/ --base-path /project source.sol\n```\n\n----------------------------------------\n\nTITLE: Contract Naming: Correct Contract and File Naming in Solidity\nDESCRIPTION: This snippet demonstrates the correct naming convention for contracts and their corresponding files in Solidity. Contract names use CapWords, and filenames should match the contract name. It includes a sample contract `Owned`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_28\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n// Owned.sol\ncontract Owned {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ABI Encoding of String Data Structure\nDESCRIPTION: This snippet illustrates the encoding structure of dynamic strings in Ethereum's ABI. It shows the offset and data organization for an array of strings, demonstrating how lengths and values are positioned in the encoded data.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_2\n\nLANGUAGE: none\nCODE:\n```\n0 - c                                                                - offset for \"one\"\n1 - d                                                                - offset for \"two\"\n2 - e                                                                - offset for \"three\"\n3 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \"one\"\n4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of \"one\"\n5 - 0000000000000000000000000000000000000000000000000000000000000003 - count for \"two\"\n6 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of \"two\"\n7 - 0000000000000000000000000000000000000000000000000000000000000005 - count for \"three\"\n8 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of \"three\"\n```\n\n----------------------------------------\n\nTITLE: Data Location for Variables in Solidity 0.5.0\nDESCRIPTION: This snippet explains the explicit declaration of data locations for variables of struct, array, or mapping types in Solidity 0.5.0. It includes function parameters and mentions `calldata` for `external` functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_27\n\nLANGUAGE: Solidity\nCODE:\n```\nExplicitly state the data location for all variables of struct, array or mapping types (including function parameters), e.g. change ``uint[] x = m_x`` to ``uint[] storage x = m_x``. Note that ``external`` functions require parameters with a data location of ``calldata``.\n```\n\n----------------------------------------\n\nTITLE: Define sol_proto_ossfuzz Executable (CMake)\nDESCRIPTION: This CMake snippet defines the `sol_proto_ossfuzz` executable, specifying its source files, include directories, and linking libraries for Solidity protobuf fuzzing. It uses `solProtoFuzzer.cpp`, `SolidityEvmoneInterface.cpp`, `protoToSol.cpp`, `solProto.pb.cc`, and `../../EVMHost.cpp`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(sol_proto_ossfuzz\n            solProtoFuzzer.cpp\n            SolidityEvmoneInterface.cpp\n            protoToSol.cpp\n            solProto.pb.cc\n            ../../EVMHost.cpp\n    )\n    target_include_directories(sol_proto_ossfuzz PRIVATE\n            /usr/include/libprotobuf-mutator\n    )\n    target_link_libraries(sol_proto_ossfuzz PRIVATE solidity libsolc\n            evmc\n            evmone-standalone\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(sol_proto_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(sol_proto_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: New Solidity Contract (Post-0.5.0)\nDESCRIPTION: This snippet shows the updated version of the above contract for Solidity 0.5.0 and later.  It demonstrates the required changes, including explicit function mutability (e.g., `pure`), explicit type declarations (`uint z = someInteger()`), use of `require` instead of `throw` for error handling, and explicit memory location declarations (`bytes memory data`).\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_14\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.5.0;\n// This will not compile after 0.6.0\n\ncontract OtherContract {\n    uint x;\n    function f(uint y) external {\n        x = y;\n    }\n    function() payable external {}\n}\n\ncontract New {\n    OtherContract other;\n    uint myNumber;\n\n    // Function mutability must be specified.\n    function someInteger() internal pure returns (uint) { return 2; }\n\n    // Function visibility must be specified.\n    // Function mutability must be specified.\n    function f(uint x) public returns (bytes memory) {\n        // The type must now be explicitly given.\n        uint z = someInteger();\n        x += z;\n        // Throw is now disallowed.\n        require(x <= 100);\n        int y = -3 >> 1;\n        require(y == -2);\n        do {\n            x += 1;\n            if (x > 10) continue;\n            // 'Continue' jumps to the condition below.\n        } while (x < 11);\n\n        // Call returns (bool, bytes).\n        // Data location must be specified.\n        (bool success, bytes memory data) = address(other).call(\"f\");\n        if (!success)\n            revert();\n        return data;\n    }\n\n    using AddressMakePayable for address;\n    // Data location for 'arr' must be specified\n    function g(uint[] memory /* arr */, bytes8 x, OtherContract otherContract, address unknownContract) public payable {\n        // 'otherContract.transfer' is not provided.\n        // Since the code of 'OtherContract' is known and has the fallback\n        // function, address(otherContract) has type 'address payable'.\n        address(otherContract).transfer(1 ether);\n\n        // 'unknownContract.transfer' is not provided.\n        // 'address(unknownContract).transfer' is not provided\n        // since 'address(unknownContract)' is not 'address payable'.\n        // If the function takes an 'address' which you want to send\n        // funds to, you can convert it to 'address payable' via 'uint160'.\n        // Note: This is not recommended and the explicit type\n        // 'address payable' should be used whenever possible.\n        // To increase clarity, we suggest the use of a library for\n        // the conversion (provided after the contract in this example).\n        address payable addr = unknownContract.makePayable();\n        require(addr.send(1 ether));\n\n        // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),\n\n```\n\n----------------------------------------\n\nTITLE: Array Literals Solidity\nDESCRIPTION: This code shows how to define and use array literals in Solidity. It demonstrates that array literals are statically-sized memory arrays and discusses type conversion when defining literals. It also showcases how to pass an array literal to a function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure {\n        g([uint(1), 2, 3]);\n    }\n    function g(uint[3] memory) public pure {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bid Submission in Solidity\nDESCRIPTION: This function allows users to submit blinded bids along with a deposit. The bid is stored in the `bids` mapping. The deposited ether is refunded only if the bid is correctly revealed during the revealing phase. It's callable only before the bidding end.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction bid(bytes32 blindedBid)\n            external\n            payable\n            onlyBefore(biddingEnd)\n        {\n            bids[msg.sender].push(Bid({\n                blindedBid: blindedBid,\n                deposit: msg.value\n            }));\n        }\n```\n\n----------------------------------------\n\nTITLE: Blank Lines Between Functions - Solidity\nDESCRIPTION: This snippet illustrates the correct usage of blank lines between function declarations within a contract in Solidity. Function declarations should be separated by a single blank line.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract A {\n    function spam() public virtual pure;\n    function ham() public virtual pure;\n}\n\n\ncontract B is A {\n    function spam() public pure override {\n        // ...\n    }\n\n    function ham() public pure override {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Import Remapping with URL\nDESCRIPTION: This command shows how to remap a URL import to a local path using the Solidity compiler. This is particularly useful when working with external libraries or dependencies hosted online.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nsolc :https://github.com/ethereum/dapp-bin=/usr/local/dapp-bin contract.sol\n```\n\n----------------------------------------\n\nTITLE: Formatting Short Function Declarations - Solidity\nDESCRIPTION: Presents the suggested formatting for short function declarations in Solidity. The opening brace of the function body should be on the same line as the function declaration, preceded by a single space, and the closing brace should be at the same indentation level as the function declaration.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_13\n\nLANGUAGE: solidity\nCODE:\n```\nfunction increment(uint x) public pure returns (uint) {\n    return x + 1;\n}\n\nfunction increment(uint x) public pure onlyOwner returns (uint) {\n    return x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Define a Struct in Solidity\nDESCRIPTION: This example demonstrates a struct definition in Solidity containing two uint members and two uint8 members.  In storage, this struct occupies 96 bytes (3 slots of 32 bytes each). In memory, it requires 128 bytes (4 items with 32 bytes each) due to padding.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_memory.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nstruct S {\n    uint a;\n    uint b;\n    uint8 c;\n    uint8 d;\n}\n```\n\n----------------------------------------\n\nTITLE: Build Solidity with Build Script Bash\nDESCRIPTION: This script provides an easier way to build on Linux and macOS which installs binaries solc and soltest at usr/local/bin.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n#note: this will install binaries solc and soltest at usr/local/bin\n./scripts/build.sh\n```\n\n----------------------------------------\n\nTITLE: Contract Structure: Correct Order of Elements in Solidity\nDESCRIPTION: This snippet demonstrates the recommended order of elements within a Solidity contract: pragma statements, contract definition, error definition, and function definition. It highlights the importance of consistent structure.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_26\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.4 <0.9.0;\n\nabstract contract Math {\n    error DivideByZero();\n    function divide(int256 numerator, int256 denominator) public virtual returns (uint256);\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - ForLoop Evaluation\nDESCRIPTION: This code presents the formal evaluation function `E` for a Yul for loop. It handles both the case with an initialization block and the case without. The initialization block's scope extends to all parts of the loop. The condition is evaluated, and if true, the body and post-execution statements are evaluated.  Break and leave statements within the loop are handled appropriately.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_46\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <for { i1, ..., in } condition post body>: ForLoop) =\n    if n >= 1:\n        let G1, L1, mode = E(G, L, i1, ..., in)\n        // mode has to be regular or leave due to the syntactic restrictions\n        if mode is leave then\n            G1, L1 restricted to variables of L, leave\n        otherwise\n            let G2, L2, mode = E(G1, L1, for {} condition post body)\n            G2, L2 restricted to variables of L, mode\n    else:\n        let G1, L1, v = E(G, L, condition)\n        if v is false:\n            G1, L1, regular\n        else:\n            let G2, L2, mode = E(G1, L, body)\n            if mode is break:\n                G2, L2, regular\n            otherwise if mode is leave:\n                G2, L2, leave\n            else:\n                G3, L3, mode = E(G2, L2, post)\n                if mode is leave:\n                    G3, L3, leave\n                otherwise\n                    E(G3, L3, for {} condition post body)\n```\n\n----------------------------------------\n\nTITLE: Blank Lines Between Contracts - Solidity\nDESCRIPTION: This snippet illustrates the correct usage of blank lines between contract declarations in Solidity. Top-level declarations should be separated by two blank lines for improved readability.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract A {\n    // ...\n}\n\n\ncontract B {\n    // ...\n}\n\n\ncontract C {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Developer Documentation Output\nDESCRIPTION: Illustrates the JSON output generated by the Solidity compiler for developer documentation, containing author information, details, custom tags, and parameter/return value descriptions.  It shows the format and structure of the JSON file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/natspec-format.rst#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"version\" : 1,\n  \"kind\" : \"dev\",\n  \"author\" : \"Larry A. Gardner\",\n  \"details\" : \"All function calls are currently implemented without side effects\",\n  \"custom:experimental\" : \"This is an experimental contract.\",\n  \"methods\" :\n  {\n    \"age(uint256)\" :\n    {\n      \"details\" : \"The Alexandr N. Tetearing algorithm could increase precision\",\n      \"params\" :\n      {\n        \"rings\" : \"The number of rings from dendrochronological sample\"\n      },\n      \"returns\" : {\n        \"_0\" : \"Age in years, rounded up for partial years\",\n        \"_1\" : \"Name of the tree\"\n      }\n    },\n    \"leaves()\" :\n    {\n        \"details\" : \"Returns only a fixed number.\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fine: Nested Array Declaration within Function (Solidity)\nDESCRIPTION: Shows a function defining a local variable `x` of type fixed-size nested array `uint[2][2]`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint, uint) { uint[2][2] memory x; }\n```\n\n----------------------------------------\n\nTITLE: EVM Assembly Output for the Contract\nDESCRIPTION: This is the EVM assembly output generated by the Solidity compiler for the 'C' contract. It includes the constructor code and the deploy code as part of the 'sub_0' object, as well as the auxdata which corresponds to the contract metadata.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/analysing-compilation-output.rst#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n======= contract.sol:C =======\nEVM assembly:\n    /* \"contract.sol\":0:86  contract C {... */\n  mstore(0x40, 0x80)\n  callvalue\n  dup1\n  iszero\n  tag_1\n  jumpi\n  0x00\n  dup1\n  revert\ntag_1:\n  pop\n  dataSize(sub_0)\n  dup1\n  dataOffset(sub_0)\n  0x00\n  codecopy\n  0x00\n  return\nstop\n\nsub_0: assembly {\n        /* \"contract.sol\":0:86  contract C {... */\n      mstore(0x40, 0x80)\n      callvalue\n      dup1\n      iszero\n      tag_1\n      jumpi\n      0x00\n      dup1\n      revert\n    tag_1:\n      pop\n      jumpi(tag_2, lt(calldatasize, 0x04))\n      shr(0xe0, calldataload(0x00))\n      dup1\n      0x901717d1\n      eq\n      tag_3\n      jumpi\n    tag_2:\n      0x00\n      dup1\n      revert\n        /* \"contract.sol\":17:84  function one() public pure returns (uint) {... */\n    tag_3:\n      tag_4\n      tag_5\n      jump\t// in\n    tag_4:\n      mload(0x40)\n      tag_6\n      swap2\n      swap1\n      tag_7\n      jump\t// in\n    tag_6:\n      mload(0x40)\n      dup1\n      swap2\n      sub\n      swap1\n      return\n    tag_5:\n        /* \"contract.sol\":53:57  uint */\n      0x00\n        /* \"contract.sol\":76:77  1 */\n      0x01\n        /* \"contract.sol\":69:77  return 1 */\n      swap1\n      pop\n        /* \"contract.sol\":17:84  function one() public pure returns (uint) {... */\n      swap1\n      jump\t// out\n        /* \"#utility.yul\":7:125   */\n    tag_10:\n        /* \"#utility.yul\":94:118   */\n      tag_12\n        /* \"#utility.yul\":112:117   */\n      dup2\n        /* \"#utility.yul\":94:118   */\n      tag_13\n      jump\t// in\n    tag_12:\n        /* \"#utility.yul\":89:92   */\n      dup3\n        /* \"#utility.yul\":82:119   */\n      mstore\n        /* \"#utility.yul\":72:125   */\n      pop\n      pop\n      jump\t// out\n        /* \"#utility.yul\":131:353   */\n    tag_7:\n      0x00\n        /* \"#utility.yul\":262:264   */\n      0x20\n        /* \"#utility.yul\":251:260   */\n      dup3\n        /* \"#utility.yul\":247:265   */\n      add\n        /* \"#utility.yul\":239:265   */\n      swap1\n      pop\n        /* \"#utility.yul\":275:346   */\n      tag_15\n        /* \"#utility.yul\":343:344   */\n      0x00\n        /* \"#utility.yul\":332:341   */\n      dup4\n        /* \"#utility.yul\":328:345   */\n      add\n        /* \"#utility.yul\":319:325   */\n      dup5\n        /* \"#utility.yul\":275:346   */\n      tag_10\n      jump\t// in\n    tag_15:\n        /* \"#utility.yul\":229:353   */\n      swap3\n      swap2\n      pop\n      pop\n      jump\t// out\n        /* \"#utility.yul\":359:436   */\n    tag_13:\n      0x00\n        /* \"#utility.yul\":425:430   */\n      dup2\n        /* \"#utility.yul\":414:430   */\n      swap1\n      pop\n        /* \"#utility.yul\":404:436   */\n      swap2\n      swap1\n      pop\n      jump\t// out\n\n    auxdata: 0xa2646970667358221220a5874f19737ddd4c5d77ace1619e5160c67b3d4bedac75fce908fed32d98899864736f6c637827302e382e342d646576656c6f702e323032312e332e33302b636f6d6d69742e65613065363933380058\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing External Functions via Interface - Solidity\nDESCRIPTION: Allows accessing external functions via contract and interface names to obtain their selector. This enables compile-time knowledge of function selectors.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_18\n\nLANGUAGE: Solidity\nCODE:\n```\nAllow accessing external functions via contract and interface names to obtain their selector.\n```\n\n----------------------------------------\n\nTITLE: Function with multiple modifiers (timedTransitions, atStage, transitionNext) in Solidity\nDESCRIPTION: This function `g` uses three modifiers: `timedTransitions`, `atStage`, and `transitionNext`. It first checks timed transitions, then the current stage.  If both checks pass, the function executes, and finally transitions to the next stage. The order of modifiers is crucial.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/common-patterns.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction g()\n            public\n            timedTransitions\n            atStage(Stages.AnotherStage)\n            transitionNext\n        {\n        }\n```\n\n----------------------------------------\n\nTITLE: Old Solidity Contract (Pre-0.5.0)\nDESCRIPTION: This snippet presents an old Solidity contract (pre-0.5.0) demonstrating several features and syntax elements that are no longer valid in Solidity 0.5.0 and later. These include implicit function mutability, the `var` keyword, `throw` for error handling, and lack of explicit data locations for arrays.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_13\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.4.25;\n// This will not compile after 0.5.0\n\ncontract OtherContract {\n    uint x;\n    function f(uint y) external {\n        x = y;\n    }\n    function() payable external {}\n}\n\ncontract Old {\n    OtherContract other;\n    uint myNumber;\n\n    // Function mutability not provided, not an error.\n    function someInteger() internal returns (uint) { return 2; }\n\n    // Function visibility not provided, not an error.\n    // Function mutability not provided, not an error.\n    function f(uint x) returns (bytes) {\n        // Var is fine in this version.\n        var z = someInteger();\n        x += z;\n        // Throw is fine in this version.\n        if (x > 100)\n            throw;\n        bytes memory b = new bytes(x);\n        y = -3 >> 1;\n        // y == -1 (wrong, should be -2)\n        do {\n            x += 1;\n            if (x > 10) continue;\n            // 'Continue' causes an infinite loop.\n        } while (x < 11);\n        // Call returns only a Bool.\n        bool success = address(other).call(\"f\");\n        if (!success)\n            revert();\n        else {\n            // Local variables could be declared after their use.\n            int y;\n        }\n        return b;\n    }\n\n    // No need for an explicit data location for 'arr'\n    function g(uint[] arr, bytes8 x, OtherContract otherContract) public {\n        otherContract.transfer(1 ether);\n\n        // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),\n        // the first 4 bytes of x will be lost. This might lead to\n        // unexpected behavior since bytesX are right padded.\n        uint32 y = uint32(x);\n        myNumber += y + msg.value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Create EVMC Interface Library with CMake\nDESCRIPTION: This snippet creates the `evmc` interface library using CMake. It specifies header files as sources, sets include directories, and links the `evmc_loader` library as an interface dependency. This allows other projects to use the EVMC API by linking against `evmc`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/evmc/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(evmc INTERFACE)\ntarget_sources(evmc INTERFACE\n    ${PROJECT_SOURCE_DIR}/test/evmc/evmc.h\n    ${PROJECT_SOURCE_DIR}/test/evmc/evmc.hpp\n    ${PROJECT_SOURCE_DIR}/test/evmc/helpers.h\n    ${PROJECT_SOURCE_DIR}/test/evmc/utils.h\n)\ntarget_include_directories(evmc INTERFACE ${PROJECT_SOURCE_DIR}/test/)\ntarget_link_libraries(evmc INTERFACE evmc_loader)\n```\n\n----------------------------------------\n\nTITLE: ERC20Token transfer function signature\nDESCRIPTION: This is the signature for the `transfer` function in the `ERC20Token` contract. It transfers tokens from the sender to a recipient address, taking the recipient address and amount as parameters.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  transfer(address,uint256)\n```\n\n----------------------------------------\n\nTITLE: SSAReverser Transform Example Yul\nDESCRIPTION: Demonstrates how the SSAReverser transforms the code, swapping the declaration and assignment to reverse the effects of SSATransform. This transform aids in reusing existing variables instead of declaring fresh ones.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_18\n\nLANGUAGE: yul\nCODE:\n```\nlet a := calldataload(0)\nmstore(a, 1)\n```\n\nLANGUAGE: yul\nCODE:\n```\nlet a_1 := calldataload(0)\nlet a := a_1\nmstore(a_1, 1)\nlet a_2 := calldataload(0x20)\na := a_2\n```\n\nLANGUAGE: yul\nCODE:\n```\nlet a := calldataload(0)\nlet a_1 := a\nmstore(a_1, 1)\na := calldataload(0x20)\nlet a_2 := a\n```\n\n----------------------------------------\n\nTITLE: Expression Splitter Transformation Example in Yul\nDESCRIPTION: Demonstrates how the expression splitter transformation works. It converts complex expressions with nested function calls into a sequence of variable declarations and assignments.  This ensures that function calls have only variables as arguments, simplifying subsequent optimization steps like reordering and inlining.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_11\n\nLANGUAGE: yul\nCODE:\n```\nadd(mload(0x123), mul(mload(0x456), 0x20))\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n        let _1 := 0x20\n        let _2 := 0x456\n        let _3 := mload(_2)\n        let _4 := mul(_3, _1)\n        let _5 := 0x123\n        let _6 := mload(_5)\n        let z := add(_6, _4)\n    }\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: FunctionCall\nDESCRIPTION: Defines the grammar for a FunctionCall, including the Identifier and a list of Expressions as arguments.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_27\n\nLANGUAGE: none\nCODE:\n```\nFunctionCall =\n    Identifier '(' ( Expression ( ',' Expression )* )? ')'\n```\n\n----------------------------------------\n\nTITLE: Reentrancy Vulnerability Counterexample\nDESCRIPTION: This is example output from the SMTChecker detecting a reentrancy vulnerability in the `Mutex` contract when the `set` function is not protected by the `mutex` modifier. It shows the synthesized external call re-entering the `set` function and changing the value of `x` before the assertion in `run`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nWarning: CHC: Assertion violation happens here.\n    Counterexample:\n    x = 1, lock = true, unknown = 1\n\n    Transaction trace:\n    Mutex.constructor(1)\n    State: x = 0, lock = false, unknown = 1\n    Mutex.run()\n        unknown.run() -- untrusted external call, synthesized as:\n            Mutex.set(1) -- reentrant call\n      --> m.sol:32:3:\n       |\n    32 | \t\tassert(xPre == x);\n       | \t\t^^^^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Configuring Stack Allocation in Solidity Optimizer\nDESCRIPTION: This snippet shows how to configure stack allocation in the Solidity optimizer. Setting `stackAllocation` to `true` improves stack slot allocation and can free up stack slots earlier. The `optimizerSteps` option allows defining a custom sequence of optimization steps.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"stackAllocation\": true,\n  \"optimizerSteps\": \"dhfoDgvulfnTUtnIf...\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for libyul\nDESCRIPTION: This code snippet defines the source files for the `libyul` library, which deals with the Yul intermediate language. Includes components for parsing, optimization, and code generation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(libyul_sources\n    libyul/Common.cpp\n    libyul/Common.h\n    libyul/CompilabilityChecker.cpp\n    libyul/ControlFlowGraphTest.cpp\n    libyul/ControlFlowGraphTest.h\n    libyul/ControlFlowSideEffectsTest.cpp\n    libyul/ControlFlowSideEffectsTest.h\n    libyul/EVMCodeTransformTest.cpp\n    libyul/EVMCodeTransformTest.h\n    libyul/FunctionSideEffects.cpp\n    libyul/FunctionSideEffects.h\n    libyul/Inliner.cpp\n    libyul/KnowledgeBaseTest.cpp\n    libyul/Metrics.cpp\n    libyul/ObjectCompilerTest.cpp\n    libyul/ObjectCompilerTest.h\n    libyul/ObjectParser.cpp\n    libyul/Parser.cpp\n    libyul/SSAControlFlowGraphTest.cpp\n    libyul/SSAControlFlowGraphTest.h\n    libyul/StackLayoutGeneratorTest.cpp\n    libyul/StackLayoutGeneratorTest.h\n    libyul/StackShufflingTest.cpp\n    libyul/StackShufflingTest.h\n    libyul/SyntaxTest.h\n    libyul/SyntaxTest.cpp\n    libyul/YulInterpreterTest.cpp\n    libyul/YulInterpreterTest.h\n    libyul/YulOptimizerTest.cpp\n    libyul/YulOptimizerTest.h\n    libyul/YulOptimizerTestCommon.cpp\n    libyul/YulOptimizerTestCommon.h\n)\ndetect_stray_source_files(\"${libyul_sources}\" \"libyul/\")\n```\n\n----------------------------------------\n\nTITLE: ERC20Token allowance function signature\nDESCRIPTION: This is the signature for the `allowance` function in the `ERC20Token` contract. It takes two address parameters and returns the allowance of tokens from one address to another.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  allowance(address,address)\n```\n\n----------------------------------------\n\nTITLE: String Literal to Bytes Conversion in Solidity\nDESCRIPTION: Demonstrates implicit conversion of string and hex string literals to fixed-size byte arrays in Solidity.  Conversion is allowed if the number of characters is less than or equal to the size of the bytes type. The example details constraints and successful/unsuccessful examples.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\nbytes2 a = hex\"1234\"; // fine\nbytes2 b = \"xy\"; // fine\nbytes2 c = hex\"12\"; // fine\nbytes2 e = \"x\"; // fine\nbytes2 f = \"xyz\"; // not allowed\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Example for Isoltest\nDESCRIPTION: This code snippet shows a simple Solidity contract used as an example for the isoltest tool. It demonstrates a state variable declaration, and the expected error if the same variable is declared twice.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\ncontract test {\n    uint256 variable;\n}\n// ----\n// DeclarationError: (36-52): Identifier already declared.\n```\n\n----------------------------------------\n\nTITLE: Fine: Function Returning Dynamic Array of Fixed-Size Arrays (Solidity)\nDESCRIPTION: Demonstrates a correct function definition that returns a dynamic array `uint[2][] a` of fixed-size arrays.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() public pure returns (uint[2][] a) { }\n```\n\n----------------------------------------\n\nTITLE: Place Bid (Internal) in Solidity\nDESCRIPTION: This internal function handles the logic for placing a bid. It refunds the previous highest bidder and updates the highest bid and highest bidder accordingly. It is only callable from within the contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/blind-auction.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\n function placeBid(address bidder, uint value) internal\n                returns (bool success)\n        {\n            if (value <= highestBid) {\n                return false;\n            }\n            if (highestBidder != address(0)) {\n                // Refund the previously highest bidder.\n                pendingReturns[highestBidder] += highestBid;\n            }\n            highestBid = value;\n            highestBidder = bidder;\n            return true;\n        }\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: VariableDeclaration\nDESCRIPTION: Defines the grammar for VariableDeclaration using the 'let' keyword, and an optional assignment with an expression.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_17\n\nLANGUAGE: none\nCODE:\n```\nVariableDeclaration =\n    'let' TypedIdentifierList ( ':=' Expression )?\n```\n\n----------------------------------------\n\nTITLE: Creating a Proxy Contract using GnosisSafeProxyFactory in Solidity\nDESCRIPTION: This snippet describes the `createProxy` function within the `GnosisSafeProxyFactory` contract. It allows for the creation of a proxy contract, utilizing an address and bytecode to instantiate the new contract. The function has a gas cost associated with it, as indicated by the values in the provided table.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_27\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafeProxyFactory          createProxy(address,bytes)\n```\n\n----------------------------------------\n\nTITLE: Memory-Unsafe Assembly: Returndata Copy\nDESCRIPTION: This assembly snippet is not memory safe because the size of the returndata may exceed the 64-byte scratch space.  It copies the return data to memory offset 0 and then reverts with the same data.  This is unsafe because the destination of `returndatacopy` is the scratch space, which should not be overwritten with more than 64 bytes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\nassembly {\n  returndatacopy(0, 0, returndatasize())\n  revert(0, returndatasize())\n}\n```\n\n----------------------------------------\n\nTITLE: ERC20Token increaseAllowance function signature\nDESCRIPTION: This is the signature for the `increaseAllowance` function in the `ERC20Token` contract. It increases the allowance of a spender for a given account.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_9\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  increaseAllowance(address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Define a Simple Solidity Contract\nDESCRIPTION: This code snippet defines a basic Solidity contract named 'C' with a function 'one' that returns the value 1. This contract is used as an example for demonstrating assembly code generation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/analysing-compilation-output.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\ncontract C {\n    function one() public pure returns (uint) {\n        return 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Interface ID via Type Information\nDESCRIPTION: Retrieves the EIP-165 interface identifier of the given interface `I`.  Uses the `type(I).interfaceId` syntax.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_19\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(I).interfaceId\n```\n\n----------------------------------------\n\nTITLE: Unknown Pragma Error in Solidity\nDESCRIPTION: This snippet demonstrates an error caused by using an unknown pragma directive 'thisdoesntexist' in a Solidity file. The compiler throws an error because the pragma is not recognized. This helps illustrate how the compiler enforces valid pragma usage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/unknown_pragma_sol_cli_output.txt#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\npragma thisdoesntexist;\n```\n\n----------------------------------------\n\nTITLE: Solidity Import with Alias\nDESCRIPTION: This example shows a shorthand for importing all global symbols as a symbol using the `as` keyword. This is equivalent to `import * as symbolName from \"filename\";`. It helps in avoiding naming conflicts and organizing the code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"filename\" as symbolName;\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Contract Instance (this) in Solidity\nDESCRIPTION: Represents the current contract instance. It can be explicitly converted to an address using `address(this)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_13\n\nLANGUAGE: Solidity\nCODE:\n```\nthis (current contract's type)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: HexNumber\nDESCRIPTION: Defines the grammar for HexNumber as '0x' followed by one or more hexadecimal digits.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_37\n\nLANGUAGE: none\nCODE:\n```\nHexNumber = '0x' [0-9a-fA-F]+\n```\n\n----------------------------------------\n\nTITLE: Solidity Interface for Pre-0.5.0 Contract\nDESCRIPTION: This snippet defines an interface for the pre-0.5.0 contract shown above. It allows newer Solidity contracts to interact with older, deployed contracts. Note that `constant` is replaced with `external returns (bool)` because of changes to how view functions are handled.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/050-breaking-changes.rst#_snippet_10\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\ninterface OldContract {\n    function someOldFunction(uint8 a) external;\n    function anotherOldFunction() external returns (bool);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Solidity Compiler Error Output\nDESCRIPTION: This code snippet provides an example of the JSON output produced by the Solidity compiler when errors are encountered during compilation. It includes information such as the error type, component, severity, error code, message, and source location.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n{\n      // Optional: not present if no errors/warnings/infos were encountered\n      \"errors\": [\n        {\n          // Optional: Location within the source file.\n          \"sourceLocation\": {\n            \"file\": \"sourceFile.sol\",\n            \"start\": 0,\n            \"end\": 100\n          },\n          // Optional: Further locations (e.g. places of conflicting declarations)\n          \"secondarySourceLocations\": [\n            {\n              \"file\": \"sourceFile.sol\",\n              \"start\": 64,\n              \"end\": 92,\n              \"message\": \"Other declaration is here:\"\n            }\n          ],\n          // Mandatory: Error type, such as \"TypeError\", \"InternalCompilerError\", \"Exception\", etc.\n          // See below for complete list of types.\n          \"type\": \"TypeError\",\n          // Mandatory: Component where the error originated, such as \"general\" etc.\n          \"component\": \"general\",\n          // Mandatory (\"error\", \"warning\" or \"info\", but please note that this may be extended in the future)\n          \"severity\": \"error\",\n          // Optional: unique code for the cause of the error\n          \"errorCode\": \"3141\",\n          // Mandatory\n          \"message\": \"Invalid keyword\",\n          // Optional: the message formatted with source location\n          \"formattedMessage\": \"sourceFile.sol:100: Invalid keyword\"\n        }\n      ]\n    }\n```\n\n----------------------------------------\n\nTITLE: Selfdestruct Alias\nDESCRIPTION: Shows that selfdestruct can be used as an alias for suicide.  selfdestruct destroys the current contract and sends any remaining ether to a specified address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_39\n\nLANGUAGE: Solidity\nCODE:\n```\nselfdestruct\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nsuicide\n```\n\n----------------------------------------\n\nTITLE: Signing a Message with web3.js in JavaScript\nDESCRIPTION: This snippet demonstrates how to sign a message using web3.js. It first calculates the SHA3 hash of the message and then uses `web3.eth.personal.sign` to sign the hash with the default account. This process is done offline without interacting with the Ethereum network.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/// Hashing first makes things easier\nvar hash = web3.utils.sha3(\"message to sign\");\nweb3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log(\"Signed\"); });\n```\n\n----------------------------------------\n\nTITLE: JSON Example of Event Output\nDESCRIPTION: This JSON snippet shows an example of the output when listening to an event, demonstrating the structure of the `returnValues` and `raw` data.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/events.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n       \"returnValues\": {\n           \"from\": \"0x1111FFFFCCCC\",\n           \"id\": \"0x50sd5adb20\",\n           \"value\": \"0x420042\"\n       },\n       \"raw\": {\n           \"data\": \"0x7f91385\",\n           \"topics\": [\"0xfd4b4ead7\", \"0x7f1a91385\"]\n       }\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in CMake\nDESCRIPTION: The `add_subdirectory` command adds a subdirectory to the build. This command is used to include the ossfuzz and yulInterpreter subprojects in the build process. These subdirectories likely contain their own CMakeLists.txt files that define how they are built.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(ossfuzz)\n\nadd_subdirectory(yulInterpreter)\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Storage Layout\nDESCRIPTION: This JSON represents the storage layout of the `A` contract. It shows the `astId`, `contract`, `label`, `offset`, `slot`, and `type` for each state variable. The `type` field references an entry in the `types` object, providing details about the variable's data type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"storage\": [\n    {\n      \"astId\": 15,\n      \"contract\": \"fileA:A\",\n      \"label\": \"x\",\n      \"offset\": 0,\n      \"slot\": \"0\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 19,\n      \"contract\": \"fileA:A\",\n      \"label\": \"w\",\n      \"offset\": 0,\n      \"slot\": \"1\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 24,\n      \"contract\": \"fileA:A\",\n      \"label\": \"s\",\n      \"offset\": 0,\n      \"slot\": \"2\",\n      \"type\": \"t_struct(S)13_storage\"\n    },\n    {\n      \"astId\": 26,\n      \"contract\": \"fileA:A\",\n      \"label\": \"addr\",\n      \"offset\": 0,\n      \"slot\": \"6\",\n      \"type\": \"t_address\"\n    },\n    {\n      \"astId\": 34,\n      \"contract\": \"fileA:A\",\n      \"label\": \"map\",\n      \"offset\": 0,\n      \"slot\": \"7\",\n      \"type\": \"t_mapping(t_uint256,t_mapping(t_address,t_bool))\"\n    },\n    {\n      \"astId\": 37,\n      \"contract\": \"fileA:A\",\n      \"label\": \"array\",\n      \"offset\": 0,\n      \"slot\": \"8\",\n      \"type\": \"t_array(t_uint256)dyn_storage\"\n    },\n    {\n      \"astId\": 39,\n      \"contract\": \"fileA:A\",\n      \"label\": \"s1\",\n      \"offset\": 0,\n      \"slot\": \"9\",\n      \"type\": \"t_string_storage\"\n    },\n    {\n      \"astId\": 41,\n      \"contract\": \"fileA:A\",\n      \"label\": \"b1\",\n      \"offset\": 0,\n      \"slot\": \"10\",\n      \"type\": \"t_bytes_storage\"\n    }\n  ],\n  \"types\": {\n    \"t_address\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"address\",\n      \"numberOfBytes\": \"20\"\n    },\n    \"t_array(t_uint256)2_storage\": {\n      \"base\": \"t_uint256\",\n      \"encoding\": \"inplace\",\n      \"label\": \"uint256[2]\",\n      \"numberOfBytes\": \"64\"\n    },\n    \"t_array(t_uint256)dyn_storage\": {\n      \"base\": \"t_uint256\",\n      \"encoding\": \"dynamic_array\",\n      \"label\": \"uint256[]\",\n      \"numberOfBytes\": \"32\"\n    },\n    \"t_bool\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"bool\",\n      \"numberOfBytes\": \"1\"\n    },\n    \"t_bytes_storage\": {\n      \"encoding\": \"bytes\",\n      \"label\": \"bytes\",\n      \"numberOfBytes\": \"32\"\n    },\n    \"t_mapping(t_address,t_bool)\": {\n      \"encoding\": \"mapping\",\n      \"key\": \"t_address\",\n      \"label\": \"mapping(address => bool)\",\n      \"numberOfBytes\": \"32\",\n      \"value\": \"t_bool\"\n    },\n    \"t_mapping(t_uint256,t_mapping(t_address,t_bool))\": {\n      \"encoding\": \"mapping\",\n      \"key\": \"t_uint256\",\n      \"label\": \"mapping(uint256 => mapping(address => bool))\",\n      \"numberOfBytes\": \"32\",\n      \"value\": \"t_mapping(t_address,t_bool)\"\n    },\n    \"t_string_storage\": {\n      \"encoding\": \"bytes\",\n      \"label\": \"string\",\n      \"numberOfBytes\": \"32\"\n    },\n    \"t_struct(S)13_storage\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"struct A.S\",\n      \"members\": [\n        {\n          \"astId\": 3,\n          \"contract\": \"fileA:A\",\n          \"label\": \"a\",\n          \"offset\": 0,\n          \"slot\": \"0\",\n          \"type\": \"t_uint128\"\n        },\n        {\n          \"astId\": 5,\n          \"contract\": \"fileA:A\",\n          \"label\": \"b\",\n          \"offset\": 16,\n          \"slot\": \"0\",\n          \"type\": \"t_uint128\"\n        },\n        {\n          \"astId\": 9,\n          \"contract\": \"fileA:A\",\n          \"label\": \"staticArray\",\n          \"offset\": 0,\n          \"slot\": \"1\",\n          \"type\": \"t_array(t_uint256)2_storage\"\n        },\n        {\n          \"astId\": 12,\n          \"contract\": \"fileA:A\",\n          \"label\": \"dynArray\",\n          \"offset\": 0,\n          \"slot\": \"3\",\n          \"type\": \"t_array(t_uint256)dyn_storage\"\n        }\n      ],\n      \"numberOfBytes\": \"128\"\n    },\n    \"t_uint128\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"uint128\",\n      \"numberOfBytes\": \"16\"\n    },\n    \"t_uint256\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"uint256\",\n      \"numberOfBytes\": \"32\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Experimental SMTChecker Pragma\nDESCRIPTION: This code shows how to enable the experimental SMTChecker in Solidity using a pragma.  It activates additional safety warnings by querying an SMT solver.  Not available in all Solidity builds and may produce many warnings due to unsupported features.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\npragma experimental SMTChecker;\n```\n\n----------------------------------------\n\nTITLE: Solidity Generated Yul Source\nDESCRIPTION: This snippet shows an example of Yul code generated by the Solidity compiler as part of the compilation process.  In this case, it's a utility function for ABI decoding. The generated code is included in the `generatedSources` array within the bytecode section of the compiler output.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_16\n\nLANGUAGE: Yul\nCODE:\n```\n{ function abi_decode(start, end) -> data { data := calldataload(start) } }\n```\n\n----------------------------------------\n\nTITLE: Memory-Safe Assembly: Zero-Length Revert\nDESCRIPTION: This assembly snippet is memory-safe because it uses a zero-length revert operation. With a zero length, the memory offset used does not matter and can safely be in the scratch space.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/assembly.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\nassembly (\"memory-safe\") {\n  revert(0, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Base Path and Remapping\nDESCRIPTION: This demonstrates setting both the base path and remapping for the solidity compiler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nsolc /project/=/contracts/ /project/contract.sol --base-path /project # source unit name: contract.sol\n```\n\n----------------------------------------\n\nTITLE: Function with Parameters in Solidity\nDESCRIPTION: This code demonstrates a simple contract `Simple` with a function `taker` that accepts two unsigned integer parameters `a` and `b` and stores their sum in the state variable `sum`.  Function parameters are declared like variables and can be assigned to. Requires Solidity version >=0.4.16 and <0.9.0.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    uint sum;\n    function taker(uint a, uint b) public {\n        sum = a + b;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Expressions\nDESCRIPTION: Demonstrates the use of tuple expressions in Solidity, allowing multiple values to be grouped together and returned from functions or assigned to variables.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_43\n\nLANGUAGE: Solidity\nCODE:\n```\n(1,2,3)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nreturn (1,2,3);\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: DecimalNumber\nDESCRIPTION: Defines the grammar for DecimalNumber as one or more decimal digits.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_38\n\nLANGUAGE: none\nCODE:\n```\nDecimalNumber = [0-9]+\n```\n\n----------------------------------------\n\nTITLE: Ballot Contract Definition Solidity\nDESCRIPTION: This Solidity code defines the Ballot contract, which implements a voting system with delegation. It includes struct definitions for `Voter` and `Proposal`, state variables, a constructor, and functions for assigning voting rights, delegating votes, and determining the winning proposal. The code utilizes `require` statements for input validation and error handling.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/voting.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n/// @title Voting with delegation.\ncontract Ballot {\n    // This declares a new complex type which will\n    // be used for variables later.\n    // It will represent a single voter.\n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    // This is a type for a single proposal.\n    struct Proposal {\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    // This declares a state variable that\n    // stores a `Voter` struct for each possible address.\n    mapping(address => Voter) public voters;\n\n    // A dynamically-sized array of `Proposal` structs.\n    Proposal[] public proposals;\n\n    /// Create a new ballot to choose one of `proposalNames`.\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n\n    // Give `voter` the right to vote on this ballot.\n    // May only be called by `chairperson`.\n    function giveRightToVote(address voter) external {\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /// Delegate your vote to the voter `to`.\n    function delegate(address to) external {\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \\\"stuck\\\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        Voter storage delegate_ = voters[to];\n\n        // Voters cannot delegate to accounts that cannot vote.\n        require(delegate_.weight >= 1);\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender]`.\n        sender.voted = true;\n        sender.delegate = to;\n\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /// Give your vote (including votes delegated to you)\n    /// to proposal `proposals[proposal].name`.\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /// @dev Computes the winning proposal taking all\n    /// previous votes into account.\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    // Calls winningProposal() function to get the index\n    // of the winner contained in the proposals array and then\n    // returns the name of the winner\n    function winnerName() external view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating solc executable CMake\nDESCRIPTION: This snippet creates the `solc` executable using the `add_executable` command in CMake. It uses the source file defined in the `sources` variable. Then, it links the executable to the `solcli` library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(solc ${sources})\ntarget_link_libraries(solc PRIVATE solcli)\n```\n\n----------------------------------------\n\nTITLE: Yul Literal Usage Example\nDESCRIPTION: This code snippet shows how to use literals in Yul. It adds two integer literals (3 and 2), performs a bitwise AND operation with the string literal \"abc\", and assigns the result to the variable `x`. In the EVM dialect, literals represent 256-bit words.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_3\n\nLANGUAGE: Yul\nCODE:\n```\nlet x := and(\"abc\", add(3, 2))\n```\n\n----------------------------------------\n\nTITLE: Fine: Empty Comment (Solidity)\nDESCRIPTION: Illustrates a valid, empty comment block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_20\n\nLANGUAGE: Solidity\nCODE:\n```\n/** bla **/\n```\n\n----------------------------------------\n\nTITLE: OwnerManager Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for managing owners of a smart contract and the required threshold. Functions include adding, removing, swapping owners, changing the threshold, and retrieving owner information. These functions are crucial for controlling access and permissions within the contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_30\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface OwnerManager {\n  function addOwnerWithThreshold(address owner, uint256 threshold) external;\n  function changeThreshold(uint256 threshold) external;\n  function getOwners() external view returns (address[] memory);\n  function getThreshold() external view returns (uint256);\n  function isOwner(address owner) external view returns (bool);\n  function removeOwner(address prevOwner, address owner, uint256 threshold) external;\n  function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity Import Statement Example\nDESCRIPTION: This code snippet shows a simple Solidity import statement that imports a file from a specific path.  The path used depends on the import remappings defined in the compilation command.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_13\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"github.com/ethereum/dapp-bin/library/math.sol\"; // source unit name: dapp-bin/library/math.sol\n```\n\n----------------------------------------\n\nTITLE: Solidity Function Overloading with Contract Types\nDESCRIPTION: This snippet illustrates a compilation error related to function overloading in Solidity. The contract `A` defines two overloaded functions `f`, one taking contract type `B` and the other taking an `address`. Although Solidity considers them different, the ABI sees both as accepting an `address`, leading to a compile-time error. It uses Solidity version 0.4.16 or higher.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/functions.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\n// This will not compile\ncontract A {\n    function f(B value) public pure returns (B out) {\n        out = value;\n    }\n\n    function f(address value) public pure returns (address out) {\n        out = value;\n    }\n}\n\ncontract B {\n}\n```\n\n----------------------------------------\n\nTITLE: Function Without Implementation in Solidity\nDESCRIPTION: This snippet illustrates a function declaration without implementation, which is a characteristic of abstract contracts. The `foo` function takes an address as input and returns an address, but lacks a body, meaning it is not implemented within the contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/abstract-contracts.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nfunction foo(address) external returns (address);\n```\n\n----------------------------------------\n\nTITLE: Introduce tload/tstore Builtins Yul\nDESCRIPTION: This snippet introduces the `tload()` and `tstore()` builtins in Yul. These builtins provide access to transient storage. Transient storage is a memory region that persists only for the duration of a single transaction, offering a cheaper alternative to persistent storage for temporary data.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nYul: Introduce builtins ``tload()`` and ``tstore()`` for transient storage access.\n```\n\n----------------------------------------\n\nTITLE: Mapping with KeyName and ValueName\nDESCRIPTION: This example shows how to use the optional KeyName and ValueName in a mapping definition. These names are only used to improve the ABI and have no functional impact on the contract. The code defines a mapping 'balances' with names 'user' for the key and 'balance' for the value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/mapping-types.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.18;\n\ncontract MappingExampleWithNames {\n    mapping(address user => uint balance) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: FunctionDefinition\nDESCRIPTION: Defines the grammar for a FunctionDefinition, including the 'function' keyword, identifier, parameters, return values, and the function body.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_16\n\nLANGUAGE: none\nCODE:\n```\nFunctionDefinition =\n    'function' Identifier '(' TypedIdentifierList? ')'\n    ( '->' TypedIdentifierList )? Block\n```\n\n----------------------------------------\n\nTITLE: Operator Whitespace: Incorrect Spacing in Solidity\nDESCRIPTION: This snippet demonstrates incorrect whitespace usage around operators in Solidity, which can reduce code readability. It shows examples of inconsistent spacing and missing spacing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_25\n\nLANGUAGE: solidity\nCODE:\n```\nx = 2** 3 + 5;\nx = y+z;\nx +=1;\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Storage Layout Structure\nDESCRIPTION: This JSON code defines the expected structure for a Solidity contract's storage layout. It contains the 'astId', 'contract', 'label', 'offset', 'slot', and 'type' properties. This structure is utilized to detail where and how state variables are stored within a Solidity contract.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n        \"astId\": 2,\n        \"contract\": \"fileA:A\",\n        \"label\": \"x\",\n        \"offset\": 0,\n        \"slot\": \"0\",\n        \"type\": \"t_uint256\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for Contracts\nDESCRIPTION: This code snippet defines the source files for the contracts component of the Solidity project. These files include `AuctionRegistrar.cpp`, `ContractInterface.h`, and `Wallet.cpp`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(contracts_sources\n    contracts/AuctionRegistrar.cpp\n    contracts/ContractInterface.h\n    contracts/Wallet.cpp\n)\ndetect_stray_source_files(\"${contracts_sources}\" \"contracts/\")\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe addOwnerWithThreshold function signature\nDESCRIPTION: This is the signature for the `addOwnerWithThreshold` function in the `GnosisSafe` contract. It adds a new owner with a specified threshold.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  addOwnerWithThreshold(address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Installing solcjs globally with npm\nDESCRIPTION: This snippet demonstrates how to install the `solcjs` Solidity compiler globally using npm. This provides a convenient way to access the compiler from the command line. Note that `solcjs` has fewer features than `solc`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --global solc\n```\n\n----------------------------------------\n\nTITLE: Mapping Getter Function in Solidity\nDESCRIPTION: This code snippet demonstrates the getter function created by the compiler for a public mapping. It allows querying the balance of a single account using its address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction balances(address account) external view returns (uint) {\n    return balances[account];\n}\n```\n\n----------------------------------------\n\nTITLE: Modulo Operation Examples\nDESCRIPTION: Examples illustrating the behavior of the modulo operator in Solidity. Shows how the result's sign matches the left operand and how it handles negative numbers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nint256(5) % int256(2) == int256(1)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nint256(5) % int256(-2) == int256(1)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nint256(-5) % int256(2) == int256(-1)\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nint256(-5) % int256(-2) == int256(-1)\n```\n\n----------------------------------------\n\nTITLE: Defining Constants and Structs\nDESCRIPTION: These code lines define constants and structs, possibly in a Solidity-like language.  The constants are aliased to each other (A constant BT = BU), and structs are defined with members that are instances of other structs (struct BT { BU m; }). The definitions seem to form a chain of dependencies.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/scripts/codespell_ignored_lines.txt#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nA constant BT = BU;\nA constant BU = BV;\nA constant FN = FO;\nA constant FO = FP;\nstruct BT { BU m; }\nstruct BU { BV m; }\nstruct FN { FO m; }\nstruct FO { FP m; }\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing in Solidity\nDESCRIPTION: This Solidity code demonstrates variable shadowing, where an inner variable declaration hides an outer variable. Assigning to a variable with the same name within the inner scope affects the outer variable before the inner variable is declared.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n// This will report a warning\ncontract C {\n    function f() pure public returns (uint) {\n        uint x = 1;\n        {\n            x = 2; // this will assign to the outer variable\n            uint x;\n        }\n        return x; // x has value 2\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating license.h\nDESCRIPTION: This snippet reads the contents of LICENSE.txt, converts it into a hexadecimal character array, and then configures the `license.h.in` template file to create the `license.h` file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\n# Create license.h from LICENSE.txt and template\n# Converting to char array is required due to MSVC's string size limit.\nfile(READ ${PROJECT_SOURCE_DIR}/LICENSE.txt LICENSE_TEXT HEX)\nstring(REGEX MATCHALL \"..\" LICENSE_TEXT \"${LICENSE_TEXT}\")\nstring(REGEX REPLACE \";\" \",\\n\\t0x\" LICENSE_TEXT \"${LICENSE_TEXT}\")\nset(LICENSE_TEXT \"0x${LICENSE_TEXT}\")\n\nconfigure_file(\"${PROJECT_SOURCE_DIR}/cmake/templates/license.h.in\" include/license.h)\n```\n\n----------------------------------------\n\nTITLE: Setting libsolcli sources CMake\nDESCRIPTION: This snippet defines the source files for the `libsolcli` library using the `set` command in CMake. It includes both .cpp and .h files necessary for building the library. The `libsolcli_sources` variable is later used in the `add_library` command.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(libsolcli_sources\n\tCommandLineInterface.cpp CommandLineInterface.h\n\tCommandLineParser.cpp CommandLineParser.h\n\tExceptions.h\n)\n```\n\n----------------------------------------\n\nTITLE: Define a Solidity Constant\nDESCRIPTION: This snippet declares a constant unsigned integer 'x' with a value of 42 in Solidity. This illustrates a simple variable declaration within a Solidity context.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nuint constant x = 42;\n```\n\n----------------------------------------\n\nTITLE: ERC20Token transferFrom function signature\nDESCRIPTION: This is the signature for the `transferFrom` function in the `ERC20Token` contract. It transfers tokens from one address to another on behalf of a spender, taking the sender, recipient, and amount as parameters.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  transferFrom(address,address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Accessing Contract Name via Type Information\nDESCRIPTION: Retrieves the name of the contract.  Uses the `type(C).name` syntax where `C` is a contract type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\ntype(C).name\n```\n\n----------------------------------------\n\nTITLE: Command-line Compilation Example\nDESCRIPTION: This bash snippet shows how to compile Solidity contracts using the command-line interface. The compiler resolves paths relative to the base or include paths to construct the source unit name.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsolc contract.sol /usr/local/dapp-bin/token.sol\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Identifier Evaluation\nDESCRIPTION: This snippet presents the formal evaluation function `E` for a Yul identifier.  It retrieves the value associated with the identifier from the local state `L` and returns it along with the global and local states.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_52\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <name>: Identifier) =\n    G, L, L[$name]\n```\n\n----------------------------------------\n\nTITLE: Emscripten Function Export with CMake\nDESCRIPTION: This CMake snippet defines how to export specific C++ functions when building with Emscripten.  It creates a list of exported functions, sets linker flags to expose them in the generated JavaScript file (`soljson.js`), and then creates the executable `soljson`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolc/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif (EMSCRIPTEN)\n\tCreateExportedFunctionsForEMSDK(\n\t\tExportedFunctions\n\t\tsolidity_license\n\t\tsolidity_version\n\t\tsolidity_compile\n\t\tsolidity_alloc\n\t\tsolidity_free\n\t\tsolidity_reset\n\t)\n\t# Specify which functions to export in soljson.js.\n\t# Note that additional Emscripten-generated methods needed by solc-js are\n\t# defined to be exported in cmake/EthCompilerSettings.cmake.\n\tset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -s EXPORTED_FUNCTIONS='${ExportedFunctions}'\")\n\tadd_executable(soljson libsolc.cpp libsolc.h)\n\ttarget_link_libraries(soljson PRIVATE solidity)\nelse()\n\tadd_library(libsolc libsolc.cpp libsolc.h)\n\tset_target_properties(libsolc PROPERTIES OUTPUT_NAME solc)\n\ttarget_link_libraries(libsolc PRIVATE solidity)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for libsolutil\nDESCRIPTION: This code snippet defines the source files for the `libsolutil` library, a utility library used within the Solidity project. Files include various utility components such as Checksum, CommonData, JSON, Keccak256, etc.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(libsolutil_sources\n    libsolutil/Checksum.cpp\n    libsolutil/CommonData.cpp\n    libsolutil/CommonIO.cpp\n    libsolutil/DisjointSet.cpp\n    libsolutil/DominatorFinderTest.cpp\n    libsolutil/FixedHash.cpp\n    libsolutil/FunctionSelector.cpp\n    libsolutil/IpfsHash.cpp\n    libsolutil/IterateReplacing.cpp\n    libsolutil/JSON.cpp\n    libsolutil/Keccak256.cpp\n    libsolutil/LazyInit.cpp\n    libsolutil/LEB128.cpp\n    libsolutil/StringUtils.cpp\n    libsolutil/SwarmHash.cpp\n    libsolutil/TemporaryDirectoryTest.cpp\n    libsolutil/UTF8.cpp\n    libsolutil/Whiskers.cpp\n)\ndetect_stray_source_files(\"${libsolutil_sources}\" \"libsolutil/\")\n```\n\n----------------------------------------\n\nTITLE: Fixed-Size Byte Array Literal Conversion in Solidity\nDESCRIPTION: Explains the rules for converting decimal and hexadecimal number literals to fixed-size byte arrays in Solidity.  Hexadecimal literals can be converted if the number of hex digits exactly matches the size of the bytes type.  Both decimal and hexadecimal literals with a value of zero can be converted to any fixed-size bytes type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_9\n\nLANGUAGE: solidity\nCODE:\n```\nbytes2 a = 54321; // not allowed\nbytes2 b = 0x12; // not allowed\nbytes2 c = 0x123; // not allowed\nbytes2 d = 0x1234; // fine\nbytes2 e = 0x0012; // fine\nbytes4 f = 0; // fine\nbytes4 g = 0x0; // fine\n```\n\n----------------------------------------\n\nTITLE: Define const_opt_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `const_opt_ossfuzz` executable, specifying its source files (`const_opt_ossfuzz.cpp`, `../fuzzer_common.cpp`), linking libraries (`libsolc`, `evmasm`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(const_opt_ossfuzz const_opt_ossfuzz.cpp ../fuzzer_common.cpp)\n    target_link_libraries(const_opt_ossfuzz PRIVATE libsolc evmasm)\n    set_target_properties(const_opt_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(const_opt_ossfuzz\n            const_opt_ossfuzz.cpp\n            ../fuzzer_common.cpp)\n    target_link_libraries(const_opt_ossfuzz PRIVATE libsolc evmasm)\nendif()\n```\n\n----------------------------------------\n\nTITLE: SPDX License Identifier Comment in Solidity\nDESCRIPTION: This code snippet shows the recommended way to include an SPDX license identifier in a Solidity source file. This helps establish trust and manage copyright concerns. It should be placed at the top of the file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: MIT\n```\n\n----------------------------------------\n\nTITLE: Setting Gas and Value in External Function Calls - Solidity\nDESCRIPTION: Enables specifying gas and value for external function calls using the syntax `c.f{gas: 10000, value: 4 ether}()`. This allows fine-grained control over gas and ether sent with function calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_19\n\nLANGUAGE: Solidity\nCODE:\n```\nAllow gas and value to be set in external function calls using ``c.f{gas: 10000, value: 4 ether}()``.\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe encodeTransactionData function signature\nDESCRIPTION: This is the signature for the `encodeTransactionData` function in the `GnosisSafe` contract. It encodes transaction data for execution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_25\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  encodeTransactionData(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Using Double Quotes for Strings - Solidity\nDESCRIPTION: Illustrates that strings should be quoted with double-quotes instead of single-quotes in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_22\n\nLANGUAGE: solidity\nCODE:\n```\nstr = \"foo\";\nstr = \"Hamlet says, 'To be or not to be...'\"\n```\n\n----------------------------------------\n\nTITLE: Compiling Solidity to Yul IR\nDESCRIPTION: This command uses the `solc` compiler to generate Yul intermediate representation (IR) from a Solidity source file. The `--ir` flag tells the compiler to output Yul IR, and the `--output-dir` flag specifies the directory where the output files should be placed. The output files will have the .yul extension and can then be processed by `yul-phaser`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsolc/solc <sol file> --ir --output-dir <output directory>\n```\n\n----------------------------------------\n\nTITLE: Address Conversion for Contracts in Solidity 0.5.0\nDESCRIPTION: This snippet illustrates the required conversion of contract types to addresses before accessing address members in Solidity 0.5.0. An example shows converting contract `c` to `address(c)` before calling `transfer()`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_28\n\nLANGUAGE: Solidity\nCODE:\n```\nExplicitly convert values of contract type to addresses before using an ``address`` member. Example: if ``c`` is a contract, change ``c.transfer(...)`` to ``address(c).transfer(...)``.\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Example with Trusted External Calls\nDESCRIPTION: This Solidity code demonstrates the potential issues when treating external calls as trusted in the SMTChecker. It showcases how casting addresses or contracts to different types can lead to inconsistent storage values and unsound analysis results, especially when the external contract's state is modified.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_14\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract D {\n    constructor(uint _x) { x = _x; }\n    uint public x;\n    function setX(uint _x) public { x = _x; }\n}\n\ncontract E {\n    constructor() { x = 2; }\n    uint public x;\n    function setX(uint _x) public { x = _x; }\n}\n\ncontract C {\n    function f() public {\n        address d = address(new D(42));\n\n        // `d` was deployed as `D`, so its `x` should be 42 now.\n        assert(D(d).x() == 42); // should hold\n        assert(D(d).x() == 43); // should fail\n\n        // E and D have the same interface, so the following\n        // call would also work at runtime.\n        // However, the change to `E(d)` is not reflected in `D(d)`.\n        E(d).setX(1024);\n\n        // Reading from `D(d)` now will show old values.\n        // The assertion below should fail at runtime,\n        // but succeeds in this mode's analysis (unsound).\n        assert(D(d).x() == 42);\n        // The assertion below should succeed at runtime,\n        // but fails in this mode's analysis (false positive).\n        assert(D(d).x() == 1024);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including EthToolchains and EthPolicy\nDESCRIPTION: This snippet includes the EthToolchains and EthPolicy CMake modules, which likely contain custom toolchain configurations and policy settings for the Ethereum project.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(EthToolchains)\n\n# Set cmake_policies\ninclude(EthPolicy)\neth_policy()\n```\n\n----------------------------------------\n\nTITLE: Testing for Big Endian Systems\nDESCRIPTION: This snippet uses the `TestBigEndian` module to determine if the system is big endian. If it is, a fatal error is raised, indicating that Solidity does not currently support big endian systems.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(TestBigEndian)\nTEST_BIG_ENDIAN(IS_BIG_ENDIAN)\nif (IS_BIG_ENDIAN)\n\tmessage(FATAL_ERROR \"${PROJECT_NAME} currently does not support big endian systems.\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define strictasm_opt_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `strictasm_opt_ossfuzz` executable, specifying its source file (`strictasm_opt_ossfuzz.cpp`), linking library (`yul`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(strictasm_opt_ossfuzz strictasm_opt_ossfuzz.cpp)\n    target_link_libraries(strictasm_opt_ossfuzz PRIVATE yul)\n    set_target_properties(strictasm_opt_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(strictasm_opt_ossfuzz\n            strictasm_opt_ossfuzz.cpp\n            )\n    target_link_libraries(strictasm_opt_ossfuzz PRIVATE yul)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Expression Evaluation Order (Solidity)\nDESCRIPTION: Highlights the difference in expression evaluation order between the old and new code generators. While the new codegen tries to evaluate in source order (left to right), it's not guaranteed, potentially leading to semantic differences. The code illustrates how pre-increment operators are handled differently, impacting the final result.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\ncontract C {\n    function preincr_u8(uint8 a) public pure returns (uint8) {\n        return ++a + a;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Function Call Example\nDESCRIPTION: This code snippet illustrates how to call both built-in and user-defined functions in Yul. The `mstore` function stores data in memory, and the example shows how to assign multiple return values from a user-defined function `f` to local variables `x` and `y`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_5\n\nLANGUAGE: Yul\nCODE:\n```\nfunction f(x, y) -> a, b { /* ... */ }\n mstore(0x80, add(mload(0x80), 3))\n // Here, the user-defined function `f` returns two values.\n let x, y := f(1, mload(0))\n```\n\n----------------------------------------\n\nTITLE: Spacing Around Operators - Solidity\nDESCRIPTION: Demonstrates that operators should be surrounded by a single space on either side in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_23\n\nLANGUAGE: solidity\nCODE:\n```\nx = 3;\nx = 100 / 10;\nx += 3 + 4;\nx |= y && z;\n```\n\n----------------------------------------\n\nTITLE: Transient Storage Layout JSON\nDESCRIPTION: This JSON snippet represents the transient storage layout of a Solidity contract. It includes information about the storage slots, variable types, offsets, and sizes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"storage\": [\n    {\n      \"astId\": 17,\n      \"contract\": \"fileA:A\",\n      \"label\": \"y\",\n      \"offset\": 0,\n      \"slot\": \"0\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 21,\n      \"contract\": \"fileA:A\",\n      \"label\": \"z\",\n      \"offset\": 0,\n      \"slot\": \"1\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 28,\n      \"contract\": \"fileA:A\",\n      \"label\": \"taddr\",\n      \"offset\": 0,\n      \"slot\": \"2\",\n      \"type\": \"t_address\"\n    }\n  ],\n  \"types\": {\n    \"t_address\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"address\",\n      \"numberOfBytes\": \"20\"\n    },\n    \"t_uint256\": {\n      \"encoding\": \"inplace\",\n      \"label\": \"uint256\",\n      \"numberOfBytes\": \"32\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Demonstrates incorrect declaration of a function returning a fixed-size nested array. The function `f` attempts to return a `uint[2][2]` array.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() pure returns (uint[2][2]) { }\n```\n\n----------------------------------------\n\nTITLE: Solidity Relative Imports Example 1\nDESCRIPTION: This code snippet demonstrates relative imports in Solidity, where the path is relative to the importing file's source unit name. This example shows how the source unit names are resolved based on the location of the importing file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"./util.sol\" as util;    // source unit name: /project/lib/util.sol\nimport \"../token.sol\" as token; // source unit name: /project/token.sol\n```\n\n----------------------------------------\n\nTITLE: Unassigned Immutables Error\nDESCRIPTION: This error indicates that immutable variables were read from but never assigned a value. This is likely caused by optimization during compilation. Review the contract's code to ensure all immutable variables are properly initialized.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_generation_error_cli_output.txt#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nError: Some immutables were read from but never assigned, possibly because of optimization.\n```\n\n----------------------------------------\n\nTITLE: Buggy: Exponentiation Operator No Space (Solidity)\nDESCRIPTION: Shows a potentially problematic use of the exponentiation operator `**` (no space) without a constant exponent. Variable `x` is raised to the power of `y`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\nx**y\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for soltest\nDESCRIPTION: This code snippet sets the source files required for building the `soltest` executable. It includes various source files from different components of the Solidity project, such as Common, EVMHost, ExecutionFramework, Metadata, TestCase, TestCaseReader, etc.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(sources\n    soltest.cpp\n    Common.cpp\n    Common.h\n    CommonSyntaxTest.cpp\n    CommonSyntaxTest.h\n    EVMHost.cpp\n    EVMHost.h\n    ExecutionFramework.cpp\n    ExecutionFramework.h\n    FilesystemUtils.cpp\n    FilesystemUtils.h\n    InteractiveTests.h\n    Metadata.cpp\n    Metadata.h\n    TestCase.cpp\n    TestCase.h\n    TestCaseReader.cpp\n    TestCaseReader.h\n)\ndetect_stray_source_files(\"${sources}\" \".\")\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Metadata\nDESCRIPTION: This snippet shows the metadata associated with the compiled Solidity contract 'C'. It includes information such as the compiler version, language, ABI, developer documentation, user documentation, compilation settings, source code hash, and URLs. This data is used for contract verification and interaction.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/solc_0.4.8_cli_output.txt#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\"compiler\":{\"version\":\"0.4.8+commit.60cc1668.mod.Darwin.appleclang\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contract.sol\":\"C\"},\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contract.sol\":{\"keccak256\":\"0xbe86d3681a198587296ad6d4a834606197e1a8f8944922c501631b04e21eeba2\",\"urls\":[\"bzzr://af16957d3d86013309d64d3cc572d007b1d8b08a821f2ff366840deb54a78524\"]}},\"version\":1}\n```\n\n----------------------------------------\n\nTITLE: Cloning Homebrew Ethereum repository\nDESCRIPTION: This snippet shows how to clone the Homebrew Ethereum repository to install a specific version of Solidity directly from the repository.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ethereum/homebrew-ethereum.git\ncd homebrew-ethereum\ngit checkout <your-hash-goes-here>\n```\n\n----------------------------------------\n\nTITLE: Switch Statement in Yul\nDESCRIPTION: This Yul code demonstrates the `switch` statement, which is used to compare an expression against several literal constants. It loads data from calldata based on the value at index 4 and stores the result in storage.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_10\n\nLANGUAGE: yul\nCODE:\n```\n{\n    let x := 0\n    switch calldataload(4)\n    case 0 {\n        x := calldataload(0x24)\n    }\n    default {\n        x := calldataload(0x44)\n    }\n    sstore(0, div(x, 2))\n}\n```\n\n----------------------------------------\n\nTITLE: SimulateTxAccessor Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for simulating transactions without executing them. This allows for checking the outcome of a transaction before committing it on-chain, preventing unexpected errors or gas costs. It accepts the target address, value, data, and operation type for simulation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_33\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface SimulateTxAccessor {\n  function simulate(address to, uint256 value, bytes calldata data, uint8 operation) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Fine: Exponentiation with Constant 200 (Solidity)\nDESCRIPTION: Shows the correct usage of the exponentiation operator `**` (no space) with a constant exponent of 200.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_19\n\nLANGUAGE: Solidity\nCODE:\n```\nx**200\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for EVMASM\nDESCRIPTION: This snippet defines a variable `sources` containing a list of source files (both .cpp and .h) that will be used to build the `evmasm` library. It essentially aggregates all the files necessary for the library's compilation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libevmasm/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(sources\n\tAbstractAssemblyStack.h\n\tAssembly.cpp\n\tAssembly.h\n\tAssemblyItem.cpp\n\tAssemblyItem.h\n\tEthdebug.cpp\n\tEthdebug.h\n\tEVMAssemblyStack.cpp\n\tEVMAssemblyStack.h\n\tBlockDeduplicator.cpp\n\tBlockDeduplicator.h\n\tCommonSubexpressionEliminator.cpp\n\tCommonSubexpressionEliminator.h\n\tConstantOptimiser.cpp\n\tConstantOptimiser.h\n\tControlFlowGraph.cpp\n\tControlFlowGraph.h\n\tDisassemble.cpp\n\tDisassemble.h\n\tExceptions.h\n\tExpressionClasses.cpp\n\tExpressionClasses.h\n\tGasMeter.cpp\n\tGasMeter.h\n\tInliner.cpp\n\tInliner.h\n\tInstruction.cpp\n\tInstruction.h\n\tJumpdestRemover.cpp\n\tJumpdestRemover.h\n\tKnownState.cpp\n\tKnownState.h\n\tLinkerObject.cpp\n\tLinkerObject.h\n\tPathGasMeter.cpp\n\tPathGasMeter.h\n\tPeepholeOptimiser.cpp\n\tPeepholeOptimiser.h\n\tSemanticInformation.cpp\n\tSemanticInformation.h\n\tSimplificationRule.h\n\tSimplificationRules.cpp\n\tSimplificationRules.h\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Definitions for Boost\nDESCRIPTION: This snippet conditionally defines the `BOOST_TEST_DYN_LINK` macro if Boost is not using static libraries. This is needed for dynamic linking of the Boost test library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT Boost_USE_STATIC_LIBS)\n    target_compile_definitions(soltest PUBLIC -DBOOST_TEST_DYN_LINK)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Definition\nDESCRIPTION: Defines a simple Solidity contract named 'C'. This contract serves as a basic example for demonstrating Solidity syntax and compilation. It requires a Solidity compiler to be compiled and deployed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/solc_0.4.0_cli_output.txt#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract C {}\n\n```\n\n----------------------------------------\n\nTITLE: Fine: Struct and Function Parameter (Solidity)\nDESCRIPTION: Shows a contract `C` with a struct `S` and a function `f` taking the struct as a parameter.  This is a valid use case.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_25\n\nLANGUAGE: Solidity\nCODE:\n```\npragma experimental ABIEncoderV2;\ncontract C\n{\n\tstruct S { uint x; }\n\tfunction f(S s);\n\tS s1;\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Single-Line If Statements - Solidity\nDESCRIPTION: Demonstrates the acceptable style for single-line `if` statements in Solidity.  Omitting braces is permissible if the statement fits on a single line.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_11\n\nLANGUAGE: solidity\nCODE:\n```\nif (x < 10)\n    x += 1;\n```\n\n----------------------------------------\n\nTITLE: Setting Project Name and Version\nDESCRIPTION: This snippet sets the project name to \"solidity\", its version to \"0.8.30\", the OSX deployment target to 10.14, and specifies that the project supports C and C++ languages.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# project name and version should be set after cmake_policy CMP0048\nset(PROJECT_VERSION \"0.8.30\")\n# OSX target needed in order to support std::visit\nset(CMAKE_OSX_DEPLOYMENT_TARGET \"10.14\")\nproject(solidity VERSION ${PROJECT_VERSION} LANGUAGES C CXX)\n```\n\n----------------------------------------\n\nTITLE: Memory Array Allocation\nDESCRIPTION: Shows the use of the `new` keyword to allocate memory arrays in Solidity.  Memory arrays are dynamically sized arrays that exist only during the execution of a function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_38\n\nLANGUAGE: Solidity\nCODE:\n```\nnew\n```\n\n----------------------------------------\n\nTITLE: Yul Assignment with Multiplication in Object\nDESCRIPTION: This snippet shows Yul code wrapped within an anonymous object.  It assigns the result of multiplying 3 and 5 to the variable 'y'. It utilizes the `:linenos:` directive to display line numbers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_6\n\nLANGUAGE: Yul\nCODE:\n```\n// Yul code wrapped in object\n{\n    let y := mul(3, 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing with ripemd160 in Solidity\nDESCRIPTION: Computes the RIPEMD-160 hash of the input. The function takes a bytes memory array and returns a bytes20 value, which is the RIPEMD-160 hash.  It's a precompiled contract, so Out-of-Gas errors might occur on private blockchains if it hasn't been called before.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nripemd160(bytes memory) returns (bytes20)\n```\n\n----------------------------------------\n\nTITLE: Fine: Exponentiation with Constant 2 (Solidity)\nDESCRIPTION: Illustrates the correct usage of the exponentiation operator `**` with a constant exponent of 2.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_17\n\nLANGUAGE: Solidity\nCODE:\n```\nx ** 2\n```\n\n----------------------------------------\n\nTITLE: Yul Power Function Implementation (Iterative)\nDESCRIPTION: This code snippet demonstrates an iterative implementation of the power function in Yul using a `for` loop. It initializes the result to 1 and then multiplies it by the base for each iteration of the loop, up to the exponent.  `lt(a, b)` computes whether `a` is less than `b`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_1\n\nLANGUAGE: Yul\nCODE:\n```\n{\n function power(base, exponent) -> result\n {\n result := 1\n for { let i := 0 } lt(i, exponent) { i := add(i, 1) }\n {\n result := mul(result, base)\n }\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Assignment Evaluation\nDESCRIPTION: This snippet presents the formal evaluation function `E` for a Yul assignment. It first evaluates the right-hand side (rhs) to obtain values `v1, ..., vn`. Then, it creates a copy of the local state `L1`, updating the values of the assigned variables with the evaluated values. Finally, it returns the updated states and 'regular' mode.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_45\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <var_1, ..., var_n := rhs>: Assignment) =\n    let G1, L1, v1, ..., vn = E(G, L, rhs)\n    let L2 be a copy of L1 where L2[$var_i] = vi for i = 1, ..., n\n    G1, L2, regular\n```\n\n----------------------------------------\n\nTITLE: Import Statements at Top - Solidity\nDESCRIPTION: This snippet emphasizes that import statements should be placed at the top of the Solidity file, following the pragma directive. This practice improves code organization and readability.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\nimport \"./Owned.sol\";\n\ncontract A {\n    // ...\n}\n\n\ncontract B is Owned {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - String Literal Evaluation\nDESCRIPTION: This code provides the formal evaluation function `E` for a Yul string literal. It uses a string evaluation function `str` to convert the literal to its actual string value and returns it along with the global and local states.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_54\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, l: StringLiteral) = G, L, str(l),\n    where str is the string evaluation function,\n    which for the EVM dialect is defined in the section 'Literals' above\n```\n\n----------------------------------------\n\nTITLE: Contract A Bytecode and Metadata\nDESCRIPTION: This snippet contains the bytecode and metadata for the Solidity contract 'A'. The bytecode is the compiled smart contract ready to be deployed on the Ethereum blockchain. The metadata includes compiler information, ABI, and source code hash, essential for contract interaction and verification.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/library_inherited2_sol_cli_output.txt#_snippet_0\n\nLANGUAGE: Binary\nCODE:\n```\n6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122086e727f29d40b264a19bbfcad38d64493dca4bab5dbba8c82ffdaae389d2bba064736f6c63430008000033\n```\n\nLANGUAGE: Metadata\nCODE:\n```\n{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"syntaxTests/scoping/library_inherited2.sol\":\"A\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"syntaxTests/scoping/library_inherited2.sol\":{\"keccak256\":\"0xd0619f00638fdfea187368965615dbd599fead93dd14b6558725e85ec7011d96\",\"urls\":[\"bzz-raw://ec7af066be66a223f0d25ba3bf9ba6dc103e1a57531a66a38a5ca2b6ce172f55\",\"dweb:/ipfs/QmW1NrqQNhnY1Tkgr3Z9oM8buCGLUJCJVCDTVejJTT5Vet\"]}},\"version\":1}\n```\n\n----------------------------------------\n\nTITLE: Standard JSON with Import Callback\nDESCRIPTION: This JSON snippet shows the usage of the 'urls' field in the Standard JSON input to trigger the import callback. The compiler will attempt to load source code from the specified URLs until one is successful.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"language\": \"Solidity\",\n    \"sources\": {\n        \"/usr/local/dapp-bin/token.sol\": {\n            \"urls\": [\n                \"/projects/mytoken.sol\",\n                \"https://example.com/projects/mytoken.sol\"\n            ]\n        }\n    },\n    \"settings\": {\"outputSelection\": {\"*\": { \"*\": [\"metadata\", \"evm.bytecode\"]}}}\n}\n```\n\n----------------------------------------\n\nTITLE: More Import Examples\nDESCRIPTION: More import examples to demonstrate edge cases.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nsolc /project/=/contracts /project/contract.sol # source unit name: /project/contract.sol\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking the Solidity Common Library\nDESCRIPTION: This snippet adds a library named 'langutil' using the specified source files and links it with 'solutil' and 'fmt::fmt-header-only'. The 'PUBLIC' keyword makes the dependencies available to downstream projects.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/liblangutil/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(langutil ${sources})\ntarget_link_libraries(langutil PUBLIC solutil fmt::fmt-header-only)\n```\n\n----------------------------------------\n\nTITLE: FallbackManager setFallbackHandler function signature\nDESCRIPTION: This is the signature for the `setFallbackHandler` function in the `FallbackManager` contract. It sets the address of the fallback handler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nFallbackManager  setFallbackHandler(address)\n```\n\n----------------------------------------\n\nTITLE: Clone Solidity Repository Git\nDESCRIPTION: This set of commands clones the Solidity repository from GitHub and navigates into the cloned directory.  It also demonstrates how to add a personal fork as a remote.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/ethereum/solidity.git\ncd solidity\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add personal git@github.com:[username]/solidity.git\n```\n\n----------------------------------------\n\nTITLE: Updating Homebrew and installing Solidity\nDESCRIPTION: This snippet demonstrates how to update Homebrew, tap the ethereum repository, and install Solidity on macOS.  Pre-built binaries (bottles) are not supported, so it builds from source.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbrew update\nbrew upgrade\nbrew tap ethereum/ethereum\nbrew install solidity\n```\n\n----------------------------------------\n\nTITLE: EVM Yul Built-in: stop()\nDESCRIPTION: This snippet provides the Yul built-in function `stop()`.  It halts execution, behaving identically to `return(0, 0)`.  It does not return a value (`-`).  It's available since the Frontier version of the EVM.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_57\n\nLANGUAGE: none\nCODE:\n```\nstop()                  | `-` | F | stop execution, identical to return(0, 0)\n```\n\n----------------------------------------\n\nTITLE: Formatting Constructor Functions with Inherited Contracts - Solidity\nDESCRIPTION: Illustrates the recommended formatting for constructor functions on inherited contracts where the base constructors require arguments. The base constructors should be placed on new lines in the same manner as modifiers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_18\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// Base contracts just to make this compile\ncontract B {\n    constructor(uint) {\n    }\n}\n\n\ncontract C {\n    constructor(uint, uint) {\n    }\n}\n\n\ncontract D {\n    constructor(uint) {\n    }\n}\n\n\ncontract A is B, C, D {\n    uint x;\n\n    constructor(uint param1, uint param2, uint param3, uint param4, uint param5)\n        B(param1)\n        C(param2, param3)\n        D(param4)\n    {\n        // do something with param5\n        x = param5;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe approveHash function signature\nDESCRIPTION: This is the signature for the `approveHash` function in the `GnosisSafe` contract. It allows an owner to approve a specific hash.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_18\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  approveHash(bytes32)\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Shows incorrect function definition attempting to return a named fixed-size nested array `uint[2][2] a`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint[2][2] a) { }\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return with Constant (Solidity)\nDESCRIPTION: Shows an incorrect attempt to use `ContractName.ConstantName` within the size declaration of a nested array return type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (\n    uint\n    [\n    ContractName.ConstantName\n    ]\n    [2]\n    a, uint x);\n```\n\n----------------------------------------\n\nTITLE: Building Solidity with AFL\nDESCRIPTION: This bash snippet shows how to configure and build the Solidity compiler (specifically `solfuzzer`) using AFL as the compiler, for fuzzing purposes. It involves cleaning the build directory, configuring CMake with AFL compiler paths, and making the `solfuzzer` target.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd build\n# if needed\nmake clean\ncmake .. -DCMAKE_C_COMPILER=path/to/afl-gcc -DCMAKE_CXX_COMPILER=path/to/afl-g++\nmake solfuzzer\n```\n\n----------------------------------------\n\nTITLE: External Function Members in Solidity\nDESCRIPTION: This example demonstrates how to access the address and selector of an external function within a Solidity contract. It shows how to verify the contract address and retrieve the function selector using `this.f.address` and `this.f.selector`, respectively. Additionally, it showcases how to make a function call with specified gas and value using `{gas: 10, value: 800}`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_17\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.4 <0.9.0;\n\ncontract Example {\n    function f() public payable returns (bytes4) {\n        assert(this.f.address == address(this));\n        return this.f.selector;\n    }\n\n    function g() public {\n        this.f{gas: 10, value: 800}();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Subtraction Function in Solidity\nDESCRIPTION: This Solidity function performs subtraction. It will revert on underflow when `b` is greater than `a` if underflow checks are enabled.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/control-structures.rst#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\n            return a - b;\n\n```\n\n----------------------------------------\n\nTITLE: Define yul_proto_diff_custom_mutate_ossfuzz Executable (CMake)\nDESCRIPTION: This CMake snippet defines the `yul_proto_diff_custom_mutate_ossfuzz` executable, including source files, include directories, and linked libraries for protobuf fuzzing with custom mutation. It uses `protoToYul.cpp`, `yulProto.pb.cc`, and `protomutators/YulProtoMutator.cpp`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(yul_proto_diff_custom_mutate_ossfuzz\n            yulProto_diff_ossfuzz.cpp\n            yulFuzzerCommon.cpp\n            protoToYul.cpp\n            yulProto.pb.cc\n            protomutators/YulProtoMutator.cpp\n            ../../libyul/YulOptimizerTestCommon.cpp\n    )\n    target_include_directories(yul_proto_diff_custom_mutate_ossfuzz PRIVATE /usr/include/libprotobuf-mutator)\n    target_link_libraries(yul_proto_diff_custom_mutate_ossfuzz PRIVATE yul\n            yulInterpreter\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(yul_proto_diff_custom_mutate_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(yul_proto_diff_custom_mutate_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: StorageAccessible Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for accessing contract storage at specific slots. It allows for retrieving data from any storage slot and simulating and reverting a transaction. This functionality is used for testing and debugging smart contracts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_34\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface StorageAccessible {\n  function getStorageAt(uint256 slot, uint256 offset) external view returns (bytes memory);\n  function simulateAndRevert(address target, bytes calldata data) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Contract Structure: Incorrect Order of Elements in Solidity\nDESCRIPTION: This snippet demonstrates an incorrect order of elements within a Solidity contract, where the error definition is placed after the function definition. This violates the recommended style guide.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_27\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.4 <0.9.0;\n\nabstract contract Math {\n    function divide(int256 numerator, int256 denominator) public virtual returns (uint256);\n    error DivideByZero();\n}\n```\n\n----------------------------------------\n\nTITLE: Hexadecimal String Literals\nDESCRIPTION: This snippet demonstrates the use of hexadecimal string literals in Solidity.  These literals allow developers to directly specify byte sequences within their code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_32\n\nLANGUAGE: Solidity\nCODE:\n```\nhex\"ab1248fe\"\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration for Verified Contracts\nDESCRIPTION: This JSON snippet demonstrates how to specify which contracts should be analyzed as the deployed one in the SMTChecker. This can reduce the complexity of the analysis, especially for contracts with multiple inheritance.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n        \"source1.sol\": [\"contract1\"],\n        \"source2.sol\": [\"contract2\", \"contract3\"]\n    }\n```\n\n----------------------------------------\n\nTITLE: Standard Input Compilation Example\nDESCRIPTION: This bash snippet illustrates how to provide Solidity source code to the compiler via standard input. The content is then placed in the virtual filesystem under the source unit name '<stdin>'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\necho 'import \"./util.sol\"; contract C {}' | solc -\n```\n\n----------------------------------------\n\nTITLE: Solidity Compiler Command\nDESCRIPTION: This shell command compiles a Solidity contract using strict assembly and activates the Yul optimizer with an optimization runs parameter of 200. This configuration optimizes the code for contracts that are expected to be executed around 200 times.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_64\n\nLANGUAGE: sh\nCODE:\n```\nsolc --strict-assembly --optimize --optimize-runs 200\n```\n\n----------------------------------------\n\nTITLE: Build Solidity with CMake Bash\nDESCRIPTION: These commands create a build directory, navigate into it, and use CMake to configure and build the Solidity project.  This is the standard build process for Linux, macOS and other Unices. The \"make\" command compiles the code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd build\ncmake .. && make\n```\n\n----------------------------------------\n\nTITLE: Run Docker Container for Solidity Fuzzing\nDESCRIPTION: These commands first navigate to the solidity directory on the host machine, and then run a Docker container sourced from the `solidity-ossfuzz-local` image.  The current working directory (`pwd`) is mounted as a volume at `/src/solidity` inside the container.  Finally, the commands change the directory to /src/solidity inside the docker container.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n## Host\n$ cd solidity\n$ docker run -v `pwd`:/src/solidity -ti solidity-ossfuzz-local /bin/bash\n## Docker shell\n$ cd /src/solidity\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Error in Solidity\nDESCRIPTION: This code snippet shows how to define a custom error `NotEnoughFunds` with parameters `requested` and `available`. It also demonstrates how to use the error in a `revert` statement within the `transfer` function.  The NatSpec style comment is also included for documentation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// Not enough funds for transfer. Requested `requested`,\n/// but only `available` available.\nerror NotEnoughFunds(uint requested, uint available);\n\ncontract Token {\n    mapping(address => uint) balances;\n    function transfer(address to, uint amount) public {\n        uint balance = balances[msg.sender];\n        if (balance < amount)\n            revert NotEnoughFunds(amount, balance);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Emscripten Linking in CMake\nDESCRIPTION: This CMake snippet conditionally links the `solidity` library with the `z3::libz3` library when building with Emscripten. It first checks if Emscripten is enabled and Z3 is found. If Z3 is not found, the build process will terminate with an error message indicating Z3 is a required dependency for Emscripten builds.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolidity/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif (EMSCRIPTEN)\n    if(NOT ${Z3_FOUND})\n            message(FATAL_ERROR \"Z3 library must be present for EMSCRIPTEN build\")\n    endif()\n    target_link_libraries(solidity PUBLIC z3::libz3)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Function Type Declaration in Solidity\nDESCRIPTION: This snippet shows how to declare a variable whose type is a function type. The variable `foo` is declared as a function that takes an address as input and returns an address. This is different from a function without implementation, as this defines a variable that can hold a function reference, rather than an abstract function definition.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/abstract-contracts.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\nfunction(address) external returns (address) foo;\n```\n\n----------------------------------------\n\nTITLE: Conditional OSSFuzz Proto Targets (CMake)\nDESCRIPTION: This snippet conditionally defines custom targets related to protobuf fuzzing if the `OSSFUZZ` flag is enabled. It sets up `ossfuzz_proto` and `ossfuzz_abiv2` targets along with their respective dependencies such as `sol_proto_ossfuzz`, `yul_proto_ossfuzz`, `yul_proto_diff_ossfuzz`, `yul_proto_diff_custom_mutate_ossfuzz`, `stack_reuse_codegen_ossfuzz`, `abiv2_proto_ossfuzz` and `abiv2_isabelle_ossfuzz`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_custom_target(ossfuzz_proto)\n    add_dependencies(ossfuzz_proto\n            sol_proto_ossfuzz\n            yul_proto_ossfuzz\n            yul_proto_diff_ossfuzz\n            yul_proto_diff_custom_mutate_ossfuzz\n            stack_reuse_codegen_ossfuzz\n    )\n\n    add_custom_target(ossfuzz_abiv2)\n    add_dependencies(ossfuzz_abiv2 abiv2_proto_ossfuzz abiv2_isabelle_ossfuzz)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly\nDESCRIPTION: Shows an example of how inline assembly is used.  Inline assembly allows for more fine-grained control over the EVM and can be used to optimize gas costs.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_35\n\nLANGUAGE: Solidity\nCODE:\n```\n// Inline assembly\n```\n\n----------------------------------------\n\nTITLE: ERC20Token balanceOf function signature\nDESCRIPTION: This is the signature for the `balanceOf` function in the `ERC20Token` contract. It takes an address as a parameter and returns the token balance for that address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  balanceOf(address)\n```\n\n----------------------------------------\n\nTITLE: Dangling Storage References in Solidity\nDESCRIPTION: This Solidity code demonstrates how dangling references to storage array elements can occur, especially when using `.pop()` on an array and then writing to a pointer that was referencing the popped element. It also shows how `s.push()` after `ptr.push(0x42)` can result in unexpected array state.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/reference-types.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ncontract C {\n    uint[][] s;\n\n    function f() public {\n        // Stores a pointer to the last array element of s.\n        uint[] storage ptr = s[s.length - 1];\n        // Removes the last array element of s.\n        s.pop();\n        // Writes to the array element that is no longer within the array.\n        ptr.push(0x42);\n        // Adding a new element to ``s`` now will not add an empty array, but\n        // will result in an array of length 1 with ``0x42`` as element.\n        s.push();\n        assert(s[s.length - 1][0] == 0x42);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateCallTransactionGuard Interface in Solidity\nDESCRIPTION: These are interface definitions for the DelegateCallTransactionGuard contract which manages transaction checks and execution permissions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nDelegateCallTransactionGuard    allowedTarget()\nDelegateCallTransactionGuard    checkAfterExecution(bytes32,bool)\nDelegateCallTransactionGuard    checkTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes,address)\nDelegateCallTransactionGuard    supportsInterface(bytes4)\n```\n\n----------------------------------------\n\nTITLE: Handling Dependencies\nDESCRIPTION: This snippet includes EthDependencies and handles finding dependencies like fmtlib, nlohmann-json, and range-v3. If IGNORE_VENDORED_DEPENDENCIES is not set, it includes the vendored versions; otherwise, it uses `find_package` to locate system-wide installations and emits a warning if vendored dependencies are ignored.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\n# Let's find our dependencies\ninclude(EthDependencies)\nif (NOT IGNORE_VENDORED_DEPENDENCIES)\n  include(fmtlib)\n  include(nlohmann-json)\n  include(range-v3)\nelse ()\n  message(WARNING \"-- Ignoring vendored dependencies. Will use installed versions if found. Versions may differ from the ones the compiler was tested with. Make sure to run the test suite and thoroughly test the resulting binaries before using them in production.\")\n  find_package(fmt REQUIRED)\n  find_package(nlohmann_json REQUIRED)\n  find_package(range-v3 REQUIRED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: SMTChecker Assertion Violation Warning\nDESCRIPTION: This text snippet displays the warning generated by the SMTChecker when an assertion violation is detected in the `Max` contract. The counterexample shows that the array `a` consisting of all zeros triggers the assertion violation, and the transaction trace pinpoints the location of the failure within the `max` function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_6\n\nLANGUAGE: Text\nCODE:\n```\nWarning: CHC: Assertion violation happens here.\nCounterexample:\n\na = [0, 0, 0, 0, 0]\n = 0\n\nTransaction trace:\nTest.constructor()\nTest.max([0, 0, 0, 0, 0])\n  --> max.sol:14:4:\n   |\n14 |            assert(m > a[i]);\n```\n\n----------------------------------------\n\nTITLE: Introduce blobhash Builtin Yul\nDESCRIPTION: This snippet introduces the `blobhash()` builtin in Yul.  This builtin retrieves versioned hashes of blobs associated with the transaction. It provides low-level access to blob data, enabling advanced usage patterns involving EIP-4844 and blob transactions within Yul code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nYul: Introduce builtin ``blobhash()`` for retrieving versioned hashes of blobs associated with the transaction.\n```\n\n----------------------------------------\n\nTITLE: Block Flattening Example in Yul\nDESCRIPTION: This example demonstrates how the BlockFlattener optimization stage eliminates nested blocks in Yul code by inserting the statements from the inner block into the outer block. It requires disambiguation to ensure variable scopes remain correct.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_14\n\nLANGUAGE: yul\nCODE:\n```\n{\n    {\n        let x := 2\n        {\n            let y := 3\n            mstore(x, y)\n        }\n    }\n}\n```\n\nLANGUAGE: yul\nCODE:\n```\n{\n    {\n        let x := 2\n        let y := 3\n        mstore(x, y)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ERC20Token approve function signature\nDESCRIPTION: This is the signature for the `approve` function in the `ERC20Token` contract. It takes an address and a uint256 as parameters, used for approving token transfers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  approve(address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Handling Z3 Dependency for Emscripten\nDESCRIPTION: This snippet specifically handles the Z3 solver dependency for Emscripten builds. It sets expected and minimum versions, uses `find_package(Z3)` to locate the library, and checks if the found version meets the requirements defined in `STRICT_Z3_VERSION`. It also adds the `EMSCRIPTEN_BUILD` definition.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nif(EMSCRIPTEN)\n    set(TESTED_Z3_VERSION \"4.13.3\")\n    set(MINIMUM_Z3_VERSION \"4.8.16\")\n    find_package(Z3)\n    if (${Z3_FOUND})\n      add_definitions(-DEMSCRIPTEN_BUILD)\n      if (${STRICT_Z3_VERSION})\n        if (NOT (\"${Z3_VERSION_STRING}\" VERSION_EQUAL ${TESTED_Z3_VERSION}))\n          message(\n            FATAL_ERROR\n            \"SMTChecker tests require Z3 ${TESTED_Z3_VERSION} for all tests to pass.\\n\"\n          )\n        endif()\n      else()\n        if (\"${Z3_VERSION_STRING}\" VERSION_LESS ${MINIMUM_Z3_VERSION})\n          message(\n            FATAL_ERROR\n            \"Solidity requires Z3 ${MINIMUM_Z3_VERSION} or newer.\\n\"\n          )\n        endif()\n      endif()\n    else()\n        message(FATAL_ERROR \"Solidity requires Z3 for emscripten build.\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct Type in Solidity\nDESCRIPTION: This code snippet demonstrates how to define a struct type named `Voter` within a Solidity contract called `Ballot`. The struct contains members `weight` (uint), `voted` (bool), `delegate` (address), and `vote` (uint).  The SPDX license identifier and pragma solidity directive are also present.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Ballot {\n    struct Voter { // Struct\n        uint weight;\n        bool voted;\n        address delegate;\n        uint vote;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Build Fuzzer Harnesses with CMake\nDESCRIPTION: This set of commands prepares the build environment for the fuzzers, compiles the protobuf C++ bindings, and then uses CMake to generate the necessary build files and make to compile the fuzzer targets. It defines the C and C++ compilers to use clang and clang++, and specifies the libfuzzer toolchain file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n## Docker shell\n$ cd /src/solidity\n$ rm -rf fuzzer-build && mkdir fuzzer-build && cd fuzzer-build\n## Compile protobuf C++ bindings\n$ protoc --proto_path=../test/tools/ossfuzz yulProto.proto --cpp_out=../test/tools/ossfuzz\n$ protoc --proto_path=../test/tools/ossfuzz abiV2Proto.proto --cpp_out=../test/tools/ossfuzz\n$ protoc --proto_path=../test/tools/ossfuzz solProto.proto --cpp_out=../test/tools/ossfuzz\n## Run cmake\n$ export CC=clang CXX=clang++\n$ cmake -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/libfuzzer.cmake -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE:-Release} ..\n$ make ossfuzz ossfuzz_proto ossfuzz_abiv2 -j\n```\n\n----------------------------------------\n\nTITLE: Hello World Contract in Solidity\nDESCRIPTION: This snippet demonstrates a simple \"Hello World\" contract in Solidity. It defines a contract named HelloWorld with a function helloWorld that returns the string \"Hello, World!\". This contract uses Solidity version 0.6.0 or higher but less than 0.9.0, and it is licensed under the MIT license.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/README.md#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\ncontract HelloWorld {\n    function helloWorld() external pure returns (string memory) {\n        return \"Hello, World!\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Shows incorrect function declaration attempting to return a named fixed-size nested array `uint[200][2] a` and a uint.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint[200][2] a, uint x);\n```\n\n----------------------------------------\n\nTITLE: Compiling Solidity files with Docker\nDESCRIPTION: This snippet demonstrates how to use the Solidity compiler in a Docker container to compile files on the host machine.  It mounts a local directory to the container, specifies the contract to compile and outputs the ABI and binary to a subdirectory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run \\\n    --volume \"/tmp/some/local/path/:/sources/\" \\\n    ethereum/solc:stable \\\n        /sources/Contract.sol \\\n        --abi \\\n        --bin \\\n        --output-dir /sources/output/\n```\n\n----------------------------------------\n\nTITLE: ERC20Token decreaseAllowance function signature\nDESCRIPTION: This is the signature for the `decreaseAllowance` function in the `ERC20Token` contract.  It allows decreasing the allowance of a spender for a given account.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  decreaseAllowance(address,uint256)\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Function Definition Evaluation\nDESCRIPTION: This snippet provides the formal evaluation function `E` for a Yul function definition.  The function definition itself does not alter the state, so it simply returns the existing global and local states along with the 'regular' mode, indicating normal execution flow.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_42\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, FunctionDefinition) =\n    G, L, regular\n```\n\n----------------------------------------\n\nTITLE: Update Shift Operator Operand Types in Solidity\nDESCRIPTION: Updates the types of right operands in shift operators to unsigned types in Solidity. This avoids potential runtime errors that occur when shifting by negative amounts.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/070-breaking-changes.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nx >> uint(256 - y)\n```\n\n----------------------------------------\n\nTITLE: Listing contributors for Solidity release notes\nDESCRIPTION: This command lists the contributors since the previous version of Solidity.  The output is used to thank voluntary contributors in the GitHub release notes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nscripts/list_contributors.sh v<previous version>\n```\n\n----------------------------------------\n\nTITLE: Implicit Integer Literal Conversion in Solidity\nDESCRIPTION: Demonstrates implicit conversion of decimal and hexadecimal number literals to integer types in Solidity, given that the integer type is large enough to represent the literal without truncation. This highlights the compiler's ability to automatically convert number literals to appropriate integer types when there is no risk of data loss.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_8\n\nLANGUAGE: solidity\nCODE:\n```\nuint8 a = 12; // fine\nuint32 b = 1234; // fine\nuint16 c = 0x123456; // fails, since it would have to truncate to 0x3456\n```\n\n----------------------------------------\n\nTITLE: Introduce blobbasefee Builtin Yul\nDESCRIPTION: This snippet introduces the `blobbasefee()` builtin in Yul. This builtin retrieves the blob base fee of the current block.  It is part of the support for EIP-4844 and blob transactions at the Yul level, providing low-level access to the blob base fee.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nYul: Introduce builtin ``blobbasefee()`` for retrieving the blob base fee of the current block.\n```\n\n----------------------------------------\n\nTITLE: Buggy: Exponentiation Operator (Solidity)\nDESCRIPTION: Shows a potentially problematic use of the exponentiation operator `**` without a constant exponent. Variable `x` is raised to the power of `y`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\nx ** y\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe execTransaction function signature\nDESCRIPTION: This is the signature for the `execTransaction` function in the `GnosisSafe` contract. It executes a transaction with the provided parameters.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_26\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)\n```\n\n----------------------------------------\n\nTITLE: Unchecked Loop Increment Example\nDESCRIPTION: Illustrates a `for` loop structure eligible for the unchecked loop increment optimization in Solidity. This optimization removes overflow checks for the loop counter variable, `i`, under specific conditions, improving gas efficiency.  The loop counter must be of an integer type and only incremented without modifications within the loop body or condition.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_21\n\nLANGUAGE: solidity\nCODE:\n```\nfor (uint i = X; i < Y; ++i) {\n    // variable i is not modified in the loop body\n}\n```\n\n----------------------------------------\n\nTITLE: Build Solidity with CMake Build Command\nDESCRIPTION: This command-line command builds the Solidity project after CMake configuration, specifying the 'Release' configuration.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncmake --build . --config Release\n```\n\n----------------------------------------\n\nTITLE: Conditionally linking solc statically CMake\nDESCRIPTION: This snippet conditionally sets the linking flags for the `solc` executable to produce a statically linked binary. This is done only if `SOLC_LINK_STATIC` is enabled and the platform is Unix-like but not macOS. Alternatively, if `SOLC_STATIC_STDLIBS` is enabled, only the standard libraries are linked statically.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(SOLC_LINK_STATIC AND UNIX AND NOT APPLE)\n\t# Produce solc as statically linked binary (includes C/C++ standard libraries)\n\t# This is not supported on macOS, see\n\t# https://developer.apple.com/library/content/qa/qa1118/_index.html.\n\tset_target_properties(\n\t\tsolc PROPERTIES\n\t\tLINK_FLAGS -static\n\t\tLINK_SEARCH_START_STATIC ON\n\t\tLINK_SEARCH_END_STATIC ON\n\t)\nelif(SOLC_STATIC_STDLIBS AND UNIX AND NOT APPLE)\n\tset_target_properties(\n\t\tsolc PROPERTIES\n\t\tLINK_FLAGS \"-static-libgcc -static-libstdc++\"\n\t)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Yul Assignment with Multiplication in Named Object\nDESCRIPTION: This snippet shows Yul code wrapped within a named object \"Test\".  It assigns the result of multiplying 3 and 5 to the variable 'y'. It utilizes the `:linenos:` directive to display line numbers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_7\n\nLANGUAGE: Yul\nCODE:\n```\n// Yul code wrapped in named object\nobject \"Test\" {\n    let y := mul(3, 5)\n:linenos:\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Long Function Declarations with Modifiers - Solidity\nDESCRIPTION: Shows the recommended style for formatting long function declarations with modifiers in Solidity. Each modifier should be dropped to its own line.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_16\n\nLANGUAGE: solidity\nCODE:\n```\nfunction thisFunctionNameIsReallyLong(address x, address y, address z)\n    public\n    onlyOwner\n    priced\n    returns (address)\n{\n    doSomething();\n}\n\nfunction thisFunctionNameIsReallyLong(\n    address x,\n    address y,\n    address z\n)\n    public\n    onlyOwner\n    priced\n    returns (address)\n{\n    doSomething();\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Binary Code\nDESCRIPTION: This snippet shows the compiled bytecode of the Solidity contract 'C'. It represents the machine-executable instructions that will be deployed and executed on the Ethereum Virtual Machine (EVM). This bytecode is the direct output of the Solidity compiler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/solc_0.4.8_cli_output.txt#_snippet_1\n\nLANGUAGE: Binary\nCODE:\n```\n6060604052346000575b60358060166000396000f30060606040525b60005600a165627a7a72305820ccf9337430b4c4f7d6ad41efb10a94411a2af6a9f173ef52daeadd31f4bf11890029\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - If Statement Evaluation\nDESCRIPTION: This snippet provides the formal evaluation function `E` for the Yul `if` statement. It evaluates the condition, and if true, evaluates the body; otherwise, it returns the original states and the `regular` mode, skipping the body.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_49\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <if condition body>: If) =\n    let G0, L0, v = E(G, L, condition)\n    if v is true:\n        E(G0, L0, body)\n    else:\n        G0, L0, regular\n```\n\n----------------------------------------\n\nTITLE: For Loop Condition Out of Body Transformation (Example 2)\nDESCRIPTION: Demonstrates another transformation of a `for` loop condition.  This time, it converts a loop using `if c { break }` into a loop using `iszero(c)` as the condition. Similar to the previous snippet, it optimizes the loop condition based on the control flow and potentially benefits from earlier transformations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_20\n\nLANGUAGE: none\nCODE:\n```\nfor { ... } 1 { ... } {\n    if c { break }\n    ...\n}\n```\n\nLANGUAGE: none\nCODE:\n```\nfor { ... } iszero(c) { ... } {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Multiplication in Named Object\nDESCRIPTION: This Yul code snippet shows how to encapsulate Yul code within a named object called \"Test\".  It multiplies 6 and 9, assigning the result to the variable 'y'. This emphasizes the organizational capabilities provided by objects in Yul.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block.rst#_snippet_4\n\nLANGUAGE: yul\nCODE:\n```\n// Yul code wrapped in named object\nobject \"Test\" {\n    {\n        let y := mul(6, 9)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buggy: Event Struct with ABIEncoderV2 (Solidity)\nDESCRIPTION: Demonstrates a contract `C` with a struct `S` and events `E` and `F` that use the struct as data, potentially leading to issues with ABIEncoderV2.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_22\n\nLANGUAGE: Solidity\nCODE:\n```\npragma experimental ABIEncoderV2;\ncontract C\n{\n\tstruct S { uint x; }\n\tevent E(S);\n\tevent F(S);\n\tenum A { B, C }\n\tevent G(A);\n\tfunction f(S s);\n}\n```\n\n----------------------------------------\n\nTITLE: Template Snippets\nDESCRIPTION: These snippets appear to be template assignments, where `templ` is likely a function or macro that assigns a value based on a condition. The `dynamic` variable controls whether the assigned value is \"end := pos\" or an empty string, suggesting conditional code generation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/scripts/codespell_ignored_lines.txt#_snippet_3\n\nLANGUAGE: Unknown\nCODE:\n```\n<assignEnd>\n\t\t\t\t\t<assignEnd>\n\t\t\t\t\t\t<assignEnd>\n\t\ttempl(\"assignEnd\", dynamic ? \"end := pos\" : \"\");\n\t\t\ttempl(\"assignEnd\", dynamic ? \"end := pos\" : \"\");\n\t\t\ttempl(\"assignEnd\", \"end := pos\");\n\t\t\ttempl(\"assignEnd\", \"end := tail\");\n\t\t\ttempl(\"assignEnd\", \"\");\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe disableModule function signature\nDESCRIPTION: This is the signature for the `disableModule` function in the `GnosisSafe` contract. It disables a module at a given address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_22\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  disableModule(address,address)\n```\n\n----------------------------------------\n\nTITLE: Address Payable Declaration in Solidity 0.5.0\nDESCRIPTION: This snippet explains the requirement of declaring variables as `address payable` to use the `transfer` function on them in Solidity 0.5.0. This ensures that the recipient address can receive Ether.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_29\n\nLANGUAGE: Solidity\nCODE:\n```\nDeclare variables and especially function arguments as ``address payable``, if you want to call ``transfer`` on them.\n```\n\n----------------------------------------\n\nTITLE: Accessing Super Contract in Solidity\nDESCRIPTION: Refers to the contract one level higher in the inheritance hierarchy.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\nsuper\n```\n\n----------------------------------------\n\nTITLE: ERC20Token decimals function signature\nDESCRIPTION: This is the signature for the `decimals` function in the `ERC20Token` contract. It returns the number of decimals used by the token.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  decimals()\n```\n\n----------------------------------------\n\nTITLE: Super Constructor Calls - Solidity\nDESCRIPTION: Introduces the ability to call super constructors using member notation (e.g., ``M.C(123)``). This allows for more explicit and readable constructor calls in inheritance scenarios.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_16\n\nLANGUAGE: Solidity\nCODE:\n```\nM.C(123)\n```\n\n----------------------------------------\n\nTITLE: Including GNUInstallDirs in CMake\nDESCRIPTION: This snippet includes the `GNUInstallDirs` module, which provides standard installation directories for CMake projects. This allows for consistent and predictable installation locations across different platforms. It is a prerequisite for the install command.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GNUInstallDirs)\n```\n\n----------------------------------------\n\nTITLE: Unchecked Loop Increment Type Conversion Example\nDESCRIPTION: Shows a `for` loop that is NOT eligible for the unchecked loop increment optimization. This is because the loop condition involves an implicit type conversion from `uint8` to `uint16` before the comparison, which could potentially lead to incorrect behavior if the overflow check is removed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_22\n\nLANGUAGE: solidity\nCODE:\n```\nfor (uint8 i = 0; i < uint16(1000); i++) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Solver Selection via JSON Option\nDESCRIPTION: This snippet demonstrates how to configure SMT solvers using the JSON settings option. This method provides an alternative way to specify the desired solvers for the model checker.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_18\n\nLANGUAGE: JSON\nCODE:\n```\nsettings.modelChecker.solvers=[smtlib2,z3]\n```\n\n----------------------------------------\n\nTITLE: Including EthCcache\nDESCRIPTION: This snippet includes the EthCcache CMake module, which is likely used to configure ccache for faster build times by caching compiler outputs.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\n# Setup cccache.\ninclude(EthCcache)\n```\n\n----------------------------------------\n\nTITLE: Define abiv2_proto_ossfuzz Executable (CMake)\nDESCRIPTION: This CMake snippet defines the `abiv2_proto_ossfuzz` executable for ABIv2 protobuf fuzzing. It includes source files like `../../EVMHost.cpp`, `abiV2ProtoFuzzer.cpp`, `SolidityEvmoneInterface.cpp`, `protoToAbiV2.cpp`, and `abiV2Proto.pb.cc`. It links against libraries like `solidity`, `evmc`, `evmone-standalone`, and the protobuf mutator libraries.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(abiv2_proto_ossfuzz\n            ../../EVMHost.cpp\n            abiV2ProtoFuzzer.cpp\n            SolidityEvmoneInterface.cpp\n            protoToAbiV2.cpp\n            abiV2Proto.pb.cc\n    )\n    target_include_directories(abiv2_proto_ossfuzz PRIVATE\n            /usr/include/libprotobuf-mutator\n    )\n    target_link_libraries(abiv2_proto_ossfuzz PRIVATE solidity\n            evmc\n            evmone-standalone\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(abiv2_proto_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(abiv2_proto_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generate Standard Library Headers with CMake\nDESCRIPTION: This snippet iterates through a list of Solidity source files (STDLIB), reads their content, converts it to hexadecimal representation, and creates corresponding header files using the configure_file command. The generated header files are stored in the ${PROJECT_BINARY_DIR}/include/libstdlib/ directory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libstdlib/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(STDLIB stub)\nset(GENERATED_STDLIB_HEADERS)\nforeach(src IN LISTS STDLIB)\n    set(STDLIB_FILE ${CMAKE_CURRENT_SOURCE_DIR}/src/${src}.sol)\n    file(READ ${STDLIB_FILE} STDLIB_FILE_CONTENT HEX)\n    string(REGEX MATCHALL \"..\" STDLIB_FILE_CONTENT \"${STDLIB_FILE_CONTENT}\")\n    list(REMOVE_ITEM STDLIB_FILE_CONTENT \"0d\")\n    string(REGEX REPLACE \";\" \",\\n\\t0x\" STDLIB_FILE_CONTENT \"${STDLIB_FILE_CONTENT}\")\n    set(STDLIB_FILE_CONTENT \"0x${STDLIB_FILE_CONTENT}\")\n    set(STDLIB_FILE_NAME ${src})\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/stdlib.src.h.in\" ${PROJECT_BINARY_DIR}/include/libstdlib/${src}.h NEWLINE_STYLE LF @ONLY)\n    list(APPEND GENERATED_STDLIB_HEADERS ${PROJECT_BINARY_DIR}/include/libstdlib/${src}.h)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Solidity Internal vs External Access\nDESCRIPTION: This example clarifies the difference between internal and external access of public state variables. Internal access (e.g., `data = 3;`) directly modifies the state variable, while external access (e.g., `this.data();`) calls the automatically generated getter function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/visibility-and-getters.rst#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract C {\n    uint public data;\n    function x() public returns (uint) {\n        data = 3; // internal access\n        return this.data(); // external access\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buggy: Indexed Event Struct with ABIEncoderV2 (Solidity)\nDESCRIPTION: Shows a contract `C` with a struct `S` and events `E` (indexed) and `F` that use the struct as data, potentially leading to issues with ABIEncoderV2 when using indexed structs.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_23\n\nLANGUAGE: Solidity\nCODE:\n```\npragma experimental ABIEncoderV2;\ncontract C\n{\n\tstruct S { uint x; }\n\tevent E(S indexed);\n\tevent F(uint, S, bool);\n}\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe enableModule function signature\nDESCRIPTION: This is the signature for the `enableModule` function in the `GnosisSafe` contract. It enables a module at a given address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_24\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  enableModule(address)\n```\n\n----------------------------------------\n\nTITLE: Defining DefaultCallbackHandler Interface in Solidity\nDESCRIPTION: This snippet presents the interface definitions for the DefaultCallbackHandler contract. It includes functions to handle ERC1155 and ERC721 token receptions, as well as a function to support interface checks and a token received handler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nDefaultCallbackHandler          onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\nDefaultCallbackHandler          onERC1155Received(address,address,uint256,uint256,bytes)\nDefaultCallbackHandler          onERC721Received(address,address,uint256,bytes)\nDefaultCallbackHandler          supportsInterface(bytes4)\nDefaultCallbackHandler          tokensReceived(address,address,address,uint256,bytes,bytes)\nDefaultCallbackHandler          VERSION()\n```\n\n----------------------------------------\n\nTITLE: ReentrancyTransactionGuard Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for preventing reentrancy attacks. Includes functions to check the transaction before and after execution. It checks if a transaction is safe to execute and prevents malicious contracts from exploiting vulnerabilities during external calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_31\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface ReentrancyTransactionGuard {\n  function checkAfterExecution(bytes32 txHash, bool success) external;\n  function checkTransaction(address to, uint256 value, bytes calldata data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes calldata signatures, address msgSender) external;\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking solutil Library (CMake)\nDESCRIPTION: This snippet creates the `solutil` library and links it to its dependencies.  It specifies the Boost, range-v3, fmt, and nlohmann_json libraries. `PROJECT_SOURCE_DIR` is added to the include directories so headers can be found. The target is also made dependent on `solidity_BuildInfo.h`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolutil/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(solutil ${sources})\ntarget_link_libraries(solutil PUBLIC Boost::boost Boost::filesystem Boost::system range-v3 fmt::fmt-header-only nlohmann_json::nlohmann_json)\ntarget_include_directories(solutil PUBLIC \"${PROJECT_SOURCE_DIR}\")\nadd_dependencies(solutil solidity_BuildInfo.h)\n```\n\n----------------------------------------\n\nTITLE: Function Specialization Example Yul\nDESCRIPTION: This snippet shows how a function called with literal arguments can be specialized by creating a new function that takes only the non-literal arguments and uses the literal values directly. This allows for further simplifications and optimizations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_15\n\nLANGUAGE: yul\nCODE:\n```\nfunction f_1(a_1) {\n        let b_1 := 5\n        sstore(a_1, b_1)\n    }\n```\n\n----------------------------------------\n\nTITLE: Solidity Import All as Symbol\nDESCRIPTION: This code snippet shows how to import all global symbols from another Solidity file and assign them to a new global symbol.  This provides a namespaced access to the imported symbols, using `symbolName.symbol`. This syntax is useful to avoid naming collisions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_6\n\nLANGUAGE: Solidity\nCODE:\n```\nimport * as symbolName from \"filename\";\n```\n\n----------------------------------------\n\nTITLE: Path Redirects Using solc\nDESCRIPTION: This code snippet demonstrates how to redirect import paths using the `solc` commandline compiler. It instructs the compiler to search for files starting with `github.com/ethereum/dapp-bin/` under `/usr/local/lib/dapp-bin/` when resolving imports in `file.sol`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/using-the-compiler.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsolc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ file.sol\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum Type in Solidity\nDESCRIPTION: This code snippet shows how to define an enum type named `State` with values `Created`, `Locked`, and `Inactive` inside a Solidity contract named `Purchase`.  The enum allows defining custom types with a finite set of constant values.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/structure-of-a-contract.rst#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Purchase {\n    enum State { Created, Locked, Inactive } // Enum\n}\n```\n\n----------------------------------------\n\nTITLE: Running Solidity compiler with Docker using --help\nDESCRIPTION: This snippet demonstrates how to run the Solidity compiler within a Docker container, pulling the stable version and passing the `--help` argument to display compiler options.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run ethereum/solc:stable --help\n```\n\n----------------------------------------\n\nTITLE: Installing the yul-phaser executable with CMake\nDESCRIPTION: This snippet installs the `yul-phaser` executable to the directory specified by the `CMAKE_INSTALL_BINDIR` variable. The `CMAKE_INSTALL_BINDIR` variable is typically defined by `GNUInstallDirs` and represents the standard location for executable files on the target system.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS yul-phaser DESTINATION \"${CMAKE_INSTALL_BINDIR}\")\n```\n\n----------------------------------------\n\nTITLE: Solidity Simplification Example\nDESCRIPTION: This code snippet demonstrates how the Solidity optimizer can simplify code by evaluating conditions known at compile time. The initial code contains a conditional statement that is always false, allowing the optimizer to remove it and return a fixed value.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nuint x = 7;\ndata[7] = 9;\nif (data[x] != x + 2) // this condition is never true\n  return 2;\nelse\n  return 1;\n```\n\nLANGUAGE: solidity\nCODE:\n```\ndata[7] = 9;\nreturn 1;\n```\n\n----------------------------------------\n\nTITLE: Adding Definition for Profiling Optimizer Steps\nDESCRIPTION: This snippet adds a compiler definition `-DPROFILE_OPTIMIZER_STEPS` if the `PROFILE_OPTIMIZER_STEPS` option is enabled. This definition likely enables the output of performance metrics for the optimizer steps during compilation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif (PROFILE_OPTIMIZER_STEPS)\n    add_definitions(-DPROFILE_OPTIMIZER_STEPS)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Serve Solidity Docs with Python HTTP Server\nDESCRIPTION: This Python command starts a simple HTTP server to serve the generated Solidity documentation. The server serves files from the `_build/html` directory on port 8080, enabling access via http://localhost:8080. The `--cgi` flag enables CGI support.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npython3 -m http.server -d _build/html --cgi 8080\n```\n\n----------------------------------------\n\nTITLE: Yul Addition Operation\nDESCRIPTION: This Yul snippet demonstrates a simple addition operation. It assigns the result of adding 1 and 5 to the variable 'x'. This highlights the low-level, assembly-like nature of Yul.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block.rst#_snippet_2\n\nLANGUAGE: yul\nCODE:\n```\nlet x := add(1, 5)\n```\n\n----------------------------------------\n\nTITLE: Complex Import Remapping Example\nDESCRIPTION: This command-line example showcases a more complex scenario of import remapping with Solidity, involving different modules and base paths. It allows specifying different remappings for different modules, enabling the use of multiple versions of the same dependency.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsolc module1:github.com/ethereum/dapp-bin/=dapp-bin/ \\\n         module2:github.com/ethereum/dapp-bin/=dapp-bin_old/ \\\n         --base-path /project \\\n         source.sol\n```\n\n----------------------------------------\n\nTITLE: Memory Pointer Limit Enforcement (Solidity)\nDESCRIPTION: Shows that the new code generator imposes a hard limit on the free memory pointer. The example demonstrates how allocations exceeding this limit will now revert, contrasting the old code generator behavior which would simply run out of gas. Core functionality involves dynamic memory allocation and error handling.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >0.8.0;\ncontract C {\n    function f() public {\n        uint[] memory arr;\n        // allocation size: 576460752303423481\n        // assumes freeMemPtr points to 0x80 initially\n        uint solYulMaxAllocationBeforeMemPtrOverflow = (type(uint64).max - 0x80 - 31) / 32;\n        // freeMemPtr overflows UINT64_MAX\n        arr = new uint[](solYulMaxAllocationBeforeMemPtrOverflow);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ModuleManager Interface Definition (Solidity)\nDESCRIPTION: Defines the interface for managing modules within a smart contract. It includes functions for executing transactions from a module, retrieving modules in a paginated manner, and checking if a module is enabled. This interface allows for a modular and extensible smart contract architecture.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_28\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface ModuleManager {\n  function execTransactionFromModule(address to, uint256 value, bytes calldata data, uint8 operation) external;\n  function execTransactionFromModuleReturnData(address to, uint256 value, bytes calldata data, uint8 operation) external returns (bytes memory);\n  function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory, address memory);\n  function isModuleEnabled(address module) external view returns (bool);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing solc executable CMake\nDESCRIPTION: This snippet installs the `solc` executable to the installation directory defined by `CMAKE_INSTALL_BINDIR`. It utilizes the `GNUInstallDirs` module to determine the standard binary installation directory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(GNUInstallDirs)\ninstall(TARGETS solc DESTINATION \"${CMAKE_INSTALL_BINDIR}\")\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for libsolidity_util\nDESCRIPTION: This code snippet defines the source files for the `libsolidity_util` library, containing utility functions for `libsolidity`.  Includes utilities for bytes, contract ABIs, and test file parsing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(libsolidity_util_sources\n    libsolidity/util/BytesUtils.cpp\n    libsolidity/util/BytesUtilsTests.cpp\n    libsolidity/util/BytesUtils.h\n    libsolidity/util/Common.cpp\n    libsolidity/util/Common.h\n    libsolidity/util/ContractABIUtils.cpp\n    libsolidity/util/ContractABIUtils.h\n    libsolidity/util/SoltestErrors.h\n    libsolidity/util/SoltestTypes.h\n    libsolidity/util/TestFileParser.cpp\n    libsolidity/util/TestFileParser.h\n    libsolidity/util/TestFileParserTests.cpp\n    libsolidity/util/TestFunctionCall.cpp\n    libsolidity/util/TestFunctionCall.h\n    libsolidity/util/TestFunctionCallTests.cpp\n)\ndetect_stray_source_files(\"${libsolidity_util_sources}\" \"libsolidity/util/\")\n```\n\n----------------------------------------\n\nTITLE: ForLoopInitRewriter Transformation\nDESCRIPTION: This transformation moves the initialization part of a `for` loop to before the loop. The example shows how a standard for loop with initialization, condition, and post-loop statements is transformed so that the initialization statements are extracted and placed before the loop itself.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nfor { Init... } C { Post... } {\n    Body...\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nInit...\nfor {} C { Post... } {\n    Body...\n}\n```\n\n----------------------------------------\n\nTITLE: SMTChecker Abstract Function Nondeterminism\nDESCRIPTION: Allows function definitions to be annotated with the custom Natspec tag `@custom:smtchecker abstract-function-nondet`.  This causes the function to be abstracted by a nondeterministic value during SMT checking, useful for modeling external or complex functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\ncustom:smtchecker abstract-function-nondet\n```\n\n----------------------------------------\n\nTITLE: ForLoopConditionIntoBody Transformation\nDESCRIPTION: This transformation moves the loop-iteration condition of a ``for`` loop into loop body. This is done so the expression splitter can apply to the iteration condition expression. The example illustrates converting a standard for loop structure into an equivalent structure with the condition inside the loop body.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nfor { Init... } C { Post... } {\n    Body...\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nfor { Init... } 1 { Post... } {\n    if iszero(C) { break }\n    Body...\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapped Assignment Statements - Solidity\nDESCRIPTION: This snippet shows how to properly format long assignment statements in Solidity. When a function call within an assignment exceeds the line length, each argument should be placed on a new line with an indent.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nthisIsALongNestedMapping[being][set][toSomeValue] = someFunction(\n    argument1,\n    argument2,\n    argument3,\n    argument4\n);\n```\n\n----------------------------------------\n\nTITLE: Isoltest Failure Output Example\nDESCRIPTION: This text snippet shows the output of a failed isoltest run. It displays the contract code, the expected error, and the obtained result, which in this case is a 'Success' instead of the expected 'DeclarationError'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nsyntaxTests/double_stateVariable_declaration.sol: FAIL\n    Contract:\n        contract test {\n            uint256 variable;\n        }\n\n    Expected result:\n        DeclarationError: (36-52): Identifier already declared.\n    Obtained result:\n        Success\n```\n\n----------------------------------------\n\nTITLE: Printing Optimized Yul Programs\nDESCRIPTION: This command prints the optimized Yul programs after applying a specific optimization sequence. It sets the number of rounds to 0 to prevent the genetic algorithm from running and uses the `--mode` argument to specify the `print-optimised-programs` mode. The `--population` argument specifies the sequence to use for optimization.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntools/yul-phaser *.yul                    \\\n    --rounds     0                        \\\n    --mode       print-optimised-programs \\\n    --population <your sequence>\n```\n\n----------------------------------------\n\nTITLE: type(T).min and type(T).max for integer types - Solidity\nDESCRIPTION: Implemented `type(T).min` and `type(T).max` for every integer type `T` that returns the smallest and largest value representable by the type.  These are compile-time constants.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_23\n\nLANGUAGE: Solidity\nCODE:\n```\nImplemented ``type(T).min`` and ``type(T).max`` for every integer type ``T`` that returns the smallest and largest value representable by the type.\n```\n\n----------------------------------------\n\nTITLE: Standard JSON Compilation Input\nDESCRIPTION: This JSON snippet shows the structure of a Standard JSON input for the Solidity compiler. It demonstrates how to provide source code directly within the JSON, with the keys of the 'sources' dictionary serving as the source unit names.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"language\": \"Solidity\",\n    \"sources\": {\n        \"contract.sol\": {\n            \"content\": \"import \\\"./util.sol\\\";\\ncontract C {}\"\n        },\n        \"util.sol\": {\n            \"content\": \"library Util {}\"\n        },\n        \"/usr/local/dapp-bin/token.sol\": {\n            \"content\": \"contract Token {}\"\n        }\n    },\n    \"settings\": {\"outputSelection\": {\"*\": { \"*\": [\"metadata\", \"evm.bytecode\"]}}}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking EVMASM Library\nDESCRIPTION: This snippet creates the `evmasm` library using the source files defined earlier and links it to other libraries. The `add_library` command creates the library, and `target_link_libraries` specifies the dependencies `solutil` and `fmt::fmt-header-only`, making them available during compilation and linking.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libevmasm/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(evmasm ${sources})\ntarget_link_libraries(evmasm PUBLIC solutil fmt::fmt-header-only)\n```\n\n----------------------------------------\n\nTITLE: Contract Lib Bytecode and Metadata\nDESCRIPTION: This snippet includes the bytecode and metadata for the Solidity library 'Lib'. The bytecode is the compiled library code intended for deployment and use by other contracts. The metadata comprises compiler details, ABI, and source code hash, which are vital for integrating and verifying the library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/library_inherited2_sol_cli_output.txt#_snippet_2\n\nLANGUAGE: Binary\nCODE:\n```\n60566050600b82828239805160001a6073146043577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207f9515e2263fa71a7984707e2aefd82241fac15c497386ca798b526f14f8ba6664736f6c63430008000033\n```\n\nLANGUAGE: Metadata\nCODE:\n```\n{\"compiler\":{\"version\":\"0.8.0+commit.c7dfd78e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"syntaxTests/scoping/library_inherited2.sol\":\"Lib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"syntaxTests/scoping/library_inherited2.sol\":{\"keccak256\":\"0xd0619f00638fdfea187368965615dbd599fead93dd14b6558725e85ec7011d96\",\"urls\":[\"bzz-raw://ec7af066be66a223f0d25ba3bf9ba6dc103e1a57531a66a38a5ca2b6ce172f55\",\"dweb:/ipfs/QmW1NrqQNhnY1Tkgr3Z9oM8buCGLUJCJVCDTVejJTT5Vet\"]}},\"version\":1}\n```\n\n----------------------------------------\n\nTITLE: Solidity: Integer Literal Expression\nDESCRIPTION: Demonstrates how number literal expressions retain arbitrary precision until converted to a non-literal type. It illustrates that calculations with literal numbers don't overflow or truncate due to their arbitrary precision.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Bytes Concatenation with Variable Arguments\nDESCRIPTION: Enables the use of `bytes.concat` with a variable number of `bytes` and `bytesNN` arguments. This function provides a restricted version of `abi.encodePacked` with a more descriptive name for concatenating byte arrays.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\nbytes.concat\n```\n\n----------------------------------------\n\nTITLE: Creating and linking the phaser library in CMake\nDESCRIPTION: This snippet creates a static library named `phaser` from the source files listed in the `libphaser_sources` variable. It then links the `phaser` library with the `solidity` and `Boost` libraries, specifically `Boost::boost` and `Boost::program_options`, making them available for use within the `phaser` library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(phaser ${libphaser_sources})\ntarget_link_libraries(phaser PUBLIC solidity Boost::boost Boost::program_options)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This snippet adds several subdirectories to the build process, including `libsolutil`, `liblangutil`, `libsmtutil`, `libevmasm`, `libyul`, `libsolidity`, `libsolc`, and `libstdlib`. These subdirectories likely contain the source code for various components of the Solidity compiler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(libsolutil)\nadd_subdirectory(liblangutil)\nadd_subdirectory(libsmtutil)\nadd_subdirectory(libevmasm)\nadd_subdirectory(libyul)\nadd_subdirectory(libsolidity)\nadd_subdirectory(libsolc)\nadd_subdirectory(libstdlib)\n```\n\n----------------------------------------\n\nTITLE: Configure Standard Library Header with CMake\nDESCRIPTION: This snippet configures the main standard library header file (stdlib.h) using the configure_file command.  It utilizes a template file (stdlib.h.in) and places the generated file in the ${PROJECT_BINARY_DIR}/include/libstdlib/ directory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libstdlib/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/stdlib.h.in\" ${PROJECT_BINARY_DIR}/include/libstdlib/stdlib.h NEWLINE_STYLE LF @ONLY)\n```\n\n----------------------------------------\n\nTITLE: Encoding Metadata Hash Example\nDESCRIPTION: This example shows how the metadata hash and compiler version are encoded at the end of the bytecode using CBOR encoding. It includes the IPFS hash (CID v0) or Swarm hash of the metadata file, flags for experimental features, and the compiler version.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/metadata.rst#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"ipfs\": \"<metadata hash>\",\n  // If \"bytecodeHash\" was \"bzzr1\" in compiler settings not \"ipfs\" but \"bzzr1\"\n  \"bzzr1\": \"<metadata hash>\",\n  // Previous versions were using \"bzzr0\" instead of \"bzzr1\"\n  \"bzzr0\": \"<metadata hash>\",\n  // If any experimental features that affect code generation are used\n  \"experimental\": true,\n  \"solc\": \"<compiler version>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Executable solfuzzer\nDESCRIPTION: This snippet creates an executable named `solfuzzer` from the source files `afl_fuzzer.cpp` and `fuzzer_common.cpp`. It links the executable against private libraries, including `libsolc`, `evmasm`, and Boost libraries.  The PRIVATE keyword ensures these are only linked for `solfuzzer` build.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(solfuzzer afl_fuzzer.cpp fuzzer_common.cpp)\ntarget_link_libraries(solfuzzer PRIVATE libsolc evmasm Boost::boost Boost::program_options Boost::system)\n```\n\n----------------------------------------\n\nTITLE: Yul Metadata Object Definition\nDESCRIPTION: Defines the special meaning of the \".metadata\" data object within Yul objects. This enhancement provides a way to include metadata directly within Yul code, potentially for compiler or deployment related information.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_7\n\nLANGUAGE: Yul\nCODE:\n```\n``.metadata``\n```\n\n----------------------------------------\n\nTITLE: Construct Payment Message Hash JavaScript\nDESCRIPTION: This JavaScript function constructs a message hash from the contract address and amount using abi.soliditySHA3. This hash is then signed to authorize a payment within the payment channel.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/examples/micropayment.rst#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfunction constructPaymentMessage(contractAddress, amount) {\n    return abi.soliditySHA3(\n        [\"address\", \"uint256\"],\n        [contractAddress, amount]\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Packed Encoding Example\nDESCRIPTION: This example illustrates the packed encoding mode in Solidity. The encoding of `int16(-1), bytes1(0x42), uint16(0x03), string(\"Hello, world!\")` results in the concatenated hexadecimal string. This encoding mode is non-standard and does not include length fields or padding for dynamically sized types.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/abi-spec.rst#_snippet_9\n\nLANGUAGE: none\nCODE:\n```\n0xffff42000348656c6c6f2c20776f726c6421\n      ^^^^                                 int16(-1)\n          ^^                               bytes1(0x42)\n            ^^^^                           uint16(0x03)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(\"Hello, world!\") without a length field\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking the Yul Interpreter Library (CMake)\nDESCRIPTION: This snippet creates a library target named yulInterpreter using the source files defined in the sources variable. It then links this library against other libraries: yul, solidity, and solutil. The PUBLIC keyword means that dependencies of yulInterpreter will also depend on these linked libraries.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/yulInterpreter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(yulInterpreter ${sources})\ntarget_link_libraries(yulInterpreter PUBLIC yul solidity solutil)\n```\n\n----------------------------------------\n\nTITLE: For Loop Condition Out of Body Transformation (Example 1)\nDESCRIPTION: Illustrates the transformation of a `for` loop condition moved out of the loop body, back into the loop condition itself.  Specifically, it transforms a loop using `if iszero(c) { break }` into one using `c` directly as the loop condition. This optimization is related to earlier transformations and potentially benefits from other optimization passes such as literal rematerialization.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_19\n\nLANGUAGE: none\nCODE:\n```\nfor { ... } 1 { ... } {\n    if iszero(c) { break }\n    ...\n}\n```\n\nLANGUAGE: none\nCODE:\n```\nfor { ... } c { ... } {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Compiler Version Pragma Warning\nDESCRIPTION: This warning indicates that the Solidity source file lacks a `pragma solidity` statement specifying the compiler version. Including this pragma is important because it ensures that the code is compiled with a compatible compiler version, avoiding potential compatibility issues.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_generation_error_cli_output.txt#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nWarning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.0;\"\n```\n\n----------------------------------------\n\nTITLE: Define OSSFuzz Custom Target and Dependencies (CMake)\nDESCRIPTION: This CMake snippet defines a custom target named `ossfuzz` and specifies its dependencies. It includes targets like `solc_ossfuzz`, `solc_mutator_ossfuzz`, `const_opt_ossfuzz`, `strictasm_diff_ossfuzz`, `strictasm_opt_ossfuzz`, and `strictasm_assembly_ossfuzz`. The dependencies ensure that these targets are built before the `ossfuzz` target.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(ossfuzz)\nadd_dependencies(ossfuzz\n        solc_ossfuzz\n        solc_mutator_ossfuzz\n        const_opt_ossfuzz\n        strictasm_diff_ossfuzz\n        strictasm_opt_ossfuzz\n        strictasm_assembly_ossfuzz\n)\n```\n\n----------------------------------------\n\nTITLE: Operator Whitespace: Correct Spacing in Solidity\nDESCRIPTION: This snippet illustrates the correct way to use whitespace around operators in Solidity to improve readability. It demonstrates that the same amount of whitespace should be used on either side of an operator.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_24\n\nLANGUAGE: solidity\nCODE:\n```\nx = 2**3 + 5;\nx = 2*y + 3*z;\nx = (a+b) * (a-b);\n```\n\n----------------------------------------\n\nTITLE: Setting Solidity Source Files in CMake\nDESCRIPTION: This CMake snippet defines a variable `sources` containing a list of C++ source and header files that make up the Solidity compiler project. These files are categorized into different directories representing different aspects of the compiler such as analysis, AST, code generation, formal verification, interface, language server protocol, parsing, and experimental features.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolidity/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(sources\n\tanalysis/ConstantEvaluator.cpp\n\tanalysis/ConstantEvaluator.h\n\tanalysis/ContractLevelChecker.cpp\n\tanalysis/ContractLevelChecker.h\n\tanalysis/ControlFlowAnalyzer.cpp\n\tanalysis/ControlFlowAnalyzer.h\n\tanalysis/ControlFlowBuilder.cpp\n\tanalysis/ControlFlowBuilder.h\n\tanalysis/ControlFlowGraph.cpp\n\tanalysis/ControlFlowGraph.h\n\tanalysis/ControlFlowRevertPruner.cpp\n\tanalysis/ControlFlowRevertPruner.h\n\tanalysis/DeclarationContainer.cpp\n\tanalysis/DeclarationContainer.h\n\tanalysis/DeclarationTypeChecker.cpp\n\tanalysis/DeclarationTypeChecker.h\n\tanalysis/DocStringAnalyser.cpp\n\tanalysis/DocStringAnalyser.h\n\tanalysis/DocStringTagParser.cpp\n\tanalysis/DocStringTagParser.h\n\tanalysis/FunctionCallGraph.cpp\n\tanalysis/FunctionCallGraph.h\n\tanalysis/ImmutableValidator.cpp\n\tanalysis/ImmutableValidator.h\n\tanalysis/GlobalContext.cpp\n\tanalysis/GlobalContext.h\n\tanalysis/NameAndTypeResolver.cpp\n\tanalysis/NameAndTypeResolver.h\n\tanalysis/OverrideChecker.cpp\n\tanalysis/OverrideChecker.h\n\tanalysis/PostTypeChecker.cpp\n\tanalysis/PostTypeChecker.h\n\tanalysis/PostTypeContractLevelChecker.cpp\n\tanalysis/PostTypeContractLevelChecker.h\n\tanalysis/ReferencesResolver.cpp\n\tanalysis/ReferencesResolver.h\n\tanalysis/Scoper.cpp\n\tanalysis/Scoper.h\n\tanalysis/StaticAnalyzer.cpp\n\tanalysis/StaticAnalyzer.h\n\tanalysis/SyntaxChecker.cpp\n\tanalysis/SyntaxChecker.h\n\tanalysis/TypeChecker.cpp\n\tanalysis/TypeChecker.h\n\tanalysis/ViewPureChecker.cpp\n\tanalysis/ViewPureChecker.h\n\tast/AST.cpp\n\tast/AST.h\n\tast/AST_accept.h\n\tast/ASTAnnotations.cpp\n\tast/ASTAnnotations.h\n\tast/ASTEnums.h\n\tast/ASTForward.h\n\tast/ASTJsonExporter.cpp\n\tast/ASTJsonExporter.h\n\tast/ASTUtils.cpp\n\tast/ASTUtils.h\n\tast/ASTJsonImporter.cpp\n\tast/ASTJsonImporter.h\n\tast/ASTVisitor.h\n\tast/CallGraph.cpp\n\tast/CallGraph.h\n\tast/ExperimentalFeatures.h\n\tast/UserDefinableOperators.h\n\tast/Types.cpp\n\tast/Types.h\n\tast/TypeProvider.cpp\n\tast/TypeProvider.h\n\tcodegen/ABIFunctions.cpp\n\tcodegen/ABIFunctions.h\n\tcodegen/ArrayUtils.cpp\n\tcodegen/ArrayUtils.h\n\tcodegen/Compiler.cpp\n\tcodegen/Compiler.h\n\tcodegen/CompilerContext.cpp\n\tcodegen/CompilerContext.h\n\tcodegen/CompilerUtils.cpp\n\tcodegen/CompilerUtils.h\n\tcodegen/ContractCompiler.cpp\n\tcodegen/ContractCompiler.h\n\tcodegen/ExpressionCompiler.cpp\n\tcodegen/ExpressionCompiler.h\n\tcodegen/LValue.cpp\n\tcodegen/LValue.h\n\tcodegen/MultiUseYulFunctionCollector.h\n\tcodegen/MultiUseYulFunctionCollector.cpp\n\tcodegen/ReturnInfo.h\n\tcodegen/ReturnInfo.cpp\n\tcodegen/YulUtilFunctions.h\n\tcodegen/YulUtilFunctions.cpp\n\tcodegen/ir/Common.cpp\n\tcodegen/ir/Common.h\n\tcodegen/ir/IRGenerator.cpp\n\tcodegen/ir/IRGenerator.h\n\tcodegen/ir/IRGeneratorForStatements.cpp\n\tcodegen/ir/IRGeneratorForStatements.h\n\tcodegen/ir/IRGenerationContext.cpp\n\tcodegen/ir/IRGenerationContext.h\n\tcodegen/ir/IRLValue.h\n\tcodegen/ir/IRVariable.cpp\n\tcodegen/ir/IRVariable.h\n\texperimental/analysis/Analysis.cpp\n\texperimental/analysis/Analysis.h\n\tformal/ArraySlicePredicate.cpp\n\tformal/ArraySlicePredicate.h\n\tformal/BMC.cpp\n\tformal/BMC.h\n\tformal/CHC.cpp\n\tformal/CHC.h\n\tformal/Cvc5SMTLib2Interface.cpp\n\tformal/Cvc5SMTLib2Interface.h\n\tformal/EldaricaCHCSmtLib2Interface.cpp\n\tformal/EldaricaCHCSmtLib2Interface.h\n\tformal/EncodingContext.cpp\n\tformal/EncodingContext.h\n\tformal/ExpressionFormatter.cpp\n\tformal/ExpressionFormatter.h\n\tformal/ModelChecker.cpp\n\tformal/ModelChecker.h\n\tformal/ModelCheckerSettings.cpp\n\tformal/ModelCheckerSettings.h\n\tformal/Predicate.cpp\n\tformal/Predicate.h\n\tformal/PredicateInstance.cpp\n\tformal/PredicateInstance.h\n\tformal/PredicateSort.cpp\n\tformal/PredicateSort.h\n\tformal/SMTEncoder.cpp\n\tformal/SMTEncoder.h\n\tformal/SSAVariable.cpp\n\tformal/SSAVariable.h\n\tformal/SymbolicState.cpp\n\tformal/SymbolicState.h\n\tformal/SymbolicTypes.cpp\n\tformal/SymbolicTypes.h\n\tformal/SymbolicVariables.cpp\n\tformal/SymbolicVariables.h\n\tformal/Z3CHCSmtLib2Interface.cpp\n\tformal/Z3CHCSmtLib2Interface.h\n\tformal/Z3SMTLib2Interface.cpp\n\tformal/Z3SMTLib2Interface.h\n\tinterface/ABI.cpp\n\tinterface/ABI.h\n\tinterface/CompilerStack.cpp\n\tinterface/CompilerStack.h\n\tinterface/DebugSettings.h\n\tinterface/FileReader.cpp\n\tinterface/FileReader.h\n\tinterface/ImportRemapper.cpp\n\tinterface/ImportRemapper.h\n\tinterface/GasEstimator.cpp\n\tinterface/GasEstimator.h\n\tinterface/Natspec.cpp\n\tinterface/Natspec.h\n\tinterface/OptimiserSettings.h\n\tinterface/ReadFile.h\n\tinterface/SMTSolverCommand.cpp\n\tinterface/SMTSolverCommand.h\n\tinterface/StandardCompiler.cpp\n\tinterface/StandardCompiler.h\n\tinterface/StorageLayout.cpp\n\tinterface/StorageLayout.h\n\tinterface/UniversalCallback.h\n\tinterface/Version.cpp\n\tinterface/Version.h\n\tlsp/DocumentHoverHandler.cpp\n\tlsp/DocumentHoverHandler.h\n\tlsp/FileRepository.cpp\n\tlsp/FileRepository.h\n\tlsp/GotoDefinition.cpp\n\tlsp/GotoDefinition.h\n\tlsp/RenameSymbol.cpp\n\tlsp/RenameSymbol.h\n\tlsp/HandlerBase.cpp\n\tlsp/HandlerBase.h\n\tlsp/LanguageServer.cpp\n\tlsp/LanguageServer.h\n\tlsp/SemanticTokensBuilder.cpp\n\tlsp/SemanticTokensBuilder.h\n\tlsp/Transport.cpp\n\tlsp/Transport.h\n\tlsp/Utils.cpp\n\tlsp/Utils.h\n\tparsing/DocStringParser.cpp\n\tparsing/DocStringParser.h\n\tparsing/Parser.cpp\n\tparsing/Parser.h\n\tparsing/Token.h\n\texperimental/analysis/Analysis.cpp\n\texperimental/analysis/Analysis.h\n\texperimental/analysis/DebugWarner.cpp\n\texperimental/analysis/DebugWarner.h\n\texperimental/analysis/FunctionDependencyAnalysis.cpp\n\texperimental/analysis/FunctionDependencyAnalysis.h\n\texperimental/analysis/TypeClassRegistration.cpp\n\texperimental/analysis/TypeClassRegistration.h\n\texperimental/analysis/TypeInference.cpp\n\texperimental/analysis/TypeInference.h\n\texperimental/analysis/TypeRegistration.cpp\n\texperimental/analysis/TypeRegistration.h\n\texperimental/analysis/SyntaxRestrictor.cpp\n\texperimental/analysis/SyntaxRestrictor.h\n\texperimental/ast/FunctionCallGraph.h\n\texperimental/ast/Type.cpp\n\texperimental/ast/Type.h\n\texperimental/ast/TypeSystem.cpp\n\texperimental/ast/TypeSystem.h\n\texperimental/ast/TypeSystemHelper.cpp\n\texperimental/ast/TypeSystemHelper.h\n\texperimental/codegen/Common.h\n\texperimental/codegen/Common.cpp\n\texperimental/codegen/IRGenerationContext.h\n\texperimental/codegen/IRGenerator.cpp\n\texperimental/codegen/IRGenerator.h\n\texperimental/codegen/IRGeneratorForStatements.cpp\n\texperimental/codegen/IRGeneratorForStatements.h\n)\n```\n\n----------------------------------------\n\nTITLE: Bytes Conversion to Fixed Bytes\nDESCRIPTION: Introduces support for converting `bytes` and `bytes` slices to `bytes1`/.../`bytes32`. This feature allows more flexible manipulation of byte arrays and fixed-size byte representations in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nbytes -> bytes1/.../bytes32\n```\n\n----------------------------------------\n\nTITLE: Assembly Hex String Literals\nDESCRIPTION: Introduces support for hex string literals in assembly and Yul. This feature enhances the expressiveness of assembly code by allowing direct representation of byte sequences using hexadecimal notation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_11\n\nLANGUAGE: Assembly/Yul\nCODE:\n```\nAllow hex string literals.\n```\n\n----------------------------------------\n\nTITLE: Selfdestructing a Contract in Solidity\nDESCRIPTION: Destroys the current contract, sending its funds to the specified address, and ends execution. Note that the destruction only takes place at the end of the transaction.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/units-and-global-variables.rst#_snippet_15\n\nLANGUAGE: Solidity\nCODE:\n```\nselfdestruct(address payable recipient)\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking the smtutil Library\nDESCRIPTION: This snippet creates a library named `smtutil` using the source files defined in the `sources` variable. It then links this library with `solutil` and `Boost::boost`. The `PUBLIC` keyword indicates that these dependencies are also required by any library that links against `smtutil`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsmtutil/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(smtutil ${sources})\ntarget_link_libraries(smtutil PUBLIC solutil Boost::boost)\n```\n\n----------------------------------------\n\nTITLE: Compiled Binary Code\nDESCRIPTION: Displays the compiled binary code of the Solidity contract 'C'. This binary code represents the machine-readable instructions that can be deployed and executed on the Ethereum Virtual Machine (EVM). The binary output depends on the specific Solidity compiler version used.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/solc_0.4.0_cli_output.txt#_snippet_1\n\nLANGUAGE: Binary\nCODE:\n```\n6060604052600c8060106000396000f360606040526008565b600256\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Hex Number Evaluation\nDESCRIPTION: This snippet presents the formal evaluation function `E` for a Yul hexadecimal number.  It converts the hexadecimal number to its big-endian value using the `hex` function and returns it along with the states.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_55\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, n: HexNumber) = G, L, hex(n)\n    where hex is the hexadecimal evaluation function,\n    which turns a sequence of hexadecimal digits into their big endian value\n```\n\n----------------------------------------\n\nTITLE: Define an Empty Solidity Contract\nDESCRIPTION: This snippet defines an empty Solidity contract named 'C'. It serves as a minimal example of a contract definition.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract C {}\n```\n\n----------------------------------------\n\nTITLE: Inlining Example - After Optimizer Steps\nDESCRIPTION: This shows the assembly after further optimization steps, where the return tag push has been moved towards the remaining jump, potentially allowing the PeepholeOptimizer to remove the return jump.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n...body of function f...\ntag_return\njump\ntag_return:\n...opcodes after call to f...\n\ntag_f:\n...body of function f...\njump      // out\n```\n\n----------------------------------------\n\nTITLE: Multiple Variable Declaration and Assignment\nDESCRIPTION: Demonstrates the declaration and assignment of multiple variables in a single statement, using tuple-like syntax.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_44\n\nLANGUAGE: Solidity\nCODE:\n```\nvar (x,y,) = (1,2,3,4,5);\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nvar (x,y) = f();\n```\n\n----------------------------------------\n\nTITLE: Define stack_reuse_codegen_ossfuzz Executable (CMake)\nDESCRIPTION: This CMake snippet defines the `stack_reuse_codegen_ossfuzz` executable, including source files, include directories, and linked libraries for stack reuse codegen fuzzing. It uses `StackReuseCodegenFuzzer.cpp`, `protoToYul.cpp`, `yulProto.pb.cc`, `../../EVMHost.cpp`, and `YulEvmoneInterface.cpp`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(stack_reuse_codegen_ossfuzz\n            StackReuseCodegenFuzzer.cpp\n            protoToYul.cpp\n            yulProto.pb.cc\n            ../../EVMHost.cpp\n            YulEvmoneInterface.cpp\n    )\n    target_include_directories(stack_reuse_codegen_ossfuzz PRIVATE /usr/include/libprotobuf-mutator)\n    target_link_libraries(stack_reuse_codegen_ossfuzz PRIVATE yul\n            evmc\n            evmone-standalone\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(stack_reuse_codegen_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(stack_reuse_codegen_ossfuzz PUBLIC\n            ${COMPILE_OPTIONS}\n            ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS}\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Yul Object Example\nDESCRIPTION: This example shows a Yul object named \"Contract1\" that consists of constructor code and a data section. The constructor code uses `datasize` and `datacopy` to copy the code of another contract. It also demonstrates how to allocate memory using a custom `allocate` function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_61\n\nLANGUAGE: Yul\nCODE:\n```\n// A contract consists of a single object with sub-objects representing\n// the code to be deployed or other contracts it can create.\n// The single \"code\" node is the executable code of the object.\n// Every (other) named object or data section is serialized and\n// made accessible to the special built-in functions datacopy / dataoffset / datasize\n// The current object, sub-objects and data items inside the current object\n// are in scope.\nobject \"Contract1\" {\n    // This is the constructor code of the contract.\n    code {\n        function allocate(size) -> ptr {\n            ptr := mload(0x40)\n            // Note that Solidity generated IR code reserves memory offset ``0x60`` as well, but a pure Yul object is free to use memory as it chooses.\n            if iszero(ptr) { ptr := 0x60 }\n            mstore(0x40, add(ptr, size))\n        }\n\n        // first create \"Contract2\"\n        let size := datasize(\"Contract2\")\n        let offset := allocate(size)\n        // This will turn into codecopy for EVM\n        datacopy(offset, dataoffset(\"Contract2\"), size)\n        // constructor parameter is a single number 0x1234\n        mstore(add(offset, size), 0x1234)\n        pop(create(0, offset, add(size, 32)))\n\n        // now return the runtime object (the currently\n        // executing code is the constructor code)\n        size := datasize(\"Contract1_deployed\")\n        offset := allocate(size)\n        // This will turn into a codecopy for EVM\n        datacopy(offset, dataoffset(\"Contract1_deployed\"), size)\n        return(offset, size)\n    }\n\n    data \"Table2\" hex\"4123\"\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Memory Allocation Function\nDESCRIPTION: This Yul code snippet defines a function called `allocate` that manages memory allocation within the Yul environment. It retrieves the current free memory pointer from address `0x40`, initializes it to `0x60` if zero, and then updates the free memory pointer by adding the requested size. The function returns a pointer to the allocated memory block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_62\n\nLANGUAGE: Yul\nCODE:\n```\nfunction allocate(size) -> ptr {\n    ptr := mload(0x40)\n    // Note that Solidity generated IR code reserves memory offset ``0x60`` as well, but a pure Yul object is free to use memory as it chooses.\n    if iszero(ptr) { ptr := 0x60 }\n    mstore(0x40, add(ptr, size))\n}\n```\n\n----------------------------------------\n\nTITLE: Including and Configuring Project Options\nDESCRIPTION: This snippet includes the EthOptions CMake module and configures project-specific options, including testing configurations using `configure_project(TESTS)`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(EthOptions)\nconfigure_project(TESTS)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Module Path\nDESCRIPTION: This snippet sets the path to the CMake modules directory and appends it to the CMAKE_MODULE_PATH variable, which allows CMake to find custom modules used in the build process.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(ETH_CMAKE_DIR   \"${CMAKE_CURRENT_LIST_DIR}/cmake\"   CACHE PATH \"The path to the cmake directory\")\nlist(APPEND CMAKE_MODULE_PATH ${ETH_CMAKE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Memory Location Tracking for Keccak256 Hash Evaluation in Yul\nDESCRIPTION: This example demonstrates how the optimizer tracks memory locations to evaluate Keccak-256 hashes at compile time. It showcases the conditional erasure of memory knowledge based on potential overlaps in memory write operations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/optimizer.rst#_snippet_0\n\nLANGUAGE: yul\nCODE:\n```\nlet x := calldataload(0)\nmstore(x, 100)\nlet value := keccak256(x, 32)\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Decimal Number Evaluation\nDESCRIPTION: This snippet defines the formal evaluation function `E` for a Yul decimal number.  It uses the `dec` function to transform the decimal number into its big-endian value and returns it together with the states.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_56\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, n: DecimalNumber) = G, L, dec(n),\n    where dec is the decimal evaluation function,\n    which turns a sequence of decimal digits into their big endian value\n```\n\n----------------------------------------\n\nTITLE: Formatting Mappings - Solidity\nDESCRIPTION: Illustrates the correct way to format mappings in Solidity. There should be no space between the `mapping` keyword and its type or between nested `mapping` keywords and their types.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_20\n\nLANGUAGE: solidity\nCODE:\n```\nmapping(uint => uint) map;\nmapping(address => bool) registeredAddresses;\nmapping(uint => mapping(bool => Data[])) public data;\nmapping(uint => mapping(uint => s)) data;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Solidity Contract\nDESCRIPTION: This code defines a simple Solidity contract named 'C' with a single function 'foo'. The contract specifies the Solidity compiler version and license identifier. The 'foo' function is declared as public and view, indicating that it can be called externally and does not modify the contract's state.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block.rst#_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract C {\n    function foo() public view {}\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Switch\nDESCRIPTION: Defines the grammar for the Switch statement, including the 'switch' keyword, Expression, Cases, and a Default case.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_21\n\nLANGUAGE: none\nCODE:\n```\nSwitch =\n    'switch' Expression ( Case+ Default? | Default )\n```\n\n----------------------------------------\n\nTITLE: Define yul_proto_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `yul_proto_ossfuzz` executable, specifying its source files, include directories, linking libraries (`yul`, `protobuf-mutator-libfuzzer.a`, `protobuf-mutator.a`, `protobuf.a`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`. It also configures compile options to silence protobuf warnings.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(yul_proto_ossfuzz\n\t    yulProtoFuzzer.cpp\n\t    protoToYul.cpp\n\t    yulProto.pb.cc\n\t    ../../libyul/YulOptimizerTestCommon.cpp\n    )\n    target_include_directories(yul_proto_ossfuzz PRIVATE /usr/include/libprotobuf-mutator)\n    target_link_libraries(yul_proto_ossfuzz PRIVATE yul\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(yul_proto_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    # The -Wno-* compile options are required for source files that\n    # are auto-generated by the protobuf compiler because the compiler\n    # does not generate warning-free C++ bindings with regard to\n    # upstream Clang builds that are used by ossfuzz.\n    set(\n        SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS\n        -Wno-sign-conversion\n        -Wno-suggest-destructor-override\n        -Wno-inconsistent-missing-destructor-override\n        -Wno-shorten-64-to-32\n        -Wno-deprecated\n    )\n\n    target_compile_options(yul_proto_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Build Solidity with CMake Windows\nDESCRIPTION: These commands create a build directory, navigate into it, and use CMake to configure a Visual Studio 2019 solution for the Solidity project.  Note the generator option `-G \"Visual Studio 16 2019\"`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd build\ncmake -G \"Visual Studio 16 2019\" ..\n```\n\n----------------------------------------\n\nTITLE: Running AFL Fuzzer\nDESCRIPTION: This bash snippet shows how to execute the AFL fuzzer, specifying the memory limit, input directory containing test cases, output directory for reports, and the path to the solfuzzer binary.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nafl-fuzz -m 60 -i /tmp/test_cases -o /tmp/fuzzer_reports -- /path/to/solfuzzer\n```\n\n----------------------------------------\n\nTITLE: Emit transient storage warning\nDESCRIPTION: This snippet describes a change where the Yul analyzer will emit a warning only for the first occurrence of `tstore`. This prevents redundant warnings and focuses developer attention on the initial use of transient storage. Subsequent uses are assumed to be intentional.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nYul Analyzer: Emit transient storage warning only for the first occurrence of ``tstore``.\n```\n\n----------------------------------------\n\nTITLE: Syntax Test Example (Solidity)\nDESCRIPTION: This code snippet illustrates a syntax test case for Solidity, demonstrating how to define a contract with an error and specify the expected compiler error using annotations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\ncontract test {\n    uint256 variable;\n    uint128 variable;\n}\n// ----\n// DeclarationError: (36-52): Identifier already declared.\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Variable Declaration Evaluation (No Assignment)\nDESCRIPTION: This code presents the formal evaluation function `E` for a Yul variable declaration without an initial assignment. It creates a copy of the local state `L`, assigning a default value of 0 to each declared variable in the new state `L1`. It then returns the global state `G`, the updated local state `L1`, and the 'regular' mode.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_44\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <let var_1, ..., var_n>: VariableDeclaration) =\n    let L1 be a copy of L where L1[$var_i] = 0 for i = 1, ..., n\n    G, L1, regular\n```\n\n----------------------------------------\n\nTITLE: Yul Multiplication Wrapped in Object\nDESCRIPTION: This Yul code snippet demonstrates how Yul code can be wrapped within an object. It calculates the product of 3 and 5 and assigns the result to the variable 'y'. This showcases the ability to group Yul code within blocks.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block.rst#_snippet_3\n\nLANGUAGE: yul\nCODE:\n```\n// Yul code wrapped in object\n{\n    {\n        let y := mul(3, 5)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Command-line Test Execution Example\nDESCRIPTION: This bash snippet demonstrates how to execute command-line tests using the `cmdlineTests.sh` script, specifying the Solidity build directory and including/excluding specific test files using filename patterns.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport SOLIDITY_BUILD_DIR=~/solidity/build/\ntest/cmdlineTests.sh \"standard_*\" \"*_yul_*\" --exclude \"standard_yul_*\"\n```\n\n----------------------------------------\n\nTITLE: Using Yul Optimization Sequences with Solc\nDESCRIPTION: This command tells the Solidity compiler to use a specific optimization sequence during compilation. The `--optimize` flag enables optimization, the `--ir-optimized` flag requests optimized IR output, and the `--yul-optimizations` option specifies the optimization sequence to use. It allows for direct integration of `yul-phaser` output with the Solidity compiler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsolc/solc <sol file> --optimize --ir-optimized --yul-optimizations <sequence>\n```\n\n----------------------------------------\n\nTITLE: Solidity ABI Coder Pragma v1\nDESCRIPTION: This snippet shows how to select the old ABI coder (v1) in Solidity using the `pragma abicoder v1` directive.  This is necessary for compatibility with older contracts or to avoid the potential gas costs associated with the new ABI coder (v2).  It affects how data is encoded and decoded for external calls.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/layout-of-source-files.rst#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\npragma abicoder v1\n```\n\n----------------------------------------\n\nTITLE: Explicit Integer Conversion in Solidity\nDESCRIPTION: Illustrates explicit type conversion in Solidity, converting a negative `int` to a `uint`.  This conversion results in a large positive number due to the two's complement representation. Developers should be cautious when using explicit type conversions, as they can lead to unexpected results if not handled carefully.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/conversion.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nint  y = -3;\nuint x = uint(y);\n```\n\n----------------------------------------\n\nTITLE: Creating Executable yulrun\nDESCRIPTION: This snippet creates an executable named `yulrun` from the source file `yulrun.cpp`. It then links the executable against several private libraries, including `yulInterpreter`, `libsolc`, `evmasm`, and Boost libraries. The PRIVATE keyword specifies that these libraries are only needed for building `yulrun` and won't be exposed to other targets.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(yulrun yulrun.cpp)\ntarget_link_libraries(yulrun PRIVATE yulInterpreter libsolc evmasm Boost::boost Boost::program_options)\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe domainSeparator function signature\nDESCRIPTION: This is the signature for the `domainSeparator` function in the `GnosisSafe` contract. It returns the domain separator for EIP712 signatures.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_23\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  domainSeparator()\n```\n\n----------------------------------------\n\nTITLE: Tagging Solidity Release\nDESCRIPTION: These commands create and push a git tag for the Solidity release. It is important to annotate the tag before pushing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit tag --annotate v$VERSION\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit push --tags\n```\n\n----------------------------------------\n\nTITLE: Setting libphaser source files in CMake\nDESCRIPTION: This snippet defines a variable `libphaser_sources` that contains a list of source files for the `phaser` library. These files include headers and source code related to Yul Phaser's components, such as genetic algorithms, fitness metrics, and chromosome manipulation. It is used later by `add_library` to compile the library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(libphaser_sources\n\tyulPhaser/Common.h\n\tyulPhaser/Common.cpp\n\tyulPhaser/AlgorithmRunner.h\n\tyulPhaser/AlgorithmRunner.cpp\n\tyulPhaser/Phaser.h\n\tyulPhaser/Phaser.cpp\n\tyulPhaser/GeneticAlgorithms.h\n\tyulPhaser/GeneticAlgorithms.cpp\n\tyulPhaser/Population.h\n\tyulPhaser/Population.cpp\n\tyulPhaser/FitnessMetrics.h\n\tyulPhaser/FitnessMetrics.cpp\n\tyulPhaser/Chromosome.h\n\tyulPhaser/Chromosome.cpp\n\tyulPhaser/Mutations.h\n\tyulPhaser/Mutations.cpp\n\tyulPhaser/PairSelections.h\n\tyulPhaser/PairSelections.cpp\n\tyulPhaser/Selections.h\n\tyulPhaser/Selections.cpp\n\tyulPhaser/ProgramCache.h\n\tyulPhaser/ProgramCache.cpp\n\tyulPhaser/Program.h\n\tyulPhaser/Program.cpp\n\tyulPhaser/SimulationRNG.h\n\tyulPhaser/SimulationRNG.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: BreakContinue\nDESCRIPTION: Defines the grammar for BreakContinue statements, which are either 'break' or 'continue'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_25\n\nLANGUAGE: none\nCODE:\n```\nBreakContinue =\n    'break' | 'continue'\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Statement Evaluation\nDESCRIPTION: This snippet illustrates the formal evaluation function `E` for a Yul statement. It defines how the evaluation function processes a sequence of statements, considering the evaluation mode returned by each statement (regular, break, continue, leave). The function recursively evaluates statements until a non-regular mode is encountered.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_41\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, St1, ..., Stn: Statement) =\n    if n is zero:\n        G, L, regular\n    else:\n        let G1, L1, mode = E(G, L, St1)\n        if mode is regular then\n            E(G1, L1, St2, ..., Stn)\n        otherwise\n            G1, L1, mode\n```\n\n----------------------------------------\n\nTITLE: Solidity list.json sample\nDESCRIPTION: A snippet illustrating what a list.json file contains regarding the Solidity compiler version.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n\n```\n\n----------------------------------------\n\nTITLE: Adding Yul Library with Source Files\nDESCRIPTION: This CMake command defines the Yul library, specifying a list of source files to be compiled into the library. It includes various components such as assembly analysis, AST manipulation, optimization passes, and EVM backend implementations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libyul/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(yul\n\t${GENERATED_POLYFILL_HEADERS}\n\n\tAsmAnalysis.cpp\n\tAsmAnalysis.h\n\tAsmAnalysisInfo.h\n\tAST.h\n\tAST.cpp\n\tASTForward.h\n\tASTLabelRegistry.cpp\n\tASTLabelRegistry.h\n\tAsmJsonConverter.h\n\tAsmJsonConverter.cpp\n\tAsmJsonImporter.h\n\tAsmJsonImporter.cpp\n\tAsmParser.cpp\n\tAsmParser.h\n\tAsmPrinter.cpp\n\tAsmPrinter.h\n\tBuiltins.h\n\tYulStack.h\n\tYulStack.cpp\n\tCompilabilityChecker.cpp\n\tCompilabilityChecker.h\n\tControlFlowSideEffects.h\n\tControlFlowSideEffectsCollector.cpp\n\tControlFlowSideEffectsCollector.h\n\tDialect.cpp\n\tDialect.h\n\tExceptions.h\n\tFunctionReferenceResolver.cpp\n\tFunctionReferenceResolver.h\n\tObject.cpp\n\tObject.h\n\tObjectOptimizer.cpp\n\tObjectOptimizer.h\n\tObjectParser.cpp\n\tObjectParser.h\n\tScope.cpp\n\tScope.h\n\tScopeFiller.cpp\n\tScopeFiller.h\n\tUtilities.cpp\n\tUtilities.h\n\tYulControlFlowGraphExporter.h\n\tYulControlFlowGraphExporter.cpp\n\tYulName.h\n\tYulString.h\n\tbackends/evm/AbstractAssembly.h\n\tbackends/evm/AsmCodeGen.cpp\n\tbackends/evm/AsmCodeGen.h\n\tbackends/evm/ConstantOptimiser.cpp\n\tbackends/evm/ConstantOptimiser.h\n\tbackends/evm/ControlFlow.cpp\n\tbackends/evm/ControlFlow.h\n\tbackends/evm/ControlFlowGraph.h\n\tbackends/evm/ControlFlowGraphBuilder.cpp\n\tbackends/evm/ControlFlowGraphBuilder.h\n\tbackends/evm/EthAssemblyAdapter.cpp\n\tbackends/evm/EthAssemblyAdapter.h\n\tbackends/evm/EVMCodeTransform.cpp\n\tbackends/evm/EVMCodeTransform.h\n\tbackends/evm/EVMDialect.cpp\n\tbackends/evm/EVMDialect.h\n\tbackends/evm/EVMObjectCompiler.cpp\n\tbackends/evm/EVMObjectCompiler.h\n\tbackends/evm/EVMMetrics.cpp\n\tbackends/evm/EVMMetrics.h\n\tbackends/evm/NoOutputAssembly.h\n\tbackends/evm/NoOutputAssembly.cpp\n\tbackends/evm/OptimizedEVMCodeTransform.cpp\n\tbackends/evm/OptimizedEVMCodeTransform.h\n\tbackends/evm/SSACFGLiveness.cpp\n\tbackends/evm/SSACFGLiveness.h\n\tbackends/evm/SSACFGLoopNestingForest.cpp\n\tbackends/evm/SSACFGLoopNestingForest.h\n\tbackends/evm/SSACFGTopologicalSort.cpp\n\tbackends/evm/SSACFGTopologicalSort.h\n\tbackends/evm/SSAControlFlowGraph.cpp\n\tbackends/evm/SSAControlFlowGraph.h\n\tbackends/evm/SSAControlFlowGraphBuilder.cpp\n\tbackends/evm/SSAControlFlowGraphBuilder.h\n\tbackends/evm/StackHelpers.h\n\tbackends/evm/StackLayoutGenerator.cpp\n\tbackends/evm/StackLayoutGenerator.h\n\tbackends/evm/VariableReferenceCounter.h\n\tbackends/evm/VariableReferenceCounter.cpp\n\toptimiser/ASTCopier.cpp\n\toptimiser/ASTCopier.h\n\toptimiser/ASTWalker.cpp\n\toptimiser/ASTWalker.h\n\toptimiser/BlockFlattener.cpp\n\toptimiser/BlockFlattener.h\n\toptimiser/BlockHasher.cpp\n\toptimiser/BlockHasher.h\n\toptimiser/CallGraphGenerator.cpp\n\toptimiser/CallGraphGenerator.h\n\toptimiser/CircularReferencesPruner.cpp\n\toptimiser/CircularReferencesPruner.h\n\toptimiser/CommonSubexpressionEliminator.cpp\n\toptimiser/CommonSubexpressionEliminator.h\n\toptimiser/ConditionalSimplifier.cpp\n\toptimiser/ConditionalSimplifier.h\n\toptimiser/ConditionalUnsimplifier.cpp\n\toptimiser/ConditionalUnsimplifier.h\n\toptimiser/ControlFlowSimplifier.cpp\n\toptimiser/ControlFlowSimplifier.h\n\toptimiser/DataFlowAnalyzer.cpp\n\toptimiser/DataFlowAnalyzer.h\n\toptimiser/DeadCodeEliminator.cpp\n\toptimiser/DeadCodeEliminator.h\n\toptimiser/Disambiguator.cpp\n\toptimiser/Disambiguator.h\n\toptimiser/EqualStoreEliminator.cpp\n\toptimiser/EqualStoreEliminator.h\n\toptimiser/EquivalentFunctionDetector.cpp\n\toptimiser/EquivalentFunctionDetector.h\n\toptimiser/EquivalentFunctionCombiner.cpp\n\toptimiser/EquivalentFunctionCombiner.h\n\toptimiser/ExpressionInliner.cpp\n\toptimiser/ExpressionInliner.h\n\toptimiser/ExpressionJoiner.cpp\n\toptimiser/ExpressionJoiner.h\n\toptimiser/ExpressionSimplifier.cpp\n\toptimiser/ExpressionSimplifier.h\n\toptimiser/ExpressionSplitter.cpp\n\toptimiser/ExpressionSplitter.h\n\toptimiser/ForLoopConditionIntoBody.cpp\n\toptimiser/ForLoopConditionIntoBody.h\n\toptimiser/ForLoopConditionOutOfBody.cpp\n\toptimiser/ForLoopConditionOutOfBody.h\n\toptimiser/ForLoopInitRewriter.cpp\n\toptimiser/ForLoopInitRewriter.h\n\toptimiser/FullInliner.cpp\n\toptimiser/FullInliner.h\n\toptimiser/FunctionCallFinder.cpp\n\toptimiser/FunctionCallFinder.h\n\toptimiser/FunctionGrouper.cpp\n\toptimiser/FunctionGrouper.h\n\toptimiser/FunctionHoister.cpp\n\toptimiser/FunctionHoister.h\n\toptimiser/FunctionSpecializer.cpp\n\toptimiser/FunctionSpecializer.h\n\toptimiser/InlinableExpressionFunctionFinder.cpp\n\toptimiser/InlinableExpressionFunctionFinder.h\n\toptimiser/KnowledgeBase.cpp\n\toptimiser/KnowledgeBase.h\n\toptimiser/LoadResolver.cpp\n\toptimiser/LoadResolver.h\n\toptimiser/LoopInvariantCodeMotion.cpp\n\toptimiser/LoopInvariantCodeMotion.h\n\toptimiser/Metrics.cpp\n\toptimiser/Metrics.h\n\toptimiser/NameCollector.cpp\n\toptimiser/NameCollector.h\n\toptimiser/NameDispenser.cpp\n\toptimiser/NameDispenser.h\n\toptimiser/NameDisplacer.cpp\n\toptimiser/NameDisplacer.h\n\toptimiser/NameSimplifier.cpp\n\toptimiser/NameSimplifier.h\n\toptimiser/OptimiserStep.h\n\toptimiser/OptimizerUtilities.cpp\n\toptimiser/OptimizerUtilities.h\n\toptimiser/UnusedAssignEliminator.cpp\n\toptimiser/UnusedAssignEliminator.h\n\toptimiser/UnusedStoreBase.cpp\n\toptimiser/UnusedStoreBase.h\n\toptimiser/UnusedStoreEliminator.cpp\n\toptimiser/UnusedStoreEliminator.h\n\toptimiser/Rematerialiser.cpp\n\toptimiser/Rematerialiser.h\n\toptimiser/SSAReverser.cpp\n\toptimiser/SSAReverser.h\n\toptimiser/SSATransform.cpp\n\toptimiser/SSATransform.h\n\toptimiser/SSAValueTracker.cpp\n\toptimiser/SSAValueTracker.h\n\toptimiser/Semantics.cpp\n\toptimiser/Semantics.h\n\toptimiser/SimplificationRules.cpp\n\toptimiser/SimplificationRules.h\n\toptimiser/StackCompressor.cpp\n\toptimiser/StackCompressor.h\n\toptimiser/StackLimitEvader.cpp\n\toptimiser/StackLimitEvader.h\n\toptimiser/StackToMemoryMover.cpp\n\toptimiser/StackToMemoryMover.h\n\toptimiser/StructuralSimplifier.cpp\n\toptimiser/StructuralSimplifier.h\n\toptimiser/Substitution.cpp\n\toptimiser/Substitution.h\n\toptimiser/Suite.cpp\n\toptimiser/Suite.h\n\toptimiser/SyntacticalEquality.cpp\n\toptimiser/SyntacticalEquality.h\n\toptimiser/UnusedFunctionParameterPruner.cpp\n\toptimiser/UnusedFunctionParameterPruner.h\n\toptimiser/UnusedFunctionsCommon.h\n\toptimiser/UnusedFunctionsCommon.cpp\n\toptimiser/UnusedPruner.cpp\n\toptimiser/UnusedPruner.h\n\toptimiser/VarDeclInitializer.cpp\n\toptimiser/VarDeclInitializer.h\n\toptimiser/VarNameCleaner.cpp\n\toptimiser/VarNameCleaner.h\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Warning for Non-Pedantic Builds\nDESCRIPTION: This snippet checks if the `PEDANTIC` option is not enabled and, if so, emits a warning message indicating that warnings will not cause compilation to fail, which is not recommended for development builds.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT PEDANTIC)\n  message(WARNING \"-- Pedantic build flags turned off. Warnings will not make compilation fail. This is NOT recommended in development builds.\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Solidity Relative Imports Example 2\nDESCRIPTION: This code snippet shows another example of relative imports in Solidity, illustrating how the source unit names are resolved when the importing file has a different source unit name.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nimport \"./util.sol\" as util;    // source unit name: lib/util.sol\nimport \"../token.sol\" as token; // source unit name: token.sol\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe changeThreshold function signature\nDESCRIPTION: This is the signature for the `changeThreshold` function in the `GnosisSafe` contract. It allows changing the required threshold for transactions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_19\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  changeThreshold(uint256)\n```\n\n----------------------------------------\n\nTITLE: Installing Solidity from a local Homebrew formula\nDESCRIPTION: This snippet demonstrates how to install Solidity from a local Homebrew formula, after checking out a specific commit from the Homebrew Ethereum repository.  The existing solidity installation is unlinked first.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbrew unlink solidity\n# eg. Install 0.4.8\nbrew install solidity.rb\n```\n\n----------------------------------------\n\nTITLE: Whitespace in Receive/Fallback - Solidity\nDESCRIPTION: This snippet illustrates that no whitespace should be included in the receive and fallback functions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_8\n\nLANGUAGE: Solidity\nCODE:\n```\nreceive() external payable {\n    ...\n}\n\nfallback() external {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Solidity using snap (stable)\nDESCRIPTION: This snippet demonstrates how to install the latest stable version of Solidity using the snap package manager, if available on the system. Note that this snap package is currently unmaintained.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo snap install solc\n```\n\n----------------------------------------\n\nTITLE: Installing Solidity using snap (edge/development)\nDESCRIPTION: This snippet shows how to install the latest development version of Solidity from the edge channel using the snap package manager, if available on the system. Note that the `solc` snap uses strict confinement.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo snap install solc --edge\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: ForLoop\nDESCRIPTION: Defines the grammar for the ForLoop statement, including the 'for' keyword, initialization Block, Expression, increment Block, and the body Block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_24\n\nLANGUAGE: none\nCODE:\n```\nForLoop =\n    'for' Block Expression Block Block\n```\n\n----------------------------------------\n\nTITLE: Creating Solidity Library in CMake\nDESCRIPTION: This CMake code creates the `solidity` library from the source files defined in the `sources` variable. It then links this library against several other libraries including `yul`, `evmasm`, `langutil`, `smtutil`, `solutil`, Boost, fmt, and Threads. These dependencies provide functionality needed by the Solidity compiler.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolidity/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(solidity ${sources})\ntarget_link_libraries(solidity PUBLIC yul evmasm langutil smtutil solutil Boost::boost fmt::fmt-header-only Threads::Threads)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: TypeName\nDESCRIPTION: Defines TypeName as an Identifier.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_30\n\nLANGUAGE: none\nCODE:\n```\nTypeName = Identifier\n```\n\n----------------------------------------\n\nTITLE: Conditional Subdirectory Inclusion\nDESCRIPTION: This snippet conditionally adds the `tools`, `solc`, and `test` subdirectories to the build process if `ONLY_BUILD_SOLIDITY_LIBRARIES` is not enabled and the build is not for Emscripten. It also conditionally includes the `test` subdirectory if testing is enabled and the build is not for Emscripten.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT ONLY_BUILD_SOLIDITY_LIBRARIES)\n\tadd_subdirectory(tools)\n\n\tif (NOT EMSCRIPTEN)\n\t\tadd_subdirectory(solc)\n\tendif()\n\n\tif (TESTS AND NOT EMSCRIPTEN)\n\t\tadd_subdirectory(test)\n\tendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Yul Assignment with Addition\nDESCRIPTION: This snippet demonstrates a simple Yul assignment operation. It assigns the result of adding 1 and 5 to the variable 'x'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_5\n\nLANGUAGE: Yul\nCODE:\n```\nlet x := add(1, 5)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Statement\nDESCRIPTION: Defines the various types of statements that can be used within a Yul Block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_15\n\nLANGUAGE: none\nCODE:\n```\nStatement =\n    Block |\n    FunctionDefinition |\n    VariableDeclaration |\n    Assignment |\n    If |\n    Expression |\n    Switch |\n    ForLoop |\n    BreakContinue |\n    Leave\n```\n\n----------------------------------------\n\nTITLE: ERC20Token totalSupply function signature\nDESCRIPTION: This is the signature for the `totalSupply` function in the `ERC20Token` contract. It returns the total number of tokens in existence.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_12\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  totalSupply()\n```\n\n----------------------------------------\n\nTITLE: Fine: Function Parameter Fixed-Size Nested Array (Solidity)\nDESCRIPTION: Shows the correct way to define a function taking a fixed-size nested array `uint[2][2]` as a parameter.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f(uint[2][2]) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Build Options\nDESCRIPTION: This snippet defines several build options using the `option` command. These options include `SOLC_LINK_STATIC`, `SOLC_STATIC_STDLIBS`, `STRICT_Z3_VERSION`, `PEDANTIC`, `PROFILE_OPTIMIZER_STEPS`, `IGNORE_VENDORED_DEPENDENCIES`, and `ONLY_BUILD_SOLIDITY_LIBRARIES`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\noption(SOLC_LINK_STATIC \"Link solc executable statically on supported platforms\" OFF)\noption(SOLC_STATIC_STDLIBS \"Link solc against static versions of libgcc and libstdc++ on supported platforms\" OFF)\noption(STRICT_Z3_VERSION \"Require the exact version of Z3 solver expected by our test suite.\" ON)\noption(PEDANTIC \"Enable extra warnings and pedantic build flags. Treat all warnings as errors.\" ON)\noption(PROFILE_OPTIMIZER_STEPS \"Output performance metrics for the optimiser steps.\" OFF)\noption(\n\tIGNORE_VENDORED_DEPENDENCIES\n\t\"Ignore libraries provided as submodules of the repository and allow CMake to look for \\\nthem in the typical locations, including system-wide dirs.\"\n\tOFF\n)\noption(\n\tONLY_BUILD_SOLIDITY_LIBRARIES\n\t\"Only build library targets that can be statically linked against. Do not build executables or tests.\"\n\tOFF\n)\nmark_as_advanced(PROFILE_OPTIMIZER_STEPS)\nmark_as_advanced(IGNORE_VENDORED_DEPENDENCIES)\nmark_as_advanced(ONLY_BUILD_SOLIDITY_LIBRARIES)\n```\n\n----------------------------------------\n\nTITLE: Define an Empty Solidity Contract with Force\nDESCRIPTION: This snippet defines an empty Solidity contract named 'D'. The `:force:` directive ensures the code block is processed even if syntax errors are present. The `:linenos:` option is also included, but it appears after the code which could lead to incorrect rendering.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract D {}\n:linenos:\n```\n\n----------------------------------------\n\nTITLE: Whitespace in Expressions - Solidity\nDESCRIPTION: This snippet illustrates avoiding extraneous whitespace within parentheses, brackets, braces, before commas or semicolons, and around assignment operators in Solidity, except for single-line function declarations.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nspam(ham[1], Coin({name: \"ham\"}));\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction spam(uint i, Coin coin) public;\n```\n\nLANGUAGE: Solidity\nCODE:\n```\nx = 1;\ny = 2;\nlongVariable = 3;\n```\n\n----------------------------------------\n\nTITLE: Define yul_proto_diff_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `yul_proto_diff_ossfuzz` executable, specifying its source files, include directories, linking libraries (`yul`, `yulInterpreter`, `protobuf-mutator-libfuzzer.a`, `protobuf-mutator.a`, `protobuf.a`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`. It also configures compile options to silence protobuf warnings.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(\n\t    yul_proto_diff_ossfuzz\n\t    yulProto_diff_ossfuzz.cpp\n\t    yulFuzzerCommon.cpp\n\t    protoToYul.cpp\n\t    yulProto.pb.cc\n\t    ../../libyul/YulOptimizerTestCommon.cpp\n    )\n    target_include_directories(yul_proto_diff_ossfuzz PRIVATE /usr/include/libprotobuf-mutator)\n    target_link_libraries(yul_proto_diff_ossfuzz PRIVATE yul\n            yulInterpreter\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n    )\n    set_target_properties(yul_proto_diff_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(yul_proto_diff_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define strictasm_assembly_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `strictasm_assembly_ossfuzz` executable, specifying its source file (`strictasm_assembly_ossfuzz.cpp`), linking library (`yul`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(strictasm_assembly_ossfuzz strictasm_assembly_ossfuzz.cpp)\n    target_link_libraries(strictasm_assembly_ossfuzz PRIVATE yul)\n    set_target_properties(strictasm_assembly_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(strictasm_assembly_ossfuzz\n            strictasm_assembly_ossfuzz.cpp\n            )\n    target_link_libraries(strictasm_assembly_ossfuzz PRIVATE yul)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting main.cpp source CMake\nDESCRIPTION: This snippet defines the source file for the main executable (`solc`) using the `set` command in CMake. In this case, the main file is `main.cpp`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(sources main.cpp)\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for libsolidity\nDESCRIPTION: This code snippet defines the source files for the core `libsolidity` library. It includes a wide range of files related to ABI encoding/decoding, AST, error checking, gas costs, imports, inline assembly, metadata, optimization, parsing, and type resolution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(libsolidity_sources\n    libsolidity/ABIDecoderTests.cpp\n    libsolidity/ABIEncoderTests.cpp\n    libsolidity/ABIJsonTest.cpp\n    libsolidity/ABIJsonTest.h\n    libsolidity/ABITestsCommon.h\n    libsolidity/AnalysisFramework.cpp\n    libsolidity/AnalysisFramework.h\n    libsolidity/Assembly.cpp\n    libsolidity/ASTJSONTest.cpp\n    libsolidity/ASTJSONTest.h\n    libsolidity/ErrorCheck.cpp\n    libsolidity/ErrorCheck.h\n    libsolidity/FunctionDependencyGraphTest.cpp\n    libsolidity/FunctionDependencyGraphTest.h\n    libsolidity/GasCosts.cpp\n    libsolidity/GasMeter.cpp\n    libsolidity/GasTest.cpp\n    libsolidity/GasTest.h\n    libsolidity/Imports.cpp\n    libsolidity/InlineAssembly.cpp\n    libsolidity/LibSolc.cpp\n    libsolidity/Metadata.cpp\n    libsolidity/MemoryGuardTest.cpp\n    libsolidity/MemoryGuardTest.h\n    libsolidity/NatspecJSONTest.cpp\n    libsolidity/NatspecJSONTest.h\n    libsolidity/OptimizedIRCachingTest.cpp\n    libsolidity/OptimizedIRCachingTest.h\n    libsolidity/SemanticTest.cpp\n    libsolidity/SemanticTest.h\n    libsolidity/SemVerMatcher.cpp\n    libsolidity/SMTCheckerTest.cpp\n    libsolidity/SMTCheckerTest.h\n    libsolidity/SolidityCompiler.cpp\n    libsolidity/SolidityEndToEndTest.cpp\n    libsolidity/SolidityExecutionFramework.cpp\n    libsolidity/SolidityExecutionFramework.h\n    libsolidity/SolidityExpressionCompiler.cpp\n    libsolidity/SolidityNameAndTypeResolution.cpp\n    libsolidity/SolidityOptimizer.cpp\n    libsolidity/SolidityParser.cpp\n    libsolidity/SolidityTypes.cpp\n    libsolidity/StandardCompiler.cpp\n    libsolidity/SyntaxTest.cpp\n    libsolidity/SyntaxTest.h\n    libsolidity/ViewPureChecker.cpp\n    libsolidity/analysis/FunctionCallGraph.cpp\n    libsolidity/interface/FileReader.cpp\n    libsolidity/ASTPropertyTest.h\n    libsolidity/ASTPropertyTest.cpp\n)\ndetect_stray_source_files(\"${libsolidity_sources}\" \"libsolidity/\")\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Leave Evaluation\nDESCRIPTION: This snippet specifies the formal evaluation function `E` for the Yul `leave` statement. Similar to `break` and `continue`, it simply returns the current states and the `leave` mode, indicating a function exit.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_48\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, leave: Leave) =\n    G, L, leave\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: If\nDESCRIPTION: Defines the grammar for the If statement, including the 'if' keyword, Expression, and Block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_20\n\nLANGUAGE: none\nCODE:\n```\nIf =\n    'if' Expression Block\n```\n\n----------------------------------------\n\nTITLE: SPDX License Identifier Warning\nDESCRIPTION: This warning suggests adding an SPDX license identifier to the Solidity source file. The identifier clarifies the licensing terms under which the code is distributed, which is crucial for open-source projects or to specify the code is proprietary using \"SPDX-License-Identifier: UNLICENSED\".\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_generation_error_cli_output.txt#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nWarning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. Please see https://spdx.org for more information.\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: This snippet sets the minimum required CMake version for the project to 3.13.0, ensuring that all CMake features used in the build configuration are supported.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13.0)\n```\n\n----------------------------------------\n\nTITLE: Creating PPA release for Solidity\nDESCRIPTION: This script creates a PPA release for Solidity on Ubuntu. It requires `.release_ppa_auth` to be configured with LAUNCHPAD_EMAIL and LAUNCHPAD_KEYID, and the DISTRIBUTIONS list in the script should contain the latest Ubuntu versions.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nscripts/release_ppa.sh v$VERSION\n```\n\n----------------------------------------\n\nTITLE: Create EVMC Loader Static Library with CMake\nDESCRIPTION: This snippet creates the `evmc_loader` static library using CMake. It sets the linker language to C, links necessary dynamic link libraries, and configures include directories. Also, it sets the `POSITION_INDEPENDENT_CODE` property to `TRUE`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/evmc/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(evmc_loader STATIC loader.h loader.c)\nset_target_properties(evmc_loader PROPERTIES LINKER_LANGUAGE C)\ntarget_link_libraries(evmc_loader INTERFACE ${CMAKE_DL_LIBS})\ntarget_include_directories(evmc_loader PUBLIC ${PROJECT_SOURCE_DIR}/test/)\nset_target_properties(evmc_loader PROPERTIES\n    POSITION_INDEPENDENT_CODE TRUE\n)\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies PowerShell\nDESCRIPTION: This PowerShell script installs the required external dependencies (boost and cmake) into the 'deps' subdirectory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\nscripts\\install_deps.ps1\n```\n\n----------------------------------------\n\nTITLE: Analyzing a Yul Optimization Sequence\nDESCRIPTION: This command analyzes a specific Yul optimization sequence by showing the value of a particular metric (e.g., code-size) for the given sequence and program. It sets the number of rounds to 0 to prevent the genetic algorithm from running and uses the `--population` argument to specify the sequence to analyze. The `--show-initial-population` flag ensures the provided population is used.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntools/yul-phaser *.yul            \\\n    --show-initial-population     \\\n    --rounds            0         \\\n    --metric            code-size \\\n    --metric-aggregator sum       \\\n    --population        <your sequence>\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for libevmasm\nDESCRIPTION: This code snippet defines the source files for the `libevmasm` library, which deals with EVM assembly. It includes files like Assembler, Optimiser, and PlainAssemblyParser.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(libevmasm_sources\n    libevmasm/Assembler.cpp\n    libevmasm/EVMAssemblyTest.cpp\n    libevmasm/EVMAssemblyTest.h\n    libevmasm/Optimiser.cpp\n    libevmasm/PlainAssemblyParser.cpp\n    libevmasm/PlainAssemblyParser.h\n)\ndetect_stray_source_files(\"${libevmasm_sources}\" \"libevmasm/\")\n```\n\n----------------------------------------\n\nTITLE: C++ Include Order Example\nDESCRIPTION: This code snippet demonstrates the recommended order for including header files in Solidity C++ projects. The order progresses from the most specific (`libsolidity`) to the most general (STL), with empty lines separating blocks of related includes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CODING_STYLE.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <libsolidity/codegen/ExpressionCompiler.h>\n\n#include <libsolidity/ast/AST.h>\n#include <libsolidity/codegen/CompilerContext.h>\n#include <libsolidity/codegen/CompilerUtils.h>\n#include <libsolidity/codegen/LValue.h>\n\n#include <libevmasm/GasMeter.h>\n\n#include <libsolutil/Common.h>\n#include <libsolutil/SHA3.h>\n\n#include <boost/range/adaptor/reversed.hpp>\n#include <boost/algorithm/string/replace.hpp>\n\n#include <utility>\n#include <numeric>\n```\n\n----------------------------------------\n\nTITLE: Function Abstraction with ecrecover in Solidity\nDESCRIPTION: This Solidity code demonstrates how the SMTChecker handles function abstraction. The SMTChecker models function calls as uninterpreted functions, especially when precise computation is not feasible. This allows proving assertions true even when the exact return value of a function like `ecrecover` cannot be computed, as long as it is deterministic and called with equivalent parameters.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst#_snippet_19\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ncontract Recover\n{\n    function f(\n        bytes32 hash,\n        uint8 v1, uint8 v2,\n        bytes32 r1, bytes32 r2,\n        bytes32 s1, bytes32 s2\n    ) public pure returns (address) {\n        address a1 = ecrecover(hash, v1, r1, s1);\n        require(v1 == v2);\n        require(r1 == r2);\n        require(s1 == s2);\n        address a2 = ecrecover(hash, v2, r2, s2);\n        assert(a1 == a2);\n        return a1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ERC20Token name function signature\nDESCRIPTION: This is the signature for the `name` function in the `ERC20Token` contract. It returns the name of the token.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  name()\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: StringLiteral\nDESCRIPTION: Defines the grammar for StringLiteral.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_34\n\nLANGUAGE: none\nCODE:\n```\nStringLiteral = '\"' ([^\"\\r\\n\\\\] | '\\\\' .)* '\"'\n```\n\n----------------------------------------\n\nTITLE: Updated Solidity Contract for Isoltest\nDESCRIPTION: This Solidity code snippet shows the corrected contract after using the 'update' command in isoltest. The second declaration of the variable has been removed, resolving the 'DeclarationError'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\ncontract test {\n    uint256 variable;\n}\n// ----\n```\n\n----------------------------------------\n\nTITLE: Fine: Function Returning Fixed-Size Array (Solidity)\nDESCRIPTION: Shows the correct way to define a function returning a fixed-size array `uint[2]`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_7\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint[2]) { }\n```\n\n----------------------------------------\n\nTITLE: Define solc_mutator_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `solc_mutator_ossfuzz` executable, specifying its source files, linking libraries (`libsolc`, `evmasm`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`. The source files suggest that it uses a custom mutator (`SolidityCustomMutatorInterface.cpp`) for fuzzing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(solc_mutator_ossfuzz\n            solc_ossfuzz.cpp\n            ../fuzzer_common.cpp\n            ../../TestCaseReader.cpp\n            SolidityGenerator.cpp\n            SolidityCustomMutatorInterface.cpp\n    )\n    target_link_libraries(solc_mutator_ossfuzz PRIVATE libsolc evmasm)\n    set_target_properties(solc_mutator_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(solc_mutator_ossfuzz\n            solc_ossfuzz.cpp\n            ../fuzzer_common.cpp\n            )\n    target_link_libraries(solc_mutator_ossfuzz PRIVATE libsolc evmasm)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Contract Import: Incorrect Contract Import Statement in Solidity\nDESCRIPTION: This snippet shows the incorrect way to import a contract in Solidity, particularly using a different pragma and lowercase contract name in the import statement.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_31\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\n\n\nimport \"./owned.sol\";\n\n\ncontract Congress is owned, tokenRecipient {\n    //...\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Expression\nDESCRIPTION: Defines the types of Expressions in Yul: FunctionCall, Identifier, or Literal.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_19\n\nLANGUAGE: none\nCODE:\n```\nExpression =\n    FunctionCall | Identifier | Literal\n```\n\n----------------------------------------\n\nTITLE: Creating soltest Executable\nDESCRIPTION: This code snippet defines the creation of the `soltest` executable, including all the source files defined in the previous `set` commands.  It then links the necessary libraries required for `soltest` to function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(soltest ${sources}\n    ${contracts_sources}\n    ${libsolutil_sources}\n    ${liblangutil_sources}\n    ${libevmasm_sources}\n    ${libyul_sources}\n    ${libsolidity_sources}\n    ${libsolidity_util_sources}\n    ${solcli_sources}\n    ${yul_phaser_sources}\n)\ntarget_link_libraries(soltest PRIVATE solcli libsolc yul solidity smtutil solutil phaser Boost::boost yulInterpreter evmasm Boost::filesystem Boost::program_options Boost::unit_test_framework evmc)\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for liblangutil\nDESCRIPTION: This code snippet defines the source files for the `liblangutil` library, which provides language utilities. It includes files like CharStream, Scanner, and SourceLocation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(liblangutil_sources\n    liblangutil/CharStream.cpp\n    liblangutil/Scanner.cpp\n    liblangutil/SourceLocation.cpp\n)\ndetect_stray_source_files(\"${liblangutil_sources}\" \"liblangutil/\")\n```\n\n----------------------------------------\n\nTITLE: Example User Documentation Output\nDESCRIPTION: Illustrates the JSON output generated by the Solidity compiler for user documentation, containing notices for contract and function level descriptions. It shows the format and structure of the JSON file.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/natspec-format.rst#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"version\" : 1,\n  \"kind\" : \"user\",\n  \"methods\" :\n  {\n    \"age(uint256)\" :\n    {\n      \"notice\" : \"Calculate tree age in years, rounded up, for live trees\"\n    },\n    \"leaves()\" :\n    {\n        \"notice\" : \"Returns the amount of leaves the tree has.\"\n    }\n  },\n  \"notice\" : \"You can use this contract for only the most basic simulation\"\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Linking of Threads Library (CMake)\nDESCRIPTION: This snippet conditionally links the Threads library to `solutil` if `SOLC_LINK_STATIC` is enabled. This allows the library to be linked statically with threads support when the variable is set. No expected inputs or outputs besides linking the Threads library.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolutil/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(SOLC_LINK_STATIC)\n\ttarget_link_libraries(solutil PUBLIC Threads::Threads)\nendif()\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe checkSignatures function signature\nDESCRIPTION: This is the signature for the `checkSignatures` function in the `GnosisSafe` contract. It verifies signatures against a given hash.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_21\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  checkSignatures(bytes32,bytes,bytes)\n```\n\n----------------------------------------\n\nTITLE: Isoltest Success Output Example\nDESCRIPTION: This text snippet shows the output after successfully running the isoltest on the updated contract. It indicates that the test case now passes.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nRe-running test case...\nsyntaxTests/double_stateVariable_declaration.sol: OK\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Case\nDESCRIPTION: Defines the grammar for a Case within a Switch statement, including the 'case' keyword, Literal, and Block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_22\n\nLANGUAGE: none\nCODE:\n```\nCase =\n    'case' Literal Block\n```\n\n----------------------------------------\n\nTITLE: Define abiv2_isabelle_ossfuzz Executable (CMake)\nDESCRIPTION: This CMake snippet defines the `abiv2_isabelle_ossfuzz` executable for ABIv2 Isabelle fuzzing. It links against libraries like `solidity`, `evmc`, `evmone-standalone`, the protobuf mutator libraries, `abicoder`, and `gmp.a`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(abiv2_isabelle_ossfuzz\n            AbiV2IsabelleFuzzer.cpp\n            SolidityEvmoneInterface.cpp\n            ../../EVMHost.cpp\n            protoToAbiV2.cpp\n            abiV2Proto.pb.cc\n    )\n    target_include_directories(abiv2_isabelle_ossfuzz PRIVATE\n            /usr/include/libprotobuf-mutator\n    )\n    target_link_libraries(abiv2_isabelle_ossfuzz PRIVATE solidity\n            evmc\n            evmone-standalone\n            protobuf-mutator-libfuzzer.a\n            protobuf-mutator.a\n            protobuf.a\n            abicoder\n            gmp.a\n    )\n    set_target_properties(abiv2_isabelle_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\n    target_compile_options(abiv2_isabelle_ossfuzz PUBLIC ${COMPILE_OPTIONS} ${SILENCE_PROTOBUF_AUTOGENERATED_WARNINGS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: TypedIdentifierList\nDESCRIPTION: Defines the grammar for a TypedIdentifierList, consisting of one or more TypedIdentifiers separated by commas, where a TypedIdentifier consists of an Identifier and an optional TypeName.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_31\n\nLANGUAGE: none\nCODE:\n```\nTypedIdentifierList = Identifier ( ':' TypeName )? ( ',' Identifier ( ':' TypeName )? )*\n```\n\n----------------------------------------\n\nTITLE: Yul Typed Literal Usage Example (Hypothetical)\nDESCRIPTION: This example demonstrates how to specify the type of a literal in Yul.  It is noted that the u32 and u256 types are not yet implemented. The example is intended to illustrate the syntax should they become available.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_4\n\nLANGUAGE: Yul\nCODE:\n```\n// This will not compile (u32 and u256 type not implemented yet)\n let x := and(\"abc\":u32, add(3:u256, 2:u256))\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for solcli\nDESCRIPTION: This code snippet defines the source files for the `solcli` command-line interface. It includes files for common utilities, command-line parsing, and handling allowed paths.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(solcli_sources\n    solc/Common.cpp\n    solc/Common.h\n    solc/CommandLineInterface.cpp\n    solc/CommandLineInterfaceAllowPaths.cpp\n    solc/CommandLineParser.cpp\n)\ndetect_stray_source_files(\"${solcli_sources}\" \"solc/\")\n```\n\n----------------------------------------\n\nTITLE: Creating libsolcli CMake library\nDESCRIPTION: This snippet creates the `solcli` library using the `add_library` command in CMake. It uses the source files defined in the `libsolcli_sources` variable. Then, it links the library to the `solidity` and `Boost` libraries.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/solc/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(solcli ${libsolcli_sources})\ntarget_link_libraries(solcli PUBLIC solidity Boost::boost Boost::program_options)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Literal\nDESCRIPTION: Defines the grammar for a Literal, which can be a NumberLiteral, StringLiteral, TrueLiteral, or FalseLiteral, and an optional TypeName.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_32\n\nLANGUAGE: none\nCODE:\n```\nLiteral =\n    (NumberLiteral | StringLiteral | TrueLiteral | FalseLiteral) ( ':' TypeName )?\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Shows incorrect function definition attempting to return a named fixed-size nested array `uint[200][2] a` and a uint.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_3\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint[200][2] a, uint x) { }\n```\n\n----------------------------------------\n\nTITLE: Running linkcheck for Solidity documentation\nDESCRIPTION: This snippet details how to run the linkcheck tool on the Solidity documentation to identify and fix any broken links. It's a crucial pre-release step to ensure the documentation is up-to-date and accurate.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake linkcheck\n```\n\n----------------------------------------\n\nTITLE: Docker deployment for Solidity release\nDESCRIPTION: This script deploys the Solidity release to Docker Hub. It requires the version number as an argument and `docker-buildx` to be installed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/docker_deploy_manual.sh v$VERSION\n```\n\n----------------------------------------\n\nTITLE: Accepting Xcode License - macOS\nDESCRIPTION: This command is used on macOS to accept the Xcode license agreement, which is a prerequisite for command-line builds after installing Xcode or a new version of Xcode. This command uses sudo to gain administrative privileges to accept the license.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/installing-solidity.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsudo xcodebuild -license accept\n```\n\n----------------------------------------\n\nTITLE: Solidity Override Keyword\nDESCRIPTION: The `override` keyword in Solidity indicates that a function, modifier, or public state variable is changing the behavior of an inherited function or modifier from a base contract. This ensures proper polymorphism and helps prevent accidental overriding.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/cheatsheet.rst#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Data Type Information\nDESCRIPTION: This JSON provides an example of type information within the storage layout output.  It defines the encoding, label, and number of bytes for a given type (in this case, uint256). The 'encoding' specifies how the data is stored, 'label' is the canonical type name, and 'numberOfBytes' indicates the storage size.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/internals/layout_in_storage.rst#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n        \"encoding\": \"inplace\",\n        \"label\": \"uint256\",\n        \"numberOfBytes\": \"32\",\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for yulPhaser\nDESCRIPTION: This code snippet defines the source files for the `yulPhaser` component, which implements a genetic algorithm-based optimizer for Yul code. It includes files for chromosome representation, fitness metrics, genetic algorithms, mutations, population management, program representation, and selections.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset(yul_phaser_sources\n    yulPhaser/TestHelpers.h\n    yulPhaser/TestHelpers.cpp\n    yulPhaser/TestHelpersTest.cpp\n    yulPhaser/Common.cpp\n    yulPhaser/Chromosome.cpp\n    yulPhaser/FitnessMetrics.cpp\n    yulPhaser/AlgorithmRunner.cpp\n    yulPhaser/GeneticAlgorithms.cpp\n    yulPhaser/Mutations.cpp\n    yulPhaser/PairSelections.cpp\n    yulPhaser/Phaser.cpp\n    yulPhaser/Population.cpp\n    yulPhaser/Program.cpp\n    yulPhaser/ProgramCache.cpp\n    yulPhaser/Selections.cpp\n    yulPhaser/SimulationRNG.cpp\n)\ndetect_stray_source_files(\"${yul_phaser_sources}\" \"yulPhaser/\")\n```\n\n----------------------------------------\n\nTITLE: Preparing Test Cases for Fuzzing\nDESCRIPTION: This bash snippet illustrates how to prepare test cases for fuzzing by creating a directory, navigating into it, and extracting Solidity source files from existing tests and documentation using the `isolate_tests.py` script.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmkdir /tmp/test_cases\ncd /tmp/test_cases\n# extract from tests:\npath/to/solidity/scripts/isolate_tests.py path/to/solidity/test/libsolidity/SolidityEndToEndTest.cpp\n# extract from documentation:\npath/to/solidity/scripts/isolate_tests.py path/to/solidity/docs\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: NumberLiteral\nDESCRIPTION: Defines a NumberLiteral as either a HexNumber or a DecimalNumber.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_33\n\nLANGUAGE: none\nCODE:\n```\nNumberLiteral = HexNumber | DecimalNumber\n```\n\n----------------------------------------\n\nTITLE: Creating a source tarball for Solidity release\nDESCRIPTION: This script creates a source tarball of the Solidity code for the release. It should be run on the tag to ensure the correct version is packaged. A `prerelease.txt` file is required for the script to run correctly.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/ReleaseChecklist.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nscripts/create_source_tarball.sh\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Demonstrates an incorrect function declaration with spacing issues, attempting to return a large named nested array `uint[200][2] a` along with a `uint x`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_5\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (\n    uint\n    [\n    200\n    ]\n    [2]\n    a, uint x);\n```\n\n----------------------------------------\n\nTITLE: Formatting Array Variable Declarations - Solidity\nDESCRIPTION: Shows how to correctly declare array variables in Solidity. There should be no space between the type and the brackets.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_21\n\nLANGUAGE: solidity\nCODE:\n```\nuint[] x;\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Flag for Visual Studio\nDESCRIPTION: This code snippet adds a special compilation flag (`/bigobj`) for Visual Studio (specifically version 2019) to handle the large size of `SolidityEndToEndTest.cpp`. This flag is used to increase the number of sections an object file can contain.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif (MSVC)\n    target_compile_options(soltest PUBLIC \"/bigobj\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define a Simple Solidity Contract\nDESCRIPTION: This snippet defines a basic Solidity contract named 'C' with a single public view function 'foo'. The code includes a SPDX license identifier and pragma statement specifying the Solidity compiler version.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract C {\n    function foo() public view {}\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Storage Layout Definition in Solidity\nDESCRIPTION: This code snippet demonstrates how to define a custom storage layout for a Solidity contract using the `layout at` specifier. The contract `C` specifies that its storage should start at slot `0xAAAA + 0x11`.  The array `x` occupies slots starting from `0xAABB`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/custom-storage-layout.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.29;\n\ncontract C layout at 0xAAAA + 0x11 {\n    uint[3] x; // Occupies slots 0xAABB..0xAABD\n}\n```\n\n----------------------------------------\n\nTITLE: C++ Test Assertion\nDESCRIPTION: This snippet is a C++ test assertion likely using the Boost Test framework. It asserts that the mutation of a `chromosome` object results in a new `Chromosome` object initialized with the string \"fo\". It tests a mutation function and its expected outcome.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/scripts/codespell_ignored_lines.txt#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nBOOST_TEST(mutation(chromosome) == Chromosome(\"fo\"));\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Block Evaluation\nDESCRIPTION: This snippet presents the formal evaluation function `E` for a Yul block. It details how the evaluation function processes a sequence of statements within a block, managing global and local state, and handling different modes (regular, break, continue, leave). It illustrates how the local state is restricted upon exiting the block to maintain scoping rules.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_40\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <{St1, ..., Stn}>: Block) =\n    let G1, L1, mode = E(G, L, St1, ..., Stn)\n    let L2 be a restriction of L1 to the identifiers of L\n    G1, L2, mode\n```\n\n----------------------------------------\n\nTITLE: Creating and linking the yul-phaser executable in CMake\nDESCRIPTION: This snippet creates an executable named `yul-phaser` from the source file `yulPhaser/main.cpp`. It then links the `yul-phaser` executable with the `phaser` library, meaning that the executable will be able to use the functions and data structures defined within the library. It is a PRIVATE link, so phaser's dependencies aren't visible to yul-phaser's consumers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(yul-phaser yulPhaser/main.cpp)\ntarget_link_libraries(yul-phaser PRIVATE phaser)\n```\n\n----------------------------------------\n\nTITLE: Building with Debug Symbols (Bash)\nDESCRIPTION: This code snippet shows how to configure CMake to build the Solidity project with debug symbols, enabling debugging of tests using GDB.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake\n```\n\n----------------------------------------\n\nTITLE: Build Solidity Docs with Shell Script\nDESCRIPTION: This shell script is used to install dependencies and build the Solidity documentation. It navigates to the `docs` directory and executes the `docs.sh` script. This will output the generated HTML files under the `_build/` directory.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd docs\n./docs.sh\n```\n\n----------------------------------------\n\nTITLE: Running Yul Phaser with Random Population\nDESCRIPTION: This command runs the `yul-phaser` tool with a random initial population of 100 sequences on Yul files located in the specified directory.  It assumes that the user is in the build directory of a Solidity repository working copy.  It is a basic invocation using sensible defaults.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntools/yul-phaser ../test/libyul/yulOptimizerTests/fullSuite/*.yul \\\n    --random-population 100\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Block\nDESCRIPTION: Defines the grammar for a Yul Block, consisting of zero or more statements enclosed in curly braces.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_14\n\nLANGUAGE: none\nCODE:\n```\nBlock = '{' Statement* '}'\n```\n\n----------------------------------------\n\nTITLE: Finding Threads Library\nDESCRIPTION: This snippet uses `find_package` to locate the Threads library, which is required for multi-threading support.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Threads)\n```\n\n----------------------------------------\n\nTITLE: Solidity Contract Definition\nDESCRIPTION: This snippet defines a simple Solidity contract named 'C'. It serves as a basic example for compilation and metadata generation. The contract itself does not contain any logic or state variables.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/solc_0.4.8_cli_output.txt#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract C {}\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe approvedHashes function signature\nDESCRIPTION: This is the signature for the `approvedHashes` function in the `GnosisSafe` contract.  It checks if a hash has been approved by an address.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_17\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  approvedHashes(address,bytes32)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: FalseLiteral\nDESCRIPTION: Defines FalseLiteral as the keyword 'false'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_36\n\nLANGUAGE: none\nCODE:\n```\nFalseLiteral = 'false'\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Switch Statement Evaluation (No Default)\nDESCRIPTION: This snippet defines the formal evaluation function `E` for a Yul `switch` statement without a default case. It transforms the switch statement into a switch statement with an empty default case.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_50\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn>: Switch) =\n    E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})\n```\n\n----------------------------------------\n\nTITLE: Linking Yul Library to Dependencies\nDESCRIPTION: This CMake command specifies the libraries that the Yul library depends on. These libraries include evmasm, solutil, langutil, smtutil, and fmt, providing necessary functionalities for assembly manipulation, Solidity utilities, language utilities, SMT solving, and formatting.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libyul/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(yul PUBLIC evmasm solutil langutil smtutil fmt::fmt-header-only)\n```\n\n----------------------------------------\n\nTITLE: Including Compiler Settings and Utilities\nDESCRIPTION: This snippet includes the EthCompilerSettings and EthUtils CMake modules, which likely contain configurations specific to the compiler being used and utility functions for the build process.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\n# Figure out what compiler and system are we using\ninclude(EthCompilerSettings)\n\n# Include utils\ninclude(EthUtils)\n```\n\n----------------------------------------\n\nTITLE: Function Visibility Specifiers Example Solidity\nDESCRIPTION: This code snippet demonstrates the usage of function visibility specifiers in Solidity, including `public`, `private`, `external`, and `internal`.  It shows how to define a function and declare its visibility, which determines where the function can be called from. No external dependencies are required.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/cheatsheet.rst#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction myFunction() <visibility specifier> returns (bool) {\n        return true;\n    }\n```\n\n----------------------------------------\n\nTITLE: Restarting Yul Phaser from a File\nDESCRIPTION: This command restarts the `yul-phaser` tool, loading a population of sequences from a file and saving the population after each round. This allows the user to continue a previous search and avoid starting from scratch. It utilizes the `--population-from-file` and `--population-autosave` options.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/tools/yulPhaser/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntools/yul-phaser *.yul                         \\\n    --population-from-file /tmp/population.txt \\\n    --population-autosave  /tmp/population.txt\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: IdentifierList\nDESCRIPTION: Defines the grammar for an IdentifierList, consisting of one or more Identifiers separated by commas.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_29\n\nLANGUAGE: none\nCODE:\n```\nIdentifierList = Identifier ( ',' Identifier)*\n```\n\n----------------------------------------\n\nTITLE: Contract Naming: Incorrect Contract and File Naming in Solidity\nDESCRIPTION: This snippet shows incorrect naming conventions for contracts and their files in Solidity.  Specifically, the contract name is `owned` (lowercase) but should be `Owned` (CapWords), which also impacts the file naming. It includes a sample contract `owned`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_30\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n// owned.sol\ncontract owned {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for smtutil Library\nDESCRIPTION: This snippet defines a variable named `sources` which contains a list of C++ and header files. These files constitute the source code for the `smtutil` library.  The list includes components related to SMT-LIB version 2 interface, parsing, context, and solvers.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsmtutil/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(sources\n\tCHCSmtLib2Interface.cpp\n\tCHCSmtLib2Interface.h\n\tExceptions.h\n\tSMTLib2Context.cpp\n\tSMTLib2Context.h\n\tSMTLib2Interface.cpp\n\tSMTLib2Interface.h\n\tSMTLib2Parser.cpp\n\tSMTLib2Parser.h\n\tSMTPortfolio.cpp\n\tSMTPortfolio.h\n\tSolverInterface.h\n\tSorts.cpp\n\tSorts.h\n\tHelpers.h\n)\n```\n\n----------------------------------------\n\nTITLE: ERC20Token symbol function signature\nDESCRIPTION: This is the signature for the `symbol` function in the `ERC20Token` contract. It returns the symbol of the token.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_11\n\nLANGUAGE: Solidity\nCODE:\n```\nERC20Token  symbol()\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Leave\nDESCRIPTION: Defines the grammar for the Leave statement, represented by the keyword 'leave'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_26\n\nLANGUAGE: none\nCODE:\n```\nLeave = 'leave'\n```\n\n----------------------------------------\n\nTITLE: Fine: Function Returning uint and Dynamic Array (Solidity)\nDESCRIPTION: Demonstrates a correct function definition that returns a uint `x` and a dynamic array `uint[] a`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_10\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() public pure  returns (uint x, uint[] a) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Solidity Common Library Sources\nDESCRIPTION: This snippet defines a list of source files that make up the Solidity Commons Library. These files include headers and source files related to character stream handling, error reporting, EVM versions, exceptions, parsing, scanning, source location, and token management.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/liblangutil/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(sources\n\tCommon.h\n\tCharStream.cpp\n\tCharStream.h\n\tDebugData.h\n\tDebugInfoSelection.cpp\n\tDebugInfoSelection.h\n\tErrorReporter.cpp\n\tErrorReporter.h\n\tEVMVersion.h\n\tEVMVersion.cpp\n\tExceptions.cpp\n\tExceptions.h\n\tParserBase.cpp\n\tParserBase.h\n\tScanner.cpp\n\tScanner.h\n\tCharStreamProvider.h\n\tSemVerHandler.cpp\n\tSemVerHandler.h\n\tSourceLocation.h\n\tSourceLocation.cpp\n\tSourceReferenceExtractor.cpp\n\tSourceReferenceExtractor.h\n\tSourceReferenceFormatter.cpp\n\tSourceReferenceFormatter.h\n\tToken.cpp\n\tToken.h\n\tUniqueErrorReporter.h\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for Yul Interpreter (CMake)\nDESCRIPTION: This snippet defines the source files that will be compiled into the Yul Interpreter library. The sources variable includes header (.h) and implementation (.cpp) files related to the EVM instruction interpreter and the interpreter itself, as well as inspector components.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/yulInterpreter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(sources\n\tEVMInstructionInterpreter.h\n\tEVMInstructionInterpreter.cpp\n\tInterpreter.h\n\tInterpreter.cpp\n\tInspector.h\n\tInspector.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Fine: Empty Comment (Solidity)\nDESCRIPTION: Illustrates a valid, empty comment block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_21\n\nLANGUAGE: Solidity\nCODE:\n```\n/**/\n```\n\n----------------------------------------\n\nTITLE: Creating Executable yulopti\nDESCRIPTION: This snippet creates an executable named `yulopti` from the source file `yulopti.cpp`. It links the executable against `solidity` and Boost libraries as PRIVATE dependencies. This means these libraries are required to build `yulopti` but not exposed to other targets.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(yulopti yulopti.cpp)\ntarget_link_libraries(yulopti PRIVATE solidity Boost::boost Boost::program_options Boost::system)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: TrueLiteral\nDESCRIPTION: Defines TrueLiteral as the keyword 'true'.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_35\n\nLANGUAGE: none\nCODE:\n```\nTrueLiteral = 'true'\n```\n\n----------------------------------------\n\nTITLE: Event Listener in JavaScript (web3.js)\nDESCRIPTION: This JavaScript code uses web3.js to listen for 'Sent' events emitted by the 'Coin' contract. It logs the details of the coin transfer, including the sender, receiver, and amount, and also displays the updated balances of both parties.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/introduction-to-smart-contracts.rst#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nCoin.Sent().watch({}, '', function(error, result) {\n    if (!error) {\n        console.log(\"Coin transfer: \" + result.args.amount +\n            \" coins were sent from \" + result.args.from +\n            \" to \" + result.args.to + \".\");\n        console.log(\"Balances now:\\n\" +\n            \"Sender: \" + Coin.balances.call(result.args.from) +\n            \"Receiver: \" + Coin.balances.call(result.args.to));\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for solutil Library (CMake)\nDESCRIPTION: This snippet defines the source files used to build the `solutil` library.  It lists all header and source files required for the library's compilation. No dependencies beyond the mentioned files themselves.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libsolutil/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(sources\n\tAlgorithms.h\n\tAnsiColorized.h\n\tAssertions.h\n\tCommon.h\n\tCommonData.cpp\n\tCommonData.h\n\tCommonIO.cpp\n\tCommonIO.h\n\tDisjointSet.cpp\n\tDisjointSet.h\n\tDominatorFinder.h\n\tExceptions.cpp\n\tExceptions.h\n\tErrorCodes.h\n\tFixedHash.h\n\tFunctionSelector.h\n\tIpfsHash.cpp\n\tIpfsHash.h\n\tJSON.cpp\n\tJSON.h\n\tKeccak256.cpp\n\tKeccak256.h\n\tLazyInit.h\n\tLEB128.h\n\tNumeric.cpp\n\tNumeric.h\n\tpicosha2.h\n\tProfiler.cpp\n\tProfiler.h\n\tResult.h\n\tSetOnce.h\n\tStackTooDeepString.h\n\tStringUtils.cpp\n\tStringUtils.h\n\tSwarmHash.cpp\n\tSwarmHash.h\n\tTemporaryDirectory.cpp\n\tTemporaryDirectory.h\n\tUTF8.cpp\n\tUTF8.h\n\tvector_ref.h\n\tViews.h\n\tVisitor.h\n\tWhiskers.cpp\n\tWhiskers.h\n)\n```\n\n----------------------------------------\n\nTITLE: Yul Formal Specification - Variable Declaration Evaluation (Assignment)\nDESCRIPTION: This code snippet presents the formal evaluation function `E` for a Yul variable declaration with assignment.  It simplifies the evaluation by transforming the declaration into an assignment operation, delegating the evaluation to the assignment function.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_43\n\nLANGUAGE: none\nCODE:\n```\nE(G, L, <let var_1, ..., var_n := rhs>: VariableDeclaration) =\n    E(G, L, <var_1, ..., var_n := rhs>: Assignment)\n```\n\n----------------------------------------\n\nTITLE: Setting Default Build Type\nDESCRIPTION: This snippet sets the default build type if none is specified. It checks for the existence of a .git directory to determine whether to use \"RelWithDebInfo\" or \"Release\".\nSOURCE: https://github.com/ethereum/solidity/blob/develop/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n\tif(EXISTS \"${PROJECT_SOURCE_DIR}/.git\")\n\t\tset(DEFAULT_BUILD_TYPE \"RelWithDebInfo\")\n\telse()\n\t\tset(DEFAULT_BUILD_TYPE \"Release\")\n\tendif()\n\tset(CMAKE_BUILD_TYPE \"${DEFAULT_BUILD_TYPE}\" CACHE STRING \"Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel\" FORCE)\n\tset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"RelWithDebInfo\" \"MinSizeRel\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Function Argument Evaluation Order (Solidity)\nDESCRIPTION: Demonstrates the evaluation order of function argument expressions. The example shows that function argument expressions are generally evaluated in the same order by both code generators, except for `addmod` and `mulmod` where the order is reversed.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/ir-breaking-changes.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\ncontract C {\n    function add(uint8 a, uint8 b) public pure returns (uint8) {\n        return a + b;\n    }\n    function g(uint8 a, uint8 b) public pure returns (uint8) {\n        return add(++a + ++b, a + b);\n    }\n}\n```\n\nLANGUAGE: Solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\ncontract C {\n    function f() public pure returns (uint256 aMod, uint256 mMod) {\n        uint256 x = 3;\n        // Old code gen: add/mulmod(5, 4, 3)\n        // New code gen: add/mulmod(4, 5, 5)\n        aMod = addmod(++x, ++x, x);\n        mMod = mulmod(++x, ++x, x);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Buggy: Nested Array Function Return (Solidity)\nDESCRIPTION: Shows incorrect function definition attempting to return a uint and a named fixed-size nested array `uint[200][2] a`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_2\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction f() returns (uint x, uint[200][2] a) { }\n```\n\n----------------------------------------\n\nTITLE: GnosisSafe checkNSignatures function signature\nDESCRIPTION: This is the signature for the `checkNSignatures` function in the `GnosisSafe` contract. It likely verifies N signatures against a given hash.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/eth_gas_report_gnosis.rst#_snippet_20\n\nLANGUAGE: Solidity\nCODE:\n```\nGnosisSafe  checkNSignatures(bytes32,bytes,bytes,uint256)\n```\n\n----------------------------------------\n\nTITLE: Define an Empty Solidity Contract with Indentation\nDESCRIPTION: This snippet defines an empty Solidity contract named 'E'. The code-block directives are indented which, based on the surrounding text, shouldn't cause Sphinx to complain.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block_with_directives.rst#_snippet_4\n\nLANGUAGE: Solidity\nCODE:\n```\ncontract E {}\n```\n\n----------------------------------------\n\nTITLE: AFL Error: No Instrumentation Detected\nDESCRIPTION: This text snippet shows the error message that appears if the target binary (solfuzzer) is not properly instrumented with AFL during compilation. It indicates that AFL cannot function without this instrumentation.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nafl-fuzz 2.52b by <lcamtuf@google.com>\n... (truncated messages)\n[*] Validating target binary...\n\n[-] Looks like the target binary is not instrumented! The fuzzer depends on\n    compile-time instrumentation to isolate interesting test cases while\n    mutating the input data. For more information, and for tips on how to\n    instrument binaries, please see /usr/share/doc/afl-doc/docs/README.\n\n    When source code is not available, you may be able to leverage QEMU\n    mode support. Consult the README for tips on how to enable this.\n    (It is also possible to use afl-fuzz as a traditional, \"dumb\" fuzzer.\n    For that, you can use the -n option - but expect much worse results.)\n\n[-] PROGRAM ABORT : No instrumentation detected\n         Location : check_binary(), afl-fuzz.c:6920\n```\n\n----------------------------------------\n\nTITLE: Docker Command\nDESCRIPTION: This is a Docker command used to run a container from the `trzeci/emscripten:sdk-tag-1.39.3-64bit` image. It mounts volumes for output and scripts, runs the `rebuild_tags.sh` script within the container, and passes the specified tags and output directory as arguments. The `--rm` flag ensures the container is removed after execution.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/scripts/codespell_ignored_lines.txt#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndocker run --rm -v \"${OUTPUTDIR}\":/tmp/output -v \"${SCRIPTDIR}\":/tmp/scripts:ro -it trzeci/emscripten:sdk-tag-1.39.3-64bit /tmp/scripts/docker-scripts/rebuild_tags.sh \"${TAGS}\" /tmp/output \"$@\"\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Logs with Web3.js\nDESCRIPTION: This JavaScript code snippet demonstrates how to subscribe to logs using the web3.js library, filtering by address and topics. It sets up an event listener to handle incoming log data.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contracts/events.rst#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar options = {\n        fromBlock: 0,\n        address: web3.eth.defaultAccount,\n        topics: [\"0x0000000000000000000000000000000000000000000000000000000000000000\", null, null]\n    };\n    web3.eth.subscribe('logs', options, function (error, result) {\n        if (!error)\n            console.log(result);\n    })\n        .on(\"data\", function (log) {\n            console.log(log);\n        })\n        .on(\"changed\", function (log) {\n    });\n```\n\n----------------------------------------\n\nTITLE: Building Solidity with AFL (Alternative)\nDESCRIPTION: This bash snippet provides an alternative configuration for building Solidity with AFL, using `afl-clang` and `afl-clang++` instead of `afl-gcc` and `afl-g++`. This is useful if the initial build fails.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/contributing.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# if previously failed\nmake clean\ncmake .. -DCMAKE_C_COMPILER=path/to/afl-clang -DCMAKE_CXX_COMPILER=path/to/afl-clang++\nmake solfuzzer\n```\n\n----------------------------------------\n\nTITLE: Solidity Import with Remapped Relative Path\nDESCRIPTION: This example illustrates how remapping affects relative imports in Solidity.  The relative path `./util.sol` will be resolved and then remapped according to command line arguments.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/path-resolution.rst#_snippet_15\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"./util.sol\" as util; // source unit name: b/util.sol\n```\n\n----------------------------------------\n\nTITLE: Adding GPL Notice to Source Files\nDESCRIPTION: This snippet demonstrates the standard GPL notice to include at the beginning of each source file in a software project licensed under the GNU General Public License. It includes the program's name, copyright information, license details, warranty disclaimer, and instructions on how to access the full license text.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/LICENSE.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n```\n\n----------------------------------------\n\nTITLE: Build Docker Image for Solidity OSS Fuzzing\nDESCRIPTION: This command builds a local Docker image from the provided Dockerfile. The image is named `solidity-ossfuzz-local` and is used to create a container with the necessary dependencies and compiler versions for fuzzing.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd .circleci/docker\n$ docker build -t solidity-ossfuzz-local -f Dockerfile.ubuntu.clang.ossfuzz .\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly: Support for True and False Literals - Yul\nDESCRIPTION: Adds support for the literals `true` and `false` within inline assembly (Yul). This simplifies boolean logic operations within assembly code.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/Changelog.md#_snippet_21\n\nLANGUAGE: Yul\nCODE:\n```\nInline Assembly: Support literals ``true`` and ``false``.\n```\n\n----------------------------------------\n\nTITLE: Displaying GPL Notice in Terminal Interaction\nDESCRIPTION: This snippet illustrates how to display a brief GPL notice when a program starts in an interactive terminal mode. It includes the program's name, copyright information, a warranty disclaimer, and instructions on how to access more details about the license and redistribution conditions. The commands `show w` and `show c` are placeholders for displaying the warranty and license information, respectively.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/LICENSE.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n<program>  Copyright (C) <year>  <name of author>\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Python Exception Handling\nDESCRIPTION: This snippet shows a Python assertion and an assignment. The assertion checks if the string '401 Client Error: Unauthorized' is present in the string representation of a manager's exception. The next line simply assigns the value of 'abd' to variable 'a'. It shows exception handling and variable assignments.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/scripts/codespell_ignored_lines.txt#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nself.assertIn('401 Client Error: Unauthorized', str(manager.exception))\na = abd;\n```\n\n----------------------------------------\n\nTITLE: Define strictasm_diff_ossfuzz Executable and Properties (CMake)\nDESCRIPTION: This CMake snippet defines the `strictasm_diff_ossfuzz` executable, specifying its source files (`strictasm_diff_ossfuzz.cpp`, `yulFuzzerCommon.cpp`), linking libraries (`libsolc`, `evmasm`, `yulInterpreter`), and setting the `LINK_FLAGS` property to `${LIB_FUZZING_ENGINE}`.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/tools/ossfuzz/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif (OSSFUZZ)\n    add_executable(strictasm_diff_ossfuzz strictasm_diff_ossfuzz.cpp yulFuzzerCommon.cpp)\n    target_link_libraries(strictasm_diff_ossfuzz PRIVATE libsolc evmasm yulInterpreter)\n    set_target_properties(strictasm_diff_ossfuzz PROPERTIES LINK_FLAGS ${LIB_FUZZING_ENGINE})\nendif()\n```\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n    add_library(strictasm_diff_ossfuzz\n            strictasm_diff_ossfuzz.cpp\n            yulFuzzerCommon.cpp\n            )\n    target_link_libraries(strictasm_diff_ossfuzz PRIVATE libsolc evmasm yulInterpreter)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This code snippet adds the `tools` and `evmc` subdirectories to the build process. This allows CMake to process the `CMakeLists.txt` files located in those directories.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(tools)\nadd_subdirectory(evmc)\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Identifier\nDESCRIPTION: Defines the grammar for an Identifier, starting with a letter, underscore or dollar sign, followed by zero or more alphanumeric characters, underscores, dollar signs or dots.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_28\n\nLANGUAGE: none\nCODE:\n```\nIdentifier = [a-zA-Z_$] [a-zA-Z_$0-9.]*\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Assignment\nDESCRIPTION: Defines the grammar for Assignment using an IdentifierList, the ':=', and an Expression.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_18\n\nLANGUAGE: none\nCODE:\n```\nAssignment =\n    IdentifierList ':=' Expression\n```\n\n----------------------------------------\n\nTITLE: Fine: Exponentiation with Constant 2 (Solidity)\nDESCRIPTION: Illustrates the correct usage of the exponentiation operator `**` (no space) with a constant exponent of 2.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_18\n\nLANGUAGE: Solidity\nCODE:\n```\nx**2\n```\n\n----------------------------------------\n\nTITLE: Solidity: Invalid Code Example\nDESCRIPTION: Illustrates a case where the Solidity compiler does not accept code involving number literal expressions used with non-literal expressions due to type incompatibility.  The specific case involves trying to add a `uint128` type to a number literal that would result in a non-integer without a common type.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/types/value-types.rst#_snippet_14\n\nLANGUAGE: Solidity\nCODE:\n```\nuint128 a = 1;\nuint128 b = 2.5 + a + 0.5;\n```\n\n----------------------------------------\n\nTITLE: Fine: Event Enum with ABIEncoderV2 (Solidity)\nDESCRIPTION: Demonstrates a contract `C` with a struct `S` and an event `G` using an enum, which is generally handled well with ABIEncoderV2.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/buglist_test_vectors.md#_snippet_24\n\nLANGUAGE: Solidity\nCODE:\n```\npragma experimental ABIEncoderV2;\ncontract C\n{\n\tstruct S { uint x; }\n\tenum A { B, C }\n\tevent G(A);\n}\n```\n\n----------------------------------------\n\nTITLE: Yul Grammar: Default\nDESCRIPTION: Defines the grammar for the Default case within a Switch statement, including the 'default' keyword and Block.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/yul.rst#_snippet_23\n\nLANGUAGE: none\nCODE:\n```\nDefault =\n    'default' Block\n```\n\n----------------------------------------\n\nTITLE: Set Directory Properties with CMake\nDESCRIPTION: This sets the CMAKE_CONFIGURE_DEPENDS property for the current directory. This ensures that the CMake configuration is re-run if any files within the src directory are modified.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/libstdlib/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_directory_properties(PROPERTY CMAKE_CONFIGURE_DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/src/)\n```\n\n----------------------------------------\n\nTITLE: Defining an Empty Solidity Contract\nDESCRIPTION: This code snippet defines an empty Solidity contract named 'C'. It serves as a basic example for demonstrating contract declaration in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/test/scripts/fixtures/code_block.rst#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\ncontract C {}\n```\n\n----------------------------------------\n\nTITLE: Contract Import: Correct Contract Import Statement in Solidity\nDESCRIPTION: This snippet shows the correct way to import a contract in Solidity, ensuring that the correct version is specified in the pragma and the import path is accurate.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_29\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\nimport \"./Owned.sol\";\n\n\ncontract Congress is Owned, TokenRecipient {\n    //...\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Multiline Output Parameters/Return Statements - Solidity\nDESCRIPTION: Demonstrates the suggested style for multiline output parameters and return statements in Solidity, aligning with maximum line length guidelines.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_17\n\nLANGUAGE: solidity\nCODE:\n```\nfunction thisFunctionNameIsReallyLong(\n    address a,\n    address b,\n    address c\n)\n    public\n    returns (\n        address someAddressName,\n        uint256 LongArgument,\n        uint256 Argument\n    )\n{\n    doSomething()\n\n    return (\n        veryLongReturnArg1,\n        veryLongReturnArg2,\n        veryLongReturnArg3\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Short Single-Line Functions - Solidity\nDESCRIPTION: Demonstrates that declaring short functions with a single statement on a single line is permissible in Solidity.\nSOURCE: https://github.com/ethereum/solidity/blob/develop/docs/style-guide.rst#_snippet_19\n\nLANGUAGE: solidity\nCODE:\n```\nfunction shortFunction() public { doSomething(); }\n```"
  }
]