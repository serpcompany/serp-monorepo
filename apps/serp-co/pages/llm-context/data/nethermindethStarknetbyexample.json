[
  {
    "owner": "nethermindeth",
    "repo": "starknetbyexample",
    "content": "TITLE: Defining ERC20 Interface in Cairo\nDESCRIPTION: This code snippet defines the interface for an ERC20 token contract in Cairo for Starknet.  It outlines the standard functions required for an ERC20 token, such as `transfer`, `balance_of`, and `total_supply`. The interface adheres to Starknet's snake_case naming convention.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/erc20.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/erc20/src/token.cairo:interface]\n```\n\n----------------------------------------\n\nTITLE: Writing SimpleStorage Contract in Cairo\nDESCRIPTION: Implements a SimpleStorage contract in Cairo that allows on-chain storage and retrieval of a single numeric value. The contract exposes two external entry points: one for setting and one for getting the value. Requires the Starknet toolchain and follows standard variable definitions and ABI exposure patterns. Inputs include an unsigned integer for storage; outputs are the stored unsigned integer. All modifications are persistent in blockchain state and require deployment to a Starknet-compatible testnet or mainnet.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/src/storage.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing ERC20 Interface in Cairo\nDESCRIPTION: This code snippet provides a concrete implementation of the ERC20 interface in Cairo for a Starknet contract. It showcases how the interface functions are implemented with the necessary logic for token management, including state updates and event emissions. The full implementation details are in the referenced file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/erc20.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/erc20/src/token.cairo:erc20]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Staking Contract in Cairo for StarkNet\nDESCRIPTION: A complete implementation of a staking contract in Cairo that allows users to stake ERC20 tokens and earn rewards. The contract includes functionality for staking/unstaking tokens, calculating and distributing rewards, and managing reward rates. It features event emissions for key actions and supports dynamic reward adjustment.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/staking.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/staking/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Implementing the Crowdfunding Campaign Contract in Cairo\nDESCRIPTION: Implements the main 'Campaign' smart contract in Cairo. This contract incorporates the 'Pledgeable' component to handle pledge management and defines the core logic for the crowdfunding platform, including campaign creation, pledging/unpledging tokens, locking funds upon reaching the goal, allowing creators to claim successful campaigns or cancel them, enabling pledgers to retrieve funds from failed campaigns, and providing admin functionality for contract upgrades.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/crowdfunding.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/crowdfunding/src/campaign.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing Starknet Account Spending Limit Contract in Cairo\nDESCRIPTION: This code snippet represents the full implementation of a Starknet account contract designed with spending limits. It includes logic to identify 'approve' and 'transfer' calls as spending transactions based on the SNIP-2 ERC-20 standard. The contract maintains spending limits per token, decreases the limit upon detected spending calls, and reverts transactions if the limit is exceeded. Limits are set with a specific duration and cannot be changed after creation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/account_abstraction/account_spending_limits.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/account_spending_limits/src/account.cairo]\n```\n\n----------------------------------------\n\nTITLE: Upgradeable Contract Definition in Cairo - Version 0\nDESCRIPTION: This snippet defines the initial version (V0) of an upgradeable contract in Cairo for Starknet. It specifies the contract's structure and behaviors, serving as the foundational implementation deployed initially. The contract includes public methods and state variables that manage the contract logic. Dependencies include the Starknet environment and Cairo language tooling. The expected input involves deploying the contract to obtain a deployed instance with a unique contract address. Outputs include the state and functions exposed by the contract. This serves as the base contract for future upgrades.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/upgradeable_contract.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/upgradeable_contract/src/upgradeable_contract_v0.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple DeFi Vault in Cairo\nDESCRIPTION: This Cairo smart contract implements a DeFi Vault where users deposit tokens to mint shares proportional to their contribution. Upon withdrawal, users burn their shares and receive both their initial deposited tokens and any accumulated yield. The contract performs calculations to determine share minting and yield distribution, managing user balances and token accounting. It depends on standard Cairo libraries for Starknet contract development and token handling. Inputs include deposit and withdrawal actions along with token amounts; outputs are updated share balances and token transfers. Constraints include correct share calculation and secure token management.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_vault.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/simple_vault/src/simple_vault.cairo]\n```\n\n----------------------------------------\n\nTITLE: Define ERC721 Interface in Cairo\nDESCRIPTION: Defines the standard interface that an ERC721 token contract must implement in Cairo for Starknet. This interface specifies functions like `balanceOf`, `ownerOf`, `transferFrom`, etc., adapted to Starknet's snake_case naming convention.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/erc721.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/erc721/src/interfaces.cairo:interface]\n```\n\n----------------------------------------\n\nTITLE: Implementing Crowdfunding Advanced Factory - Cairo\nDESCRIPTION: This code snippet represents the core implementation of the Advanced Factory contract in Cairo. It includes the necessary logic for deploying new instances of the Campaign contract, tracking deployed campaigns, and managing the class hash used for new deployments and potential upgrades. This contract acts as the central point for standardized campaign creation and management.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/advanced_factory.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/advanced_factory/src/contract.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBridge Contract in Solidity for Ethereum\nDESCRIPTION: Defines the TokenBridge contract on Ethereum responsible for interacting with the Starknet L2 contract to facilitate token minting and burning by exchanging messages through the cross-chain communication infrastructure. It manages locking, minting, and withdrawing tokens between Ethereum and Starknet. Inputs consist of cross-chain messages specifying token amounts and recipients, and outputs include emitting events for state synchronization and triggering mint/burn operations on Ethereum tokens. Manual withdrawal consumption is necessary on Ethereum to finalize transfers, and bridging times vary between L1 to L2 and L2 to L1.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_6\n\nLANGUAGE: solidity\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/solidity/src/TokenBridge.sol]\n```\n\n----------------------------------------\n\nTITLE: Creating IMintableToken Interface in Cairo for Starknet Token Operations\nDESCRIPTION: Defines the IMintableToken interface representing any token that supports minting and burning, enabling the TokenBridge to interact generically with tokens without knowledge of internal implementation. This interface specifies the required functions for token minting and burning that the TokenBridge depends on to execute cross-chain transfers. It is a prerequisite dependency for the TokenBridge contract. Expected inputs include token recipient addresses and token amounts, while the output is the execution of mint or burn operation on the token contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Defining Solidity Interface IMintableToken for Ethereum Mintable Tokens\nDESCRIPTION: Declares the Solidity interface for a mintable and burnable token contract on Ethereum. This interface outlines the essential functions such as mint and burn that any compatible token must implement to be used in the token bridge. It requires input parameters like recipient addresses and token amounts for minting/burning. Outputs are state changes in token supply and balances. This interface serves as a prerequisite for mock token and bridge contracts interacting with tokens on Ethereum.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/solidity/src/IMintableToken.sol]\n```\n\n----------------------------------------\n\nTITLE: Deploying SimpleCounter with Factory Contract in Cairo\nDESCRIPTION: This Cairo code represents a minimal factory contract designed to deploy instances of the `SimpleCounter` contract.  It includes functions to create new counter instances and update the `SimpleCounter` class hash, enabling contract upgrades.  It lacks access control, deployed contract tracking, and event emission for simplicity.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/factory.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/factory/src/simple_factory.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing TokenBridge Contract in Starknet Using Cairo\nDESCRIPTION: Defines the TokenBridge contract on Starknet that handles communication with Ethereum for cross-chain minting and burning of tokens. It interacts with the IMintableToken interface to perform minting and burning regardless of token specifics. This contract listens to messages from L1, triggering minting operations and emits events to confirm state changes. Prerequisites include the Cairo programming environment and Starknet deployment setup. Inputs consist of cross-chain messages specifying token amounts and recipient addresses. Outputs include on-chain token minting events and state updates enabling cross-chain synchronization.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Mintable Token Contract in Solidity for Ethereum\nDESCRIPTION: Provides a mock token implementation in Solidity compatible with the IMintableToken interface, mimicking minting and burning behavior for testing the token bridge on Ethereum. This contract emits appropriate events during token state changes to verify cross-chain message handling. Inputs include token recipient addresses and amounts, while outputs include event emissions and updated balances. The contract requires Solidity development environment and is used as the token counterpart to the Starknet mock token.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/solidity/src/MintableTokenMock.sol]\n```\n\n----------------------------------------\n\nTITLE: Defining ISRC5 Trait in Cairo\nDESCRIPTION: This snippet defines the `ISRC5` trait, which specifies the interface for interface detection. It includes the `supports_interface` function, which allows querying whether a contract implements a specific interface defined by its identifier. This is crucial for interoperability.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/account_abstraction/account_contract.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n```cairo\n/// @title SRC-5 Standard Interface Detection\ntrait ISRC5 {\n    /// @notice Query if a contract implements an interface\n    /// @param interface_id The interface identifier, as specified in SRC-5\n    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n    fn supports_interface(interface_id: felt252) -> bool;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Constant Product AMM Contract in Cairo\nDESCRIPTION: This code snippet represents the Cairo implementation of the Constant Product Automated Market Maker contract. It includes functions for swapping tokens based on the constant product formula (x * y = k), adding liquidity by providing tokens in the current reserve ratio, and removing liquidity by burning shares. Users must call the `approve()` function on the respective ERC20 token contracts before interacting with these AMM functions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/constant-product-amm.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/constant_product_amm/src/contracts.cairo:ConstantProductAmmContract]\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Mintable Token in Cairo for Testing Cross-Chain Bridge\nDESCRIPTION: Provides a mock implementation of a mintable and burnable token contract in Cairo. This mock token emits events on minting and burning operations to verify the success of cross-chain communication through the TokenBridge contract. Dependencies include the IMintableToken interface and Starknet Cairo environment. Inputs are recipient addresses and token amounts, while outputs involve state changes in token balances and event emissions for observability during testing.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/src/mintable_token_mock.cairo]\n```\n\n----------------------------------------\n\nTITLE: Starknet Foundry Event Testing (cairo)\nDESCRIPTION: This snippet highlights the process of testing event emissions within a Starknet Foundry environment. This verifies that specific events are correctly emitted based on contract execution. This is crucial for validating the proper functionality of event-driven contract logic.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/testing_how_to/src/test_contract.cairo:tests_with_events]\n```\n\n----------------------------------------\n\nTITLE: Defining Solidity Interface IMintableTokenEvents for Ethereum Token Events\nDESCRIPTION: Specifies the Solidity interface declaring the events related to minting and burning tokens on Ethereum. This interface is used to monitor and respond to mint and burn operations within the Ethereum mock token and bridge implementations. The interface requires no input parameters but defines emitted events for tracking token state changes. It is a prerequisite for Ethereum-side token contracts involved in the token bridge.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/l1_l2_token_bridge.md#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// [!include ~/listings/applications/l1_l2_token_bridge/solidity/src/IMintableTokenEvents.sol]\n```\n\n----------------------------------------\n\nTITLE: Including Cairo Contract Demonstrating Map Usage\nDESCRIPTION: This snippet is an include directive that points to a complete Cairo contract file. The included code demonstrates the practical application of mappings within a Starknet contract's storage, including declaring a map within the `Storage` struct and performing read/write operations. It implies the contract utilizes the `StorageMapReadAccess` and `StorageMapWriteAccess` traits.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/mappings.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/mappings/src/mappings.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing CoinFlip using Pragma VRF - Cairo\nDESCRIPTION: This snippet represents the implementation of a CoinFlip contract in Cairo that leverages the Pragma VRF service for generating randomness. The contract allows users to flip a virtual coin and receive a random outcome (Heads or Tails). It requires interaction with Pragma's Randomness Oracle to retrieve a random value and emit events based on the outcome.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/random_number_generator.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/coin_flip/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Starknet Foundry Basic Test Structure (cairo)\nDESCRIPTION: This code snippet shows the basic structure of a test function in Cairo using Starknet Foundry. The `#[test]` attribute marks a function as a test. Tests that are expected to fail will also use the `#[should_panic]` attribute. The provided example will show how a complete test will look.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/testing_how_to/src/test_contract.cairo:tests]\n```\n\n----------------------------------------\n\nTITLE: Implement ERC721 Contract in Cairo\nDESCRIPTION: Provides an example implementation of the ERC721 interface in Cairo. This snippet demonstrates how to build the logic for the functions required by the ERC721 standard on Starknet. Alternative implementations like OpenZeppelin's are also available.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/erc721.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/erc721/src/erc721.cairo]\n```\n\n----------------------------------------\n\nTITLE: Declaring Cairo Map with Composite Key\nDESCRIPTION: This snippet shows the syntax for declaring a Cairo map (`Map`) that uses a composite key. The key type is defined as a tuple `(ContractAddress, ContractAddress)`, suitable for scenarios like an ERC20 allowance where the key represents the owner and spender addresses. The value type in this example is `felt252`, representing the allowance amount.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/mappings.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nMap<(ContractAddress, ContractAddress), felt252>  // (owner, spender) -> amount\n```\n\n----------------------------------------\n\nTITLE: Setting Stored Data in Contract via set() - JavaScript\nDESCRIPTION: Invokes the 'set' method on the SimpleStorage contract with Starknet-js, passing the new unsigned integer value as calldata. Requires a valid Account object to sign the transaction and proper network connectivity to Starknet. The transaction submission and confirmation are asynchronous, and output is a transaction receipt or confirmation that the value is set.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:set]\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Enums with Multiple Data Types in Cairo\nDESCRIPTION: This snippet demonstrates how to define enums in Cairo that hold different data types including unit types, structs, other enums, tuples, core library types, arrays, and dictionaries. It highlights the flexibility of enums as expressions that can return values and improve strong type checking and structured control flows such as pattern matching. This snippet assumes a basic Cairo development environment and no external dependencies are required.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/enums.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/enum_example.cairo:enums]\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Contract using Ownable Component in Cairo\nDESCRIPTION: This snippet presents a mock contract implemented in Cairo that utilizes the `Ownable` component. The mock contract demonstrates how the `Ownable` component is integrated and used.  This contract inherits functionality from the `Ownable` component to allow the owner to call methods and uses the `_assert_is_owner` function to verify the caller's ownership status.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/ownable.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/ownable.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Creating Contract Object from ABI and Address (JavaScript)\nDESCRIPTION: Creates a Starknet-js Contract object by supplying the ABI and contract address, enabling function invocation and state querying on the deployed contract. The ABI is read from a JSON file generated during deployment and must match the live contract. Contract address should be that of the deployed SimpleStorage instance.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst contractAddress = 'PASTE_CONTRACT_ADDRESS_HERE';\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:contract]\n```\n\n----------------------------------------\n\nTITLE: Reading Stored Data from Contract via get() - JavaScript\nDESCRIPTION: Calls the 'get' method of the SimpleStorage contract instance using Starknet-js, retrieving the currently stored unsigned integer value. Requires that both the provider and contract objects are correctly initialized. Outputs the value to the console or UI, depending on code implementation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:get]\n```\n\n----------------------------------------\n\nTITLE: Using Enums in Contracts with Trait Derivations for Storage and Serialization in Cairo\nDESCRIPTION: This snippet illustrates how enums can be used inside a Cairo contract, showing the need to explicitly implement the Store trait for the enums and all their variants to be stored in contract storage. It includes an example of deriving traits such as starknet::Store for storage capabilities, as well as Serde and Drop traits to enable passing enums as parameters and return values in contract entrypoints. The contract example demonstrates these concepts in practice with relevant trait derivations for proper enum handling.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/enums.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/enum_example.cairo:enum_contract]\n```\n\n----------------------------------------\n\nTITLE: Deploying Contracts in Cairo\nDESCRIPTION: Deploys a new contract instance with the specified class hash and constructor parameters. Returns the deployed address and constructor result.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nfn deploy_syscall(\n    class_hash: ClassHash,\n    contract_address_salt: felt252,\n    calldata: Span<felt252>,\n    deploy_from_zero: bool,\n) -> SyscallResult<(ContractAddress, Span::<felt252>)>\n```\n\n----------------------------------------\n\nTITLE: Creating Provider and Setting Account Address in JavaScript\nDESCRIPTION: Initializes a Starknet Provider object for sending queries and transactions to the network, and defines the account address as a constant. The provider acts as a bridge between the client and the Starknet node. Requires input of a valid account address and may depend on network configuration.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:provider]\nconst accountAddress = // 'PASTE_ACCOUNT_ADDRESS_HERE';\n```\n\n----------------------------------------\n\nTITLE: Implementing a Caller Contract with Dispatcher Pattern in Cairo\nDESCRIPTION: Implementation of a Caller contract that interacts with the Callee contract using the dispatcher pattern for type-safe contract calls.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/calling_other_contracts.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// Define the Callee contract interface again (or import it)\n#[starknet::interface]\ntrait ICallee<TContractState> {\n    fn set_value(ref self: TContractState, new_value: u128);\n    fn get_value(self: @TContractState) -> u128;\n}\n\n// Implementation of the Caller contract\n#[starknet::contract]\nmod Caller {\n    // Import the dispatcher trait\n    use super::ICalleeDispatcherTrait;\n    use super::ICalleeDispatcher;\n\n    #[storage]\n    struct Storage {\n        callee_addr: starknet::ContractAddress,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, callee_addr_: starknet::ContractAddress) {\n        self.callee_addr.write(callee_addr_);\n    }\n\n    #[external(v0)]\n    fn set_callee_value(ref self: ContractState, new_value: u128) {\n        // Create a dispatcher instance with the callee's address\n        let callee_dispatcher = ICalleeDispatcher { contract_address: self.callee_addr.read() };\n        \n        // Call the callee's set_value function through the dispatcher\n        callee_dispatcher.set_value(new_value);\n    }\n\n    #[external(v0)]\n    fn get_callee_value(self: @ContractState) -> u128 {\n        // Create a dispatcher instance with the callee's address\n        let callee_dispatcher = ICalleeDispatcher { contract_address: self.callee_addr.read() };\n        \n        // Call the callee's get_value function through the dispatcher and return the result\n        callee_dispatcher.get_value()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Commit-Reveal Contract in Cairo\nDESCRIPTION: An example showing how to interact with the Commit-Reveal contract, demonstrating the process of creating a commitment off-chain and then revealing it. Includes the computation of the hash using Poseidon.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/commit-reveal.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/commit_reveal/src/commit_reveal.cairo:offchain]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Stateful Counter Contract using Cairo\nDESCRIPTION: This Cairo contract defines a state variable 'counter' initialized to zero and provides two entrypoints: 'increment' and 'decrement' to modify the counter by increasing or decreasing it by one respectively. The contract demonstrates basic management of persistent state variables and function invocation in a StarkNet smart contract. It requires the Cairo language environment and appropriate compiler setup. Inputs are implicit calls to the entrypoints without parameters, and output is the updated persistent state of 'counter'. Limitations include simplistic increment/decrement logic without boundary checks.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/counter.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/counter/src/counter.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Upgradeable Contract Definition in Cairo - Version 1\nDESCRIPTION: This snippet provides the updated version (V1) of the upgradeable contract in Cairo. It represents the new implementation to which a deployed V0 instance can be upgraded by changing its associated class hash. The code includes modifications or additional functionalities beyond V0. It requires the same Starknet and Cairo environment and is dependent on the initial contract's storage layout staying compatible as storage is preserved upon upgrade. Inputs include transactions invoking upgrade functionality with the new class hash; outputs reflect changes in contract behavior after upgrade.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/upgradeable_contract.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/upgradeable_contract/src/upgradeable_contract_v1.cairo]\n```\n\n----------------------------------------\n\nTITLE: Getting Execution Information in Cairo\nDESCRIPTION: Returns information about the current execution context. Two versions are available, with the v2 syscall providing enhanced information.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_execution_info_v2_syscall() -> SyscallResult<Box<starknet::info::v2::ExecutionInfo>>\nfn get_execution_info_syscall() -> SyscallResult<Box<starknet::info::ExecutionInfo>>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Block Hash in Cairo\nDESCRIPTION: Retrieves the hash of a specific block by its number. This only works for blocks within a specific range relative to the current block.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_block_hash_syscall(block_number: u64) -> SyscallResult<felt252>\n```\n\n----------------------------------------\n\nTITLE: Defining StorePacking Trait in Cairo\nDESCRIPTION: Definition of the StorePacking trait which provides methods for packing a value of type T into a more compact representation PackedT and unpacking it back. This trait is used to optimize storage usage in Cairo smart contracts.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/optimisations/store_using_packing.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\ntrait StorePacking<T, PackedT> {\n    fn pack(value: T) -> PackedT;\n    fn unpack(value: PackedT) -> T;\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing a Value in Cairo using HashStateTrait\nDESCRIPTION: Demonstrates the standard procedure for hashing a value in Cairo. It involves initializing a hash state using `HashStateTrait::new()`, updating it with the value(s) to be hashed using `update()`, and finally obtaining the resulting `felt252` hash with `finalize()`. This requires the type being hashed to implement the `Hash` trait.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/hashing.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// Placeholder: Code demonstrating hashing using HashStateTrait\n// 1. Initialize state: let state = HashStateTrait::new();\n// 2. Update state: state.update(value_to_hash);\n//    (Can be called multiple times for multiple values)\n// 3. Finalize: let hash_result: felt252 = state.finalize();\n\n// Note: The actual code is included from an external file:\n// [!include ~/listings/advanced-concepts/hash_trait/src/hash_trait.cairo:hash]\n```\n\n----------------------------------------\n\nTITLE: Calling Other Contracts in Cairo\nDESCRIPTION: Calls a contract at the specified address with given entry point and calldata. Failures will revert the entire transaction and cannot be caught.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nfn call_contract_syscall(\n    address: ContractAddress,\n    entry_point_selector: felt252,\n    calldata: Span<felt252>\n) -> SyscallResult<Span<felt252>>\n```\n\n----------------------------------------\n\nTITLE: Defining ISRC6 Trait in Cairo\nDESCRIPTION: This snippet defines the `ISRC6` trait, which specifies the interface for executing and validating transactions in an account contract. It includes the `__execute__` function for executing a list of calls, the `__validate__` function for validating a list of calls, and the `is_valid_signature` function for verifying a signature. These functions are crucial for the Starknet protocol to interact with the account contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/account_abstraction/account_contract.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n```cairo\n/// @title SRC-6 Standard Account\ntrait ISRC6 {\n    /// @notice Execute a transaction through the account\n    /// @param calls The list of calls to execute\n    /// @return The list of each call's serialized return value\n    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n\n    /// @notice Assert whether the transaction is valid to be executed\n    /// @param calls The list of calls to execute\n    /// @return The string 'VALID' represented as felt when is valid\n    fn __validate__(calls: Array<Call>) -> felt252;\n\n    /// @notice Assert whether a given signature for a given hash is valid\n    /// @param hash The hash of the data\n    /// @param signature The signature to validate\n    /// @return The string 'VALID' represented as felt when the signature is valid\n    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Starknet-js and Required Libraries in JavaScript\nDESCRIPTION: Imports core classes and functions from the Starknet-js library, along with other required dependencies for account management and contract interaction. Ensures all tools necessary for connecting to Starknet, signing transactions, and handling keys are available in the runtime scope. Must be placed at the top of the primary JavaScript file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:imports]\n```\n\n----------------------------------------\n\nTITLE: Creating Account Object from Environment Variables (JavaScript)\nDESCRIPTION: Imports the account private key from environment variables and uses it, along with the account address, to instantiate a Starknet-js Account object. This enables transaction signing and contract invocation from the JavaScript application. All sensitive secrets must be loaded securely before executing account interactions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst accountAddress = // 'PASTE_ACCOUNT_PUBLIC_ADDRESS_HERE';\n// [!include ~/listings/applications/simple_storage_starknetjs/index.js:account]\n```\n\n----------------------------------------\n\nTITLE: ECDSA Verification Contract in Cairo\nDESCRIPTION: This code snippet represents the ECDSA verification contract in Cairo. It is included from the file `~/listings/advanced-concepts/ecdsa_verification/src/ecdsa_verification.cairo` and demonstrates how to verify ECDSA signatures on-chain using a smart contract within the StarkNet environment. The contract facilitates the verification of messages signed off-chain, ensuring authenticity and integrity.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/signature_verification.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/ecdsa_verification/src/ecdsa_verification.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Storage Variables in Starknet Cairo Contracts\nDESCRIPTION: Demonstrates how to define storage variables in a Starknet contract using a struct marked with the `#[storage]` attribute, enabling persistent contract state across executions. This snippet exemplifies the declaration of multiple storage variables with different types and integrates them into contract logic. It depends on the Cairo compiler and the Starknet attributes framework to manage contract storage correctly.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/storage.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/storage/src/contract.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ownable Component in Cairo\nDESCRIPTION: This snippet includes the Cairo code for the `Ownable` component. The component defines the basic functionalities for ownership management within a StarkNet contract.  It allows for setting and asserting the owner, ensuring that only the owner can call specific functions and provides functionality to renounce ownership, effectively making the contract function without an owner.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/ownable.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/ownable.cairo:component]\n```\n\n----------------------------------------\n\nTITLE: Sample Excerpt from ABI JSON File\nDESCRIPTION: Displays the initial content structure of the contract ABI JSON file, essential for Contract object creation. This fragment indicates the format and presence of the sierra_program array, part of the ABI required by Starknet-js. The ABI must be accurate and kept in sync with the deployed contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_12\n\nLANGUAGE: JSON\nCODE:\n```\n{\"sierra_program\":[\"0x1\",\"0x5\",\"0x0\",\"0x2\",\"0x6\",\"0x3\",\"0x98\",\"0x68\",\"0x18\", //...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Minimal Commit-Reveal Contract in Cairo\nDESCRIPTION: A basic implementation of the Commit-Reveal pattern in Cairo for Starknet. The contract stores commitments in a mapping, allows users to commit values through hashes, and provides functionality to reveal the original values.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/commit-reveal.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/commit_reveal/src/commit_reveal.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: `ZkERC20Token` Contract for On-Chain Proof-based Token Minting\nDESCRIPTION: This Cairo contract allows users to mint tokens by submitting valid zk-SNARK proofs demonstrating knowledge of a secret password. The contract internally verifies the proof through a generated verifier contract and ensures each proof is unique per user, preventing replay attacks and enabling secure, proof-based token issuance.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\n[!include ~/listings/advanced-concepts/verify_proofs/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: TimeLock Contract Implementation\nDESCRIPTION: This snippet contains the Cairo code for a TimeLock contract. The contract allows delaying the execution of transactions until a specified time in the future. It includes functionalities for queuing, canceling, and executing transactions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/timelock.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/timelock/src/timelock.cairo]\n```\n\n----------------------------------------\n\nTITLE: Defining a Callee Contract in Cairo for Starknet\nDESCRIPTION: Implementation of a simple Callee contract that stores a value which can be set and retrieved via its interface.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/calling_other_contracts.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// Define the contract interface with the starknet::interface attribute\n#[starknet::interface]\ntrait ICallee<TContractState> {\n    fn set_value(ref self: TContractState, new_value: u128);\n    fn get_value(self: @TContractState) -> u128;\n}\n\n// Implement the contract\n#[starknet::contract]\nmod Callee {\n    #[storage]\n    struct Storage {\n        value: u128,\n    }\n\n    // Implement the interface functions\n    #[external(v0)]\n    impl CalleeImpl of super::ICallee<ContractState> {\n        fn set_value(ref self: ContractState, new_value: u128) {\n            self.value.write(new_value);\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Contract Instance with Starkli\nDESCRIPTION: Deploys a new instance of a previously declared Starknet contract class on the Starknet Sepolia Testnet using Starkli. The command requires the class hash of the contract code that was declared. Upon successful execution, it outputs the address of the newly created contract instance. Requires a deployed Starknet account, keystore access, and the contract's class hash.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nstarkli deploy \\\n  --keystore /path/to/starkli-wallet/keystore.json \\\n  --account /path/to/starkli-wallet/account.json \\\n  --watch 0x05c8c21062a74e3c8f2015311d7431e820a08a6b0a9571422b607429112d2eb4\n```\n\n----------------------------------------\n\nTITLE: Local Variable Example in Cairo\nDESCRIPTION: This example demonstrates the usage of local variables in a Cairo contract. Local variables are temporary and exist only within the scope of the function or code block in which they are defined. They are used for intermediate calculations and temporary data storage within a function, improving code readability.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/variables.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/variables/src/local_variables.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Basic Error Functions in Cairo\nDESCRIPTION: Describes Cairo's core error handling functions, 'assert' and 'panic', used for validation and halting execution respectively. Includes syntax examples for both basic and formatted error messages. Emphasizes that assertions like 'assert_eq!' are for testing only and should not be used in contract code.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/errors.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// Usage of assert for condition validation\nassert(condition, 'error message');\n// Formatted assertion example\nassert!(condition, \"formatted error: {}\", x);\n\n// Usage of panic for immediate halt\npanic_with_felt252('error message');\n// Formatted panic example\npanic!(\"formatted error: value={}\", value);\n```\n\n----------------------------------------\n\nTITLE: Creating Wallet Directory using Bash\nDESCRIPTION: Creates a new directory named `starkli-wallet` in the current working directory. This directory will be used to store the account keystore file and the account configuration file for Starkli.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir ./starkli-wallet\n```\n\n----------------------------------------\n\nTITLE: Illustrating Storage Variable Name Collision (Cairo)\nDESCRIPTION: Shows the Cairo code segment demonstrating the storage collision. Because both the contract and the embedded `Switchable` component define a storage variable named `switchable_value`, and storage layout is determined solely by variable names in this context, these variables occupy the same storage slot, leading to unintended behavior.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/collisions.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/others/switch_collision.cairo:collision]\n```\n\n----------------------------------------\n\nTITLE: Proof Generation using Groth16 with Snarkjs\nDESCRIPTION: Creates a zk-SNARK proof and the associated public signals by utilizing the proving key and witness. The proof JSON and public JSON are outputs, which can be sent to an on-chain verifier for proof validation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsnarkjs groth16 prove circuit_0001.zkey witness.wtns proof.json public.json\n```\n\n----------------------------------------\n\nTITLE: Circuit Definition for Password Hash Verification in Circom\nDESCRIPTION: Defines an arithmetic circuit in Circom that accepts user address, public hash, and private password in plain text. It computes the hash of the password and asserts equality with the public hash for proof of correct knowledge without revealing the password, forming the core of the zero-knowledge proof piece.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n[!include ~/listings/advanced-concepts/verify_proofs/src/circuit/circuit.circom]\n```\n\n----------------------------------------\n\nTITLE: Verifier Contract Generation with Garaga\nDESCRIPTION: Automatically generates a Starknet verifier contract in Cairo using Garaga based on the Groth16 system and the verification key. This contract can be deployed to Starknet to enable on-chain proof verification.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngaraga gen --system groth16 --vk circuit_verification_key.json\n```\n\n----------------------------------------\n\nTITLE: Circuit Compilation Command using circom\nDESCRIPTION: Compiles the Circom circuit into R1CS constraints, WebAssembly, and symbol files, organizing build artifacts in the 'target' directory to prepare for proof generation. This step translates high-level circuit descriptions into a form suitable for proof systems.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir target\ncircom src/circuit/circuit.circom -l node_modules --r1cs --wasm --output target\n```\n\n----------------------------------------\n\nTITLE: Testing the Switchable Component via a Mock Contract in Cairo\nDESCRIPTION: Illustrates how to write tests for a Cairo component by interacting with a contract that incorporates it. This approach uses the 'SwitchableContract' (or a similar mock contract) to test the component's functionality and state changes in a realistic execution environment.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/how_to.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/switchable.cairo:tests]\n```\n\n----------------------------------------\n\nTITLE: Emitting Events in Cairo\nDESCRIPTION: Emits an event with indexed keys and data values that can be captured by off-chain applications or services.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nfn emit_event_syscall(\n    keys: Span<felt252>,\n    data: Span<felt252>\n) -> SyscallResult<()>\n```\n\n----------------------------------------\n\nTITLE: Witness Generation for Proof Construction\nDESCRIPTION: Generates the witness file from the circuit's wasm and the input JSON, capturing all intermediate values and private inputs necessary for proof creation. It uses the compiled circuit and circuit inputs to produce a witness for proof generation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnode circuit_js/generate_witness.js circuit_js/circuit.wasm ../src/circuit/input.json witness.wtns\n```\n\n----------------------------------------\n\nTITLE: Countable Implementation with Switchable Dependency (Cairo)\nDESCRIPTION: This code snippet demonstrates how to modify the `Countable` component implementation to depend on the `ISwitchable` trait.  It relies on the contract implementing the `ISwitchable` trait.  The actual code is not directly shown in the document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components_dependencies/src/countable_dep_switch.cairo:impl]\n```\n\n----------------------------------------\n\nTITLE: Contract Using Countable and Switchable Components (Cairo)\nDESCRIPTION: This code snippet shows a contract that utilizes both the `Countable` and `Switchable` components. By using the `Switchable` component, the contract implicitly implements the `ISwitchable` trait, satisfying the dependency of the `Countable` component. The actual code is not directly shown in the document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components_dependencies/src/contract_countable_switchable.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Countable Component with Internal Switchable Dependency (Cairo)\nDESCRIPTION: This code shows how the Countable component can depend on internal functions of another component (Switchable) through component state access. It makes the `Countable` component depend on the `Switchable` component allowing access to internal functions. The actual code is not directly shown in the document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components_dependencies/src/countable_internal_dep_switch.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Getting Class Hash at Address in Cairo\nDESCRIPTION: Returns the class hash of a contract at a specific address. Only supported from Starknet v0.13.4 onwards.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_class_hash_at_syscall(contract_address: ContractAddress) -> SyscallResult<ClassHash>\n```\n\n----------------------------------------\n\nTITLE: Including Storage Variables with Sierra in Cairo - Cairo\nDESCRIPTION: Demonstrates the use of Cairo's preprocessor directive to include an external Sierra-format storage variable snippet. Assumes the presence of a Sierra file located at '~/listings/getting-started/variables/storage_variables.sierra', which must be accessible for the inclusion to succeed. No parameters are required; the included code is inlined at build time, enhancing modularity and maintainability.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/sierra_ir_storage_contract.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/variables/storage_variables.sierra]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Loop Usage in Cairo\nDESCRIPTION: This snippet exemplifies the usage of the 'loop' construct in the Cairo language, illustrating how a code block executes repeatedly until a halting condition is encountered. It assumes familiarity with basic Cairo syntax and control-flow mechanisms. The snippet is intended to show the structure and execution flow of loops in Cairo, helping developers understand iterative execution patterns.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/loop.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/loop_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the while Loop in Cairo\nDESCRIPTION: This snippet provides an example illustrating the syntax and functionality of a `while` loop in Cairo. It shows how a condition is evaluated before each loop iteration, with the loop body executing only if the condition is true. The code is referenced from an external file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/while.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/while_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Processing SHA-256 Block in Cairo\nDESCRIPTION: Computes the next SHA-256 state for the input block with a given state. Input must be a multiple of 512 bits with no additional padding.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\nfn sha256_process_block_syscall(\n    state: core::sha256::Sha256StateHandle, input: Box<[u32; 16]>,\n) -> SyscallResult<core::sha256::Sha256StateHandle> {}\n```\n\n----------------------------------------\n\nTITLE: Tuple Example in Cairo\nDESCRIPTION: This code snippet demonstrates the creation and usage of tuples in Cairo.  Tuples are used to group together a fixed number of items of potentially different types. The size of a tuple cannot be changed after it is created.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/tuples.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/tuple_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Example of Struct Definition and Usage in Cairo\nDESCRIPTION: This code snippet reference points to an example demonstrating how to define and use a struct in Cairo. Structs are user-defined types that group related data fields, potentially of different types, under a single name, similar to tuples but with named fields.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/struct.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/struct_example.cairo]\n```\n\n----------------------------------------\n\nTITLE: Enabling Structs as Mapping Keys in Cairo\nDESCRIPTION: This Cairo code snippet (referenced via include) demonstrates defining a struct (e.g., 'Pet') and applying the `#[derive(Hash)]` attribute. This allows instances of the struct to be used as keys in a StarkNet `Map` by automatically generating a hash function for the struct.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/struct-mapping-key.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/struct_as_mapping_key/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Reading from Storage in Cairo\nDESCRIPTION: Low-level storage read operation to access contract storage. Direct usage is not recommended in favor of higher-level storage abstractions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\nfn storage_read_syscall(\n    address_domain: u32,\n    address: StorageAddress,\n) -> SyscallResult<felt252>\n```\n\n----------------------------------------\n\nTITLE: Emitting Events in Starknet Cairo Contract\nDESCRIPTION: This code snippet demonstrates how to define and emit events in a Starknet Cairo smart contract. It involves creating event structs, defining an `Event` enum annotated with `#[event]`, and emitting events using the `emit` function. The snippet uses a counter example to illustrate the process.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/events.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/events/src/counter.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Implementation of Storage Packing in Cairo\nDESCRIPTION: A placeholder for an example showing how to implement the StorePacking trait for a Time struct with two u8 values. This demonstrates how to pack multiple smaller values into a single felt252 storage slot.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/optimisations/store_using_packing.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/store_using_packing/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Build Ethereum Project with Forge (Shell)\nDESCRIPTION: This snippet demonstrates how to compile the Ethereum project using Foundry's Forge build tool. It involves running the 'forge build' command to compile Solidity contracts and prepare them for deployment or testing.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge build\n```\n\n----------------------------------------\n\nTITLE: Defining the Switchable Component in Cairo\nDESCRIPTION: Defines a reusable 'Switchable' component in Cairo. This component includes storage for a boolean state ('switchable_value'), a function to toggle the state ('switch'), and an event signaling the state change ('Switch'). It follows a structure similar to a contract but lacks a constructor, using an '_init' function for initialization.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/how_to.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/switchable.cairo:component]\n```\n\n----------------------------------------\n\nTITLE: Format Code with Forge (Shell)\nDESCRIPTION: This command formats Solidity source files according to Forge's predefined style rules, ensuring code consistency across the project.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge fmt\n```\n\n----------------------------------------\n\nTITLE: Solidity Compatible Keccak Hashing - Cairo\nDESCRIPTION: This Cairo code snippet implements Keccak hashing in a way that is compatible with Solidity's keccak256 function. It utilizes `keccak_u256s_be_inputs` function to handle big-endian format needed to match the output of Solidity's keccak256, considering Cairo's little-endian nature, and then reverses the result with `u128_byte_reverse` to get the correct hash. The main purpose is to enable interoperability between Cairo and Solidity in terms of hashing functions, which is useful for verifying and comparing hashes generated by both platforms.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/hash-solidity-compatible.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/hash_solidity_compatible/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Replacing Contract Class in Cairo\nDESCRIPTION: Upgrades the contract's code by replacing its class hash. The new code only affects future calls, while the current transaction continues with the old code.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nfn replace_class_syscall(\n    class_hash: ClassHash\n) -> SyscallResult<()>\n```\n\n----------------------------------------\n\nTITLE: Writing to Storage in Cairo\nDESCRIPTION: Low-level storage write operation to modify contract storage. Direct usage is not recommended in favor of higher-level storage abstractions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\nfn storage_write_syscall(\n    address_domain: u32,\n    address: StorageAddress,\n    value: felt252\n) -> SyscallResult<()>\n```\n\n----------------------------------------\n\nTITLE: Interact with Ethereum using Cast (Shell)\nDESCRIPTION: This command serves as a versatile CLI tool for interacting with EVM smart contracts, for sending transactions, calling functions, or retrieving chain data.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ cast <subcommand>\n```\n\n----------------------------------------\n\nTITLE: Using stdError for Testing Reverts in Solidity\nDESCRIPTION: Example demonstrating how to use the stdError contract with Forge's expectRevert cheatcode to test for arithmetic errors in a contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/README.md#_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function testExpectArithmetic() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n}\n\ncontract ErrorsTest {\n    function arithmeticError(uint256 a) public {\n        uint256 a = a - 100;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using felt252 data type in Cairo\nDESCRIPTION: This snippet demonstrates the usage of `felt252`, a fundamental data type in Cairo. `felt252` can be used to store short string representations with a maximum length of 31 characters.  It's a building block from which all other Cairo data types are derived. There are no specific dependencies for this example.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/felt.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/felt_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Implementing Library Dispatcher in Cairo\nDESCRIPTION: This snippet likely demonstrates how to define and use a library dispatcher in a Cairo contract. The library dispatcher facilitates function calls to contract classes, enabling stateless function execution. This approach is similar to delegate calls in Solidity and contrasts with contract dispatchers that interact with deployed contracts with state. The specific implementation details are included from the referenced file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/library_calls.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/library_calls/src/library_call.cairo:library_dispatcher]\n```\n\n----------------------------------------\n\nTITLE: Using Console Logging in Solidity with forge-std\nDESCRIPTION: Examples showing two different ways to use console logging in Forge tests: console2.sol (recommended for better trace decoding) and console.sol (for Hardhat compatibility).\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/README.md#_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console2.sol\";\n...\nconsole2.log(someValue);\n```\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console.sol\";\n...\nconsole.log(someValue);\n```\n\n----------------------------------------\n\nTITLE: Using stdCheats for Address Spoofing and Balance Manipulation in Solidity\nDESCRIPTION: Example showing how to use the stdCheats library for hoax and startHoax functions, which combine address spoofing (prank) with balance manipulation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/README.md#_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// Inherit the stdCheats\ncontract StdCheatsTest is Test {\n    Bar test;\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testHoax() public {\n        // we call `hoax`, which gives the target address\n        // eth and then calls `prank`\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n\n        // overloaded to allow you to specify how much eth to\n        // initialize the address with\n        hoax(address(1337), 1);\n        test.bar{value: 1}(address(1337));\n    }\n\n    function testStartHoax() public {\n        // we call `startHoax`, which gives the target address\n        // eth and then calls `startPrank`\n        //\n        // it is also overloaded so that you can specify an eth amount\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n}\n\ncontract Bar {\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Forge Standard Library with Forge\nDESCRIPTION: Command to install the Forge Standard Library using Forge package manager.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nforge install foundry-rs/forge-std\n```\n\n----------------------------------------\n\nTITLE: Starknet Foundry Contract State Testing (cairo)\nDESCRIPTION: This snippet shows how to access the internal state of a contract for testing purposes using `Contract::contract_state_for_testing`.  This is valuable for verifying the internal contract state after executing test transactions or functions. This can be used to test contract functions and how they manipulate state.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/testing_how_to/src/test_contract.cairo:tests_with_contract_state]\n```\n\n----------------------------------------\n\nTITLE: Library Call in Cairo\nDESCRIPTION: Makes a delegate call to execute code from another contract class within the current contract's context, similar to Ethereum's delegatecall but limited to a single class.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\nfn library_call_syscall(\n    class_hash: ClassHash,\n    function_selector: felt252,\n    calldata: Span<felt252>\n) -> SyscallResult<Span<felt252>>\n```\n\n----------------------------------------\n\nTITLE: Adding Cairo-test Dev Dependency in Scarb.toml\nDESCRIPTION: This TOML snippet shows how to declare `cairo_test` as a development dependency in your `Scarb.toml` file. Adding this line is necessary to enable the Cairo-test framework within your Scarb project. Ensure the version matches your project's Starknet or Scarb version.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-cairo-test.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[dev-dependencies]\ncairo_test = \"2.10.1\" // Version should be same as your Starknet/Scarb version\n```\n\n----------------------------------------\n\nTITLE: Run cairo program verifier\nDESCRIPTION: This bash script verifies the compilation, tests, and formatting of Cairo programs within the book. It uses `scarb build`, `scarb test`, and `scarb fmt` to ensure the code is valid and consistent.  It should be run from the root of the repository.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/cairo_programs_verifier.sh\n```\n\n----------------------------------------\n\nTITLE: Installing Starknet Toolchain using starkup (Bash)\nDESCRIPTION: Downloads and executes the `starkup` installation script using curl. This command installs the essential Starknet development toolchain, including Scarb, Starknet Foundry, Cairo Language Server, and other compiler/profiling tools.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.starkup.dev | sh\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Vault Contract with 'assert' and 'panic'\nDESCRIPTION: Demonstrates error handling within a vault contract managing deposits and withdrawals. Shows defining custom errors in a separate module, using 'assert' for balance checks, and 'panic' for critical errors, ensuring safety against underflow conditions and other issues.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/errors.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/errors/src/vault_errors.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Install dependencies with pnpm\nDESCRIPTION: This command installs all the required dependencies for the project using pnpm.  This is a prerequisite for building and running the project locally.  It utilizes a package manager (pnpm) to manage project dependencies.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm i\n```\n\n----------------------------------------\n\nTITLE: Compiling a Starknet Contract with Scarb (Bash)\nDESCRIPTION: Executes the `scarb build` command within a Starknet project directory (e.g., `my_starknet_project`). This compiles the Cairo smart contracts located in the `src/` directory (like the default `lib.cairo`) and outputs the compilation artifacts (e.g., contract class JSON) into the `target/dev/` directory.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nscarb build\n```\n\n----------------------------------------\n\nTITLE: On-Chain Proof Verification Call (Calldata Generation)\nDESCRIPTION: Converts proof and public inputs into calldata suitable for calling the Starknet verifier contract, streamlining proof on-chain validation. This command facilitates integrating proof verification into smart contract logic by preparing correct calldata payload.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngaraga calldata --system groth16 --vk circuit_verification_key.json --proof proof.json --public-inputs public.json --format starkli | xargs starkli invoke --account ~/.starkli-wallets/deployer/account.json --keystore ~/.starkli-wallets/deployer/keystore.json --network sepolia --watch 0x00375cf5081763e1f2a7ed5e28d4253c6135243385f432492dda00861ec5e58f mint_with_proof\n```\n\n----------------------------------------\n\nTITLE: Including Error Handling in Cairo Contracts\nDESCRIPTION: Provides a placeholder for a simple error handling example in Cairo, indicated by an include directive. Serves as a basic demonstration or starting point for implementing error handling logic within Cairo contracts.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/errors.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/errors/src/simple_errors.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Check for typos with typos-cli\nDESCRIPTION: This command uses the typos-cli tool to check for typos in the Markdown files. It helps maintain the quality of the written content by identifying and suggesting corrections for potential spelling errors.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo install typos-cli\ntypos pages/\n```\n\n----------------------------------------\n\nTITLE: Markdown include example\nDESCRIPTION: Shows how to include a specific region of code from a cairo file into a markdown file using the include syntax.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n````markdown\n    ```cairo\n    // [!include ~/listings/src/contract.cairo:region_name]\n    ```\n````\n```\n\n----------------------------------------\n\nTITLE: Markdown code-group example\nDESCRIPTION: Shows how to display contract and tests in tabs format in markdown using the code-group syntax.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n````\n    :::code-group\n\n    ```cairo [contract]\n    // [!include ~/listings/src/contract.cairo:contract]\n    ```\n\n    ```cairo [tests]\n    // [!include ~/listings/src/contract.cairo:tests]\n    ```\n\n    :::\n````\n```\n\n----------------------------------------\n\nTITLE: Countable Component Definition (Cairo)\nDESCRIPTION: This code snippet defines the Countable component.  It is referenced but the actual code is not directly included in the document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/countable.cairo:component]\n```\n\n----------------------------------------\n\nTITLE: Include Full Cairo Contract Source\nDESCRIPTION: This line is a source inclusion directive used by the documentation generator. It indicates that the full Cairo source code for the NFT Dutch Auction smart contract, specifically the 'contract' section, should be included from the specified file path. It represents the complete implementation of the auction logic.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/nft_dutch_auction.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/nft_dutch_auction/src/nft_dutch_auction.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Defining Tool Versions in .tool-versions (Markdown)\nDESCRIPTION: Shows an example comment within a `.tool-versions` file, indicating a potential inclusion of global tool versions using a specific syntax (`[!include ~/.tool-versions]`). This file is typically used by version managers like `asdf` to define project-specific tool versions (e.g., Cairo, Scarb).\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n// [!include ~/.tool-versions]\n```\n\n----------------------------------------\n\nTITLE: Formatting and Testing Code Changes in Foundry (Shell)\nDESCRIPTION: These commands are used to ensure that code changes are properly formatted and that all tests pass before submitting a pull request.  `forge fmt --check` checks the formatting of the code, and `forge test -vvv` runs the tests with verbose output. These help maintain code quality and prevent regressions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nforge fmt --check\nforge test -vvv\n```\n\n----------------------------------------\n\nTITLE: Initializing Contract Storage via Constructor in Cairo\nDESCRIPTION: This Cairo code snippet defines a constructor function annotated with #[constructor], which runs once during contract deployment to initialize storage variables. It requires importing the StoragePointerWriteAccess trait to enable writing to specific storage pointers. The constructor accepts three parameters (a, b, c), corresponding to storage variables, and uses their values to set initial contract state. This setup is crucial for establishing deployment-time parameters and access control. Inputs are the parameters; outputs are the updated storage entries. The constructor function cannot be called again after deployment unless additional mutable functions are implemented.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/constructor.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/constructor/src/constructor.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Configuring Starknet Foundry Test Runner with Scarb (toml)\nDESCRIPTION: This code snippet configures Scarb to use snforge as the default test runner.  The `[scripts]` section within the `scarb.toml` file defines a `test` script that executes `snforge test`. This simplifies test execution by allowing users to run tests with the `scarb test` command.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[scripts]\ntest = \"snforge test\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Starknet Contract Interface Traits in Cairo\nDESCRIPTION: This snippet demonstrates how to use Rust-like documentation style to document contract interface traits in Cairo 1 for Starknet. It shows the usage of the #[starknet::interface] attribute on a trait definition, with detailed doc comments describing the high-level purpose of the contract function, arguments, and return values. The snippet is meant to guide users on writing clear and concise interface documentation without revealing implementation details. It requires the Cairo 1 compiler and the Starknet contract framework.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/documentation.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::interface]\ntrait IContract<TContractState> {\n    /// High-level description of the function\n    ///\n    /// # Arguments\n    ///\n    /// * `arg_1` - Description of the argument\n    /// * `arg_n` - ...\n    ///\n    /// # Returns\n    ///\n    /// High-level description of the return value\n    fn do_something(ref self: TContractState, arg_1: T_arg_1) -> T_return;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Minimal Starknet Contract in Cairo\nDESCRIPTION: Shows the simplest possible Cairo contract for Starknet, illustrating the required module structure and the `#[starknet::contract]` attribute usage. This snippet serves as a basic template for creating Starknet contracts. It assumes familiarity with Cairo syntax and the Starknet contract attribute macro.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/storage.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/storage/src/minimal_contract.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Starknet Interface Definition Example\nDESCRIPTION: This snippet demonstrates the definition of a Starknet interface. Interfaces are defined using the `#[starknet::interface]` attribute. This attribute lists all functions that can be called externally, forming part of the contract's public API. Functions defined in the interface can be called as transactions or view calls. The actual code is not shown, as it is assumed to be imported from elsewhere.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/visibility-mutability.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/visibility/src/visibility.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Storage Variable Example in Cairo\nDESCRIPTION: This example showcases storage variables in a Cairo contract. Storage variables persist between contract executions and are stored on the blockchain. Reading storage variables is free, but writing requires a transaction and costs gas. Storage variables must be defined in the contract's Storage struct.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/variables.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/variables/src/storage_variables.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Exporting Verification Key from ZKey\nDESCRIPTION: Extracts the verification key from the finalized zkey file, generating a JSON file that contains the necessary public parameters to verify zk-SNARK proofs on-chain or off-chain. This key is critical for proof validation.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsnarkjs zkey export verificationkey circuit_0001.zkey circuit_verification_key.json\n```\n\n----------------------------------------\n\nTITLE: Global Variable Example in Cairo\nDESCRIPTION: This example demonstrates the use of global variables in a Cairo contract. Global variables provide access to blockchain context and system information, such as the caller address and block information. They are accessed through core library functions and are available anywhere within the contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/variables.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/variables/src/global_variables.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Defining and Storing a Custom Struct in Cairo\nDESCRIPTION: Illustrates the complete contract structure for storing a custom `Person` struct in Starknet storage. It requires deriving the `starknet::Store` trait for the `Person` struct and defining a storage variable (`people`) of type `LegacyMap<felt252, Person>`.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/storing_custom_types.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/storing_custom_types/src/contract.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Cairo Unit Test Module Guard\nDESCRIPTION: This code snippet demonstrates guarding a test module with `#[cfg(test)]`. This ensures the module, and thus the tests within it, are only compiled and included during testing. This is a common practice for unit tests placed directly within source files.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/testing_how_to/src/contract.cairo:tests]\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Stored Struct Members in Cairo\nDESCRIPTION: Demonstrates how to access and modify a specific field (`name`) of a stored `Person` struct. It reads the struct from the `people` storage map using `read()`, modifies the `name` field, and writes the updated struct back using `write()`. Requires the `Person` struct and the `people` storage variable to be defined.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/storing_custom_types.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/storing_custom_types/src/contract.cairo:set_name]\n```\n\n----------------------------------------\n\nTITLE: Exporting Starkli Keystore Path\nDESCRIPTION: Sets the `STARKNET_KEYSTORE` environment variable to the path of the generated keystore file. Exporting this variable allows subsequent Starkli commands to automatically locate and use the keystore without needing to specify the `--keystore` flag explicitly in every command.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport STARKNET_KEYSTORE=\"./starkli-wallet/keystore.json\"\n```\n\n----------------------------------------\n\nTITLE: Merkle Tree Contract Inclusion in Cairo\nDESCRIPTION: This snippet includes the Cairo code for the Merkle Tree contract. It is an adaptation of a Solidity example. The code is included from an external file. No specific parameters, inputs, or outputs are defined in this document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/merkle_tree.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/merkle_tree/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Contract Implementing Countable Component and ISwitchable Trait (Cairo)\nDESCRIPTION: This code snippet showcases a contract that uses the `Countable` component and implements the `ISwitchable` trait. This allows the `Countable` component to function correctly by satisfying its dependency on the `ISwitchable` trait. The actual code is not directly shown in the document.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components_dependencies/src/contract_countable.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Sending Messages to L1 in Cairo\nDESCRIPTION: Sends a message from a Starknet contract to an Ethereum (L1) contract, enabling cross-layer communication.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\nfn send_message_to_l1_syscall(\n    to_address: felt252,\n    payload: Span<felt252>\n) -> SyscallResult<()>\n```\n\n----------------------------------------\n\nTITLE: Integrating the Switchable Component into a Cairo Contract\nDESCRIPTION: Demonstrates how to use the previously defined 'Switchable' component within a Cairo contract. This involves declaring the component within the contract's state and potentially calling its '_init' function from the contract's constructor to initialize the component's state when the contract is deployed.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/how_to.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/switchable.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Generation of Powers of Tau for Trusted Setup (Phase 1)\nDESCRIPTION: Starts the trusted setup ceremony by initializing the 'Powers of Tau' with a specific elliptic curve parameter (bn128) for 2^12 size, creating a ceremony file 'pot12_0000.ptau', and contributing randomness to enhance security. Multiple contributions add trust and reduce the risk of malicious setup.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir target/ptau && cd target/ptau\nsnarkjs powersoftau new bn128 12 pot12_0000.ptau -v\n```\n\nLANGUAGE: bash\nCODE:\n```\nsnarkjs powersoftau contribute pot12_0000.ptau pot12.ptau --name=\"My contribution to part 1\" -v -e=\"some random text for the contribution to part 1\"\n```\n\n----------------------------------------\n\nTITLE: Creating Starkli Keystore File\nDESCRIPTION: Generates a new encrypted keystore file at the specified path (`./starkli-wallet/keystore.json`) using Starkli. This file securely stores the private key associated with your Starknet account. You will be prompted to enter a password to encrypt the private key.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nstarkli signer keystore new ./starkli-wallet/keystore.json\n```\n\n----------------------------------------\n\nTITLE: Defining the Contract Interface with Component Interaction (Cairo)\nDESCRIPTION: Defines the Cairo interface `ICollisionSwitch` for a contract interacting with a `Switchable` component. It imports `ISwitchable` and declares functions for getting/setting a value (`get_value`, `set_value`) and managing the switch state (`switch`, `is_on`), setting up the structure for a potential storage collision scenario.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/collisions.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/others/switch_collision.cairo:interface]\n```\n\n----------------------------------------\n\nTITLE: Installing Starknet-js via npm (Terminal Bash)\nDESCRIPTION: Installs the latest pre-release version of the Starknet-js library, enabling programmatic interaction with Starknet contracts in JavaScript. This command adds the dependency to the project and updates package.json accordingly. Requires an initialized npm project and internet connection.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install starknet@next\n```\n\n----------------------------------------\n\nTITLE: Defining Call Struct in Cairo\nDESCRIPTION: This snippet defines the `Call` struct, which represents a call to a target contract. It takes the target contract address (`to`), function selector (`selector`), and serialized function parameters (`calldata`). This struct is used to represent a transaction and is available under the `starknet::account` module.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/account_abstraction/account_contract.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n```cairo\n/// @title Represents a call to a target contract\n/// @param to The target contract address\n/// @param selector The target function selector\n/// @param calldata The serialized function parameters\nstruct Call {\n    to: ContractAddress,\n    selector: felt252,\n    calldata: Array<felt252>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for ESM Modules (JSON)\nDESCRIPTION: Sets the JavaScript package type to 'module' to enable ECMAScript module syntax and features. Ensures compatibility with modern import/export statements used by Starknet-js. This should be placed at the root of the package.json file. No inputs or outputsmodifies project configuration only.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n\"type\": \"module\"\n}\n```\n\n----------------------------------------\n\nTITLE: Cairo Contract Demonstrating Serde Trait\nDESCRIPTION: This snippet includes the Cairo code for a Starknet contract that demonstrates the use of the `#[derive(Serde)]` attribute on a custom type. This enables the type to be automatically serialized and deserialized, allowing it to be used correctly as parameters or return values in contract entrypoints. The actual contract code is included from an external file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/custom-types-in-entrypoints.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/custom_type_entrypoints/src/contract.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Starknet Project with Scarb (Bash)\nDESCRIPTION: Uses the `scarb new` command to initialize a new Starknet project directory named 'my_starknet_project'. It prompts the user to select a test runner (Starknet Foundry recommended). Requires Scarb to be installed via `starkup` or other means.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nscarb new my_starknet_project\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Account Contract\nDESCRIPTION: Deploys the Starknet account contract specified in the account configuration file (`./starkli-wallet/account.json`) to the Starknet Sepolia Testnet. Before this transaction can be confirmed, the calculated account address must be funded with Sepolia ETH. Requires the account file to be initialized and the keystore accessible.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nstarkli account deploy ./starkli-wallet/account.json\n```\n\n----------------------------------------\n\nTITLE: Declaring Starknet Contract Class with Starkli\nDESCRIPTION: Declares a compiled Starknet contract class on the Starknet Sepolia Testnet using Starkli. The command requires the path to the compiled Sierra contract class JSON file (e.g., `./target/dev/simple_storage_SimpleStorage.contract_class.json`). This makes the contract's code available on-chain under a unique class hash. Requires a deployed Starknet account, keystore access, and the compiled contract JSON file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nstarkli declare \\\n  --keystore /path/to/starkli-wallet/keystore.json \\\n  --account /path/to/starkli-wallet/account.json \\\n  --watch ./target/dev/simple_storage_SimpleStorage.contract_class.json\n```\n\n----------------------------------------\n\nTITLE: Starknet Foundry Direct Storage Access (cairo)\nDESCRIPTION: This snippet demonstrates the use of `load` and `store` functions for direct access to contract storage within a Starknet Foundry test. This enables specific storage scenarios during testing, which is useful for verifying storage-related functionalities.  This will be used to access the testing contract storage directly.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/testing/testing-snforge.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/getting-started/testing_how_to/src/test_contract.cairo:tests_with_direct_storage_access]\n```\n\n----------------------------------------\n\nTITLE: ISwitchable Trait Definition (Cairo)\nDESCRIPTION: This code defines the `ISwitchable` trait, which provides a way to enable or disable a component. It includes functions for turning the switch on or checking its state. It serves as a dependency for the `Countable` component.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/dependencies.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/switchable.cairo:interface]\n```\n\n----------------------------------------\n\nTITLE: Initializing Node.js Project for Starknet-js Interactions (Terminal Bash)\nDESCRIPTION: Initializes a new npm package directory to set up the JavaScript environment for interacting with Starknet via Starknet-js. This step creates a package.json file and prepares the workspace for dependency installation. No input or output parameters are required; this step is foundational for all subsequent JavaScript code execution.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Scarb.toml configuration (Starknet Foundry)\nDESCRIPTION: This is the required Scarb.toml configuration for Starknet Foundry.  It specifies the package name, version, dependencies, and scripts for testing. This configuration is used when creating new Cairo projects. This configuration includes dependencies for Starknet and snforge_std for testing.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"pkg_name\"\nversion.workspace = true\nedition.workspace = true\n\n# Specify that this can be used as a dependency in another scarb project:\n[lib]\n\n[dependencies]\nstarknet.workspace = true\n# Uncomment the following lines if you want to use additional dependencies:\n# OpenZeppelin:\n# openzeppelin_{package_name}.workspace = true\n\n# If you want to use another Starknet By Example's listing, you can add it as a dependency like this:\n# erc20 = { path = \"../../getting-started/erc20\" }\n\n[dev-dependencies]\nassert_macros.workspace = true\nsnforge_std.workspace = true\n\n[scripts]\ntest.workspace = true\n\n[[target.starknet-contract]]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `if let` in Cairo\nDESCRIPTION: This snippet, referenced from an external file, demonstrates the usage of the `if let` statement in Cairo. It showcases how `if let` can be used to conditionally execute a block of code only if a pattern (typically matching a variant of an enum like `Option`) successfully binds a value, serving as a cleaner syntax for handling single cases compared to a full `match` expression.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/if_let.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Updating Cheatcodes in Foundry (Python and Shell)\nDESCRIPTION: This script is used to update the cheatcodes in the `src/Vm.sol` file. It generates the cheatcodes from the `cheatcodes.json` file or from a custom JSON file provided with the `--from` flag. This ensures that the cheatcodes in the Solidity code are up-to-date with the latest definitions.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./scripts/vm.py --from path/to/cheatcodes.json\n```\n\n----------------------------------------\n\nTITLE: Writing to Arbitrary Storage Slots using Poseidon Hash in Cairo for Starknet\nDESCRIPTION: This code demonstrates how to write to and read from arbitrary storage slots in a Starknet contract using the storage syscalls instead of the standard variable access methods. It implements a more efficient storage mechanism using the Poseidon hash function instead of Pedersen.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/write_to_any_slot.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/advanced-concepts/write_to_any_slot/src/contract.cairo]\n```\n\n----------------------------------------\n\nTITLE: Declaring Contract and Component Storage (Cairo)\nDESCRIPTION: Declares the storage structure for a Cairo contract using the `Switchable` component. It includes the component's storage via `#[component]` and explicitly declares its own `switchable_value: bool` storage variable. This creates a naming conflict with the component's storage variable of the same name.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/components/collisions.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// [!include ~/listings/applications/components/src/others/switch_collision.cairo:storage]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Casting with into and try_into (Cairo)\nDESCRIPTION: This snippet represents an example loaded from an external file (`type_casting_example.cairo`). The example demonstrates how Cairo supports type casting using the `into` method for converting from smaller to larger types and the `try_into` method for converting from larger to smaller types, highlighting the potential failure case with `try_into`.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/type_casting.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/type_casting_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Exporting Private Key from Starkli Keystore via CLI (Terminal Bash)\nDESCRIPTION: Extracts the account private key from a Starkli keystore file in raw format, suitable for use in development or testing. Requires that Starkli CLI is installed and a valid keystore path is provided. Outputs the private key to stdout, which should be securely handled and never shared.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nstarkli signer keystore inspect-private /path/to/starkli-wallet/keystore.json --raw\n```\n\n----------------------------------------\n\nTITLE: Including Cairo Mapping Example in Documentation\nDESCRIPTION: This snippet links to an external Cairo code example demonstrating the Map type, which shows how to implement and use key-value collections within Cairo programs. It depends on an external file located at '~/listings/cairo_cheatsheet/src/mapping_example.cairo' for concrete implementation details.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/mapping.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/mapping_example.cairo]\n```\n\n----------------------------------------\n\nTITLE: Defining Array Operations with ArrayTrait in Cairo\nDESCRIPTION: This Cairo snippet defines the ArrayTrait trait, which outlines a suite of standard array operations for managing collections of elements in Cairo, including initialization, appending elements, removing elements from the front, element access by index, checking the length, and getting a span view. Required dependency: corelib containing Array, Option, Box, Span, and bool types. The trait is generic over element type T, facilitating extensible array-based data structures.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/arrays.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\ntrait ArrayTrait<T> {\n    fn new() -> Array<T>;\n    fn append(ref self: Array<T>, value: T);\n    fn pop_front(ref self: Array<T>) -> Option<T> nopanic;\n    fn pop_front_consume(self: Array<T>) -> Option<(Array<T>, T)> nopanic;\n    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>>;\n    fn at(self: @Array<T>, index: usize) -> @T;\n    fn len(self: @Array<T>) -> usize;\n    fn is_empty(self: @Array<T>) -> bool;\n    fn span(self: @Array<T>) -> Span<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Starkli Account File (OpenZeppelin)\nDESCRIPTION: Initializes a new account configuration file (`./starkli-wallet/account.json`) using Starkli, based on the standard OpenZeppelin account contract class pre-deployed on Starknet. This command calculates and outputs the prospective account address and provides the necessary command to deploy this account on-chain.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/interacting/how_to_deploy.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nstarkli account oz init ./starkli-wallet/account.json\n```\n\n----------------------------------------\n\nTITLE: Run Tests with Forge (Shell)\nDESCRIPTION: This command executes the test suite for the smart contracts using Forge's testing framework. It assumes that tests are written in Solidity and are part of the project structure.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge test\n```\n\n----------------------------------------\n\nTITLE: Start Local Ethereum Node with Anvil (Shell)\nDESCRIPTION: This command launches a local Ethereum node for development and testing purposes, providing a sandbox environment similar to Ganache or Hardhat Network.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ anvil\n```\n\n----------------------------------------\n\nTITLE: Finalizing Powers of Tau and Generating ZKey for Circuit\nDESCRIPTION: Prepares the final ceremony parameters by processing the ptau file and generates the zkey proving key for the circuit using the finalized parameters. Contributing further to the phase enhances parameter security.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/advanced-concepts/verify_proofs.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsnarkjs powersoftau prepare phase2 pot12.ptau pot12_final.ptau -v\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd ..\nsnarkjs groth16 setup circuit.r1cs ptau/pot12_final.ptau circuit_0000.zkey\n```\n\nLANGUAGE: bash\nCODE:\n```\nsnarkjs zkey contribute circuit_0000.zkey circuit_0001.zkey --name=\"My contribution to part 2\" -v -e=\"some random text for the contribution to part 2\"\n```\n\n----------------------------------------\n\nTITLE: Deploy Smart Contract Script with Forge (Shell)\nDESCRIPTION: This command deploys a Solidity script to a specified RPC URL using a private key. It runs the designated script, facilitating automation of contract deployment.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge script script/Counter.s.sol:CounterScript --rpc-url <your_rpc_url> --private-key <your_private_key>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Error Codes in Cairo\nDESCRIPTION: Shows how to organize error messages into a dedicated module for better clarity and maintainability. Uses an include directive pointing to a module where custom error codes are defined, promoting consistent error handling across contracts.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/basics/errors.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/getting-started/errors/src/custom_errors.cairo:contract]\n```\n\n----------------------------------------\n\nTITLE: Using stdStorage to Find and Manipulate Storage Slots in Solidity\nDESCRIPTION: Example showing how to use stdStorage to find and write to storage slots in a contract, including simple variables, mappings, and complex structs without knowing the storage layout.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/README.md#_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    using stdStorage for StdStorage;\n\n    Storage test;\n\n    function setUp() public {\n        test = new Storage();\n    }\n\n    function testFindExists() public {\n        // Lets say we want to find the slot for the public\n        // variable `exists`. We just pass in the function selector\n        // to the `find` command\n        uint256 slot = stdstore.target(address(test)).sig(\"exists()\").find();\n        assertEq(slot, 0);\n    }\n\n    function testWriteExists() public {\n        // Lets say we want to write to the slot for the public\n        // variable `exists`. We just pass in the function selector\n        // to the `checked_write` command\n        stdstore.target(address(test)).sig(\"exists()\").checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    // It supports arbitrary storage layouts, like assembly based storage locations\n    function testFindHidden() public {\n        // `hidden` is a random hash of a bytes, iteration through slots would\n        // not find it. Our mechanism does\n        // Also, you can use the selector instead of a string\n        uint256 slot = stdstore.target(address(test)).sig(test.hidden.selector).find();\n        assertEq(slot, uint256(keccak256(\"my.random.var\")));\n    }\n\n    // If targeting a mapping, you have to pass in the keys necessary to perform the find\n    // i.e.:\n    function testFindMapping() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.map_addr.selector)\n            .with_key(address(this))\n            .find();\n        // in the `Storage` constructor, we wrote that this address' value was 1 in the map\n        // so when we load the slot, we expect it to be 1\n        assertEq(uint(vm.load(address(test), bytes32(slot))), 1);\n    }\n\n    // If the target is a struct, you can specify the field depth:\n    function testFindStruct() public {\n        // NOTE: see the depth parameter - 0 means 0th field, 1 means 1st field, etc.\n        uint256 slot_for_a_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(0)\n            .find();\n\n        uint256 slot_for_b_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(1)\n            .find();\n\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_a_field))), 1);\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_b_field))), 2);\n    }\n}\n\n// A complex storage contract\ncontract Storage {\n    struct UnpackedStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    constructor() {\n        map_addr[msg.sender] = 1;\n    }\n\n    uint256 public exists = 1;\n    mapping(address => uint256) public map_addr;\n    // mapping(address => Packed) public map_packed;\n    mapping(address => UnpackedStruct) public map_struct;\n    mapping(address => mapping(address => uint256)) public deep_map;\n    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;\n    UnpackedStruct public basicStruct = UnpackedStruct({\n        a: 1,\n        b: 2\n    });\n\n    function hidden() public view returns (bytes32 t) {\n        // an extremely hidden storage slot\n        bytes32 slot = keccak256(\"my.random.var\");\n        assembly {\n            t := sload(slot)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Keccak Hash in Cairo\nDESCRIPTION: Computes the Keccak hash of input data as a little-endian 256-bit number. Input must be properly padded following the Keccak padding rules.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/syscalls.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\nfn keccak_syscall(input: Span<u64>) -> SyscallResult<u256>\n```\n\n----------------------------------------\n\nTITLE: Building Foundry with Specific Solc Versions (Shell)\nDESCRIPTION: These commands build the Foundry project using specific versions of the Solidity compiler (solc). This ensures compatibility across different compiler versions. The `--skip test` flag skips the tests during the build process, and `--use solc:<version>` specifies the solc version to use.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/lib/forge-std/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nforge build --skip test --use solc:0.6.2\nforge build --skip test --use solc:0.6.12\nforge build --skip test --use solc:0.7.0\nforge build --skip test --use solc:0.7.6\nforge build --skip test --use solc:0.8.0\n```\n\n----------------------------------------\n\nTITLE: Sample contract.cairo file\nDESCRIPTION: This is a sample `contract.cairo` file including contract code, and test module. This shows how to structure your contract code and add tests using #[cfg(test)].\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\n// [!region contract]\n// Write your contract here\n// [!endregion contract]\n\n// [!region test]\n#[cfg(test)]\nmod tests {\n  // Write your tests for the contract here\n}\n// [!endregion test]\n```\n\n----------------------------------------\n\nTITLE: Build the application\nDESCRIPTION: This command builds the application, ensuring everything works as expected after making changes to Markdown files.  This step compiles and bundles the project.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Start development server\nDESCRIPTION: This command starts the development server for the Next.js project. It allows you to preview the changes you make to the Markdown files.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Sample .env File for Storing Private Keys (Bash)\nDESCRIPTION: Provides a template .env file for local development that stores the Starknet account private key as an environment variable. This file should be kept secret, added to .gitignore, and never used in production environments. Key names and format should match those expected by the account initialization code.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/simple_storage_starknetjs.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n// [!include ~/listings/applications/simple_storage_starknetjs/.env.example]\n```\n\n----------------------------------------\n\nTITLE: Install Scarb with asdf\nDESCRIPTION: This command installs Scarb using asdf.  Scarb is a build system for Cairo projects.  asdf is a version manager.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nasdf install\n```\n\n----------------------------------------\n\nTITLE: Sample lib.cairo file\nDESCRIPTION: This `lib.cairo` file demonstrates the basic structure for a Cairo contract, importing necessary modules and defining the contract code within the `contract` module. It sets up the structure for the contract.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nmod contract;\n// any other modules you want\n```\n\n----------------------------------------\n\nTITLE: Including Cairo `while let` Loop Example from External File\nDESCRIPTION: This snippet demonstrates how to include an external Cairo code example illustrating the use of the `while let` loop. It serves as a reference point for understanding pattern matching within loops in Cairo. Dependencies include the external file located at `~/listings/cairo_cheatsheet/src/while_let_example.cairo`, which contains the implementation details. As it is an include statement, it does not execute code itself but ensures code reuse and modularity.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/cairo_cheatsheet/while_let.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/cairo_cheatsheet/src/while_let_example.cairo:sheet]\n```\n\n----------------------------------------\n\nTITLE: Scarb.toml configuration (cairo-test)\nDESCRIPTION: This is the required `Scarb.toml` configuration for `cairo-test`. It specifies the package information, dependencies, and the test script configuration for a Cairo project using cairo-test framework. This configuration includes dependencies for Starknet and cairo_test for testing.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"pkg_name\"\nversion.workspace = true\nedition.workspace = true\n\n# Specify that this can be used as a dependency in another scarb project:\n[lib]\n\n[dependencies]\nstarknet.workspace = true\n# Uncomment the following lines if you want to use additional dependencies:\n# OpenZeppelin:\n# openzeppelin_{package_name}.workspace = true\n\n# If you want to use another Starknet By Example's listing, you can add it as a dependency like this:\n# erc20 = { path = \"../../getting-started/erc20\" }\n\n[dev-dependencies]\ncairo_test.workspace = true\n\n[scripts]\ntest.workspace = true\n\n[[target.starknet-contract]]\n```\n\n----------------------------------------\n\nTITLE: Installing Tools Specified in .tool-versions (Bash)\nDESCRIPTION: Uses the `asdf install` command to read the `.tool-versions` file in the current directory and install the specified versions of the tools listed within it. This ensures that all developers use the same tool versions for the project. Requires `asdf` and relevant plugins to be installed.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nasdf install\n```\n\n----------------------------------------\n\nTITLE: Checking Scarb Version (Bash)\nDESCRIPTION: Navigates into the newly created project directory (`my_starknet_project`) and then executes `scarb --version` to display the currently installed Scarb version. This helps verify the installation and check compatibility.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/getting-started/env_setup.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd my_starknet_project\nscarb --version\n```\n\n----------------------------------------\n\nTITLE: Create Gas Usage Snapshots (Shell)\nDESCRIPTION: This command captures gas consumption data for transactions or tests, allowing developers to analyze and optimize gas efficiency over time.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge snapshot\n```\n\n----------------------------------------\n\nTITLE: Defining the Pledgeable Component in Cairo\nDESCRIPTION: Defines a Cairo component named 'Pledgeable' designed to manage pledge storage for the crowdfunding campaign. It uses storage variables to track pledgers and their corresponding amounts, structured to allow iteration over all pledges, which is crucial for functionalities like refunding all users during a contract upgrade.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/applications/crowdfunding.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n// [!include ~/listings/applications/crowdfunding/src/campaign/pledgeable.cairo:component]\n```\n\n----------------------------------------\n\nTITLE: Listing Project Version Information (Markdown)\nDESCRIPTION: Displays the specific versions of key dependencies, including Cairo, the edition, and Sierra, that are used by this project or book. The commented lines indicate that this information is typically sourced from a .tool-versions file.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/pages/index.mdx#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\ncairo 2.10.1\nedition 2024_07\nsierra 1.7.0\n// .tool-versions:\n// [!include ~/.tool-versions]\n```\n\n----------------------------------------\n\nTITLE: Display Help for Foundry Tools (Shell)\nDESCRIPTION: These commands provide detailed help information for Forge, Anvil, and Cast commands, assisting users in understanding available options and usage patterns.\nSOURCE: https://github.com/nethermindeth/starknetbyexample/blob/dev/listings/applications/l1_l2_token_bridge/solidity/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ forge --help\n$ anvil --help\n$ cast --help\n```"
  }
]