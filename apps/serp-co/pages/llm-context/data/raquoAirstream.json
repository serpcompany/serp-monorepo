[
  {
    "owner": "raquo",
    "repo": "airstream",
    "content": "TITLE: Making HTTP Requests with FetchStream in Scala.js\nDESCRIPTION: Demonstrates how to use FetchStream to make HTTP requests in Scala.js applications, including custom request configurations and response handling.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nFetchStream.get(\n  url,\n  _.redirect(_.follow),\n  _.referrerPolicy(_.`no-referrer`),\n  _.abortStream(...)\n) // EventStream[String] of response body\n```\n\nLANGUAGE: scala\nCODE:\n```\nFetchStream.raw.get(url) // EventStream[dom.Response]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval Fetch = FetchStream.withCodec(encodeRequest, decodeResponse)\n\nFetch.post(url, _.body(myRequest)) // EventStream[MyResponse]\n```\n\n----------------------------------------\n\nTITLE: Making Ajax GET Requests with Airstream\nDESCRIPTION: Demonstrates how to make an Ajax GET request using Airstream's AjaxStream and transform the response. The code creates an EventStream that emits the XMLHttpRequest object, then maps it to extract the response text.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nAjaxStream\n  .get(\"/api/kittens\") // EventStream[dom.XMLHttpRequest]\n  .map(req => req.responseText) // EventStream[String]\n```\n\n----------------------------------------\n\nTITLE: Triggering Network Request with flatMapSwitch in Scala\nDESCRIPTION: Demonstrates a valid use case for flatMapSwitch to trigger a network request when a signal updates and subscribe to the corresponding network responses.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_51\n\nLANGUAGE: scala\nCODE:\n```\nval userS: Signal[User] = ???\nval responseS: EventStream[Response] = userS.flatMapSwitch { user =>\n  FetchStream.get(s\"/user/${user.id}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic List Rendering with Laminar Elements\nDESCRIPTION: Shows how to efficiently render a dynamic list of Foo objects into HTML elements while maintaining element identity and state across updates.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(id: String, version: Int)\n   \ndef renderFoo(fooId: String, initialFoo: Foo, fooSignal: Signal[Foo]): HtmlElement = {\n  div(\n    \"foo id: \" + fooId,\n    \"first seen foo with this id: \" + initialFoo.toString,\n    \"last seen foo with this id: \",\n    child <-- fooSignal.map(_.toString)\n  )\n}\n \nval inputSignal: Signal[List[Foo]] = ???\nval outputSignal: Signal[List[HtmlElement]] = inputSignal.split(\n  key = _.id\n)(\n  project = renderFoo\n)\n```\n\n----------------------------------------\n\nTITLE: Using flatMapWithStatus for Async Operations in Scala\nDESCRIPTION: Demonstrates how to use flatMapWithStatus to handle asynchronous network requests and show loading indicators.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nval requestS: EventStream[Request] = ???\n\ntype Response = String // but it could be something else\n\nval responseS: EventStream[Status[Request, Response]] =\n  requestS.flatMapWithStatus { request =>\n    // returns EventStream[Response]\n    FetchStream.get(request.url, request.options)\n  }\n\nval isLoadingS: EventStream[Boolean] = responseS.map(_.isPending)\n\nval textS: EventStream[String] =\n  responseS.foldStatus(\n    resolved = _.toString,\n    pending = _ => \"Loading...\" \n  )\n\n// Example usage from Laminar:\ndiv(\n  child(img(src(\"spinner.gif\"))) <-- isLoadingS,\n  text <-- textS\n)\n\n// Or, perhaps more realistically:\ndiv(\n  child <-- responseS.splitStatus(\n    (resolved, _) => div(\"Response: \" + resolved.output.toString),\n    (pending, _) => div(img(src(\"spinner.gif\")), \"Loading ...\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Chaining Reactive Streams in Scala using Airstream\nDESCRIPTION: This snippet demonstrates how to create a chain of dependent EventStreams in Airstream. It shows the definition of multiple streams that transform data through a series of mapping operations, and illustrates how adding an observer to one stream affects the activation state of the entire chain.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval foo: EventStream[Foo] = ???\nval bar: EventStream[Bar] = foo.map(fooToBar)\nval baz: EventStream[Baz] = bar.map(barToBaz)\nval qux: EventStream[Qux] = baz.map(bazToQux)\nval rap: EventStream[Rap] = qux.map(quxToRap)\n\nbaz.addObserver(bazObserver)\n```\n\n----------------------------------------\n\nTITLE: Creating a State Signal from EventStream in Scala\nDESCRIPTION: Shows how to create a state signal from an event stream using scanLeft. The state signal compiles state based on events, allowing child components to re-sync with it when they are stopped and restarted.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_57\n\nLANGUAGE: scala\nCODE:\n```\nval parentClickEvents: EventStream[dom.MouseEvent] = ???\nval state: Signal[State] = parentClickEvents.scanLeft((initialState, ev) => newState)\n```\n\n----------------------------------------\n\nTITLE: Using flatMapMerge on EventStream in Scala\nDESCRIPTION: Demonstrates the flatMapMerge operator, which accumulates and merges all inner streams created from the parent stream's events, instead of switching between them.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\nval parentBus: EventBus[A] = ???\n\nval parentStream: EventStream[A] = parentBus.events\n\ndef makeInnerStream(ev: A): EventStream[B] = ???\n\nval flatStream: EventStream[B] =\n  parentStream.flatMapMerge(ev => makeInnerStream(ev))\n  \nparentBus.emit(a1)\nparentBus.emit(a2)\n\n// Now flatStream re-emits the events from both\n// makeInnerStream(a1) and makeInnerStream(a2),\n// assuming it has any observers, of course.\n```\n\n----------------------------------------\n\nTITLE: Creating and Transforming Signals in Scala\nDESCRIPTION: This example demonstrates creating a Signal from an EventStream with an initial value, and then transforming it with map. It illustrates how Signal's initial value and transformations are evaluated lazily.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval fooStream: EventStream[Foo] = ???\nval fooSignal: Signal[Foo] = fooStream.startWith(myFoo)\nval barSignal: Signal[Bar] = fooSignal.map(fooToBar)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Recovery in Scala Signals\nDESCRIPTION: This example demonstrates how to use the 'recover' method to handle errors in a signal chain. It shows different strategies for handling specific exceptions, including emitting a new value, skipping the event, or throwing a new exception.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_64\n\nLANGUAGE: scala\nCODE:\n```\nval signal0: Signal[A] = ???\nval signal1 = signal0.map(whatever)\nval signal2 = signal1.recover {\n  case MyException(foo) if foo.isGood => Some(foo) // emit foo\n  case MyException(foo) if !foo.isGood => None // skip this, emit nothing\n  case o: MyOtherException => throw new Exception(\"lolwat\") // emit new error\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting Vars with Bidirectional Updates in Airstream\nDESCRIPTION: Demonstrates splitting a Var[List[A]] into multiple individual Var[A] instances with bidirectional updates. Changes to child Vars update the parent Var and vice versa, allowing synchronized state management across components.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\n// Laminar example\ncase class User(id: String, name: String)\nval usersVar = Var[List[User]](...)\n\ndiv(\n  usersVar.split(_.id)((userId, initial, userVar) => {\n    div(\n      s\"User ${userId}: \",\n      input(\n        value <-- userVar.signal.map(_.name),\n        onInput.mapToValue --> { newName =>\n          userVar.update(_.copy(name = newName))\n        }\n      )\n    )\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Splitting Try Values in Airstream\nDESCRIPTION: Demonstrates using the splitTry operator to handle success and failure cases separately in a Signal[Try[User]]. This creates distinct, typed callbacks for each branch that receive both the initial value and a signal of subsequent values.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nval userTrySignal: Signal[Try[User]] = ???\ndiv(\n  child <-- userTrySignal.splitTry(\n    success = (initialUser: User, userSignal: Signal[User]) =>\n       div(\"User name: \", text <-- userSignal.map(_.name)),\n    failure = (initialErr: Throwable, errSignal: Signal[Throwable]) =>\n       div(\"Something is wrong: \", text <-- errSignal.map(_.getMessage))\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Batch Updates for Multiple Variables in Scala\nDESCRIPTION: Shows how to perform batch updates on multiple Vars in a single transaction to avoid glitches downstream, using the Var.set method.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval value = Var(1)\nval isEven = Var(false)\n\nval sumSignal = x.signal.combineWith(y.signal)\n\n// batch updates!\nVar.set(x -> 2, y -> true)\n```\n\n----------------------------------------\n\nTITLE: Merging EventStreams with Proper Glitch Prevention in Scala\nDESCRIPTION: Demonstrates how to merge streams of values using EventStream.merge, showing how the merge stream emits values from multiple sources (tens and hundreds) when the source stream emits a value.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nval numbers: EventStream[Int] = ???\nval tens: EventStream[Int] = numbers.map(_ * 10)\nval hundreds: EventStream[Int] = tens.map(_ * 10)\nval multiples: EventStream[Int] = EventStream.merge(hundreds, tens)\nmultiples.addObserver(multiplesObserver)(owner)\n```\n\n----------------------------------------\n\nTITLE: Implementing flatMapSwitch on EventStream in Scala\nDESCRIPTION: Illustrates the usage of flatMapSwitch operator on an EventStream, explaining how it switches between inner streams as new events are emitted by the parent stream.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_52\n\nLANGUAGE: scala\nCODE:\n```\nval parentStream: EventStream[A] = ???\n\ndef makeInnerStream(ev: A): EventStream[B] = ???\n\nval flatStream: EventStream[B] =\n  parentStream.flatMapSwitch(ev => makeInnerStream(ev))\n```\n\n----------------------------------------\n\nTITLE: Creating LocalStorage-backed Vars with Custom JSON Codec\nDESCRIPTION: Shows how to create a LocalStorage-backed variable for a custom type using JSON encoding and decoding. This approach allows storing complex data structures by providing custom conversion functions between the type and its string representation.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval fooVar: WebStorageVar[Foo] = WebStorageVar\n  .localStorage(key = \"foo\", syncOwner = None)\n  .withCodec(\n    encode = Foo.toJson,\n    decode = Foo.fromJson,\n    default = Success(Foo(1, \"name\"))\n  )\n```\n\n----------------------------------------\n\nTITLE: Transforming Signal[List[Foo]] to Signal[Map[String, Signal[Foo]]]\nDESCRIPTION: Demonstrates how to split a signal of Foo list into individual signals per Foo ID. This allows tracking the latest version of each Foo independently.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(id: String, version: Int)\nval inputSignal: Signal[List[Foo]] = ???\n \nval outputSignal: Signal[List[(String, Signal[Foo])]] = inputSignal.split(\n  key = _.id\n)(\n  project = (key, initialFoo, thisFooSignal) => (key, thisFooSignal)\n)\n \nval resultSignal: Signal[Map[String, Signal[Foo]]] = outputSignal.map(list => Map(list: _*))\n```\n\n----------------------------------------\n\nTITLE: Tracking Ajax Progress Events in Airstream\nDESCRIPTION: Shows how to listen for progress events during an Ajax request. This creates an observer and stream for progress events, then uses them with AjaxEventStream to track bytes loaded during request processing.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval (progressObserver, progressS) = EventStream.withObserver[(dom.XMLHttpRequest, dom.ProgressEvent)]\n\nval requestS = AjaxEventStream.get(\n  url = \"/api/kittens\",\n  progressObserver = progressObserver\n)\n\nval bytesLoadedS = progressS.mapN((xhr, ev) => ev.loaded)\n```\n\n----------------------------------------\n\nTITLE: Creating DOM Event Stream in Scala\nDESCRIPTION: Creates an EventStream that listens to DOM click events on a specified element. The stream automatically manages event listener lifecycle.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval element: dom.Element = ???\nDomEventStream[dom.MouseEvent](element, \"click\") // EventStream[dom.MouseEvent]\n```\n\n----------------------------------------\n\nTITLE: Using Var.update for Reactive State Management in Scala\nDESCRIPTION: Demonstrates the proper way to update a Var's value using the update method, which evaluates modifications when the transaction runs, ensuring access to the freshest state.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nval logVar = Var(List[Event]())\nstream.foreach { ev =>\n  logVar.update(_ :+ ev)\n  logVar.update(_ :+ ev)\n  // After both transactions execute, logVar will have two `ev`-s in it\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Derived Variables in Scala\nDESCRIPTION: Demonstrates how to create and use derived variables (LazyDerivedVar) from a parent Var using the zoomLazy method. The example shows two-way linking between the parent and derived vars.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ncase class FormData(num: Int, str: String)\nval formDataVar = Var(FormData(0, \"a\"))\nval strVar = formDataVar.zoomLazy(_.str)((formData, newStr) => formData.copy(str = newStr))\n\n// strVar.now() == \"a\"\n\nformDataVar.update(_.copy(str = \"b\"))\n// formDataVar.now() == FormData(0, \"b\")\n// strVar.now() == \"b\"\n\nstrVar.set(\"c\")\n// formDataVar.now() == FormData(0, \"c\")\n// strVar.now() == \"c\"\n```\n\n----------------------------------------\n\nTITLE: Collecting Errors as Values in Scala Streams\nDESCRIPTION: This snippet shows how to use 'recoverToTry' to transform an Observable[A] into an Observable[Try[A]], allowing errors to be collected as regular values in the stream instead of being propagated through the error channel.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_65\n\nLANGUAGE: scala\nCODE:\n```\nstream.recoverToTry.collect { case Failure(err) => err } // EventStream[Throwable]\n```\n\n----------------------------------------\n\nTITLE: Handling Cases with handleCase in Scala\nDESCRIPTION: Demonstrates the use of handleCase, which is a more flexible alternative to handleValue and handleType. It allows for arbitrary pattern matching in observable splitting.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\n// handleValue(LoginPage)(div(...))\nhandleCase { case LoginPage => () } { (_, _) => div(...) }\n\n// handleType[UserPage] {\n//   (initialUserPage, userPageSignal) => div(...)\n// }\nhandleCase { case up: UserPage => up } {\n  (initialUserPage, userPageSignal) => div(...)\n}\n\nhandleCase { case UserPage(userId) => userId } {\n  (initialUserId, userIdSignal) => div(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating LocalStorage-backed Vars with Primitive Types\nDESCRIPTION: Demonstrates creating persistent variables backed by LocalStorage for various primitive data types. The example shows creating text, integer, and boolean variables with default values that persist across page loads.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval themeVar: WebStorageVar[String] = WebStorageVar\n  .localStorage(key = \"themeName\", syncOwner = None)\n  .text(default = \"light\")\n\nval tabIxVar: WebStorageVar[Int] = WebStorageVar\n  .localStorage(key = \"selectedTabIndex\", syncOwner = None)\n  .int(default = 0)\n\nval showSidebarVar: WebStorageVar[Boolean] = WebStorageVar\n  .localStorage(key = \"showSidebar\", syncOwner = None)\n  .bool(default = true)\n```\n\n----------------------------------------\n\nTITLE: Using delayWithStatus for Timed Message Display in Scala\nDESCRIPTION: Shows how to use delayWithStatus to automatically show a message for a few seconds before clearing it.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\nval receivedMessageS: EventStream[String] = ???\n\nval messageStatusS: EventStream[Status[String, String]] =\n  receivedMessageS.delayWithStatus(ms = 3000)\n\nval showMessageS: EventStream[String] =\n  messageStatusS.foldStatus(\n    resolved = _ => \"\",\n    pending = _.input // contains the event fired by `messageReceivedS`, i.e. the message\n  )\n  \ndiv(text <-- showMessageS) // in Laminar\n```\n\n----------------------------------------\n\nTITLE: Dynamic Subscription Example in Scala\nDESCRIPTION: Demonstrates creation and usage of DynamicSubscription with DynamicOwner, showing how to activate and deactivate subscriptions dynamically. Includes stream observation and owner lifecycle management.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval stream: EventStream[Int] = ???\nval observer: Observer[Int] = ???\n \nval dynOwner = new DynamicOwner\n \nval dynSub = DynamicSubscription.unsafe(\n  dynOwner,\n  activate = (owner: Owner) => stream.addObserver(observer)(owner)\n)\n \n// Run dynSub's activate method and save the resulting non-dynamic Subscription\ndynOwner.activate()\n \n// Kill the regular Subscription that we saved \ndynOwner.deactivate()\n \n// Run dynSub's activate method again, obtaining a new Subscription\ndynOwner.activate()\n \n// Kill the new Subscription that we saved \ndynOwner.deactivate()\n```\n\n----------------------------------------\n\nTITLE: Debugging Event Streams in Scala with Airstream\nDESCRIPTION: Demonstrates various debugging operators available for Airstream observables including logging events, spying on starts, and breaking on errors. Shows how to chain multiple debug operations and configure logging options.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_58\n\nLANGUAGE: scala\nCODE:\n```\nval stream: EventStream[Int] = ???\nval useJsLogger: Boolean = false\n\nval debugStream = stream\n  .debugWithName(\"MyStream\") // optional: use this prefix when logging below\n  .debugLogEvents(when = _ < 0, useJsLogger) // optional: only log negative numbers\n  .debugSpyStarts(topoRank => ???)\n  .debugBreakErrors()\n\n// Before:\nstream.addObserver(obs)\n\n// After: when debugging, replace with:\ndebugStream.addObserver(obs)\n```\n\n----------------------------------------\n\nTITLE: FRP Diamond Pattern Implementation\nDESCRIPTION: Illustrates the diamond pattern in FRP, demonstrating how event streams are combined while avoiding glitches through proper event propagation.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nval numbers: EventStream[Int] = ???\nval isPositive: EventStream[Boolean] = numbers.map(_ > 0)\nval doubledNumbers: EventStream[Int] = numbers.map(_ * 2)\nval combinedStream: EventStream[(Int, Boolean)] = doubledNumbers.combineWith(isPositive)\ncombinedStream.addObserver(combinedStreamObserver)(owner)\n```\n\n----------------------------------------\n\nTITLE: Using splitMatchSeq for Collections in Scala\nDESCRIPTION: Illustrates the use of splitMatchSeq to handle collections of different types. This example shows how to render different HTML elements for Stock and FxRate items in a collection.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\ntrait Item { val id: String }\ncase class Stock(ticker: String, currency: String, value: Double) {\n  override val id: String = ticker\n}\ncase class FxRate(currency1: String, currency2: String, rate: Double) {\n  override val id: String = currency1 + \"-\" + currency2 \n}\n\nval itemsSignal: Signal[Seq[Item]] = ???\nval elementsSignal: Signal[Seq[HtmlElement]] =\n  modelsSignal\n    .splitMatchSeq(_.id)\n    .handleType[Stock] { (initialStock, stockSignal) =>\n      div(\n        initialStock.id + \": \",\n        text <-- stockSignal.map(_.value),\n        \" \" + initialStock.currency\n      )\n    }\n    .handleType[FxRate] { (initialRate, rateSignal) =>\n      div(initialRate.id, \": \", text <-- rateSignal.map(_.rate))\n    }\n    .toSignal\n\nchildren <-- elementsSignal // in Laminar\n```\n\n----------------------------------------\n\nTITLE: Converting FS2 Stream to Airstream EventStream via Publisher\nDESCRIPTION: Example showing how to transform an FS2 Stream into an Airstream EventStream using Flow.Publisher as an intermediary. This demonstrates interoperability between different streaming APIs.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.effect.unsafe.implicits._ // imports implicit IORuntime\nEventStream.fromPublisher(fs2Stream.unsafeToPublisher())\n```\n\n----------------------------------------\n\nTITLE: Creating and Using WriteBus with FilterWriter and ContramapWriter in Scala\nDESCRIPTION: Creates an EventBus for Foo events and derives a specialized writer for Bar events using filtering and transformation. This allows child components to send Bar events that get transformed to Foo events without knowing about the Foo type.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval eventBus = new EventBus[Foo]\nval barWriter: WriteBus[Bar] = eventBus.writer\n  .filterWriter(isGoodFoo)\n  .contramapWriter(barToFoo)\n```\n\n----------------------------------------\n\nTITLE: Creating Distinct Variables in Scala\nDESCRIPTION: Demonstrates how to create a distinct Var that only updates when the new value is different from the current value, using the distinct method.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(id: Int, label: String)\nval fooVar: Var[Foo] = Var(Foo(1, \"hello\"))\nval distinctFooVar: Var[Foo] = fooVar.distinct\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Var Updaters in Scala\nDESCRIPTION: Shows how to create an updater for a Var that combines the current Var value with incoming values. The example demonstrates appending integers to a list stored in a Var and shows both direct usage and integration with streams.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval v = Var(List(1, 2, 3))\nval adder = v.updater[Int]((currValue, nextInput) => currValue :+ nextInput)\n\nadder.onNext(4)\nv.now() // List(1, 2, 3, 4)\n\nval inputStream: EventStream[Int] = ???\n\ninputStream.foreach(adder)\ndiv(inputStream --> adder) // Laminar syntax\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom DOM Event Stream in Scala\nDESCRIPTION: Shows implementation of a custom DOM event stream using CustomStreamSource. Handles event listener registration and cleanup through onStart and onStop callbacks.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\ndef apply[Ev <: dom.Event](\n  eventTarget: dom.EventTarget,\n  eventKey: String,\n  useCapture: Boolean = false\n): EventStream[Ev] = {\n\n  CustomStreamSource[Ev]( (fireValue, fireError, getStartIndex, getIsStarted) => {\n\n    val eventHandler: js.Function1[Ev, Unit] = fireValue\n\n    CustomSource.Config(\n      onStart = () => {\n        eventTarget.addEventListener(eventKey, eventHandler, useCapture)\n      },\n      onStop = () => {\n        eventTarget.removeEventListener(eventKey, eventHandler, useCapture)\n      }\n    )\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using SyncDelay for Stream Ordering in Scala\nDESCRIPTION: Example of using delaySync operator to establish a specific emission order between streams within the same transaction. This is useful when the order of emissions matters but isn't naturally established by dependencies.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nval stream1: EventStream[Int] = ???\nval stream2: EventStream[Int] = ???\n \nval stream1synced = stream1.delaySync(after = stream2)\n```\n\n----------------------------------------\n\nTITLE: Using Distinction Operators in Scala\nDESCRIPTION: Examples of various distinction operators in Airstream that filter updates using different comparison methods. These operators can be used to control when signals emit values based on equality checks.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nsignal.distinct // performs `==` checks, similar to pre-15.0.0 behaviour\nsignal.distinctBy(_.id) // performs `==` checks on a certain key\nsignal.distinctByRef // performs reference equality checks\nsignal.distinctByFn((prevValue, nextValue) => isSame) // custom checks\nsignal.distinctErrors((prevErr, nextErr) => isSame) // filter errors in the error channel\nsignal.distinctTry((prevTryValue, nextTryValue) => isSame) // one comparator for both event and error channels\n```\n\n----------------------------------------\n\nTITLE: Syncing LocalStorage Vars with Element Lifecycle\nDESCRIPTION: Demonstrates how to create and sync a LocalStorage-backed variable that is tied to a specific UI element's lifecycle. This ensures proper cleanup of syncing resources when the element is unmounted, using Laminar's onMountCallback.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef renderItem(item: Item): Div = {\n  val isExpandedVar = WebStorageVar\n    .localStorage(key = s\"item_${id}_isExpanded\", syncOwner = None)\n    .bool(default = false) \n  div(\n    onMountCallback { ctx => isExpandedVar.syncFromExternalUpdates(ctx.owner) },\n    div(\n      onClick.mapToUnit --> isExpandedVar.invertWriter,\n      s\"Item ${item.id}: ${item.label}\"\n    ),\n    div(\n      cls(\"-details\"),\n      display <-- isExpandedVar.signal.map(if (_) \"block\" else \"hidden\"),\n      \"...\"\n    )\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using ComposeChanges with Signals in Scala\nDESCRIPTION: Examples of using composeChanges to apply stream-only operators to Signals. This allows operations like filtering and delay to be applied to Signal updates while preserving the initial value.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nval signal: Signal[Int] = ???\nval delayedSignal = signal.composeChanges(changes => changes.delay(1000)) // all updates delayed by one second\nval filteredSignal = signal.composeChanges(_.filter(_ % 2 == 0)) // only allows changes with even numbers (initial value can still be odd)\n```\n\n----------------------------------------\n\nTITLE: Splitting Signal[Page] with Pattern Matching in Scala\nDESCRIPTION: Demonstrates how to use splitMatchOne to handle different Page types in a Signal. This example shows how to render different HTML elements based on the current page type.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nval pageSignal: Signal[Page] = router.currentPageSignal\n\nval elementSignal: Signal[HtmlElement] =\n  pageSignal\n    .splitMatchOne\n    .handleValue(HomePage) {\n      div(h1(\"Home page\"))\n    }\n    .handleValue(LoginPage) {\n      div(h1(\"Login page\"))\n    }\n    .handleType[UserPage] { (initialUserPage, userPageSignal) =>\n      div(\n        h1(\"User #\", text <-- userPageSignal.map(_.id))\n      )\n    }\n    .toSignal // or .toStream, if pageSignal was a stream instead\n```\n\n----------------------------------------\n\nTITLE: SplitOne Usage for Editor Component\nDESCRIPTION: Demonstrates using splitOne for managing single-item state changes and component lifecycle.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\ncase class Editor(text: Boolean, isMultiLine: Boolean)\n   \ndef renderEditor(\n  isMultiLine: Boolean,\n  initialEditor: Editor,\n  editorSignal: Signal[Editor]\n): HtmlElement = {\n  val tag = if (isMultiLine) textArea else input\n  tag(value <-- editorSignal.map(_.text))\n}\n \nval inputSignal: Signal[Editor] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.isMultiLine)(project = renderEditor)\n```\n\n----------------------------------------\n\nTITLE: SplitOne for Document Editor State Management\nDESCRIPTION: Shows how to use splitOne for managing complex component state and lifecycle based on document ID changes.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\ncase class Document(id: String, content: DocumentContent, ...)\n   \ndef editor(\n  documentId: Boolean,\n  initialDocument: Document,\n  documentSignal: Signal[Document]\n): HtmlElement = {\n  val documentState = Var(initialDocument)\n  ... // More complex setup here, with some internal state specific to a particular document\n  div(\n    someInput --> documentState,\n    documentSignal.map(...) --> documentState,\n    documentState --> ...\n  )\n}\n \nval inputSignal: Signal[Document] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.id)(project = editor)\n```\n\n----------------------------------------\n\nTITLE: Isomorphic Transformation of Var using bimap in Scala\nDESCRIPTION: Shows how to use Var.bimap to create an isomorphic transformation of a Var, creating a new Var with a JSON representation of the original Var's content.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval jsonVar: Var[String] = fooVar.bimap(getThis = Foo.toJson)(getParent = Foo.fromJson)\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Observer Callbacks with Try-Catch\nDESCRIPTION: This code demonstrates the recommended approach for handling potential errors in observer callbacks using try-catch blocks. This pattern allows for local error handling within an observer without affecting other observers or the stream's behavior.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_61\n\nLANGUAGE: scala\nCODE:\n```\nstream.addObserver(Observer(onNext = v =>\n  try { riskyFoo(v) }\n  catch { case err => recoverFromFooFail() }\n))\n```\n\n----------------------------------------\n\nTITLE: Defining a Signal that maps from a parent observable in Scala\nDESCRIPTION: Example showing how a signal is defined by mapping from a parent observable. When the signal loses its last observer, it will be stopped and detached from the parent, preventing it from receiving updates.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_56\n\nLANGUAGE: scala\nCODE:\n```\nval numSignal: Signal[Int] = ???\nval fooSignal: Signal[Foo] = numSignal.map(Foo(_))\n```\n\n----------------------------------------\n\nTITLE: Event Source Usage in Scala\nDESCRIPTION: Demonstrates how to use EventBus as a source for div elements, showing both direct events access and implicit source conversion.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nval textBus = new EventBus[String]\ndiv(value <-- textBus.events)\ndiv(value <-- textBus) // Also works because this <-- accepts Source[String]\n```\n\n----------------------------------------\n\nTITLE: Using EventStream with Callback in Scala\nDESCRIPTION: Example demonstrating the use of EventStream.withCallback to create a stream and a callback function. The callback passes values to the stream, which only emits events when it has observers.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval (stream, callback) = EventStream.withCallback[Int]\ncallback(1) // nothing happens because stream has no observers\nstream.foreach(println)\ncallback(2) // `2` will be printed  \n```\n\n----------------------------------------\n\nTITLE: Batch Emitting Events to Multiple EventBuses in Scala\nDESCRIPTION: Demonstrates how to emit values to multiple EventBuses within a single transaction to avoid glitches. This ensures that downstream observers see a consistent state when processing events from multiple sources.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval valuesEventBus = new EventBus[Int]\nval labelsEventBus = new EventBus[String]\n \nEventBus.emit(\n  valuesEventBus -> 100,\n  labelsEventBus -> \"users\"\n)\n```\n\n----------------------------------------\n\nTITLE: Simple List Rendering Without Split\nDESCRIPTION: Demonstrates inefficient list rendering without using split operator for comparison. Shows limitations of simple mapping approach.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(id: String, version: Int)\n   \ndef renderFoo(foo: Foo): Div = {\n  div(\n    \"foo id: \" + foo.id,\n    \"last seen foo with this id: \" + foo.toString\n  )\n}\n \nval inputSignal: Signal[List[Foo]] = ???\nval outputSignal: Signal[List[Div]] = inputSignal.map(_.map(renderFoo))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Airstream Error Handling Limitations in Conventional Approaches\nDESCRIPTION: This code snippet illustrates the limitations of conventional streaming libraries' error handling approaches using a simple example where an observable chain could fail due to division by zero. The example shows why recovery from errors in parent streams is difficult in traditional streaming models.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_60\n\nLANGUAGE: scala\nCODE:\n```\nobject OtherModule {\n  def doubled(parentStream: EventStream[Double]): EventStream[Double] = {\n    parentStream.map(num => num * 2)\n  }\n}\n \n// ----\n \nimport OtherModule.doubled\n \nval stream1: EventStream[Double] = ???\nval invertedStream: EventStream[Double] = stream1.map(num => 1 / num)\n \ndoubled(invertedStream).foreach(dom.console.log(_))\n```\n\n----------------------------------------\n\nTITLE: Debugging Observers in Scala with Airstream\nDESCRIPTION: Shows how to debug observers using similar debugging operators as observables but with contramap semantics. Demonstrates naming, logging, and error spying functionality for observers.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_59\n\nLANGUAGE: scala\nCODE:\n```\nval stream: EventStream[Int] = ???\nval obs: Observer[Int] = ???\n\nval debuggedObs = obs\n  .debugWithName(\"MyObserver\")\n  .debugLog()\n  .debugSpyErrors(err => ???)\n\n// Before:\nstream.addObserver(obs)\n\n// After: when debugging, replace with:\nstream.addObserver(debuggedObs)\n```\n\n----------------------------------------\n\nTITLE: Initializing SessionStorage Var in Scala\nDESCRIPTION: Creates a WebStorageVar that persists data in browser's SessionStorage. The var is configured with a key and no sync owner, storing text data with an empty default value.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval themeVar: WebStorageVar[String] = WebStorageVar\n  .sessionStorage(key = \"comment\", syncOwner = None)\n  .text(default = \"\")\n```\n\n----------------------------------------\n\nTITLE: Custom Distinct Composition with Split\nDESCRIPTION: Shows how to customize the distinction logic in split operator using distinctCompose parameter.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nchildren <-- nodesStream.split(_.id, _.distinctByFn(customComparator))(/*...*/)\n```\n\n----------------------------------------\n\nTITLE: Defining Page ADT for Routing in Scala\nDESCRIPTION: Defines a sealed trait Page with three case classes representing different pages in a web application. This ADT is used to demonstrate pattern matching in observable splitting.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Page\nobject HomePage extends Page\nobject LoginPage extends Page\ncase class UserPage(userId: Int) extends Page\n```\n\n----------------------------------------\n\nTITLE: Using flatMap to emit multiple events per incoming event in Scala\nDESCRIPTION: Example demonstrating how flatMap can violate transaction constraints by emitting more than one event per incoming event, which is why it's classified as a 'loopy' operator rather than a 'flowy' operator.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\nval intStream: EventStream[Int] = ???\nval flatIntStream: EventStream[Int] = intStream.flatMap { ev =>\n  EventStream.fromSeq(List(ev + 1, ev + 2))\n}\n```\n\n----------------------------------------\n\nTITLE: Transaction Scheduling with Multiple Reactive Variables in Scala\nDESCRIPTION: Illustrates how nested transactions are scheduled and executed in Airstream, demonstrating the depth-first execution model of transaction hierarchies when multiple streams and variables interact.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nval bus = new EventBus[Event]\nval logVar = Var(List[Event]())\nval countVar = Var(0)\nbus.events.foreach { ev =>\n  logVar.update(_ :+ ev)\n  logVar.update(_ :+ ev)\n  // After both transactions execute, logVar will have two `ev`-s in it\n}\nlogVar.signal.foreach { log =>\n  sideEffect(log.size)\n  countVar.update(_ += 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an EventStream from a Sequence in Scala\nDESCRIPTION: Definition of EventStream.fromSeq factory method that creates a stream emitting events from a provided sequence. Each event is emitted in a separate transaction, ensuring complete propagation before the next event starts.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject EventStream {\n  def fromSeq[A](events: Seq[A]): EventStream[A] = ...\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Var Transaction Delay Behavior in Scala\nDESCRIPTION: Illustrates how Var updates and value reads interact with transactions. The code shows different output when run directly versus when run inside another transaction, demonstrating Var's transaction scheduling behavior.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval myVar = Var(0)\n\nprintln(\"Start\")\n\nmyVar.set(1)\nprintln(s\"After set: ${myVar.now()}\")\n\nmyVar.update(_ + 1)\nprintln(s\"After update: ${myVar.now()}\")\n\nTransaction { _ =>\n  println(s\"After trx: ${myVar.now()}\")\n}\n\nprintln(\"Done\")\n```\n\n----------------------------------------\n\nTITLE: Managing Transaction Scheduling with Vars in Scala\nDESCRIPTION: Shows a problematic pattern where setting a Var's value and then reading it in the same transaction does not reflect the updates because they are scheduled for future execution.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nval logVar: Var[List[Event]] = ???\nstream.foreach { ev =>\n  logVar.set(logVar.now() :+ ev)\n  logVar.set(logVar.now() :+ ev)\n  println(logVar.now())\n  // NONE of the logVar.now() calls here will contain any `ev`\n  // because they are all executed before the .set transaction executes.\n  // Because of this, after all of the transactions are executed,\n  // logVar will only contain one instance of `ev`, not two.\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a self-dependent observable loop with flatMap in Scala\nDESCRIPTION: Example showing how flatMap can create a cycle in the observable graph by allowing an observable to depend on itself, which explains why it must emit events in a new transaction.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nval intStream: EventStream[Int] = ???\nval flatIntStream: EventStream[Int] = intStream.flatMap { ev =>\n  flatIntStream.map(_ + 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Status Types in Scala\nDESCRIPTION: Defines the basic types for representing the status of asynchronous operations in Airstream.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Status[+In, +Out] { /* ... */ }\ncase class Pending[+In](input: In) extends Status[In, Nothing] { /* ... */ }\ncase class Resolved[+In, +Out](input: In, output: Out, ix: Int) extends Status[In, Out] { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Multiplication in Scala Streams\nDESCRIPTION: This code snippet illustrates how a single error in an upstream source can propagate to multiple downstream streams, potentially resulting in multiple unhandled error reports. It shows the importance of handling errors at the appropriate level in the stream hierarchy.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_63\n\nLANGUAGE: scala\nCODE:\n```\nval upStream = ???\nval fooStream = upStream.map(foo)\nval barStream = upStream.map(bar)\nfooStream.foreach(dom.console.log(\"foo\"))\nbarStream.foreach(dom.console.log(\"bar\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing TransferableSubscription in Scala\nDESCRIPTION: Definition of TransferableSubscription class which allows subscription transfer between active DynamicOwners without deactivation. It provides methods to set or clear the owner while maintaining continuity of active ownership.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass TransferableSubscription(\n  activate: () => Unit,\n  deactivate: () => Unit\n) { \n  def setOwner(nextOwner: DynamicOwner): Unit\n  def clearOwner(): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Airstream Dependency to Scala.js Project\nDESCRIPTION: This snippet shows how to add the Airstream library as a dependency in a Scala.js project. It requires Scala.js version 1.16.0 or higher.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n\"com.raquo\" %%% \"airstream\" % \"<version>\"  // Requires Scala.js 1.16.0+\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Observer Error Handling in Scala\nDESCRIPTION: This snippet shows how errors are handled in derived observers. It creates a source observer that prints Try[Int] values, and a derived observer that throws an exception for negative values. The example demonstrates how errors are wrapped and propagated.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_62\n\nLANGUAGE: scala\nCODE:\n```\nval sourceObs = Observer.fromTry[Int](println)\nval derivedObs = sourceObs.contramap[Int] { value =>\n  if (value >= 0) 1 else throw new Exception(\"negative!\")\n}\nderivedObs.onNext(1) // prints \"Success(1)\"\nderivedObs.onNext(-1) // prints \"Failure(ObserverError: java.lang.Exception: negative!)\"\n// no errors are sent into unhandled because `println` is a total function, it handles them all.\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicate Key Warnings in Airstream's Split Operator\nDESCRIPTION: Shows how to configure duplicate key warnings for split operators. This can be set globally for the entire application or individually for specific split operators to control error reporting behavior.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\n// Disable duplicate key warnings by default\nDuplicateKeysConfig.setDefault(DuplicateKeysConfig.noWarnings)\n\n// Disable warnings for just one split observable\nstream.split(_.id, duplicateKeys = DuplicateKeysConfig.noWarnings)(...)\n```\n\n----------------------------------------\n\nTITLE: Equivalent splitOne Implementation in Scala\nDESCRIPTION: Shows the equivalent implementation of the splitMatchOne macro using the regular splitOne operator. This demonstrates how the macro expands and handles different types.\nSOURCE: https://github.com/raquo/airstream/blob/master/README.md#2025-04-20_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nval elementSignal: Signal[HtmlElement] =\n  pageSignal\n    .map {\n      // condition => (handlerIndex, handlerInput)\n      case HomePage => (0, ())\n      case LoginPage => (1, ())\n      case up: UserPage => (2, up)\n    }\n    .splitOne(key = _._1) {\n      (\n        handlerIndex: Int,\n        handlerIndexAndInput: (Int, Page | Unit),\n        signalOfIndexAndInput: Signal[(Int, Page | Unit)]\n      ) =>\n        if (handlerIndex == 0) {\n          // handleValue(HomePage)\n          div(h1(\"Home page\"))\n        } else if (handlerIndex == 1) {\n          // handleValue(LoginPage)\n          div(h1(\"Login page\"))\n        } else if (handlerIndex == 2) {\n          // handleType[UserPage] { ... }\n          val initialUserPage: UserPage = handlerIndexAndInput._2.asInstanceOf[UserPage]\n          val userPageSignal: Signal[UserPage] = signalOfIndexAndInput.map(_._2.asInstanceOf[UserPage]) \n          div(\n            h1(\"User #\", text <-- userPageSignal.map(_.id))\n          )\n        }\n    }\n\nchild <-- elementSignal // in Laminar\n```"
  }
]