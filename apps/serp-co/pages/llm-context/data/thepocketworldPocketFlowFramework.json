[
  {
    "owner": "the-pocket-world",
    "repo": "pocket-flow-framework",
    "content": "TITLE: Complete Example: End-to-End Flow Implementation\nDESCRIPTION: A comprehensive example showing how to create multiple nodes, connect them in a flow, and run the flow with shared state.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"pocket-ts\";\n\n// Node #1: Greet user\nclass GreetNode extends BaseNode {\n  public async execAsync(_: unknown): Promise<string> {\n    return \"Hello! What's your name?\";\n  }\n  public async postAsync(sharedState: any, _: any, greeting: string): Promise<string> {\n    console.log(greeting);\n    return DEFAULT_ACTION;\n  }\n}\n\n// Node #2: Get user's name (mock input)\nclass GetNameNode extends BaseNode {\n  public async execAsync(_: unknown): Promise<string> {\n    return \"Alice\"; // In real life, you'd ask or read from user input\n  }\n  public async postAsync(sharedState: any, _: any, name: string): Promise<string> {\n    sharedState.userName = name;\n    return DEFAULT_ACTION;\n  }\n}\n\n// Node #3: Personalize farewell\nclass FarewellNode extends BaseNode {\n  public async execAsync(_: unknown): Promise<string> {\n    return \"Nice to meet you!\";\n  }\n  public async postAsync(sharedState: any, _: any, farewell: string): Promise<string> {\n    console.log(`${farewell} Goodbye, ${sharedState.userName}!`);\n    return DEFAULT_ACTION;\n  }\n}\n\n// Build flow\nconst greetNode = new GreetNode();\nconst nameNode = new GetNameNode();\nconst farewellNode = new FarewellNode();\n\ngreetNode.addSuccessor(nameNode, DEFAULT_ACTION);\nnameNode.addSuccessor(farewellNode, DEFAULT_ACTION);\n\nconst flow = new Flow(greetNode);\n\n// Run flow\nflow.runAsync({}).then(() => {\n  console.log(\"Flow complete!\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Branching and Looping Expense Approval Flow in TypeScript\nDESCRIPTION: This example demonstrates how to create a complex flow with branching logic and a potential loop. It models an expense approval process with four node types: review, payment, revision, and completion, showing how to configure different action transitions.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Define ReviewExpenseNode\nclass ReviewExpenseNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare expense data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute review logic\n  }\n\n  public async postAsync(sharedState: any, prepResult: void, execResult: void): Promise<string> {\n    // Example decision logic\n    const decision = \"approved\"; // Replace with actual decision-making\n    return decision;\n  }\n}\n\n// Define PaymentNode\nclass PaymentNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare payment data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute payment processing\n  }\n\n  public async postAsync(sharedState: any, prepResult: void, execResult: void): Promise<string> {\n    return DEFAULT_ACTION;\n  }\n}\n\n// Define ReviseExpenseNode\nclass ReviseExpenseNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare revision data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute revision logic\n  }\n\n  public async postAsync(sharedState: any, prepResult: void, execResult: void): Promise<string> {\n    return \"needs_revision\";\n  }\n}\n\n// Define FinishNode\nclass FinishNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare finish data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute finish logic\n  }\n\n  public async postAsync(sharedState: any, prepResult: void, execResult: void): Promise<string> {\n    return DEFAULT_ACTION;\n  }\n}\n\n// Instantiate nodes\nconst reviewExpense = new ReviewExpenseNode();\nconst payment = new PaymentNode();\nconst reviseExpense = new ReviseExpenseNode();\nconst finish = new FinishNode();\n\n// Define the flow connections\nreviewExpense.addSuccessor(payment, \"approved\");\nreviewExpense.addSuccessor(reviseExpense, \"needs_revision\");\nreviewExpense.addSuccessor(finish, \"rejected\");\n\nreviseExpense.addSuccessor(reviewExpense, \"needs_revision\"); // Loop back for revision\npayment.addSuccessor(finish, \"default\"); // Proceed to finish after payment\n\n// Create the flow starting with reviewExpense\nconst expenseFlow = new Flow(reviewExpense);\n\n// Initial shared state\nconst sharedState = {};\n\n// Run the flow\nexpenseFlow.runAsync(sharedState).then(() => {\n  console.log(\"Expense flow completed successfully.\");\n}).catch(error => {\n  console.error(\"Expense flow execution failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Article Writing Flow with TypeScript\nDESCRIPTION: A complete implementation of an article writing system using three nodes: outline generation, content writing, and review/refinement. The code demonstrates how to structure async operations, manage shared state, and chain LLM calls in a TypeScript-based flow framework.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/decomp.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Placeholder for an asynchronous LLM call\nasync function callLLM(prompt: string): Promise<string> {\n  // Replace with actual implementation, e.g., API call to an LLM service\n  return `Generated response based on prompt: ${prompt}`;\n}\n\nexport class GenerateOutlineNode extends BaseNode {\n  // The 'prepAsync' method prepares the topic for generating an outline\n  public async prepAsync(sharedState: any): Promise<string> {\n    return sharedState.topic;\n  }\n\n  // The 'execAsync' method generates a detailed outline for the article\n  public async execAsync(topic: string): Promise<string> {\n    const prompt = `Create a detailed outline for an article about ${topic}`;\n    const outline = await callLLM(prompt);\n    return outline;\n  }\n\n  // The 'postAsync' method stores the generated outline in the shared store\n  public async postAsync(sharedState: any, _: string, execResult: string): Promise<string> {\n    sharedState.outline = execResult;\n    return DEFAULT_ACTION; // Proceed to the next node\n  }\n}\n\nexport class WriteSectionNode extends BaseNode {\n  // The 'prepAsync' method retrieves the outline from the shared store\n  public async prepAsync(sharedState: any): Promise<string> {\n    return sharedState.outline;\n  }\n\n  // The 'execAsync' method writes content based on the outline\n  public async execAsync(outline: string): Promise<string> {\n    const prompt = `Write content based on this outline: ${outline}`;\n    const draft = await callLLM(prompt);\n    return draft;\n  }\n\n  // The 'postAsync' method stores the draft in the shared store\n  public async postAsync(sharedState: any, _: string, execResult: string): Promise<string> {\n    sharedState.draft = execResult;\n    return DEFAULT_ACTION; // Proceed to the next node\n  }\n}\n\nexport class ReviewAndRefineNode extends BaseNode {\n  // The 'prepAsync' method retrieves the draft from the shared store\n  public async prepAsync(sharedState: any): Promise<string> {\n    return sharedState.draft;\n  }\n\n  // The 'execAsync' method reviews and improves the draft\n  public async execAsync(draft: string): Promise<string> {\n    const prompt = `Review and improve this draft: ${draft}`;\n    const finalArticle = await callLLM(prompt);\n    return finalArticle;\n  }\n\n  // The 'postAsync' method stores the final article in the shared store\n  public async postAsync(sharedState: any, _: string, execResult: string): Promise<string> {\n    sharedState.final_article = execResult;\n    return DEFAULT_ACTION; // Flow is complete\n  }\n}\n\n// Instantiate nodes\nconst generateOutline = new GenerateOutlineNode();\nconst writeSection = new WriteSectionNode();\nconst reviewAndRefine = new ReviewAndRefineNode();\n\n// Connect nodes to form the flow: GenerateOutline -> WriteSection -> ReviewAndRefine\ngenerateOutline.addSuccessor(writeSection, DEFAULT_ACTION);\nwriteSection.addSuccessor(reviewAndRefine, DEFAULT_ACTION);\n\n// Create the flow starting with the GenerateOutline node\nconst writingFlow = new Flow(generateOutline);\n\n// Define the shared state with the article topic\nconst shared = { topic: \"AI Safety\" };\n\n// Run the flow\nwritingFlow.runAsync(shared).then(() => {\n  console.log(\"Final Article:\", shared.final_article);\n}).catch(error => {\n  console.error(\"Flow execution failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Workflow with Nodes and Flow in TypeScript\nDESCRIPTION: This comprehensive example demonstrates how to create a complete workflow by extending BaseNode to create custom nodes, defining transitions between them, and orchestrating execution with a Flow.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/core_abstraction.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\nclass NodeA extends BaseNode {\n  async prep(sharedState: any): Promise<void> {}\n  async execCore(prepResult: any): Promise<void> {}\n  async post(prepResult: any, execResult: any, sharedState: any): Promise<string> {\n    return \"default\";\n  }\n}\n\nclass NodeB extends BaseNode {\n  async prep(sharedState: any): Promise<void> {}\n  async execCore(prepResult: any): Promise<void> {}\n  async post(prepResult: any, execResult: any, sharedState: any): Promise<string> {\n    return DEFAULT_ACTION;\n  }\n}\n\nconst nodeA = new NodeA();\nconst nodeB = new NodeB();\nnodeA.addSuccessor(nodeB, \"default\");\n\nconst flow = new Flow(nodeA);\nflow.run({});\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Flows with Logging and Notification in TypeScript\nDESCRIPTION: Creates LoggingNode and NotificationNode classes extending BaseNode, and demonstrates how to connect them to existing order processing flows. Includes async preparation, execution, and post-processing logic with shared state management.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Define LoggingNode\nclass LoggingNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare logging data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute logging logic\n  }\n\n  public async postAsync(sharedState: any, _, __: void): Promise<string> {\n    console.log(`Order ${sharedState.orderId} processed for ${sharedState.customer}`);\n    return DEFAULT_ACTION;\n  }\n}\n\n// Define NotificationNode\nclass NotificationNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Prepare notification data\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execute notification logic\n  }\n\n  public async postAsync(sharedState: any, _, __: void): Promise<string> {\n    // Send notification\n    return DEFAULT_ACTION;\n  }\n}\n\n// Instantiate logging and notification nodes\nconst loggingNode = new LoggingNode();\nconst notificationNode = new NotificationNode();\n\n// Connect shippingFlow to logging and notification\nshippingFlow.addSuccessor(loggingNode, \"default\");\nloggingNode.addSuccessor(notificationNode, \"default\");\n\n// Update the master flow to include logging and notification\norderProcessingFlow.addSuccessor(loggingNode, \"default\");\nloggingNode.addSuccessor(notificationNode, \"default\");\n\n// Run the updated flow\norderProcessingFlow.runAsync(sharedState).then(() => {\n  console.log(\"Order processing with logging and notification completed successfully.\");\n}).catch(error => {\n  console.error(\"Order processing failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Node-Based Processing in TypeScript\nDESCRIPTION: Defines the fundamental BaseNode abstract class with a three-phase execution pattern including prep, execCore, and post methods for handling data processing flow.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class BaseNode {\n    async prep(sharedState: any): Promise<any>;     // Prepare data\n    async execCore(prepResult: any): Promise<any>;  // Execute core logic\n    async post(prepResult: any, execResult: any, sharedState: any): Promise<string>;  // Post-process\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Processing with BatchFlow in TypeScript using Pocket Flow Framework\nDESCRIPTION: This example demonstrates parallel processing of multiple items using BatchFlow from the Pocket Flow Framework. It processes an array of image paths concurrently and stores the results in the shared state.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/apps.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass ImageProcessingFlow extends BatchFlow {\n    async prep(sharedState: any) {\n        // Return array of image paths to process\n        return sharedState.imagePaths;\n    }\n\n    async post(prepResults: string[], results: any[], sharedState: any) {\n        sharedState.processedImages = results;\n        return DEFAULT_ACTION;\n    }\n}\n\n// Usage\nconst batchFlow = new ImageProcessingFlow(processingNode);\nawait batchFlow.run({\n    imagePaths: [\n        \"image1.jpg\",\n        \"image2.jpg\",\n        \"image3.jpg\"\n    ]\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Node and Flow Execution in TypeScript\nDESCRIPTION: Complete example demonstrating the implementation of a custom node (MyNode) extending BaseNode, flow construction by connecting nodes, and flow execution with initial shared state.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/guide.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"pocket\"; // Assuming 'pocket' is the package name\n\nclass MyNode extends BaseNode {\n  async prep(sharedState: any): Promise<any> {\n    console.log(\"MyNode Prep:\", sharedState);\n    // Example: Prepare data based on shared state\n    return { nodeInput: sharedState.initialData }; \n  }\n  \n  async execCore(prepResult: any): Promise<any> {\n    console.log(\"MyNode ExecCore:\", prepResult);\n    // Example: Perform the core task\n    return { resultData: `Processed: ${prepResult.nodeInput}` };\n  }\n  \n  async post(prepResult: any, execResult: any, sharedState: any): Promise<string> {\n    console.log(\"MyNode Post:\", execResult);\n    // Example: Update shared state\n    sharedState.lastResult = execResult.resultData;\n    // Determine the next action\n    return DEFAULT_ACTION; // Proceed to the default successor\n  }\n\n  // Required for the flow to function correctly\n  _clone(): BaseNode {\n    return new MyNode();\n  }\n}\n\n// --- Flow Setup ---\n\n// Create node instances\nconst nodeA = new MyNode();\nconst nodeB = new MyNode(); // Another node instance\n\n// Connect nodeA's default action to nodeB\nnodeA.addSuccessor(nodeB, DEFAULT_ACTION);\n\n// Create the flow starting with nodeA\nconst flow = new Flow(nodeA);\n\n// Define initial shared state\nconst initialState = { initialData: \"Hello PocketFlow!\" };\n\n// Run the flow\nconsole.log(\"Starting flow...\");\nconst finalState = await flow.run(initialState);\nconsole.log(\"Flow finished. Final State:\", finalState);\n```\n\n----------------------------------------\n\nTITLE: Implementing YAML Summarization Node in TypeScript\nDESCRIPTION: A complete TypeScript class that extends BaseNode to summarize text using an LLM and return structured YAML output. The implementation includes preparation, execution, and post-processing with validation of the LLM response.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/structure.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, DEFAULT_ACTION } from \"../src/pocket\";\nimport { callLLM } from \"../path/to/your/llm-wrapper\";\n\n/**\n * SummarizeNode:\n * 1) Prepares a prompt with instructions for YAML output.\n * 2) Calls the LLM to generate the structured YAML.\n * 3) Parses the YAML and validates the result.\n */\nexport class SummarizeNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string> {\n    // Grab the text to summarize\n    const textToSummarize: string = sharedState.text ?? \"No text provided.\";\n    return textToSummarize;\n  }\n\n  public async execAsync(text: string): Promise<string> {\n    // Construct a prompt that instructs the LLM to return exactly 3 bullet points in YAML\n    const prompt = `\nPlease summarize the following text in YAML with exactly 3 bullet points.\n\nText:\n${text}\n\nThe YAML should look like this:\n\n\\`\\`\\`yaml\nsummary:\n  - bullet 1\n  - bullet 2\n  - bullet 3\n\\`\\`\\`\n\nOnly return the YAML (including the fences).\n`;\n    // Call the LLM with your custom logic\n    const response = await callLLM(prompt);\n    return response;\n  }\n\n  public async postAsync(\n    sharedState: any,\n    prepResult: string,\n    llmResponse: string\n  ): Promise<string> {\n    // Extract the YAML content between the fences\n    let yamlStr = \"\";\n    try {\n      const startTag = \"```yaml\";\n      const endTag = \"```\";\n\n      const startIndex = llmResponse.indexOf(startTag);\n      const endIndex = llmResponse.indexOf(endTag, startIndex + startTag.length);\n\n      if (startIndex !== -1 && endIndex !== -1) {\n        yamlStr = llmResponse.substring(startIndex + startTag.length, endIndex).trim();\n      } else {\n        throw new Error(\"LLM response did not contain valid ```yaml``` fences.\");\n      }\n\n      // Parse the YAML\n      // (You might need \"js-yaml\" or similar library for safe YAML parsing.)\n      const yaml = await import(\"js-yaml\");\n      const structResult = yaml.load(yamlStr);\n\n      // Validate the structure\n      if (!structResult || typeof structResult !== \"object\") {\n        throw new Error(\"Parsed result is not a valid YAML object.\");\n      }\n      if (!(\"summary\" in structResult) || !Array.isArray((structResult as any).summary)) {\n        throw new Error(\"Expected a 'summary' array in the YAML output.\");\n      }\n\n      // Save the structured output\n      sharedState.summary = structResult;\n    } catch (err) {\n      // Optionally retry or provide fallback. For now, just log and store an error.\n      console.error(\"Error parsing YAML from LLM:\", err);\n      sharedState.summary = { error: \"Invalid YAML output from LLM.\" };\n    }\n\n    return DEFAULT_ACTION; // Continue the flow\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Flow Orchestration in the Flow Class\nDESCRIPTION: The Flow class manages node execution. The orchestrate method handles the sequential execution of nodes, passing control from one node to the next based on the returned action, while maintaining the shared state.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nclass Flow extends BaseNode {\n    private start: BaseNode;\n\n    async orchestrate(sharedState: any, flowParams?: any): Promise<any> {\n        let currentNode: BaseNode | undefined = await this.getStartNode();\n        while (currentNode) {\n            currentNode.setParams((flowParams) ? flowParams : this.flow_params);\n            const action = await currentNode.run(sharedState);\n            currentNode = currentNode.getSuccessor(action);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic OpenAI LLM Wrapper Implementation in TypeScript\nDESCRIPTION: Implements a basic LLM wrapper function that sends prompts to OpenAI's API and returns responses. Uses environment variables for API key storage and includes basic error handling.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/llm.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Configuration, OpenAIApi } from \"openai\";\n\n/**\n * callLLM\n * \n * An example function that sends a prompt to OpenAI's API and returns the response text.\n * Make sure to store your API key in an environment variable like OPENAI_API_KEY.\n */\nexport async function callLLM(prompt: string): Promise<string> {\n  const config = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n  const openai = new OpenAIApi(config);\n\n  const response = await openai.createChatCompletion({\n    model: \"gpt-4\",\n    messages: [{ role: \"user\", content: prompt }],\n  });\n\n  // Safely handle the response\n  return response.data.choices?.[0]?.message?.content ?? \"\";\n}\n\n/**\n * Example usage\n */\n// (async () => {\n//   const reply = await callLLM(\"How are you?\");\n//   console.log(\"LLM reply:\", reply);\n// })();\n```\n\n----------------------------------------\n\nTITLE: Defining BaseNode Abstract Class in TypeScript\nDESCRIPTION: Abstract class definition for BaseNode, which is the foundation for all nodes in the Pocket Flow Framework. It outlines the required lifecycle methods and the clone method.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/guide.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class BaseNode {\n  // Prepare input data or transform shared state before core execution\n  abstract prep(sharedState: any): Promise<any>;\n  \n  // Contains the main logic of the node\n  abstract execCore(prepResult: any): Promise<any>;\n  \n  // Processes results, updates shared state, and determines the next step (action)\n  abstract post(prepResult: any, execResult: any, sharedState: any): Promise<string>;\n\n  // Creates a new instance of the node (required for flow execution)\n  abstract _clone(): BaseNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncParallelBatchFlow for Processing Multiple Files Concurrently in TypeScript\nDESCRIPTION: This snippet shows how to use AsyncParallelBatchFlow to process multiple files in parallel. The class generates parameter objects for each file, then runs a subflow concurrently for each set of parameters. This pattern is useful for independent I/O operations like processing multiple files simultaneously.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/parallel.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AsyncParallelBatchFlow, Flow } from \"../src/pocket\";\nimport { LoadAndSummarizeFile } from \"./somewhere\";\n\nexport class SummarizeMultipleFiles extends AsyncParallelBatchFlow {\n  // We override prepAsync to produce a list of param objects\n  public async prepAsync(sharedState: any): Promise<any[]> {\n    // Return one param object per file\n    const files: string[] = sharedState.files ?? [];\n    return files.map((filename) => ({ filename }));\n  }\n}\n\n// Example usage:\nconst subFlow = new Flow(new LoadAndSummarizeFile());\nconst parallelFlow = new SummarizeMultipleFiles(subFlow);\n\nconst shared: any = {\n  files: [\"doc1.txt\", \"doc2.txt\", \"doc3.txt\"],\n};\n\nparallelFlow.runAsync(shared).then(() => {\n  console.log(\"All files processed in parallel!\");\n  // shared might now contain combined summaries or saved results per file\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing RAG System with PrepareEmbeddingsNode and AnswerQuestionNode in TypeScript\nDESCRIPTION: This code snippet demonstrates the implementation of a Retrieval Augmented Generation (RAG) system using TypeScript. It includes two main classes: PrepareEmbeddingsNode for creating and indexing embeddings, and AnswerQuestionNode for retrieving relevant information and generating answers. The code also includes placeholder functions for embedding, indexing, and LLM calls, which should be replaced with actual implementations in a real-world scenario.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/rag.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n/** \n * Placeholder for your embedding + index building code.\n * In a real scenario, you'd call a vector DB or embedding service.\n */\nasync function getEmbedding(text: string): Promise<Float32Array> {\n  // Return a 768-D or 1536-D embedding from a service or local model\n  // Here we just fake it by returning a vector of length = text.length\n  return new Float32Array(text.length).fill(0.5);\n}\nfunction createIndex(embeddings: Float32Array[]): any {\n  // Build or store the index in memory or an external DB\n  // Return an index object for subsequent searches\n  return { someIndexObject: true };\n}\nfunction searchIndex(index: any, queryEmbedding: Float32Array, topK: number): [Array<[number, number]>, any] {\n  // This function should return indices of the most relevant documents\n  // and potentially their scores. For demonstration, we'll assume it always returns\n  // an index of 0 with a dummy similarity score.\n  return [[[0, 0.99]], null];\n}\n\n/**\n * Placeholder for an LLM call. Replace with your actual logic, e.g. OpenAI chat API.\n */\nasync function callLLM(prompt: string): Promise<string> {\n  return `Answer to: ${prompt.substring(0, 60)}...`;\n}\n\n/**\n * Step 1: PrepareEmbeddingsNode\n *  - Gathers the corpus from sharedState[\"texts\"]\n *  - Creates embeddings\n *  - Builds a search index and stores it in sharedState[\"search_index\"]\n */\nexport class PrepareEmbeddingsNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string[]> {\n    if (!Array.isArray(sharedState.texts)) {\n      throw new Error(\"sharedState.texts must be an array of strings\");\n    }\n    return sharedState.texts;\n  }\n\n  public async execAsync(texts: string[]): Promise<any> {\n    // Compute embeddings for each text\n    const embeddings: Float32Array[] = [];\n    for (let text of texts) {\n      const emb = await getEmbedding(text);\n      embeddings.push(emb);\n    }\n    // Create an index from these embeddings\n    const index = createIndex(embeddings);\n    return index;\n  }\n\n  public async postAsync(sharedState: any, prepResult: string[], execResult: any): Promise<string> {\n    // Store the search index\n    sharedState.search_index = execResult;\n    return DEFAULT_ACTION;\n  }\n}\n\n/**\n * Step 2: AnswerQuestionNode\n *  - Reads a question from the user or a passed-in param\n *  - Searches the index for the most relevant text\n *  - Calls the LLM with the question + relevant text to get an answer\n *  - Outputs the answer\n */\nexport class AnswerQuestionNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<{ question: string; relevantText: string }> {\n    // For a real UI, you might read from the console or an API param\n    const question = this.params[\"question\"] ?? \"How does Node.js handle concurrency?\";\n\n    // Get embedding for this question\n    const questionEmbedding = await getEmbedding(question);\n\n    // Search the existing index\n    if (!sharedState.search_index) {\n      throw new Error(\"No search index found in sharedState\");\n    }\n    const [results] = searchIndex(sharedState.search_index, questionEmbedding, 1);\n    // results might look like: [[docIndex, similarityScore], ...], pick the top one\n    const docIndex = results[0][0]; // The top doc index\n    const relevantText = sharedState.texts?.[docIndex] ?? \"\";\n\n    return { question, relevantText };\n  }\n\n  public async execAsync({ question, relevantText }: { question: string; relevantText: string }): Promise<string> {\n    const prompt = `Question: ${question}\\nContext: ${relevantText}\\nAnswer: `;\n    return await callLLM(prompt);\n  }\n\n  public async postAsync(sharedState: any, prepResult: any, execResult: string): Promise<string> {\n    console.log(`Answer: ${execResult}`);\n    // In a real scenario, you might store the answer in sharedState or return a next Action\n    return DEFAULT_ACTION;  // Flow ends or continues\n  }\n}\n\n/**\n * Example usage:\n */\n(async () => {\n  const shared: any = {\n    texts: [\n      \"Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.\",\n      \"TypeScript extends JavaScript by adding types, improving developer productivity.\",\n      \"Retrieval Augmented Generation (RAG) helps LLMs ground responses in real sources.\"\n    ]\n  };\n\n  // Create the nodes\n  const prepNode = new PrepareEmbeddingsNode();\n  const answerNode = new AnswerQuestionNode();\n  // Connect them\n  prepNode.addSuccessor(answerNode, \"default\");\n\n  // Build the Flow\n  const flow = new Flow(prepNode);\n\n  // Optionally set the question as a param for answerNode\n  answerNode.setParams({ question: \"What is Node.js concurrency model?\" });\n\n  // Run the flow\n  await flow.runAsync(shared);\n})();\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Flows in TypeScript\nDESCRIPTION: This snippet shows how to create nested flows by composing a sub-flow within a parent flow. It demonstrates how flows can be used as nodes within other flows to enable powerful compositional patterns.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Define sub-flow nodes\nconst nodeA = new NodeA();\nconst nodeB = new NodeB();\nnodeA.addSuccessor(nodeB);\n\n// Create sub-flow\nconst subFlow = new Flow(nodeA);\n\n// Connect sub-flow to another node\nconst nodeC = new NodeC();\nsubFlow.addSuccessor(nodeC);\n\n// Create parent flow\nconst parentFlow = new Flow(subFlow);\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Reduce Pattern for Document Summarization in TypeScript\nDESCRIPTION: A complete implementation of a Map Reduce pattern for document summarization using two nodes: MapSummaries for splitting and processing chunks, and ReduceSummaries for combining results. The implementation includes a placeholder LLM call function and demonstrates the full flow setup.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/mapreduce.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Placeholder LLM call that takes a prompt and returns a string\nasync function callLLM(prompt: string): Promise<string> {\n  // Replace with your actual LLM logic (OpenAI, local model, etc.)\n  return `Summary: ${prompt.substring(0, 60)}...`;\n}\n\n/**\n * MapSummaries Node:\n *  - Splits a large text into chunks (prepAsync)\n *  - Summarizes each chunk (execAsync)\n *  - Collects the chunk summaries into an array (postAsync)\n */\nexport class MapSummaries extends BaseNode {\n  // The 'prepAsync' method chunks the text\n  public async prepAsync(sharedState: any): Promise<string[]> {\n    const text = sharedState.text ?? \"\";\n    const chunkSize = 10000;\n    const chunks: string[] = [];\n    for (let i = 0; i < text.length; i += chunkSize) {\n      chunks.push(text.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  // The 'execAsync' method calls the LLM for each chunk\n  public async execAsync(chunk: string): Promise<string> {\n    return await callLLM(`Summarize this chunk: ${chunk}`);\n  }\n\n  // The 'postAsync' method saves each summarized chunk into sharedState\n  public async postAsync(sharedState: any, prepResult: string[], execResultList: string[]): Promise<string> {\n    sharedState.summaries = execResultList;\n    return DEFAULT_ACTION; // Transition to the reduce node\n  }\n}\n\n/**\n * ReduceSummaries Node:\n *  - Takes the array of chunk summaries\n *  - Merges them into one final summary\n */\nexport class ReduceSummaries extends BaseNode {\n  // The 'prepAsync' method retrieves the chunk summaries\n  public async prepAsync(sharedState: any): Promise<string[]> {\n    return sharedState.summaries ?? [];\n  }\n\n  // The 'execAsync' method calls the LLM to combine the chunk summaries\n  public async execAsync(summaries: string[]): Promise<string> {\n    const prompt = `Combine these summaries:\\n${summaries.join(\"\\n\")}`;\n    return await callLLM(prompt);\n  }\n\n  // The 'postAsync' method saves the final summary\n  public async postAsync(sharedState: any, prepResult: string[], execResult: string): Promise<string> {\n    sharedState.final_summary = execResult;\n    return DEFAULT_ACTION; // Flow ends here by default\n  }\n}\n\n// Instantiate the Map (split+summaries) and Reduce nodes\nconst mapNode = new MapSummaries();\nconst reduceNode = new ReduceSummaries();\n\n// Connect mapNode to reduceNode\nmapNode.addSuccessor(reduceNode, DEFAULT_ACTION);\n\n// Create the Flow\nconst summarizeFlow = new Flow(mapNode);\n\n// Example usage\n(async () => {\n  const shared: any = {\n    text: \"Very large text content goes here...\",\n  };\n  await summarizeFlow.runAsync(shared);\n  console.log(\"Final summary:\", shared.final_summary);\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing BaseNode Abstract Class in TypeScript\nDESCRIPTION: The BaseNode class is the foundation of the framework. It defines the core methods that every node must implement, including prep for preparation, execCore for execution logic, post for post-processing, and _clone for replication.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class BaseNode {\n    // Prepare data for execution\n    abstract prep(sharedState: any): Promise<any>;\n\n    // Core execution logic\n    abstract execCore(prepResult: any): Promise<any>;\n\n    // Post-processing and determine next action\n    abstract post(prepResult: any, execResult: any, sharedState: any): Promise<string>;\n\n    // Required for cloning in parallel execution\n    abstract _clone(): BaseNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Search Agent with Recursive Decision-Making in TypeScript\nDESCRIPTION: This code demonstrates how to build an agent that can make recursive decisions about whether to search for more information or answer a query. It includes three custom node types (DecideAction, SearchWebNode, and DirectAnswer) that are connected in a flow with looping capabilities.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/agent.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Placeholder for an LLM call\nasync function callLLM(prompt: string): Promise<string> {\n  // Example function to call a Large Language Model\n  // Return a YAML-like string (or any structured string) in practice\n  return `\n\\`\\`\\`yaml\naction: \"search\"\nreason: \"Need more results\"\nsearch_term: \"Nobel Prize 2024\"\n\\`\\`\\`\n`;\n}\n\n// Placeholder for a web search\nasync function searchWeb(searchTerm: string): Promise<string> {\n  // Example function that interacts with an external API\n  return `Search Results for: ${searchTerm}`;\n}\n\nexport class DecideAction extends BaseNode {\n  // The 'prep' method extracts data from sharedState to pass into execCore\n  public async prep(sharedState: any): Promise<[string, string]> {\n    const context = sharedState.context ?? \"No previous search\";\n    const query = sharedState.query;\n    return [query, context];\n  }\n\n  // The main logic calls callLLM to decide whether to search again or to answer\n  public async execCore(inputs: [string, string]): Promise<any> {\n    const [query, context] = inputs;\n    const prompt = `\nGiven input: ${query}\nPrevious search results: ${context}\nShould I: 1) Search web for more info 2) Answer with current knowledge\nOutput in YAML:\n\\`\\`\\`yaml\naction: search/answer\nreason: Explanation\nsearch_term: search phrase if action is search\n\\`\\`\\`\n    `;\n\n    const resp = await callLLM(prompt);\n\n    // Parse YAML from resp (this is example logic; you'd use a real YAML parser)\n    const yamlStr = resp.split(\"```yaml\")[1]?.split(\"```\")[0]?.trim() || \"\";\n    // Assume the structure is { action, reason, search_term? }\n    const parsed = { action: \"search\", reason: \"Need more results\", search_term: \"Nobel Prize 2024\" };\n    // In a real scenario, you'd do something like:\n    // const parsed = yaml.load(yamlStr); // using js-yaml or similar\n\n    if (parsed.action === \"search\" && !parsed.search_term) {\n      throw new Error(\"Missing search_term for 'search' action!\");\n    }\n\n    return parsed;\n  }\n\n  public async post(prepResult: [string, string], execResult: any, sharedState: any): Promise<string> {\n    if (execResult.action === \"search\") {\n      sharedState.search_term = execResult.search_term;\n    }\n    return execResult.action;\n  }\n}\n\nexport class SearchWebNode extends BaseNode {\n  public async prep(sharedState: any): Promise<string> {\n    return sharedState.search_term;\n  }\n\n  public async execCore(searchTerm: string): Promise<string> {\n    return await searchWeb(searchTerm);\n  }\n\n  public async post(prepResult: string, execResult: string, sharedState: any): Promise<string> {\n    const previous = sharedState.context || [];\n    sharedState.context = [...previous, { term: prepResult, result: execResult }];\n\n    // Loop back to the DecideAction node\n    return \"decide\";\n  }\n}\n\nexport class DirectAnswer extends BaseNode {\n  public async prep(sharedState: any): Promise<[string, any]> {\n    return [sharedState.query, sharedState.context ?? \"\"];\n  }\n\n  public async execCore(inputs: [string, any]): Promise<string> {\n    const [query, context] = inputs;\n    const prompt = `Context: ${JSON.stringify(context)}\\nAnswer this query: ${query}`;\n    return await callLLM(prompt);\n  }\n\n  public async post(\n    prepResult: [string, any],\n    execResult: string,\n    sharedState: any\n  ): Promise<string> {\n    console.log(\"Answer:\", execResult);\n    sharedState.answer = execResult;\n    return DEFAULT_ACTION; // or any string that indicates the flow is done\n  }\n}\n\n// Connect nodes\nconst decide = new DecideAction();\nconst search = new SearchWebNode();\nconst answer = new DirectAnswer();\n\ndecide.addSuccessor(search, \"search\");\ndecide.addSuccessor(answer, \"answer\");\nsearch.addSuccessor(decide, \"decide\");  // loop back\n\nconst flow = new Flow(decide);\nflow.run({ query: \"Who won the Nobel Prize in Physics 2024?\" });\n```\n\n----------------------------------------\n\nTITLE: Implementing BatchFlow in TypeScript for Efficient Array Processing\nDESCRIPTION: Example of implementing a BatchFlow that extends a base BatchFlow class. It demonstrates how to process an array of items efficiently, with prep returning the array and execCore processing individual items.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/guide.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BatchFlow } from \"pocket\"; // Assuming a base BatchFlow exists\n\nclass MyBatchFlow extends BatchFlow { // Extend the appropriate BatchFlow base\n  async prep(sharedState: any): Promise<any[]> {\n    // Example: Return an array of items from shared state\n    return sharedState.itemsToProcess || []; \n  }\n\n  // execCore would typically process a single item from the batch\n  async execCore(singleItem: any): Promise<any> {\n    console.log(\"Processing item:\", singleItem);\n    return { processedItem: singleItem * 2 }; // Example processing\n  }\n\n  // post might aggregate results or update state after batch completion\n  async post(prepResult: any, execResult: any, sharedState: any): Promise<string> {\n      // execResult might be an array of results from execCore calls\n      sharedState.batchResults = execResult; \n      return DEFAULT_ACTION;\n  }\n\n  _clone(): BaseNode { return new MyBatchFlow(); } // Adjust as needed\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Processing with BatchFlow\nDESCRIPTION: BatchFlow enables parallel execution of workflows. It extends Flow to process multiple inputs concurrently by creating separate promises for each orchestration and then waiting for all to complete using Promise.all.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nclass BatchFlow extends Flow {\n    async run(sharedState: any): Promise<string> {\n        const prepResultList = await this.prep(sharedState);\n        const resultPromises = [];\n        \n        for (const prepResult of prepResultList) {\n            const result = this.orchestrate(sharedState, prepResult);\n            resultPromises.push(result);\n        }\n        \n        const resultList = await Promise.all(resultPromises);\n        return this.post(prepResultList, resultList, sharedState);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Processing with BatchFlow\nDESCRIPTION: Defines a BatchFlow class that extends Flow to enable parallel processing of multiple items in a workflow.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nclass BatchFlow extends Flow {\n    async prep(sharedState: any): Promise<any[]> {\n        return sharedState.items; // Return array of items to process\n    }\n\n    async post(prepResults: any[], results: any[], sharedState: any): Promise<string> {\n        sharedState.results = results;\n        return DEFAULT_ACTION;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Flows in TypeScript using Pocket Flow Framework\nDESCRIPTION: This example demonstrates how to compose complex workflows using nested flows in the Pocket Flow Framework. It includes sub-flows for data preprocessing and model inference, which are then combined into a main flow.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/apps.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Sub-flow for data preprocessing\nconst preprocessFlow = new Flow(preprocessNode);\npreprocessFlow.addSuccessor(validationNode);\n\n// Sub-flow for model inference\nconst inferenceFlow = new Flow(modelNode);\ninferenceFlow.addSuccessor(postprocessNode);\n\n// Main flow combining sub-flows\npreprocessFlow.addSuccessor(inferenceFlow);\nconst mainFlow = new Flow(preprocessFlow);\n\n// Run the composed flow\nawait mainFlow.run({\n    input: \"Raw data\"\n});\n```\n\n----------------------------------------\n\nTITLE: Chat History Handler for OpenAI LLM in TypeScript\nDESCRIPTION: Implements an enhanced LLM wrapper that supports chat history by accepting an array of messages instead of a single prompt.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/llm.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Configuration, OpenAIApi, ChatCompletionRequestMessage } from \"openai\";\n\nexport async function callLLMWithHistory(messages: ChatCompletionRequestMessage[]): Promise<string> {\n  const config = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n  const openai = new OpenAIApi(config);\n\n  const response = await openai.createChatCompletion({\n    model: \"gpt-4\",\n    messages: messages,\n  });\n\n  return response.data.choices?.[0]?.message?.content ?? \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Multi-Agent Game System in TypeScript\nDESCRIPTION: Implements a word guessing game with two agents (Hinter and Guesser) communicating through queues. The system includes LLM integration, state management, and turn-based gameplay logic. Uses the Pocket Flow Framework for agent coordination and async execution.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/multi_agent.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow } from \"../src/pocket\";\n\n// Placeholder LLM function (replace with real calls as needed)\nasync function callLLM(prompt: string): Promise<string> {\n  // For demonstration\n  return `LLM says: ${prompt.substring(0, 60)}`;\n}\n\n/** \n * AsyncHinter:\n *  1) Waits for a guess from the guesser (via hinterQueue).\n *  2) Generates a new hint while avoiding certain forbidden words.\n *  3) Sends the hint to guesserQueue.\n */\nexport class AsyncHinter extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<{\n    guess: string;\n    target: string;\n    forbidden: string[];\n    pastGuesses: string[];\n  } | null> {\n    // Dequeue guess\n    const hinterQueue = sharedState.hinterQueue as string[];\n    if (!Array.isArray(hinterQueue)) throw new Error(\"hinterQueue not found\");\n\n    if (hinterQueue.length === 0) {\n      return null; // no new guess in queue\n    }\n    const guess = hinterQueue.shift() as string;\n\n    // If guess == \"GAME_OVER\", we can end the Hinter agent\n    if (guess === \"GAME_OVER\") {\n      return null;\n    }\n\n    return {\n      guess,\n      target: sharedState.target_word,\n      forbidden: sharedState.forbidden_words,\n      pastGuesses: sharedState.past_guesses ?? [],\n    };\n  }\n\n  public async execAsync(inputs: {\n    guess: string;\n    target: string;\n    forbidden: string[];\n    pastGuesses: string[];\n  } | null): Promise<string | null> {\n    if (!inputs) {\n      return null; // means we should end\n    }\n    const { guess, target, forbidden, pastGuesses } = inputs;\n\n    // The prompt for generating a hint from the LLM\n    let prompt = `Generate a 1-sentence hint for the word \"${target}\". Avoid these words: ${forbidden.join(\", \")}. `;\n    if (guess !== \"\") {\n      prompt += `Previous guess was: \"${guess}\". `;\n    }\n    if (pastGuesses.length) {\n      prompt += `Past wrong guesses: ${pastGuesses.join(\", \")}. `;\n    }\n    prompt += \"Hint: use at most 5 words.\";\n\n    const hint = await callLLM(prompt);\n    console.log(`\\nHinter: Here's your hint -> ${hint}`);\n    return hint;\n  }\n\n  public async postAsync(\n    sharedState: any,\n    prepResult: {\n      guess: string;\n      target: string;\n      forbidden: string[];\n      pastGuesses: string[];\n    } | null,\n    execResult: string | null\n  ): Promise<string> {\n    // If no inputs or execResult, game is over or no messages left\n    if (!prepResult || execResult === null) {\n      return \"end\"; \n    }\n\n    // Send the generated hint to guesserQueue\n    const guesserQueue = sharedState.guesserQueue as string[];\n    guesserQueue.push(execResult);\n\n    return \"continue\"; \n  }\n}\n\n/** \n * AsyncGuesser:\n *  1) Waits for a hint from guesserQueue.\n *  2) Generates a guess.\n *  3) Checks correctness. If correct, game ends; else adds guess to pastGuesses and re-queues for Hinter.\n */\nexport class AsyncGuesser extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<{\n    hint: string;\n    pastGuesses: string[];\n    target: string;\n  } | null> {\n    const guesserQueue = sharedState.guesserQueue as string[];\n    if (!Array.isArray(guesserQueue)) throw new Error(\"guesserQueue not found\");\n\n    if (guesserQueue.length === 0) {\n      return null;\n    }\n    const hint = guesserQueue.shift() as string;\n    return {\n      hint,\n      pastGuesses: sharedState.past_guesses ?? [],\n      target: sharedState.target_word,\n    };\n  }\n\n  public async execAsync(inputs: {\n    hint: string;\n    pastGuesses: string[];\n    target: string;\n  } | null): Promise<string | null> {\n    if (!inputs) {\n      return null;\n    }\n\n    const { hint, pastGuesses, target } = inputs;\n    let prompt = `We have hint: \"${hint}\". Past wrong guesses: ${pastGuesses.join(\", \")}. Make a new single-word guess:`;\n    // In reality, you'd refine this logic or call an actual LLM\n    const guess = await callLLM(prompt);\n    console.log(`Guesser: I guess it's -> ${guess}`);\n    return guess;\n  }\n\n  public async postAsync(\n    sharedState: any,\n    prepResult: { hint: string; pastGuesses: string[]; target: string } | null,\n    execResult: string | null\n  ): Promise<string> {\n    if (!prepResult || execResult === null) {\n      return \"end\";\n    }\n\n    // Check correctness\n    const guessLower = execResult.trim().toLowerCase();\n    const targetLower = prepResult.target.trim().toLowerCase();\n    if (guessLower === targetLower) {\n      console.log(\"Game Over -> Correct guess!\");\n      // Signal the hinter to stop\n      const hinterQueue = sharedState.hinterQueue as string[];\n      hinterQueue.push(\"GAME_OVER\");\n      return \"end\";\n    }\n\n    // If guess is wrong, add to pastGuesses\n    if (!sharedState.past_guesses) {\n      sharedState.past_guesses = [];\n    }\n    sharedState.past_guesses.push(execResult);\n\n    // Send guess to the Hinter for feedback\n    const hinterQueue = sharedState.hinterQueue as string[];\n    hinterQueue.push(execResult);\n\n    return \"continue\";\n  }\n}\n\n// Example usage\n(async () => {\n  const shared = {\n    target_word: \"nostalgia\",\n    forbidden_words: [\"memory\", \"past\", \"remember\", \"feeling\", \"longing\"],\n    hinterQueue: [] as string[],\n    guesserQueue: [] as string[],\n    past_guesses: [] as string[],\n  };\n\n  console.log(\"Game starting!\");\n  console.log(`Target word: ${shared.target_word}`);\n  console.log(`Forbidden words: ${shared.forbidden_words}`);\n\n  // Initialize by sending an empty guess to Hinter\n  shared.hinterQueue.push(\"\");\n\n  const hinter = new AsyncHinter();\n  const guesser = new AsyncGuesser();\n\n  // In pocket.ts, you might have AsyncFlow (if your BaseNode variants are async).\n  // For demonstration, assume Flow can handle async as well. \n  const hinterFlow = new Flow(hinter);\n  const guesserFlow = new Flow(guesser);\n\n  // Connect each node to itself to allow multiple turns\n  hinter.addSuccessor(hinter, \"continue\");\n  guesser.addSuccessor(guesser, \"continue\");\n\n  // Start both flows concurrently\n  // Typically you'd want a coordination mechanism like Promise.all or a dedicated runner\n  hinterFlow.runAsync(shared).catch((err) => console.error(\"Hinter flow failed:\", err));\n  guesserFlow.runAsync(shared).catch((err) => console.error(\"Guesser flow failed:\", err));\n})();\n```\n\n----------------------------------------\n\nTITLE: Running a Flow with Shared State\nDESCRIPTION: Shows how to run a flow asynchronously with a shared state object.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n  const shared: any = {\n    userName: \"Alice\",\n  };\n\n  await flow.runAsync(shared);\n\n  // After the flow completes, inspect sharedState\n  console.log(\"All done! Final shared state:\", shared);\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncParallelBatchNode for Parallel Text Summarization in TypeScript\nDESCRIPTION: This code demonstrates how to implement an AsyncParallelBatchNode that processes multiple texts in parallel. The node takes an array of texts, summarizes each one concurrently using LLM calls, and then combines the results. This approach can significantly reduce total processing time for I/O-bound operations.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/parallel.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AsyncParallelBatchNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\nimport { callLLM } from \"../path/to/your/llm-wrapper\";\n\nexport class ParallelSummaries extends AsyncParallelBatchNode<string, string> {\n  // prepAsync returns the array of items to process in parallel\n  public async prepAsync(sharedState: any): Promise<string[]> {\n    return sharedState.texts ?? [];\n  }\n\n  // execAsync is called in parallel for each item from prepAsync()\n  public async execAsync(text: string): Promise<string> {\n    const prompt = `Summarize: ${text}`;\n    return await callLLM(prompt); // LLM call\n  }\n\n  // postAsync collects the results into sharedState\n  public async postAsync(\n    sharedState: any,\n    prepResult: string[],\n    execResultList: string[]\n  ): Promise<string> {\n    sharedState.summary = execResultList.join(\"\\n\\n\");\n    return DEFAULT_ACTION; // continue or end flow as needed\n  }\n}\n\n// Example usage:\nconst node = new ParallelSummaries();\nconst flow = new Flow(node);\n\nconst shared: any = {\n  texts: [\n    \"Node.js is a JavaScript runtime built on Chrome's V8 engine.\",\n    \"TypeScript is a typed superset of JavaScript providing better tooling.\",\n    \"Parallel processing can reduce total latency for I/O-bound tasks.\"\n  ],\n};\n\nflow.runAsync(shared).then(() => {\n  console.log(\"All parallel summaries done.\");\n  console.log(\"Combined summary:\", shared.summary);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a GreetNode in TypeScript\nDESCRIPTION: Example of creating a Node class that extends BaseNode with prep, exec, and post methods.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass GreetNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string> {\n    // Suppose we want to greet a user\n    const userName = sharedState.userName ?? \"Guest\";\n    return userName;\n  }\n\n  public async execAsync(userName: string): Promise<string> {\n    return `Hello, ${userName}!`;\n  }\n\n  public async postAsync(\n    sharedState: any,\n    prepResult: string,\n    execResult: string\n  ): Promise<string> {\n    sharedState.greeting = execResult;\n    console.log(\"GreetNode result:\", execResult);\n    return DEFAULT_ACTION; // proceed to next node or end if none\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SummarizeThenVerify AsyncNode with Feedback Loop\nDESCRIPTION: This example demonstrates a complete implementation of an AsyncNode that reads a document, summarizes it using an async LLM call, and awaits user feedback. It shows the full async workflow including prep_async for file reading, exec_async for LLM processing, and post_async for user interaction, along with flow definition and execution.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/async.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass SummarizeThenVerify(AsyncNode):\n    async def prep_async(self, shared):\n        # Example: read a file asynchronously\n        doc_text = await read_file_async(shared[\"doc_path\"])\n        return doc_text\n\n    async def exec_async(self, prep_res):\n        # Example: async LLM call\n        summary = await call_llm_async(f\"Summarize: {prep_res}\")\n        return summary\n\n    async def post_async(self, shared, prep_res, exec_res):\n        # Example: wait for user feedback\n        decision = await gather_user_feedback(exec_res)\n        if decision == \"approve\":\n            shared[\"summary\"] = exec_res\n            return \"approve\"\n        return \"deny\"\n\nsummarize_node = SummarizeThenVerify()\nfinal_node = Finalize()\n\n# Define transitions\nsummarize_node - \"approve\" >> final_node\nsummarize_node - \"deny\"    >> summarize_node  # retry\n\nflow = AsyncFlow(start=summarize_node)\n\nasync def main():\n    shared = {\"doc_path\": \"document.txt\"}\n    await flow.run_async(shared)\n    print(\"Final Summary:\", shared.get(\"summary\"))\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Connecting Nodes in a Flow\nDESCRIPTION: Demonstrates how to create node instances and connect them in a flow using addSuccessor.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass AskFavoriteColorNode extends BaseNode {\n  // ...\n}\n\nclass RespondColorNode extends BaseNode {\n  // ...\n}\n\n// Create instances\nconst greetNode = new GreetNode();\nconst askColorNode = new AskFavoriteColorNode();\nconst respondColorNode = new RespondColorNode();\n\n// Connect\ngreetNode.addSuccessor(askColorNode, DEFAULT_ACTION);\naskColorNode.addSuccessor(respondColorNode, DEFAULT_ACTION);\n\n// Build a Flow that starts with greetNode\nconst flow = new Flow(greetNode);\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Processing Flow with Shared Store in Pocket Flow Framework\nDESCRIPTION: This example demonstrates a complete flow implementation with two nodes that communicate through a shared store. The LoadDataNode populates the shared store with file data, and the SummarizeNode accesses this data to generate a summary using an LLM.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/communication.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Placeholder for an asynchronous LLM call\nasync function callLLM(prompt: string): Promise<string> {\n  // Example implementation\n  return \"This is a summary generated by the LLM.\";\n}\n\nexport class LoadDataNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Simulate reading data from an API or disk\n    sharedState.data[\"my_file.txt\"] = \"Some text content loaded asynchronously.\";\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // No execution needed for loading data\n  }\n\n  public async postAsync(sharedState: any, _: void, __: void): Promise<string> {\n    return DEFAULT_ACTION;\n  }\n}\n\nexport class SummarizeNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string> {\n    // Access data loaded by LoadDataNode\n    return sharedState.data[\"my_file.txt\"] || \"\";\n  }\n\n  public async execAsync(content: string): Promise<string> {\n    const prompt = `Summarize the following content:\\n${content}`;\n    return await callLLM(prompt);\n  }\n\n  public async postAsync(sharedState: any, _: string, execResult: string): Promise<string> {\n    sharedState.summary[\"my_file.txt\"] = execResult;\n    return \"default\";\n  }\n}\n\n// Instantiate nodes\nconst loadData = new LoadDataNode();\nconst summarize = new SummarizeNode();\n\n// Define the flow\nloadData.addSuccessor(summarize, \"default\");\nconst flow = new Flow(loadData);\n\n// Initial shared state\nconst shared = { data: {}, summary: {}, config: {} };\n\n// Run the flow\nflow.runAsync(shared).then(() => {\n  console.log(\"Summary:\", shared.summary[\"my_file.txt\"]);\n}).catch(error => {\n  console.error(\"Flow execution failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Full History Chat Memory in Python\nDESCRIPTION: A basic implementation of a chat node that maintains the complete conversation history. This approach sends the entire chat history to the LLM with each request, which may become inefficient as the conversation grows longer.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/memory.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ChatNode(Node):\n    def prep(self, shared):\n        if \"history\" not in shared:\n            shared[\"history\"] = []\n        user_input = input(\"You: \")\n        return shared[\"history\"], user_input\n\n    def exec(self, inputs):\n        history, user_input = inputs\n        messages = [{\"role\": \"system\", \"content\": \"You are a helpful assistant\"}]\n        for h in history:\n            messages.append(h)\n        messages.append({\"role\": \"user\", \"content\": user_input})\n        response = call_llm(messages)\n        return response\n\n    def post(self, shared, prep_res, exec_res):\n        shared[\"history\"].append({\"role\": \"user\", \"content\": prep_res[1]})\n        shared[\"history\"].append({\"role\": \"assistant\", \"content\": exec_res})\n        return \"continue\"\n\nchat = ChatNode()\nchat - \"continue\" >> chat\nflow = Flow(start=chat)\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Processing with Retry Logic in TypeScript using Pocket Flow Framework\nDESCRIPTION: This snippet shows how to implement retry logic for API calls using the Pocket Flow Framework. The ApiNode extends RetryNode to provide 3 retries with a 1-second interval between attempts. It simulates an API call that might fail and handles the response.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/apps.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass ApiNode extends RetryNode {\n    constructor() {\n        super(3, 1000); // 3 retries, 1 second interval\n    }\n\n    async prep(sharedState: any) {\n        return sharedState.apiEndpoint;\n    }\n\n    async execCore(endpoint: string) {\n        // Simulate API call that might fail\n        const response = await fetch(endpoint);\n        if (!response.ok) throw new Error(\"API call failed\");\n        return response.json();\n    }\n\n    async post(prepResult: any, execResult: any, sharedState: any) {\n        sharedState.apiResponse = execResult;\n        return DEFAULT_ACTION;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cached LLM Wrapper Implementation in TypeScript\nDESCRIPTION: Implements a cached version of the LLM wrapper using lru-cache to avoid repeated identical calls. Includes cache bypass option for retries.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/llm.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport LRU from \"lru-cache\";\nimport { Configuration, OpenAIApi } from \"openai\";\n\nconst llmCache = new LRU<string, string>({ max: 1000 });\n\nexport async function cachedCallLLM(prompt: string, useCache: boolean): Promise<string> {\n  // If caching is enabled and a cached value exists, return it\n  if (useCache && llmCache.has(prompt)) {\n    return llmCache.get(prompt) as string;\n  }\n\n  // Otherwise, call the LLM\n  const config = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n  });\n  const openai = new OpenAIApi(config);\n\n  const response = await openai.createChatCompletion({\n    model: \"gpt-4\",\n    messages: [{ role: \"user\", content: prompt }],\n  });\n\n  const text = response.data.choices?.[0]?.message?.content ?? \"\";\n\n  // Cache the result if desired\n  if (useCache) {\n    llmCache.set(prompt, text);\n  }\n  return text;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a BatchFlow for Multi-File Processing in TypeScript\nDESCRIPTION: Shows how to create a BatchFlow that processes multiple files by repeatedly running a Flow. Includes LoadFile and SummarizeFile nodes to handle individual files, and a SummarizeAllFiles BatchFlow to iterate through all files and collect summaries.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/batch.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, BatchFlow, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Define nodes for processing a single file\nclass LoadFile extends BaseNode {\n    public async prep(sharedState: any): Promise<string> {\n        return sharedState.filename;\n    }\n\n    public async execCore(filename: string): Promise<string> {\n        return await readFile(filename);\n    }\n\n    public async post(prepResult: string, execResult: string, sharedState: any): Promise<string> {\n        sharedState.currentContent = execResult;\n        return \"summarize\";\n    }\n}\n\nclass SummarizeFile extends BaseNode {\n    public async prep(sharedState: any): Promise<string> {\n        return sharedState.currentContent;\n    }\n\n    public async execCore(content: string): Promise<string> {\n        return await callLLM(`Summarize: ${content}`);\n    }\n\n    public async post(prepResult: string, execResult: string, sharedState: any): Promise<string> {\n        sharedState.summaries[sharedState.filename] = execResult;\n        return DEFAULT_ACTION;\n    }\n}\n\n// Build the per-file flow\nconst loadFileNode = new LoadFile();\nconst summarizeFileNode = new SummarizeFile();\n\nloadFileNode.addSuccessor(summarizeFileNode, \"summarize\");\nconst fileFlow = new Flow(loadFileNode);\n\n// Define the BatchFlow that iterates over files\nclass SummarizeAllFiles extends BatchFlow {\n    public async prep(sharedState: any): Promise<{ filename: string }[]> {\n        const filenames = Object.keys(sharedState.data);\n        return filenames.map(fn => ({ filename: fn }));\n    }\n\n    public async post(prepResults: any[], results: any[], sharedState: any): Promise<string> {\n        console.log(\"All files summarized\");\n        return DEFAULT_ACTION;\n    }\n}\n\n// Run the BatchFlow\nconst summarizeAllFiles = new SummarizeAllFiles();\nawait summarizeAllFiles.run({\n    data: {\n        \"file1.txt\": \"Content of file 1...\",\n        \"file2.txt\": \"Content of file 2...\"\n    },\n    summaries: {}\n});\n```\n\n----------------------------------------\n\nTITLE: Prompt Templates for Building Agents with Pocket Flow Framework\nDESCRIPTION: Collection of prompt templates for LLM assistants to help develop agents using the Pocket Flow Framework. Includes prompts for creating a general task-based agent and a specialized research agent.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/batch.md#2025-04-16_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nI want to build an agent that can:\n1. Take a complex task\n2. Break it into subtasks\n3. Execute each subtask\n4. Combine the results\n\nUsing this TypeScript framework:\n\n[paste the pocket.ts code here]\n\nCan you help me create:\n1. A TaskPlannerNode that uses an LLM to break down tasks\n2. A TaskExecutorNode that handles individual subtasks\n3. A ResultCombinerNode that synthesizes results\n4. A Flow that connects these together\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nI want to build a research agent that can:\n1. Take a research question\n2. Search for relevant information\n3. Analyze and synthesize findings\n4. Generate a summary report\n\nUsing this TypeScript framework:\n\n[paste the pocket.ts code here]\n\nCan you help me create:\n1. A SearchNode that finds relevant sources\n2. An AnalysisNode that extracts key information\n3. A SynthesisNode that combines findings\n4. A Flow that orchestrates the research process\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Chat Memory with Vector Search in Python\nDESCRIPTION: An improved chat memory implementation that limits recent history to 8 messages and uses vector search to retrieve relevant past exchanges. This approach creates and maintains a vector index of conversation history to enable semantic retrieval of relevant context.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/memory.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass ChatWithMemory(Node):\n    def prep(self, s):\n        # Initialize shared dict\n        s.setdefault(\"history\", [])\n        s.setdefault(\"memory_index\", None)\n        \n        user_input = input(\"You: \")\n        \n        # Retrieve relevant past if we have enough history and an index\n        relevant = []\n        if len(s[\"history\"]) > 8 and s[\"memory_index\"]:\n            idx, _ = search_index(s[\"memory_index\"], get_embedding(user_input), top_k=2)\n            relevant = [s[\"history\"][i[0]] for i in idx]\n\n        return {\"user_input\": user_input, \"recent\": s[\"history\"][-8:], \"relevant\": relevant}\n\n    def exec(self, c):\n        messages = [{\"role\": \"system\", \"content\": \"You are a helpful assistant.\"}]\n        # Include relevant history if any\n        if c[\"relevant\"]:\n            messages.append({\"role\": \"system\", \"content\": f\"Relevant: {c['relevant']}\"})\n        # Add recent history and the current user input\n        messages += c[\"recent\"] + [{\"role\": \"user\", \"content\": c[\"user_input\"]}]\n        return call_llm(messages)\n\n    def post(self, s, pre, ans):\n        # Update chat history\n        s[\"history\"] += [\n            {\"role\": \"user\", \"content\": pre[\"user_input\"]},\n            {\"role\": \"assistant\", \"content\": ans}\n        ]\n        \n        # When first reaching 8 messages, create index\n        if len(s[\"history\"]) == 8:\n            embeddings = []\n            for i in range(0, 8, 2):\n                e = s[\"history\"][i][\"content\"] + \" \" + s[\"history\"][i+1][\"content\"]\n                embeddings.append(get_embedding(e))\n            s[\"memory_index\"] = create_index(embeddings)\n            \n        # Embed older exchanges once we exceed 8 messages\n        elif len(s[\"history\"]) > 8:\n            pair = s[\"history\"][-10:-8]\n            embedding = get_embedding(pair[0][\"content\"] + \" \" + pair[1][\"content\"])\n            s[\"memory_index\"].add(np.array([embedding]).astype('float32'))\n        \n        print(f\"Assistant: {ans}\")\n        return \"continue\"\n\nchat = ChatWithMemory()\nchat - \"continue\" >> chat\nflow = Flow(start=chat)\nflow.run({})\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Mechanism for Error Handling\nDESCRIPTION: Shows how to implement retry logic for error handling using the RetryNode class with configurable attempts and intervals.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nclass ApiNode extends RetryNode {\n    constructor() {\n        super(3, 1000); // 3 retries, 1 second interval\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Document Processing Pipeline in TypeScript using Pocket Flow Framework\nDESCRIPTION: This snippet demonstrates a document processing pipeline using the Pocket Flow Framework. It includes a DocumentLoaderNode for loading documents and a TextExtractorNode for text extraction. The flow loads a document and extracts its content in lowercase.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/apps.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\nclass DocumentLoaderNode extends BaseNode {\n    async prep(sharedState: any) {\n        return sharedState.documentPath;\n    }\n\n    async execCore(path: string) {\n        // Simulate loading document\n        return { content: \"Sample document content\" };\n    }\n\n    async post(prepResult: any, execResult: any, sharedState: any) {\n        sharedState.document = execResult;\n        return DEFAULT_ACTION;\n    }\n}\n\nclass TextExtractorNode extends BaseNode {\n    async prep(sharedState: any) {\n        return sharedState.document;\n    }\n\n    async execCore(document: any) {\n        return document.content.toLowerCase();\n    }\n\n    async post(prepResult: any, execResult: any, sharedState: any) {\n        sharedState.extractedText = execResult;\n        return DEFAULT_ACTION;\n    }\n}\n\n// Create and connect nodes\nconst loader = new DocumentLoaderNode();\nconst extractor = new TextExtractorNode();\nloader.addSuccessor(extractor);\n\n// Create flow\nconst docFlow = new Flow(loader);\n\n// Run the flow\nawait docFlow.run({\n    documentPath: \"path/to/document.pdf\"\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an UnreliableNode with Retry Logic\nDESCRIPTION: Demonstrates how to create a node with built-in retry logic for handling potential failures.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass UnreliableNode extends BaseNode {\n  constructor() {\n    // e.g., ask for 3 attempts with a 2-second wait\n    super({ maxRetries: 3, wait: 2 });\n  }\n\n  public async execAsync(_: unknown): Promise<string> {\n    if (Math.random() < 0.5) {\n      throw new Error(\"Random failure!\");\n    }\n    return \"Success this time!\";\n  }\n}\n\n// If all retries fail, execFallbackAsync is called, if defined.\n// If fallback is not defined or rethrows, the flow can fail unless you handle it.\n```\n\n----------------------------------------\n\nTITLE: Implementing a BatchNode for Chunk-Based Text Processing in TypeScript\nDESCRIPTION: Demonstrates how to create a MapSummaries node that extends BaseNode to process large text in chunks. The implementation includes prep() to split text into manageable chunks, execCore() to process each chunk individually, and post() to combine results.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/batch.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\nclass MapSummaries extends BaseNode {\n    // The 'prep' method returns chunks to process\n    public async prep(sharedState: any): Promise<string[]> {\n        const content = sharedState.data[\"large_text.txt\"] || \"\";\n        const chunkSize = 10000;\n        const chunks = [];\n        for (let i = 0; i < content.length; i += chunkSize) {\n            chunks.push(content.substring(i, i + chunkSize));\n        }\n        return chunks;\n    }\n\n    // The 'execCore' method processes each chunk\n    public async execCore(chunk: string): Promise<string> {\n        const prompt = `Summarize this chunk in 10 words: ${chunk}`;\n        return await callLLM(prompt);\n    }\n\n    // The 'post' method combines all summaries\n    public async post(prepResult: string[], execResult: string, sharedState: any): Promise<string> {\n        sharedState.summary[\"large_text.txt\"] = execResult;\n        return DEFAULT_ACTION;\n    }\n}\n\n// Create and run the flow\nconst mapSummaries = new MapSummaries();\nconst flow = new Flow(mapSummaries);\n\nawait flow.run({\n    data: {\n        \"large_text.txt\": \"Your very large text content goes here...\"\n    },\n    summary: {}\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Action-Based Transitions in TypeScript\nDESCRIPTION: Demonstrates how to configure node transitions based on action strings, enabling dynamic workflow paths and conditional branching.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Define transitions based on actions\nnodeA.addSuccessor(nodeB, \"success\");\nnodeA.addSuccessor(errorNode, \"error\");\n```\n\n----------------------------------------\n\nTITLE: Complete File Summarization Node Implementation\nDESCRIPTION: Full implementation of a Node that reads file content, processes it with an LLM, and handles results with retry logic and fallback handling.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/node.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, DEFAULT_ACTION } from \"../src/pocket\";\nimport { callLLM } from \"../path/to/your/llm-wrapper\";\n\nexport class SummarizeFile extends BaseNode {\n  // constructor to accept node config (like maxRetries)\n  constructor(private config?: { maxRetries?: number; wait?: number }) {\n    super(config);\n  }\n\n  // prepAsync: read data from sharedState\n  public async prepAsync(sharedState: any): Promise<string> {\n    const filename = this.params[\"filename\"] as string;\n    const fileContent = sharedState.data?.[filename];\n    return fileContent ?? \"\";\n  }\n\n  // execAsync: make the LLM call with the prepared file content\n  public async execAsync(fileContent: string): Promise<string> {\n    if (!fileContent) {\n      throw new Error(\"Empty file content!\");\n    }\n    const prompt = `Summarize this text in ~10 words:\\n${fileContent}`;\n    const summary = await callLLM(prompt); // might fail\n    return summary;\n  }\n\n  // execFallbackAsync: provide a default summary if there's an error\n  public async execFallbackAsync(\n    sharedState: any,\n    prepResult: string,\n    err: Error\n  ): Promise<string> {\n    console.error(\"LLM call failed:\", err);\n    return \"There was an error processing your request.\";\n  }\n\n  // postAsync: store the result in sharedState and return \"default\"\n  public async postAsync(sharedState: any, prepResult: string, execResult: string): Promise<string> {\n    const filename = this.params[\"filename\"] as string;\n    if (!sharedState.summary) {\n      sharedState.summary = {};\n    }\n    sharedState.summary[filename] = execResult;\n    return DEFAULT_ACTION; // or just \"default\"\n  }\n}\n\n// Example usage:\nconst summarizeNode = new SummarizeFile({ maxRetries: 3, wait: 10 });\nsummarizeNode.setParams({ filename: \"test_file.txt\" });\n\n// Prepare a shared state with data\nconst shared: any = {\n  data: {\n    \"test_file.txt\": \"Once upon a time in a faraway land...\",\n  },\n};\n\n// node.runAsync(...) calls prepAsync->execAsync->postAsync\n// If execAsync() fails repeatedly, it calls execFallbackAsync() before postAsync().\nsummarizeNode.runAsync(shared).then((actionReturned) => {\n  console.log(\"Action returned:\", actionReturned);  // Usually \"default\"\n  console.log(\"Summary stored:\", shared.summary?.[\"test_file.txt\"]);\n}).catch((error) => {\n  console.error(\"Node execution error:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Flow Parameters in BaseNode\nDESCRIPTION: Each node can maintain its own parameters through the flow_params property. The setParams method allows for configuration of node-specific parameters during execution.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass BaseNode {\n    public flow_params: any;\n\n    public setParams(params: any): void {\n        this.flow_params = params;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Agent Communication with Shared Queue in TypeScript\nDESCRIPTION: This code snippet demonstrates how to implement agent communication using a queue-like structure in Node.js with TypeScript. It defines an AgentNode class that reads messages from a shared queue, processes them, and loops back to await more messages. The example includes a simple message generator to simulate asynchronous message arrival.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/multi_agent.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// We'll define a simple queue interface\ninterface MessageQueue {\n  messages: string[];\n  // optional signals or a real concurrency approach\n}\n\n// This is our AgentNode, which reads a message from the queue each time it runs.\n// For demonstration, we poll the queue at intervals to simulate asynchronous arrival of messages.\nexport class AgentNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string | null> {\n    const messageQueue: MessageQueue = this.params[\"messages\"] as MessageQueue;\n    if (!messageQueue || !Array.isArray(messageQueue.messages)) {\n      throw new Error(\"Invalid message queue\");\n    }\n\n    // Wait until there's at least one message or return null if no messages are pending\n    if (messageQueue.messages.length === 0) {\n      return null;\n    }\n\n    // Dequeue the first message\n    return messageQueue.messages.shift() || null;\n  }\n\n  public async execAsync(message: string | null): Promise<string | null> {\n    if (message === null) {\n      // No new message\n      return null;\n    }\n\n    // Process or log the message\n    console.log(`Agent received: ${message}`);\n    // You could also call an LLM or do more sophisticated processing here\n    return message;\n  }\n\n  public async postAsync(sharedState: any, prepResult: string | null, execResult: string | null): Promise<string> {\n    // We can continue if there's more work to do; otherwise, we might wait or exit.\n    // For this example, we just loop forever (polling), so we return \"loop\"\n    return \"loop\";\n  }\n}\n\n// Example usage\n(async () => {\n  // Our simulated queue\n  const messageQueue: MessageQueue = {\n    messages: [],\n  };\n\n  // Create the agent node\n  const agent = new AgentNode();\n  // Connect the agent node to itself on the \"loop\" action\n  agent.addSuccessor(agent, \"loop\");\n\n  // Create a flow starting from our agent\n  const flow = new Flow(agent);\n\n  // Set the flow params so the agent node knows about the queue\n  flow.setParams({ messages: messageQueue });\n\n  // We'll also define a simple message generator that appends to the queue periodically\n  setInterval(() => {\n    const timestamp = Date.now();\n    const sampleMessages = [\n      \"System status: all systems operational\",\n      \"Memory usage: normal\",\n      \"Network connectivity: stable\",\n      \"Processing load: optimal\",\n    ];\n    const msg = `${sampleMessages[timestamp % sampleMessages.length]} | timestamp_${timestamp}`;\n    messageQueue.messages.push(msg);\n  }, 1000);\n\n  // Run the flow\n  const shared = {};\n  // Because it loops indefinitely, this flow never truly ends unless we forcibly stop it.\n  // In a real app, you'd have a stopping condition or signal.\n  flow.runAsync(shared).catch((err) => {\n    console.error(\"Flow execution failed:\", err);\n  });\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Prep Method in TypeScript\nDESCRIPTION: This snippet shows the signature of the prep method in a Node, which prepares the node for execution by initializing necessary state or resources.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/core_abstraction.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync prep(sharedState: any): Promise<void> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Branching Flow in TypeScript using Pocket Flow Framework\nDESCRIPTION: This snippet showcases a flow with different paths based on conditions using the Pocket Flow Framework. It includes a ValidationNode that determines the path (valid or invalid) and corresponding handler nodes.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/apps.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass ValidationNode extends BaseNode {\n    async prep(sharedState: any) {\n        return sharedState.data;\n    }\n\n    async execCore(data: any) {\n        return data.isValid;\n    }\n\n    async post(prepResult: any, execResult: any, sharedState: any) {\n        return execResult ? \"valid\" : \"invalid\";\n    }\n}\n\n// Create nodes\nconst validator = new ValidationNode();\nconst successHandler = new SuccessNode();\nconst errorHandler = new ErrorNode();\n\n// Set up branching\nvalidator.addSuccessor(successHandler, \"valid\");\nvalidator.addSuccessor(errorHandler, \"invalid\");\n\n// Create and run flow\nconst flow = new Flow(validator);\nawait flow.run({\n    data: { isValid: true }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Node post Method in TypeScript\nDESCRIPTION: This snippet shows the signature of the post method, which determines the next action to take based on execution results and returns a transition identifier.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/core_abstraction.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync post(prepResult: any, execResult: any, sharedState: any): Promise<string>\n```\n\n----------------------------------------\n\nTITLE: Implementing RetryNode in TypeScript for Automatic Retry Logic\nDESCRIPTION: Example of implementing a RetryNode that extends the base RetryNode class. It includes retry logic for handling potential failures in the execCore method.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/guide.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RetryNode } from \"pocket\";\n\nclass MyRetryNode extends RetryNode {\n  constructor(maxRetries: number = 3, retryIntervalMs: number = 1000) {\n    super(maxRetries, retryIntervalMs);\n  }\n\n  async prep(sharedState: any): Promise<any> { /* ... */ return {}; }\n  async execCore(prepResult: any): Promise<any> { \n    // Example: Simulate potential failure\n    if (Math.random() < 0.5) { throw new Error(\"Simulated failure\"); }\n    return { success: true }; \n  }\n  async post(prepResult: any, execResult: any, sharedState: any): Promise<string> { /* ... */ return DEFAULT_ACTION; }\n  _clone(): BaseNode { return new MyRetryNode(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Flow Construction and Execution Example\nDESCRIPTION: Example showing how to construct a complex flow with nested nodes and flows, including data preparation, validation, feature extraction, model training, and evaluation stages.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/viz.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass DataPrepBatchNode extends BaseNode {\n    async prepAsync(shared: any): Promise<void> { return; }\n}\nclass ValidateDataNode extends BaseNode {}\nclass FeatureExtractionNode extends BaseNode {}\nclass TrainModelNode extends BaseNode {}\nclass EvaluateModelNode extends BaseNode {\n    async prepAsync(shared: any): Promise<void> {\n        const stack = getNodeCallStack();\n        console.log(\"Call stack:\", stack);\n    }\n}\nclass ModelFlow extends Flow {}\nclass DataScienceFlow extends Flow {}\n\n// Build the flow\nconst featureNode = new FeatureExtractionNode();\nconst trainNode = new TrainModelNode();\nconst evaluateNode = new EvaluateModelNode();\n\nfeatureNode.addSuccessor(trainNode, \"default\");\ntrainNode.addSuccessor(evaluateNode, \"default\");\n\nconst modelFlow = new ModelFlow(featureNode);\n\nconst dataPrepNode = new DataPrepBatchNode();\nconst validateNode = new ValidateDataNode();\n\ndataPrepNode.addSuccessor(validateNode, \"default\");\nvalidateNode.addSuccessor(modelFlow, \"default\");\n\nconst dataScienceFlow = new DataScienceFlow(dataPrepNode);\n\n// Run the flow\ndataScienceFlow.run({});\n```\n\n----------------------------------------\n\nTITLE: Creating Execution Wrappers for BaseNode with RetryNode Example\nDESCRIPTION: The framework supports custom execution wrappers for additional functionality. The RetryNode implementation demonstrates how to extend BaseNode with retry capabilities, allowing for automatic retries with configurable intervals.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nclass BaseNode {\n    public execWrapper(prepResult: any): Promise<any> {\n        return this.execCore(prepResult);\n    }\n}\n\n// Example: RetryNode implementation\nabstract class RetryNode extends BaseNode {\n    constructor(maxRetries: number, intervalMs: number) {\n        super();\n        this.maxRetries = maxRetries;\n        this.intervalMs = intervalMs;\n    }\n\n    public async execWrapper(prepResult: any): Promise<any> {\n        for (let i = 0; i < this.maxRetries; i++) {\n            try {\n                return await this.execCore(prepResult);\n            } catch (error) {\n                await new Promise(resolve => setTimeout(resolve, this.intervalMs));\n            }\n        }\n        throw new Error(\"Max retries reached after \" + this.maxRetries + \" attempts\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: OCR for Image-Based PDFs using LLM Vision Capabilities\nDESCRIPTION: A function that uses OpenAI's vision-capable LLM to perform OCR on image-based PDFs. It converts PDF pages to images, encodes them as base64, and sends them to the LLM for text extraction.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom openai import OpenAI\nimport base64\n\ndef call_llm_vision(prompt, image_data):\n    client = OpenAI(api_key=\"YOUR_API_KEY_HERE\")\n    img_base64 = base64.b64encode(image_data).decode('utf-8')\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\n            \"role\": \"user\",\n            \"content\": [\n                {\"type\": \"text\", \"text\": prompt},\n                {\"type\": \"image_url\", \n                 \"image_url\": {\"url\": f\"data:image/png;base64,{img_base64}\"}}\n            ]\n        }]\n    )\n    \n    return response.choices[0].message.content\n\npdf_document = fitz.open(\"document.pdf\")\npage_num = 0\npage = pdf_document[page_num]\npix = page.get_pixmap()\nimg_data = pix.tobytes(\"png\")\n\ncall_llm_vision(\"Extract text from this image\", img_data)\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Transitions in BaseNode\nDESCRIPTION: Nodes connect through action-based transitions using a successors Map. The addSuccessor method connects nodes, while getSuccessor retrieves the next node based on the action name and ensures proper cloning.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/preparation.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nclass BaseNode {\n    public successors: Map<string, BaseNode>;\n\n    public addSuccessor(newSuccessor: BaseNode, action: string = \"default\"): void {\n        if (this.successors.has(action)) {\n            throw new Error(`Action ${action} already exists`);\n        }\n        this.successors.set(action, newSuccessor);\n    }\n\n    public getSuccessor(name: string): BaseNode | undefined {\n        if (!this.successors.has(name)) {\n            return undefined;\n        }\n        return this.successors.get(name)!.clone();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Google Search Integration with SerpAPI in Python\nDESCRIPTION: A function that provides Google search capabilities via the SerpAPI service. It sends the search query to SerpAPI and returns the JSON response containing search results.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef search_google(query):\n    import requests\n    params = {\n        \"engine\": \"google\",\n        \"q\": query,\n        \"api_key\": \"YOUR_API_KEY\"\n    }\n    r = requests.get(\"https://serpapi.com/search\", params=params)\n    return r.json()\n```\n\n----------------------------------------\n\nTITLE: Managing Shared State in Flow Processing\nDESCRIPTION: Shows how nodes can interact with shared state during execution, allowing data to persist and flow through the entire workflow.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Each node can read/write to shared state\nasync post(prepResult: any, execResult: any, sharedState: any): Promise<string> {\n    sharedState.results.push(execResult);\n    return \"default\";\n}\n```\n\n----------------------------------------\n\nTITLE: SQLite Database Operations in Python\nDESCRIPTION: A simple function for executing SQL queries against a SQLite database. It handles connection management and returns query results, with a warning about SQL injection risks.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sqlite3\n\ndef execute_sql(query):\n    conn = sqlite3.connect(\"mydb.db\")\n    cursor = conn.cursor()\n    cursor.execute(query)\n    result = cursor.fetchall()\n    conn.commit()\n    conn.close()\n    return result\n```\n\n----------------------------------------\n\nTITLE: Composing Nested Flows in TypeScript\nDESCRIPTION: Illustrates how to compose complex workflows by nesting flows within larger flows, enabling modular workflow design.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a sub-flow\nconst subFlow = new Flow(startNode);\n\n// Use it in a larger flow\nmainFlow.addSuccessor(subFlow);\n```\n\n----------------------------------------\n\nTITLE: Python Code Execution in Runtime Environment\nDESCRIPTION: A function that executes Python code provided as a string in a controlled environment. It returns the environment dictionary containing any variables defined by the executed code, with a warning about security risks.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef run_code(code_str):\n    env = {}\n    exec(code_str, env)\n    return env\n\nrun_code(\"print('Hello, world!')\")\n```\n\n----------------------------------------\n\nTITLE: Initializing a Shared Store in TypeScript for Pocket Flow Framework\nDESCRIPTION: Demonstrates the basic structure of a shared store object in the Pocket Flow Framework. The shared store serves as a global data structure that all nodes can read from and write to during execution.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/communication.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst shared = { data: {}, summary: {}, config: { /* ... */ } };\n```\n\n----------------------------------------\n\nTITLE: Audio Transcription with OpenAI Whisper in Python\nDESCRIPTION: A function that transcribes audio files using OpenAI's Whisper model. It takes a file path as input, opens the audio file, and returns the transcribed text.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef transcribe_audio(file_path):\n    import openai\n    audio_file = open(file_path, \"rb\")\n    transcript = openai.Audio.transcribe(\"whisper-1\", audio_file)\n    return transcript[\"text\"]\n```\n\n----------------------------------------\n\nTITLE: Using Params for Node Configuration in Pocket Flow Framework\nDESCRIPTION: This example demonstrates how to use params for node-specific configuration in the Pocket Flow Framework. The SummarizeFileNode uses its params to determine which file to process, allowing the same node to be reused for different files.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/communication.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Placeholder for an asynchronous LLM call\nasync function callLLM(prompt: string): Promise<string> {\n  // Example implementation\n  return `Summary for ${prompt}`;\n}\n\nexport class SummarizeFileNode extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<string> {\n    // Access the node's params\n    const filename = this.params[\"filename\"];\n    return sharedState.data[filename] || \"\";\n  }\n\n  public async execAsync(content: string): Promise<string> {\n    const prompt = `Summarize the following content:\\n${content}`;\n    return await callLLM(prompt);\n  }\n\n  public async postAsync(sharedState: any, _: string, execResult: string): Promise<string> {\n    const filename = this.params[\"filename\"];\n    sharedState.summary[filename] = execResult;\n    return DEFAULT_ACTION;\n  }\n}\n\n// Instantiate the node\nconst summarizeFile = new SummarizeFileNode();\n\n// Set Node params directly (for testing)\nsummarizeFile.setParams({ filename: \"doc1.txt\" });\n\n// Define the flow\nconst flow = new Flow(summarizeFile);\n\n// Initial shared state\nconst shared = { data: { \"doc1.txt\": \"Content of document 1.\" }, summary: {} };\n\n// Run the flow\nflow.runAsync(shared).then(() => {\n  console.log(\"Summary:\", shared.summary[\"doc1.txt\"]);\n}).catch(error => {\n  console.error(\"Flow execution failed:\", error);\n});\n\n// Alternatively, set Flow params (overwrites node params)\nconst flowWithParams = new Flow(summarizeFile);\nflowWithParams.setParams({ filename: \"doc2.txt\" });\nflowWithParams.runAsync({ data: { \"doc2.txt\": \"Content of document 2.\" }, summary: {} }).then(() => {\n  console.log(\"Summary:\", shared.summary[\"doc2.txt\"]);\n}).catch(error => {\n  console.error(\"Flow execution failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Configuration Files in YAML\nDESCRIPTION: Example of a YAML-based configuration file structure that defines server settings including host, port, and SSL settings.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/structure.md#2025-04-16_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nserver:\n  host: 127.0.0.1\n  port: 8080\n  ssl: true\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Cloning for Race Condition Prevention\nDESCRIPTION: Shows the implementation of node cloning to prevent race conditions during parallel execution of workflows.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\npublic clone(): BaseNode {\n    const newNode = this._clone();\n    newNode.flow_params = cloneDeep(this.flow_params);\n    newNode.successors = new Map(this.successors);\n    return newNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Product Information in YAML\nDESCRIPTION: Example of structured YAML output for representing product information with name, price, and a multi-line description.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/structure.md#2025-04-16_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nproduct:\n  name: Widget Pro\n  price: 199.99\n  description: |\n    A high-quality widget designed for professionals.\n    Suitable for advanced users.\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Node Sequence Flow in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a simple two-node flow where NodeA transitions to NodeB using the default action. It shows the complete implementation of node classes, flow creation, and execution with error handling.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"../src/pocket\";\n\n// Define NodeA\nclass NodeA extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Preparation logic for NodeA\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execution logic for NodeA\n  }\n\n  public async postAsync(sharedState: any, _: void, __: void): Promise<string> {\n    // Transition to NodeB\n    return \"default\";\n  }\n}\n\n// Define NodeB\nclass NodeB extends BaseNode {\n  public async prepAsync(sharedState: any): Promise<void> {\n    // Preparation logic for NodeB\n  }\n\n  public async execAsync(_: void): Promise<void> {\n    // Execution logic for NodeB\n  }\n\n  public async postAsync(sharedState: any, _: void, __: void): Promise<string> {\n    // No further nodes to transition to\n    return DEFAULT_ACTION;\n  }\n}\n\n// Instantiate nodes\nconst nodeA = new NodeA();\nconst nodeB = new NodeB();\n\n// Define the flow connections\nnodeA.addSuccessor(nodeB, \"default\");\n\n// Create the flow starting with nodeA\nconst flow = new Flow(nodeA);\n\n// Initial shared state\nconst sharedState = {};\n\n// Run the flow\nflow.runAsync(sharedState).then(() => {\n  console.log(\"Flow completed successfully.\");\n}).catch(error => {\n  console.error(\"Flow execution failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Text-to-Speech Conversion with pyttsx3 in Python\nDESCRIPTION: A simple function that converts text to speech using the pyttsx3 library. It initializes a TTS engine, provides the text to be spoken, and triggers the speech synthesis.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef text_to_speech(text):\n    import pyttsx3\n    engine = pyttsx3.init()\n    engine.say(text)\n    engine.runAndWait()\n```\n\n----------------------------------------\n\nTITLE: Implementing execFallbackAsync Method in TypeScript\nDESCRIPTION: Template for implementing graceful error handling in Node execution with fallback logic for handling failures.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/node.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\npublic async execFallbackAsync(\n  sharedState: any,\n  prepResult: any,\n  error: Error\n): Promise<any> {\n  throw error; // Default just rethrows\n}\n```\n\n----------------------------------------\n\nTITLE: Importing pocket-ts in TypeScript\nDESCRIPTION: Import statement for bringing in the necessary components from pocket-ts.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow, DEFAULT_ACTION } from \"pocket-ts\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Node Retries in TypeScript\nDESCRIPTION: Example of configuring retry behavior for a Node instance with maximum retries and wait time between attempts.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/node.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myNode = new SummarizeFile({ maxRetries: 3, wait: 10 });\n```\n\n----------------------------------------\n\nTITLE: Managing Node Parameters in TypeScript\nDESCRIPTION: Demonstrates how to manage node-specific parameters separately from shared state using setParams method.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/paradigm.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass CustomNode extends BaseNode {\n    constructor() {\n        super();\n        this.setParams({ threshold: 0.5 });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Search with Faiss in Python\nDESCRIPTION: Functions for creating and searching a Faiss vector index. The implementation allows for nearest neighbor search of embeddings, which is essential for semantic search and similarity matching tasks.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport faiss\nimport numpy as np\n\ndef create_index(embeddings):\n    dim = len(embeddings[0])\n    index = faiss.IndexFlatL2(dim)\n    index.add(np.array(embeddings).astype('float32'))\n    return index\n\ndef search_index(index, query_embedding, top_k=5):\n    D, I = index.search(\n        np.array([query_embedding]).astype('float32'), \n        top_k\n    )\n    return I, D\n\nindex = create_index(embeddings)\nsearch_index(index, query_embedding)\n```\n\n----------------------------------------\n\nTITLE: Generating Embeddings with OpenAI API in Python\nDESCRIPTION: A function that creates text embeddings using OpenAI's embedding API. It takes a text string as input and returns the embedding vector for use in semantic search or other NLP tasks.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef get_embedding(text):\n    from openai import OpenAI\n    client = OpenAI(api_key=\"YOUR_API_KEY_HERE\")\n    r = client.embeddings.create(\n        model=\"text-embedding-ada-002\",\n        input=text\n    )\n    return r.data[0].embedding\n\nget_embedding(\"What's the meaning of life?\")\n```\n\n----------------------------------------\n\nTITLE: Generating Mermaid Graph Visualization for Flow Nodes\nDESCRIPTION: A recursive function that traverses nested flow graphs and generates Mermaid syntax for visualization. Handles both regular nodes and Flow nodes as subgraphs, assigning unique IDs and creating hierarchical connections.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/viz.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode, Flow } from \"../src/pocket\";\n\nexport function buildMermaid(start: BaseNode | Flow): string {\n    const ids = new Map<any, string>();\n    const visited = new Set<any>();\n    const lines: string[] = [\"graph LR\"];\n    let counter = 1;\n\n    function getId(node: any): string {\n        if (!ids.has(node)) {\n            ids.set(node, `N${counter++}`);\n        }\n        return ids.get(node)!;\n    }\n\n    function link(a: string, b: string): void {\n        lines.push(`    ${a} --> ${b}`);\n    }\n\n    function walk(node: any, parent?: string): void {\n        if (visited.has(node)) {\n            if (parent) link(parent, getId(node));\n            return;\n        }\n        visited.add(node);\n\n        if (node instanceof Flow) {\n            if (node.start && parent) {\n                link(parent, getId(node.start));\n            }\n            lines.push(`\\n    subgraph sub_flow_${getId(node)}[${node.constructor.name}]`);\n            if (node.start) {\n                walk(node.start);\n            }\n            for (const nxt of node.successors.values()) {\n                if (node.start) {\n                    walk(nxt, getId(node.start));\n                } else if (parent) {\n                    link(parent, getId(nxt));\n                } else {\n                    walk(nxt);\n                }\n            }\n            lines.push(\"    end\\n\");\n        } else {\n            const nodeId = getId(node);\n            lines.push(`    ${nodeId}[\"${node.constructor.name}\"]`);\n            if (parent) link(parent, nodeId);\n            for (const nxt of node.successors.values()) {\n                walk(nxt, nodeId);\n            }\n        }\n    }\n\n    walk(start);\n    return lines.join(\"\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Flow Execution Call Stack Tracking\nDESCRIPTION: Utility function that captures the execution call stack of nodes in a flow. Extracts node class names from the stack trace to show the execution path.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/viz.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseNode } from \"../src/pocket\";\n\nexport function getNodeCallStack(): string[] {\n    const stack = new Error().stack?.split(\"\\n\").slice(1) || [];\n    const nodeNames: string[] = [];\n    const seenIds = new Set<number>();\n    \n    for (const line of stack) {\n        const match = line.match(/at (\\w+)\\.(prep|exec|post)/);\n        if (match) {\n            const className = match[1];\n            if (!seenIds.has(nodeNames.length)) {\n                seenIds.add(nodeNames.length);\n                nodeNames.push(className);\n            }\n        }\n    }\n    \n    return nodeNames;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Node execCore Method in TypeScript\nDESCRIPTION: This snippet shows the signature of the execCore method, which contains the main execution logic of a Node.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/core_abstraction.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nasync execCore(prepResult: any): Promise<void> {}\n```\n\n----------------------------------------\n\nTITLE: Implementing a SurveyNode with Multiple Actions\nDESCRIPTION: Example of a node that can return different actions based on user input, allowing for branching flows.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nclass SurveyNode extends BaseNode {\n  public async execAsync(_: unknown): Promise<string> {\n    const userInput = await this.askQuestion(\"Do you like TypeScript? (yes/no)\");\n    return userInput.trim().toLowerCase();\n  }\n\n  public async postAsync(\n    sharedState: any,\n    prepResult: unknown,\n    userResponse: string\n  ): Promise<string> {\n    if (userResponse === \"yes\") {\n      return \"yes_action\";\n    } else {\n      return \"no_action\";\n    }\n  }\n\n  private async askQuestion(question: string): Promise<string> {\n    // minimal prompt for demonstration\n    // replace with a real I/O method, or an LLM prompt\n    return Promise.resolve(\"yes\"); \n  }\n}\n\n// Usage:\n//     surveyNode.addSuccessor(yesNode, \"yes_action\");\n//     surveyNode.addSuccessor(noNode, \"no_action\");\n```\n\n----------------------------------------\n\nTITLE: Logging-enabled LLM Wrapper in TypeScript\nDESCRIPTION: Implements a wrapper function with logging capabilities to track prompts and responses using console logging.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/llm.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function callLLMWithLogging(prompt: string): Promise<string> {\n  console.info(`Prompt: ${prompt}`);\n  // ...Perform the call as shown above\n  // Example:\n  const reply = await callLLM(prompt);\n  console.info(`Response: ${reply}`);\n  return reply;\n}\n```\n\n----------------------------------------\n\nTITLE: PDF Text Extraction with PyMuPDF in Python\nDESCRIPTION: A function that extracts text content from PDF files using PyMuPDF (fitz). It handles text-based PDFs and processes them page by page to extract all text content.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport fitz  # PyMuPDF\n\ndef extract_text(pdf_path):\n    doc = fitz.open(pdf_path)\n    text = \"\"\n    for page in doc:\n        text += page.get_text()\n    doc.close()\n    return text\n\nextract_text(\"document.pdf\")\n```\n\n----------------------------------------\n\nTITLE: Web Crawling with Requests and BeautifulSoup in Python\nDESCRIPTION: A simple web crawling function that fetches a webpage's content and extracts its title and text. It uses requests to fetch HTML and BeautifulSoup for parsing the content.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef crawl_web(url):\n    import requests\n    from bs4 import BeautifulSoup\n    html = requests.get(url).text\n    soup = BeautifulSoup(html, \"html.parser\")\n    return soup.title.string, soup.get_text()\n```\n\n----------------------------------------\n\nTITLE: Creating Bullet Point Summaries in YAML\nDESCRIPTION: YAML template for representing document summaries as bullet points, useful for quick information extraction from longer content.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/structure.md#2025-04-16_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nsummary:\n  - This product is easy to use.\n  - It is cost-effective.\n  - Suitable for novices and experts alike.\n```\n\n----------------------------------------\n\nTITLE: Visualizing Flow Diagram with Mermaid\nDESCRIPTION: A Mermaid flowchart diagram visualizing the expense approval process flow with three possible paths: approval leading to payment, revision requiring changes, or rejection ending the process.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    reviewExpense[Review Expense] -->|approved| payment[Process Payment]\n    reviewExpense -->|needs_revision| reviseExpense[Revise Report]\n    reviewExpense -->|rejected| finish[Finish Process]\n\n    reviseExpense --> reviewExpense\n    payment --> finish\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram Visualization using Mermaid\nDESCRIPTION: Visualizes the nested flow structure including payment, inventory, shipping, and logging/notification flows using Mermaid flowchart syntax. Shows the relationships and transitions between different components of the order processing system.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/flow.md#2025-04-16_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    subgraph orderProcessingFlow[\"Order Processing Flow\"]\n        subgraph paymentFlow[\"Payment Flow\"]\n            A[Validate Payment] -->|process_payment| B[Process Payment]\n            B -->|payment_confirmation| C[Payment Confirmation]\n            A -->|reject_payment| D[Handle Rejection]\n        end\n\n        subgraph inventoryFlow[\"Inventory Flow\"]\n            E[Check Stock] -->|reserve_items| F[Reserve Items]\n            F -->|update_inventory| G[Update Inventory]\n            E -->|out_of_stock| H[Handle Out of Stock]\n        end\n\n        subgraph shippingFlow[\"Shipping Flow\"]\n            I[Create Label] -->|assign_carrier| J[Assign Carrier]\n            J -->|schedule_pickup| K[Schedule Pickup]\n        end\n\n        subgraph loggingFlow[\"Logging & Notification Flow\"]\n            L[Logging] -->|default| M[Notification]\n        end\n\n        paymentFlow --> inventoryFlow\n        inventoryFlow --> shippingFlow\n        shippingFlow --> loggingFlow\n    end\n```\n\n----------------------------------------\n\nTITLE: Generated Mermaid Flow Visualization\nDESCRIPTION: Example Mermaid graph output showing the hierarchical structure of the constructed flow with nested subgraphs and node connections.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/viz.md#2025-04-16_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    subgraph sub_flow_N1[DataScienceFlow]\n    N2[\"DataPrepBatchNode\"]\n    N3[\"ValidateDataNode\"]\n    N2 --> N3\n    N3 --> N4\n\n    subgraph sub_flow_N5[ModelFlow]\n    N4[\"FeatureExtractionNode\"]\n    N6[\"TrainModelNode\"]\n    N4 --> N6\n    N7[\"EvaluateModelNode\"]\n    N6 --> N7\n    end\n\n    end\n```\n\n----------------------------------------\n\nTITLE: Sending Emails with SMTP in Python\nDESCRIPTION: A function for sending emails via SMTP using Python's built-in email libraries. It creates an email message with the specified subject, body, and addresses, then sends it through Gmail's SMTP server.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/tool.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef send_email(to_address, subject, body, from_address, password):\n    import smtplib\n    from email.mime.text import MIMEText\n\n    msg = MIMEText(body)\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = from_address\n    msg[\"To\"] = to_address\n\n    with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n        server.login(from_address, password)\n        server.sendmail(from_address, [to_address], msg.as_string())\n```\n\n----------------------------------------\n\nTITLE: Installing pocket-ts via npm\nDESCRIPTION: Command to install the pocket-ts package using npm.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/docs/usage.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install pocket-ts\n```\n\n----------------------------------------\n\nTITLE: Installing Pocketflow Framework via Git Clone\nDESCRIPTION: Commands to clone the Pocketflow Framework repository and navigate to the project directory. This is the first step in getting started with the framework.\nSOURCE: https://github.com/The-Pocket-World/Pocket-Flow-Framework/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/The-Pocket-World/Pocket-Flow-Framework.git # Or your specific repo URL if different\ncd Pocket-Flow-Framework\n```"
  }
]