[
  {
    "owner": "louthy",
    "repo": "language-ext",
    "content": "TITLE: IO Effect Types in LanguageExt.Core\nDESCRIPTION: Defines the core effect types for handling synchronous and asynchronous side-effects in functional programming. Includes IO<A> for basic effects, Eff<A> for error handling, and Eff<RT, A> for dependency injection.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIO<A>      // Synchronous and asynchronous side-effect monad\nEff<A>     // Side-effect with error handling\nEff<RT, A> // Side-effect with injectable runtime\n```\n\n----------------------------------------\n\nTITLE: Importing Language-Ext Prelude Namespace\nDESCRIPTION: Shows how to import the Prelude static class which provides fundamental functional programming constructs. This import should be added to every code file or global usings to make all Prelude functions available locally.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing static LanguageExt.Prelude;\n```\n\n----------------------------------------\n\nTITLE: Atomic Types in LanguageExt.Core\nDESCRIPTION: Defines atomic reference types for concurrent programming, including basic atomic references, atomic collections, and vector clocks for distributed systems.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nAtom<A>                          // Lock-free atomic reference\nRef<A>                           // Transactional memory reference\nAtomHashMap<K, V>                // Atomic immutable HashMap\nAtomSeq<A>                       // Atomic immutable Seq\nVectorClock<A>                   // Distributed causality clock\nVersionVector<A>                 // Versioned vector clock\nVersionHashMap<ConflictV, K, V> // Distributed versioned HashMap\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Usings for Language-Ext in C#\nDESCRIPTION: Full set of global using directives to import all key Language-Ext functionality into scope. Includes core types, prelude functions, traits, effects, pipes, and pretty printing capabilities.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nglobal using LanguageExt;\nglobal using LanguageExt.Common;\nglobal using static LanguageExt.Prelude;\nglobal using LanguageExt.Traits;\nglobal using LanguageExt.Effects;\nglobal using LanguageExt.Pipes;\nglobal using LanguageExt.Pretty;\nglobal using LanguageExt.Traits.Domain;\n```\n\n----------------------------------------\n\nTITLE: Implementing Domain Value Types for Name, Age, and Email in C#\nDESCRIPTION: This code snippet demonstrates the creation of domain value types for Name, Age, and Email using the language-ext library. It includes validation logic, error handling, and example usage of these custom types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Domain/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing LanguageExt;\nusing static LanguageExt.Prelude;\nusing System.Text.RegularExpressions;\n\npublic readonly record struct Name\n{\n    public string Value { get; }\n\n    private Name(string value) => Value = value;\n\n    public static Validation<Error, Name> Create(string value) =>\n        string.IsNullOrWhiteSpace(value)\n            ? Error.New(\"Name cannot be empty\")\n            : new Name(value);\n}\n\npublic readonly record struct Age\n{\n    public int Value { get; }\n\n    private Age(int value) => Value = value;\n\n    public static Validation<Error, Age> Create(int value) =>\n        value < 0 || value > 150\n            ? Error.New(\"Age must be between 0 and 150\")\n            : new Age(value);\n}\n\npublic readonly record struct Email\n{\n    public string Value { get; }\n\n    private Email(string value) => Value = value;\n\n    public static Validation<Error, Email> Create(string value) =>\n        string.IsNullOrWhiteSpace(value)\n            ? Error.New(\"Email cannot be empty\")\n            : !Regex.IsMatch(value, @\"^(.+)@(.+)$\")\n                ? Error.New(\"Invalid email format\")\n                : new Email(value);\n}\n\npublic record Person(\n    Name Name,\n    Age Age,\n    Email Email\n);\n\n// Usage\nvar personV =\n    from name in Name.Create(\"John Doe\")\n    from age in Age.Create(30)\n    from email in Email.Create(\"john@example.com\")\n    select new Person(name, age, email);\n\npersonV.Match(\n    Succ: person => Console.WriteLine($\"Created person: {person}\"),\n    Fail: errors => Console.WriteLine($\"Errors: {errors}\")\n);\n```\n\n----------------------------------------\n\nTITLE: Language-Ext Type Construction Examples in C#\nDESCRIPTION: Shows how to construct various Language-Ext types using constructor functions rather than new keyword. Demonstrates Options, Sequences, Lists, and Maps.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nOption<int> x = Some(123);\nOption<int> y = None;\nSeq<int> items = Seq(1,2,3,4,5);\nList<int> items = List(1,2,3,4,5);\nHashMap<int, string> dict = HashMap((1, \"Hello\"), (2, \"World\"));\nMap<int, string> dict = Map((1, \"Hello\"), (2, \"World\"));\n```\n\n----------------------------------------\n\nTITLE: Immutable Collection Types Overview\nDESCRIPTION: Core immutable collection types including arrays, lists, maps, sets, queues and stacks with various constraints and implementations\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nArr<A>              // Immutable array\nSeq<A>              // Lazy immutable list\nIterable<A>         // IEnumerable wrapper with traits\nLst<A>              // Immutable list\nMap<K,V>            // Immutable map\nHashMap<K,V>        // Immutable hash-map\nSet<A>              // Immutable set\nHashSet<A>          // Immutable hash-set\nQue<A>              // Immutable queue\nStck<A>             // Immutable stack\n```\n\n----------------------------------------\n\nTITLE: Core Traits Table Structure in Markdown\nDESCRIPTION: Markdown table defining core traits of the language-ext library, including MonoidK, Applicative, Eq, and other fundamental functional programming concepts. Each entry includes the trait location, name, and description with links to detailed documentation.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                                | Description                                                                                                                                                            |\n|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `MonoidK<F>`                       | [A monoid on applicative functors](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Alternative/index.html)                                               |\n| `Core`   | `Applicative<F>`                       | [Applicative functor](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Applicative/index.html)                                                            |\n```\n\n----------------------------------------\n\nTITLE: Optional and Alternative Value Monads Overview\nDESCRIPTION: Core monad types for handling optional values, error cases, and validations including transformers\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nOption<A>                      // Option monad\nOptionT<M,A>                  // Option monad-transformer\nEither<L,R>                   // Right/Left choice monad\nEitherT<L,M,R>               // Choice monad-transformer\nFin<A>                        // Error handling monad\nFinT<M,A>                    // Error handling transformer\nTry<A>                        // Exception handling monad\nTryT<M,A>                    // Exception handling transformer\nValidation<FAIL,SUCCESS>     // Validation applicative/monad\nValidationT<FAIL,M,SUCCESS> // Validation transformer\n```\n\n----------------------------------------\n\nTITLE: Using guard for conditional validation in monadic expressions\nDESCRIPTION: This example demonstrates how to use the guard function to conditionally halt a monadic expression when a condition is not met, returning an error value. The guard checks if x equals 100 and returns an error if not.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Monadic conditionals/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfrom x in ma\nfrom _ in guard(x == 100, Error.New(\"x should be 100\"))\nselect x;\n```\n\n----------------------------------------\n\nTITLE: Core Traits Table in Markdown\nDESCRIPTION: Markdown table documenting core traits in language-ext, including their location, feature names and descriptions. Covers fundamental functional programming concepts like Monad, Functor, Applicative, and other utility traits.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                                | Description                                                                                                                                                            |\n|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `MonoidK<F>`                       | [A monoid on applicative functors](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Alternative/index.html)                                               |\n| `Core`   | `Applicative<F>`                       | [Applicative functor](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Applicative/index.html)                                                            |\n```\n\n----------------------------------------\n\nTITLE: Using Atoms for Atomic State Management in C#\nDESCRIPTION: This example demonstrates how to create and use Atoms to manage shared state. It shows creating an Atom with an immutable record, atomically modifying it with Swap, and taking a snapshot of the current state using the Value property.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Concurrency/Atom/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrecord Person(string Name, string Surname);\n\n// Create a new atom\nvar person = Atom(new Person(\"Paul\", \"Louth\"));\n\n// Modify it atomically\nperson.Swap(p => p with { Surname = $\"{p.Name}y\" });\n\n// Take a snapshot of the state of the atom \nvar snapshot = p.Value;\n```\n\n----------------------------------------\n\nTITLE: Effect Monad Implementation in C#\nDESCRIPTION: Implements Eff<A> and Eff<RT, A> types for handling side-effects with error handling and dependency injection support\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nEff<A>\nEff<RT, A>\n```\n\n----------------------------------------\n\nTITLE: Core Monad Types Overview\nDESCRIPTION: Summary of core monad types available in Language-Ext including Option, Either, Try, and Validation monads with their transformer variants\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nCore:\n- Option<A>\n- OptionT<M, A>\n- Either<L,R>\n- EitherT<L, M, R>\n- Fin<A>\n- FinT<M, A>\n- Try<A>\n- TryT<M, A>\n- Validation<FAIL, SUCCESS>\n- ValidationT<FAIL, M, SUCCESS>\n```\n\n----------------------------------------\n\nTITLE: Optional and Alternative Value Monads Overview\nDESCRIPTION: Documentation of core monadic types for handling optional values, error cases, and validation scenarios. Includes Option, Either, Fin, Try, and Validation monads along with their transformer variants.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature | Description |\n|----------|---------------------------------|----------|\n| `Core` | `Option<A>` | Option monad |\n| `Core` | `OptionT<M, A>` | Option monad-transformer |\n```\n\n----------------------------------------\n\nTITLE: Parser Combinators Overview\nDESCRIPTION: Parser monad implementations for string parsing and generic input stream parsing\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nParsec:\n- Parser<A>\n- Parser<I, O>\n```\n\n----------------------------------------\n\nTITLE: Immutable Collection Types in LanguageExt.Core\nDESCRIPTION: Defines various immutable collection types including arrays, lists, maps, sets, queues, and stacks. Each collection type provides specific guarantees around immutability and performance characteristics.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nArr<A>             // Immutable array\nSeq<A>             // Lazy immutable list\nIterable<A>        // IEnumerable wrapper\nLst<A>             // Immutable list\nMap<K, V>          // Immutable map\nMap<OrdK, K, V>    // Ordered immutable map\nHashMap<K, V>      // Immutable hash-map\nHashMap<EqK, K, V> // Equality-constrained hash-map\nSet<A>             // Immutable set\nSet<OrdA, A>       // Ordered immutable set\nHashSet<A>         // Immutable hash-set\nHashSet<EqA, A>    // Equality-constrained hash-set\nQue<A>             // Immutable queue\nStck<A>            // Immutable stack\n```\n\n----------------------------------------\n\nTITLE: Creating an Expected Error in C#\nDESCRIPTION: Demonstrates how to create a simple expected error with a message. Expected errors are non-exceptional and represent situations that might normally occur during program execution.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nError.New(\"This error was expected\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Option Types in C#\nDESCRIPTION: Demonstrates basic initialization of Option<A> types using the Some() constructor and None value. Shows how to create optional values in a type-safe manner.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/Option/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nOption<int> ma = Some(123);\nOption<int> mb = None;\n```\n\n----------------------------------------\n\nTITLE: Parser Combinators Implementation\nDESCRIPTION: Parser monad implementations for string parsing and generic input stream parsing with full combinator library support.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nParser<A>     // String parser monad\nParser<I, O>  // Generic input stream parser monad\n```\n\n----------------------------------------\n\nTITLE: State Management Monads Overview\nDESCRIPTION: Core state management monads including Reader, Writer, and State monads and their transformer variants. These provide functional approaches to handling state and environment in C#.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nReader<E, A>      // Reader monad\nReaderT<E, M, A>  // Reader monad-transformer\nWriter<W, A>      // Writer monad with Monoid constraint\nWriterT<W, M, A>  // Writer monad-transformer\nState<S, A>       // State monad\nStateT<S, M, A>   // State monad-transformer\n```\n\n----------------------------------------\n\nTITLE: Sequence Method with Either Monad for Error Collection in C#\nDESCRIPTION: Example of using Sequence with Either monad to collect the first error encountered. When transforming a List<Either<string, int>> to Either<string, List<int>>, the first Left value encountered becomes the result, otherwise all Right values are collected.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_44\n\nLANGUAGE: c#\nCODE:\n```\n    var x = List<Either<string, int>>(1, 2, 3, 4, \"error\");\n\n    var y = x.Sequence();\n\n    Assert.True(y.IsLeft && y == \"error\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Either Monad with Explicit Types\nDESCRIPTION: Demonstrates creation of Either monad instances using explicit generic type parameters for both Left and Right values.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/Either/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nEither<string, int> ma = Left<string, int>(\"this is an error\");\nEither<string, int> mb = Right<string, int>(123);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Expected Error Type in C#\nDESCRIPTION: Shows how to extend the Error system by creating a custom record that inherits from Expected. This allows for creating domain-specific error types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic record BespokeError(bool MyData) \n    : Expected(\"Something bespoke\", 100, None);\n```\n\n----------------------------------------\n\nTITLE: Atomic Concurrency Types Overview\nDESCRIPTION: Core atomic concurrency types including Atom<A>, Ref<A>, AtomHashMap<K,V>, AtomSeq<A>, VectorClock<A>, VersionVector<A>, and VersionHashMap for thread-safe operations\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nAtom<A>              // Lock-free atomically mutable reference\nRef<A>               // Atomic reference for transactional memory\nAtomHashMap<K,V>      // Atomic immutable HashMap\nAtomSeq<A>           // Atomic immutable Seq\nVectorClock<A>        // Distributed causality tracking\nVersionVector<A>      // Vector clock with versioned data\nVersionHashMap<ConflictV,K,V> // Distributed atomic versioning\n```\n\n----------------------------------------\n\nTITLE: Composing Pipes Components in C#\nDESCRIPTION: Demonstrates how to compose ProducerT, PipeT, and ConsumerT components using the '|' operator to create an EffectT that can be run.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Streaming/Pipes/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nProducerT<string, M, A> readLine = // ...\\nPipeT<string, int, M, A> parseInt = // ...\\nConsumerT<int, M, A> writeLine = // ...\\n\\nEffectT<M, A> effect = readLine | parseInt | writeLine;\\nvar result = effect.Run();\n```\n\n----------------------------------------\n\nTITLE: Function Style vs Fluent Style in Language-Ext\nDESCRIPTION: Demonstrates the difference between using functional style (camelCase) and fluent style (PascalCase) method calls in Language-Ext.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar x = map(opt, v => v * 2);\nvar x = opt.Map(v => v * 2);\n```\n\n----------------------------------------\n\nTITLE: Using Lock-free AtomHashSet for Thread-safe Operations in C#\nDESCRIPTION: Shows the simplified approach using the AtomHashSet class for lock-free atomic operations. This eliminates the need for explicit locks while maintaining thread safety.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Concurrency/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic AtomHashSet<int> set = AtomHashSet(1, 2, 3);\nset.Add(4);\n```\n\n----------------------------------------\n\nTITLE: Initializing Immutable Collections in Language-Ext\nDESCRIPTION: Examples of how to construct different immutable collection types using the Prelude constructor functions. Shows initialization of HashMap, HashSet, Map, Set, Seq, and Lst collections with sample data.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nHashMap<string, int> hashSet = HashMap((\"a\", 1), (\"b\", 2), (\"c\", 3));\nHashSet<int> hashMap         = HashSet(1, 2, 3);\nMap<string, int> hashSet     = Map((\"a\", 1), (\"b\", 2), (\"c\", 3));\nSet<int> hashMap             = Set(1, 2, 3);\nSeq<int> list                = Seq(1, 2, 3);\nLst<int> list                = List(1, 2, 3);\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Fold Operator with Iterator<A> in C#\nDESCRIPTION: Demonstrates using the built-in Fold operator on Iterator<A> to implement a Sum function. This approach uses the functional Fold operation to accumulate values from the iterator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter.Fold(A.Zero, (s, x) => s + x);\n```\n\n----------------------------------------\n\nTITLE: Monad Interface Implementation\nDESCRIPTION: Generic Monad interface implementation with bind, return, and fail operations using type constraints.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_39\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Monad<MA, A>\n{\n    MB Bind<MonadB, MB, B>(MA ma, Func<B, MB> bind) \n        where MonadB : struct, Monad<MB, B>;\n\n    MA Return(A a);\n    MA Fail(Exception e = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Value Traits in Language-Ext Core\nDESCRIPTION: Code representation of the core value traits including DomainType, Identifier, VectorSpace, Amount, and Locus. Each trait provides specific semantic meaning and operators for underlying values.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                              | Description                                                                                                                                                                                                                       |\n|----------|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `DomainType<SELF, REPR>`             | Provides a mapping from `SELF` to an underlying representation: `REPR`                                                                                                                                                                            |\n| `Core`   | `Identifier <SELF>`                  | Identifiers (like IDs in databases: `PersonId` for example), they are equivalent to `DomaintType` with equality.                                                                                                                                  |\n| `Core`   | `VectorSpace<SELF, SCALAR>`          | Scalable values; can add and subtract self, but can only multiply and divide by a scalar. Can also negate.                                                                                                                                        |\n| `Core`   | `Amount <SELF, SCALAR>`              | Quantities, such as the amount of money in USD on a bank account or a file size in bytes. Derives `VectorSpace`, `IdentifierLike`, `DomainType`, and is orderable (comparable).                                                                   |\n| `Core`   | `Locus <SELF, DISTANCE, SCALAR>`     | Works with space-like structures. Spaces have absolute and relative distances. Has an origin/zero point and derives `DomainType`, `IdentifierLike`, `AmountLike` and `VectorSpace`.  `DISTANCE` must also be an `AmountLike<SELF, REPR, SCALAR>`. |\n```\n\n----------------------------------------\n\nTITLE: State Managing Monads Documentation\nDESCRIPTION: Overview of monads for managing state and environment, including Reader, Writer, and State monads with their transformer variants. These provide functional approaches to handling state and side effects.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature | Description |\n|----------|----------------|-------------|\n| `Core` | `Reader<E, A>` | Reader monad |\n| `Core` | `Writer<W, A>` | Writer monad |\n```\n\n----------------------------------------\n\nTITLE: Running IO Operations\nDESCRIPTION: Demonstrates how to execute an IO operation that returns a concrete result instead of a Task-wrapped result, while still maintaining concurrent execution.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nSeq<string> result = operation.Run();\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Container in C#\nDESCRIPTION: Example showing how to wrap existing types with a monoidal container by implementing Monoid<T>. This demonstrates the new approach to creating monoid implementations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_16\n\nLANGUAGE: c#\nCODE:\n```\npublic readonly record struct MEnumerable<A>(IEnumerable<A> Items) : \n    Monoid<MEnumerable<A>>\n{\n    public MEnumerable<A> Append(MEnumerable<A> rhs) =>\n        new(Items.Concat(rhs.Items));\n\n    public static MEnumerable<A> Empty =>\n        new(Enumerable.Empty<A>());\n}\n```\n\n----------------------------------------\n\nTITLE: Using IL.Ctor for Fast Constructor Delegates in C#\nDESCRIPTION: Example of IL.Ctor utility that creates delegates for invoking constructors without reflection. The generated delegate performs as fast as a direct constructor call by emitting IL code directly. This example creates a delegate for DateTime constructor.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_47\n\nLANGUAGE: c#\nCODE:\n```\n    var ticks = new DateTime(2017, 1, 1).Ticks;\n\n    // Builds a delegate to call new DateTime(long);\n    var ctor = IL.Ctor<long, DateTime>();\n\n    DateTime res = ctor(ticks);\n\n    Assert.True(res.Ticks == ticks);\n```\n\n----------------------------------------\n\nTITLE: Markdown Table: Optional and Alternative Value Monads\nDESCRIPTION: Table documenting optional and alternative value monads including Option, Either, Fin, Try and Validation types along with their monad transformers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                         | Description                                                                                                                                                                              |\n|----------|---------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `Option<A>`                     | [Option monad]                                                                                    |\n| `Core`   | `OptionT<M, A>`                 | [Option monad-transformer]                                                                       |\n| `Core`   | `Either<L,R>`                   | [Right/Left choice monad]                                                                         |\n| `Core`   | `EitherT<L, M, R>`              | [Right/Left choice monad-transformer]                                                            |\n| `Core`   | `Fin<A>`                        | [`Error` handling monad, like `Either<Error, A>`]                                                    |\n| `Core`   | `FinT<M, A>`                    | [`Error` handling monad-transformer]                                                                |\n| `Core`   | `Try<A>`                        | [Exception handling monad]                                                                           |\n| `Core`   | `TryT<M, A>`                    | [Exception handling monad-transformer]                                                              |\n| `Core`   | `Validation<FAIL ,SUCCESS>`     | [Validation applicative and monad] for collecting multiple errors before aborting an operation |\n| `Core`   | `ValidationT<FAIL, M, SUCCESS>` | [Validation applicative and monad-transformer]\n```\n\n----------------------------------------\n\nTITLE: Creating an Exceptional Error from an Exception in C#\nDESCRIPTION: Demonstrates how to wrap an exception within an Error object. This is useful for capturing unexpected errors while maintaining the structured Error type system.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n    // This wraps up the exceptional error\n}\ncatch(Exception e)\n{\n    return Error.New(e);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Serializable Custom Error Type in C#\nDESCRIPTION: Demonstrates how to create a custom error type with serializable properties using the DataMember attribute. This allows error data to be preserved when sending errors over the wire.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic record BespokeError([property: DataMember] bool MyData) \n    : Expected(\"Something bespoke\", 100, None);\n```\n\n----------------------------------------\n\nTITLE: Testing Choice Implementation with ChoiceLaw\nDESCRIPTION: Code examples demonstrating the core laws that any Choice implementation must satisfy, including Pure and Fail cases. Shows how Choice handles propagation of success and failure states.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Choice/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nchoose(Pure(a),   Pure(b))  = Pure(a)\nchoose(Fail,      Pure(b))  = Pure(b)\nchoose(Pure(a),   Fail)     = Pure(a)\nchoose(Fail [1],  Fail [2]) = Fail [2]\n```\n\n----------------------------------------\n\nTITLE: Initializing Case-Insensitive String Set in C#\nDESCRIPTION: Demonstrates creating a type-safe set of strings with case-insensitive comparison using Set<TStringOrdinalIgnoreCase, string>\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar map = Set<TStringOrdinalIgnoreCase, string>(...)\n```\n\n----------------------------------------\n\nTITLE: Value Traits Overview\nDESCRIPTION: Specialized traits for domain modeling that provide semantic meaning and common operators for underlying values, similar to NewType pattern.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nDomainType<SELF, REPR>         - Maps SELF to underlying representation REPR\nIdentifier<SELF>              - For database-like IDs with equality\nVectorSpace<SELF, SCALAR>      - For scalable values with add/subtract/multiply operations\nAmount<SELF, SCALAR>          - For quantities like money or file size\nLocusLike<SELF, SCALAR, DISTANCE> - For space-like structures with absolute/relative distances\n```\n\n----------------------------------------\n\nTITLE: Comparing Fluent vs Static Function Approaches in C#\nDESCRIPTION: Illustrates the difference between using fluent methods on types versus using static functions from Prelude. Both approaches accomplish the same task of folding a sequence to calculate the sum.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Prelude/README.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar items = Seq(1, 2, 3);\n    \n// Fluent version\nvar sum = items.Fold(0, (s, x) => s + x);\n    \n// Prelude static function\nvar sum = fold(items, 0, (s, x) => s + x);\n```\n\n----------------------------------------\n\nTITLE: TryAsync Implementation Examples in C#\nDESCRIPTION: Shows usage of TryAsync type for handling asynchronous operations with error handling and parallel execution support.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_24\n\nLANGUAGE: c#\nCODE:\n```\nTryAsync<int> LongRunningOp() => TryAsync(() => 10);\n\n    int x = await LongRunningOp().Match(\n                Succ: y  => y * 2,\n                Fail: ex => 0\n                );\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<int> CombineAndOrder(Lst<int> x, Lst<int> y) =>\n    from item in (x + y)\n    orderby item\n    select item;\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequence Matching in C#\nDESCRIPTION: Demonstrates the new Seq-based matching functionality for sequence operations, replacing the previous IEnumerable matching system.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\n        static int Sum(Seq<int> seq) =>\n            seq.Match(\n                ()      => 0,\n                x       => x,\n                (x, xs) => x + Sum(xs));\n```\n\n----------------------------------------\n\nTITLE: Using when for conditional operations in monadic expressions\nDESCRIPTION: This example shows how to use the when function to conditionally execute a side effect when a condition is met. When x equals 100, it writes a message to the console using the Eff monad.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Monadic conditionals/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfrom x in ma\nfrom _ in when(x == 100, Console.writeLine<RT>(\"x is 100, finally!\"))\nselect x;\n```\n\n----------------------------------------\n\nTITLE: Sequence Method for Flipping Inner and Outer Monadic Types in C#\nDESCRIPTION: Example of the Sequence method which transforms a list of options (Lst<Option<int>>) into an option of list (Option<Lst<int>>). The transformation follows the inner monad's rules, so a None value anywhere in the list results in a final None result.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_42\n\nLANGUAGE: c#\nCODE:\n```\n    Lst<Option<int>> x = List(Some(1), Some(2), Some(3), Some(4), Some(5));\n    Option<Lst<int>> y = x.Sequence();\n\n    Assert.True(y == Some(List(1, 2, 3, 4, 5)));\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Option Patterns\nDESCRIPTION: Demonstrates lazy evaluation patterns with Option<A> type, showing both lazy and strict behaviors with LINQ syntax.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_15\n\nLANGUAGE: c#\nCODE:\n```\n    var option = from w in Some(_ => 5)\n                 from x in Some(_ => 10)\n                 from y in Some(_ => 15)\n                 from z in Some(_ => 20)\n                 select w + x + y + z;\n\n    // At this point the w + x + y + z expression hasn't run\n```\n\n----------------------------------------\n\nTITLE: Traverse Method for Parallel Task Execution in C#\nDESCRIPTION: Example of using Traverse to transform a list of tasks into a single task of list. This enables parallel execution of tasks with the results collected into a single list once all tasks are complete. The mapping function doubles each value during the transformation.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_45\n\nLANGUAGE: c#\nCODE:\n```\n    var start = DateTime.UtcNow;\n\n    var f1 = Task.Run(() => { Thread.Sleep(3000); return 1; });\n    var f2 = Task.Run(() => { Thread.Sleep(3000); return 2; });\n    var f3 = Task.Run(() => { Thread.Sleep(3000); return 3; });\n    var f4 = Task.Run(() => { Thread.Sleep(3000); return 4; });\n    var f5 = Task.Run(() => { Thread.Sleep(3000); return 5; });\n    var f6 = Task.Run(() => { Thread.Sleep(3000); return 6; });\n\n    var res = await List(f1, f2, f3, f4, f5, f6).Traverse(x => x * 2);\n\n    Assert.True(toSet(res) == Set(2, 4, 6, 8, 10, 12));\n\n    var ms = (int)(DateTime.UtcNow - start).TotalMilliseconds;\n    Assert.True(ms < 3500, $\"Took {ms} ticks\");\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Iterator<A> in C#\nDESCRIPTION: Demonstrates how to use pattern matching with Iterator<A> like a functional 'cons' linked-list to implement a Sum function. This approach leverages C# pattern matching to handle empty and non-empty iterators.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter switch\n    {\n        Iterator<A>.Nil                 => A.Zero,\n        Iterator<A>.Cons(var x, var xs) => x + Sum(xs),\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Addable Interface for MyList and MyString in C#\nDESCRIPTION: This snippet demonstrates the implementation of the Addable interface for two different types: MyList and MyString. Each type provides its own implementation of the static Add method, showcasing how the trait-like behavior can be customized for different data structures.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/README.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic record MyList<A>(A[] values) : Addable<MyList<A>>\n{\n    public static MyList<A> Add(MyList<A> x, MyList<A> y) =>\n        new (x.values.Append(y.values).ToArray());\n}\n\npublic record MyString(string value) : Addable<MyString>\n{\n    public static MyString Add(MyString x, MyString y) =>\n        new (x.value + y.value);\n}\n```\n\n----------------------------------------\n\nTITLE: Memory-Efficient Iteration with Clone in C#\nDESCRIPTION: Demonstrates using the Clone method to create a separate reference to the iterator, allowing memory to be reclaimed during iteration. This approach works around the memory issues of the previous example.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar start = Naturals.GetIterator();\nfor(var iter = start.Clone(); !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Expected Error with Status Code in C#\nDESCRIPTION: Shows how to create an expected error with both a status code and message. When using codes, equality and matching is performed using the code only.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nError.New(404, \"Page not found\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Forked Operations in C#\nDESCRIPTION: Demonstrates how to implement parallel operations using Fork() and Await. The code shows how to queue work to run on the next available ThreadPool thread while maintaining concurrency.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar forkedOperation = from f in operation.Fork() // runs in parallel\n                      from r in f.Await\t\t     // use the ForkIO to await the result\n\t\t\t          select r;\n\n// This will yield the current thread to allow concurrency, whilst the forked\n// operation runs on another thread.\nvar result = forkedOperation.Run();\n```\n\n----------------------------------------\n\nTITLE: Core Traits Overview\nDESCRIPTION: Core traits for functional programming in C# including monads, functors, and applicatives. These form the foundation for generic programming with higher-kinds.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nMonoidK<F>        - A monoid on applicative functors\nApplicative<F>    - Applicative functor\nEq<A>             - Ad-hoc equality trait\nFallible<F>       - Trait that describes types that can fail\nFoldable<T>       - Aggregation over a structure\nFunctor<F>        - Functor Map\nHas<M, TRAIT>     - Used in runtimes to enable DI-like capabilities\nMonad<M>          - Monad trait\nMonadT<M, N>      - Monad transformer trait\n```\n\n----------------------------------------\n\nTITLE: Minimal Global Usings for Language-Ext in C#\nDESCRIPTION: Minimal set of global using directives for basic Language-Ext functionality, importing just the core namespace and prelude functions.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nglobal using LanguageExt;\nglobal using static LanguageExt.Prelude;\n```\n\n----------------------------------------\n\nTITLE: Initializing Either Monad with Implicit Types\nDESCRIPTION: Shows simplified Either monad creation using implicit type casting, where the compiler infers the generic types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/Either/README.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nEither<string, int> ma = Left(\"this is an error\");\nEither<string, int> mb = Right(123);\n```\n\n----------------------------------------\n\nTITLE: Proper Memory Management with Iterator<A> in C#\nDESCRIPTION: Shows a loop that properly manages memory when iterating through a potentially infinite sequence. By updating the iterator in-place, unreferenced items can be garbage collected.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nfor(var iter = Naturals.GetIterator(); !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: File Reading Operation with IO Lifting\nDESCRIPTION: Shows how to lift an asynchronous file reading operation into an IO monad using liftIO. The operation reads text from a file and splits it into lines while handling cancellation tokens.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar operation = from text in liftIO(env => File.ReadAllTextAsync(path, env.Token))\n                let lines = text.Split(\"\\r\\n\").ToSeq()\n                select lines;\n```\n\n----------------------------------------\n\nTITLE: Non-Empty List Product Function in C#\nDESCRIPTION: Shows how to enforce non-empty list constraint through type system when calculating product of integers\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic int Product(Lst<NonEmpty, int> list) =>\n    list.Fold(1, (s, x) => s * x);\n```\n\n----------------------------------------\n\nTITLE: Sequence Method with None Value in List in C#\nDESCRIPTION: Example showing how Sequence handles a None value in a list of Options. When transforming Lst<Option<int>> to Option<Lst<int>>, a single None in the source list causes the entire result to be None according to Option monad rules.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_43\n\nLANGUAGE: c#\nCODE:\n```\n    Lst<Option<int>> x = List(Some(1), Some(2), Some(3), None, Some(5));\n    Option<Lst<int>> y = x.Sequence();\n\n    Assert.True(y == None);\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Fold Operator with Iterator<A> in C#\nDESCRIPTION: Demonstrates using the built-in Fold operator to process an Iterator<A> sequence. This concise approach leverages higher-order functions to accumulate values from the sequence.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter.Fold(A.Zero, (s, x) => s + x);\n```\n\n----------------------------------------\n\nTITLE: Creating an Option Type in C#\nDESCRIPTION: Demonstrates how to create an Option type with Some value using the Prelude constructor. This creates an Option containing the integer value 100.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Prelude/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nOption<int> mx = Some(100);\n```\n\n----------------------------------------\n\nTITLE: IO Monad Implementation in C#\nDESCRIPTION: Defines IO<A> type for handling synchronous and asynchronous side-effects in a pure functional way\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIO<A>\n```\n\n----------------------------------------\n\nTITLE: Generic Monad Addition Function\nDESCRIPTION: Example of a generic function that adds two monadic values with numeric constraints.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_40\n\nLANGUAGE: c#\nCODE:\n```\npublic static MA Add<MonadA, MA, NumA, A>(MA ma, MA mb)\n    where MonadA  : struct, Monad<MA, A>\n    where NumA    : struct, Num<A> =>\n        default(MonadA).Bind<MonadA, MA, A>(ma, a =>\n        default(MonadA).Bind<MonadA, MA, A>(mb, b =>\n        default(MonadA).Return(default(NumA).Plus(a, b))));\n```\n\n----------------------------------------\n\nTITLE: Implementing Option Type with Kind Interface\nDESCRIPTION: Example of how Option<A> implements the K<F,A> interface to support higher-kinded polymorphism.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic readonly struct Option<A> :\n    K<Option, A>\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Transformer Extension Methods for Nested Monads in C#\nDESCRIPTION: Extension methods available for nested monad types like Arr<Lst<A>>, providing operations such as SumT, CountT, BindT, Traverse, and MapT. These methods simplify working with nested monadic structures without dealing with the complexity of the fully generic implementation.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_41\n\nLANGUAGE: c#\nCODE:\n```\nA SumT<NumA, A>(this Arr<Lst<A>> ma);\n\nint CountT<A>(this Arr<Lst<A>> ma);\n\nArr<Lst<B>> BindT<A, B>(this Arr<Lst<A>> ma, Func<A, Lst<B>> f);\n\nLst<Arr<B>> Traverse<A, B>(this Arr<Lst<A>> ma, Func<A, B> f);\n\nLst<Arr<A>> Sequence<A>(this Arr<Lst<A>> ma);\n\nArr<Lst<B>> MapT<A, B>(this Arr<Lst<A>> ma, Func<A, B> f);\n\nS FoldT<S, A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f);\n\nS FoldBackT<S, A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f);\n\nbool ExistsT<A>(this Arr<Lst<A>> ma, Func<A, bool> f);\n\nbool ForAllT<A>(this Arr<Lst<A>> ma, Func<A, bool> f);\n\nUnit IterT<A>(this Arr<Lst<A>> ma, Action<A> f);\n\nArr<Lst<A>> FilterT< A>(this Arr<Lst<A>> ma, Func<A, bool> pred);\n\nArr<Lst<A>> Where<A>(this Arr<Lst<A>> ma, Func<A, bool> pred);\n\nArr<Lst<A>> Select<A, B>(this Arr<Lst<A>> ma, Func<A, B> f);\n\nArr<Lst<C>> SelectMany<A, B, C>(\n        this Arr<Lst<A>> ma,\n        Func<A, Lst<B>> bind,\n        Func<A, B, C> project);\n\nArr<Lst<A>> PlusT<NUM, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A>;\n\nArr<Lst<A>> SubtractT<NUM, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A>;\n\nArr<Lst<A>> ProductT<NUM, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>\n        ApplyT(default(NUM).Product, x, y);\n\nArr<Lst<A>> DivideT<NUM, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A>;\n\nAppendT<SEMI, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where SEMI : struct, Semigroup<A>;\n\nint CompareT<ORD, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where ORD : struct, Ord<A>;\n\nbool EqualsT<EQ, A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where EQ : struct, Eq<A>;\n\nArr<Lst<A>> ApplyT<A, B>(this Func<A, B> fab, Arr<Lst<A>> fa);\n\nArr<Lst<C>> ApplyT<A, B, C>(this Func<A, B, C> fabc, Arr<Lst<A>> fa, Arr<Lst<A>> fb);\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoid Helper Functions\nDESCRIPTION: Static helper methods in TypeClass for working with Monoids, including mempty for getting identity values and mconcat for combining multiple values.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_35\n\nLANGUAGE: c#\nCODE:\n```\npublic static partial class TypeClass\n{\n    public static A mempty<MONOID, A>() where MONOID : struct, Monoid<A> =>\n        default(MONOID).Empty();\n\n    public static A mconcat<MONOID, A>(IEnumerable<A> xs) where MONOID : struct, Monoid<A> =>\n        xs.Fold(mempty<MONOID, A>(), (s, x) => append<MONOID, A>(s, x));\n\n    public static A mconcat<MONOID, A>(params A[] xs) where MONOID : struct, Monoid<A> =>\n        xs.Fold(mempty<MONOID, A>(), (s, x) => append<MONOID, A>(s, x));\n}\n```\n\n----------------------------------------\n\nTITLE: Writer Monad Implementation\nDESCRIPTION: Generic Writer monad implementation that uses a Monoid constraint for the log type.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_37\n\nLANGUAGE: c#\nCODE:\n```\npublic class Writer<MonoidW, W, A> where MonoidW : struct, Monoid<W>\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Static Monad Transformer Classes in C#\nDESCRIPTION: Example of using the static OptionT transformer class for operations on nested monads where Option is the inner monad. Static methods like foldT, sumT, and filterT provide functionality without requiring extension methods.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_46\n\nLANGUAGE: c#\nCODE:\n```\n    var ma = List(Some(1),Some(2),Some(3),Some(4),Some(5));\n\n    var total = OptionT.foldT(ma, 0, (s, x) => s + x); // 15\n    var total = OptionT.sumT<TInt, int>(ma); // 15\n    var mb    = OptionT.filterT(ma, x > 3); // List(Some(3), Some(4))\n```\n\n----------------------------------------\n\nTITLE: Sequence to Traverse Migration Examples\nDESCRIPTION: Examples showing how to migrate from the old Sequence method to the new Traverse method with proper type conversion.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_19\n\nLANGUAGE: c#\nCODE:\n```\n// Before:\nvar results = Seq(1,2,3).Sequence(x => x % 2 == 0 : Some(x) : None);\n\n// After:\nvar results = Seq(1,2,3).Traverse(x => x % 2 == 0 : Some(x) : None).As();\n```\n\n----------------------------------------\n\nTITLE: Cond Type Implementation in C#\nDESCRIPTION: Examples of using the Cond type for building conditional expressions with fluent syntax and async support.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_22\n\nLANGUAGE: c#\nCODE:\n```\nvar cond = Cond<int>(x => x == 4)\n               .Then(true)\n               .Else(false);\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar vowels = Subj<char>().Map(Char.ToLower)\n                             .Any(x => x == 'a', x => x == 'e', x => x == 'i', x => x == 'o', x => x == 'u')\n                             .Then(\"Is a vowel\")\n                             .Else(\"Is a consonant\");\n```\n\n----------------------------------------\n\nTITLE: Semigroup Type Class Definition\nDESCRIPTION: Definition of the Semigroup<A> type class interface for associative binary operations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_33\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Semigroup<A>\n{\n    A Append(A x, A y);\n}\n```\n\n----------------------------------------\n\nTITLE: Option Map Implementation\nDESCRIPTION: Implementation of the Map function for Option type showing type casting pattern.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\npublic class Option :\n\tMonad<Option>, \n\tTraversable<Option>, \n\tAlternative<Option>\n{\n\t// ...\n\n\tpublic static K<Option, B> Map<A, B>(Func<A, B> f, K<Option, A> ma) => \n\t    ma.As().Map(f);\n\n\t// ...\n\n}\n```\n\n----------------------------------------\n\nTITLE: Function Application with Map and Apply in C#\nDESCRIPTION: Example showing the updated approach to function application using Map instead of Apply for the first argument, demonstrating the change in applicative functor patterns.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_17\n\nLANGUAGE: c#\nCODE:\n```\nFunc<string, string, string> surround = \n\t(str, before, after) => $\"{before} {str} {after}\";\n\nvar mx = Some(\"Paul\");\nvar my = Some(\"Mr.\");\nvar mz = Some(\"Louth\");\n\nsurround.Map(mx).Apply(my).Apply(mz);\n```\n\n----------------------------------------\n\nTITLE: Equality Type Class Definition\nDESCRIPTION: Definition of the Eq<A> type class interface for equality operations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_30\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Eq<A>\n{\n    bool Equals(A x, A y);\n    int GetHashCode(A x);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Nullable<int> to Option<int> in C#\nDESCRIPTION: Demonstrates how to convert from a nullable int to an Option<int> using the ToOption() extension method. This is an example of a natural transformation function provided by the language-ext library.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/Nullable/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint? x = ...\nOption<int> mx = x.ToOption();\n```\n\n----------------------------------------\n\nTITLE: Creating a Sequence in C#\nDESCRIPTION: Shows how to create a Seq type with initial values using the Prelude constructor. This creates a sequence containing the integers 1, 2, and 3.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Prelude/README.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSeq<int> mx = Seq(1, 2, 3);\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection of Errors with Error.Many in C#\nDESCRIPTION: Shows how to create a ManyErrors instance that contains multiple error objects. This allows for collecting and returning multiple errors at once rather than failing on the first error.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nError.Many(Error.New(\"error one\"), Error.New(\"error two\"));\n```\n\n----------------------------------------\n\nTITLE: Option Class Trait Implementation\nDESCRIPTION: Shows how the Option class implements multiple traits like Monad, Traversable, and Alternative.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\npublic class Option : \n\tMonad<Option>, \n\tTraversable<Option>, \n\tAlternative<Option>\n{\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using a NewType Class in C#\nDESCRIPTION: Example of implementing a custom type (Metres) using the NewType class and using its factory function. NewType provides a way to create strongly-typed wrappers around primitive types with clean syntax for instantiation.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_49\n\nLANGUAGE: c#\nCODE:\n```\n   class Metres : NewType<Metres, float> \n   { \n       public Metres(float x) : base(x) {} \n   }\n\n   var ms = Metres.New(100);\n```\n\n----------------------------------------\n\nTITLE: Functor Interface Definition\nDESCRIPTION: Definition of the Functor trait interface with static abstract Map method using K type.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Functor<F>  \n    where F : Functor<F>\n{\n    public static abstract K<F, B> Map<A, B>(Func<A, B> f, K<F, A> ma);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Functor with Multiple Types\nDESCRIPTION: Examples of using the AddOne function with different functor types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\nK<Option, int> mx = AddOne(Option<int>.Some(10));\nK<Seq, int>    my = AddOne(Seq<int>(1, 2, 3, 4));\nK<Fin, int>    mz = AddOne(Fin<int>.Succ(123));\n```\n\n----------------------------------------\n\nTITLE: Natural Isomorphism Type Structure Example in C#\nDESCRIPTION: Demonstrates the forward and backward mappings possible in a natural isomorphism between types F and G.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Natural/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nF〈A〉-> G〈A〉\n```\n\nLANGUAGE: C#\nCODE:\n```\nG〈A〉-> F〈A〉\n```\n\n----------------------------------------\n\nTITLE: Imperative Approach with Iterator<A> in C#\nDESCRIPTION: Illustrates an imperative approach to processing an Iterator<A> using a while loop. This method updates the iterator in-place, allowing for efficient garbage collection as the sequence is processed.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber\n{\n    var total = A.Zero;\n    while(!iter.IsEmpty)\n    {\n        total += iter.Head;\n        iter = iter.Tail;\n    }\n    return total;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Alternative Implementation with AlternativeLaw in C#\nDESCRIPTION: This code snippet demonstrates the expected behavior of the Alternative trait's Choose method using the AlternativeLaw. It shows the four key cases that should be satisfied by any implementation of Alternative.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Alternative/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nchoose(Pure(a), Pure(b)) = Pure(a)\nchoose(Empty  , Pure(b)) = Pure(b)\nchoose(Pure(a), Empty  ) = Pure(a)\nchoose(Empty  , Empty  ) = Empty\n```\n\n----------------------------------------\n\nTITLE: Atomic Reference Implementation in C#\nDESCRIPTION: Defines Atom<A> and Ref<A> types for lock-free atomic operations and transactional memory system\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nAtom<A>\nRef<A>\n```\n\n----------------------------------------\n\nTITLE: Differencing and Patch Operations\nDESCRIPTION: Implementation for calculating differences between collections and applying patches, similar to git diff functionality.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nPatch<EqA, A>  // Patch calculation and application type\n```\n\n----------------------------------------\n\nTITLE: Monoid Usage Examples\nDESCRIPTION: Practical examples of using monoid operations with different types like strings, lists, and integers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_36\n\nLANGUAGE: c#\nCODE:\n```\nvar x = mconcat<TString, string>(\"Hello\", \" \", \"World\");   // \"Hello World\"\nvar y = mconcat<TLst<int>, Lst<int>>(List(1), List(2, 3)); // [1,2,3]\nvar z = mconcat<TInt, int>(1, 2, 3, 4, 5);                 // 15\n```\n\n----------------------------------------\n\nTITLE: Range Type Implementation in C#\nDESCRIPTION: Demonstrates the generic Range type implementation with example of IntegerRange definition.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_23\n\nLANGUAGE: c#\nCODE:\n```\npublic class Range<SELF, MonoidOrdA, A> : IEnumerable<A>\n        where SELF : Range<SELF, MonoidOrdA, A>\n        where MonoidOrdA : struct, Monoid<A>, Ord<A>, Arithmetic<A>\n    {\n        ...\n    }\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic class IntegerRange : Range<IntegerRange, TInt, int>\n    {\n        IntegerRange(int min, int max, int step) : base(min, max, step) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Numeric Addition in C#\nDESCRIPTION: Example showing why traditional interface-based numeric operations in C# can lead to boxing issues. This demonstrates a problematic approach that the library aims to solve using traits and ad-hoc polymorphism.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Class Instances/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nINumeric Add(INumeric x, INumeric y) => x + y;\n```\n\n----------------------------------------\n\nTITLE: Defining NewType with Generic Arguments\nDESCRIPTION: Shows the updated NewType implementation with additional generic arguments for improved type safety.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_16\n\nLANGUAGE: c#\nCODE:\n```\n    class Metres : NewType<double> { ... }\n```\n\nLANGUAGE: c#\nCODE:\n```\n    class Metres : NewType<Metres, double>  { ... } \n```\n\n----------------------------------------\n\nTITLE: Constructing Seq<A> from Different Collection Types\nDESCRIPTION: Shows different ways to create Seq<A> instances from various collection types including List, Array, and direct construction.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\n    var seq1 = Seq(List(1, 2, 3, 4, 5));    // Lst<A> -> Seq<A>\n    var seq2 = Seq(Arr(1, 2, 3, 4, 5));     // Arr<A> -> Seq<A>\n    var seq3 = Seq(new [] {1, 2, 3, 4, 5}); // A[] -> Seq<A>\n```\n\n----------------------------------------\n\nTITLE: Protecting Immutable Updates with Traditional Locks in C#\nDESCRIPTION: Demonstrates how to use traditional locking to safely update an immutable HashSet in a multi-threaded environment. This approach requires explicit lock management around state mutations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Concurrency/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Some global\nstatic HashSet<int> set = HashSet(1, 2, 3);\nstatic object sync = new();\n\nlock(sync)\n{\n    set = set.Add(4);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Kind Type Interface in C#\nDESCRIPTION: Base interface definition for higher-kinded types using generic parameters F and A.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic interface K<F, A>\n```\n\n----------------------------------------\n\nTITLE: Migration Example for Traverse Operations\nDESCRIPTION: Shows before and after code examples for migrating from the removed Traverse method to using Sequence and Map combination.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_22\n\nLANGUAGE: c#\nCODE:\n```\nvar results = Seq(Some(1), Some(2), None).Traverse(x => x * 2);\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar results = Seq(Some(1), Some(2), None).Sequence().Map(x => x * 2).As();\n```\n\n----------------------------------------\n\nTITLE: IL.Ctor Usage in NewType for Factory Functions in C#\nDESCRIPTION: Implementation of the NewType abstract class using IL.Ctor to build a strongly-typed factory function. This technique allows creation of a constructor delegate for a generic type parameter that couldn't otherwise be instantiated directly from the base class.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_48\n\nLANGUAGE: c#\nCODE:\n```\n    public abstract class NewType<NEWTYPE, A, PRED> :\n        IEquatable<NEWTYPE>,\n        IComparable<NEWTYPE>\n        where PRED    : struct, Pred<A>\n        where NEWTYPE : NewType<NEWTYPE, A, PRED>\n    {\n        protected readonly A Value;\n\n        /// <summary>\n        /// Constructor function\n        /// </summary>\n        public static readonly Func<A, NEWTYPE> New = IL.Ctor<A, NEWTYPE>();\n\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Generic Functor Usage Example\nDESCRIPTION: Example of using Functor constraint to create a generic AddOne function.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\npublic static K<F, int> AddOne<F>(K<F, int> mx) where F : Functor<F> =>\n\tF.Map(x => x + 1, mx);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Type in C#\nDESCRIPTION: Shows the basic tuple type syntax representing an integer AND string combination.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n(int, string)\n```\n\n----------------------------------------\n\nTITLE: Naive Functor Interface Implementation\nDESCRIPTION: Demonstrates a problematic attempt at implementing functors using interfaces, showing why this approach doesn't work well for higher-kinded types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\ninterface Functor<A>\n{\n    Functor<B> Map<B>(Func<A, B> f);\n}\n\npublic class Option<A> : Functor<A>\n{\n    // ...    \n}\npublic class Seq<A> : Functor<A>\n{\n    // ...    \n}\n```\n\n----------------------------------------\n\nTITLE: Higher-Kind Type Pattern Implementation\nDESCRIPTION: Implementation pattern for simulating higher-kind types in C# using generic constraints and type parameters.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_38\n\nLANGUAGE: c#\nCODE:\n```\npublic interface MyType<MA, A>\n{\n    MB Foo<MB, B>(MA ma);\n}\n\npublic class MyOptionType<A> : MyType<Option<A>, A>\n{\n    public MB Foo<MB, B>(Option<A> ma) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Validated String NewType\nDESCRIPTION: Example of NewType with embedded validation using predicates for string length constraints.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_17\n\nLANGUAGE: c#\nCODE:\n```\n    public class ClientConnectionId : NewType<ClientConnectionId, string, StrLen<I10, I100>>\n    {\n        public ClientConnectionId(string value) : base(value)\n        { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Direct Seq<A> Construction Methods\nDESCRIPTION: Demonstrates direct construction of Seq<A> using the Seq constructor and Cons method.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\n    var seq1 = Seq(1, 2, 3, 4, 5);\n\n    var seq2 = 1.Cons(2.Cons(3.Cons(4.Cons(5.Cons(Empty)))));\n```\n\n----------------------------------------\n\nTITLE: Value Traits Table in Markdown\nDESCRIPTION: Table documenting value traits in language-ext including DomainType, Identifier, VectorSpace, Amount, and LocusLike. Each trait is listed with its location and detailed functional description.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.FSharp/README.nuget.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                              | Description                                                                                                                                                                                                                                       |\n|----------|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `DomainType<SELF, REPR>`             | Provides a mapping from `SELF` to an underlying representation: `REPR`                                                                                                                                                                            |\n```\n\n----------------------------------------\n\nTITLE: Numeric Type Class Definition\nDESCRIPTION: Definition of the Num<A> type class interface for generic numeric operations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_26\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Num<A>\n{\n    A Add(A x, A b);\n    A Subtract(A x, A b);\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using IsEmpty and Head Properties with Iterator<A> in C#\nDESCRIPTION: Shows how to use the IsEmpty property and Head/Tail accessors to process an Iterator<A> in a recursive manner. This approach explicitly checks for emptiness instead of using pattern matching.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter.IsEmpty\n        ? A.Zero\n        : iter.Head + Sum(iter.Tail);\n```\n\n----------------------------------------\n\nTITLE: Resolving HashSet Ambiguity in C#\nDESCRIPTION: Example of using namespace aliases to resolve ambiguity between System.Collections.Generic.HashSet and LanguageExt.HashSet.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/version-2-migration-notes.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n    using G = System.Collections.Generic;\n\n    var hs = new G.HashSet<int>();\n```\n\n----------------------------------------\n\nTITLE: Updating Activity Handling in LanguageExt.Sys\nDESCRIPTION: Code transformation example showing the change from using a use/startActivity pattern to a more functional from/select approach for activity handling.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/Migration War Stories/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nuse(startActivity(name, activityKind, activityTags, activityLinks, startTime),\n\tact => localEff<RT, RT, TA>(rt => rt.SetActivity(act.Activity), operation));\n```\n\nLANGUAGE: csharp\nCODE:\n```\nfrom a in startActivity(name, activityKind, activityTags, activityLinks, startTime)\nfrom r in localEff<RT, RT, TA>(rt => rt.WithActivity(a), operation)\nselect r;\n```\n\n----------------------------------------\n\nTITLE: SourceT Effect Lifting Methods in C#\nDESCRIPTION: Static methods available on SourceT for lifting various effect types into streams.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Streaming/README.nuget.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nSourceT.liftM(IO<A> effect)\nSourceT.foreverM(IO<A> effect)\nSourceT.liftM(Channel<IO<A>> channel)\nSourceT.liftM(IEnumerable<IO<A>> effects)\nSourceT.liftM(IAsyncEnumerable<IO<A>> effects)\n```\n\n----------------------------------------\n\nTITLE: Stream Type Declarations in C#\nDESCRIPTION: Demonstrates the core type signatures for closed stream components in the Pipes system, including ProducerT, PipeT, and ConsumerT monad transformers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Streaming/README.nuget.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nProducerT<OUT, M, A>\nPipeT<IN, OUT, M, A>\nConsumerT<IN, M, A>\n```\n\n----------------------------------------\n\nTITLE: Tail Property Implementation in ConsValueEnum Class\nDESCRIPTION: Implementation of the Tail property in ConsValueEnum class that lazily initializes the next iterator element in a thread-safe manner. Uses a similar pattern to ConsFirst with Interlocked.CompareExchange for thread safety.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Iterator<A> Tail\n{\n    get\n    {\n        if(tailAcquired == 2) return tailValue!;\n        if(tailAcquired == 3) exception!.Rethrow();\n\n        SpinWait sw = default;\n        while (tailAcquired < 2)\n        {\n            if (Interlocked.CompareExchange(ref tailAcquired, 1, 0) == 0)\n            {   \n                try\n                {\n                    if (enumerator!.MoveNext())\n                    {\n                        tailValue = new ConsValueEnum(enumerator.Current, enumerator);\n                    }\n                    else\n                    {\n                        enumerator?.Dispose();\n                        enumerator = null;\n                        tailValue = Nil.Default;\n                    }\n\n                    tailAcquired = 2;\n                }\n                catch (Exception e)\n                {\n                    exception = e;\n                    tailAcquired = 3;\n                    throw;\n                }\n            }\n            else\n            {\n                sw.SpinOnce();\n            }\n        }\n\n        if(tailAcquired == 3) exception!.Rethrow();\n        return tailValue!;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConsFirst Internal Structure in Iterator<A> in C#\nDESCRIPTION: Shows the internal fields of the Iterator<A>.ConsFirst implementation. This represents the initial wrapper around an IEnumerable<A> that hasn't yet started enumeration.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<A> enumerable;\nint firstAcquired;\nIterator<A>? firstValue;\n```\n\n----------------------------------------\n\nTITLE: Creating Maps from Ranges in C#\nDESCRIPTION: Shows the standardized ways to create Map collections from IEnumerable sequences using createRange or toMap methods.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/version-2-migration-notes.md#2025-04-23_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n    IEnumerable<(int, string)> xs = new [] { (1, \"A\"), (2, \"B\"), (1, \"C\") };\n\n    var m1 = toMap(xs);\n    var m2 = Map.createRange(xs);\n```\n\n----------------------------------------\n\nTITLE: Combining Errors with the Addition Operator in C#\nDESCRIPTION: Demonstrates how to combine multiple errors using the + operator, which is a simplified way to create a ManyErrors collection.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Common/README.md#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nError.New(\"error one\") + Error.New(\"error two\")\n```\n\n----------------------------------------\n\nTITLE: First Property Implementation in Iterator<A>.ConsFirst in C#\nDESCRIPTION: Shows the implementation of the First property in ConsFirst, which handles thread-safe initialization of the iterator. This uses lock-free synchronization with Interlocked.CompareExchange to ensure thread safety.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nIterator<A> First\n{\n    get\n    {\n        if (firstAcquired == 2) return firstValue!;\n        \n        SpinWait sw = default;\n        while (firstAcquired < 2)\n        {\n            if (Interlocked.CompareExchange(ref firstAcquired, 1, 0) == 0)\n            {\n                try\n                {\n                    var enumerator = enumerable.GetEnumerator();\n                    if (enumerator.MoveNext())\n                    {\n                        firstValue = new ConsValueEnum(enumerator.Current, enumerator);\n                    }\n                    else\n                    {\n                        enumerator.Dispose();\n                        firstValue = Nil.Default;\n                    }\n\n                    firstAcquired = 2;\n                }\n                catch (Exception)\n                {\n                    firstAcquired = 0;\n                    throw;\n                }\n            }\n            else\n            {\n                sw.SpinOnce();\n            }\n        }\n\n        return firstValue!;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Iterator<A> in C#\nDESCRIPTION: Demonstrates how to use pattern matching with Iterator<A> similar to a functional 'cons' linked-list type. This approach uses the switch expression to handle both empty (Nil) and non-empty (Cons) cases.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter switch\n    {\n        Iterator<A>.Nil                 => A.Zero,\n        Iterator<A>.Cons(var x, var xs) => x + Sum(xs),\n    }\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing and Differencing Overview\nDESCRIPTION: Doc monad for pretty printing and Patch type for collection differencing\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nCore:\n- Doc<A>\n- Patch<EqA, A>\n```\n\n----------------------------------------\n\nTITLE: Defining Monoid Interface in C#\nDESCRIPTION: Basic interface definition for a Monoid type class that extends Semigroup<A> and adds an Empty() function for identity values.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_34\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Monoid<A> : Semigroup<A>\n{\n    A Empty();\n}\n```\n\n----------------------------------------\n\nTITLE: Haskell Functor Definition\nDESCRIPTION: Original Haskell definition of Functor for comparison with C# implementation.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_11\n\nLANGUAGE: haskell\nCODE:\n```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n```\n\n----------------------------------------\n\nTITLE: Converting Back to Concrete Types\nDESCRIPTION: Example of converting K types back to concrete types using As() extension method.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_15\n\nLANGUAGE: c#\nCODE:\n```\nOption<int> mx = AddOne(Option<int>.Some(10))\n                     .Bind(x => Option<int>.Some(x + 10))\n                     .Map(x => x + 20)\n                     .As();\n\nSeq<int> mx = AddOne(Seq<int>(1, 2, 3, 4))\n                  .Bind(x => Seq(x + 10))\n                  .Map(x => x + 20)\n                  .As();\n```\n\n----------------------------------------\n\nTITLE: Safe Iteration with Iterator<A> in C#\nDESCRIPTION: Demonstrates a memory-efficient way to iterate through an iterator by updating the reference in-place. This approach allows the garbage collector to reclaim memory from processed items.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nfor(var iter = Naturals.GetIterator(); !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: State Management Monads Overview\nDESCRIPTION: Summary of state management monads including Reader, Writer, and State with their transformer variants\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Sys/README.nuget.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nCore:\n- Reader<E, A>\n- ReaderT<E, M, A>\n- Writer<W, A>\n- WriterT<W, M, A>\n- State<S, A>\n- StateT<S, M, A>\n```\n\n----------------------------------------\n\nTITLE: Simple Cons Construction Example\nDESCRIPTION: Shows simplified Cons construction without explicit Empty parameter.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\n    var seq = 1.Cons();   // Creates a sequence with one item in\n```\n\n----------------------------------------\n\nTITLE: Creating Fin Monad Instances in C#\nDESCRIPTION: Demonstrates how to construct instances of the Fin monad with both success and failure cases. The first example creates a successful Fin with an integer value, while the second creates a failed Fin with an error message.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/Fin/README.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nFin<int> ma = Pure(123);\nFin<int> mb = Fail(Error.New(\"Error!\"));\n```\n\n----------------------------------------\n\nTITLE: Custom Traverse Extension Method Implementation\nDESCRIPTION: Example of how to restore previous Traverse functionality by implementing a custom extension method.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_23\n\nLANGUAGE: c#\nCODE:\n```\npublic static Option<Seq<B>> Traverse<A, B>(this Seq<Option<A>> mx, Func<A, B> f) =>\n    mx.Sequence().Map(f).As();\n```\n\n----------------------------------------\n\nTITLE: ISeq<A> Interface Definition\nDESCRIPTION: Complete interface definition for ISeq<A> showing all available operations including pattern matching, mapping, filtering, and sequence manipulation methods.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\n    public interface ISeq<A> : \n        IEnumerable<A>, \n        IEquatable<ISeq<A>>, \n        IComparable<ISeq<A>>\n    {\n        /// <summary>\n        /// Head of the sequence\n        /// </summary>\n        A Head { get; }\n\n        /// <summary>\n        /// Head of the sequence\n        /// </summary>\n        Option<A> HeadOrNone();\n\n        /// <summary>\n        /// Tail of the sequence\n        /// </summary>\n        Seq<A> Tail { get; }\n\n        /// <summary>\n        /// True if this cons node is the Empty node\n        /// </summary>\n        bool IsEmpty { get; }\n\n        /// <summary>\n        /// Returns the number of items in the sequence\n        /// </summary>\n        /// <returns>Number of items in the sequence</returns>\n        int Count { get; }\n\n        /// <summary>\n        /// Match empty sequence, or multi-item sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Return value type</typeparam>\n        /// <param name=\"Empty\">Match for an empty list</param>\n        /// <param name=\"Tail\">Match for a non-empty</param>\n        /// <returns>Result of match function invoked</returns>\n        B Match<B>(\n            Func<B> Empty,\n            Func<A, Seq<A>, B> Tail);\n\n        /// <summary>\n        /// Match empty sequence, or one item sequence, or multi-item sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Return value type</typeparam>\n        /// <param name=\"Empty\">Match for an empty list</param>\n        /// <param name=\"Tail\">Match for a non-empty</param>\n        /// <returns>Result of match function invoked</returns>\n        B Match<B>(\n            Func<B> Empty,\n            Func<A, B> Head,\n            Func<A, Seq<A>, B> Tail);\n\n        /// <summary>\n        /// Match empty sequence, or multi-item sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Return value type</typeparam>\n        /// <param name=\"Empty\">Match for an empty list</param>\n        /// <param name=\"Seq\">Match for a non-empty</param>\n        /// <returns>Result of match function invoked</returns>\n        B Match<B>(\n            Func<B> Empty,\n            Func<Seq<A>, B> Seq);\n\n        /// <summary>\n        /// Match empty sequence, or one item sequence, or multi-item sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Return value type</typeparam>\n        /// <param name=\"Empty\">Match for an empty list</param>\n        /// <param name=\"Tail\">Match for a non-empty</param>\n        /// <returns>Result of match function invoked</returns>\n        B Match<B>(\n            Func<B> Empty,\n            Func<A, B> Head,\n            Func<Seq<A>, B> Tail);\n\n        /// <summary>\n        /// Map the sequence using the function provided\n        /// </summary>\n        /// <typeparam name=\"B\"></typeparam>\n        /// <param name=\"f\">Mapping function</param>\n        /// <returns>Mapped sequence</returns>\n        Seq<B> Map<B>(Func<A, B> f);\n\n        /// <summary>\n        /// Map the sequence using the function provided\n        /// </summary>\n        /// <typeparam name=\"B\"></typeparam>\n        /// <param name=\"f\">Mapping function</param>\n        /// <returns>Mapped sequence</returns>\n        Seq<B> Select<B>(Func<A, B> f);\n\n        /// <summary>\n        /// Filter the items in the sequence\n        /// </summary>\n        /// <param name=\"f\">Predicate to apply to the items</param>\n        /// <returns>Filtered sequence</returns>\n        Seq<A> Filter(Func<A, bool> f);\n\n        /// <summary>\n        /// Filter the items in the sequence\n        /// </summary>\n        /// <param name=\"f\">Predicate to apply to the items</param>\n        /// <returns>Filtered sequence</returns>\n        Seq<A> Where(Func<A, bool> f);\n\n        /// <summary>\n        /// Monadic bind (flatmap) of the sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Bound return value type</typeparam>\n        /// <param name=\"f\">Bind function</param>\n        /// <returns>Flatmapped sequence</returns>\n        Seq<B> Bind<B>(Func<A, Seq<B>> f);\n\n        /// <summary>\n        /// Monadic bind (flatmap) of the sequence\n        /// </summary>\n        /// <typeparam name=\"B\">Bound return value type</typeparam>\n        /// <param name=\"bind\">Bind function</param>\n        /// <returns>Flatmapped sequence</returns>\n        Seq<C> SelectMany<B, C>(Func<A, Seq<B>> bind, Func<A, B, C> project);\n\n        /// <summary>\n        /// Fold the sequence from the first item to the last\n        /// </summary>\n        /// <typeparam name=\"S\">State type</typeparam>\n        /// <param name=\"state\">Initial state</param>\n        /// <param name=\"f\">Fold function</param>\n        /// <returns>Aggregated state</returns>\n        S Fold<S>(S state, Func<S, A, S> f);\n\n        /// <summary>\n        /// Fold the sequence from the last item to the first\n        /// </summary>\n        /// <typeparam name=\"S\">State type</typeparam>\n        /// <param name=\"state\">Initial state</param>\n        /// <param name=\"f\">Fold function</param>\n        /// <returns>Aggregated state</returns>\n        S FoldBack<S>(S state, Func<S, A, S> f);\n\n        /// <summary>\n        /// Returns true if the supplied predicate returns true for any\n        /// item in the sequence.  False otherwise.\n        /// </summary>\n        /// <param name=\"f\">Predicate to apply</param>\n        /// <returns>True if the supplied predicate returns true for any\n        /// item in the sequence.  False otherwise.</returns>\n        bool Exists(Func<A, bool> f);\n\n        /// <summary>\n        /// Returns true if the supplied predicate returns true for all\n        /// items in the sequence.  False otherwise.  If there is an \n        /// empty sequence then true is returned.\n        /// </summary>\n        /// <param name=\"f\">Predicate to apply</param>\n        /// <returns>True if the supplied predicate returns true for all\n        /// items in the sequence.  False otherwise.  If there is an \n        /// empty sequence then true is returned.</returns>\n        bool ForAll(Func<A, bool> f);\n\n        /// <summary>\n        /// Skip count items\n        /// </summary>\n        Seq<A> Skip(int count);\n\n        /// <summary>\n        /// Take count items\n        /// </summary>\n        Seq<A> Take(int count);\n\n        /// <summary>\n        /// Iterate the sequence, yielding items if they match the predicate \n        /// provided, and stopping as soon as one doesn't\n        /// </summary>\n        /// <returns>A new sequence with the first items that match the \n        /// predicate</returns>\n        Seq<A> TakeWhile(Func<A, bool> pred);\n\n        /// <summary>\n        /// Iterate the sequence, yielding items if they match the predicate \n        /// provided, and stopping as soon as one doesn't.  An index value is \n        /// also provided to the predicate function.\n        /// </summary>\n        /// <returns>A new sequence with the first items that match the \n        /// predicate</returns>\n        Seq<A> TakeWhile(Func<A, int, bool> pred);\n    }\n```\n\n----------------------------------------\n\nTITLE: Memory-Inefficient Iteration with Iterator<A> in C#\nDESCRIPTION: Shows a problematic approach that keeps a reference to the head of the iterator, preventing garbage collection of processed items. This can lead to memory issues with large or infinite sequences.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar start = Naturals.GetIterator();\nfor(var iter = start; !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: Ordering Type Class Definition\nDESCRIPTION: Definition of the Ord<A> type class interface for comparison operations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_31\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Ord<A> : Eq<A>\n{\n    int Compare(A x, A y);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Numeric Function\nDESCRIPTION: Generic function implementation using type class constraints.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_29\n\nLANGUAGE: c#\nCODE:\n```\npublic A DoubleIt<NumA, A>(A x) where NumA : struct, Num<A> =>\n    default(NumA).Add(x, x);\n```\n\n----------------------------------------\n\nTITLE: Generic Option Mapping\nDESCRIPTION: Shows a function that maps any type within an Option to its string representation, demonstrating lower-kind polymorphism.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nstatic Option<string> Show(Option<A> mx) =>\n\tmx.Map(x => x.ToString());\n```\n\n----------------------------------------\n\nTITLE: Core Traits Table in Markdown\nDESCRIPTION: Table documenting core traits in language-ext including MonoidK, Applicative, Eq, Fallible, and others. Each trait is listed with its location and functional description.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.FSharp/README.nuget.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                                | Description                                                                                                                                                            |\n|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `MonoidK<F>`                       | [A monoid on applicative functors](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Alternative/index.html)                                               |\n| `Core`   | `Applicative<F>`                       | [Applicative functor](https://louthy.github.io/language-ext/LanguageExt.Core/Traits/Applicative/index.html)                                                            |\n```\n\n----------------------------------------\n\nTITLE: Using IsEmpty and Head Properties with Iterator<A> in C#\nDESCRIPTION: Shows how to implement a Sum function using the IsEmpty property and Head/Tail accessors of Iterator<A>. This recursive approach checks if the iterator is empty before accessing its elements.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber =>\n    iter.IsEmpty\n        ? A.Zero\n        : iter.Head + Sum(iter.Tail);\n```\n\n----------------------------------------\n\nTITLE: Nil Implementation in Iterator<A>\nDESCRIPTION: Implementation of Head and Tail properties in the Nil class of Iterator<A>. The Head property throws an exception when accessed, while Tail returns itself, representing the empty iterator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic override A Head =>\n    throw new InvalidOperationException(\"Nil iterator has no head\");\n\npublic override Iterator<A> Tail =>\n    this;\n```\n\n----------------------------------------\n\nTITLE: Custom Sequence Extension Method Implementation\nDESCRIPTION: Example showing how to restore previous Sequence functionality by creating a custom extension method using Traverse.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_20\n\nLANGUAGE: c#\nCODE:\n```\npublic static Option<Seq<A>> Sequence<A>(this Seq<Option<A>> mx) =>\n    mx.Traverse(identity).As();\n```\n\n----------------------------------------\n\nTITLE: Using Clone to Prevent Memory Leaks with Iterator<A> in C#\nDESCRIPTION: Shows how to use the Clone method to create a new iterator reference, allowing proper garbage collection even when maintaining a reference to the original sequence start.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar start = Naturals.GetIterator();\nfor(var iter = start.Clone(); !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: ValueTuple and Tuple Creation Examples in C#\nDESCRIPTION: Demonstrates the usage of C# 7's ValueTuple syntax and Map creation using tuples with named elements.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_20\n\nLANGUAGE: c#\nCODE:\n```\nTuple.Create(a, b)\n```\n\nLANGUAGE: c#\nCODE:\n```\n(a, b)\n```\n\nLANGUAGE: c#\nCODE:\n```\n(K Key, V Value)\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar map = Map(\n        (1, \"Paul\"), \n        (2, \"Steve\"), \n        (3, \"Stan\"), \n        (4, \"Tanzeel\"), \n        (5, \"Dan\"), \n        (6, \"Andreas\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing String Length Predicate\nDESCRIPTION: Shows the implementation of a string length validation predicate using constant generic constraints.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_18\n\nLANGUAGE: c#\nCODE:\n```\n    public struct StrLen<NMin, NMax> : Pred<string>\n            where NMin : struct, Const<int>\n            where NMax : struct, Const<int>\n    {\n        [Pure]\n        public bool True(string value) =>\n            Range<int, TInt, NMin, NMax>.Is.True(value?.Length ?? 0);\n    }\n```\n\n----------------------------------------\n\nTITLE: HTML Div Wrapper Function with Constrained List in C#\nDESCRIPTION: Demonstrates practical use of constrained lists in function parameters\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic string Divify(Lst<NonEmpty, NonNullItems<string>, string> items) =>\n    String.Join(items.Map(x => $\"<div>{x}</div>\"));\n```\n\n----------------------------------------\n\nTITLE: Testing Non-nullable Map Initialization\nDESCRIPTION: Shows how non-nullable struct types automatically initialize to empty collections without explicit initialization.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\n    static class Test\n    {\n        public static Map<string, int> Foo;\n    }\n\n    Assert.True(Test.Foo == Map.empty<string, int>());\n    Assert.True(Test.Foo == default(Map<string, int>);\n```\n\n----------------------------------------\n\nTITLE: Tuple Operations and Extensions in C#\nDESCRIPTION: Shows various tuple operations including adding items, appending, head/tail operations, and mapping functions.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_21\n\nLANGUAGE: c#\nCODE:\n```\nvar (a,b,c)   = (1, 2).Add(3);\nvar (a,b,c,d) = (1, 2).Add(3).Add(\"Hello\");\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar (a, b) = append<TLst<int>, TInt, Lst<int>, int>(\n                    (List(1,2,3), 3),\n                    (List(4,5,6,7), 4));\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar list = append<TLst<int>, Lst<int>>( (List(1,2,3), List(4,5,6,7)) );\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar a  = (\"a\", 123, true).Head();   // \"a\"\nvar bc = (\"a\", 123, true).Tail();   // (123, true)\n```\n\n----------------------------------------\n\nTITLE: ConsValueEnum Internal Fields in Iterator<A> Implementation\nDESCRIPTION: Shows the internal fields of the ConsValueEnum class that represents non-empty iterators. These fields track the enumerator, exceptions, and the tail value with its acquisition state.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nException? exception;\nIEnumerator<A>? enumerator;\nint tailAcquired;\nIterator<A>? tailValue;\n```\n\n----------------------------------------\n\nTITLE: Updating NewType Generic Arguments in C#\nDESCRIPTION: Example showing how to update NewType class definition to include the additional required generic argument for proper type inheritance.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/version-2-migration-notes.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n    public class Metres : NewType<int>\n    {\n        public Metres(int x) : base(x)\n        {}\n    }\n```\n\nLANGUAGE: c#\nCODE:\n```\n    public class Metres : NewType<Metres, int>\n    {\n        public Metres(int x) : base(x)\n        {}\n    }\n```\n\n----------------------------------------\n\nTITLE: Markdown Table: Differencing\nDESCRIPTION: Table documenting the Patch type for calculating and applying differences between collections.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature         | Description                                                                                                                                                                                                                          |\n|----------|-----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `Patch<EqA, A>` | Uses patch-theory to efficiently calculate the difference (`Patch.diff(list1, list2)`) between two collections of `A` and build a patch which can be applied (`Patch.apply(patch, list)`) to one to make the other (think git diff). |\n```\n\n----------------------------------------\n\nTITLE: Basic Ad-hoc Polymorphism Example\nDESCRIPTION: Example showing a basic INumeric interface implementation that would cause boxing issues.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_25\n\nLANGUAGE: c#\nCODE:\n```\nINumeric Add(INumeric x, INumeric y) => x + y;\n```\n\n----------------------------------------\n\nTITLE: Array Ordering Implementation\nDESCRIPTION: Complex implementation of array ordering using type classes.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_32\n\nLANGUAGE: c#\nCODE:\n```\npublic struct OrdArray<ORD, A> : Ord<A[]>\n    where ORD : struct, Ord<A>\n{\n    public int Compare(A[] mx, A[] my)\n    {\n        if (ReferenceEquals(mx, my)) return 0;\n        if (ReferenceEquals(mx, null)) return -1;\n        if (ReferenceEquals(my, null)) return 1;\n\n        var cmp = mx.Length.CompareTo(my.Length);\n        if (cmp == 0)\n        {\n            for(var i = 0; i < mx.Length; i++)\n            {\n                cmp = default(ORD).Compare(mx[i], my[i]);\n                if (cmp != 0) return cmp;\n            }\n            return 0;\n        }\n        else\n        {\n            return cmp;\n        }\n    }\n\n    public bool Equals(A[] x, A[] y) =>\n        default(EqArray<ORD, A>).Equals(x, y);\n\n    public int GetHashCode(A[] x) =>\n        hash(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Empty Non-Null List Example in C#\nDESCRIPTION: Shows creation of list with both non-empty and non-null constraints\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvar x = List<NonEmpty, NonNullItems<string>, string>(\"1\", \"2\", \"3\");\n```\n\n----------------------------------------\n\nTITLE: Markdown Table: Pretty Printing\nDESCRIPTION: Table documenting the Doc type for formatted text layout.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature  | Description                                      |\n|----------|----------|--------------------------------------------------|\n| `Core`   | `Doc<A>` | Produce nicely formatted text with smart layouts |\n```\n\n----------------------------------------\n\nTITLE: Specialized Eff Stream Types in C#\nDESCRIPTION: Shows the specialized versions of stream components that work specifically with the Eff<RT, A> effect monad.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Streaming/README.nuget.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nProducer<RT, OUT, A>\nPipe<RT, IN, OUT, A>\nConsumer<RT, IN, A>\n```\n\n----------------------------------------\n\nTITLE: System.Collections.Immutable Type References\nDESCRIPTION: Mapping of abbreviated collection type names to their full System.Collections.Immutable namespace equivalents\nSOURCE: https://github.com/louthy/language-ext/blob/main/Performance.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* `Sys.Coll.Imm.List` is `System.Collections.Immutable.ImmutableList`\n* `Sys.Coll.Imm.Dictionary` is `System.Collections.Immutable.ImmutableDictionary`\n* `Sys.Coll.Imm.SortedDictionary` is `System.Collections.Immutable.ImmutableSortedDictionary`\n* `Sys.Coll.Imm.SortedSet` is `System.Collections.Immutable.ImmutableSortedSet`\n```\n\n----------------------------------------\n\nTITLE: Static Console Usage Example in C#\nDESCRIPTION: Demonstrates using static imports to enable direct function-style calls without class qualification.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing static System.Console;\n\nWriteLine(\"Hello, World\");\n```\n\n----------------------------------------\n\nTITLE: NaturalMono Type Inheritance in C#\nDESCRIPTION: Shows the inheritance structure of NaturalMono, demonstrating its relationship with Natural and CoNatural types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Natural/README.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nNatural〈F, G〉\nCoNatural〈G, F〉\n```\n\n----------------------------------------\n\nTITLE: ConsValueEnum Internal Structure in Iterator<A> in C#\nDESCRIPTION: Shows the internal fields of the ConsValueEnum class, which represents a non-empty iterator that has already acquired its head value but may not have processed its tail yet.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nException? exception;\nIEnumerator<A>? enumerator;\nint tailAcquired;\nIterator<A>? tailValue;\n```\n\n----------------------------------------\n\nTITLE: Head and Tail Properties in ConsFirst Class\nDESCRIPTION: Implementation of the Head and Tail properties in the ConsFirst class that inherits from Iterator<A>. Both properties delegate to the First property which handles the initialization of the iterator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic override A Head =>\n    First.Head;\n\npublic override Iterator<A> Tail =>\n    First.Tail;\n```\n\n----------------------------------------\n\nTITLE: Attempted Higher-Kinded Polymorphism\nDESCRIPTION: Demonstrates an attempt at implementing higher-kinded polymorphism that won't work in C#, showing the limitations of the type system.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nstatic F<int> AddOne<F>(F<int> mx) where F : Functor =>\n\tmx.Map(x => x + 1);\n```\n\n----------------------------------------\n\nTITLE: Problematic Memory Usage with Iterator<A> in C#\nDESCRIPTION: Demonstrates a potential memory issue when maintaining a reference to the head of the sequence. This prevents garbage collection of processed items, leading to growing memory usage.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar start = Naturals.GetIterator();\nfor(var iter = start; !iter.IsEmpty; iter = iter.Tail)\n{\n    Console.WriteLine(iter.Head);\n}\n```\n\n----------------------------------------\n\nTITLE: Head and Tail Implementation in Iterator<A>.ConsFirst in C#\nDESCRIPTION: Shows how the Head and Tail properties are implemented in the ConsFirst class. Both properties delegate to the First property which handles the initialization of the iterator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic override A Head =>\n    First.Head;\n\npublic override Iterator<A> Tail =>\n    First.Tail;\n```\n\n----------------------------------------\n\nTITLE: NaturalEpi Type Inheritance in C#\nDESCRIPTION: Shows the inheritance structure of NaturalEpi, the dual of NaturalMono.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Natural/README.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nNatural〈G, F〉\nCoNatural〈F, G〉\n```\n\n----------------------------------------\n\nTITLE: Markdown Table: State Managing Monads\nDESCRIPTION: Table documenting state management monads including Reader, Writer, and State types along with their monad transformers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature            | Description                                                                                                                                                                             |\n|----------|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `Reader<E, A>`     | [Reader monad]                                               |\n| `Core`   | `ReaderT<E, M, A>` | [Reader monad-transformer]                                  |\n| `Core`   | `Writer<W, A>`     | [Writer monad that logs to a `W` constrained to be a Monoid] |\n| `Core`   | `WriterT<W, M, A>` | [Writer monad-transformer]                                  |\n| `Core`   | `State<S, A>`      | [State monad]                                                  |\n| `Core`   | `StateT<S, M, A>`  | [State monad-transformer]\n```\n\n----------------------------------------\n\nTITLE: First Property Implementation in ConsFirst Class\nDESCRIPTION: Shows the implementation of the First property in ConsFirst class that handles thread-safe initialization of the iterator. Uses Interlocked.CompareExchange to ensure only one thread initializes the enumerator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nIterator<A> First\n{\n    get\n    {\n        if (firstAcquired == 2) return firstValue!;\n        \n        SpinWait sw = default;\n        while (firstAcquired < 2)\n        {\n            if (Interlocked.CompareExchange(ref firstAcquired, 1, 0) == 0)\n            {\n                try\n                {\n                    var enumerator = enumerable.GetEnumerator();\n                    if (enumerator.MoveNext())\n                    {\n                        firstValue = new ConsValueEnum(enumerator.Current, enumerator);\n                    }\n                    else\n                    {\n                        enumerator.Dispose();\n                        firstValue = Nil.Default;\n                    }\n\n                    firstAcquired = 2;\n                }\n                catch (Exception)\n                {\n                    firstAcquired = 0;\n                    throw;\n                }\n            }\n            else\n            {\n                sw.SpinOnce();\n            }\n        }\n\n        return firstValue!;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Value Traits Table in Markdown\nDESCRIPTION: Markdown table documenting value traits in language-ext, focusing on domain-specific implementations like DomainType, Identifier, VectorSpace, Amount, and LocusLike traits.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                              | Description                                                                                                                                                                                                                                       |\n|----------|--------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `DomainType<SELF, REPR>`             | Provides a mapping from `SELF` to an underlying representation: `REPR`                                                                                                                                                                            |\n```\n\n----------------------------------------\n\nTITLE: Empty List Product Example in C#\nDESCRIPTION: Demonstrates error handling when trying to calculate product of empty list\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nLst<int> list = List<int>();\n\nvar res = Product(list);  // ArgumentOutOfRangeException\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Constants\nDESCRIPTION: Demonstrates how to define constant values as struct types for use in validation predicates.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_19\n\nLANGUAGE: c#\nCODE:\n```\n    public struct I10 : Const<int> { public int Value => 10; }\n    public struct I100 : Const<int> { public int Value => 100; }\n```\n\n----------------------------------------\n\nTITLE: Valid List Product Example in C#\nDESCRIPTION: Shows successful product calculation with non-empty list\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nLst<int> list = List<int>(1, 2, 3, 4, 5);\n\nvar res = Product(list); // 120\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing Documentation Type\nDESCRIPTION: Documentation type for producing formatted text with smart layouts.\nSOURCE: https://github.com/louthy/language-ext/blob/main/README.md#2025-04-23_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nDoc<A>  // Pretty printing documentation type\n```\n\n----------------------------------------\n\nTITLE: Immutable Collection Types in C#\nDESCRIPTION: Implements various immutable collection types including arrays, lists, maps, sets, queues, and stacks with optional constraints\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nArr<A>\nSeq<A>\nLst<A>\nMap<K, V>\nHashMap<K, V>\nSet<A>\nHashSet<A>\nQue<A>\nStck<A>\n```\n\n----------------------------------------\n\nTITLE: Basic Option Mapping Example\nDESCRIPTION: Shows a simple function that maps over an Option type to add one to the contained value, demonstrating basic functor usage.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nstatic Option<int> AddOne(Option<int> mx) =>\n\tmx.Map(x => x + 1);\n```\n\n----------------------------------------\n\nTITLE: Calling Constrained List Function in C#\nDESCRIPTION: Shows how to call function requiring constrained list with implicit conversion\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nvar res = Divify(List(\"1\", \"2\", \"3\")); \n\n// \"<div>1</div><div>2</div><div>3</div>\"\n```\n\n----------------------------------------\n\nTITLE: Parser Combinators Documentation\nDESCRIPTION: Documentation of parser monad implementations for string parsing and general input stream parsing, with full combinator library support.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature | Description |\n|----------|----------------|-------------|\n| `Parsec` | `Parser<A>` | String parser monad |\n| `Parsec` | `Parser<I, O>` | Generic input parser |\n```\n\n----------------------------------------\n\nTITLE: Float Type Class Instance\nDESCRIPTION: Implementation of TFloat struct as a type class instance for floating point numbers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_28\n\nLANGUAGE: c#\nCODE:\n```\npublic struct TFloat : Num<float>\n{\n    public float Add(float x, float b) => x + y;\n    public float Subtract(float x, float b) => x + y;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Table: Parser Combinators\nDESCRIPTION: Table documenting parser combinator types for string and generic input stream parsing.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Rx/README.nuget.md#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature        | Description                                                                                                                    |\n|----------|----------------|--------------------------------------------------------------------------------------------------------------------------------|\n| `Parsec` | `Parser<A>`    | [String parser monad and full parser combinators library] |\n| `Parsec` | `Parser<I, O>` | [Parser monad that can work with any input stream type]\n```\n\n----------------------------------------\n\nTITLE: Removed Sequence Extension Method Example\nDESCRIPTION: Example of a removed Sequence extension method signature that was previously used for traversing monadic types.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_18\n\nLANGUAGE: c#\nCODE:\n```\npublic static Fin<Lst<B>> Sequence<A, B>(this Lst<A> ta, Func<A, Fin<B>> f) => ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Map Collections in C#\nDESCRIPTION: Demonstrates different ways to initialize Map collections when null is no longer allowed as a default value.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/version-2-migration-notes.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n    Map<string, int> xs = Map<string, int>();        // If you're using static LanguageExt.Prelude\n    Map<string, int> xs = Map.empty<string, int>();\n    Map<string, int> xs = default(Map<string, int>);\n```\n\n----------------------------------------\n\nTITLE: Integer Type Class Instance\nDESCRIPTION: Implementation of TInt struct as a type class instance for integers.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_27\n\nLANGUAGE: c#\nCODE:\n```\npublic struct TInt : Num<int>\n{\n    public int Add(int x, int b) => x + y;\n    public int Subtract(int x, int b) => x + y;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Predicate List Construction in C#\nDESCRIPTION: Demonstrates direct construction of predicate-constrained list\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nLst<NonEmpty, int> list = List<NonEmpty, int>(1, 2, 3, 4, 5);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Either Monad Type in C#\nDESCRIPTION: Shows the Either monad type syntax representing a choice between an integer OR string value.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Monads/Alternative Monads/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nEither<int, string>\n```\n\n----------------------------------------\n\nTITLE: ConsFirst Internal Fields in Iterator<A> Implementation\nDESCRIPTION: Shows the internal fields of the ConsFirst class that implements Iterator<A>. These fields are used to cache the first value and track the acquisition state of the enumerator.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<A> enumerable;\nint firstAcquired;\nIterator<A>? firstValue;\n```\n\n----------------------------------------\n\nTITLE: Removing Manual Traverse Extension Method in C#\nDESCRIPTION: Example of removed Traverse extension method pattern that is being replaced by a combination of Sequence and Map operations.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 5/README.md#2025-04-23_snippet_21\n\nLANGUAGE: c#\nCODE:\n```\npublic static Seq<Fin<B>> Traverse<A, B>(this Fin<Seq<A>> ma, Func<A, B> f) => ...\n```\n\n----------------------------------------\n\nTITLE: Imperative Approach with Iterator<A> in C#\nDESCRIPTION: Shows an imperative implementation of a Sum function using Iterator<A>. This non-recursive approach uses a while loop to iterate through the elements, updating the iterator reference at each step.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/Iterator/README.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic A Sum<A>(Iterator<A> iter) where A : INumber\n{\n    var total = A.Zero;\n    while(!iter.IsEmpty)\n    {\n        total += iter.Head;\n        iter = iter.Tail;\n    }\n    return total;\n}\n```\n\n----------------------------------------\n\nTITLE: Machine Specification Details\nDESCRIPTION: System specification details for the benchmark environment, including CPU, OS version, and .NET runtime information\nSOURCE: https://github.com/louthy/language-ext/blob/main/Performance.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nBenchmarkDotNet=v0.11.5, OS=Windows 10.0.17134.1184 (1803/April2018Update/Redstone4)\nIntel Core i5-3470 CPU 3.20GHz (Ivy Bridge), 1 CPU, 4 logical and 4 physical cores\nFrequency=3117923 Hz, Resolution=320.7263 ns, Timer=TSC\n.NET Core SDK=3.1.100\n  [Host]     : .NET Core 3.0.1 (CoreCLR 4.700.19.51502, CoreFX 4.700.19.51609), 64bit RyuJIT\n  DefaultJob : .NET Core 3.0.1 (CoreCLR 4.700.19.51502, CoreFX 4.700.19.51609), 64bit RyuJIT\n```\n\n----------------------------------------\n\nTITLE: NaturalIso Type Inheritance in C#\nDESCRIPTION: Shows the inheritance structure of NaturalIso, deriving from both Natural and CoNatural interfaces.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/Natural/README.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nNatural〈F, G〉\nCoNatural〈F, G〉\n```\n\n----------------------------------------\n\nTITLE: Nil Implementation in Iterator<A> in C#\nDESCRIPTION: Shows the implementation of Head and Tail properties in the Nil case of Iterator<A>. Head throws an exception when accessed, and Tail returns itself, representing an empty sequence.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic override A Head =>\n    throw new InvalidOperationException(\"Nil iterator has no head\");\n\npublic override Iterator<A> Tail =>\n    this;\n```\n\n----------------------------------------\n\nTITLE: Tail Implementation in Iterator<A>.ConsValueEnum in C#\nDESCRIPTION: Shows the implementation of the Tail property in ConsValueEnum, which lazily advances the enumerator when first accessed and caches the result. This uses thread-safe initialization similar to the First property in ConsFirst.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Immutable Collections/IteratorAsync/README.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic override Iterator<A> Tail\n{\n    get\n    {\n        if(tailAcquired == 2) return tailValue!;\n        if(tailAcquired == 3) exception!.Rethrow();\n\n        SpinWait sw = default;\n        while (tailAcquired < 2)\n        {\n            if (Interlocked.CompareExchange(ref tailAcquired, 1, 0) == 0)\n            {   \n                try\n                {\n                    if (enumerator!.MoveNext())\n                    {\n                        tailValue = new ConsValueEnum(enumerator.Current, enumerator);\n                    }\n                    else\n                    {\n                        enumerator?.Dispose();\n                        enumerator = null;\n                        tailValue = Nil.Default;\n                    }\n\n                    tailAcquired = 2;\n                }\n                catch (Exception e)\n                {\n                    exception = e;\n                    tailAcquired = 3;\n                    throw;\n                }\n            }\n            else\n            {\n                sw.SpinOnce();\n            }\n        }\n\n        if(tailAcquired == 3) exception!.Rethrow();\n        return tailValue!;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Breaking Change in Map Collection Type\nDESCRIPTION: Example showing code that will no longer compile in version 2.0 due to Map type being changed to a struct which cannot be null.\nSOURCE: https://github.com/louthy/language-ext/blob/main/Major Version Release Notes/Version 2/README.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nMap<int, string> x = null;\n```\n\n----------------------------------------\n\nTITLE: Defining Addable Interface with Static Abstract Member in C#\nDESCRIPTION: This snippet defines an Addable interface with a static abstract Add method. It uses a generic type parameter SELF with a constraint to implement the same interface, allowing for trait-like behavior.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Traits/README.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic interface Addable<SELF> where SELF : Addable<SELF>\n{\n    public static abstract SELF Add(SELF x, SELF y);\n}\n```\n\n----------------------------------------\n\nTITLE: Value Traits Table Structure in Markdown\nDESCRIPTION: Markdown table describing value traits that provide semantic meaning and common operators for underlying values. Includes traits like DomainType, Identifier, VectorSpace, Amount, and LocusLike.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/README.nuget.md#2025-04-23_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n| Location | Feature                              | Description                                                                                                                                                                                                                                       |\n|----------|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `Core`   | `DomainType<SELF, REPR>`             | Provides a mapping from `SELF` to an underlying representation: `REPR`                                                                                                                                                                            |\n```\n\n----------------------------------------\n\nTITLE: Importing Prelude Class in C#\nDESCRIPTION: Shows how to import the Prelude class for use in a C# file. This using static directive makes all static members of Prelude available without qualification.\nSOURCE: https://github.com/louthy/language-ext/blob/main/LanguageExt.Core/Prelude/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing static LanguageExt.Prelude;\n```"
  }
]