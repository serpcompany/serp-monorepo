[
  {
    "owner": "astral-sh",
    "repo": "ruff",
    "content": "TITLE: Simple Function Call Type Checking in Python\nDESCRIPTION: Demonstrates a simple function call with type checking using reveal_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef get_int() -> int:\n    return 42\n\nreveal_type(get_int())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Displaying Ruff's 'check' Command Help for Linting\nDESCRIPTION: This snippet provides the full command-line help output for Ruff's 'check' command, which is used for linting. It details all available options for running Ruff on files or directories, including fix options, output formats, rule selection, and file selection criteria.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nRun Ruff on the given files or directories\n\nUsage: ruff check [OPTIONS] [FILES]...\n\nArguments:\n  [FILES]...  List of files or directories to check [default: .]\n\nOptions:\n      --fix\n          Apply fixes to resolve lint violations. Use `--no-fix` to disable or\n          `--unsafe-fixes` to include unsafe fixes\n      --unsafe-fixes\n          Include fixes that may not retain the original intent of the code.\n          Use `--no-unsafe-fixes` to disable\n      --show-fixes\n          Show an enumeration of all fixed lint violations. Use\n          `--no-show-fixes` to disable\n      --diff\n          Avoid writing any fixed files back; instead, output a diff for each\n          changed file to stdout, and exit 0 if there are no diffs. Implies\n          `--fix-only`\n  -w, --watch\n          Run in watch mode by re-running whenever files change\n      --fix-only\n          Apply fixes to resolve lint violations, but don't report on, or exit\n          non-zero for, leftover violations. Implies `--fix`. Use\n          `--no-fix-only` to disable or `--unsafe-fixes` to include unsafe\n          fixes\n      --ignore-noqa\n          Ignore any `# noqa` comments\n      --output-format <OUTPUT_FORMAT>\n          Output serialization format for violations. The default serialization\n          format is \"full\" [env: RUFF_OUTPUT_FORMAT=] [possible values:\n          concise, full, json, json-lines, junit, grouped, github, gitlab,\n          pylint, rdjson, azure, sarif]\n  -o, --output-file <OUTPUT_FILE>\n          Specify file to write the linter output to (default: stdout) [env:\n          RUFF_OUTPUT_FILE=]\n      --target-version <TARGET_VERSION>\n          The minimum Python version that should be supported [possible values:\n          py37, py38, py39, py310, py311, py312, py313]\n      --preview\n          Enable preview mode; checks will include unstable rules and fixes.\n          Use `--no-preview` to disable\n      --extension <EXTENSION>\n          List of mappings from file extension to language (one of `python`,\n          `ipynb`, `pyi`). For example, to treat `.ipy` files as IPython\n          notebooks, use `--extension ipy:ipynb`\n      --statistics\n          Show counts for every rule with at least one violation\n      --add-noqa\n          Enable automatic additions of `noqa` directives to failing lines\n      --show-files\n          See the files Ruff will be run against with the current settings\n      --show-settings\n          See the settings Ruff will use to lint a given Python file\n  -h, --help\n          Print help\n\nRule selection:\n      --select <RULE_CODE>\n          Comma-separated list of rule codes to enable (or ALL, to enable all\n          rules)\n      --ignore <RULE_CODE>\n          Comma-separated list of rule codes to disable\n      --extend-select <RULE_CODE>\n          Like --select, but adds additional rule codes on top of those already\n          specified\n      --per-file-ignores <PER_FILE_IGNORES>\n          List of mappings from file pattern to code to exclude\n      --extend-per-file-ignores <EXTEND_PER_FILE_IGNORES>\n          Like `--per-file-ignores`, but adds additional ignores on top of\n          those already specified\n      --fixable <RULE_CODE>\n          List of rule codes to treat as eligible for fix. Only applicable when\n          fix itself is enabled (e.g., via `--fix`)\n      --unfixable <RULE_CODE>\n          List of rule codes to treat as ineligible for fix. Only applicable\n          when fix itself is enabled (e.g., via `--fix`)\n      --extend-fixable <RULE_CODE>\n          Like --fixable, but adds additional rule codes on top of those\n          already specified\n\nFile selection:\n      --exclude <FILE_PATTERN>\n          List of paths, used to omit files and/or directories from analysis\n      --extend-exclude <FILE_PATTERN>\n          Like --exclude, but adds additional files and directories on top of\n          those already excluded\n      --respect-gitignore\n          Respect file exclusions via `.gitignore` and other standard ignore\n          files. Use `--no-respect-gitignore` to disable\n      --force-exclude\n          Enforce exclusions, even for paths passed to Ruff directly on the\n          command-line. Use `--no-force-exclude` to disable\n\nMiscellaneous:\n  -n, --no-cache\n          Disable cache reads [env: RUFF_NO_CACHE=]\n      --cache-dir <CACHE_DIR>\n          Path to the cache directory [env: RUFF_CACHE_DIR=]\n      --stdin-filename <STDIN_FILENAME>\n          The name of the file when passing it through stdin\n  -e, --exit-zero\n          Exit with status code \"0\", even upon detecting lint violations\n      --exit-non-zero-on-fix\n          Exit with a non-zero status code if any files were modified via fix,\n          even if no lint violations remain\n\nLog levels:\n  -v, --verbose  Enable verbose logging\n  -q, --quiet    Print diagnostics, but nothing else\n  -s, --silent   Disable all logging (but still exit with status code \"1\" upon\n                 detecting diagnostics)\n\nGlobal options:\n      --config <CONFIG_OPTION>\n          Either a path to a TOML configuration file (`pyproject.toml` or\n          `ruff.toml`), or a TOML `<KEY> = <VALUE>` pair (such as you might\n          find in a `ruff.toml` configuration file) overriding a specific\n          configuration option. Overrides of individual settings using this\n          option always take precedence over all configuration files, including\n          configuration files that were also specified using `--config`\n      --isolated\n          Ignore all configuration files\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Kinds and Type Inference in Python\nDESCRIPTION: This snippet shows different parameter kinds in a Python function and how their types are inferred. It includes positional-only, keyword-only, variadic, and variadic-keyword parameters with various type annotations and default values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef f(a, b: int, c=1, d: int = 2, /, e=3, f: Literal[4] = 4, *args: object, g=5, h: Literal[6] = 6, **kwargs: str):\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: int\n    reveal_type(c)  # revealed: Unknown | Literal[1]\n    reveal_type(d)  # revealed: int\n    reveal_type(e)  # revealed: Unknown | Literal[3]\n    reveal_type(f)  # revealed: Literal[4]\n    reveal_type(g)  # revealed: Unknown | Literal[5]\n    reveal_type(h)  # revealed: Literal[6]\n\n    # TODO: should be `tuple[object, ...]` (needs generics)\n    reveal_type(args)  # revealed: tuple\n\n    # TODO: should be `dict[str, str]` (needs generics)\n    reveal_type(kwargs)  # revealed: dict\n```\n\n----------------------------------------\n\nTITLE: Ruff Configuration in TOML\nDESCRIPTION: Shows how to configure Ruff settings in either pyproject.toml or ruff.toml, including line length and rule selection.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Set the maximum line length to 79.\nline-length = 79\n\n[tool.ruff.lint]\n# Add the `line-too-long` rule to the enforced rule set. By default, Ruff omits rules that\n# overlap with the use of a formatter, like Black, but we can override this behavior by\n# explicitly adding the rule.\nextend-select = [\"E501\"]\n```\n\nLANGUAGE: toml\nCODE:\n```\n# Set the maximum line length to 79.\nline-length = 79\n\n[lint]\n# Add the `line-too-long` rule to the enforced rule set. By default, Ruff omits rules that\n# overlap with the use of a formatter, like Black, but we can override this behavior by\n# explicitly adding the rule.\nextend-select = [\"E501\"]\n```\n\n----------------------------------------\n\nTITLE: Using Ruff Format CLI in Shell\nDESCRIPTION: Demonstrates how to use the 'ruff format' command to format Python files and directories.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nruff format                   # Format all files in the current directory.\nruff format path/to/code/     # Format all files in `path/to/code` (and any subdirectories).\nruff format path/to/file.py   # Format a single file.\n```\n\n----------------------------------------\n\nTITLE: NoneType Handling\nDESCRIPTION: Shows type narrowing behavior with NoneType checks in Python 3.10+.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/issubclass.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom types import NoneType\n\ndef _(flag: bool):\n    t = int if flag else NoneType\n\n    if issubclass(t, NoneType):\n        reveal_type(t)  # revealed: Literal[NoneType]\n\n    if issubclass(t, type(None)):\n        reveal_type(t)  # revealed: Literal[NoneType]\n```\n\n----------------------------------------\n\nTITLE: Running Ruff with command-line arguments\nDESCRIPTION: This snippet demonstrates how to run Ruff with specific command-line arguments for rule selection and logging level.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nruff check --select F401 --select F403 --quiet\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Context Manager in Python\nDESCRIPTION: Demonstrates a basic implementation of a context manager with __enter__ and __exit__ methods. The type of the target variable in the 'with' statement is inferred from the __enter__ method's return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Target: ...\n\nclass Manager:\n    def __enter__(self) -> Target:\n        return Target()\n\n    def __exit__(self, exc_type, exc_value, traceback): ...\n\nwith Manager() as f:\n    reveal_type(f)  # revealed: Target\n```\n\n----------------------------------------\n\nTITLE: Exit Codes for Ruff Format Command\nDESCRIPTION: This snippet details the exit codes of the `ruff format` command, specifying different termination scenarios based on success and error conditions. It helps users understand the feedback they'll receive when they execute the formatting commands.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n`ruff format` exits with the following status codes:\n\n- `0` if Ruff terminates successfully, regardless of whether any files were formatted.\n- `2` if Ruff terminates abnormally due to invalid configuration, invalid CLI options, or an internal error.\n\nMeanwhile, `ruff format --check` exits with the following status codes:\n\n- `0` if Ruff terminates successfully, and no files would be formatted if `--check` were not specified.\n- `1` if Ruff terminates successfully, and one or more files would be formatted if `--check` were not specified.\n- `2` if Ruff terminates abnormally due to invalid configuration, invalid CLI options, or an internal error.\n```\n\n----------------------------------------\n\nTITLE: Displaying Ruff's 'format' Command Help for Code Formatting\nDESCRIPTION: This snippet shows the full command-line help output for Ruff's 'format' command, used for code formatting. It includes options for checking and diffing changes, file selection, and formatting configuration such as line length and target Python version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nRun the Ruff formatter on the given files or directories\n\nUsage: ruff format [OPTIONS] [FILES]...\n\nArguments:\n  [FILES]...  List of files or directories to format [default: .]\n\nOptions:\n      --check\n          Avoid writing any formatted files back; instead, exit with a non-zero\n          status code if any files would have been modified, and zero otherwise\n      --diff\n          Avoid writing any formatted files back; instead, exit with a non-zero\n          status code and the difference between the current file and how the\n          formatted file would look like\n      --extension <EXTENSION>\n          List of mappings from file extension to language (one of `python`,\n          `ipynb`, `pyi`). For example, to treat `.ipy` files as IPython\n          notebooks, use `--extension ipy:ipynb`\n      --target-version <TARGET_VERSION>\n          The minimum Python version that should be supported [possible values:\n          py37, py38, py39, py310, py311, py312, py313]\n      --preview\n          Enable preview mode; enables unstable formatting. Use `--no-preview`\n          to disable\n  -h, --help\n          Print help (see more with '--help')\n\nMiscellaneous:\n  -n, --no-cache\n          Disable cache reads [env: RUFF_NO_CACHE=]\n      --cache-dir <CACHE_DIR>\n          Path to the cache directory [env: RUFF_CACHE_DIR=]\n      --stdin-filename <STDIN_FILENAME>\n          The name of the file when passing it through stdin\n      --exit-non-zero-on-format\n          Exit with a non-zero status code if any files were modified via\n          format, even if all files were formatted successfully\n\nFile selection:\n      --respect-gitignore\n          Respect file exclusions via `.gitignore` and other standard ignore\n          files. Use `--no-respect-gitignore` to disable\n      --exclude <FILE_PATTERN>\n          List of paths, used to omit files and/or directories from analysis\n      --force-exclude\n          Enforce exclusions, even for paths passed to Ruff directly on the\n          command-line. Use `--no-force-exclude` to disable\n\nFormat configuration:\n      --line-length <LINE_LENGTH>  Set the line-length\n\nEditor options:\n      --range <RANGE>  When specified, Ruff will try to only format the code in\n                       the given range.\n                       It might be necessary to extend the start backwards or\n                       the end forwards, to fully enclose a logical line.\n                       The `<RANGE>` uses the format\n```\n\n----------------------------------------\n\nTITLE: Flexible Descriptor with Different Get/Set Types\nDESCRIPTION: Implementation of a descriptor that handles different types for __get__ and __set__ methods, converting string inputs to integers\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass FlexibleInt:\n    def __init__(self):\n        self._value: int | None = None\n\n    def __get__(self, instance: object, owner: type | None = None) -> int | None:\n        return self._value\n\n    def __set__(self, instance: object, value: int | str) -> None:\n        self._value = int(value)\n\nclass C:\n    flexible_int: FlexibleInt = FlexibleInt()\n\nc = C()\n\nreveal_type(c.flexible_int)  # revealed: int | None\n\nc.flexible_int = 42\nc.flexible_int = \"42\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Context Manager with Type Hints\nDESCRIPTION: Shows implementation of an async context manager with explicit type hints for __aenter__ return value. Demonstrates proper typing pattern for async with statements while highlighting current limitations in type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/async.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Target: ...\n\nclass Manager:\n    async def __aenter__(self) -> Target:\n        return Target()\n\n    async def __aexit__(self, exc_type, exc_value, traceback): ...\n\nasync def test():\n    async with Manager() as f:\n        reveal_type(f)  # revealed: @Todo(async `with` statement)\n```\n\n----------------------------------------\n\nTITLE: Ruff Lint Rule Extension\nDESCRIPTION: Uses TOML within ruff.toml to extend and customize lint rules, selectively enabling new codes such as \"Q\" and configuring specific plugin options like \"flake8-quotes\".\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\n# Add \"Q\" to the list of enabled codes.\nselect = [\"E4\", \"E7\", \"E9\", \"F\", \"Q\"]\n\n[lint.flake8-quotes]\ndocstring-quotes = \"double\"\n\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Variadic Parameters in Python\nDESCRIPTION: Illustrates lambda expressions with variadic (*args) and keyword-variadic (**kwargs) parameters and their type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda *args: args)  # revealed: (*args) -> Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda **kwargs: kwargs)  # revealed: (**kwargs) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Exceptions in Tuple\nDESCRIPTION: Shows how to handle multiple exceptions using tuple syntax, including predefined exception tuples. Demonstrates type checking for multiple exception types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nEXCEPTIONS = (AttributeError, TypeError)\n\ntry:\n    help()\nexcept (RuntimeError, OSError) as e:\n    reveal_type(e)  # revealed: RuntimeError | OSError\nexcept EXCEPTIONS as f:\n    reveal_type(f)  # revealed: AttributeError | TypeError\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Target Version in pyproject.toml\nDESCRIPTION: This snippet demonstrates how to set the target Python version for Ruff in the pyproject.toml file. It uses the 'target-version' setting to specify compatible Python versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/invalid_extension.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Assume Python 3.8+.\ntarget-version = \"py38\"\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Package Managers\nDESCRIPTION: Commands to install Ruff using different package managers like uv, pip, and pipx.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# With uv.\nuv tool install ruff@latest  # Install Ruff globally.\nuv add --dev ruff            # Or add Ruff to your project.\n\n# With pip.\npip install ruff\n\n# With pipx.\npipx install ruff\n```\n\n----------------------------------------\n\nTITLE: Generic Class Definition using PEP 695 Syntax\nDESCRIPTION: Basic generic class definition using modern PEP 695 syntax with type parameter T.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Explicit Super Object Behavior in Python\nDESCRIPTION: Shows how super(pivot_class, owner) performs attribute lookup along the Method Resolution Order (MRO), starting immediately after the specified pivot class. Includes examples of accessible and inaccessible attributes across the inheritance chain.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def a(self): ...\n    aa: int = 1\n\nclass B(A):\n    def b(self): ...\n    bb: int = 2\n\nclass C(B):\n    def c(self): ...\n    cc: int = 3\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[B], Literal[A], Literal[object]]\n\nsuper(C, C()).a\nsuper(C, C()).b\n# error: [unresolved-attribute] \"Type `<super: Literal[C], C>` has no attribute `c`\"\nsuper(C, C()).c\n\nsuper(B, C()).a\n# error: [unresolved-attribute] \"Type `<super: Literal[B], C>` has no attribute `b`\"\nsuper(B, C()).b\n# error: [unresolved-attribute] \"Type `<super: Literal[B], C>` has no attribute `c`\"\nsuper(B, C()).c\n\n# error: [unresolved-attribute] \"Type `<super: Literal[A], C>` has no attribute `a`\"\nsuper(A, C()).a\n# error: [unresolved-attribute] \"Type `<super: Literal[A], C>` has no attribute `b`\"\nsuper(A, C()).b\n# error: [unresolved-attribute] \"Type `<super: Literal[A], C>` has no attribute `c`\"\nsuper(A, C()).c\n\nreveal_type(super(C, C()).a)  # revealed: bound method C.a() -> Unknown\nreveal_type(super(C, C()).b)  # revealed: bound method C.b() -> Unknown\nreveal_type(super(C, C()).aa)  # revealed: int\nreveal_type(super(C, C()).bb)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Basic Decorator Example in Python\nDESCRIPTION: Demonstrates a simple decorator that changes the return type of a function to int.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef custom_decorator(f) -> int:\n    return 1\n\n@custom_decorator\ndef f(x): ...\n\nreveal_type(f)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with Vim-LSP\nDESCRIPTION: Setup configuration for Ruff language server in Vim using the vim-lsp plugin.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_2\n\nLANGUAGE: vim\nCODE:\n```\nif executable('ruff')\n    au User lsp_setup call lsp#register_server({\n        \\ 'name': 'ruff',\n        \\ 'cmd': {server_info->['ruff', 'server']},\n        \\ 'allowlist': ['python'],\n        \\ 'workspace_config': {},\n        \\ })\nendif\n```\n\n----------------------------------------\n\nTITLE: Adding Ruff Badge in HTML\nDESCRIPTION: Code snippet for adding the Ruff badge to a project's documentation using HTML syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_13\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"https://github.com/astral-sh/ruff\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json\" alt=\"Ruff\" style=\"max-width:100%;\"></a>\n```\n\n----------------------------------------\n\nTITLE: Using Ruff as a Formatter\nDESCRIPTION: Commands to run Ruff as a formatter on different file paths and configurations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nruff format                          # Format all files in the current directory (and any subdirectories).\nruff format path/to/code/            # Format all files in `/path/to/code` (and any subdirectories).\nruff format path/to/code/*.py        # Format all `.py` files in `/path/to/code`.\nruff format path/to/code/to/file.py  # Format `file.py`.\nruff format @arguments.txt           # Format using an input file, treating its contents as newline-delimited command-line arguments.\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff in Zed Editor - JSON\nDESCRIPTION: This JSON configuration adds Ruff as a language server in Zed for Python. It specifies language server settings and enables formatting options on save.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"languages\": {\n    \"Python\": {\n      \"language_servers\": [\"ruff\"]\n      // Or, if there are other language servers you want to use with Python\n      // \"language_servers\": [\"pyright\", \"ruff\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Lint Rules in Ruff (TOML)\nDESCRIPTION: Configuration to enable preview lint rules in Ruff using pyproject.toml or ruff.toml. This setting enables preview mode for linting without affecting formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\npreview = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\npreview = true\n```\n\n----------------------------------------\n\nTITLE: Testing Union Type Assignability in Python\nDESCRIPTION: Demonstrates how union types interact with assignability, showing that component types are assignable to their union, unions with compatible components can be assigned to each other, and how Any and Unknown interact with unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import AlwaysTruthy, AlwaysFalsy, static_assert, is_assignable_to, Unknown\nfrom typing_extensions import Literal, Any, LiteralString\n\nstatic_assert(is_assignable_to(int, int | str))\nstatic_assert(is_assignable_to(str, int | str))\nstatic_assert(is_assignable_to(int | str, int | str))\nstatic_assert(is_assignable_to(str | int, int | str))\nstatic_assert(is_assignable_to(Literal[1], int | str))\nstatic_assert(is_assignable_to(Literal[1], Unknown | str))\nstatic_assert(is_assignable_to(Literal[1] | Literal[2], Literal[1] | Literal[2]))\nstatic_assert(is_assignable_to(Literal[1] | Literal[2], int))\nstatic_assert(is_assignable_to(Literal[1] | None, int | None))\nstatic_assert(is_assignable_to(Any, int | str))\nstatic_assert(is_assignable_to(Any | int, int))\nstatic_assert(is_assignable_to(str, int | Any))\n\nstatic_assert(not is_assignable_to(int | None, int))\nstatic_assert(not is_assignable_to(int | None, str | None))\nstatic_assert(not is_assignable_to(Literal[1] | None, int))\nstatic_assert(not is_assignable_to(Literal[1] | None, str | None))\nstatic_assert(not is_assignable_to(Any | int | str, int))\n\n# TODO: No errors\n# error: [static-assert-error]\nstatic_assert(is_assignable_to(bool, Literal[False] | AlwaysTruthy))\n# error: [static-assert-error]\nstatic_assert(is_assignable_to(bool, Literal[True] | AlwaysFalsy))\n# error: [static-assert-error]\nstatic_assert(is_assignable_to(LiteralString, Literal[\"\"] | AlwaysTruthy))\nstatic_assert(not is_assignable_to(Literal[True] | AlwaysFalsy, Literal[False] | AlwaysTruthy))\n```\n\n----------------------------------------\n\nTITLE: Using Ruff Action in GitHub Workflows\nDESCRIPTION: Configuration for using the dedicated ruff-action in GitHub workflows. Shows basic setup and demonstrates passing optional parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/integrations.md#2025-04-17_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nname: Ruff\non: [ push, pull_request ]\njobs:\n  ruff:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: astral-sh/ruff-action@v3\n```\n\nLANGUAGE: yaml\nCODE:\n```\n- uses: astral-sh/ruff-action@v3\n  with:\n    version: 0.8.0\n    args: check --select B\n    src: \"./src\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Comparison for Same Class in Python\nDESCRIPTION: Example showing implementation of all rich comparison dunder methods (__eq__, __ne__, __lt__, __le__, __gt__, __ge__) for comparing instances of the same class type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass EqReturnType: ...\nclass NeReturnType: ...\nclass LtReturnType: ...\nclass LeReturnType: ...\nclass GtReturnType: ...\nclass GeReturnType: ...\n\nclass A:\n    def __eq__(self, other: A) -> EqReturnType:\n        return EqReturnType()\n\n    def __ne__(self, other: A) -> NeReturnType:\n        return NeReturnType()\n\n    def __lt__(self, other: A) -> LtReturnType:\n        return LtReturnType()\n\n    def __le__(self, other: A) -> LeReturnType:\n        return LeReturnType()\n\n    def __gt__(self, other: A) -> GtReturnType:\n        return GtReturnType()\n\n    def __ge__(self, other: A) -> GeReturnType:\n        return GeReturnType()\n\nreveal_type(A() == A())  # revealed: EqReturnType\nreveal_type(A() != A())  # revealed: NeReturnType\nreveal_type(A() < A())  # revealed: LtReturnType\nreveal_type(A() <= A())  # revealed: LeReturnType\nreveal_type(A() > A())  # revealed: GtReturnType\nreveal_type(A() >= A())  # revealed: GeReturnType\n```\n\n----------------------------------------\n\nTITLE: Checking Empty List Type in Python\nDESCRIPTION: Uses reveal_type() to examine the inferred type of an empty list literal. This demonstrates Python's type inference system treating empty lists as generic list type without element type specification.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/collections/list.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type([])  # revealed: list\n```\n\n----------------------------------------\n\nTITLE: Using Ruff as a GitHub Action\nDESCRIPTION: YAML configuration to use Ruff as a GitHub Action for continuous integration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nname: Ruff\non: [ push, pull_request ]\njobs:\n  ruff:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: astral-sh/ruff-action@v3\n```\n\n----------------------------------------\n\nTITLE: Example Python Function Implementation\nDESCRIPTION: Demonstrates a simple Python function that calculates the sum of even numbers from an iterable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\nimport os\n\n\ndef sum_even_numbers(numbers: Iterable[int]) -> int:\n    \"\"\"Given an iterable of integers, return the sum of all even numbers in the iterable.\"\"\"\n    return sum(\n        num for num in numbers\n        if num % 2 == 0\n    )\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Except-Else Block with Multiple Except Clauses\nDESCRIPTION: This snippet shows type inference in a try-except-else block with multiple except clauses. It demonstrates how the final inferred type considers all possible execution paths through the try, multiple except, and else suites.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\nexcept ValueError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 3\n    reveal_type(x)  # revealed: Literal[3]\nelse:\n    reveal_type(x)  # revealed: str\n    x = 4\n    reveal_type(x)  # revealed: Literal[4]\n\nreveal_type(x)  # revealed: Literal[2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with OR Operator\nDESCRIPTION: Demonstrates type narrowing behavior when using the 'or' operator in conditionals\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C: ...\n\ndef _(x: A | B | C):\n    if isinstance(x, A) or isinstance(x, B):\n        reveal_type(x)  # revealed:  A | B\n    else:\n        reveal_type(x)  # revealed:  C & ~A & ~B\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Standalone Installers\nDESCRIPTION: Provides commands for installing Ruff using standalone installers on macOS, Linux, and Windows. It also shows how to install a specific version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ # On macOS and Linux.\n$ curl -LsSf https://astral.sh/ruff/install.sh | sh\n\n$ # On Windows.\n$ powershell -c \"irm https://astral.sh/ruff/install.ps1 | iex\"\n\n$ # For a specific version.\n$ curl -LsSf https://astral.sh/ruff/0.5.0/install.sh | sh\n$ powershell -c \"irm https://astral.sh/ruff/0.5.0/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference for String Literals in Python\nDESCRIPTION: This snippet shows how the `reveal_type()` function is used to display the inferred type of a string literal in Python. It demonstrates that the string \"foo\" is inferred as a Literal type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(\"foo\")  # revealed: Literal[\"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Displaying Ruff's Main Command-Line Interface Help\nDESCRIPTION: This snippet shows the full command-line help output for Ruff, listing all available top-level commands and global options. It includes usage information, available commands, and common options for logging and configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_17\n\nLANGUAGE: text\nCODE:\n```\nRuff: An extremely fast Python linter and code formatter.\n\nUsage: ruff [OPTIONS] <COMMAND>\n\nCommands:\n  check    Run Ruff on the given files or directories\n  rule     Explain a rule (or all rules)\n  config   List or describe the available configuration options\n  linter   List all supported upstream linters\n  clean    Clear any caches in the current directory and any subdirectories\n  format   Run the Ruff formatter on the given files or directories\n  server   Run the language server\n  analyze  Run analysis over Python source code\n  version  Display Ruff's version\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\nLog levels:\n  -v, --verbose  Enable verbose logging\n  -q, --quiet    Print diagnostics, but nothing else\n  -s, --silent   Disable all logging (but still exit with status code \"1\" upon\n                 detecting diagnostics)\n\nGlobal options:\n      --config <CONFIG_OPTION>\n          Either a path to a TOML configuration file (`pyproject.toml` or\n          `ruff.toml`), or a TOML `<KEY> = <VALUE>` pair (such as you might\n          find in a `ruff.toml` configuration file) overriding a specific\n          configuration option. Overrides of individual settings using this\n          option always take precedence over all configuration files, including\n          configuration files that were also specified using `--config`\n      --isolated\n          Ignore all configuration files\n\nFor help with a specific command, see: `ruff help <command>`.\n```\n\n----------------------------------------\n\nTITLE: Typevar Inference Examples\nDESCRIPTION: Examples showing typevar inference with multiple parameters and union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef two_params[T](x: T, y: T) -> T:\n    return x\n\nreveal_type(two_params(\"a\", \"b\"))  # revealed: Literal[\"a\", \"b\"]\nreveal_type(two_params(\"a\", 1))  # revealed: Literal[\"a\", 1]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff for Multiple Python Versions in pyproject.toml\nDESCRIPTION: This example shows how to configure Ruff to work with multiple Python versions in the pyproject.toml file. It uses an array to specify multiple target versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/invalid_extension.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Assume Python 3.7, 3.8, 3.9, 3.10, or 3.11.\ntarget-version = [\"py37\", \"py38\", \"py39\", \"py310\", \"py311\"]\n```\n\n----------------------------------------\n\nTITLE: Annotating Variables with typing.Union in Python\nDESCRIPTION: Demonstrates various ways to declare Union type annotations and how they are interpreted by type checkers. Shows multiple nesting patterns and special cases like Union with None or single types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\na: Union[int, str]\na1: Union[int, bool]\na2: Union[int, Union[bytes, str]]\na3: Union[int, None]\na4: Union[Union[bytes, str]]\na5: Union[int]\na6: Union[()]\n\ndef f():\n    # revealed: int | str\n    reveal_type(a)\n    # Since bool is a subtype of int we simplify to int here. But we do allow assigning boolean values (see below).\n    # revealed: int\n    reveal_type(a1)\n    # revealed: int | bytes | str\n    reveal_type(a2)\n    # revealed: int | None\n    reveal_type(a3)\n    # revealed: bytes | str\n    reveal_type(a4)\n    # revealed: int\n    reveal_type(a5)\n    # revealed: Never\n    reveal_type(a6)\n```\n\n----------------------------------------\n\nTITLE: Initializing Python Project Structure with UV\nDESCRIPTION: Shows the directory structure created by UV when initializing a new Python library project.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nnumbers\n  ├── README.md\n  ├── pyproject.toml\n  └── src\n      └── numbers\n          ├── __init__.py\n          └── py.typed\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff in pyproject.toml\nDESCRIPTION: This snippet shows how to configure Ruff in a pyproject.toml file. It sets the target Python version, selects lint rules, and configures formatting options.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n# Assume Python 3.9\ntarget-version = \"py39\"\n\n[lint]\n# Enable Pyflakes (`F`) and a subset of the pycodestyle (`E`)  codes by default.\nselect = [\"E4\", \"E7\", \"E9\", \"F\"]\nignore = []\n\n# Allow fix for all enabled rules (when `--fix`) is provided.\nfixable = [\"ALL\"]\nunfixable = []\n\n# Allow unused variables when underscore-prefixed.\ndummy-variable-rgx = \"^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$\"\n\n[format]\n# Like Black, use double quotes for strings.\nquote-style = \"double\"\n\n# Like Black, indent with spaces, rather than tabs.\nindent-style = \"space\"\n\n# Like Black, respect magic trailing commas.\nskip-magic-trailing-comma = false\n\n# Like Black, automatically detect the appropriate line ending.\nline-ending = \"auto\"\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Language Server in CLI\nDESCRIPTION: Command to start the Ruff Language Server from the command line. The server listens for requests from code editors and interacts with Ruff's linter and formatter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nruff server\n```\n\n----------------------------------------\n\nTITLE: String Concatenation Formatting: Ruff vs Black\nDESCRIPTION: This snippet showcases how Ruff and Black differ in formatting implicit string concatenations, particularly when line lengths exceed the configured limit. Black tends to split implicit concatenations more aggressively, even if they can fit on a single line, whereas Ruff avoids splitting unless necessary.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(\"aaaaaaaaaaaaaaaa\" \"aaaaaaaaaaaaaaaa\".format(bbbbbbbbbbbbbbbbbb + bbbbbbbbbbbbbbbbbb))\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(\n    \"aaaaaaaaaaaaaaaa\"\n    \"aaaaaaaaaaaaaaaa\".format(bbbbbbbbbbbbbbbbbb + bbbbbbbbbbbbbbbbbb)\n)\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(\n    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".format(bbbbbbbbbbbbbbbbbb + bbbbbbbbbbbbbbbbbb)\n)\n```\n\n----------------------------------------\n\nTITLE: Testing Tuple Type Assignability in Python\nDESCRIPTION: Demonstrates how tuple types can be assigned based on their element types and tuple lengths, showing that tuple[int] is assignable to tuple[Any] but not to tuple[str], and that length mismatches prevent assignability.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, AlwaysTruthy, AlwaysFalsy\nfrom typing import Literal, Any\n\nstatic_assert(is_assignable_to(tuple[()], tuple[()]))\nstatic_assert(is_assignable_to(tuple[int], tuple[int]))\nstatic_assert(is_assignable_to(tuple[int], tuple[Any]))\nstatic_assert(is_assignable_to(tuple[Any], tuple[int]))\nstatic_assert(is_assignable_to(tuple[int, str], tuple[int, str]))\nstatic_assert(is_assignable_to(tuple[Literal[1], Literal[2]], tuple[int, int]))\nstatic_assert(is_assignable_to(tuple[Any, Literal[2]], tuple[int, int]))\nstatic_assert(is_assignable_to(tuple[Literal[1], Any], tuple[int, int]))\nstatic_assert(is_assignable_to(tuple[()], tuple))\nstatic_assert(is_assignable_to(tuple[int, str], tuple))\nstatic_assert(is_assignable_to(tuple[Any], tuple))\n\n# TODO: It is not yet clear if we want the following two assertions to hold.\n# See https://github.com/astral-sh/ruff/issues/15528 for more details. The\n# short version is: We either need to special-case enforcement of the Liskov\n# substitution principle on `__bool__` and `__len__` for tuple subclasses,\n# or we need to negate these assertions.\nstatic_assert(is_assignable_to(tuple[()], AlwaysFalsy))\nstatic_assert(is_assignable_to(tuple[int], AlwaysTruthy))\n\nstatic_assert(not is_assignable_to(tuple[()], tuple[int]))\nstatic_assert(not is_assignable_to(tuple[int], tuple[str]))\nstatic_assert(not is_assignable_to(tuple[int], tuple[int, str]))\nstatic_assert(not is_assignable_to(tuple[int, str], tuple[int]))\nstatic_assert(not is_assignable_to(tuple[int, int], tuple[Literal[1], int]))\nstatic_assert(not is_assignable_to(tuple[Any, Literal[2]], tuple[int, str]))\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Rules in TOML\nDESCRIPTION: Example TOML configuration for selecting and ignoring Ruff linting rules\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nselect = [\"E\", \"F\"]\nignore = [\"F401\"]\n```\n\n----------------------------------------\n\nTITLE: Error Cases and Type Inference with inspect.getattr_static in Python\nDESCRIPTION: This snippet showcases error cases when using inspect.getattr_static, including missing arguments and incorrect argument types. It also demonstrates how type inference falls back to Any when the attribute name is not a literal string.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nclass C:\n    x: int = 1\n\ndef _(attr_name: str):\n    reveal_type(inspect.getattr_static(C(), attr_name))  # revealed: Any\n    reveal_type(inspect.getattr_static(C(), attr_name, 1))  # revealed: Any\n\n# error: [missing-argument] \"No arguments provided for required parameters `obj`, `attr` of function `getattr_static`\"\ninspect.getattr_static()\n\n# error: [missing-argument] \"No argument provided for required parameter `attr`\"\ninspect.getattr_static(C())\n\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `str`, found `Literal[1]`\"\ninspect.getattr_static(C(), 1)\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `getattr_static`: expected 3, got 4\"\ninspect.getattr_static(C(), \"x\", \"default-arg\", \"one too many\")\n```\n\n----------------------------------------\n\nTITLE: GitLab CI/CD Configuration for Ruff\nDESCRIPTION: GitLab CI/CD pipeline configuration that runs Ruff format and check commands in parallel, with codequality report integration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/integrations.md#2025-04-17_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n.base_ruff:\n  stage: build\n  interruptible: true\n  image:\n    name: ghcr.io/astral-sh/ruff:0.11.5-alpine\n  before_script:\n    - cd $CI_PROJECT_DIR\n    - ruff --version\n\nRuff Check:\n  extends: .base_ruff\n  script:\n    - ruff check --output-format=gitlab > code-quality-report.json\n  artifacts:\n    reports:\n      codequality: $CI_PROJECT_DIR/code-quality-report.json\n\nRuff Format:\n  extends: .base_ruff\n  script:\n    - ruff format --diff\n```\n\n----------------------------------------\n\nTITLE: Implementing Callable Instance with Dunder Call Method in Python\nDESCRIPTION: This snippet demonstrates the implementation of a callable instance using the __call__ method. It shows how to create a Multiplier class that can be called like a function and how type checking reveals the return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Multiplier:\n    def __init__(self, factor: int):\n        self.factor = factor\n\n    def __call__(self, number: int) -> int:\n        return number * self.factor\n\na = Multiplier(2)(3)\nreveal_type(a)  # revealed: int\n\nclass Unit: ...\n\nb = Unit()(3.0)  # error: \"Object of type `Unit` is not callable\"\nreveal_type(b)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Simple Type[Any] Usage in Python\nDESCRIPTION: Demonstrates basic usage of type[Any] and type[str] annotations, showing their assignability and type revelation behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/dynamic.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef f(x: type[Any], y: type[str]):\n    reveal_type(x)  # revealed: type[Any]\n    # TODO: could be `<object.__repr__ type> & Any`\n    reveal_type(x.__repr__)  # revealed: Any\n\n    # type[str] and type[Any] are assignable to each other\n    a: type[str] = x\n    b: type[Any] = y\n\nclass A: ...\n\nx: type[Any] = object\nx: type[Any] = type\nx: type[Any] = A\nx: type[Any] = A()  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Boolean Conversion in Python\nDESCRIPTION: This code defines a class 'NotBoolable' with an incorrectly implemented __bool__ method. When an instance of this class is used in a boolean context (like an assertion), it triggers a Ruff linting error due to unsupported boolean conversion.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/assert.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\nassert NotBoolable()\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Package Managers\nDESCRIPTION: Shows how to install Ruff globally or add it to a project using uv, pip, or pipx. It includes commands for different installation methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ # Install Ruff globally.\n$ uv tool install ruff@latest\n\n$ # Or add Ruff to your project.\n$ uv add --dev ruff\n\n$ # With pip.\n$ pip install ruff\n\n$ # With pipx.\n$ pipx install ruff\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff as a pre-commit hook (YAML)\nDESCRIPTION: This YAML configuration integrates Ruff as a pre-commit hook. It specifies the repository, revision (version), and hooks to run (linter and formatter).  This ensures that Ruff is run automatically before each commit, enforcing code style and catching potential errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n- repo: https://github.com/astral-sh/ruff-pre-commit\n  # Ruff version.\n  rev: v0.11.5\n  hooks:\n    # Run the linter.\n    - id: ruff\n    # Run the formatter.\n    - id: ruff-format\n```\n\n----------------------------------------\n\nTITLE: Property Getter Override in Python\nDESCRIPTION: Shows how to use property.getter to override an existing getter while maintaining the setter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def my_property(self) -> int:\n        return 1\n\n    @my_property.setter\n    def my_property(self, value: int) -> None:\n        pass\n\n    @my_property.getter\n    def my_property(self) -> str:\n        return \"a\"\n\nc = C()\nreveal_type(c.my_property)  # revealed: str\nc.my_property = 2\n\n# error: [invalid-assignment]\nc.my_property = \"b\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with Inline Settings - VS Code\nDESCRIPTION: Example of configuring Ruff using inline JSON configuration in VS Code settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.configuration\": {\n        \"lint\": {\n            \"unfixable\": [\"F401\"],\n            \"extend-select\": [\"TID251\"],\n            \"flake8-tidy-imports\": {\n                \"banned-api\": {\n                    \"typing.TypedDict\": {\n                        \"msg\": \"Use `typing_extensions.TypedDict` instead\"\n                    }\n                }\n            }\n        },\n        \"format\": {\n            \"quote-style\": \"single\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Class Inheritance with Type Parameters\nDESCRIPTION: Example of a class inheriting from a generic class while maintaining generic type parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass D[U](C[U]): ...\n```\n\n----------------------------------------\n\nTITLE: Augmenting and Relaxing Docstring Conventions in ruff.toml\nDESCRIPTION: This snippet shows how to augment and relax docstring conventions in Ruff using `ruff.toml`. It demonstrates selecting additional rules (like `D401`) and ignoring specific rules (like `D417`) on top of a chosen `convention`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\n\"[lint]\nselect = [\n    \"D\",\n    # Augment the convention by requiring an imperative mood for all docstrings.\n    \"D401\",\n]\n\nignore = [\n    # Relax the convention by _not_ requiring documentation for every function parameter.\n    \"D417\",\n]\n\n[lint.pydocstyle]\nconvention = \"google\"\"\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Formatting in pyproject.toml\nDESCRIPTION: TOML configuration to exclude Jupyter Notebook files from formatting operations while still allowing linting in pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.format]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Unary Operators in Python Custom Classes\nDESCRIPTION: This code demonstrates how to implement unary operators (+, -, ~) in a custom Python class using dunder methods (__pos__, __neg__, __invert__). It also shows type checking with reveal_type and error handling when these operators are used on classes that don't implement the required dunder methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/invert_add_usub.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Number:\n    def __init__(self, value: int):\n        self.value = 1\n\n    def __pos__(self) -> int:\n        return +self.value\n\n    def __neg__(self) -> int:\n        return -self.value\n\n    def __invert__(self) -> Literal[True]:\n        return True\n\na = Number(0)\n\nreveal_type(+a)  # revealed: int\nreveal_type(-a)  # revealed: int\nreveal_type(~a)  # revealed: Literal[True]\n\nclass NoDunder: ...\n\nb = NoDunder()\n+b  # error: [unsupported-operator] \"Unary operator `+` is unsupported for type `NoDunder`\"\n-b  # error: [unsupported-operator] \"Unary operator `-` is unsupported for type `NoDunder`\"\n~b  # error: [unsupported-operator] \"Unary operator `~` is unsupported for type `NoDunder`\"\n```\n\n----------------------------------------\n\nTITLE: Hierarchical Configuration with Ruff\nDESCRIPTION: Demonstrates how to apply hierarchical configuration in Ruff via pyproject.toml, showing how to extend configurations from parent files while overriding certain parameters like line length.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Extend the `pyproject.toml` file in the parent directory...\nextend = \"../pyproject.toml\"\n\n# ...but use a different line length.\nline-length = 100\n\n```\n\n----------------------------------------\n\nTITLE: Ruff Lint and Format Configuration\nDESCRIPTION: This TOML configuration section details how to set up Ruff using the ruff.toml file for linting and formatting Python code. It includes directory exclusions, lint rules selection, quote styles, and structure indentation settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# Exclude a variety of commonly ignored directories.\nexclude = [\n    \".bzr\",\n    \".direnv\",\n    \".eggs\",\n    \".git\",\n    \".git-rewrite\",\n    \".hg\",\n    \".ipynb_checkpoints\",\n    \".mypy_cache\",\n    \".nox\",\n    \".pants.d\",\n    \".pyenv\",\n    \".pytest_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".svn\",\n    \".tox\",\n    \".venv\",\n    \".vscode\",\n    \"__pypackages__\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"node_modules\",\n    \"site-packages\",\n    \"venv\",\n]\n\n# Same as Black.\nline-length = 88\nindent-width = 4\n\n# Assume Python 3.9\ntarget-version = \"py39\"\n\n[lint]\n# Enable Pyflakes (`F`) and a subset of the pycodestyle (`E`)  codes by default.\n# Unlike Flake8, Ruff doesn't enable pycodestyle warnings (`W`) or\n# McCabe complexity (`C901`) by default.\nselect = [\"E4\", \"E7\", \"E9\", \"F\"]\nignore = []\n\n# Allow fix for all enabled rules (when `--fix`) is provided.\nfixable = [\"ALL\"]\nunfixable = []\n\n# Allow unused variables when underscore-prefixed.\ndummy-variable-rgx = \"^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$\"\n\n[format]\n# Like Black, use double quotes for strings.\nquote-style = \"double\"\n\n# Like Black, indent with spaces, rather than tabs.\nindent-style = \"space\"\n\n# Like Black, respect magic trailing commas.\nskip-magic-trailing-comma = false\n\n# Like Black, automatically detect the appropriate line ending.\nline-ending = \"auto\"\n\n# Enable auto-formatting of code examples in docstrings. Markdown,\n# reStructuredText code/literal blocks and doctests are all supported.\n#\n# This is currently disabled by default, but it is planned for this\n# to be opt-out in the future.\ndocstring-code-format = false\n\n# Set the line length limit used when formatting code snippets in\n# docstrings.\n#\n# This only has an effect when the `docstring-code-format` setting is\n# enabled.\ndocstring-code-line-length = \"dynamic\"\n\n```\n\n----------------------------------------\n\nTITLE: Pre-commit Hook Configuration for Ruff\nDESCRIPTION: Configuration examples for using Ruff with pre-commit hooks, including linting and formatting options with customizable file types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/integrations.md#2025-04-17_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n- repo: https://github.com/astral-sh/ruff-pre-commit\n  # Ruff version.\n  rev: v0.11.5\n  hooks:\n    # Run the linter.\n    - id: ruff\n    # Run the formatter.\n    - id: ruff-format\n```\n\nLANGUAGE: yaml\nCODE:\n```\n- repo: https://github.com/astral-sh/ruff-pre-commit\n  # Ruff version.\n  rev: v0.11.5\n  hooks:\n    # Run the linter.\n    - id: ruff\n      types_or: [ python, pyi ]\n      args: [ --fix ]\n    # Run the formatter.\n    - id: ruff-format\n      types_or: [ python, pyi ]\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with pkgx\nDESCRIPTION: Shows the command to install Ruff using the pkgx package manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ pkgx install ruff\n```\n\n----------------------------------------\n\nTITLE: Configuring Docstring Convention in ruff.toml\nDESCRIPTION: This snippet shows how to configure the docstring convention (e.g., Google, NumPy, PEP 257) in Ruff using `ruff.toml`. It focuses on setting the `convention` option under `[lint.pydocstyle]`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n\"[lint.pydocstyle]\nconvention = \"google\"  # Accepts: \"google\", \"numpy\", or \"pep257\".\"\n```\n\n----------------------------------------\n\nTITLE: Importing and Accessing sys.path in Python\nDESCRIPTION: This snippet imports the sys module and accesses the sys.path attribute, which contains the list of directories Python searches for modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nsys.path\n```\n\n----------------------------------------\n\nTITLE: Function Return Type Validation for Callable Types\nDESCRIPTION: Demonstrates how function return types are validated when assigning to Callable types. Shows a valid assignment when return types match and an invalid assignment that generates a type error when return types are incompatible.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Callable\n\ndef f(x: Any) -> str:\n    return \"\"\n\ndef g(x: Any) -> int:\n    return 1\n\nc: Callable[[Any], str] = f\n\n# error: [invalid-assignment] \"Object of type `def g(x: Any) -> int` is not assignable to `(Any, /) -> str`\"\nc: Callable[[Any], str] = g\n```\n\n----------------------------------------\n\nTITLE: Generating PR Performance Comparison\nDESCRIPTION: Create a comparison of benchmark results between the main branch and a PR using critcmp.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n# On main\ncargo bench -p ruff_benchmark -- --save-baseline=main\n\n# After applying your changes\ncargo bench -p ruff_benchmark -- --save-baseline=pr\n\ncritcmp main pr\n```\n\n----------------------------------------\n\nTITLE: Configuring Docstring Code Formatting in TOML\nDESCRIPTION: Shows how to enable and configure docstring code formatting in Ruff using pyproject.toml and ruff.toml files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.format]\ndocstring-code-format = true\ndocstring-code-line-length = 20\n```\n\nLANGUAGE: toml\nCODE:\n```\n[format]\ndocstring-code-format = true\ndocstring-code-line-length = 20\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Matching Without Wildcard in Python\nDESCRIPTION: This snippet demonstrates pattern matching without a wildcard case. It shows how the absence of a catch-all case can lead to potential unresolved reference errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(target: int):\n    match target:\n        case 1:\n            y = 2\n        case 2:\n            y = 3\n\n    # revealed: Literal[2, 3]\n    # error: [possibly-unresolved-reference]\n    reveal_type(y)\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Linting in ruff.toml\nDESCRIPTION: TOML configuration to exclude Jupyter Notebook files from linting operations while still allowing formatting in ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Super Objects in Python\nDESCRIPTION: Demonstrates the implicit super() form which is equivalent to super(__class__, <first argument>). Shows how it behaves in instance methods and class methods, and exposes its type behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass A:\n    def __init__(self, a: int): ...\n    @classmethod\n    def f(cls): ...\n\nclass B(A):\n    def __init__(self, a: int):\n        # TODO: Once `Self` is supported, this should be `<super: Literal[B], B>`\n        reveal_type(super())  # revealed: <super: Literal[B], Unknown>\n        super().__init__(a)\n\n    @classmethod\n    def f(cls):\n        # TODO: Once `Self` is supported, this should be `<super: Literal[B], Literal[B]>`\n        reveal_type(super())  # revealed: <super: Literal[B], Unknown>\n        super().f()\n\nsuper(B, B(42)).__init__(42)\nsuper(B, B).f()\n```\n\n----------------------------------------\n\nTITLE: Examples of Fully-static Types in Python\nDESCRIPTION: Demonstrates various Python types that are considered fully-static because they don't contain any gradual forms. The `is_fully_static` function is used to verify these types, with `static_assert` confirming each case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_fully_static.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString, Never, Callable\nfrom knot_extensions import Intersection, Not, TypeOf, is_fully_static, static_assert\n\nstatic_assert(is_fully_static(Never))\nstatic_assert(is_fully_static(None))\n\nstatic_assert(is_fully_static(Literal[1]))\nstatic_assert(is_fully_static(Literal[True]))\nstatic_assert(is_fully_static(Literal[\"abc\"]))\nstatic_assert(is_fully_static(Literal[b\"abc\"]))\n\nstatic_assert(is_fully_static(LiteralString))\n\nstatic_assert(is_fully_static(str))\nstatic_assert(is_fully_static(object))\nstatic_assert(is_fully_static(type))\n\nstatic_assert(is_fully_static(TypeOf[str]))\nstatic_assert(is_fully_static(TypeOf[Literal]))\n\nstatic_assert(is_fully_static(str | None))\nstatic_assert(is_fully_static(Intersection[str, Not[LiteralString]]))\n\nstatic_assert(is_fully_static(tuple[()]))\nstatic_assert(is_fully_static(tuple[int, object]))\n\nstatic_assert(is_fully_static(type[str]))\nstatic_assert(is_fully_static(type[object]))\n```\n\n----------------------------------------\n\nTITLE: Testing Type Disjointness in Python\nDESCRIPTION: Demonstrates the use of is_disjoint_from to check if types are mutually exclusive. Shows examples with None, int, and Literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_disjoint_from, static_assert\nfrom typing import Literal\n\nstatic_assert(is_disjoint_from(None, int))\nstatic_assert(not is_disjoint_from(Literal[2] | str, int))\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff as a pre-commit Hook\nDESCRIPTION: YAML configuration to use Ruff as a pre-commit hook for linting and formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n- repo: https://github.com/astral-sh/ruff-pre-commit\n  # Ruff version.\n  rev: v0.11.5\n  hooks:\n    # Run the linter.\n    - id: ruff\n      args: [ --fix ]\n    # Run the formatter.\n    - id: ruff-format\n```\n\n----------------------------------------\n\nTITLE: Generic Dataclass Implementation\nDESCRIPTION: Shows implementation of generic dataclasses with type parameters and validation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass DataWithDescription[T]:\n    data: T\n    description: str\n\nreveal_type(DataWithDescription[int])  # revealed: Literal[DataWithDescription[int]]\n\nd_int = DataWithDescription[int](1, \"description\")  # OK\nreveal_type(d_int.data)  # revealed: int\nreveal_type(d_int.description)  # revealed: str\n\n# TODO: should be an error: wrong argument type\nDataWithDescription[int](None, \"description\")\n```\n\n----------------------------------------\n\nTITLE: TypeVarTuple Usage with Starred Expression Annotations\nDESCRIPTION: Demonstrates how to use TypeVarTuple to create type-safe variadic functions with starred expressions. The function append_int takes variable arguments and returns a tuple containing the input arguments plus an integer.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/starred.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypeVarTuple\n\nTs = TypeVarTuple(\"Ts\")\n\ndef append_int(*args: *Ts) -> tuple[*Ts, int]:\n    # TODO: tuple[*Ts]\n    reveal_type(args)  # revealed: tuple\n\n    return (*args, 1)\n\n# TODO should be tuple[Literal[True], Literal[\"a\"], int]\nreveal_type(append_int(True, \"a\"))  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Rule Violations in a File\nDESCRIPTION: Demonstrates how to ignore a specific rule (F841 unused variable) across an entire Python file by using the 'ruff: noqa:' directive with the specific rule code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# ruff: noqa: F841\n```\n\n----------------------------------------\n\nTITLE: Legacy Generic Class Definition\nDESCRIPTION: Generic class definition using legacy syntax with typing.Generic and TypeVar.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n# TODO: no error\n# error: [invalid-base]\nclass C(Generic[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff using ruff.toml\nDESCRIPTION: Example of Ruff configuration using the alternative ruff.toml file format. This format allows omitting the [tool.ruff] section header while maintaining the same functionality as pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\nline-length = 88\n\n[lint.pydocstyle]\nconvention = \"google\"\n```\n\n----------------------------------------\n\nTITLE: Non-Generic Class Inheritance with Concrete Type\nDESCRIPTION: Example of a class inheriting from a generic class with a concrete type parameter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass E(C[int]): ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with pyproject.toml for requires-python\nDESCRIPTION: Example TOML configuration showing how to specify the Python version requirement in a pyproject.toml file through the requires-python field.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Configuration options here\n\n[project]\nrequires-python = \">=3.8\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Descriptor with Type Hints\nDESCRIPTION: Example of a basic descriptor class 'Ten' that returns a constant value, demonstrating __get__ and __set__ methods with type hints\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Ten:\n    def __get__(self, instance: object, owner: type | None = None) -> Literal[10]:\n        return 10\n\n    def __set__(self, instance: object, value: Literal[10]) -> None:\n        pass\n\nclass C:\n    ten: Ten = Ten()\n\nc = C()\n\nreveal_type(c.ten)  # revealed: Literal[10]\n\nreveal_type(C.ten)  # revealed: Literal[10]\n\n# This is fine:\nc.ten = 10\n\n# error: [invalid-assignment]\nc.ten = 11\n```\n\n----------------------------------------\n\nTITLE: Ignoring All Violations in a File with ruff: noqa\nDESCRIPTION: Shows how to ignore all linting violations throughout an entire Python file by adding a single 'ruff: noqa' directive, typically at the top of the file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# ruff: noqa\n```\n\n----------------------------------------\n\nTITLE: Enabling Docstring Rules and Convention in ruff.toml\nDESCRIPTION: This snippet demonstrates enabling docstring rules and setting a convention in `ruff.toml`. It shows how to select the `D` rule prefix and configure the `convention` for `pydocstyle`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n\"[lint]\nselect = [\"D\"]\n\n[lint.pydocstyle]\nconvention = \"google\"\"\n```\n\n----------------------------------------\n\nTITLE: Customizing Ruff with Additional Lint Rules\nDESCRIPTION: TOML configuration using pyproject.toml for enabling additional lint codes with Ruff, excluding specific violations, and setting per-file ignore rules. It allows selective enforcement of lint rules such as 'flake8-bugbear' and customization of quote styles.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\n# 1. Enable flake8-bugbear (`B`) rules, in addition to the defaults.\nselect = [\"E4\", \"E7\", \"E9\", \"F\", \"B\"]\n\n# 2. Avoid enforcing line-length violations (`E501`)\nignore = [\"E501\"]\n\n# 3. Avoid trying to fix flake8-bugbear (`B`) violations.\nunfixable = [\"B\"]\n\n# 4. Ignore `E402` (import violations) in all `__init__.py` files, and in selected subdirectories.\n[tool.ruff.lint.per-file-ignores]\n\"__init__.py\" = [\"E402\"]\n\"**/{tests,docs,tools}/*\" = [\"E402\"]\n\n[tool.ruff.format]\n# 5. Use single quotes in `ruff format`.\nquote-style = \"single\"\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff in Emacs via Eglot - Elisp\nDESCRIPTION: This Elisp code snippet sets up Ruff as the language server for Python mode in Emacs using Eglot. It includes hooks for ensuring Eglot starts and for auto formatting on save.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_6\n\nLANGUAGE: elisp\nCODE:\n```\n(add-hook 'python-mode-hook 'eglot-ensure)\n(with-eval-after-load 'eglot\n  (add-to-list 'eglot-server-programs\n               '(python-mode . (\"ruff\" \"server\")))\n  (add-hook 'after-save-hook 'eglot-format))\n```\n\n----------------------------------------\n\nTITLE: Configuring First-Party Sources in ruff.toml\nDESCRIPTION: This snippet demonstrates the equivalent configuration in a `ruff.toml` file.  It also specifies the \"src\" directory as the primary location for resolving first-party imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n\"# Ruff supports a top-level `src` option in lieu of isort's `src_paths` setting.\n# All paths are relative to the project root, which is the directory containing the pyproject.toml.\nsrc = [\"src\"]\"\n```\n\n----------------------------------------\n\nTITLE: Testing Intersection Type Behaviors in Python Type System\nDESCRIPTION: Demonstrates intersection type behaviors between parent/child classes, unrelated types, and interaction with Any type. Shows type assignability rules and edge cases using static assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Intersection, Not, AlwaysTruthy, AlwaysFalsy\nfrom typing_extensions import Any, Literal, final, LiteralString\n\nclass Parent: ...\nclass Child1(Parent): ...\nclass Child2(Parent): ...\nclass Grandchild(Child1, Child2): ...\nclass Unrelated: ...\n\nstatic_assert(is_assignable_to(Intersection[Child1, Child2], Child1))\nstatic_assert(is_assignable_to(Intersection[Child1, Child2], Child2))\nstatic_assert(is_assignable_to(Intersection[Child1, Child2], Parent))\nstatic_assert(is_assignable_to(Intersection[Child1, Parent], Parent))\n\n# Additional assertions...\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Operations on Union Types in Python\nDESCRIPTION: This snippet demonstrates how unsupported operations on union types are handled. It shows that a diagnostic is emitted if any of the possible comparisons is unsupported, and the result type falls back to 'bool'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/unions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = [1, 2] if flag else 1\n\n    result = 1 in x  # error: \"Operator `in` is not supported\"\n    reveal_type(result)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff for Emacs Flymake - Elisp\nDESCRIPTION: This Elisp snippet sets up Flymake in Emacs for linting with Ruff. It adds Ruff to the Python mode hook to automatically load the linter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_7\n\nLANGUAGE: elisp\nCODE:\n```\n(require 'flymake-ruff)\n(add-hook 'python-mode-hook #'flymake-ruff-load)\n```\n\n----------------------------------------\n\nTITLE: Decorated Function Call Type Checking in Python\nDESCRIPTION: Shows a decorated function call with type checking, where the decorator changes the return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef foo() -> int:\n    return 42\n\ndef decorator(func) -> Callable[[], int]:\n    return foo\n\n@decorator\ndef bar() -> str:\n    return \"bar\"\n\nreveal_type(bar())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Possibly Undeclared and Possibly Unbound Symbol Usage in Python\nDESCRIPTION: Demonstrates type inference for possibly undeclared and possibly unbound symbols, showing how possibly-unbound-import errors are raised.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef flag() -> bool:\n    return True\n\nif flag():\n    a: Any = 1\n    b = 2\nelse:\n    b: str\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: [possibly-unbound-import]\n# error: [possibly-unbound-import]\nfrom mod import a, b\n\nreveal_type(a)  # revealed: Literal[1] | Any\nreveal_type(b)  # revealed: Literal[2] | str\n\n# External modifications of `b` that violate the declared type are not allowed:\n# error: [invalid-assignment]\nb = None\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Ruff WASM for Python Linting and Formatting in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize the Ruff WASM module, create a workspace with custom settings, and use it to check and format Python code. It imports necessary types, sets up a sample Python document, and shows how to configure Ruff settings for linting and formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_wasm/README.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport init, { Workspace, type Diagnostic } from '@astral-sh/ruff-api';\n\nconst exampleDocument = `print('hello'); print(\"world\")`\n\nawait init(); // Initializes WASM module\n\n// These are default settings just to illustrate configuring Ruff\n// Settings info: https://docs.astral.sh/ruff/settings\nconst workspace = new Workspace({\n  'line-length': 88,\n  'indent-width': 4,\n  format: {\n    'indent-style': 'space',\n    'quote-style': 'double',\n  },\n  lint: {\n    select: [\n      'E4',\n      'E7',\n      'E9',\n      'F'\n    ],\n  },\n});\n\n// Will contain 1 diagnostic code for E702: Multiple statements on one line\nconst diagnostics: Diagnostic[] = workspace.check(exampleDocument);\n\nconst formatted = workspace.format(exampleDocument);\n```\n\n----------------------------------------\n\nTITLE: Implementing __contains__ Method for Membership Tests in Python\nDESCRIPTION: Demonstrates a class implementing the __contains__ method to support membership tests with the 'in' and 'not in' operators. Shows type checking behavior with both compatible and incompatible types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __contains__(self, item: str) -> bool:\n        return True\n\nreveal_type(\"hello\" in A())  # revealed: bool\nreveal_type(\"hello\" not in A())  # revealed: bool\n# error: [unsupported-operator] \"Operator `in` is not supported for types `int` and `A`, in comparing `Literal[42]` with `A`\"\nreveal_type(42 in A())  # revealed: bool\n# error: [unsupported-operator] \"Operator `not in` is not supported for types `int` and `A`, in comparing `Literal[42]` with `A`\"\nreveal_type(42 not in A())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Demonstrating float annotation accepting int values\nDESCRIPTION: Shows how Python type checkers allow passing an int value to a function expecting a float parameter, as 'float' annotation is interpreted as 'int | float'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/int_float_complex.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef takes_float(x: float):\n    pass\n\ndef passes_int_to_float(x: int):\n    # no error!\n    takes_float(x)\n```\n\n----------------------------------------\n\nTITLE: Understanding Implicit Super in Complex Nested Structures\nDESCRIPTION: Shows how implicit super() works in complex nested class structures, demonstrating type resolution in nested classes, inner functions, and lambdas.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass A:\n    def test(self):\n        reveal_type(super())  # revealed: <super: Literal[A], Unknown>\n\n    class B:\n        def test(self):\n            reveal_type(super())  # revealed: <super: Literal[B], Unknown>\n\n            class C(A.B):\n                def test(self):\n                    reveal_type(super())  # revealed: <super: Literal[C], Unknown>\n\n            def inner(t: C):\n                reveal_type(super())  # revealed: <super: Literal[B], C>\n            lambda x: reveal_type(super())  # revealed: <super: Literal[B], Unknown>\n```\n\n----------------------------------------\n\nTITLE: Formatting Python Code with Ruff\nDESCRIPTION: Shows an example of how Ruff formats Python code, demonstrating its adherence to Black's code style.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Input\ndef _make_ssl_transport(\n    rawsock, protocol, sslcontext, waiter=None,\n    *, server_side=False, server_hostname=None,\n    extra=None, server=None,\n    ssl_handshake_timeout=None,\n    call_connection_made=True):\n    '''Make an SSL transport.'''\n    if waiter is None:\n      waiter = Future(loop=loop)\n\n    if extra is None:\n      extra = {}\n\n    ...\n\n# Ruff\ndef _make_ssl_transport(\n    rawsock,\n    protocol,\n    sslcontext,\n    waiter=None,\n    *,\n    server_side=False,\n    server_hostname=None,\n    extra=None,\n    server=None,\n    ssl_handshake_timeout=None,\n    call_connection_made=True,\n):\n    \"\"\"Make an SSL transport.\"\"\"\n    if waiter is None:\n        waiter = Future(loop=loop)\n\n    if extra is None:\n        extra = {}\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Complex Boolean Expression Type Narrowing\nDESCRIPTION: Shows type narrowing with complex boolean expressions involving multiple operators and nested conditions\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str | None, y: str | None):\n    if x is None and y is not x:\n        reveal_type(y)  # revealed: str\n\n    if x is None:\n        reveal_type(y)  # revealed: str | None\n\n    if y is not x:\n        reveal_type(y)  # revealed: str | None\n```\n\n----------------------------------------\n\nTITLE: Handling Single Exceptions with Type Checking\nDESCRIPTION: Demonstrates handling individual exceptions with type checking annotations. Shows handling of NameError and re.error with type revelation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport re\n\ntry:\n    help()\nexcept NameError as e:\n    reveal_type(e)  # revealed: NameError\nexcept re.error as f:\n    reveal_type(f)  # revealed: error\n```\n\n----------------------------------------\n\nTITLE: Partial Deferred Type Resolution in Python\nDESCRIPTION: Demonstrates using a union type where one part is a direct reference and the other is a string annotation referring to a later-defined class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(v: int | \"Foo\"):\n    reveal_type(v)  # revealed: int | Foo\n\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Format Exclusions for .pyi Files in pyproject.toml\nDESCRIPTION: TOML configuration to exclude .pyi files from formatting while still including them in linting using pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.format]\nexclude = [\"*.pyi\"]\n```\n\n----------------------------------------\n\nTITLE: Dynamic Exception Type Handling\nDESCRIPTION: Demonstrates handling of dynamically defined exception types using type annotations. Shows type checking with various exception type configurations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo(\n    x: type[AttributeError],\n    y: tuple[type[OSError], type[RuntimeError]],\n    z: tuple[type[BaseException], ...],\n):\n    try:\n        help()\n    except x as e:\n        reveal_type(e)  # revealed: AttributeError\n    except y as f:\n        reveal_type(f)  # revealed: OSError | RuntimeError\n    except z as g:\n        # TODO: should be `BaseException`\n        reveal_type(g)  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Comment Association in Expressions: Ruff vs Black\nDESCRIPTION: This snippet demonstrates how Ruff and Black differ in associating own-line comments within expressions. Black associates the comment with the immediately following variable, potentially splitting the expression, while Ruff associates the comment with the entire boolean expression, preserving the initial formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n(\n    # A comment in the middle\n    some_example_var and some_example_var not in some_example_var\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n(\n    # A comment in the middle\n    some_example_var\n    and some_example_var not in some_example_var\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n(\n    # A comment in the middle\n    some_example_var and some_example_var not in some_example_var\n)\n```\n\n----------------------------------------\n\nTITLE: Running Ruff with nbQA on a Jupyter Notebook\nDESCRIPTION: This snippet demonstrates how to run Ruff on a Jupyter Notebook using nbQA. It shows the command-line invocation and an example of the output, including identified errors and fixable issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n\"$ nbqa ruff Untitled.ipynb\nUntitled.ipynb:cell_1:2:5: F841 Local variable `x` is assigned to but never used\nUntitled.ipynb:cell_2:1:1: E402 Module level import not at top of file\nUntitled.ipynb:cell_2:1:8: F401 `os` imported but unused\nFound 3 errors.\n1 potentially fixable with the --fix option.\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Reflected Binary Operations in Python Subclasses\nDESCRIPTION: Demonstrates how reflected binary operation methods (r-methods) in subclasses interact with the regular binary operation methods from parent classes. Shows how the Sub class implements reflected methods that override the behavior of the Yes superclass.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Yes:\n    def __add__(self, other) -> Literal[\"+\"]:\n        return \"+\"\n\n    def __sub__(self, other) -> Literal[\"-\"]:\n        return \"-\"\n\n    def __mul__(self, other) -> Literal[\"*\"]:\n        return \"*\"\n\n    def __matmul__(self, other) -> Literal[\"@\"]:\n        return \"@\"\n\n    def __truediv__(self, other) -> Literal[\"/\"]:\n        return \"/\"\n\n    def __mod__(self, other) -> Literal[\"%\"]:\n        return \"%\"\n\n    def __pow__(self, other) -> Literal[\"**\"]:\n        return \"**\"\n\n    def __lshift__(self, other) -> Literal[\"<<\"]:\n        return \"<<\"\n\n    def __rshift__(self, other) -> Literal[\">>\"]:\n        return \">>\"\n\n    def __or__(self, other) -> Literal[\"|\"]:\n        return \"|\"\n\n    def __xor__(self, other) -> Literal[\"^\"]:\n        return \"^\"\n\n    def __and__(self, other) -> Literal[\"&\"]:\n        return \"&\"\n\n    def __floordiv__(self, other) -> Literal[\"//\"]:\n        return \"//\"\n\nclass Sub(Yes):\n    def __radd__(self, other) -> Literal[\"r+\"]:\n        return \"r+\"\n\n    def __rsub__(self, other) -> Literal[\"r-\"]:\n        return \"r-\"\n\n    def __rmul__(self, other) -> Literal[\"r*\"]:\n        return \"r*\"\n\n    def __rmatmul__(self, other) -> Literal[\"r@\"]:\n        return \"r@\"\n\n    def __rtruediv__(self, other) -> Literal[\"r/\"]:\n        return \"r/\"\n\n    def __rmod__(self, other) -> Literal[\"r%\"]:\n        return \"r%\"\n\n    def __rpow__(self, other) -> Literal[\"r**\"]:\n        return \"r**\"\n\n    def __rlshift__(self, other) -> Literal[\"r<<\"]:\n        return \"r<<\"\n\n    def __rrshift__(self, other) -> Literal[\"r>>\"]:\n        return \"r>>\"\n\n    def __ror__(self, other) -> Literal[\"r|\"]:\n        return \"r|\"\n\n    def __rxor__(self, other) -> Literal[\"r^\"]:\n        return \"r^\"\n\n    def __rand__(self, other) -> Literal[\"r&\"]:\n        return \"r&\"\n\n    def __rfloordiv__(self, other) -> Literal[\"r//\"]:\n        return \"r//\"\n\nclass No:\n    def __radd__(self, other) -> Literal[\"r+\"]:\n        return \"r+\"\n\n    def __rsub__(self, other) -> Literal[\"r-\"]:\n        return \"r-\"\n\n    def __rmul__(self, other) -> Literal[\"r*\"]:\n        return \"r*\"\n\n    def __rmatmul__(self, other) -> Literal[\"r@\"]:\n        return \"r@\"\n\n    def __rtruediv__(self, other) -> Literal[\"r/\"]:\n        return \"r/\"\n\n    def __rmod__(self, other) -> Literal[\"r%\"]:\n        return \"r%\"\n\n    def __rpow__(self, other) -> Literal[\"r**\"]:\n        return \"r**\"\n\n    def __rlshift__(self, other) -> Literal[\"r<<\"]:\n        return \"r<<\"\n\n    def __rrshift__(self, other) -> Literal[\"r>>\"]:\n        return \"r>>\"\n\n    def __ror__(self, other) -> Literal[\"r|\"]:\n        return \"r|\"\n\n    def __rxor__(self, other) -> Literal[\"r^\"]:\n        return \"r^\"\n\n    def __rand__(self, other) -> Literal[\"r&\"]:\n        return \"r&\"\n\n    def __rfloordiv__(self, other) -> Literal[\"r//\"]:\n        return \"r//\"\n```\n\n----------------------------------------\n\nTITLE: Running Ruff CLI Commands\nDESCRIPTION: Examples of basic Ruff CLI usage for linting Python files with various options\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ ruff check                  # Lint files in the current directory.\n$ ruff check --fix            # Lint files in the current directory and fix any fixable errors.\n$ ruff check --watch          # Lint files in the current directory and re-lint on change.\n$ ruff check path/to/code/    # Lint files in `path/to/code`.\n```\n\n----------------------------------------\n\nTITLE: Performing Numpy Array Operations in Python\nDESCRIPTION: This snippet imports Numpy and performs array operations including creating a range, squaring elements, summing, and calculating the median. It demonstrates basic Numpy functionality for numerical computations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/unformatted.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy\nmaths = (numpy.arange(100)**2).sum()\nstats= numpy.asarray([1,2,3,4]).median()\n```\n\n----------------------------------------\n\nTITLE: Method Calls on Unions in Python\nDESCRIPTION: Demonstrates method calls on union types, showing how type inference handles methods on different classes in a union.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nclass A:\n    def f(self) -> int:\n        return 1\n\nclass B:\n    def f(self) -> str:\n        return \"a\"\n\ndef f(a_or_b: A | B, any_or_a: Any | A):\n    reveal_type(a_or_b.f)  # revealed: (bound method A.f() -> int) | (bound method B.f() -> str)\n    reveal_type(a_or_b.f())  # revealed: int | str\n\n    reveal_type(any_or_a.f)  # revealed: Any | (bound method A.f() -> int)\n    reveal_type(any_or_a.f())  # revealed: Any | int\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with File Path - Neovim\nDESCRIPTION: Example of configuring Ruff using a configuration file path in Neovim settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    configuration = \"~/path/to/ruff.toml\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Completely Disabling Jupyter Notebook Support in ruff.toml\nDESCRIPTION: TOML configuration to completely exclude Jupyter Notebook files from both linting and formatting operations in ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\nextend-exclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Formatting in ruff.toml\nDESCRIPTION: TOML configuration to exclude Jupyter Notebook files from formatting operations while still allowing linting in ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[format]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Running Ruff linter from repository root on a multi-package project\nDESCRIPTION: This command demonstrates running the Ruff linter from the repository root directory, which should correctly pick up and enforce the appropriate settings for each package in the project structure.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n∴ cargo run -p ruff -- check crates/ruff_linter/resources/test/project/\ncrates/ruff_linter/resources/test/project/examples/.dotfiles/script.py:1:1: I001 [*] Import block is un-sorted or un-formatted\ncrates/ruff_linter/resources/test/project/examples/.dotfiles/script.py:1:8: F401 [*] `numpy` imported but unused\ncrates/ruff_linter/resources/test/project/examples/.dotfiles/script.py:2:17: F401 [*] `app.app_file` imported but unused\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:8:5: F841 [*] Local variable `x` is assigned to but never used\ncrates/ruff_linter/resources/test/project/project/file.py:1:8: F401 [*] `os` imported but unused\ncrates/ruff_linter/resources/test/project/project/import_file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\nFound 7 errors.\n[*] 7 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Adding noqa directives for specific rules in Ruff (console)\nDESCRIPTION: This command adds `# noqa` directives to all existing violations of a specific rule (e.g., `UP035`) in the codebase. This allows developers to focus on enforcing the rule going forward without addressing pre-existing violations. It uses the `--select` flag to specify the rule and `--add-noqa` to add the directives.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ uv run ruff check --select UP035 --add-noqa .\nAdded 1 noqa directive.\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff on Arch Linux\nDESCRIPTION: Provides the command to install Ruff on Arch Linux using the pacman package manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ pacman -S ruff\n```\n\n----------------------------------------\n\nTITLE: Completely Disabling Jupyter Notebook Support in pyproject.toml\nDESCRIPTION: TOML configuration to completely exclude Jupyter Notebook files from both linting and formatting operations in pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nextend-exclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Testing Equivalence of Callable Types with Default Values\nDESCRIPTION: This code tests equivalence between callable types with default parameter values. It demonstrates that for equivalence, the presence of default values matters, but their actual values do not. Two callables are equivalent if they have the same structure of parameters with defaults.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, is_equivalent_to, static_assert\nfrom typing import Callable\n\ndef f1(a: int = 1) -> None: ...\ndef f2(a: int = 2) -> None: ...\n\nstatic_assert(is_equivalent_to(CallableTypeOf[f1], CallableTypeOf[f2]))\nstatic_assert(is_equivalent_to(CallableTypeOf[f1] | bool | CallableTypeOf[f2], CallableTypeOf[f2] | bool | CallableTypeOf[f1]))\n```\n\n----------------------------------------\n\nTITLE: Exception Cause Handling\nDESCRIPTION: Shows examples of exception chaining with 'raise from' syntax. Includes valid and invalid cases of exception cause specification.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    try:\n        raise EOFError() from GeneratorExit  # fine\n    except:\n        ...\n\ndef _():\n    try:\n        raise StopIteration from MemoryError()  # fine\n    except:\n        ...\n\ndef _():\n    try:\n        raise BufferError() from None  # fine\n    except:\n        ...\n\ndef _():\n    try:\n        raise ZeroDivisionError from False  # error: [invalid-raise]\n    except:\n        ...\n\ndef _():\n    try:\n        raise SystemExit from bool()  # error: [invalid-raise]\n    except:\n        ...\n\ndef _():\n    try:\n        raise\n    except KeyboardInterrupt as e:  # fine\n        reveal_type(e)  # revealed: KeyboardInterrupt\n        raise LookupError from e  # fine\n\ndef _():\n    try:\n        raise\n    except int as e:  # error: [invalid-exception-caught]\n        reveal_type(e)  # revealed: Unknown\n        raise KeyError from e\n\ndef _(e: Exception | type[Exception]):\n    raise ModuleNotFoundError from e  # fine\n\ndef _(e: Exception | type[Exception] | None):\n    raise IndexError from e  # fine\n\ndef _(e: int | None):\n    raise IndexError from e  # error: [invalid-raise]\n```\n\n----------------------------------------\n\nTITLE: Running ruff-ecosystem check\nDESCRIPTION: This command executes the ruff-ecosystem tool in check mode, comparing the output of the system Ruff executable against a debug build located at ./target/debug/ruff. It helps identify differences in linting behavior between the two versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem check ruff \"./target/debug/ruff\"\n```\n\n----------------------------------------\n\nTITLE: Custom Dunder Methods for Augmented Assignment\nDESCRIPTION: Shows implementation of custom __isub__ and __iadd__ dunder methods to override augmented assignment behavior. Demonstrates type checking with custom return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __isub__(self, other: int) -> str:\n        return \"Hello, world!\"\n\nx = C()\nx -= 1\nreveal_type(x)  # revealed: str\n\nclass C:\n    def __iadd__(self, other: str) -> int:\n        return 1\n\nx = C()\nx += \"Hello\"\nreveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Running Ruff with uvx in Shell\nDESCRIPTION: Demonstrates how to invoke Ruff directly using uvx for linting and formatting files in the current directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuvx ruff check   # Lint all files in the current directory.\nuvx ruff format  # Format all files in the current directory.\n```\n\n----------------------------------------\n\nTITLE: Running ruff-ecosystem format\nDESCRIPTION: This command runs the ruff-ecosystem tool in format mode, comparing the output of the system Ruff executable against a debug build located at ./target/debug/ruff. This is useful for verifying consistent formatting behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem format ruff \"./target/debug/ruff\"\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in `else` branch in Python\nDESCRIPTION: This function demonstrates how a `raise` statement within the `else` branch of an `if` statement inside a `try` block affects variable visibility in the `except`, `else`, and `finally` clauses. The function uses `reveal_type` to show the possible types of `x` based on whether the exception is raised.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_else_branch(cond: bool):\n    x = \"before\"\n    try:\n        if cond:\n            x = \"else\"\n            reveal_type(x)  # revealed: Literal[\"else\"]\n        else:\n            x = \"raise\"\n            reveal_type(x)  # revealed: Literal[\"raise\"]\n            raise ValueError\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise\"]\n```\n\n----------------------------------------\n\nTITLE: Recursive Descriptor Protocol Implementation\nDESCRIPTION: Demonstrates complex recursive descriptor protocol implementation where __get__ lookups trigger the descriptor protocol on callable's __call__ method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass ReturnedCallable2:\n    def __call__(self, descriptor: Descriptor1, instance: None, owner: type[C]) -> int:\n        return 1\n\nclass ReturnedCallable1:\n    def __call__(self, descriptor: Descriptor2, instance: Callable1, owner: type[Callable1]) -> ReturnedCallable2:\n        return ReturnedCallable2()\n\nclass Callable3:\n    def __call__(self, descriptor: Descriptor3, instance: Callable2, owner: type[Callable2]) -> ReturnedCallable1:\n        return ReturnedCallable1()\n\nclass Descriptor3:\n    __get__: Callable3 = Callable3()\n\nclass Callable2:\n    __call__: Descriptor3 = Descriptor3()\n\nclass Descriptor2:\n    __get__: Callable2 = Callable2()\n\nclass Callable1:\n    __call__: Descriptor2 = Descriptor2()\n\nclass Descriptor1:\n    __get__: Callable1 = Callable1()\n\nclass C:\n    d: Descriptor1 = Descriptor1()\n```\n\n----------------------------------------\n\nTITLE: Basic Augmented Assignment Operations in Python\nDESCRIPTION: Demonstrates basic augmented assignment operations with different data types including integers, floats, and tuples. Shows type inference results for each operation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 3\nx -= 1\nreveal_type(x)  # revealed: Literal[2]\n\nx = 1.0\nx /= 2\nreveal_type(x)  # revealed: int | float\n\nx = (1, 2)\nx += (3, 4)\nreveal_type(x)  # revealed: tuple[Literal[1], Literal[2], Literal[3], Literal[4]]\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation of ExprList Formatter\nDESCRIPTION: Rust code implementing formatting logic for Python expression lists, handling dangling comments through custom formatting rules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nimpl FormatNodeRule<ExprList> for FormatExprList {\n    fn fmt_fields(&self, item: &ExprList, f: &mut PyFormatter) -> FormatResult<()> {\n        // ...\n\n        write!(\n            f,\n            [group(&format_args![\n                text(\"[\"),\n                dangling_comments(dangling), // Gets all the comments marked as dangling for the node\n                soft_block_indent(&items),\n                text(\"]\")])\n            ]\n        )\n    }\n\n    fn fmt_dangling_comments(&self, _node: &ExprList, _f: &mut PyFormatter) -> FormatResult<()> {\n        // Handled as part of `fmt_fields`\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unary Operators with Metaclass Implementation\nDESCRIPTION: Demonstrates how to implement unary operators at the metaclass level, allowing operations on class objects themselves. Shows inheritance of metaclass operations to subclasses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/custom.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Meta(type):\n    def __pos__(self) -> bool:\n        return False\n\n    def __neg__(self) -> str:\n        return \"negative\"\n\n    def __invert__(self) -> int:\n        return 17\n\nclass Yes(metaclass=Meta): ...\nclass Sub(Yes): ...\nclass No: ...\n\nreveal_type(+Yes)  # revealed: bool\nreveal_type(-Yes)  # revealed: str\nreveal_type(~Yes)  # revealed: int\n\nreveal_type(+Sub)  # revealed: bool\nreveal_type(-Sub)  # revealed: str\nreveal_type(~Sub)  # revealed: int\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `Literal[No]`\"\nreveal_type(+No)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `Literal[No]`\"\nreveal_type(-No)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `Literal[No]`\"\nreveal_type(~No)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: File-Level Error Suppression Example\nDESCRIPTION: Shows how to suppress linting errors at the file level using a ruff comment directive.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ruff: noqa: UP035\nfrom typing import Iterable\n\n\ndef sum_even_numbers(numbers: Iterable[int]) -> int:\n    \"\"\"Given an iterable of integers, return the sum of all even numbers in the iterable.\"\"\"\n    return sum(num for num in numbers if num % 2 == 0)\n```\n\n----------------------------------------\n\nTITLE: Typevar Return Value Example\nDESCRIPTION: Example showing typevar usage for matching return type with parameter type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef return_value[T](x: T) -> T:\n    return x\n```\n\n----------------------------------------\n\nTITLE: Customizing File Inclusion Patterns in pyproject.toml\nDESCRIPTION: TOML configuration to customize which files Ruff will analyze by specifying explicit file inclusion patterns in pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\ninclude = [\"pyproject.toml\", \"src/**/*.py\", \"scripts/**/*.py\"]\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Default Parameter Values in Python\nDESCRIPTION: Illustrates lambda expressions with default parameter values and their type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda a=1: a)  # revealed: (a=Literal[1]) -> Unknown\nreveal_type(lambda a, b=2: a)  # revealed: (a, b=Literal[2]) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Special Forms in Type Expressions\nDESCRIPTION: This code demonstrates error messages generated when special forms like `Unpack`, `TypeGuard`, `TypeIs`, `Concatenate`, and `ParamSpec` are used incorrectly in type expressions. Each error message specifies the argument requirements for the respective special form.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_special_forms.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Unpack, TypeGuard, TypeIs, Concatenate, ParamSpec\n\ndef _(\n    a: Unpack,  # error: [invalid-type-form] \"`typing.Unpack` requires exactly one argument when used in a type expression\"\n    b: TypeGuard,  # error: [invalid-type-form] \"`typing.TypeGuard` requires exactly one argument when used in a type expression\"\n    c: TypeIs,  # error: [invalid-type-form] \"`typing.TypeIs` requires exactly one argument when used in a type expression\"\n    d: Concatenate,  # error: [invalid-type-form] \"`typing.Concatenate` requires at least two arguments when used in a type expression\"\n    e: ParamSpec,\n) -> None:\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n    reveal_type(c)  # revealed: Unknown\n    reveal_type(d)  # revealed: Unknown\n\n    def foo(a_: e) -> None:\n        reveal_type(a_)  # revealed: @Todo(Support for `typing.ParamSpec`)\n```\n\n----------------------------------------\n\nTITLE: Variable Scope in Python Boolean Expressions with Short-Circuiting\nDESCRIPTION: This snippet illustrates how variables assigned in earlier parts of a boolean expression can be used in later parts, but not vice versa. It uses the walrus operator for inline assignments and reveal_type() for type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    flag or (x := 1) or reveal_type(x)  # revealed: Literal[1]\n\n    # error: [unresolved-reference]\n    flag or reveal_type(y) or (y := 1)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type-Annotated Decorator in Python\nDESCRIPTION: Shows a decorator that ensures a function returns a positive boolean value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef ensure_positive(wrapped: Callable[[int], bool]) -> Callable[[int], bool]:\n    return lambda x: wrapped(x) and x > 0\n\n@ensure_positive\ndef even(x: int) -> bool:\n    return x % 2 == 0\n\nreveal_type(even)  # revealed: (int, /) -> bool\nreveal_type(even(4))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Valid Typevar Usage with Multiple Parameters\nDESCRIPTION: Demonstration of correct typevar usage where the same type is required for multiple parameters or return values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef two_params[T](x: T, y: T) -> T:\n    return x\n```\n\n----------------------------------------\n\nTITLE: Enabling Docstring Rules and Convention in pyproject.toml\nDESCRIPTION: This snippet demonstrates enabling docstring rules and setting a convention in `pyproject.toml`. It shows how to select the `D` rule prefix and configure the `convention` for `pydocstyle`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff.lint]\nselect = [\"D\"]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\"\n```\n\n----------------------------------------\n\nTITLE: Extending Configuration with src in pyproject.toml\nDESCRIPTION: This snippet demonstrates extending a base configuration while explicitly setting the `src` option. This is important when the configuration file is located in a subdirectory, ensuring Ruff correctly identifies first-party sources relative to the project root.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff]\nextend = \"../pyproject.toml\"\nsrc = [\"../src\"]\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Formatter Arguments (Legacy)\nDESCRIPTION: Example of configuring Ruff formatter arguments using the deprecated ruff-lsp settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.format.args\": \"--line-length 80 --config='format.quote-style=double'\"\n}\n```\n\n----------------------------------------\n\nTITLE: Metaclass Attribute Access\nDESCRIPTION: Demonstrates attribute access patterns when using metaclasses, including precedence rules and type revelation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Meta1:\n    attr: Literal[\"metaclass value\"] = \"metaclass value\"\n\nclass C1(metaclass=Meta1): ...\n\nreveal_type(C1.attr)\n\nclass Meta2:\n    attr: str = \"metaclass value\"\n\nclass C2(metaclass=Meta2):\n    attr: Literal[\"class value\"] = \"class value\"\n\nreveal_type(C2.attr)\n```\n\n----------------------------------------\n\nTITLE: Aliased Type Aliases\nDESCRIPTION: Demonstrates assignment and validation of aliased type aliases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntype IntOrStr = int | str\nMyIntOrStr = IntOrStr\n\nx: MyIntOrStr = 1\n\n# error: [invalid-assignment]\ny: MyIntOrStr = None\n```\n\n----------------------------------------\n\nTITLE: Installing ruff-ecosystem with uv\nDESCRIPTION: This command installs the ruff-ecosystem tool using uv, a tool for managing Python environments and dependencies. It installs the package in editable mode from the specified path.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuv tool install -e ./python/ruff-ecosystem\n```\n\n----------------------------------------\n\nTITLE: Class Pattern Matching in Python\nDESCRIPTION: This snippet shows how class pattern matching works in Python. It demonstrates matching against different class hierarchies and how it affects type inference of variables in different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\n\nclass Foo:\n    pass\n\nclass FooSub(Foo):\n    pass\n\nclass Bar:\n    pass\n\n@final\nclass Baz:\n    pass\n\ndef _(target: FooSub):\n    y = 1\n\n    match target:\n        case Baz():\n            y = 2\n        case Foo():\n            y = 3\n        case Bar():\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[3]\n\ndef _(target: FooSub):\n    y = 1\n\n    match target:\n        case Baz():\n            y = 2\n        case Bar():\n            y = 3\n        case Foo():\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[3, 4]\n\ndef _(target: FooSub | str):\n    y = 1\n\n    match target:\n        case Baz():\n            y = 2\n        case Foo():\n            y = 3\n        case Bar():\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[1, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Docstring Formatting Example in Python\nDESCRIPTION: Demonstrates how Ruff formats Python code examples within docstrings when the feature is enabled.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    '''\n    Something about `f`. And an example:\n\n    .. code-block:: python\n\n        foo, bar, quux = this_is_a_long_line(lion, hippo, lemur, bear)\n    '''\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    \"\"\"\n    Something about `f`. And an example:\n\n    .. code-block:: python\n\n        (\n            foo,\n            bar,\n            quux,\n        ) = this_is_a_long_line(\n            lion,\n            hippo,\n            lemur,\n            bear,\n        )\n    \"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Running ruff-ecosystem format comparing with Black\nDESCRIPTION: This command executes the ruff-ecosystem tool in format mode, comparing Ruff's formatting output with that of the Black formatter. It utilizes the `--format-comparison black-and-ruff` flag and sets verbosity using `-v` and specifies a cache directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem format black ruff -v --cache python/checkouts --format-comparison black-and-ruff\n```\n\n----------------------------------------\n\nTITLE: Accessing Method Attributes Using getattr_static in Python\nDESCRIPTION: Shows how to access method attributes using inspect.getattr_static to bypass the descriptor protocol and directly access the function attribute.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import getattr_static\n\nreveal_type(getattr_static(C, \"f\"))  # revealed: def f(self, x: int) -> str\n\nreveal_type(getattr_static(C, \"f\").__get__)  # revealed: <method-wrapper `__get__` of `f`>\n\nreveal_type(getattr_static(C, \"f\").__get__(None, C))  # revealed: def f(self, x: int) -> str\nreveal_type(getattr_static(C, \"f\").__get__(C(), C))  # revealed: bound method C.f(x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Value Pattern Match Type Narrowing\nDESCRIPTION: Demonstrates type narrowing for literal value patterns including strings, integers, floats, complex numbers, and bytes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case \"foo\":\n        reveal_type(x)  # revealed: Literal[\"foo\"]\n    case 42:\n        reveal_type(x)  # revealed: Literal[42]\n    case 6.0:\n        reveal_type(x)  # revealed: float\n    case 1j:\n        reveal_type(x)  # revealed: complex\n    case b\"foo\":\n        reveal_type(x)  # revealed: Literal[b\"foo\"]\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Testing Integer Literal Type Assignability in Python\nDESCRIPTION: Demonstrates how integer literal types (like Literal[1]) are assignable to the int type but not vice versa, and different integer literals are not assignable to each other.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to\nfrom typing import Literal\n\nstatic_assert(is_assignable_to(Literal[1], Literal[1]))\nstatic_assert(is_assignable_to(Literal[1], int))\n\nstatic_assert(not is_assignable_to(Literal[1], Literal[2]))\nstatic_assert(not is_assignable_to(int, Literal[1]))\nstatic_assert(not is_assignable_to(Literal[1], str))\n```\n\n----------------------------------------\n\nTITLE: Implementing NewType with GenericAlias in Python\nDESCRIPTION: Demonstrates the usage of typing.NewType and GenericAlias, highlighting current limitations in type annotations. Shows how NewType is used with integers and GenericAlias, while noting compatibility issues between NewType and type expectations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/new_types.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import NewType\nfrom types import GenericAlias\n\nX = GenericAlias(type, ())\nA = NewType(\"A\", int)\n# TODO: typeshed for `typing.GenericAlias` uses `type` for the first argument. `NewType` should be special-cased\n# to be compatible with `type`\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `type`, found `NewType`\"\nB = GenericAlias(A, ())\n\ndef _(\n    a: A,\n    b: B,\n):\n    reveal_type(a)  # revealed: @Todo(Support for `typing.NewType` instances in type expressions)\n    reveal_type(b)  # revealed: @Todo(Support for `typing.GenericAlias` instances in type expressions)\n```\n\n----------------------------------------\n\nTITLE: Nested Union Flattening\nDESCRIPTION: Demonstrates how nested unions are flattened into a single union type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(\n    u1: (int | str) | bytes,\n    u2: int | (str | bytes),\n    u3: int | (str | (bytes | bytearray)),\n) -> None:\n    reveal_type(u1)  # revealed: int | str | bytes\n    reveal_type(u2)  # revealed: int | str | bytes\n    reveal_type(u3)  # revealed: int | str | bytes | bytearray\n```\n\n----------------------------------------\n\nTITLE: Descriptor Protocol for Dunder Methods\nDESCRIPTION: Shows how dunder methods are always looked up on the meta-type without instance fallback, demonstrating descriptor protocol implementation for special methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass SomeCallable:\n    def __call__(self, x: int) -> str:\n        return \"a\"\n\nclass Descriptor:\n    def __get__(self, instance: object, owner: type | None = None) -> SomeCallable:\n        return SomeCallable()\n\nclass B:\n    __call__: Descriptor = Descriptor()\n\nb_instance = B()\nreveal_type(b_instance(1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Revealing Types of Unary Bitwise Inversion Operations in Python\nDESCRIPTION: Demonstrates how bitwise inversion (~) affects the revealed types of literal values and boolean True. The type checker correctly identifies the resulting literal types after bitwise negation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/integers.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(~0)  # revealed: Literal[-1]\nreveal_type(~1)  # revealed: Literal[-2]\nreveal_type(~True)  # revealed: Literal[-2]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Linter Settings (Native Server)\nDESCRIPTION: Updated example of configuring Ruff linter settings using the new native server settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.select\": [\"E\", \"F\"],\n    \"ruff.configuration\": {\n        \"unsafe-fixes\": true,\n        \"lint\": {\n            \"unfixable\": [\"F401\"]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fully Qualified Dataclass Usage\nDESCRIPTION: Demonstrates using the fully qualified dataclasses.dataclass decorator name.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\n@dataclasses.dataclass\nclass C:\n    x: str\n\n# TODO: should show the proper signature\nreveal_type(C.__init__)  # revealed: (*args: Any, **kwargs: Any) -> None\n```\n\n----------------------------------------\n\nTITLE: Mutable Instance Truthiness\nDESCRIPTION: Explains how truthiness is handled for instances of classes with customizable __bool__ methods. Shows type narrowing behavior for objects with mutable truth values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef f(x: A | B):\n    if x:\n        reveal_type(x)  # revealed: A & ~AlwaysFalsy | B & ~AlwaysFalsy\n    else:\n        reveal_type(x)  # revealed: A & ~AlwaysTruthy | B & ~AlwaysTruthy\n```\n\n----------------------------------------\n\nTITLE: Simplifying Intersections of bool with AlwaysTruthy and AlwaysFalsy\nDESCRIPTION: Demonstrates how intersections of bool with AlwaysTruthy and AlwaysFalsy can be simplified to Literal types due to bool being a @final class. Shows various combinations and their simplified type revelations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not, AlwaysTruthy, AlwaysFalsy\nfrom typing_extensions import Literal\n\nclass P: ...\n\ndef f(\n    a: Intersection[bool, AlwaysTruthy],\n    b: Intersection[bool, AlwaysFalsy],\n    c: Intersection[bool, Not[AlwaysTruthy]],\n    d: Intersection[bool, Not[AlwaysFalsy]],\n    e: Intersection[bool, AlwaysTruthy, P],\n    f: Intersection[bool, AlwaysFalsy, P],\n    g: Intersection[bool, Not[AlwaysTruthy], P],\n    h: Intersection[bool, Not[AlwaysFalsy], P],\n):\n    reveal_type(a)  # revealed: Literal[True]\n    reveal_type(b)  # revealed: Literal[False]\n    reveal_type(c)  # revealed: Literal[False]\n    reveal_type(d)  # revealed: Literal[True]\n\n    # `bool & AlwaysTruthy & P` -> `Literal[True] & P` -> `Never`\n    reveal_type(e)  # revealed: Never\n    reveal_type(f)  # revealed: Never\n    reveal_type(g)  # revealed: Never\n    reveal_type(h)  # revealed: Never\n\ndef never(\n    a: Intersection[Intersection[AlwaysFalsy, Not[Literal[False]]], bool],\n    b: Intersection[Intersection[AlwaysTruthy, Not[Literal[True]]], bool],\n    c: Intersection[Intersection[Literal[True], Not[AlwaysTruthy]], bool],\n    d: Intersection[Intersection[Literal[False], Not[AlwaysFalsy]], bool],\n):\n    # TODO: This should be `Never`\n    reveal_type(a)  # revealed: Literal[True]\n    # TODO: This should be `Never`\n    reveal_type(b)  # revealed: Literal[False]\n    reveal_type(c)  # revealed: Never\n    reveal_type(d)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Disabling Ruff Hover in Neovim\nDESCRIPTION: Configuration to disable Ruff's hover capability in favor of other language servers like Pyright.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nvim.api.nvim_create_autocmd(\"LspAttach\", {\n  group = vim.api.nvim_create_augroup('lsp_attach_disable_ruff_hover', { clear = true }),\n  callback = function(args)\n    local client = vim.lsp.get_client_by_id(args.data.client_id)\n    if client == nil then\n      return\n    end\n    if client.name == 'ruff' then\n      -- Disable hover in favor of Pyright\n      client.server_capabilities.hoverProvider = false\n    end\n  end,\n  desc = 'LSP: Disable hover capability from Ruff',\n})\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Unannotated Variadic Parameters in Python\nDESCRIPTION: This snippet demonstrates how types are inferred for unannotated variadic and variadic-keyword parameters in Python. The types are inferred as tuple of Unknown and dict from string to Unknown, respectively.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef g(*args, **kwargs):\n    # TODO: should be `tuple[Unknown, ...]` (needs generics)\n    reveal_type(args)  # revealed: tuple\n\n    # TODO: should be `dict[str, Unknown]` (needs generics)\n    reveal_type(kwargs)  # revealed: dict\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Annotation Interchangeability in Python\nDESCRIPTION: Shows how typing.Type can be used interchangeably with type annotations. Demonstrates type checking behavior with basic and parameterized Type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/typing_dot_Type.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Type\n\nclass A: ...\n\ndef _(c: Type, d: Type[A]):\n    reveal_type(c)  # revealed: type\n    reveal_type(d)  # revealed: type[A]\n    c = d  # fine\n    d = c  # fine\n```\n\n----------------------------------------\n\nTITLE: Assignment Expressions in If Tests\nDESCRIPTION: Shows type inference with assignment expressions (:=) in conditional test expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef check(x: int) -> bool:\n    return bool(x)\n\nif check(x := 1):\n    x = 2\nelif check(x := 3):\n    x = 4\n\nreveal_type(x)  # revealed: Literal[2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Super with Generic Classes in Python\nDESCRIPTION: Shows how to use super with generic classes, preserving type parameters through the inheritance chain for proper type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import TypeOf, static_assert, is_subtype_of\n\nclass A[T]:\n    def f(self, a: T) -> T:\n        return a\n\nclass B[T](A[T]):\n    def f(self, b: T) -> T:\n        return super().f(b)\n```\n\n----------------------------------------\n\nTITLE: Edge Case: Assignment to 'self' After Nested Function\nDESCRIPTION: Shows type inference when 'self' is reused as a parameter name in a nested function before instance attribute assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nclass Other:\n    x: str = \"a\"\n\nclass C:\n    def __init__(self) -> None:\n        def nested_function(self: Other):\n            self.x = \"b\"\n        self.x: int = 1\n\nreveal_type(C().x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Mode with Rule Selection in Ruff (TOML)\nDESCRIPTION: Configuration to enable preview mode and select specific rules in Ruff using pyproject.toml or ruff.toml. This example shows how to enable preview mode and extend the selected rule set.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nextend-select = [\"HYP\"]\npreview = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\nextend-select = [\"HYP\"]\npreview = true\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Lint Rules in Ruff (CLI)\nDESCRIPTION: Command-line instruction to enable preview lint rules in Ruff. This command enables preview mode for linting when running Ruff checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nruff check --preview\n```\n\n----------------------------------------\n\nTITLE: Preserving parentheses around single-element lists\nDESCRIPTION: Ruff preserves parentheses around single-element lists, whereas Black 2025 and newer might remove them if they aren't multiline and doing so doesn't change semantics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Using --config to specify a configuration file for Ruff\nDESCRIPTION: This command demonstrates using the --config flag to force Ruff to use a specific pyproject.toml configuration file for all checked files, resolving paths from the current working directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n∴ (cargo run -p ruff -- check --config=crates/ruff_linter/resources/test/project/pyproject.toml crates/ruff_linter/resources/test/project/)\ncrates/ruff_linter/resources/test/project/examples/.dotfiles/script.py:1:8: F401 [*] `numpy` imported but unused\ncrates/ruff_linter/resources/test/project/examples/.dotfiles/script.py:2:17: F401 [*] `app.app_file` imported but unused\ncrates/ruff_linter/resources/test/project/examples/docs/docs/concepts/file.py:1:8: F401 [*] `os` imported but unused\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:1:8: F401 [*] `os` imported but unused\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:3:8: F401 [*] `numpy` imported but unused\ncrates/ruff_linter/resources/test/project/examples/docs/docs/file.py:4:27: F401 [*] `docs.concepts.file` imported but unused\ncrates/ruff_linter/resources/test/project/examples/excluded/script.py:1:8: F401 [*] `os` imported but unused\ncrates/ruff_linter/resources/test/project/project/file.py:1:8: F401 [*] `os` imported but unused\nFound 9 errors.\n[*] 9 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Unsupported Types in Augmented Assignment\nDESCRIPTION: Demonstrates type checking errors when attempting incompatible augmented assignment operations. Shows how type checker handles mismatched types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __isub__(self, other: str) -> int:\n        return 42\n\nx = C()\n# error: [unsupported-operator] \"Operator `-=` is unsupported between objects of type `C` and `Literal[1]`\"\nx -= 1\n\nreveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Using len() with Objects Lacking __len__ in Python\nDESCRIPTION: This snippet demonstrates the behavior of `len()` when used with an object that doesn't implement the `__len__` method. It shows that an error should be raised for invalid argument type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass NoDunderLen: ...\n\n# error: [invalid-argument-type]\nreveal_type(len(NoDunderLen()))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Versioning Example for VS Code Extension\nDESCRIPTION: Demonstrates the versioning scheme used for Ruff's Visual Studio Code extension, where even minor versions indicate stable releases and odd minor versions indicate preview releases\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/versioning.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n2024.30.0, 2024.32.0, 2024.34.0, ...\n2024.31.0, 2024.33.0, 2024.35.0, ...\n```\n\n----------------------------------------\n\nTITLE: Testing Single-Valued Types with Static Assertions in Python\nDESCRIPTION: This code tests various Python types to determine if they are single-valued using the is_single_valued function and static assertions. It checks different scenarios including None, Literals, tuples, built-in types, and callable types. A type is considered single-valued if it is not empty and all its inhabitants compare equal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_single_valued.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport types\nfrom typing_extensions import Any, Literal, LiteralString, Never, Callable\nfrom knot_extensions import is_single_valued, static_assert, TypeOf\n\nstatic_assert(is_single_valued(None))\nstatic_assert(is_single_valued(Literal[True]))\nstatic_assert(is_single_valued(Literal[1]))\nstatic_assert(is_single_valued(Literal[\"abc\"]))\nstatic_assert(is_single_valued(Literal[b\"abc\"]))\n\nstatic_assert(is_single_valued(tuple[()]))\nstatic_assert(is_single_valued(tuple[Literal[True], Literal[1]]))\n\nstatic_assert(not is_single_valued(str))\nstatic_assert(not is_single_valued(Never))\nstatic_assert(not is_single_valued(Any))\n\nstatic_assert(not is_single_valued(Literal[1, 2]))\n\nstatic_assert(not is_single_valued(tuple[None, int]))\n\nstatic_assert(not is_single_valued(Callable[..., None]))\nstatic_assert(not is_single_valued(Callable[[int, str], None]))\n\nclass A:\n    def method(self): ...\n\nstatic_assert(is_single_valued(TypeOf[A().method]))\nstatic_assert(is_single_valued(TypeOf[types.FunctionType.__get__]))\nstatic_assert(is_single_valued(TypeOf[A.method.__get__]))\n```\n\n----------------------------------------\n\nTITLE: Error: Context Expression with Possibly-Unbound Union Variants\nDESCRIPTION: Shows the error when using a union type as a context manager where one variant doesn't implement the required methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Manager1:\n        def __enter__(self) -> str:\n            return \"foo\"\n\n        def __exit__(self, exc_type, exc_value, traceback): ...\n\n    class NotAContextManager: ...\n    context_expr = Manager1() if flag else NotAContextManager()\n\n    # error: [invalid-context-manager] \"Object of type `Manager1 | NotAContextManager` cannot be used with `with` because the methods `__enter__` and `__exit__` are possibly unbound\"\n    with context_expr as f:\n        reveal_type(f)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Running Ruff linter from the project directory\nDESCRIPTION: This command shows running the Ruff linter from the project directory itself, which should exhibit the same behavior as running from the repository root but with relative paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n∴ (cd crates/ruff_linter/resources/test/project/ && cargo run -p ruff -- check .)\nexamples/.dotfiles/script.py:1:1: I001 [*] Import block is un-sorted or un-formatted\nexamples/.dotfiles/script.py:1:8: F401 [*] `numpy` imported but unused\nexamples/.dotfiles/script.py:2:17: F401 [*] `app.app_file` imported but unused\nexamples/docs/docs/file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\nexamples/docs/docs/file.py:8:5: F841 [*] Local variable `x` is assigned to but never used\nproject/file.py:1:8: F401 [*] `os` imported but unused\nproject/import_file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\nFound 7 errors.\n[*] 7 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Using type[...] with Dynamic Base Classes in Python\nDESCRIPTION: Illustrates type checking behavior with Any and Unknown base types. When using type[Any] or type[Unknown], the constructor can accept any arguments and the revealed type is the base type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/subclass_of.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom knot_extensions import Unknown\n\ndef _(subclass_of_any: type[Any], subclass_of_unknown: type[Unknown]):\n    reveal_type(subclass_of_any())  # revealed: Any\n    reveal_type(subclass_of_any(\"any\", \"args\", 1, 2))  # revealed: Any\n    reveal_type(subclass_of_unknown())  # revealed: Unknown\n    reveal_type(subclass_of_unknown(\"any\", \"args\", 1, 2))  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Builtins Scope Limitations in Python\nDESCRIPTION: This snippet shows that symbols imported in builtins.pyi are not automatically available in the builtins scope. Attempting to use Literal and sys without importing them results in errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# These symbols are being imported in `builtins.pyi` but shouldn't be considered as being\n# available in the builtins scope.\n\n# error: \"Name `Literal` used when not defined\"\nreveal_type(Literal)  # revealed: Unknown\n\n# error: \"Name `sys` used when not defined\"\nreveal_type(sys)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement on Non-Single-Valued Types in Python\nDESCRIPTION: Demonstrates type analysis for a match statement where the scrutinee's value is not statically known. The variable 'x' could be 1, 2, or 3 depending on the value of 's'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef _(s: str):\n    match s:\n        case \"a\":\n            x = 1\n        case \"b\":\n            x = 2\n        case _:\n            x = 3\n\n    reveal_type(x)  # revealed: Literal[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: If-Elif-Else Chain Type Analysis\nDESCRIPTION: Shows type inference in a complete if-elif-else chain with multiple variable assignments and scoping effects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    y = 1\n    y = 2\n\n    if flag:\n        y = 3\n    elif flag2:\n        y = 4\n    else:\n        r = y\n        y = 5\n        s = y\n    x = y\n\n    reveal_type(x)  # revealed: Literal[3, 4, 5]\n\n    # revealed: Literal[2]\n    # error: [possibly-unresolved-reference]\n    reveal_type(r)\n\n    # revealed: Literal[5]\n    # error: [possibly-unresolved-reference]\n    reveal_type(s)\n```\n\n----------------------------------------\n\nTITLE: Tuple Inheritance Examples\nDESCRIPTION: Demonstrates inheritance behavior with tuple types and MRO (Method Resolution Order) revelations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# TODO: `tuple[int, str]` is a valid base (generics)\n# error: [invalid-base] \"Invalid class base with type `GenericAlias` (all bases must be a class, `Any`, `Unknown` or `Todo`)\"\nclass A(tuple[int, str]): ...\n\n# Runtime value: `(A, tuple, object)`\n# TODO: Generics\nreveal_type(A.__mro__)  # revealed: tuple[Literal[A], Unknown, Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Class Variables with String Type Annotations in Python\nDESCRIPTION: Demonstrates how string type annotations for class variables interact with name resolution, showing the difference between forward references and direct references.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nMyType = int\n\nclass Aliases:\n    MyType = str\n\n    forward: \"MyType\" = \"value\"\n    not_forward: MyType = \"value\"\n\nreveal_type(Aliases.forward)  # revealed: str\nreveal_type(Aliases.not_forward)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Comparing Regular Attribute Access with inspect.getattr_static in Python\nDESCRIPTION: This snippet shows how regular attribute access invokes the descriptor protocol, while inspect.getattr_static reveals the underlying types without invoking descriptors. It demonstrates the difference in behavior for both normal and descriptor attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nc = C()\n\nreveal_type(c.normal)  # revealed: int\nreveal_type(c.descriptor)  # revealed: str\n\nreveal_type(inspect.getattr_static(c, \"normal\"))  # revealed: int\nreveal_type(inspect.getattr_static(c, \"descriptor\"))  # revealed: Descriptor\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Mode with Rule Selection in Ruff (CLI)\nDESCRIPTION: Command-line instruction to enable preview mode and select specific rules in Ruff. This command enables preview mode and extends the selected rule set.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_7\n\nLANGUAGE: console\nCODE:\n```\nruff check --extend-select HYP --preview\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in AND Expressions - Python\nDESCRIPTION: Shows type narrowing in 'and' expressions where the right-hand side reveals the type when left-hand conditions are truthy.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A: ...\n    x: A | None = A() if flag else None\n\n    isinstance(x, A) and reveal_type(x)  # revealed: A\n    x is None and reveal_type(x)  # revealed: None\n    reveal_type(x)  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Error Case: Too Many Arguments to ClassVar in Python\nDESCRIPTION: Shows an error case where ClassVar is provided with more than one type parameter. The example demonstrates that ClassVar expects exactly one type parameter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nclass C:\n    # error: [invalid-type-form] \"Type qualifier `typing.ClassVar` expects exactly one type parameter\"\n    x: ClassVar[int, str] = 1\n```\n\n----------------------------------------\n\nTITLE: Using New-Style Union Types with | Operator in Python 3.10+\nDESCRIPTION: Demonstrates the usage of Python 3.10's new-style union type syntax with the '|' operator, creating a type alias. Shows that while supported syntactically, full type checking support may be incomplete.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nX = int | str\n\ndef f(y: X):\n    reveal_type(y)  # revealed: @Todo(Support for `types.UnionType` instances in type expressions)\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Standalone Installers\nDESCRIPTION: Commands to install Ruff using standalone installers for macOS, Linux, and Windows.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# On macOS and Linux.\ncurl -LsSf https://astral.sh/ruff/install.sh | sh\n\n# On Windows.\npowershell -c \"irm https://astral.sh/ruff/install.ps1 | iex\"\n\n# For a specific version.\ncurl -LsSf https://astral.sh/ruff/0.11.5/install.sh | sh\npowershell -c \"irm https://astral.sh/ruff/0.11.5/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Customizing File Inclusion Patterns in ruff.toml\nDESCRIPTION: TOML configuration to customize which files Ruff will analyze by specifying explicit file inclusion patterns in ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\ninclude = [\"pyproject.toml\", \"src/**/*.py\", \"scripts/**/*.py\"]\n```\n\n----------------------------------------\n\nTITLE: Ignoring Line Violations with noqa in Python\nDESCRIPTION: Demonstrates how to use the '#noqa' comment to ignore all linting violations on a single line of Python code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx = 1  # noqa\n```\n\n----------------------------------------\n\nTITLE: Dataclass Inheritance - Normal Base\nDESCRIPTION: Shows inheritance pattern where a dataclass inherits from a normal class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nclass Base:\n    x: int = 1\n\n@dataclass\nclass Derived(Base):\n    y: str\n\nd = Derived(\"a\")\n\n# TODO: should be an error:\nDerived(1, \"a\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Methods in Python\nDESCRIPTION: This snippet shows how to define a class with instance and class methods in Python. It includes a potential style issue (E301) related to blank lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# E301\nclass Class:\n    \"\"\"Class for minimal repo.\"\"\"\n\n    def method(cls) -> None:\n        pass\n    @classmethod\n    def cls_method(cls) -> None:\n        pass\n# end\n```\n\n----------------------------------------\n\nTITLE: Error: Context Manager Without __enter__ and __exit__ Methods\nDESCRIPTION: Demonstrates the error that occurs when trying to use a class as a context manager without implementing both __enter__ and __exit__ methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Manager: ...\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not implement `__enter__` and `__exit__`\"\nwith Manager():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Single `with` Item Formatting: Ruff vs Black\nDESCRIPTION: This snippet demonstrates how Ruff formats `with` statements with a single context manager similarly to `while` and `if` statements. Black's formatting is different.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Input\ndef run(data_path, model_uri):\n    with pyspark.sql.SparkSession.builder.config(\n        key=\"spark.python.worker.reuse\", value=True\n    ).config(key=\"spark.ui.enabled\", value=False).master(\n        \"local-cluster[2, 1, 1024]\"\n    ).getOrCreate():\n        # ignore spark log output\n        spark.sparkContext.setLogLevel(\"OFF\")\n        print(score_model(spark, data_path, model_uri))\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\ndef run(data_path, model_uri):\n    with pyspark.sql.SparkSession.builder.config(\n        key=\"spark.python.worker.reuse\", value=True\n    ).config(key=\"spark.ui.enabled\", value=False).master(\n        \"local-cluster[2, 1, 1024]\"\n    ).getOrCreate():\n        # ignore spark log output\n        spark.sparkContext.setLogLevel(\"OFF\")\n        print(score_model(spark, data_path, model_uri))\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\ndef run(data_path, model_uri):\n    with (\n        pyspark.sql.SparkSession.builder.config(\n            key=\"spark.python.worker.reuse\", value=True\n        )\n        .config(key=\"spark.ui.enabled\", value=False)\n        .master(\"local-cluster[2, 1, 1024]\")\n        .getOrCreate()\n    ):\n        # ignore spark log output\n        spark.sparkContext.setLogLevel(\"OFF\")\n        print(score_model(spark, data_path, model_uri))\n```\n\n----------------------------------------\n\nTITLE: Cloning CPython Repository for Benchmarking\nDESCRIPTION: Clone the CPython repository to use as a benchmark target for Ruff. This provides a large and diverse Python codebase for testing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit clone --branch 3.10 https://github.com/python/cpython.git crates/ruff_linter/resources/test/cpython\n```\n\n----------------------------------------\n\nTITLE: Completely Disabling Jupyter Notebook Support in Ruff\nDESCRIPTION: TOML configuration example showing how to completely disable Jupyter Notebook support in Ruff using the extend-exclude setting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nextend-exclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Formatting in Ruff (CLI)\nDESCRIPTION: Command-line instruction to enable preview formatting in Ruff. This command enables preview mode for formatting when running Ruff format.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nruff format --preview\n```\n\n----------------------------------------\n\nTITLE: Configuring Zsh Autocompletion for Ruff\nDESCRIPTION: Shell commands to enable Ruff autocompletion in Zsh. Requires adding completion function to ~/.zfunc directory and updating ~/.zshrc configuration file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_20\n\nLANGUAGE: zsh\nCODE:\n```\nfpath+=~/.zfunc\nautoload -Uz compinit && compinit\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Typeshed Directory in TOML\nDESCRIPTION: Basic TOML configuration to specify a custom typeshed directory path for testing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Analyzing Integer Instance Comparison Types in Python\nDESCRIPTION: Shows type checking behavior when comparing integer variables rather than literals. The function demonstrates that comparisons involving variables result in bool types rather than literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/integers.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# TODO: implement lookup of `__eq__` on typeshed `int` stub.\ndef _(a: int, b: int):\n    reveal_type(1 == a)  # revealed: bool\n    reveal_type(9 < a)  # revealed: bool\n    reveal_type(a < b)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Method Callable as Dunder in Python\nDESCRIPTION: This code snippet shows that a dunder can also be a non-method callable. It defines a SomeCallable class with a __call__ method and uses it as the __getitem__ dunder in ClassWithNonMethodDunder.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass SomeCallable:\n    def __call__(self, key: int) -> str:\n        return str(key)\n\nclass ClassWithNonMethodDunder:\n    __getitem__: SomeCallable = SomeCallable()\n\nclass_with_callable_dunder = ClassWithNonMethodDunder()\n\nreveal_type(class_with_callable_dunder[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in both branches in Python\nDESCRIPTION: This function demonstrates how `raise` statements in both the `then` and `else` branches of an `if` statement within a `try` block affect variable visibility, particularly noting the unreachability of the `else` clause. `reveal_type` is used to show the possible types of `x` based on which exception is raised.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_both_branches(cond: bool):\n    x = \"before\"\n    try:\n        if cond:\n            x = \"raise1\"\n            reveal_type(x)  # revealed: Literal[\"raise1\"]\n            raise ValueError\n        else:\n            x = \"raise2\"\n            reveal_type(x)  # revealed: Literal[\"raise2\"]\n            raise ValueError\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise1\", \"raise2\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise1\", \"raise2\"]\n    else:\n        # This branch is unreachable, since all control flows in the `try` clause raise exceptions.\n        # As a result, this binding should never be reachable, since new bindings are visible only\n        # when they are reachable.\n        x = \"unreachable\"\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise1\", \"raise2\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"raise1\", \"raise2\"]\n```\n\n----------------------------------------\n\nTITLE: Working with NoReturn and Never in Assignments\nDESCRIPTION: Shows assignment compatibility rules between Never, NoReturn, and other types. Demonstrates that Never is assignable to all types, but only Never and Any are assignable to Never.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/never.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import NoReturn, Never, Any\n\n# error: [invalid-type-form] \"Type `typing.Never` expected no type parameter\"\nx: Never[int]\na1: NoReturn\na2: Never\nb1: Any\nb2: int\n\ndef f():\n    # revealed: Never\n    reveal_type(a1)\n    # revealed: Never\n    reveal_type(a2)\n\n    # Never is assignable to all types.\n    v1: int = a1\n    v2: str = a1\n    # Other types are not assignable to Never except for Never (and Any).\n    v3: Never = b1\n    v4: Never = a2\n    v5: Any = b2\n    # error: [invalid-assignment] \"Object of type `Literal[1]` is not assignable to `Never`\"\n    v6: Never = 1\n```\n\n----------------------------------------\n\nTITLE: Using Inconsistent Stub Packages in Python\nDESCRIPTION: Demonstrates the behavior of inconsistent stub packages, where one import succeeds and another fails.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom shapes.polygons.pentagon import Pentagon\nfrom shapes.polygons.hexagon import Hexagon  # error: [unresolved-import]\n\nreveal_type(Pentagon().sides)  # revealed: int\nreveal_type(Hexagon().area)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Call Chain Formatting: Ruff vs Black (Identical)\nDESCRIPTION: This snippet shows a case where both Black and Ruff format call chains identically, demonstrating that Black's last-call argument breaking is not universally applied.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Input\ndf.drop(\n    columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]\n).drop_duplicates(a).rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(\n    path / \"aaaaaa.csv\", index=False\n).other(a)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\ndf.drop(columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]).drop_duplicates(a).rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(path / \"aaaaaa.csv\", index=False).other(a)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\ndf.drop(columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]).drop_duplicates(a).rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(path / \"aaaaaa.csv\", index=False).other(a)\n```\n\n----------------------------------------\n\nTITLE: Restricting Attribute Assignment with Literal Types\nDESCRIPTION: Demonstrates how to restrict which attributes can be assigned to using Literal types on the name parameter of __setattr__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Date:\n    def __setattr__(self, name: Literal[\"day\", \"month\", \"year\"], value: int) -> None:\n        pass\n\ndate = Date()\ndate.day = 8\ndate.month = 4\ndate.year = 2025\n\n# error: [unresolved-attribute] \"Can not assign object of `Literal[\"UTC\"]` to attribute `tz` on type `Date` with custom `__setattr__` method.\"\ndate.tz = \"UTC\"\n```\n\n----------------------------------------\n\nTITLE: Tuple Parameter Type Inference\nDESCRIPTION: Examples of type inference with tuple parameters and multiple typevars.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef tuple_param[T, S](x: T | S, y: tuple[T, S]) -> tuple[T, S]:\n    return y\n\nreveal_type(tuple_param(\"a\", (\"a\", 1)))  # revealed: tuple[Literal[\"a\"], Literal[1]]\nreveal_type(tuple_param(1, (\"a\", 1)))  # revealed: tuple[Literal[\"a\"], Literal[1]]\n```\n\n----------------------------------------\n\nTITLE: Subtype Simplification\nDESCRIPTION: Shows how unions are simplified when one type is a subtype of another.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\n\ndef _(\n    u1: str | LiteralString, u2: LiteralString | str, u3: Literal[\"a\"] | str | LiteralString, u4: str | bytes | LiteralString\n) -> None:\n    reveal_type(u1)  # revealed: str\n    reveal_type(u2)  # revealed: str\n    reveal_type(u3)  # revealed: str\n    reveal_type(u4)  # revealed: str | bytes\n```\n\n----------------------------------------\n\nTITLE: Generic Function Call Type Checking in Python\nDESCRIPTION: Demonstrates a generic function call with type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_int[T]() -> int:\n    return 42\n\nreveal_type(get_int())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Deferring Future Annotations in Python\nDESCRIPTION: This snippet demonstrates how future annotations are deferred, allowing the use of forward references in type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nx: Foo\n\nclass Foo: ...\n\nx = Foo()\nreveal_type(x)  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: No Type Narrowing with Multiple Arguments\nDESCRIPTION: Demonstrates that type narrowing does not occur when type() is used with multiple arguments to create a dynamic class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str | int):\n    # The following diagnostic is valid, since the three-argument form of `type`\n    # can only be called with `str` as the first argument.\n    # error: [no-matching-overload] \"No overload of class `type` matches arguments\"\n    if type(x, (), {}) is str:\n        reveal_type(x)  # revealed: str | int\n    else:\n        reveal_type(x)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Importing Math and Matplotlib in Python\nDESCRIPTION: This snippet imports the math module, enables inline matplotlib plotting, imports the os module, and assigns the value of pi to an underscore variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\n%matplotlib inline\n\nimport os\n\n_ = math.pi\n```\n\n----------------------------------------\n\nTITLE: Ignoring Import Sorting Violations in Python\nDESCRIPTION: Demonstrates how to use the 'noqa' directive to ignore import sorting violations (I001) for an entire import block by placing it at the end of the first line in the block.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os  # noqa: I001\nimport abc\n```\n\n----------------------------------------\n\nTITLE: Analyzing len() with String and Bytes Literals in Python\nDESCRIPTION: This snippet demonstrates the use of `len()` with various string and bytes literals, including normal strings, raw strings, concatenated strings, and multi-line strings. It shows how `len()` calculates the length of these literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(len(\"no\\rmal\"))  # revealed: Literal[6]\nreveal_type(len(r\"aw stri\\ng\"))  # revealed: Literal[10]\nreveal_type(len(r\"conca\\t\" \"ena\\tion\"))  # revealed: Literal[14]\nreveal_type(len(b\"ytes lite\" rb\"al\"))  # revealed: Literal[11]\nreveal_type(len(\"𝒰𝕹🄸©🕲𝕕ℇ\"))  # revealed: Literal[7]\n\nreveal_type(  # revealed: Literal[7]\n    len(\n        \"\"\"foo\nbar\"\"\"\n    )\n)\nreveal_type(  # revealed: Literal[9]\n    len(\n        r\"\"\"foo\\r\nbar\"\"\"\n    )\n)\nreveal_type(  # revealed: Literal[7]\n    len(\n        b\"\"\"foo\nbar\"\"\"\n    )\n)\nreveal_type(  # revealed: Literal[9]\n    len(\n        rb\"\"\"foo\\r\nbar\"\"\"\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Notebook Exclude in TOML\nDESCRIPTION: TOML configuration to opt-out of automatic notebook linting and formatting by adding *.ipynb to the extend-exclude setting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nextend-exclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Except Block with Non-Bare Except\nDESCRIPTION: This snippet demonstrates type inference in a try-except block with a specific exception type (TypeError). It shows how the type inference behaves similarly to a bare except clause for control flow analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef could_raise_returns_str() -> str:\n    return \"foo\"\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\n\nreveal_type(x)  # revealed: str | Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Handling Class-Declared and Instance-Bound Variables in Python\nDESCRIPTION: Explores the behavior of variables declared in the class body and possibly bound in __init__. Demonstrates type inference and access rules for these variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    declared_and_bound: str | None\n\n    def __init__(self) -> None:\n        self.declared_and_bound = \"value set in __init__\"\n\nc_instance = C()\n\nreveal_type(c_instance.declared_and_bound)  # revealed: str | None\n\n# Note that both mypy and pyright show no error in this case! So we may reconsider this in\n# the future, if it turns out to produce too many false positives. We currently emit:\n# error: [unresolved-attribute] \"Attribute `declared_and_bound` can only be accessed on instances, not on the class object `Literal[C]` itself.\"\nreveal_type(C.declared_and_bound)  # revealed: Unknown\n\n# Same as above. Mypy and pyright do not show an error here.\n# error: [invalid-attribute-access] \"Cannot assign to instance attribute `declared_and_bound` from the class object `Literal[C]`\"\nC.declared_and_bound = \"overwritten on class\"\n\n# error: [invalid-assignment] \"Object of type `Literal[1]` is not assignable to attribute `declared_and_bound` of type `str | None`\"\nc_instance.declared_and_bound = 1\n```\n\n----------------------------------------\n\nTITLE: Union with Callable\nDESCRIPTION: Demonstrates using Callable in union types with other types including None.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable, Union\n\ndef _(\n    c: Callable[[Union[int, str]], int] | None,\n    d: None | Callable[[Union[int, str]], int],\n    e: None | Callable[[Union[int, str]], int] | int,\n):\n    reveal_type(c)  # revealed: ((int | str, /) -> int) | None\n    reveal_type(d)  # revealed: None | ((int | str, /) -> int)\n    reveal_type(e)  # revealed: None | ((int | str, /) -> int) | int\n```\n\n----------------------------------------\n\nTITLE: Disabling Rule Comment Code Actions in Ruff LSP\nDESCRIPTION: Controls whether to display Quick Fix actions to disable rules via 'noqa' suppression comments. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.codeAction.disableRuleComment.enable\": false\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      codeAction = {\n        disableRuleComment = {\n          enable = false\n        }\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"codeAction\": {\n            \"disableRuleComment\": {\n              \"enable\": false\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Homogeneous Tuples in Python\nDESCRIPTION: This snippet shows concatenation operations on homogeneous tuples. It uses the 'reveal_type' function to display the resulting types for concatenating tuples of integers and strings, as well as a tuple with literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/tuples.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: tuple[int, ...], y: tuple[str, ...]):\n    reveal_type(x + y)  # revealed: @Todo(full tuple[...] support)\n    reveal_type(x + (1, 2))  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Property Deleter Implementation in Python\nDESCRIPTION: Demonstrates property deleter implementation while maintaining getter and setter functionality.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def my_property(self) -> int:\n        return 1\n\n    @my_property.setter\n    def my_property(self, value: int) -> None:\n        pass\n\n    @my_property.deleter\n    def my_property(self) -> None:\n        pass\n\nc = C()\nreveal_type(c.my_property)  # revealed: int\nc.my_property = 2\n# error: [invalid-assignment]\nc.my_property = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Complex Import Pattern with Exception Handling in Python\nDESCRIPTION: This snippet shows a more complex import pattern, including exception handling for import errors, assigning to a magic variable, and multiple import statements. It demonstrates how to handle potential import errors gracefully.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport a\n\ntry:\n    import b\nexcept ImportError:\n    pass\nelse:\n    pass\n\n__some__magic = 1\n\nimport c\n```\n\n----------------------------------------\n\nTITLE: Async Comprehensions in Python\nDESCRIPTION: Shows implementation of async comprehensions using async iterables and iterators with type revelation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass AsyncIterator:\n    async def __anext__(self) -> int:\n        return 42\n\nclass AsyncIterable:\n    def __aiter__(self) -> AsyncIterator:\n        return AsyncIterator()\n\n# revealed: @Todo(async iterables/iterators)\n[reveal_type(x) async for x in AsyncIterable()]\n```\n\n----------------------------------------\n\nTITLE: Dataclass Decorator with Arguments\nDESCRIPTION: Demonstrates customizing dataclass behavior using decorator arguments to control method generation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass(init=True, repr=True, eq=True)\nclass Person:\n    name: str\n    age: int | None = None\n\nalice = Person(\"Alice\", 30)\nreveal_type(repr(alice))  # revealed: str\nreveal_type(alice == alice)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Bounds and Constraints\nDESCRIPTION: Examples of generic classes with bounded type parameters and type constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Bounded[T: int]: ...\nclass BoundedByUnion[T: int | str]: ...\nclass IntSubclass(int): ...\n\nreveal_type(Bounded[int]())  # revealed: Bounded[int]\nreveal_type(Bounded[IntSubclass]())  # revealed: Bounded[IntSubclass]\n\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `str`\"\nreveal_type(Bounded[str]())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Ruff Executable Path in JSON\nDESCRIPTION: Sets a list of paths to ruff executables. The first executable in the list which exists is used, taking precedence over the importStrategy setting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.path\": [\"/home/user/.local/bin/ruff\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Augmenting and Relaxing Docstring Conventions in pyproject.toml\nDESCRIPTION: This snippet showcases how to augment and relax docstring conventions in Ruff using `pyproject.toml`. It demonstrates selecting additional rules (like `D401`) and ignoring specific rules (like `D417`) on top of a chosen `convention`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff.lint]\nselect = [\n    \"D\",\n    # Augment the convention by requiring an imperative mood for all docstrings.\n    \"D401\",\n]\n\nignore = [\n    # Relax the convention by _not_ requiring documentation for every function parameter.\n    \"D417\",\n]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\"\n```\n\n----------------------------------------\n\nTITLE: Disabling Linting in Ruff LSP\nDESCRIPTION: Controls whether to enable linting. Set to false to use Ruff exclusively as a formatter. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.enable\": false\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      lint = {\n        enable = false\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"lint\": {\n            \"enable\": false\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling with an Unknown Union in Python\nDESCRIPTION: Shows type checking behavior when calling a function that might be imported but could also be defined conditionally, resulting in an Unknown | int union type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nonexistent import f  # error: [unresolved-import] \"Cannot resolve import `nonexistent`\"\n\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    def f() -> int:\n        return 1\n\nreveal_type(f())  # revealed: Unknown | int\n```\n\n----------------------------------------\n\nTITLE: Terminal Statement Unreachable Code Examples in Python\nDESCRIPTION: Examples showing unreachable code after terminal statements like return, raise, break, and continue.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f1():\n    return\n\n    # TODO: we should mark this as unreachable\n    print(\"unreachable\")\n\ndef f2():\n    raise Exception()\n\n    # TODO: we should mark this as unreachable\n    print(\"unreachable\")\n\ndef f3():\n    while True:\n        break\n\n        # TODO: we should mark this as unreachable\n        print(\"unreachable\")\n\ndef f4():\n    for _ in range(10):\n        continue\n\n        # TODO: we should mark this as unreachable\n        print(\"unreachable\")\n```\n\n----------------------------------------\n\nTITLE: Basic Walrus Operator Assignment in Python\nDESCRIPTION: Demonstrates the basic usage of the walrus operator (:=) which assigns a value to a variable as part of an expression. In this example, y is assigned the value 1, and then x becomes the result of y + 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/walrus.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = (y := 1) + 1\nreveal_type(x)  # revealed: Literal[2]\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Complex Type Narrowing with Multiple Conditions\nDESCRIPTION: Illustrates complex type narrowing with multiple negative conditions and equality checks. Shows how the type system handles multiple branches and their impact on type narrowing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/elif_else.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = 1 if flag1 else 2 if flag2 else 3\n\n    if x != 1:\n        reveal_type(x)  # revealed: Literal[2, 3]\n    elif x != 2:\n        # TODO should be `Literal[1]`\n        reveal_type(x)  # revealed: Literal[1, 3]\n    elif x == 3:\n        # TODO should be Never\n        reveal_type(x)  # revealed: Literal[1, 2, 3]\n    else:\n        # TODO should be Never\n        reveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Ignoring Violations in Multi-line Strings with noqa in Python\nDESCRIPTION: Shows how to suppress specific violations (in this case, E501 line length errors) for multi-line strings or docstrings by placing the 'noqa' directive after the closing triple quotes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Lorem ipsum dolor sit amet.\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor.\n\"\"\"  # noqa: E501\n```\n\n----------------------------------------\n\nTITLE: Augmented Assignment Operations\nDESCRIPTION: Shows augmented assignment operations with and without semicolons and comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Augmented assignment without a semicolon\nx += 1\n```\n\nLANGUAGE: python\nCODE:\n```\n# Augmented assignment without a semicolon\nx += 1;\nx += 1;  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Importing and Renaming Classes in Python\nDESCRIPTION: Demonstrates importing a class from another module, renaming it, and verifying its type. The imported class C is renamed to D and then assigned to E.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom b import C as D\n\nE = D\nreveal_type(E)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Gradual Form Callable\nDESCRIPTION: Demonstrates the gradual form of Callable using ellipsis for parameter types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef gradual_form(c: Callable[..., str]):\n    reveal_type(c)  # revealed: (...) -> str\n```\n\n----------------------------------------\n\nTITLE: Declared and Bound Symbol Usage in Python\nDESCRIPTION: Demonstrates type inference for declared and bound symbols, showing how declared types take precedence over inferred types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef any() -> Any: ...\n\na: int = 1\nb: str = 2  # error: [invalid-assignment]\nc: Any = 3\nd: int = any()\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import a, b, c, d\n\nreveal_type(a)  # revealed: int\nreveal_type(b)  # revealed: str\nreveal_type(c)  # revealed: Any\nreveal_type(d)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Examples of Non-fully-static Types in Python\nDESCRIPTION: Shows Python types that are not considered fully-static because they contain gradual forms like Any or Unknown. The `is_fully_static` function is used with negation to verify these types aren't fully-static.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_fully_static.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Any, Literal, LiteralString, Callable\nfrom knot_extensions import Intersection, Not, TypeOf, Unknown, is_fully_static, static_assert\n\nstatic_assert(not is_fully_static(Any))\nstatic_assert(not is_fully_static(Unknown))\n\nstatic_assert(not is_fully_static(Any | str))\nstatic_assert(not is_fully_static(str | Unknown))\nstatic_assert(not is_fully_static(Intersection[Any, Not[LiteralString]]))\n\nstatic_assert(not is_fully_static(tuple[Any, ...]))\nstatic_assert(not is_fully_static(tuple[int, Any]))\nstatic_assert(not is_fully_static(type[Any]))\n```\n\n----------------------------------------\n\nTITLE: Comparing Union Types with Literals in Python\nDESCRIPTION: This snippet demonstrates how comparison operations behave when a union type is compared with literal values. It shows type inference for various comparison operators (<, >, <=, >=, ==, !=) and membership tests (in, not in).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/unions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    one_or_two = 1 if flag else 2\n\n    reveal_type(one_or_two <= 2)  # revealed: Literal[True]\n    reveal_type(one_or_two <= 1)  # revealed: bool\n    reveal_type(one_or_two <= 0)  # revealed: Literal[False]\n\n    reveal_type(2 >= one_or_two)  # revealed: Literal[True]\n    reveal_type(1 >= one_or_two)  # revealed: bool\n    reveal_type(0 >= one_or_two)  # revealed: Literal[False]\n\n    reveal_type(one_or_two < 1)  # revealed: Literal[False]\n    reveal_type(one_or_two < 2)  # revealed: bool\n    reveal_type(one_or_two < 3)  # revealed: Literal[True]\n\n    reveal_type(one_or_two > 0)  # revealed: Literal[True]\n    reveal_type(one_or_two > 1)  # revealed: bool\n    reveal_type(one_or_two > 2)  # revealed: Literal[False]\n\n    reveal_type(one_or_two == 3)  # revealed: Literal[False]\n    reveal_type(one_or_two == 1)  # revealed: bool\n\n    reveal_type(one_or_two != 3)  # revealed: Literal[True]\n    reveal_type(one_or_two != 1)  # revealed: bool\n\n    a_or_ab = \"a\" if flag else \"ab\"\n\n    reveal_type(a_or_ab in \"ab\")  # revealed: Literal[True]\n    reveal_type(\"a\" in a_or_ab)  # revealed: Literal[True]\n\n    reveal_type(\"c\" not in a_or_ab)  # revealed: Literal[True]\n    reveal_type(\"a\" not in a_or_ab)  # revealed: Literal[False]\n\n    reveal_type(\"b\" in a_or_ab)  # revealed: bool\n    reveal_type(\"b\" not in a_or_ab)  # revealed: bool\n\n    one_or_none = 1 if flag else None\n\n    reveal_type(one_or_none is None)  # revealed: bool\n    reveal_type(one_or_none is not None)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Enabling String-less Annotations\nDESCRIPTION: Demonstrates how to enable use of future annotations to avoid quoting type hints in Python code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/vendor/typeshed/stdlib/_typeshed/README.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n```\n\n----------------------------------------\n\nTITLE: Type Variable isinstance() Check\nDESCRIPTION: Shows that type narrowing doesn't occur with type variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, t: type):\n    x = 1 if flag else \"foo\"\n\n    if isinstance(x, t):\n        reveal_type(x)  # revealed: Literal[1, \"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Validating Callable Parameter Type Compatibility with Gradual Form\nDESCRIPTION: Demonstrates how a Callable using the gradual form (...) for parameter types is compatible with any input signature. The code shows type checking assertions to validate that various callable types are assignable to a generic callable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, static_assert, is_assignable_to\nfrom typing import Any, Callable\n\nstatic_assert(is_assignable_to(Callable[[], None], Callable[..., None]))\nstatic_assert(is_assignable_to(Callable[..., None], Callable[..., None]))\nstatic_assert(is_assignable_to(Callable[[int, float, str], None], Callable[..., None]))\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff in Kate LSP Client - JSON\nDESCRIPTION: This JSON snippet configures the LSP Client plugin in Kate to use the Ruff language server for Python development. The external command for the server is specified, along with other properties like URL and highlighting mode.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"servers\": {\n    \"python\": {\n      \"command\": [\"ruff\", \"server\"],\n      \"url\": \"https://github.com/astral-sh/ruff\",\n      \"highlightingModeRegex\": \"^Python$\",\n      \"settings\": {}\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Variable Two Levels Up in Nested Functions\nDESCRIPTION: Shows type inference for a variable accessed two levels up through multiple nested function scopes. The outer variable x is accessed from the innermost function h().\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/nonlocal.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    x = 1\n    def g():\n        def h():\n            reveal_type(x)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dunder Method Lookup on Class in Python\nDESCRIPTION: This code snippet shows that when invoking a dunder method on an instance of a class, it is looked up on the class itself. It defines a ClassWithNormalDunder with a __getitem__ method and demonstrates its usage.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass ClassWithNormalDunder:\n    def __getitem__(self, key: int) -> str:\n        return str(key)\n\nclass_with_normal_dunder = ClassWithNormalDunder()\n\nreveal_type(class_with_normal_dunder[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Basic Dataclass Implementation in Python\nDESCRIPTION: Demonstrates basic dataclass usage with type annotations and different initialization patterns. Shows type checking and comparison behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int | None = None\n\nalice1 = Person(\"Alice\", 30)\nalice2 = Person(name=\"Alice\", age=30)\nalice3 = Person(age=30, name=\"Alice\")\nalice4 = Person(\"Alice\", age=30)\n\nreveal_type(alice1)  # revealed: Person\nreveal_type(type(alice1))  # revealed: type[Person]\n\nreveal_type(alice1.name)  # revealed: str\nreveal_type(alice1.age)  # revealed: int | None\n\nreveal_type(repr(alice1))  # revealed: str\n\nreveal_type(alice1 == alice2)  # revealed: bool\nreveal_type(alice1 == \"Alice\")  # revealed: bool\n\nbob = Person(\"Bob\")\nbob2 = Person(\"Bob\", None)\nbob3 = Person(name=\"Bob\")\nbob4 = Person(name=\"Bob\", age=None)\n```\n\n----------------------------------------\n\nTITLE: Handling BaseException with except*\nDESCRIPTION: Example of using except* with BaseException to catch all exception types in an exception group.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    help()\nexcept* BaseException as e:\n    # TODO: should be `BaseExceptionGroup[BaseException]` --Alex\n    reveal_type(e)  # revealed: BaseExceptionGroup\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff using the --config argument\nDESCRIPTION: This snippet shows how to provide configuration options to Ruff using the --config command-line argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nruff check --config \"lint.per-file-ignores = {'some_file.py' = ['F841']}\"\n```\n\n----------------------------------------\n\nTITLE: Basic Custom __setattr__ Implementation\nDESCRIPTION: Demonstrates how to implement a custom __setattr__ method to control the type of values that can be assigned to attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nclass CustomSetAttr:\n    def __setattr__(self, name: str, value: int) -> None:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Testing Union and Intersection Type Equivalence in Python\nDESCRIPTION: Tests gradual equivalence between union and intersection types. Shows how order doesn't matter for unions and intersections, and demonstrates equivalence with complex type combinations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom knot_extensions import Intersection, Not, Unknown, is_gradual_equivalent_to, static_assert\n\nstatic_assert(is_gradual_equivalent_to(str | int, str | int))\nstatic_assert(is_gradual_equivalent_to(str | int | Any, str | int | Unknown))\nstatic_assert(is_gradual_equivalent_to(str | int, int | str))\nstatic_assert(\n    is_gradual_equivalent_to(Intersection[str, int, Not[bytes], Not[None]], Intersection[int, str, Not[None], Not[bytes]])\n)\nstatic_assert(is_gradual_equivalent_to(Intersection[str | int, Not[type[Any]]], Intersection[int | str, Not[type[Unknown]]]))\n\nstatic_assert(not is_gradual_equivalent_to(str | int, int | str | bytes))\nstatic_assert(not is_gradual_equivalent_to(str | int | bytes, int | str | dict))\n\n# TODO: No errors\n# error: [static-assert-error]\nstatic_assert(is_gradual_equivalent_to(Unknown, Unknown | Any))\n# error: [static-assert-error]\nstatic_assert(is_gradual_equivalent_to(Unknown, Intersection[Unknown, Any]))\n```\n\n----------------------------------------\n\nTITLE: Parameter Type Inference in Lambda Expressions in Python\nDESCRIPTION: Shows type inference for different parameter types in lambda expressions, including regular, default, variadic, and keyword-variadic parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nlambda x: reveal_type(x)  # revealed: Unknown\n\nlambda x=1: reveal_type(x)  # revealed: Unknown | Literal[1]\n\n# TODO: should be `tuple[Unknown, ...]` (needs generics)\nlambda *args: reveal_type(args)  # revealed: tuple\n\n# TODO: should be `dict[str, Unknown]` (needs generics)\nlambda **kwargs: reveal_type(kwargs)  # revealed: dict\n```\n\n----------------------------------------\n\nTITLE: Handling Union Types in Context Managers\nDESCRIPTION: Shows how Python handles union types in context managers. The type of the target variable is inferred as a union of possible return types from different __enter__ methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Manager1:\n        def __enter__(self) -> str:\n            return \"foo\"\n\n        def __exit__(self, exc_type, exc_value, traceback): ...\n\n    class Manager2:\n        def __enter__(self) -> int:\n            return 42\n\n        def __exit__(self, exc_type, exc_value, traceback): ...\n\n    context_expr = Manager1() if flag else Manager2()\n\n    with context_expr as f:\n        reveal_type(f)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Implementing Standard Binary Operations in Python\nDESCRIPTION: Demonstrates the implementation of all standard binary operations using magic methods in a class. It shows how type inference works for these operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> \"A\":\n        return self\n\n    def __sub__(self, other) -> \"A\":\n        return self\n\n    def __mul__(self, other) -> \"A\":\n        return self\n\n    def __matmul__(self, other) -> \"A\":\n        return self\n\n    def __truediv__(self, other) -> \"A\":\n        return self\n\n    def __floordiv__(self, other) -> \"A\":\n        return self\n\n    def __mod__(self, other) -> \"A\":\n        return self\n\n    def __pow__(self, other) -> \"A\":\n        return self\n\n    def __lshift__(self, other) -> \"A\":\n        return self\n\n    def __rshift__(self, other) -> \"A\":\n        return self\n\n    def __and__(self, other) -> \"A\":\n        return self\n\n    def __xor__(self, other) -> \"A\":\n        return self\n\n    def __or__(self, other) -> \"A\":\n        return self\n\nclass B: ...\n\nreveal_type(A() + B())  # revealed: A\nreveal_type(A() - B())  # revealed: A\nreveal_type(A() * B())  # revealed: A\nreveal_type(A() @ B())  # revealed: A\nreveal_type(A() / B())  # revealed: A\nreveal_type(A() // B())  # revealed: A\nreveal_type(A() % B())  # revealed: A\nreveal_type(A() ** B())  # revealed: A\nreveal_type(A() << B())  # revealed: A\nreveal_type(A() >> B())  # revealed: A\nreveal_type(A() & B())  # revealed: A\nreveal_type(A() ^ B())  # revealed: A\nreveal_type(A() | B())  # revealed: A\n```\n\n----------------------------------------\n\nTITLE: functools.wraps Decorator Pattern in Python\nDESCRIPTION: Demonstrates the use of functools.wraps in implementing a decorator.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\nfrom functools import wraps\n\ndef custom_decorator(f) -> Callable[[int], str]:\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        print(\"Calling decorated function\")\n        return f(*args, **kwargs)\n    return wrapper\n\n@custom_decorator\ndef f(x: int) -> str:\n    return str(x)\n\nreveal_type(f)  # revealed: (int, /) -> str\n```\n\n----------------------------------------\n\nTITLE: Testing Ruff Formatter with Shell Commands\nDESCRIPTION: Shows how to run the ruff_python_formatter binary to format Python files and display debug info\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --bin ruff_python_formatter -- --emit stdout scratch.py\n```\n\n----------------------------------------\n\nTITLE: Class-Based Decorator in Python\nDESCRIPTION: Shows how a class can be used as a decorator, turning the decorated function into an instance of the class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass accept_strings:\n    custom_attribute: str = \"a\"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __call__(self, x: str | int) -> bool:\n        return self.f(int(x))\n\n@accept_strings\ndef even(x: int) -> bool:\n    return x > 0\n\nreveal_type(even)  # revealed: accept_strings\nreveal_type(even.custom_attribute)  # revealed: str\nreveal_type(even(\"1\"))  # revealed: bool\nreveal_type(even(1))  # revealed: bool\n\n# error: [invalid-argument-type]\neven(None)\n```\n\n----------------------------------------\n\nTITLE: Dunder Method Resolution with super() in Python\nDESCRIPTION: Demonstrates how dunder methods defined in the 'owner' class are not automatically applied to the super object. Shows that super objects do not inherit attributes of the owner class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __getitem__(self, key: int) -> int:\n        return 42\n\nclass B(A): ...\n\nreveal_type(A()[0])  # revealed: int\nreveal_type(super(B, B()).__getitem__)  # revealed: bound method B.__getitem__(key: int) -> int\n# error: [non-subscriptable] \"Cannot subscript object of type `<super: Literal[B], B>` with no `__getitem__` method\"\nsuper(B, B())[0]\n```\n\n----------------------------------------\n\nTITLE: Object Type Subsumption\nDESCRIPTION: Shows how object type subsumes all other types in unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Never, Any\n\ndef _(\n    u1: int | object,\n    u2: object | int,\n    u3: Any | object,\n    u4: object | Any,\n    u5: object | Never,\n    u6: Never | object,\n    u7: int | str | object | bytes | Any,\n) -> None:\n    reveal_type(u1)  # revealed: object\n    reveal_type(u2)  # revealed: object\n    reveal_type(u3)  # revealed: object\n    reveal_type(u4)  # revealed: object\n    reveal_type(u5)  # revealed: object\n    reveal_type(u6)  # revealed: object\n    reveal_type(u7)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Type Inference in Nested Try-Except Blocks\nDESCRIPTION: Illustrates type inference in nested exception handlers with multiple branches, showing complex control flow and type tracking across nested scopes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\nclass E: ...\nclass F: ...\nclass G: ...\nclass H: ...\nclass I: ...\nclass J: ...\nclass K: ...\n\ndef could_raise_returns_A() -> A:\n    return A()\n\n# ... [additional function definitions] ...\n\nx = 1\n\ntry:\n    try:\n        reveal_type(x)  # revealed: Literal[1]\n        x = could_raise_returns_A()\n        reveal_type(x)  # revealed: A\n    except TypeError:\n        reveal_type(x)  # revealed: Literal[1] | A\n        x = could_raise_returns_B()\n        reveal_type(x)  # revealed: B\n        x = could_raise_returns_C()\n        reveal_type(x)  # revealed: C\n    except ValueError:\n        reveal_type(x)  # revealed: Literal[1] | A\n        x = could_raise_returns_D()\n        reveal_type(x)  # revealed: D\n        x = could_raise_returns_E()\n        reveal_type(x)  # revealed: E\n    else:\n        reveal_type(x)  # revealed: A\n        x = could_raise_returns_F()\n        reveal_type(x)  # revealed: F\n        x = could_raise_returns_G()\n        reveal_type(x)  # revealed: G\n    finally:\n        reveal_type(x)  # revealed: C | E | G\n        x = 2\n        reveal_type(x)  # revealed: Literal[2]\n    reveal_type(x)  # revealed: Literal[2]\nexcept:\n    reveal_type(x)  # revealed: Literal[1, 2] | A | B | C | D | E | F | G\n    x = could_raise_returns_H()\n    reveal_type(x)  # revealed: H\n    x = could_raise_returns_I()\n    reveal_type(x)  # revealed: I\nelse:\n    reveal_type(x)  # revealed: Literal[2]\n    x = could_raise_returns_J()\n    reveal_type(x)  # revealed: J\n    x = could_raise_returns_K()\n    reveal_type(x)  # revealed: K\nfinally:\n    reveal_type(x)  # revealed: I | K\n\nreveal_type(x)  # revealed: I | K\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Short-Circuit Evaluation in Python Boolean Expressions\nDESCRIPTION: This code snippet shows how 'or' and 'and' expressions can short-circuit, potentially leaving some variables unassigned. It uses the walrus operator (:=) for inline assignments and reveal_type() for type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag or (x := 1):\n        # error: [possibly-unresolved-reference]\n        reveal_type(x)  # revealed: Literal[1]\n\n    if flag and (x := 1):\n        # error: [possibly-unresolved-reference]\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Example Path Suffix Check\nDESCRIPTION: Example demonstrating the PTH210 check for invalid path suffix including the case \".\"\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npath.with_suffix(\".\")\n```\n\n----------------------------------------\n\nTITLE: Implementing __class_getitem__ for Basic Class Subscription\nDESCRIPTION: Demonstrates a simple implementation of the __class_getitem__ special method that returns a string conversion of the subscript index.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Identity:\n    def __class_getitem__(cls, item: int) -> str:\n        return str(item)\n\nreveal_type(Identity[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of typing.Any in Python\nDESCRIPTION: Demonstrates the basic usage of typing.Any as a type annotation. Any allows a variable to hold values of any type, and the type checker will not enforce any constraints on it.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/any.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nx: Any = 1\nx = \"foo\"\n\ndef f():\n    reveal_type(x)  # revealed: Any\n```\n\n----------------------------------------\n\nTITLE: Distinct Bounded Typevar Relationships in Python\nDESCRIPTION: Shows that distinct type variables, even with identical bounds, are not subtypes of each other. This applies even to final class bounds.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef two_bounded[T: Super, U: Super](t: list[T], u: list[U]) -> None:\n    static_assert(not is_assignable_to(T, U))\n    static_assert(not is_assignable_to(U, T))\n\n    static_assert(not is_subtype_of(T, U))\n    static_assert(not is_subtype_of(U, T))\n\ndef two_final_bounded[T: FinalClass, U: FinalClass](t: list[T], u: list[U]) -> None:\n    static_assert(not is_assignable_to(T, U))\n    static_assert(not is_assignable_to(U, T))\n\n    static_assert(not is_subtype_of(T, U))\n    static_assert(not is_subtype_of(U, T))\n```\n\n----------------------------------------\n\nTITLE: Static Type Assertions for Instance Types and Type[T] in Python\nDESCRIPTION: This snippet examines the relationship between instance types and type[T] types. It asserts their disjoint status leveraging the @final decorator to emphasize type constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\nfrom knot_extensions import is_disjoint_from, static_assert\n\n@final\nclass Foo: ...\n\nstatic_assert(is_disjoint_from(Foo, type[int]))\nstatic_assert(is_disjoint_from(type[object], Foo))\nstatic_assert(is_disjoint_from(type[dict], Foo))\n\n@final\nclass Meta1(type): ...\n\nclass UsesMeta1(metaclass=Meta1): ...\n\nstatic_assert(not is_disjoint_from(Meta1, type[UsesMeta1]))\n\nclass Meta2(type): ...\nclass UsesMeta2(metaclass=Meta2): ...\n\nstatic_assert(not is_disjoint_from(Meta2, type[UsesMeta2]))\nstatic_assert(is_disjoint_from(Meta1, type[UsesMeta2]))\n```\n\n----------------------------------------\n\nTITLE: Assigning Unknown Attributes in Python\nDESCRIPTION: Demonstrates attempting to set attributes that are not defined, resulting in unresolved attribute errors for both class and instance assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\nC.non_existent = 1  # error: [unresolved-attribute]\n\ninstance = C()\ninstance.non_existent = 1  # error: [unresolved-attribute]\n```\n\n----------------------------------------\n\nTITLE: Error Propagation in Tuple Comparisons\nDESCRIPTION: Demonstrates how errors in tuple comparisons propagate and how comparison shortcuts work when early elements are decisive. Shows behavior with unsupported operators between custom class instances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef _(n: int, s: str):\n    class A: ...\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `A` and `A`\"\n    A() < A()\n    # error: [unsupported-operator] \"Operator `<=` is not supported for types `A` and `A`\"\n    A() <= A()\n    # error: [unsupported-operator] \"Operator `>` is not supported for types `A` and `A`\"\n    A() > A()\n    # error: [unsupported-operator] \"Operator `>=` is not supported for types `A` and `A`\"\n    A() >= A()\n\n    a = (0, n, A())\n\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `A` and `A`, in comparing `tuple[Literal[0], int, A]` with `tuple[Literal[0], int, A]`\"\n    reveal_type(a < a)  # revealed: Unknown\n    # error: [unsupported-operator] \"Operator `<=` is not supported for types `A` and `A`, in comparing `tuple[Literal[0], int, A]` with `tuple[Literal[0], int, A]`\"\n    reveal_type(a <= a)  # revealed: Unknown\n    # error: [unsupported-operator] \"Operator `>` is not supported for types `A` and `A`, in comparing `tuple[Literal[0], int, A]` with `tuple[Literal[0], int, A]`\"\n    reveal_type(a > a)  # revealed: Unknown\n    # error: [unsupported-operator] \"Operator `>=` is not supported for types `A` and `A`, in comparing `tuple[Literal[0], int, A]` with `tuple[Literal[0], int, A]`\"\n    reveal_type(a >= a)  # revealed: Unknown\n\n    b = (99999, n, A())\n\n    reveal_type(a < b)  # revealed: Literal[True]\n    reveal_type(a <= b)  # revealed: Literal[True]\n    reveal_type(a > b)  # revealed: Literal[False]\n    reveal_type(a >= b)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Fully Static Type Variables in Python\nDESCRIPTION: Demonstrates the concept of fully static type variables and how they are determined based on their bounds and constraints. It uses custom extensions to assert the static nature of type variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_fully_static, static_assert\nfrom typing import Any\n\ndef unbounded_unconstrained[T](t: list[T]) -> None:\n    static_assert(is_fully_static(T))\n\ndef bounded[T: int](t: list[T]) -> None:\n    static_assert(is_fully_static(T))\n\ndef bounded_by_gradual[T: Any](t: list[T]) -> None:\n    static_assert(not is_fully_static(T))\n\ndef constrained[T: (int, str)](t: list[T]) -> None:\n    static_assert(is_fully_static(T))\n\ndef constrained_by_gradual[T: (int, Any)](t: list[T]) -> None:\n    static_assert(not is_fully_static(T))\n```\n\n----------------------------------------\n\nTITLE: Basic For Loop with Iterator Protocol\nDESCRIPTION: Demonstrates basic iterator protocol implementation with a simple integer iterator and iterable class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\nfor x in IntIterable():\n    pass\n\n# revealed: int\n# error: [possibly-unresolved-reference]\nreveal_type(x)\n```\n\n----------------------------------------\n\nTITLE: Stub Functions in Python Function Overloads\nDESCRIPTION: This snippet shows how stub functions are used in Python function overloads. It demonstrates the use of @overload decorator and ellipsis (...) for default values in overload signatures.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import overload\n\n@overload\ndef x(y: None = ...) -> None: ...\n@overload\ndef x(y: int) -> str: ...\ndef x(y: int | None = None) -> str | None: ...\n```\n\n----------------------------------------\n\nTITLE: Single-Element Tuple Parenthesization: Ruff vs Black\nDESCRIPTION: This snippet shows that Ruff always inserts parentheses around single-element tuples, providing visual distinction and preventing accidental tuples. Black omits parentheses in some cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Input\n(a, b),\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\n(a, b),\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\n((a, b),)\n```\n\n----------------------------------------\n\nTITLE: Setting Arbitrary Attributes with __setattr__\nDESCRIPTION: Shows how to set arbitrary attributes on instances of a class with a custom __setattr__ method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nc = CustomSetAttr()\n\nc.whatever = 42\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with None in Python\nDESCRIPTION: Demonstrates type inference for the 'not' operator applied to None, showing that 'not None' is inferred as Literal[True] and 'not not None' as Literal[False].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(not None)  # revealed: Literal[True]\nreveal_type(not not None)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Running Ruff linter from a sub-package directory\nDESCRIPTION: This command demonstrates running the Ruff linter from a sub-package directory, which should apply the sub-package's settings and only check files within that directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n∴ (cd crates/ruff_linter/resources/test/project/examples/docs && cargo run -p ruff -- check .)\ndocs/file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\ndocs/file.py:8:5: F841 [*] Local variable `x` is assigned to but never used\nFound 2 errors.\n[*] 2 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Inheritance with Sub-graphs\nDESCRIPTION: Shows MRO behavior with cyclic inheritance combined with non-cyclic sub-graphs in the inheritance hierarchy.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass FooCycle(BarCycle): ...\nclass Foo: ...\nclass BarCycle(FooCycle): ...\nclass Bar(Foo): ...\n\nclass Baz(Bar, BarCycle): ...\nclass Spam(Baz): ...\n\nreveal_type(FooCycle.__mro__)\nreveal_type(BarCycle.__mro__)\nreveal_type(Baz.__mro__)\nreveal_type(Spam.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Tuple Slicing Operations\nDESCRIPTION: Shows comprehensive tuple slicing operations including positive/negative indices, steps, and None values. Demonstrates type revelations for various slice operations and error cases for zero step sizes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(m: int, n: int):\n    t = (1, \"a\", None, b\"b\")\n\n    reveal_type(t[0:0])  # revealed: tuple[()]\n    reveal_type(t[0:1])  # revealed: tuple[Literal[1]]\n    reveal_type(t[0:2])  # revealed: tuple[Literal[1], Literal[\"a\"]]\n    reveal_type(t[0:4])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n    reveal_type(t[0:5])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n    reveal_type(t[1:3])  # revealed: tuple[Literal[\"a\"], None]\n\n    reveal_type(t[-2:4])  # revealed: tuple[None, Literal[b\"b\"]]\n    reveal_type(t[-3:-1])  # revealed: tuple[Literal[\"a\"], None]\n    reveal_type(t[-10:10])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n\n    reveal_type(t[0:])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n    reveal_type(t[2:])  # revealed: tuple[None, Literal[b\"b\"]]\n    reveal_type(t[4:])  # revealed: tuple[()]\n    reveal_type(t[:0])  # revealed: tuple[()]\n    reveal_type(t[:2])  # revealed: tuple[Literal[1], Literal[\"a\"]]\n    reveal_type(t[:10])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n    reveal_type(t[:])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n\n    reveal_type(t[::-1])  # revealed: tuple[Literal[b\"b\"], None, Literal[\"a\"], Literal[1]]\n    reveal_type(t[::2])  # revealed: tuple[Literal[1], None]\n    reveal_type(t[-2:-5:-1])  # revealed: tuple[None, Literal[\"a\"], Literal[1]]\n    reveal_type(t[::-2])  # revealed: tuple[Literal[b\"b\"], Literal[\"a\"]]\n    reveal_type(t[-1::-3])  # revealed: tuple[Literal[b\"b\"], Literal[1]]\n\n    reveal_type(t[None:2:None])  # revealed: tuple[Literal[1], Literal[\"a\"]]\n    reveal_type(t[1:None:1])  # revealed: tuple[Literal[\"a\"], None, Literal[b\"b\"]]\n    reveal_type(t[None:None:None])  # revealed: tuple[Literal[1], Literal[\"a\"], None, Literal[b\"b\"]]\n\n    start = 1\n    stop = None\n    step = 2\n    reveal_type(t[start:stop:step])  # revealed: tuple[Literal[\"a\"], Literal[b\"b\"]]\n\n    reveal_type(t[False:True])  # revealed: tuple[Literal[1]]\n    reveal_type(t[True:3])  # revealed: tuple[Literal[\"a\"], None]\n\n    t[0:4:0]  # error: [zero-stepsize-in-slice]\n    t[:4:0]  # error: [zero-stepsize-in-slice]\n    t[0::0]  # error: [zero-stepsize-in-slice]\n    t[::0]  # error: [zero-stepsize-in-slice]\n\n    tuple_slice = t[m:n]\n    # TODO: Support overloads... Should be `tuple[Literal[1, 'a', b\"b\"] | None, ...]\n    reveal_type(tuple_slice)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Usage of Python's `cast` Function\nDESCRIPTION: This snippet shows how to use the `cast` function to convert values between different types, including literal types, union types, and named arguments. It also demonstrates error cases for invalid type forms and incorrect argument usage.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/cast.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, cast, Any\n\nreveal_type(True)  # revealed: Literal[True]\nreveal_type(cast(str, True))  # revealed: str\nreveal_type(cast(\"str\", True))  # revealed: str\n\nreveal_type(cast(int | str, 1))  # revealed: int | str\n\nreveal_type(cast(val=\"foo\", typ=int))  # revealed: int\n\n# error: [invalid-type-form]\nreveal_type(cast(Literal, True))  # revealed: Unknown\n\n# error: [invalid-type-form]\nreveal_type(cast(1, True))  # revealed: Unknown\n\n# error: [missing-argument] \"No argument provided for required parameter `val` of function `cast`\"\ncast(str)\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `cast`: expected 2, got 3\"\ncast(str, b\"ar\", \"foo\")\n\ndef function_returning_int() -> int:\n    return 10\n\n# error: [redundant-cast] \"Value is already of type `int`\"\ncast(int, function_returning_int())\n\ndef function_returning_any() -> Any:\n    return \"blah\"\n\n# error: [redundant-cast] \"Value is already of type `Any`\"\ncast(Any, function_returning_any())\n```\n\n----------------------------------------\n\nTITLE: Ignoring Lint Rules in Ruff LSP\nDESCRIPTION: Specifies rules to disable by default for linting. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.ignore\": [\"E4\", \"E7\"]\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      lint = {\n        ignore = {\"E4\", \"E7\"}\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"lint\": {\n            \"ignore\": [\"E4\", \"E7\"]\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Type Assertions in Python\nDESCRIPTION: Demonstrates basic usage of assert_type for checking variable types against expected types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\ndef _(x: int):\n    assert_type(x, int)  # fine\n    assert_type(x, str)  # error: [type-assertion-failure]\n```\n\n----------------------------------------\n\nTITLE: Basic TYPE_CHECKING Usage in Python Type Checking\nDESCRIPTION: Demonstrates the basic usage of TYPE_CHECKING constant from the typing module. Shows that the constant is inferred as Literal[True] during type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING\nimport typing\n\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\nreveal_type(typing.TYPE_CHECKING)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Invalid Exception Handler Cases\nDESCRIPTION: Shows examples of invalid exception handlers and their type checking errors. Includes cases with invalid exception types and tuple combinations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pass\nexcept 3 as e:\n    reveal_type(e)  # revealed: Unknown\n\ntry:\n    pass\nexcept (ValueError, OSError, \"foo\", b\"bar\") as e:\n    reveal_type(e)  # revealed: ValueError | OSError | Unknown\n\ndef foo(\n    x: type[str],\n    y: tuple[type[OSError], type[RuntimeError], int],\n    z: tuple[type[str], ...],\n):\n    try:\n        help()\n    except x as e:\n        reveal_type(e)  # revealed: Unknown\n    except y as f:\n        reveal_type(f)  # revealed: OSError | RuntimeError | Unknown\n    except z as g:\n        reveal_type(g)  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Using LiteralString as a Type Annotation in Python\nDESCRIPTION: Demonstrates how to use LiteralString as a type annotation in Python and shows how the type is revealed during type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\nx: LiteralString\n\ndef f():\n    reveal_type(x)  # revealed: LiteralString\n```\n\n----------------------------------------\n\nTITLE: Testing Type Assignability in Python\nDESCRIPTION: Shows how to use is_assignable_to to test whether values of one type can be assigned to variables of another type, particularly with Any types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_assignable_to, static_assert\nfrom typing import Any\n\nstatic_assert(is_assignable_to(int, Any))\nstatic_assert(is_assignable_to(Any, str))\nstatic_assert(not is_assignable_to(int, str))\n```\n\n----------------------------------------\n\nTITLE: Async Function Call Type Checking in Python\nDESCRIPTION: Shows an async function call with a TODO note about coroutine type support.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def get_int_async() -> int:\n    return 42\n\n# TODO: we don't yet support `types.CoroutineType`, should be generic `Coroutine[Any, Any, int]`\nreveal_type(get_int_async())  # revealed: @Todo(generic types.CoroutineType)\n```\n\n----------------------------------------\n\nTITLE: Python Code with Error Suppression\nDESCRIPTION: Demonstrates how to suppress specific Ruff warnings using noqa comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable  # noqa: UP035\n\n\ndef sum_even_numbers(numbers: Iterable[int]) -> int:\n    \"\"\"Given an iterable of integers, return the sum of all even numbers in the iterable.\"\"\"\n    return sum(num for num in numbers if num % 2 == 0)\n```\n\n----------------------------------------\n\nTITLE: Configuring Explicit Preview Rules in Ruff (TOML)\nDESCRIPTION: Configuration to enable explicit selection of preview rules in Ruff using pyproject.toml or ruff.toml. This setting requires individual selection of preview rules when preview mode is enabled.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\npreview = true\nexplicit-preview-rules = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\npreview = true\nexplicit-preview-rules = true\n```\n\n----------------------------------------\n\nTITLE: Running Diagnostics Diff Between Git Revisions\nDESCRIPTION: Command to compare type checking diagnostics between two Git revisions using the Red Knot type checker. Demonstrates filtering for specific projects and output formatting options.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/mypy_primer.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmypy_primer \\\n    --type-checker knot \\\n    --old origin/main \\\n    --new my/feature \\\n    --debug \\\n    --output concise \\\n    --project-selector '/black$'\n```\n\n----------------------------------------\n\nTITLE: Multiple Symbol Type Narrowing\nDESCRIPTION: Shows how multiple symbols can be narrowed simultaneously in conditional expressions\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B, y: A | B):\n    if isinstance(x, A) and isinstance(y, B):\n        reveal_type(x)  # revealed: A\n        reveal_type(y)  # revealed: B\n    else:\n        reveal_type(x)  # revealed: A | B\n        reveal_type(y)  # revealed: A | B\n\n    reveal_type(x)  # revealed: A | B\n    reveal_type(y)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Literal Result Types with Membership Tests in Python\nDESCRIPTION: Demonstrates how __contains__ methods with literal return types can result in BooleanLiteral outcomes for 'in' and 'not in' operations, providing more precise type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass AlwaysTrue:\n    def __contains__(self, item: int) -> Literal[1]:\n        return 1\n\nclass AlwaysFalse:\n    def __contains__(self, item: int) -> Literal[\"\"]:\n        return \"\"\n\nreveal_type(42 in AlwaysTrue())  # revealed: Literal[True]\nreveal_type(42 not in AlwaysTrue())  # revealed: Literal[False]\n\nreveal_type(42 in AlwaysFalse())  # revealed: Literal[False]\nreveal_type(42 not in AlwaysFalse())  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Truthiness Evaluation of Literal Types in Python\nDESCRIPTION: Demonstrates type checking of boolean conversions for various literal types, including numeric literals, strings, and custom truth types. Shows how the type system handles known true and false values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/truthiness.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\nfrom knot_extensions import AlwaysFalsy, AlwaysTruthy\n\ndef _(\n    a: Literal[1],\n    b: Literal[-1],\n    c: Literal[\"foo\"],\n    d: tuple[Literal[0]],\n    e: Literal[1, 2],\n    f: AlwaysTruthy,\n):\n    reveal_type(bool(a))  # revealed: Literal[True]\n    reveal_type(bool(b))  # revealed: Literal[True]\n    reveal_type(bool(c))  # revealed: Literal[True]\n    reveal_type(bool(d))  # revealed: Literal[True]\n    reveal_type(bool(e))  # revealed: Literal[True]\n    reveal_type(bool(f))  # revealed: Literal[True]\n\ndef _(\n    a: tuple[()],\n    b: Literal[0],\n    c: Literal[\"\"],\n    d: Literal[b\"\"],\n    e: Literal[0, 0],\n    f: AlwaysFalsy,\n):\n    reveal_type(bool(a))  # revealed: Literal[False]\n    reveal_type(bool(b))  # revealed: Literal[False]\n    reveal_type(bool(c))  # revealed: Literal[False]\n    reveal_type(bool(d))  # revealed: Literal[False]\n    reveal_type(bool(e))  # revealed: Literal[False]\n    reveal_type(bool(f))  # revealed: Literal[False]\n\ndef _(\n    a: str,\n    b: Literal[1, 0],\n    c: str | Literal[0],\n    d: str | Literal[1],\n):\n    reveal_type(bool(a))  # revealed: bool\n    reveal_type(bool(b))  # revealed: bool\n    reveal_type(bool(c))  # revealed: bool\n    reveal_type(bool(d))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Method Calls on Literals in Python\nDESCRIPTION: Shows method calls on boolean, integer, string, and bytes literals, demonstrating type inference and error detection.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(True.bit_length())  # revealed: int\nreveal_type(True.as_integer_ratio())  # revealed: tuple[int, Literal[1]]\n\nreveal_type((42).bit_length())  # revealed: int\n\nreveal_type(\"abcde\".find(\"abc\"))  # revealed: int\nreveal_type(\"foo\".encode(encoding=\"utf-8\"))  # revealed: bytes\n\n\"abcde\".find(123)  # error: [invalid-argument-type]\n\nreveal_type(b\"abcde\".startswith(b\"abc\"))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Qualified Imported Class Type Usage\nDESCRIPTION: Demonstrates using type[] with qualified imported class names.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport a\n\ndef f(c: type[a.B]):\n    reveal_type(c)  # revealed: type[B]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass B: ...\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Non-Matching Match Statement with Guard in Python\nDESCRIPTION: Shows how type analysis handles a match statement with a guard where the scrutinee is known not to match. The guard has no influence since the pattern won't match.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nx = 1\n\nmatch \"something else\":\n    case \"a\" if flag():\n        x = 2\n    case \"b\":\n        x = 3\n    case _:\n        pass\n\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Typevar Constraints Example\nDESCRIPTION: Examples showing how upper bounds constrain typevar usage and affect return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef good_param[T: int](x: T) -> None:\n    reveal_type(x)  # revealed: T\n\ndef good_return[T: int](x: T) -> T:\n    return x\n\ndef bad_return[T: int](x: T) -> T:\n    return x + 1\n```\n\n----------------------------------------\n\nTITLE: Checking Fully Static Types in Python\nDESCRIPTION: Shows how to verify if types are fully static using is_fully_static. Tests various type combinations including unions and Any types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_fully_static, static_assert\nfrom typing import Any\n\nstatic_assert(is_fully_static(int | str))\nstatic_assert(is_fully_static(type[int]))\n\nstatic_assert(not is_fully_static(int | Any))\nstatic_assert(not is_fully_static(type[Any]))\n```\n\n----------------------------------------\n\nTITLE: Basic Property Getter Implementation in Python\nDESCRIPTION: Demonstrates the basic usage of @property decorator to create a read-only property with type hints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def my_property(self) -> int:\n        return 1\n\nreveal_type(C().my_property)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Assigning Ellipsis to Class and Module Symbols in Stub Files\nDESCRIPTION: The ellipsis literal can be assigned to class or module symbols in stub files regardless of their declared types. The type system honors the annotated type for typed variables and assumes Unknown for untyped variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ny: bytes = ...\nreveal_type(y)  # revealed: bytes\nx = ...\nreveal_type(x)  # revealed: Unknown\n\nclass Foo:\n    y: int = ...\n\nreveal_type(Foo.y)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Assigning ClassVar Attributes in Python\nDESCRIPTION: Illustrates setting ClassVar attributes on class objects and instances. Shows that these can only be set on class objects, with an error when attempting to set on an instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nclass C:\n    attr: ClassVar[int] = 0\n\nC.attr = 1  # fine\nC.attr = \"wrong\"  # error: [invalid-assignment]\n\ninstance = C()\ninstance.attr = 1  # error: [invalid-attribute-access]\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in nested `then` branch in Python\nDESCRIPTION: This function demonstrates a nested `if` statement where the exception is raised in the inner `then` branch. It explores how the type of variable `x` changes based on the different execution paths within the nested conditional and how `reveal_type` is used to infer the union of possible types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_nested_then_branch(cond1: bool, cond2: bool):\n    x = \"before\"\n    try:\n        if cond1:\n            x = \"else1\"\n            reveal_type(x)  # revealed: Literal[\"else1\"]\n        else:\n            if cond2:\n                x = \"raise\"\n                reveal_type(x)  # revealed: Literal[\"raise\"]\n                raise ValueError\n            else:\n                x = \"else2\"\n                reveal_type(x)  # revealed: Literal[\"else2\"]\n            reveal_type(x)  # revealed: Literal[\"else2\"]\n        reveal_type(x)  # revealed: Literal[\"else1\", \"else2\"]\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"raise\", \"else2\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"raise\", \"else2\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"else1\", \"else2\"]\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"raise\", \"else2\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"raise\", \"else2\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in Single Branch If Statements\nDESCRIPTION: Illustrates type narrowing behavior in if statements without explicit else branches, showing effects on multiple variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/post_if_statement.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int | None, y: int | None):\n    if x is None:\n        x = 0\n\n    if y is None:\n        pass\n\n    reveal_type(x)  # revealed: int\n    reveal_type(y)  # revealed: int | None\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dunder Method Lookup on Metaclass in Python\nDESCRIPTION: This code snippet shows that when invoking a dunder method on a class, it is looked up on the metaclass. It defines a Meta class with a __getitem__ method and a DunderOnMetaclass that uses this metaclass.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Meta(type):\n    def __getitem__(cls, key: int) -> str:\n        return str(key)\n\nclass DunderOnMetaclass(metaclass=Meta):\n    pass\n\nreveal_type(DunderOnMetaclass[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Multi-line String Annotations in Python\nDESCRIPTION: Demonstrates how multi-line string annotations are parsed, showing that valid annotations are treated as if surrounded by parentheses, and highlighting invalid syntax examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef valid(\n    a1: \"\"\"(\n      int |\n      str\n  )\n  \"\"\",\n    a2: \"\"\"\n     int |\n       str\n  \"\"\",\n):\n    reveal_type(a1)  # revealed: int | str\n    reveal_type(a2)  # revealed: int | str\n\ndef invalid(\n    # error: [invalid-syntax-in-forward-annotation]\n    a1: \"\"\"\n  int |\nstr)\n\"\"\",\n    # error: [invalid-syntax-in-forward-annotation]\n    a2: \"\"\"\n  int) |\nstr\n\"\"\",\n    # error: [invalid-syntax-in-forward-annotation]\n    a3: \"\"\"\n      (int)) \"\"\",\n):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Boolean Singleton\nDESCRIPTION: Shows type narrowing when comparing against the False singleton value. Demonstrates how boolean comparisons affect type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = True if flag else False\n\n    if x != False:\n        reveal_type(x)  # revealed: Literal[True]\n    else:\n        # TODO should be Literal[False]\n        reveal_type(x)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Configuring Simple Stub Package in TOML\nDESCRIPTION: Sets up the environment with an extra path for package stubs.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Intersection Operations with Constrained TypeVars in Python\nDESCRIPTION: Explains how constrained typevars can be modeled using a hypothetical OneOf connector and how intersections with them simplify based on the relationship with constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef constrained[T: (Base, Sub, Unrelated)](t: T) -> None:\n    def _(x: Intersection[T, Base]) -> None:\n        # With OneOf this would be OneOf[Base, Sub]\n        reveal_type(x)  # revealed: T & Base\n\n    def _(x: Intersection[T, Unrelated]) -> None:\n        reveal_type(x)  # revealed: Unrelated\n\n    def _(x: Intersection[T, Sub]) -> None:\n        reveal_type(x)  # revealed: Sub\n\n    def _(x: Intersection[T, None]) -> None:\n        reveal_type(x)  # revealed: Never\n\n    def _(x: Intersection[T, Any]) -> None:\n        reveal_type(x)  # revealed: T & Any\n```\n\n----------------------------------------\n\nTITLE: Performing Platform Substring Comparison in Python\nDESCRIPTION: Python code demonstrating the recommended approach of using startswith() for platform checks. This allows checking for platform families rather than exact versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.platform.startswith(\"freebsd\"))  # revealed: Literal[True]\nreveal_type(sys.platform.startswith(\"linux\"))  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Testing Type and Class Literal Assignability in Python\nDESCRIPTION: Demonstrates the complex relationships between different forms of type objects, including type[str], TypeOf[str], type[object], and type[Any], showing which are assignable to each other based on their conceptual meanings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Unknown, TypeOf\nfrom typing import Any\n\nstatic_assert(is_assignable_to(type, type))\nstatic_assert(is_assignable_to(type[object], type[object]))\n\nstatic_assert(is_assignable_to(type, type[object]))\nstatic_assert(is_assignable_to(type[object], type))\n\nstatic_assert(is_assignable_to(type[str], type[object]))\nstatic_assert(is_assignable_to(TypeOf[str], type[object]))\nstatic_assert(is_assignable_to(type[str], type))\nstatic_assert(is_assignable_to(TypeOf[str], type))\n\nstatic_assert(is_assignable_to(type[str], type[str]))\nstatic_assert(is_assignable_to(TypeOf[str], type[str]))\n\nstatic_assert(not is_assignable_to(TypeOf[int], type[str]))\nstatic_assert(not is_assignable_to(type, type[str]))\nstatic_assert(not is_assignable_to(type[object], type[str]))\n\nstatic_assert(is_assignable_to(type[Any], type[Any]))\nstatic_assert(is_assignable_to(type[Any], type[object]))\nstatic_assert(is_assignable_to(type[object], type[Any]))\nstatic_assert(is_assignable_to(type, type[Any]))\nstatic_assert(is_assignable_to(type[Any], type[str]))\nstatic_assert(is_assignable_to(type[str], type[Any]))\nstatic_assert(is_assignable_to(TypeOf[str], type[Any]))\n\nstatic_assert(is_assignable_to(type[Unknown], type[Unknown]))\nstatic_assert(is_assignable_to(type[Unknown], type[object]))\nstatic_assert(is_assignable_to(type[object], type[Unknown]))\nstatic_assert(is_assignable_to(type, type[Unknown]))\nstatic_assert(is_assignable_to(type[Unknown], type[str]))\nstatic_assert(is_assignable_to(type[str], type[Unknown]))\nstatic_assert(is_assignable_to(TypeOf[str], type[Unknown]))\n\nstatic_assert(is_assignable_to(type[Unknown], type[Any]))\nstatic_assert(is_assignable_to(type[Any], type[Unknown]))\n\nstatic_assert(not is_assignable_to(object, type[Any]))\nstatic_assert(not is_assignable_to(str, type[Any]))\n\nclass Meta(type): ...\n\nstatic_assert(is_assignable_to(type[Any], Meta))\nstatic_assert(is_assignable_to(type[Unknown], Meta))\nstatic_assert(is_assignable_to(Meta, type[Any]))\nstatic_assert(is_assignable_to(Meta, type[Unknown]))\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Non-Fully Static Type Annotations in Python\nDESCRIPTION: This snippet shows how type inference works when a parameter has a non-fully static type annotation (like Any) with a default value. The default value type becomes a lower bound on the inferred type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef f(x: Any = 1):\n    reveal_type(x)  # revealed: Any | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Implementing Unary Operators for Class Instances\nDESCRIPTION: Demonstrates implementation of custom unary operators (__pos__, __neg__, __invert__) in a base class and their inheritance behavior. Shows type checking and error handling for supported and unsupported operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/custom.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Yes:\n    def __pos__(self) -> bool:\n        return False\n\n    def __neg__(self) -> str:\n        return \"negative\"\n\n    def __invert__(self) -> int:\n        return 17\n\nclass Sub(Yes): ...\nclass No: ...\n\nreveal_type(+Yes())  # revealed: bool\nreveal_type(-Yes())  # revealed: str\nreveal_type(~Yes())  # revealed: int\n\nreveal_type(+Sub())  # revealed: bool\nreveal_type(-Sub())  # revealed: str\nreveal_type(~Sub())  # revealed: int\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `No`\"\nreveal_type(+No())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `No`\"\nreveal_type(-No())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `No`\"\nreveal_type(~No())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Nested While Loops Type Checking in Python\nDESCRIPTION: Shows type checking behavior in nested while loops with break statements and else clauses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nx = 1\n\nwhile flag():\n    x = 2\n\n    while flag():\n        x = 3\n        if flag():\n            break\n    else:\n        x = 4\n\n    if flag():\n        break\nelse:\n    x = 5\n\nreveal_type(x)  # revealed: Literal[3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Accessing Unknown Attributes with __getattr__\nDESCRIPTION: Shows how type inference works when accessing arbitrary attributes on a class with __getattr__, returning the type specified in the __getattr__ method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nc = CustomGetAttr()\n\nreveal_type(c.whatever)  # revealed: GetAttrReturnType\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with __new__ method in Python\nDESCRIPTION: Demonstrates the behavior when a class defines a custom __new__ method, including type checking and error handling for various argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __new__(cls, x: int) -> \"Foo\":\n        return object.__new__(cls)\n\nreveal_type(Foo(1))  # revealed: Foo\n\n# error: [missing-argument] \"No argument provided for required parameter `x` of function `__new__`\"\nreveal_type(Foo())  # revealed: Foo\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `__new__`: expected 1, got 2\"\nreveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Object Identity Check\nDESCRIPTION: Shows type narrowing when comparing object identity using 'is' between two variables. Demonstrates how the type system handles custom class instances and None unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A: ...\n    x = A()\n    y = x if flag else None\n\n    if y is x:\n        reveal_type(y)  # revealed: A\n    else:\n        reveal_type(y)  # revealed: A | None\n\n    reveal_type(y)  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Class Union Operation in Python 3.10+\nDESCRIPTION: Demonstrates using the | operator to create a union of two classes in Python 3.10 or later versions, which returns a UnionType.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/classes.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\nreveal_type(A | B)  # revealed: UnionType\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching in Python\nDESCRIPTION: This snippet shows a basic pattern matching scenario where the variable 'y' is assigned different values based on the match cases. It demonstrates how the type of 'y' is inferred after the match statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(target: int):\n    y = 1\n    y = 2\n\n    match target:\n        case 1:\n            y = 3\n        case 2:\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Successful Deferred Annotations with __future__.annotations\nDESCRIPTION: Demonstrates how importing __future__.annotations properly enables deferred annotations in regular Python files, allowing forward references to work correctly.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\ndef get_foo() -> Foo:\n    return Foo()\n\nclass Foo: ...\n\nreveal_type(get_foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Classmethod Error Detection\nDESCRIPTION: Demonstrates error detection for incorrect classmethod calls including invalid arguments and argument count mismatches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nC.f(\"incorrect\")  # error: [invalid-argument-type]\nC.f()  # error: [missing-argument]\nC.f(1, 2)  # error: [too-many-positional-arguments]\n```\n\n----------------------------------------\n\nTITLE: Or Pattern Match Type Narrowing\nDESCRIPTION: Demonstrates type narrowing with or patterns (|) combining multiple value types and their resulting union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case \"foo\" | 42 | None:\n        reveal_type(x)  # revealed: Literal[\"foo\", 42] | None\n    case \"foo\" | tuple():\n        reveal_type(x)  # revealed: Literal[\"foo\"] | tuple\n    case True | False:\n        reveal_type(x)  # revealed: bool\n    case 3.14 | 2.718 | 1.414:\n        reveal_type(x)  # revealed: float\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Function Descriptors Implementation\nDESCRIPTION: Shows how Python functions implement the descriptor protocol through __get__ method, enabling method call behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: object) -> str:\n    return \"a\"\n\nreveal_type(f)  # revealed: def f(x: object) -> str\nreveal_type(f.__get__)  # revealed: <method-wrapper `__get__` of `f`>\nreveal_type(f.__get__(None, type(f)))  # revealed: def f(x: object) -> str\nreveal_type(f.__get__(None, type(f))(1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Generic Classes\nDESCRIPTION: Shows type narrowing behavior with generic classes, demonstrating that runtime type checks operate on erased types without specializations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass A[T = int]: ...\nclass B: ...\n\ndef _[T](x: A | B):\n    if type(x) is A[str]:\n        reveal_type(x)  # revealed: A[int] & A[Unknown] | B & A[Unknown]\n    else:\n        reveal_type(x)  # revealed: A[int] | B\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with type(x) is not C Pattern\nDESCRIPTION: Shows type narrowing behavior with 'type(x) is not A' pattern. Similar to the positive case, full union type must be maintained in the negative branch.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B):\n    if type(x) is not A:\n        # Same reasoning as above: no narrowing should occur here.\n        reveal_type(x)  # revealed: A | B\n    else:\n        reveal_type(x)  # revealed: A\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Parameter Specification\nDESCRIPTION: Example showing explicit type parameter specification in generic classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    x: T\n\nreveal_type(C[int]())  # revealed: C[int]\n```\n\n----------------------------------------\n\nTITLE: Testing Equivalence of Differently Ordered Unions and Intersections in Python\nDESCRIPTION: This code demonstrates that union and intersection types with differently ordered components are equivalent. It shows various permutations of union types (P | Q | R) and intersection types that are equivalent regardless of the order of their components.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_equivalent_to, static_assert, Intersection, Not\n\nclass P: ...\nclass Q: ...\nclass R: ...\nclass S: ...\n\nstatic_assert(is_equivalent_to(P | Q | R, P | R | Q))  # 1\nstatic_assert(is_equivalent_to(P | Q | R, Q | P | R))  # 2\nstatic_assert(is_equivalent_to(P | Q | R, Q | R | P))  # 3\nstatic_assert(is_equivalent_to(P | Q | R, R | P | Q))  # 4\nstatic_assert(is_equivalent_to(P | Q | R, R | Q | P))  # 5\nstatic_assert(is_equivalent_to(P | R | Q, Q | P | R))  # 6\nstatic_assert(is_equivalent_to(P | R | Q, Q | R | P))  # 7\nstatic_assert(is_equivalent_to(P | R | Q, R | P | Q))  # 8\nstatic_assert(is_equivalent_to(P | R | Q, R | Q | P))  # 9\nstatic_assert(is_equivalent_to(Q | P | R, Q | R | P))  # 10\nstatic_assert(is_equivalent_to(Q | P | R, R | P | Q))  # 11\nstatic_assert(is_equivalent_to(Q | P | R, R | Q | P))  # 12\nstatic_assert(is_equivalent_to(Q | R | P, R | P | Q))  # 13\nstatic_assert(is_equivalent_to(Q | R | P, R | Q | P))  # 14\nstatic_assert(is_equivalent_to(R | P | Q, R | Q | P))  # 15\n\nstatic_assert(is_equivalent_to(str | None, None | str))\n\nstatic_assert(is_equivalent_to(Intersection[P, Q], Intersection[Q, P]))\nstatic_assert(is_equivalent_to(Intersection[Q, Not[P]], Intersection[Not[P], Q]))\nstatic_assert(is_equivalent_to(Intersection[Q, R, Not[P]], Intersection[Not[P], R, Q]))\nstatic_assert(is_equivalent_to(Intersection[Q | R, Not[P | S]], Intersection[Not[S | P], R | Q]))\n```\n\n----------------------------------------\n\nTITLE: Continue Statements in Nested Conditional Blocks\nDESCRIPTION: Explores the complexities of continue statements in nested conditionals within loops. Shows how type inference currently works and notes the limitations in tracking all possible values after the loop completes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef continue_in_nested_then_branch(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop1\"\n            reveal_type(x)  # revealed: Literal[\"loop1\"]\n        else:\n            if cond2:\n                x = \"continue\"\n                reveal_type(x)  # revealed: Literal[\"continue\"]\n                continue\n            else:\n                x = \"loop2\"\n                reveal_type(x)  # revealed: Literal[\"loop2\"]\n            reveal_type(x)  # revealed: Literal[\"loop2\"]\n        reveal_type(x)  # revealed: Literal[\"loop1\", \"loop2\"]\n    # TODO: Should be Literal[\"before\", \"loop1\", \"loop2\", \"continue\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop1\", \"loop2\"]\n\ndef continue_in_nested_else_branch(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop1\"\n            reveal_type(x)  # revealed: Literal[\"loop1\"]\n        else:\n            if cond2:\n                x = \"loop2\"\n                reveal_type(x)  # revealed: Literal[\"loop2\"]\n            else:\n                x = \"continue\"\n                reveal_type(x)  # revealed: Literal[\"continue\"]\n                continue\n            reveal_type(x)  # revealed: Literal[\"loop2\"]\n        reveal_type(x)  # revealed: Literal[\"loop1\", \"loop2\"]\n    # TODO: Should be Literal[\"before\", \"loop1\", \"loop2\", \"continue\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop1\", \"loop2\"]\n\ndef continue_in_both_nested_branches(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        else:\n            if cond2:\n                x = \"continue1\"\n                reveal_type(x)  # revealed: Literal[\"continue1\"]\n                continue\n            else:\n                x = \"continue2\"\n                reveal_type(x)  # revealed: Literal[\"continue2\"]\n                continue\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    # TODO: Should be Literal[\"before\", \"loop\", \"continue1\", \"continue2\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Possibly Undeclared Variables in Python\nDESCRIPTION: This snippet shows a scenario where a variable is conditionally declared but not assigned. It demonstrates how this affects type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    x: int\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference with Unified Branches in Try-Except Block\nDESCRIPTION: This snippet shows how type inference works when both try and except branches result in the same type for a variable. The final inferred type is not a union in this case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ntry:\n    x = could_raise_returns_str()\nexcept:\n    x = could_raise_returns_str()\n\nreveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Basic Conditionals\nDESCRIPTION: Demonstrates how type narrowing works with simple integer comparisons in if-elif blocks. Shows how positive contributions become negative in subsequent branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/elif_else.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int):\n    if x == 1:\n        # cannot narrow; could be a subclass of `int`\n        reveal_type(x)  # revealed: int\n    elif x == 2:\n        reveal_type(x)  # revealed: int & ~Literal[1]\n    elif x != 3:\n        reveal_type(x)  # revealed: int & ~Literal[1] & ~Literal[2] & ~Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Handling Return Statements in Conditionals\nDESCRIPTION: Shows how `return` statements affect variable binding resolution. When a branch ends with a return statement, control flow does not continue past that point, which impacts type analysis and reference resolution.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef resolved_reference(cond: bool) -> str:\n    if cond:\n        x = \"test\"\n    else:\n        return \"early\"\n    return x  # no possibly-unresolved-reference diagnostic!\n\ndef return_in_then_branch(cond: bool):\n    if cond:\n        x = \"terminal\"\n        reveal_type(x)  # revealed: Literal[\"terminal\"]\n        return\n    else:\n        x = \"test\"\n        reveal_type(x)  # revealed: Literal[\"test\"]\n    reveal_type(x)  # revealed: Literal[\"test\"]\n\ndef return_in_else_branch(cond: bool):\n    if cond:\n        x = \"test\"\n        reveal_type(x)  # revealed: Literal[\"test\"]\n    else:\n        x = \"terminal\"\n        reveal_type(x)  # revealed: Literal[\"terminal\"]\n        return\n    reveal_type(x)  # revealed: Literal[\"test\"]\n\ndef return_in_both_branches(cond: bool):\n    if cond:\n        x = \"terminal1\"\n        reveal_type(x)  # revealed: Literal[\"terminal1\"]\n        return\n    else:\n        x = \"terminal2\"\n        reveal_type(x)  # revealed: Literal[\"terminal2\"]\n        return\n```\n\n----------------------------------------\n\nTITLE: Basic While Loop Type Narrowing in Python\nDESCRIPTION: Demonstrates basic type narrowing in a while loop where a variable of type int | None is narrowed to int within the loop and None after the loop.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/while.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef next_item() -> int | None:\n    return 1\n\nx = next_item()\n\nwhile x is not None:\n    reveal_type(x)  # revealed: int\n    x = next_item()\n\nreveal_type(x)  # revealed: None\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'not is None' Check\nDESCRIPTION: Demonstrates type narrowing behavior when using 'not is None' check. Shows how a variable of type Optional[int] gets narrowed to Literal[1] in the true branch and None in the false branch.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = None if flag else 1\n\n    if not x is None:\n        reveal_type(x)  # revealed: Literal[1]\n    else:\n        reveal_type(x)  # revealed: None\n\n    reveal_type(x)  # revealed: None | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Implementing __len__ with Literal Integers in Python\nDESCRIPTION: This snippet shows custom class implementations of `__len__` that return Literal integer types. It demonstrates how `len()` behaves with these custom objects and highlights cases where diagnostics should be emitted.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Zero:\n    def __len__(self) -> Literal[0]:\n        return 0\n\nclass ZeroOrOne:\n    def __len__(self) -> Literal[0, 1]:\n        return 0\n\nclass ZeroOrTrue:\n    def __len__(self) -> Literal[0, True]:\n        return 0\n\nclass OneOrFalse:\n    def __len__(self) -> Literal[1] | Literal[False]:\n        return 1\n\nclass OneOrFoo:\n    def __len__(self) -> Literal[1, \"foo\"]:\n        return 1\n\nclass ZeroOrStr:\n    def __len__(self) -> Literal[0] | str:\n        return 0\n\nreveal_type(len(Zero()))  # revealed: Literal[0]\nreveal_type(len(ZeroOrOne()))  # revealed: Literal[0, 1]\nreveal_type(len(ZeroOrTrue()))  # revealed: Literal[0, 1]\nreveal_type(len(OneOrFalse()))  # revealed: Literal[1, 0]\n\n# TODO: Emit a diagnostic\nreveal_type(len(OneOrFoo()))  # revealed: int\n\n# TODO: Emit a diagnostic\nreveal_type(len(ZeroOrStr()))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Revealing sys.version_info Type\nDESCRIPTION: Basic type revelation of sys.version_info showing it as _version_info type\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info)  # revealed: _version_info\n```\n\n----------------------------------------\n\nTITLE: System Import Configuration\nDESCRIPTION: TOML configuration specifying system import settings\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nsystem = \"os\"\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Unbound __iter__ with Possibly Invalid __getitem__ in Python\nDESCRIPTION: Tests type inference in the complex case where both __iter__ and __getitem__ might be problematic. The system should infer a union of all possible element types from both methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\nclass Iterator:\n    def __next__(self) -> bytes:\n        return b\"foo\"\n\ndef _(flag: bool, flag2: bool):\n    class Iterable1:\n        if flag:\n            def __getitem__(self, item: int) -> str:\n                return \"foo\"\n        else:\n            __getitem__: None = None\n\n        if flag2:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n\n    class Iterable2:\n        if flag:\n            def __getitem__(self, item: int) -> str:\n                return \"foo\"\n        else:\n            def __getitem__(self, item: str) -> int:\n                return 42\n        if flag2:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n\n    # error: [not-iterable]\n    for x in Iterable1():\n        # TODO: `bytes | str` might be better\n        reveal_type(x)  # revealed: bytes | str | Unknown\n\n    # error: [not-iterable]\n    for y in Iterable2():\n        reveal_type(y)  # revealed: bytes | str | int\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with __new__ method in superclass in Python\nDESCRIPTION: Shows how the __new__ method defined in a superclass affects the instantiation of a subclass, including type checking and error handling.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nclass Base:\n    def __new__(cls, x: int) -> Self: ...\n\nclass Foo(Base): ...\n\nreveal_type(Foo(1))  # revealed: Foo\n\n# error: [missing-argument] \"No argument provided for required parameter `x` of function `__new__`\"\nreveal_type(Foo())  # revealed: Foo\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `__new__`: expected 1, got 2\"\nreveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Basic Wrapper Descriptor Usage with Class Binding\nDESCRIPTION: Demonstrates how to use wrapper descriptors to bind a free function to a class instance, including type revelation and method binding.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\nbound_method = wrapper_descriptor(f, C(), C)\n\nreveal_type(bound_method)  # revealed: bound method C.f() -> str\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Linting in pyproject.toml\nDESCRIPTION: TOML configuration to exclude Jupyter Notebook files from linting operations while still allowing formatting in pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Basic Type Alias Usage\nDESCRIPTION: Demonstrates basic usage of type aliases with reveal_type checks showing type information at different scopes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntype IntOrStr = int | str\n\nreveal_type(IntOrStr)  # revealed: typing.TypeAliasType\nreveal_type(IntOrStr.__name__)  # revealed: Literal[\"IntOrStr\"]\n\nx: IntOrStr = 1\n\nreveal_type(x)  # revealed: Literal[1]\n\ndef f() -> None:\n    reveal_type(x)  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Binary Operations with Literal Types in Python\nDESCRIPTION: Demonstrates how binary operations work with literal types and instances of custom classes. Shows type inference in various scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> \"A\":\n        return self\n\n    def __radd__(self, other) -> \"A\":\n        return self\n\nreveal_type(A() + 1)  # revealed: A\nreveal_type(1 + A())  # revealed: A\n\nreveal_type(A() + \"foo\")  # revealed: A\n# TODO should be `A` since `str.__add__` doesn't support `A` instances\n# TODO overloads\nreveal_type(\"foo\" + A())  # revealed: @Todo(return type of overloaded function)\n\nreveal_type(A() + b\"foo\")  # revealed: A\n# TODO should be `A` since `bytes.__add__` doesn't support `A` instances\nreveal_type(b\"foo\" + A())  # revealed: bytes\n\nreveal_type(A() + ())  # revealed: A\n# TODO this should be `A`, since `tuple.__add__` doesn't support `A` instances\nreveal_type(() + A())  # revealed: @Todo(return type of overloaded function)\n\nliteral_string_instance = \"foo\" * 1_000_000_000\n# the test is not testing what it's meant to be testing if this isn't a `LiteralString`:\nreveal_type(literal_string_instance)  # revealed: LiteralString\n\nreveal_type(A() + literal_string_instance)  # revealed: A\n# TODO should be `A` since `str.__add__` doesn't support `A` instances\n# TODO overloads\nreveal_type(literal_string_instance + A())  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Deferring Annotations in Python Stub Files\nDESCRIPTION: This snippet shows how annotations in stub files are deferred, similar to future annotations, allowing forward references.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nx: Foo\n\nclass Foo: ...\n\nx = Foo()\nreveal_type(x)  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Testing Final Class Inheritance Restrictions in Python\nDESCRIPTION: Demonstrates invalid inheritance patterns when using @final and @typing_extensions.final decorators. Shows error cases when attempting to subclass final classes directly or through multiple inheritance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/final.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport typing_extensions\nfrom typing import final\n\n@final\nclass A: ...\n\nclass B(A): ...  # error: 9 [subclass-of-final-class] \"Class `B` cannot inherit from final class `A`\"\n\n@typing_extensions.final\nclass C: ...\n\nclass D(C): ...  # error: [subclass-of-final-class]\nclass E: ...\nclass F: ...\nclass G: ...\n\n# fmt: off\nclass H(\n    E,\n    F,\n    A,  # error: [subclass-of-final-class]\n    G,\n): ...\n```\n\n----------------------------------------\n\nTITLE: Python Class Attribute Type Analysis\nDESCRIPTION: Illustrates different patterns of attribute definition and type checking in a Python class, including always-bound attributes, union types, declared unions, and possibly unbound attributes. Shows how type checking reveals different types based on attribute definition patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/attribute.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A:\n        always_bound: int = 1\n\n        if flag:\n            union = 1\n        else:\n            union = \"abc\"\n\n        if flag:\n            union_declared: int = 1\n        else:\n            union_declared: str = \"abc\"\n\n        if flag:\n            possibly_unbound: str = \"abc\"\n\n    reveal_type(A.always_bound)  # revealed: int\n\n    reveal_type(A.union)  # revealed: Unknown | Literal[1, \"abc\"]\n\n    reveal_type(A.union_declared)  # revealed: int | str\n\n    # error: [possibly-unbound-attribute] \"Attribute `possibly_unbound` on type `Literal[A]` is possibly unbound\"\n    reveal_type(A.possibly_unbound)  # revealed: str\n\n    # error: [unresolved-attribute] \"Type `Literal[A]` has no attribute `non_existent`\"\n    reveal_type(A.non_existent)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Error: Context Manager Without __exit__ Method\nDESCRIPTION: Illustrates the error when a class implements __enter__ but not __exit__, making it an invalid context manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Manager:\n    def __enter__(self): ...\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not implement `__exit__`\"\nwith Manager():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Setting Ruff Language Server Trace Level in JSON\nDESCRIPTION: Controls the trace level for the language server according to the LSP specification, determining the verbosity of server logs.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.trace.server\": \"messages\"\n}\n```\n\n----------------------------------------\n\nTITLE: Deferred Type Resolution with String Annotations in Python\nDESCRIPTION: Demonstrates how string annotations can refer to classes defined later in the code. This allows forward references to types that aren't yet defined.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f(v: \"Foo\"):\n    reveal_type(v)  # revealed: Foo\n\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Single Solid Base Class Pattern with __slots__\nDESCRIPTION: Shows a pattern where multiple inheritance is compatible as long as all classes inherit from a common base with __slots__. This is a safe pattern for multiple inheritance with slots.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = (\"a\", \"b\")\n\nclass B(A): ...\nclass C(A): ...\nclass D(B, A): ...  # fine\nclass E(B, C, A): ...  # fine\n```\n\n----------------------------------------\n\nTITLE: Deferred Annotations in Stub Files (.pyi)\nDESCRIPTION: Demonstrates how annotations in stub files (.pyi) are automatically deferred, allowing forward references to work without explicit __future__ imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef get_foo() -> Foo: ...\nclass Foo: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import get_foo\n\nreveal_type(get_foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Using type[...] with a Trivial Constructor Class in Python\nDESCRIPTION: Demonstrates the basic usage of type[C] annotation for a simple class with no constructor parameters. The revealed type of instances created from a subclass of C is C.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/subclass_of.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\ndef _(subclass_of_c: type[C]):\n    reveal_type(subclass_of_c())  # revealed: C\n```\n\n----------------------------------------\n\nTITLE: Error Case: Illegal ClassVar Usage in Type Expressions in Python\nDESCRIPTION: Demonstrates illegal usage of ClassVar in type expressions rather than annotation expressions. The example shows that ClassVar cannot be used in union types or as part of other type operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nclass C:\n    # error: [invalid-type-form] \"Type qualifier `typing.ClassVar` is not allowed in type expressions (only in annotation expressions)\"\n    x: ClassVar | int\n\n    # error: [invalid-type-form] \"Type qualifier `typing.ClassVar` is not allowed in type expressions (only in annotation expressions)\"\n    y: int | ClassVar[str]\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Pure Instance Variables in Python\nDESCRIPTION: Demonstrates the behavior of pure instance variables declared and bound in __init__. Shows type inference, access restrictions, and assignment rules for these variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self, param: int | None, flag: bool = False) -> None:\n        value = 1 if flag else \"a\"\n        self.inferred_from_value = value\n        self.inferred_from_other_attribute = self.inferred_from_value\n        self.inferred_from_param = param\n        self.declared_only: bytes\n        self.declared_and_bound: bool = True\n        if flag:\n            self.possibly_undeclared_unbound: str = \"possibly set in __init__\"\n\nc_instance = C(1)\n\nreveal_type(c_instance.inferred_from_value)  # revealed: Unknown | Literal[1, \"a\"]\n\n# TODO: Same here. This should be `Unknown | Literal[1, \"a\"]\n\"reveal_type(c_instance.inferred_from_other_attribute)  # revealed: Unknown\n\n# There is no special handling of attributes that are (directly) assigned to a declared parameter,\n# which means we union with `Unknown` here, since the attribute itself is not declared. This is\n# something that we might want to change in the future.\n#\n# See https://github.com/astral-sh/ruff/issues/15960 for a related discussion.\nreveal_type(c_instance.inferred_from_param)  # revealed: Unknown | int | None\n\nreveal_type(c_instance.declared_only)  # revealed: bytes\n\nreveal_type(c_instance.declared_and_bound)  # revealed: bool\n\n# error: [possibly-unbound-attribute]\nreveal_type(c_instance.possibly_undeclared_unbound)  # revealed: str\n\n# This assignment is fine, as we infer `Unknown | Literal[1, \"a\"]` for `inferred_from_value`.\nc_instance.inferred_from_value = \"value set on instance\"\n\n# This assignment is also fine:\nc_instance.declared_and_bound = False\n\n# error: [invalid-assignment] \"Object of type `Literal[\"incompatible\"]` is not assignable to attribute `declared_and_bound` of type `bool`\"\nc_instance.declared_and_bound = \"incompatible\"\n\n# mypy shows no error here, but pyright raises \"reportAttributeAccessIssue\"\n# error: [unresolved-attribute] \"Attribute `inferred_from_value` can only be accessed on instances, not on the class object `Literal[C]` itself.\"\nreveal_type(C.inferred_from_value)  # revealed: Unknown\n\n# mypy shows no error here, but pyright raises \"reportAttributeAccessIssue\"\n# error: [invalid-attribute-access] \"Cannot assign to instance attribute `inferred_from_value` from the class object `Literal[C]`\"\nC.inferred_from_value = \"overwritten on class\"\n\n# This assignment is fine:\nc_instance.declared_and_bound = False\n\n# TODO: After this assignment to the attribute within this scope, we may eventually want to narrow\n# the `bool` type (see above) for this instance variable to `Literal[False]` here. This is unsound\n# in general (we don't know what else happened to `c_instance` between the assignment and the use\n# here), but mypy and pyright support this. In conclusion, this could be `bool` but should probably\n# be `Literal[False]`.\nreveal_type(c_instance.declared_and_bound)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Method Inheritance and Binding in Python\nDESCRIPTION: Shows how methods are bound to instances of derived classes when accessed through inheritance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass D(C):\n    pass\n\nreveal_type(D().f)  # revealed: bound method D.f(x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing Constraint Behavior\nDESCRIPTION: Illustrates how type narrowing inside if-expressions does not affect the type inference outside of the expression context, maintaining the original union type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/if.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(flag: bool):\n    x: Literal[42, \"hello\"] = 42 if flag else \"hello\"\n\n    reveal_type(x)  # revealed: Literal[42, \"hello\"]\n\n    _ = ... if isinstance(x, str) else ...\n\n    reveal_type(x)  # revealed: Literal[42, \"hello\"]\n```\n\n----------------------------------------\n\nTITLE: CallableTypeOf Basic Usage in Python\nDESCRIPTION: Demonstrates basic usage and error cases of CallableTypeOf special form for extracting callable types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf\n\ndef f1():\n    return\n\ndef f2() -> int:\n    return 1\n\ndef f3(x: int, y: str) -> None:\n    return\n\n# error: [invalid-type-form] \"Special form `knot_extensions.CallableTypeOf` expected exactly one type parameter\"\nc1: CallableTypeOf[f1, f2]\n\n# error: [invalid-type-form] \"Expected the first argument to `knot_extensions.CallableTypeOf` to be a callable object, but got an object of type `Literal[\"foo\"]`\"\nc2: CallableTypeOf[\"foo\"]\n\n# error: [invalid-type-form] \"`knot_extensions.CallableTypeOf` requires exactly one argument when used in a type expression\"\ndef f(x: CallableTypeOf) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Boolean Literal Type Assignability in Python\nDESCRIPTION: Demonstrates how Boolean literal types (Literal[True] and Literal[False]) are assignable to bool and int types, following the language's hierarchy where booleans are subtypes of integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to\nfrom typing import Literal\n\nstatic_assert(is_assignable_to(Literal[True], Literal[True]))\nstatic_assert(is_assignable_to(Literal[True], bool))\nstatic_assert(is_assignable_to(Literal[True], int))\n\nstatic_assert(not is_assignable_to(Literal[True], Literal[False]))\nstatic_assert(not is_assignable_to(bool, Literal[True]))\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom __getattr__ Method in Python\nDESCRIPTION: Demonstrates how a class with a custom __getattr__ method affects type inference for unknown attributes, with attribute precedence rules explained.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef flag() -> bool:\n    return True\n\nclass GetAttrReturnType: ...\n\nclass CustomGetAttr:\n    class_attr: int = 1\n\n    if flag():\n        possibly_unbound: bytes = b\"a\"\n\n    def __init__(self) -> None:\n        self.instance_attr: str = \"a\"\n\n    def __getattr__(self, name: str) -> GetAttrReturnType:\n        return GetAttrReturnType()\n```\n\n----------------------------------------\n\nTITLE: Undeclared but Bound Symbol Usage in Python\nDESCRIPTION: Demonstrates type inference for undeclared but bound symbols, using unions with Unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Undeclared:\na = 1\n\n# Implicitly declared with `Unknown`, due to the usage of an unknown name in the annotation:\nb: SomeUnknownName = 1  # error: [unresolved-reference]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import a, b\n\nreveal_type(a)  # revealed: Unknown | Literal[1]\nreveal_type(b)  # revealed: Unknown\n\n# All external modifications of `a` are allowed:\na = None\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing With Mutation in One Branch\nDESCRIPTION: Shows how type narrowing persists when a variable is mutated in one branch of an if-else statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/post_if_statement.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int | None):\n    if x is None:\n        x = 10\n    else:\n        pass\n\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Except Block with Single Bare Except\nDESCRIPTION: This snippet demonstrates type inference in a try-except block with a single bare except clause. It shows how the type of variable 'x' changes throughout the block and how the final type is inferred as a union of possible types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef could_raise_returns_str() -> str:\n    return \"foo\"\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nexcept:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\n\nreveal_type(x)  # revealed: str | Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Type Alias __value__ Attribute\nDESCRIPTION: Shows the usage of the __value__ attribute on type aliases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntype IntOrStr = int | str\n\nreveal_type(IntOrStr.__value__)  # revealed: Any\n```\n\n----------------------------------------\n\nTITLE: Handling Variables Defined in Non-__init__ Methods in Python\nDESCRIPTION: Demonstrates type inference and access rules for instance variables defined in methods other than __init__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self, param: int | None, flag: bool = False) -> None:\n        self.initialize(param, flag)\n\n    def initialize(self, param: int | None, flag: bool) -> None:\n        value = 1 if flag else \"a\"\n        self.inferred_from_value = value\n        self.inferred_from_other_attribute = self.inferred_from_value\n        self.inferred_from_param = param\n        self.declared_only: bytes\n        self.declared_and_bound: bool = True\n\nc_instance = C(1)\n\nreveal_type(c_instance.inferred_from_value)  # revealed: Unknown | Literal[1, \"a\"]\n\n# TODO: Should be `Unknown | Literal[1, \"a\"]\nreveal_type(c_instance.inferred_from_other_attribute)  # revealed: Unknown\n\nreveal_type(c_instance.inferred_from_param)  # revealed: Unknown | int | None\n\nreveal_type(c_instance.declared_only)  # revealed: bytes\n\nreveal_type(c_instance.declared_and_bound)  # revealed: bool\n\n# error: [unresolved-attribute] \"Attribute `inferred_from_value` can only be accessed on instances, not on the class object `Literal[C]` itself.\"\nreveal_type(C.inferred_from_value)  # revealed: Unknown\n\n# error: [invalid-attribute-access] \"Cannot assign to instance attribute `inferred_from_value` from the class object `Literal[C]`\"\nC.inferred_from_value = \"overwritten on class\"\n```\n\n----------------------------------------\n\nTITLE: EllipsisType Handling Python 3.10+\nDESCRIPTION: Shows type narrowing with EllipsisType in Python 3.10 and above. Includes TOML configuration for Python version and demonstrates type narrowing with ellipsis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom types import EllipsisType\n\ndef _(x: int | EllipsisType):\n    if x is ...:\n        reveal_type(x)  # revealed: EllipsisType\n    else:\n        reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with __init__ method in superclass in Python\nDESCRIPTION: Shows how the __init__ method defined in a superclass affects the instantiation of a subclass, including type checking and error handling.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def __init__(self, x: int): ...\n\nclass Foo(Base): ...\n\nreveal_type(Foo(1))  # revealed: Foo\n\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__init__`\"\nreveal_type(Foo())  # revealed: Foo\n# error: [too-many-positional-arguments] \"Too many positional arguments to bound method `__init__`: expected 1, got 2\"\nreveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Accessing sys.platform Type with All Platforms Configuration\nDESCRIPTION: Python code that imports sys and reveals the type of sys.platform when configured for all platforms. The type is revealed as LiteralString.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.platform)  # revealed: LiteralString\n```\n\n----------------------------------------\n\nTITLE: Basic Literal Type Parameterization in Python\nDESCRIPTION: Demonstrates various ways to parameterize Literal types including strings, integers, bytes, booleans, and enum values. Shows type revelation and validation of different literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\nfrom enum import Enum\n\nmode: Literal[\"w\", \"r\"]\na1: Literal[26]\na2: Literal[0x1A]\na3: Literal[-4]\na4: Literal[\"hello world\"]\na5: Literal[b\"hello world\"]\na6: Literal[True]\na7: Literal[None]\na8: Literal[Literal[1]]\n\nclass Color(Enum):\n    RED = 0\n    GREEN = 1\n    BLUE = 2\n\nb1: Literal[Color.RED]\n\ndef f():\n    reveal_type(mode)  # revealed: Literal[\"w\", \"r\"]\n    reveal_type(a1)  # revealed: Literal[26]\n    reveal_type(a2)  # revealed: Literal[26]\n    reveal_type(a3)  # revealed: Literal[-4]\n    reveal_type(a4)  # revealed: Literal[\"hello world\"]\n    reveal_type(a5)  # revealed: Literal[b\"hello world\"]\n    reveal_type(a6)  # revealed: Literal[True]\n    reveal_type(a7)  # revealed: None\n    reveal_type(a8)  # revealed: Literal[1]\n    # TODO: This should be Color.RED\n    reveal_type(b1)  # revealed: @Todo(Attribute access on enum classes)\n\n# error: [invalid-type-form]\ninvalid1: Literal[3 + 4]\n# error: [invalid-type-form]\ninvalid2: Literal[4 + 3j]\n# error: [invalid-type-form]\ninvalid3: Literal[(3, 4)]\n\nhello = \"hello\"\ninvalid4: Literal[\n    1 + 2,  # error: [invalid-type-form]\n    \"foo\",\n    hello,  # error: [invalid-type-form]\n    (1, 2, 3),  # error: [invalid-type-form]\n]\n```\n\n----------------------------------------\n\nTITLE: Analyzing len() with Lists, Sets, and Dictionaries in Python\nDESCRIPTION: This snippet demonstrates the use of `len()` with lists, sets, and dictionaries, including empty and non-empty collections, as well as collections with star unpacking. It also shows the behavior with constructor calls for these types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(len([]))  # revealed: int\nreveal_type(len([1]))  # revealed: int\nreveal_type(len([1, 2]))  # revealed: int\nreveal_type(len([*{}, *dict()]))  # revealed: int\n\nreveal_type(len({}))  # revealed: int\nreveal_type(len({**{}}))  # revealed: int\nreveal_type(len({**{}, **{}}))  # revealed: int\n\nreveal_type(len({1}))  # revealed: int\nreveal_type(len({1, 2}))  # revealed: int\nreveal_type(len({*[], 2}))  # revealed: int\n\nreveal_type(len(list()))  # revealed: int\nreveal_type(len(set()))  # revealed: int\nreveal_type(len(dict()))  # revealed: int\nreveal_type(len(frozenset()))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Analyzing Continue Statements in Loop Control Flow\nDESCRIPTION: Demonstrates how continue statements affect control flow analysis within loops. Shows how variables assigned before a continue statement may or may not be visible after the loop, with limitations in the current implementation noted.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef resolved_reference(cond: bool) -> str:\n    while True:\n        if cond:\n            x = \"test\"\n        else:\n            continue\n        return x\n\ndef continue_in_then_branch(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"continue\"\n            reveal_type(x)  # revealed: Literal[\"continue\"]\n            continue\n        else:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    # TODO: Should be Literal[\"before\", \"loop\", \"continue\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop\"]\n\ndef continue_in_else_branch(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        else:\n            x = \"continue\"\n            reveal_type(x)  # revealed: Literal[\"continue\"]\n            continue\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    # TODO: Should be Literal[\"before\", \"loop\", \"continue\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop\"]\n```\n\n----------------------------------------\n\nTITLE: Wrapper Descriptor Error Cases\nDESCRIPTION: Shows various error cases when using wrapper descriptors, including missing arguments, incorrect types, and invalid parameter counts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Calling the wrapper descriptor without any arguments is an\n# error: [no-matching-overload]\nwrapper_descriptor()\n\n# Calling it without the `instance` argument is an also an\n# error: [no-matching-overload]\nwrapper_descriptor(f)\n\n# Additional error cases...\nwrapper_descriptor(f, None)\nwrapper_descriptor(f, C())\nwrapper_descriptor(1, None, type(f))\nwrapper_descriptor(f, None, f)\nwrapper_descriptor(f, None, type(f), \"one too many\")\n```\n\n----------------------------------------\n\nTITLE: Dunder Init Import in Python\nDESCRIPTION: This snippet demonstrates an import in the __init__.py file of a package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom .foo import X\n\nreveal_type(X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Typing Module Aliases with MRO Inspection\nDESCRIPTION: This snippet shows how typing module aliases can be inherited from to create custom subclasses. It creates subclasses for various collection types and reveals their Method Resolution Order (MRO) to show inheritance hierarchies, with some TODOs noted for incomplete implementations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/stdlib_typing_aliases.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\n####################\n### Built-ins\n\nclass ListSubclass(typing.List): ...\n\n# revealed: tuple[Literal[ListSubclass], Literal[list], Literal[MutableSequence], Literal[Sequence], Literal[Reversible], Literal[Collection], Literal[Iterable], Literal[Container], @Todo(protocol), Literal[object]]\nreveal_type(ListSubclass.__mro__)\n\nclass DictSubclass(typing.Dict): ...\n\n# TODO: should have `Generic`, should not have `Unknown`\n# revealed: tuple[Literal[DictSubclass], Literal[dict], Unknown, Literal[object]]\nreveal_type(DictSubclass.__mro__)\n\nclass SetSubclass(typing.Set): ...\n\n# revealed: tuple[Literal[SetSubclass], Literal[set], Literal[MutableSet], Literal[AbstractSet], Literal[Collection], Literal[Iterable], Literal[Container], @Todo(protocol), Literal[object]]\nreveal_type(SetSubclass.__mro__)\n\nclass FrozenSetSubclass(typing.FrozenSet): ...\n\n# TODO: should have `Generic`, should not have `Unknown`\n# revealed: tuple[Literal[FrozenSetSubclass], Literal[frozenset], Unknown, Literal[object]]\nreveal_type(FrozenSetSubclass.__mro__)\n\n####################\n### `collections`\n\nclass ChainMapSubclass(typing.ChainMap): ...\n\n# TODO: Should be (ChainMapSubclass, ChainMap, MutableMapping, Mapping, Collection, Sized, Iterable, Container, Generic, object)\n# revealed: tuple[Literal[ChainMapSubclass], Literal[ChainMap], Unknown, Literal[object]]\nreveal_type(ChainMapSubclass.__mro__)\n\nclass CounterSubclass(typing.Counter): ...\n\n# TODO: Should be (CounterSubclass, Counter, dict, MutableMapping, Mapping, Collection, Sized, Iterable, Container, Generic, object)\n# revealed: tuple[Literal[CounterSubclass], Literal[Counter], Unknown, Literal[object]]\nreveal_type(CounterSubclass.__mro__)\n\nclass DefaultDictSubclass(typing.DefaultDict): ...\n\n# TODO: Should be (DefaultDictSubclass, defaultdict, dict, MutableMapping, Mapping, Collection, Sized, Iterable, Container, Generic, object)\n# revealed: tuple[Literal[DefaultDictSubclass], Literal[defaultdict], Unknown, Literal[object]]\nreveal_type(DefaultDictSubclass.__mro__)\n\nclass DequeSubclass(typing.Deque): ...\n\n# revealed: tuple[Literal[DequeSubclass], Literal[deque], Literal[MutableSequence], Literal[Sequence], Literal[Reversible], Literal[Collection], Literal[Iterable], Literal[Container], @Todo(protocol), Literal[object]]\nreveal_type(DequeSubclass.__mro__)\n\nclass OrderedDictSubclass(typing.OrderedDict): ...\n\n# TODO: Should be (OrderedDictSubclass, OrderedDict, dict, MutableMapping, Mapping, Collection, Sized, Iterable, Container, Generic, object)\n# revealed: tuple[Literal[OrderedDictSubclass], Literal[OrderedDict], Unknown, Literal[object]]\nreveal_type(OrderedDictSubclass.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Extending Configuration with TOML in Ruff\nDESCRIPTION: This example shows how to extend a Ruff configuration using the 'extend' property in a pyproject.toml file. When this configuration is used, Ruff will still use the directory containing this file as the project root for resolving paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_20\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nextend = \"/path/to/pyproject.toml\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Python File in Mocked Virtual Environment\nDESCRIPTION: This Python code snippet is used to demonstrate how files can be written to a mocked virtual environment's site-packages directory. It creates a simple Python file with a variable assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nX = 1\n```\n\n----------------------------------------\n\nTITLE: Data vs Non-Data Descriptors Example\nDESCRIPTION: Demonstration of the difference between data and non-data descriptors and their precedence chain in attribute access\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass DataDescriptor:\n    def __get__(self, instance: object, owner: type | None = None) -> Literal[\"data\"]:\n        return \"data\"\n\n    def __set__(self, instance: object, value: int) -> None:\n        pass\n\nclass NonDataDescriptor:\n    def __get__(self, instance: object, owner: type | None = None) -> Literal[\"non-data\"]:\n        return \"non-data\"\n\nclass C:\n    data_descriptor = DataDescriptor()\n    non_data_descriptor = NonDataDescriptor()\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with type(x) is C Pattern\nDESCRIPTION: Demonstrates type narrowing behavior when using 'type(x) is A' pattern. Shows that narrowing works for the positive case but must maintain the union type for the else branch due to possible subclassing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B):\n    if type(x) is A:\n        reveal_type(x)  # revealed: A\n    else:\n        # It would be wrong to infer `B` here. The type\n        # of `x` could be a subclass of `A`, so we need\n        # to infer the full union type:\n        reveal_type(x)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule Ignores for Jupyter Notebooks in ruff.toml\nDESCRIPTION: TOML configuration to ignore specific linting rules (T20 in this example) only for Jupyter Notebook files in ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\n[lint.per-file-ignores]\n\"*.ipynb\" = [\"T20\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with None Comparison\nDESCRIPTION: Demonstrates type narrowing behavior when comparing a variable with None using the != operator. Shows how the type system handles the true and false branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = None if flag else 1\n\n    if x != None:\n        reveal_type(x)  # revealed: Literal[1]\n    else:\n        # TODO should be None\n        reveal_type(x)  # revealed: None | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Iterators and Generators\nDESCRIPTION: Example showing correct and incorrect usage of yield from statements. Demonstrates that yield from requires an iterable object, defining both valid (Iterable class) and invalid (NotIterable class) cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/iterators.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NotIterable: ...\n\nclass Iterator:\n    def __next__(self) -> int:\n        return 42\n\nclass Iterable:\n    def __iter__(self) -> Iterator:\n        return Iterator()\n\ndef generator_function():\n    yield from Iterable()\n    yield from NotIterable()  # error: \"Object of type `NotIterable` is not iterable\"\n```\n\n----------------------------------------\n\nTITLE: Complex Literal Type Narrowing with Tuple Membership\nDESCRIPTION: Demonstrates sophisticated type narrowing with Literal types and multiple conditions using tuple membership tests.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(x: Literal[1, 2, \"a\", \"b\", False, b\"abc\"]):\n    if x in (1,):\n        reveal_type(x)  # revealed: Literal[1]\n    elif x in (2, \"a\"):\n        reveal_type(x)  # revealed: Literal[2, \"a\"]\n    elif x in (b\"abc\",):\n        reveal_type(x)  # revealed: Literal[b\"abc\"]\n    elif x not in (3,):\n        reveal_type(x)  # revealed: Literal[\"b\", False]\n    else:\n        reveal_type(x)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Example Dict Key Deletion Pattern\nDESCRIPTION: Example of the RUF051 rule checking for if-key-in-dict-del pattern\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nif key in my_dict:\n    del my_dict[key]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'is None' Check\nDESCRIPTION: Demonstrates type narrowing behavior when checking if a variable is None using 'is' operator. Shows how the type system narrows from Union[None, int] to specific types in different branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = None if flag else 1\n\n    if x is None:\n        reveal_type(x)  # revealed: None\n    else:\n        reveal_type(x)  # revealed: Literal[1]\n\n    reveal_type(x)  # revealed: None | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Callable with Gradual Form Parameters\nDESCRIPTION: Illustrates the use of ellipsis (...) in Callable type annotation to accept any number of parameters with any types while maintaining return type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/annotation.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(c: Callable[..., int]):\n    reveal_type(c())  # revealed: int\n    reveal_type(c(1))  # revealed: int\n    reveal_type(c(1, \"str\", False, a=[1, 2], b=(3, 4)))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Annotating Function Return Type with NoReturn\nDESCRIPTION: Demonstrates how to annotate a function that never returns using NoReturn from the typing module. The function raises an exception instead of returning normally.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/never.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NoReturn\n\ndef stop() -> NoReturn:\n    raise RuntimeError(\"no way\")\n\n# revealed: Never\nreveal_type(stop())\n```\n\n----------------------------------------\n\nTITLE: Metaclass Operator Overloading\nDESCRIPTION: Shows how operator overloading works with metaclasses, implementing __add__, __lt__, and __getitem__ methods on a Meta type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass Meta(type):\n    def __add__(self, other: Meta) -> int:\n        return 1\n\n    def __lt__(self, other: Meta) -> bool:\n        return True\n\n    def __getitem__(self, key: int) -> str:\n        return \"a\"\n\nclass A(metaclass=Meta): ...\nclass B(metaclass=Meta): ...\n\nreveal_type(A + B)  # revealed: int\n# error: [unsupported-operator] \"Operator `-` is unsupported between objects of type `Literal[A]` and `Literal[B]`\"\nreveal_type(A - B)  # revealed: Unknown\n\nreveal_type(A < B)  # revealed: bool\nreveal_type(A > B)  # revealed: bool\n\n# error: [unsupported-operator] \"Operator `<=` is not supported for types `Literal[A]` and `Literal[B]`\"\nreveal_type(A <= B)  # revealed: Unknown\n\nreveal_type(A[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Different Parameter Kinds\nDESCRIPTION: This code demonstrates that callable types with different parameter kinds (positional-only vs. regular parameters) are not equivalent. The parameter kind is part of the callable's type signature.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef f7(a: int, /) -> None: ...\ndef f8(a: int) -> None: ...\n\nstatic_assert(not is_equivalent_to(CallableTypeOf[f7], CallableTypeOf[f8]))\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Invalid __getitem__ Methods in Python\nDESCRIPTION: Tests type inference when __getitem__ might be invalid due to being unbound or having an incompatible parameter type. The system should emit diagnostics while inferring possible element types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\ndef _(flag: bool):\n    class Iterable1:\n        if flag:\n            def __getitem__(self, item: int) -> str:\n                return \"foo\"\n        else:\n            __getitem__: None = None\n\n    class Iterable2:\n        if flag:\n            def __getitem__(self, item: int) -> str:\n                return \"foo\"\n        else:\n            def __getitem__(self, item: str) -> int:\n                return 42\n\n    # error: [not-iterable]\n    for x in Iterable1():\n        # TODO: `str` might be better\n        reveal_type(x)  # revealed: str | Unknown\n\n    # error: [not-iterable]\n    for y in Iterable2():\n        reveal_type(y)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Decorator with Arguments in Python\nDESCRIPTION: Illustrates a decorator that takes arguments to customize its behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef ensure_larger_than(lower_bound: int) -> Callable[[Callable[[int], bool]], Callable[[int], bool]]:\n    def decorator(wrapped: Callable[[int], bool]) -> Callable[[int], bool]:\n        return lambda x: wrapped(x) and x >= lower_bound\n    return decorator\n\n@ensure_larger_than(10)\ndef even(x: int) -> bool:\n    return x % 2 == 0\n\nreveal_type(even)  # revealed: (int, /) -> bool\nreveal_type(even(14))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Multiple Branch Type Narrowing\nDESCRIPTION: Shows type narrowing behavior in elif and else branches with multiple type possibilities.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/issubclass.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    t = int if flag1 else str if flag2 else bytes\n\n    if issubclass(t, int):\n        reveal_type(t)  # revealed: Literal[int]\n    else:\n        reveal_type(t)  # revealed: Literal[str, bytes]\n\n    if issubclass(t, int):\n        reveal_type(t)  # revealed: Literal[int]\n    elif issubclass(t, str):\n        reveal_type(t)  # revealed: Literal[str]\n    else:\n        reveal_type(t)  # revealed: Literal[bytes]\n```\n\n----------------------------------------\n\nTITLE: Metaclass Attribute Resolution with Descriptors\nDESCRIPTION: Shows how metaclass data descriptors take precedence over class attributes and how normal metaclass attributes are shadowed by class-level attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Meta3(type):\n    meta_attribute1: Literal[\"value on metaclass\"] = \"value on metaclass\"\n    meta_attribute2: Literal[\"value on metaclass\"] = \"value on metaclass\"\n    meta_non_data_descriptor1: NonDataDescriptor = NonDataDescriptor()\n    meta_non_data_descriptor2: NonDataDescriptor = NonDataDescriptor()\n\nclass C3(metaclass=Meta3):\n    meta_attribute1: Literal[\"value on class\"] = \"value on class\"\n    meta_attribute2: ClassLevelDataDescriptor = ClassLevelDataDescriptor()\n    meta_non_data_descriptor1: Literal[\"value on class\"] = \"value on class\"\n    meta_non_data_descriptor2: ClassLevelDataDescriptor = ClassLevelDataDescriptor()\n```\n\n----------------------------------------\n\nTITLE: Assigning Lambda Expressions to Callable Types in Python\nDESCRIPTION: Shows valid and invalid assignments of lambda expressions to Callable types, demonstrating type checking for lambda expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\na1: Callable[[], None] = lambda: None\na2: Callable[[int], None] = lambda x: None\na3: Callable[[int, int], None] = lambda x, y, z=1: None\na4: Callable[[int, int], None] = lambda *args: None\n\n# error: [invalid-assignment]\na5: Callable[[], None] = lambda x: None\n# error: [invalid-assignment]\na6: Callable[[int], None] = lambda: None\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Literal Types in Python\nDESCRIPTION: This code explores disjointness relations between various literal types, including boolean literals, integer literals, string literals, and their interactions with other types. It also includes TODOs for tests that currently produce errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\nfrom knot_extensions import Intersection, Not, TypeOf, is_disjoint_from, static_assert, AlwaysFalsy, AlwaysTruthy\n\nstatic_assert(is_disjoint_from(Literal[True], Literal[False]))\nstatic_assert(is_disjoint_from(Literal[True], Literal[1]))\nstatic_assert(is_disjoint_from(Literal[False], Literal[0]))\n\nstatic_assert(is_disjoint_from(Literal[1], Literal[2]))\n\nstatic_assert(is_disjoint_from(Literal[\"a\"], Literal[\"b\"]))\n\nstatic_assert(is_disjoint_from(Literal[b\"a\"], LiteralString))\nstatic_assert(is_disjoint_from(Literal[b\"a\"], Literal[b\"b\"]))\nstatic_assert(is_disjoint_from(Literal[b\"a\"], Literal[\"a\"]))\n\nstatic_assert(is_disjoint_from(type[object], TypeOf[Literal]))\nstatic_assert(is_disjoint_from(type[str], LiteralString))\n\nstatic_assert(not is_disjoint_from(Literal[True], Literal[True]))\nstatic_assert(not is_disjoint_from(Literal[False], Literal[False]))\nstatic_assert(not is_disjoint_from(Literal[True], bool))\nstatic_assert(not is_disjoint_from(Literal[True], int))\n\nstatic_assert(not is_disjoint_from(Literal[1], Literal[1]))\n\nstatic_assert(not is_disjoint_from(Literal[\"a\"], Literal[\"a\"]))\nstatic_assert(not is_disjoint_from(Literal[\"a\"], LiteralString))\nstatic_assert(not is_disjoint_from(Literal[\"a\"], str))\n\n# TODO: No errors\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(AlwaysFalsy, Intersection[LiteralString, Not[Literal[\"\"]]]))\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(Intersection[Not[Literal[True]], Not[Literal[False]]], bool))\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(Intersection[AlwaysFalsy, Not[Literal[False]]], bool))\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(Intersection[AlwaysTruthy, Not[Literal[True]]], bool))\n\n# TODO: No errors\n# The condition `is_disjoint(T, Not[T])` must still be satisfied after the following transformations:\n# `LiteralString & AlwaysTruthy` -> `LiteralString & ~Literal[\"\"]\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(Intersection[LiteralString, AlwaysTruthy], Not[LiteralString] | AlwaysFalsy))\n# `LiteralString & ~AlwaysFalsy`  -> `LiteralString & ~Literal[\"\"]\n# error: [static-assert-error]\nstatic_assert(is_disjoint_from(Intersection[LiteralString, Not[AlwaysFalsy]], Not[LiteralString] | AlwaysFalsy))\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Diamond Inheritance MRO (Example 5)\nDESCRIPTION: Tests type inference for complex inheritance with multiple levels\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass O: ...\nclass F(O): ...\nclass E(O): ...\nclass D(O): ...\nclass C(D, F): ...\nclass B(D, E): ...\nclass A(B, C): ...\n\nreveal_type(C.__mro__)\nreveal_type(B.__mro__)\nreveal_type(A.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Partial String Type Annotation in Python\nDESCRIPTION: Shows mixing regular type annotations with string annotations in a complex type. Only part of the type expression is in a string.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f(v: tuple[int, \"str\"]):\n    reveal_type(v)  # revealed: tuple[int, str]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in If-Elif Without Else\nDESCRIPTION: Demonstrates type narrowing in if-elif chains without explicit else branches, showing how mutations affect the final type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/post_if_statement.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int | None):\n    if x is None:\n        x = 0\n    elif x > 50:\n        x = 50\n\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Assigning Values to Union Types in Python\nDESCRIPTION: Shows valid and invalid assignments to variables with Union type annotations. Demonstrates type checking errors when assigning incompatible types to Union variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\na: Union[int, str]\na = 1\na = \"\"\na1: Union[int, bool]\na1 = 1\na1 = True\n# error: [invalid-assignment] \"Object of type `Literal[b\"\"]` is not assignable to `int | str`\"\na = b\"\"\n```\n\n----------------------------------------\n\nTITLE: Generic Function Type Inference\nDESCRIPTION: Examples demonstrating type inference for generic function parameters with different input types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: T) -> T:\n    return x\n\nreveal_type(f(1))  # revealed: Literal[1]\nreveal_type(f(1.0))  # revealed: float\nreveal_type(f(True))  # revealed: Literal[True]\nreveal_type(f(\"string\"))  # revealed: Literal[\"string\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Multi-Target Assignments in Python Classes\nDESCRIPTION: Demonstrates type inference for attributes defined in multi-target assignments within class methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self) -> None:\n        self.a = self.b = 1\n\nc_instance = C()\n\nreveal_type(c_instance.a)  # revealed: Unknown | Literal[1]\nreveal_type(c_instance.b)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Integer Literal Comparison Types in Python\nDESCRIPTION: Demonstrates the types inferred from comparisons between integer literals and boolean values using reveal_type(). Shows how chained comparisons are typed and includes examples of identity checks with 'is' operator.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/integers.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1 == 1 == True)  # revealed: Literal[True]\nreveal_type(1 == 1 == 2 == 4)  # revealed: Literal[False]\nreveal_type(False < True <= 2 < 3 != 6)  # revealed: Literal[True]\nreveal_type(1 < 1)  # revealed: Literal[False]\nreveal_type(1 > 1)  # revealed: Literal[False]\nreveal_type(1 is 1)  # revealed: bool\nreveal_type(1 is not 1)  # revealed: bool\nreveal_type(1 is 2)  # revealed: Literal[False]\nreveal_type(1 is not 7)  # revealed: Literal[True]\n# error: [unsupported-operator] \"Operator `<=` is not supported for types `int` and `str`, in comparing `Literal[1]` with `Literal[\"\"]\"\nreveal_type(1 <= \"\" and 0 < 1)  # revealed: Unknown & ~AlwaysTruthy | Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Custom Classes\nDESCRIPTION: Demonstrates type narrowing behavior when using 'is not' with custom class instances and None unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is_not.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A: ...\n    x = A()\n    y = x if flag else None\n\n    if y is not x:\n        reveal_type(y)  # revealed: A | None\n    else:\n        reveal_type(y)  # revealed: A\n\n    reveal_type(y)  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Using Ruff as a Linter\nDESCRIPTION: Commands to run Ruff as a linter on different file paths and configurations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nruff check                          # Lint all files in the current directory (and any subdirectories).\nruff check path/to/code/            # Lint all files in `/path/to/code` (and any subdirectories).\nruff check path/to/code/*.py        # Lint all `.py` files in `/path/to/code`.\nruff check path/to/code/to/file.py  # Lint `file.py`.\nruff check @arguments.txt           # Lint using an input file, treating its contents as newline-delimited command-line arguments.\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with String Literals in Python\nDESCRIPTION: Demonstrates type inference with string literals, where 'not \"\"' is Literal[True] for empty strings and 'not \"anything\"' is Literal[False] for non-empty strings, including concatenated strings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(not \"hello\")  # revealed: Literal[False]\nreveal_type(not \"\")  # revealed: Literal[True]\nreveal_type(not \"0\")  # revealed: Literal[False]\nreveal_type(not \"hello\" + \"world\")  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Comparing Incompatible Types in Python\nDESCRIPTION: Demonstrates type checking behavior when comparing integers with complex numbers and boolean values. Shows reveal_type output for various comparison operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1 >= 2j)  # revealed: Unknown\n\ndef f(x: bool, y: int):\n    reveal_type(x < y)  # revealed: bool\n    reveal_type(y < x)  # revealed: bool\n    reveal_type(4.2 < x)  # revealed: bool\n    reveal_type(x < 4.2)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Delayed Final Assignment in Python\nDESCRIPTION: Shows valid pattern of declaring a Final variable and binding it later in the code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nDECLARED_THEN_BOUND: Final[int]\nDECLARED_THEN_BOUND = 1\n```\n\n----------------------------------------\n\nTITLE: Write-only Property Access in Python\nDESCRIPTION: Demonstrates behavior when attempting to read a write-only property.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def attr_setter(self, value: int) -> None:\n        pass\n    attr = property(fset=attr_setter)\n\nc = C()\nc.attr = 1\n\nreveal_type(c.attr)  # revealed: Unknown | property\n```\n\n----------------------------------------\n\nTITLE: Calling Bound Methods and Function Objects in Python\nDESCRIPTION: Demonstrates the difference between calling a bound method and a function object, showing how the instance is implicitly or explicitly passed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(C().f(1))  # revealed: str\nreveal_type(bound_method(1))  # revealed: str\n\nC.f(1)  # error: [missing-argument]\n\nreveal_type(C.f(C(), 1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Basic Callable Type Usage with Return Types\nDESCRIPTION: Demonstrates basic usage of Callable type annotation with no parameters and with specific parameter types. Shows type checking for return values and argument validation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/annotation.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef _(c: Callable[[], int]):\n    reveal_type(c())  # revealed: int\n\ndef _(c: Callable[[int, str], int]):\n    reveal_type(c(1, \"a\"))  # revealed: int\n\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\\\"a\\\"]\"\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `str`, found `Literal[1]`\n    reveal_type(c(\"a\", 1))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Benchmarks\nDESCRIPTION: Shell command to execute Ruff benchmarks against the CPython repository.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/benchmarks/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/benchmarks/run.sh\n```\n\n----------------------------------------\n\nTITLE: Understanding Tuple Annotations in Python\nDESCRIPTION: This snippet demonstrates various forms of tuple annotations in Python, including empty tuples, single-item tuples, multi-item tuples, nested tuples, and tuples with union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Unpack\n\na: tuple[()] = ()\nb: tuple[int] = (42,)\nc: tuple[str, int] = (\"42\", 42)\nd: tuple[tuple[str, str], tuple[int, int]] = ((\"foo\", \"foo\"), (42, 42))\ne: tuple[str, ...] = ()\nf: tuple[str, *tuple[int, ...], bytes] = (\"42\", b\"42\")\ng: tuple[str, Unpack[tuple[int, ...]], bytes] = (\"42\", b\"42\")\nh: tuple[list[int], list[int]] = ([], [])\ni: tuple[str | int, str | int] = (42, 42)\nj: tuple[str | int] = (42,)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom module import a, b, c, d, e, f, g, h, i, j\n\nreveal_type(a)  # revealed: tuple[()]\nreveal_type(b)  # revealed: tuple[int]\nreveal_type(c)  # revealed: tuple[str, int]\nreveal_type(d)  # revealed: tuple[tuple[str, str], tuple[int, int]]\n\n# TODO: homogeneous tuples, PEP-646 tuples, generics\nreveal_type(e)  # revealed: @Todo(full tuple[...] support)\nreveal_type(f)  # revealed: @Todo(full tuple[...] support)\nreveal_type(g)  # revealed: @Todo(full tuple[...] support)\nreveal_type(h)  # revealed: tuple[@Todo(generics), @Todo(generics)]\n\nreveal_type(i)  # revealed: tuple[str | int, str | int]\nreveal_type(j)  # revealed: tuple[str | int]\n```\n\n----------------------------------------\n\nTITLE: Nested Callable Types\nDESCRIPTION: Shows how to use nested Callable types as parameter types and return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef _(c: Callable[[Callable[[int], str]], int]):\n    reveal_type(c)  # revealed: ((int, /) -> str, /) -> int\n```\n\n----------------------------------------\n\nTITLE: Nested Tuple Type isinstance() Check\nDESCRIPTION: Demonstrates type narrowing with nested tuples of types in isinstance() checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else \"a\"\n\n    if isinstance(x, (bool, (bytes, int))):\n        reveal_type(x)  # revealed: Literal[1]\n    else:\n        reveal_type(x)  # revealed: Literal[\"a\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Known First-Party Modules in ruff.toml\nDESCRIPTION: This snippet shows how to configure Ruff to treat specific modules as first-party using `ruff.toml`. This configuration involves setting the `known-first-party` option within the `[lint.isort]` section and enabling relevant rules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n\"src = [\"src\", \"tests\"]\n\n[lint]\nselect = [\n    # Pyflakes\n    \"F\",\n    # Pycodestyle\n    \"E\",\n    \"W\",\n    # isort\n    \"I001\"\n]\n\n[lint.isort]\nknown-first-party = [\"my_module1\", \"my_module2\"]\"\n```\n\n----------------------------------------\n\nTITLE: Python String Literal Comparison Types\nDESCRIPTION: Demonstrates various string comparison operations using reveal_type to show compile-time type information. Includes equality, ordering, containment, and identity comparisons with both literals and variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/strings.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str):\n    reveal_type(\"abc\" == \"abc\")  # revealed: Literal[True]\n    reveal_type(\"ab_cd\" <= \"ab_ce\")  # revealed: Literal[True]\n    reveal_type(\"abc\" in \"ab cd\")  # revealed: Literal[False]\n    reveal_type(\"\" not in \"hello\")  # revealed: Literal[False]\n    reveal_type(\"--\" is \"--\")  # revealed: bool\n    reveal_type(\"A\" is \"B\")  # revealed: Literal[False]\n    reveal_type(\"--\" is not \"--\")  # revealed: bool\n    reveal_type(\"A\" is not \"B\")  # revealed: Literal[True]\n    reveal_type(x < \"...\")  # revealed: bool\n\n    # ensure we're not comparing the interned salsa symbols, which compare by order of declaration.\n    reveal_type(\"ab\" < \"ab_cd\")  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Value Pattern Match with Guard Type Narrowing\nDESCRIPTION: Shows type narrowing for value patterns with guard conditions, including various literal types and their type revelations within guards.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case \"foo\" if reveal_type(x):  # revealed: Literal[\"foo\"]\n        pass\n    case 42 if reveal_type(x):  # revealed: Literal[42]\n        pass\n    case 6.0 if reveal_type(x):  # revealed: float\n        pass\n    case 1j if reveal_type(x):  # revealed: complex\n        pass\n    case b\"foo\" if reveal_type(x):  # revealed: Literal[b\"foo\"]\n        pass\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with bool() Function Examples in Python\nDESCRIPTION: Demonstrates different scenarios of using bool() for type narrowing, including positive and negative checks, invalid arguments, and type revelations. Shows how type narrowing works with conditional statements and bool() function calls.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/bool-call.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n\n    x = 1 if flag else None\n\n    # valid invocation, positive\n    reveal_type(x)  # revealed: Literal[1] | None\n    if bool(x is not None):\n        reveal_type(x)  # revealed: Literal[1]\n\n    # valid invocation, negative\n    reveal_type(x)  # revealed: Literal[1] | None\n    if not bool(x is not None):\n        reveal_type(x)  # revealed: None\n\n    # no args/narrowing\n    reveal_type(x)  # revealed: Literal[1] | None\n    if not bool():\n        reveal_type(x)  # revealed: Literal[1] | None\n\n    # invalid invocation, too many positional args\n    reveal_type(x)  # revealed: Literal[1] | None\n    # error: [too-many-positional-arguments] \"Too many positional arguments to class `bool`: expected 1, got 2\"\n    if bool(x is not None, 5):\n        reveal_type(x)  # revealed: Literal[1] | None\n\n    # invalid invocation, too many kwargs\n    reveal_type(x)  # revealed: Literal[1] | None\n    # error: [unknown-argument] \"Argument `y` does not match any known parameter of class `bool`\"\n    if bool(x is not None, y=5):\n        reveal_type(x)  # revealed: Literal[1] | None\n```\n\n----------------------------------------\n\nTITLE: Invalid type() Function Calls\nDESCRIPTION: Shows invalid calls to type() function with incorrect number of arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [no-matching-overload] \"No overload of class `type` matches arguments\"\ntype(\"Foo\", ())\n\n# error: [no-matching-overload] \"No overload of class `type` matches arguments\"\ntype(\"Foo\", (), {}, weird_other_arg=42)\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with __init__ method in Python\nDESCRIPTION: Demonstrates the behavior when a class defines a custom __init__ method, including type checking and error handling for various argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __init__(self, x: int): ...\n\nreveal_type(Foo(1))  # revealed: Foo\n\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__init__`\"\nreveal_type(Foo())  # revealed: Foo\n# error: [too-many-positional-arguments] \"Too many positional arguments to bound method `__init__`: expected 1, got 2\"\nreveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Generic Type Aliases\nDESCRIPTION: Shows the implementation of generic type aliases with type parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntype ListOrSet[T] = list[T] | set[T]\n\n# TODO: Should be `tuple[typing.TypeVar | typing.ParamSpec | typing.TypeVarTuple, ...]`,\n# as specified in the `typeshed` stubs.\nreveal_type(ListOrSet.__type_params__)  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Basic Async For Loop Implementation in Python\nDESCRIPTION: Shows proper implementation of async iteration protocol using __anext__ and __aiter__ methods. Implements an async iterator that returns integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/async_for.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def foo():\n    class IntAsyncIterator:\n        async def __anext__(self) -> int:\n            return 42\n\n    class IntAsyncIterable:\n        def __aiter__(self) -> IntAsyncIterator:\n            return IntAsyncIterator()\n\n    # TODO(Alex): async iterables/iterators!\n    async for x in IntAsyncIterable():\n        pass\n\n    # error: [possibly-unresolved-reference]\n    # revealed: @Todo(async iterables/iterators)\n    reveal_type(x)\n```\n\n----------------------------------------\n\nTITLE: Using %matplotlib Magic Command with Type Annotations\nDESCRIPTION: Demonstrates use of the %matplotlib line magic command both with and without type annotations. Shows listing available matplotlib backends using --list flag.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/unused_variable.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    foo1 = %matplotlib --list\n    foo2: list[str] = %matplotlib --list\n```\n\n----------------------------------------\n\nTITLE: Super with Built-ins and Literals in Python\nDESCRIPTION: Demonstrates how super works with built-in types and literal values, showing the type information preserved when using super with these values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(super(bool, True))  # revealed: <super: Literal[bool], bool>\nreveal_type(super(bool, bool()))  # revealed: <super: Literal[bool], bool>\nreveal_type(super(int, bool()))  # revealed: <super: Literal[int], bool>\nreveal_type(super(int, 3))  # revealed: <super: Literal[int], int>\nreveal_type(super(str, \"\"))  # revealed: <super: Literal[str], str>\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with Unknown Types\nDESCRIPTION: Shows how the type checker handles exceptions from unresolved imports. Demonstrates type checking behavior with unknown exception types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom nonexistent_module import foo  # error: [unresolved-import]\n\ntry:\n    help()\nexcept foo as e:\n    reveal_type(foo)  # revealed: Unknown\n    reveal_type(e)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Generic Class Constructor Implementation\nDESCRIPTION: Implementation of generic class constructors using __new__ and __init__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    def __new__(cls, x: T) -> \"C\"[T]:\n        return object.__new__(cls)\n\n    def __init__(self, x: T) -> None: ...\n\nreveal_type(C(1))  # revealed: C[Literal[1]]\n```\n\n----------------------------------------\n\nTITLE: Reflected Precedence in Binary Operations without Method Override in Python\nDESCRIPTION: Shows how precedence works when the right-hand operand is a subtype of the left-hand operand but does not override the reflected method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> str:\n        return \"foo\"\n\n    def __radd__(self, other) -> int:\n        return 42\n\nclass B(A): ...\n\nreveal_type(A() + B())  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: File Path Reference for Typeshed Integration\nDESCRIPTION: Directory paths showing where vendored typeshed stubs are stored and the location of the source commit reference file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\ncrates/red_knot_vendored/vendor/typeshed\ncrates/red_knot_vendored/vendor/typeshed/source_commit.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Expressions With Parameters in Python\nDESCRIPTION: Shows lambda expressions with parameters and their type inference. It demonstrates that parameters in lambda expressions cannot be annotated.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda a: a)  # revealed: (a) -> Unknown\nreveal_type(lambda a, b: a + b)  # revealed: (a, b) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Demonstrating float variable annotations accepting int values\nDESCRIPTION: Shows how Python type checkers allow assigning an int value to a variable annotated as float, due to the special case where 'float' means 'int | float'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/int_float_complex.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef assigns_int_to_float(x: int):\n    # no error!\n    y: float = x\n```\n\n----------------------------------------\n\nTITLE: Illustrating Legacy Typevar Usage in Multiple Functions in Python\nDESCRIPTION: This example demonstrates how a legacy typevar can be inferred to represent different types in the same code block when used in multiple generic functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\ndef f1(x: T) -> T:\n    return x\n\ndef f2(x: T) -> T:\n    return x\n\nf1(1)\nf2(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Testing Keyword Assignment Syntax Error in Python\nDESCRIPTION: Demonstrates parser handling when attempting to use 'pass' keyword as a variable name in an assignment statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\npass = 1\n```\n\n----------------------------------------\n\nTITLE: Import Module Attribute vs Submodule - From Import\nDESCRIPTION: Shows how Python resolves 'from a import b' when there's both an attribute 'b' in a/__init__.py and a submodule a/b.py\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom a import b\n\nreveal_type(b)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Reflected Comparisons Implementation in Python\nDESCRIPTION: Shows how Python handles reflected comparisons when left-hand side methods are not defined, including fallback behavior to right-hand side comparison methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass EqReturnType: ...\nclass NeReturnType: ...\nclass LtReturnType: ...\nclass LeReturnType: ...\nclass GtReturnType: ...\nclass GeReturnType: ...\n\nclass A:\n    def __eq__(self, other: B) -> EqReturnType:\n        return EqReturnType()\n\n    def __ne__(self, other: B) -> NeReturnType:\n        return NeReturnType()\n\n    def __lt__(self, other: B) -> LtReturnType:\n        return LtReturnType()\n\n    def __le__(self, other: B) -> LeReturnType:\n        return LeReturnType()\n\n    def __gt__(self, other: B) -> GtReturnType:\n        return GtReturnType()\n\n    def __ge__(self, other: B) -> GeReturnType:\n        return GeReturnType()\n\nclass Unrelated: ...\n\nclass B:\n    def __eq__(self, other: Unrelated) -> B:\n        return B()\n\n    def __ne__(self, other: Unrelated) -> B:\n        return B()\n\nreveal_type(B() == A())  # revealed: EqReturnType\nreveal_type(B() != A())  # revealed: NeReturnType\nreveal_type(B() < A())  # revealed: GtReturnType\nreveal_type(B() <= A())  # revealed: GeReturnType\nreveal_type(B() > A())  # revealed: LtReturnType\nreveal_type(B() >= A())  # revealed: LeReturnType\n```\n\n----------------------------------------\n\nTITLE: Method Return Type Validation for Callable Types\nDESCRIPTION: Shows how method return types are validated when assigning bound methods to Callable types. Demonstrates a valid assignment when return types match and an invalid assignment that generates a type error when return types are incompatible.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Callable\n\nclass A:\n    def f(self, x: Any) -> str:\n        return \"\"\n\n    def g(self, x: Any) -> int:\n        return 1\n\nc: Callable[[Any], str] = A().f\n\n# error: [invalid-assignment] \"Object of type `bound method A.g(x: Any) -> int` is not assignable to `(Any, /) -> str`\"\nc: Callable[[Any], str] = A().g\n```\n\n----------------------------------------\n\nTITLE: Using __iter__ Method for Membership Tests in Python\nDESCRIPTION: Shows how classes that implement __iter__ but not __contains__ can support membership tests. The needle will be sought in the iterated items, regardless of types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass StringIterator:\n    def __next__(self) -> str:\n        return \"foo\"\n\nclass A:\n    def __iter__(self) -> StringIterator:\n        return StringIterator()\n\nreveal_type(\"hello\" in A())  # revealed: bool\nreveal_type(\"hello\" not in A())  # revealed: bool\nreveal_type(42 in A())  # revealed: bool\nreveal_type(42 not in A())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Parameter Shadowing with Type Reassignment in Python\nDESCRIPTION: Demonstrates how a parameter can be shadowed within a function body by reassigning it with a new type annotation. This is allowed without generating diagnostics since it's an explicit reassignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/function.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: str):\n    x: int = int(x)\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Tuples in Python\nDESCRIPTION: Demonstrates type inference with tuple literals, where 'not ()' is Literal[True] for empty tuples and 'not (any_elements)' is Literal[False] for non-empty tuples, regardless of element types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(not (1,))  # revealed: Literal[False]\nreveal_type(not (1, 2))  # revealed: Literal[False]\nreveal_type(not (1, 2, 3))  # revealed: Literal[False]\nreveal_type(not ())  # revealed: Literal[True]\nreveal_type(not (\"hello\",))  # revealed: Literal[False]\nreveal_type(not (1, \"hello\"))  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: TypeOf Annotations in Python\nDESCRIPTION: Shows how to use TypeOf in type annotations and demonstrates error cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef type_of_annotation() -> None:\n    t1: TypeOf[Base] = Base\n    t2: TypeOf[Base] = Derived  # error: [invalid-assignment]\n\n    # Note how this is different from `type[…]` which includes subclasses:\n    s1: type[Base] = Base\n    s2: type[Base] = Derived  # no error here\n\n# error: \"Special form `knot_extensions.TypeOf` expected exactly one type parameter\"\nt: TypeOf[int, str, bytes]\n\n# error: [invalid-type-form] \"`knot_extensions.TypeOf` requires exactly one argument when used in a type expression\"\ndef f(x: TypeOf) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Illustrating Nested Formal Typevar Restrictions in Generic Functions in Python\nDESCRIPTION: This example shows that generic functions nested within other generic functions should use distinct typevars.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: T, y: T) -> None:\n    def ok[S](a: S, b: S) -> None: ...\n\n    # TODO: error\n    def bad[T](a: T, b: T) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compatible __slots__ Inheritance in Python\nDESCRIPTION: Shows examples of classes with compatible __slots__ inheritance. Empty __slots__ or unspecified __slots__ can be freely combined in inheritance without issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\nclass B:\n    __slots__ = ()\n\nclass C:\n    __slots__ = (\"lorem\", \"ipsum\")\n\nclass AB(A, B): ...  # fine\nclass AC(A, C): ...  # fine\nclass BC(B, C): ...  # fine\nclass ABC(A, B, C): ...  # fine\n```\n\n----------------------------------------\n\nTITLE: Using inspect.getattr_static with Gradual Typing in Python\nDESCRIPTION: This snippet shows how inspect.getattr_static interacts with gradual typing, demonstrating its behavior with Any types and tuple[Any]. It highlights the challenges in type inference when dealing with gradual typing scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\nfrom typing import Any\n\ndef _(a: Any, tuple_of_any: tuple[Any]):\n    reveal_type(inspect.getattr_static(a, \"x\", \"default\"))  # revealed: Any | Literal[\"default\"]\n\n    # TODO: Ideally, this would just be `def index(self, value: Any, start: SupportsIndex = Literal[0], stop: SupportsIndex = int, /) -> int`\n    # revealed: (def index(self, value: Any, start: SupportsIndex = Literal[0], stop: SupportsIndex = int, /) -> int) | Literal[\"default\"]\n    reveal_type(inspect.getattr_static(tuple_of_any, \"index\", \"default\"))\n```\n\n----------------------------------------\n\nTITLE: For-Loop Attribute Assignment in Python\nDESCRIPTION: Demonstrates attribute assignment within for-loops, including iterator type handling and unpacking scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 1\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\nclass TupleIterator:\n    def __next__(self) -> tuple[int, str]:\n        return (1, \"a\")\n\nclass TupleIterable:\n    def __iter__(self) -> TupleIterator:\n        return TupleIterator()\n\nclass NonIterable: ...\n\nclass C:\n    def __init__(self):\n        for self.x in IntIterable():\n            pass\n\n        for _, self.y in TupleIterable():\n            pass\n\n        # TODO: We should emit a diagnostic here\n        for self.z in NonIterable():\n            pass\n\n# Iterable might be empty\n# error: [possibly-unbound-attribute]\nreveal_type(C().x)  # revealed: Unknown | int\n# error: [possibly-unbound-attribute]\nreveal_type(C().y)  # revealed: Unknown | str\n```\n\n----------------------------------------\n\nTITLE: Installing Type Stubs for Third-Party Packages using pip\nDESCRIPTION: This command demonstrates how to install type stubs for third-party packages (html5lib and requests) using pip. These stubs follow PEP 561 and are automatically released by typeshed internal machinery.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/vendor/typeshed/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install types-html5lib types-requests\n```\n\n----------------------------------------\n\nTITLE: Single Pattern Match Type Narrowing\nDESCRIPTION: Demonstrates type narrowing for a single match pattern with None and numeric values. Shows how the type of y changes based on matching x against None.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = None if flag else 1\n\n    reveal_type(x)  # revealed: None | Literal[1]\n\n    y = 0\n\n    match x:\n        case None:\n            y = x\n\n    reveal_type(y)  # revealed: Literal[0] | None\n```\n\n----------------------------------------\n\nTITLE: Handling Specific Exception with except*\nDESCRIPTION: Example of using except* with a specific exception type (OSError) in an exception group.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    help()\nexcept* OSError as e:\n    # TODO: more precise would be `ExceptionGroup[OSError]` --Alex\n    # (needs homogeneous tuples + generics)\n    reveal_type(e)  # revealed: BaseExceptionGroup\n```\n\n----------------------------------------\n\nTITLE: Terminal `break` in `try` with `finally` in Python\nDESCRIPTION: This function demonstrates the interaction between a `break` statement within a `try` block and a `finally` clause. It illustrates that the `finally` clause is always executed before the loop terminates, affecting variable values. The `reveal_type` call highlights a potential issue with type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    x = 1\n    while True:\n        try:\n            break\n        finally:\n            x = 2\n    # TODO: should be Literal[2]\n    reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Incompatible __slots__ Tuples in Multiple Inheritance\nDESCRIPTION: Demonstrates the error case when inheriting from multiple classes with different __slots__ definitions. When parent classes have different slot names, inheritance causes incompatibility errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = (\"a\", \"b\")\n\nclass B:\n    __slots__ = (\"c\", \"d\")\n\nclass C(\n    A,  # error: [incompatible-slots]\n    B,  # error: [incompatible-slots]\n): ...\n```\n\n----------------------------------------\n\nTITLE: Importing and Revealing Final Types in Python\nDESCRIPTION: Shows how Final types are revealed when imported from another module, demonstrating type inference behavior across module boundaries.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import FINAL_A, FINAL_B, FINAL_C, FINAL_D, FINAL_E\n\n# TODO: All of these should be Literal[1]\nreveal_type(FINAL_A)  # revealed: int\nreveal_type(FINAL_B)  # revealed: int\nreveal_type(FINAL_C)  # revealed: int\nreveal_type(FINAL_D)  # revealed: Unknown\nreveal_type(FINAL_E)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Builtins Import Limitations in Python\nDESCRIPTION: This snippet illustrates that importing symbols from the builtins module which aren't re-exported raises errors. It also shows an example of attempting to import a non-existent symbol from the math module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `builtins` has no member `Literal`\"\n# error: \"Module `builtins` has no member `sys`\"\nfrom builtins import Literal, sys\n\nreveal_type(Literal)  # revealed: Unknown\nreveal_type(sys)  # revealed: Unknown\n\n# error: \"Module `math` has no member `Iterable`\"\nfrom math import Iterable\n\nreveal_type(Iterable)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Or Pattern Matching in Python\nDESCRIPTION: This snippet demonstrates or-pattern matching in Python using the '|' operator. It shows how matching against multiple patterns affects type inference in various scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, final\n\ndef _(target: Literal[\"foo\", \"baz\"]):\n    y = 1\n\n    match target:\n        case \"foo\" | \"bar\":\n            y = 2\n        case \"baz\":\n            y = 3\n\n    # TODO: with exhaustiveness, this should be Literal[2, 3]\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n\ndef _(target: None):\n    y = 1\n\n    match target:\n        case None | 3:\n            y = 2\n        case \"foo\" | 4 | True:\n            y = 3\n\n    reveal_type(y)  # revealed: Literal[2]\n\n@final\nclass Baz:\n    pass\n\ndef _(target: int | None | float):\n    y = 1\n\n    match target:\n        case None | 3:\n            y = 2\n        case Baz():\n            y = 3\n\n    reveal_type(y)  # revealed: Literal[1, 2]\n\ndef _(target: None | str):\n    y = 1\n\n    match target:\n        case Baz() | True | False:\n            y = 2\n        case int():\n            y = 3\n\n    reveal_type(y)  # revealed: Literal[1, 3]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in OR Expressions - Python\nDESCRIPTION: Demonstrates type narrowing behavior in 'or' expressions where the right-hand side reveals the type when left-hand conditions are falsy.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A: ...\n    x: A | None = A() if flag else None\n\n    isinstance(x, A) or reveal_type(x)  # revealed: None\n    x is None or reveal_type(x)  # revealed: A\n    reveal_type(x)  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Built-in Property Descriptor Usage\nDESCRIPTION: Demonstrates the usage of Python's built-in property decorator as a descriptor, showing type checking for getters and setters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    _name: str | None = None\n\n    @property\n    def name(self) -> str:\n        return self._name or \"Unset\"\n\n    @name.setter\n    def name(self, value: str | None) -> None:\n        self._value = value\n```\n\n----------------------------------------\n\nTITLE: Tuple Indexing with Type Revelations\nDESCRIPTION: Demonstrates tuple indexing operations with type hints, including positive and negative indices, boolean indices, and out-of-bounds error cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nt = (1, \"a\", \"b\")\n\nreveal_type(t[0])  # revealed: Literal[1]\nreveal_type(t[1])  # revealed: Literal[\"a\"]\nreveal_type(t[-1])  # revealed: Literal[\"b\"]\nreveal_type(t[-2])  # revealed: Literal[\"a\"]\n\nreveal_type(t[False])  # revealed: Literal[1]\nreveal_type(t[True])  # revealed: Literal[\"a\"]\n\na = t[4]  # error: [index-out-of-bounds]\nreveal_type(a)  # revealed: Unknown\n\nb = t[-4]  # error: [index-out-of-bounds]\nreveal_type(b)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Gradual Type Assignability in Python\nDESCRIPTION: Demonstrates the assignability relation for gradual types like Any and Unknown, which can be assigned to or from static types despite not participating in traditional subtyping relationships.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Unknown\nfrom typing import Any, Literal\n\nstatic_assert(is_assignable_to(Unknown, Literal[1]))\nstatic_assert(is_assignable_to(Any, Literal[1]))\nstatic_assert(is_assignable_to(Literal[1], Unknown))\nstatic_assert(is_assignable_to(Literal[1], Any))\n```\n\n----------------------------------------\n\nTITLE: Deferred Self-Reference Annotations in Class Definitions\nDESCRIPTION: Shows how class self-references work with __future__.annotations. Annotations referencing the class itself are resolved, but direct references in expressions still cause errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass Foo:\n    this: Foo\n    # error: [unresolved-reference]\n    _ = Foo()\n    # error: [unresolved-reference]\n    [Foo for _ in range(1)]\n    a = int\n\n    def f(self, x: Foo):\n        reveal_type(x)  # revealed: Foo\n\n    def g(self) -> Foo:\n        _: Foo = self\n        return self\n\n    class Bar:\n        foo: Foo\n        b = int\n\n        def f(self, x: Foo):\n            return self\n        # error: [unresolved-reference]\n        def g(self) -> Bar:\n            return self\n        # error: [unresolved-reference]\n        def h[T: Bar](self):\n            pass\n\n        class Baz[T: Foo]:\n            pass\n\n        # error: [unresolved-reference]\n        type S = a\n        type T = b\n\n    def h[T: Bar]():\n        # error: [unresolved-reference]\n        return Bar()\n    type Baz = Foo\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Special Forms in Python Type Annotations\nDESCRIPTION: This example demonstrates various special typing forms that are currently unsupported by red-knot but don't trigger false-positive errors when used in annotations. It includes `Self`, `TypeVarTuple`, `Unpack`, `TypeGuard`, `TypeIs`, `Concatenate`, `ParamSpec`, and `TypeAlias`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_special_forms.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self, TypeVarTuple, Unpack, TypeGuard, TypeIs, Concatenate, ParamSpec, TypeAlias, Callable, TypeVar\n\nP = ParamSpec(\"P\")\nTs = TypeVarTuple(\"Ts\")\nR_co = TypeVar(\"R_co\", covariant=True)\n\nAlias: TypeAlias = int\n\ndef f(*args: Unpack[Ts]) -> tuple[Unpack[Ts]]:\n    # TODO: should understand the annotation\n    reveal_type(args)  # revealed: tuple\n\n    reveal_type(Alias)  # revealed: @Todo(Support for `typing.TypeAlias`)\n\ndef g() -> TypeGuard[int]: ...\ndef h() -> TypeIs[int]: ...\ndef i(callback: Callable[Concatenate[int, P], R_co], *args: P.args, **kwargs: P.kwargs) -> R_co:\n    # TODO: should understand the annotation\n    reveal_type(args)  # revealed: tuple\n\n    # TODO: should understand the annotation\n    reveal_type(kwargs)  # revealed: dict\n\n    return callback(42, *args, **kwargs)\n\nclass Foo:\n    def method(self, x: Self):\n        reveal_type(x)  # revealed: @Todo(Support for `typing.Self`)\n```\n\n----------------------------------------\n\nTITLE: Conditional __class_getitem__ Implementation with Union Type Result\nDESCRIPTION: Shows how conditional implementation of __class_getitem__ can result in a union type return value, depending on a runtime flag.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class UnionClassGetItem:\n        if flag:\n            def __class_getitem__(cls, item: int) -> str:\n                return str(item)\n        else:\n            def __class_getitem__(cls, item: int) -> int:\n                return item\n\n    reveal_type(UnionClassGetItem[0])  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Python Bytes Literal Operations with Type Revelation\nDESCRIPTION: Demonstrates various operations with bytes literals including concatenation and hex values, showing their inferred types using reveal_type. The examples show how Python treats bytes literals as constant values at compile time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/bytes.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(b\"red\" b\"knot\")  # revealed: Literal[b\"redknot\"]\nreveal_type(b\"hello\")  # revealed: Literal[b\"hello\"]\nreveal_type(b\"world\" + b\"!\")  # revealed: Literal[b\"world!\"]\nreveal_type(b\"\\xff\\x00\")  # revealed: Literal[b\"\\xff\\x00\"]\n```\n\n----------------------------------------\n\nTITLE: Combining Function Definition with IPython Command in Python\nDESCRIPTION: This snippet defines a function that incorporates an IPython magic command (%pwd) to get the current working directory. It demonstrates how to use IPython commands within Python functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/unformatted.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfoo = %pwd\ndef some_function(foo,bar,):\n    # Another cell with IPython escape command\n    foo = %pwd\n    print(foo)\n```\n\n----------------------------------------\n\nTITLE: Nested Lambda Expressions in Python\nDESCRIPTION: Demonstrates a nested lambda expression where one lambda is used as a default value for a parameter in another lambda.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda a=lambda x, y: 0: 2)  # revealed: (a=(x, y) -> Unknown) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Using Static Assertions for Narrowing Constraints in Python\nDESCRIPTION: Demonstrates how static_assert can be used to enforce narrowing constraints on variables, ensuring type safety at compile time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\n\ndef f(x: int | None) -> None:\n    if x is not None:\n        static_assert(x is not None)\n    else:\n        static_assert(x is None)\n```\n\n----------------------------------------\n\nTITLE: Error: Context Manager Without __enter__ Method\nDESCRIPTION: Shows the error when a class implements __exit__ but not __enter__, making it an invalid context manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Manager:\n    def __exit__(self, exc_tpe, exc_value, traceback): ...\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not implement `__enter__`\"\nwith Manager():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Any and Unknown Type Assignability in Python\nDESCRIPTION: Shows that all types are assignable to Any and Unknown as they are gradual types that can materialize to any type at runtime.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Unknown\nfrom typing import Literal, Any\n\nstatic_assert(is_assignable_to(str, Any))\nstatic_assert(is_assignable_to(Literal[1], Any))\nstatic_assert(is_assignable_to(object, Any))\n# Additional assertions...\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'for...else' inside 'if True' in Python\nDESCRIPTION: Shows how type analysis handles a for loop with an else clause inside an always-true condition. The variable 'x' will always be 3 after execution since the for loop's else clause is guaranteed to execute.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef iterable() -> list[object]:\n    return [1, \"\"]\n\nx = 1\n\nif True:\n    for _ in iterable():\n        x = 2\n    else:\n        x = 3\nelse:\n    x = 4\n\nreveal_type(x)  # revealed: Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Bytes Literals in Python\nDESCRIPTION: Shows type inference with bytes literals, where 'not b\"\"' is Literal[True] for empty bytes and 'not b\"anything\"' is Literal[False] for non-empty bytes, including concatenated bytes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(not b\"hello\")  # revealed: Literal[False]\nreveal_type(not b\"\")  # revealed: Literal[True]\nreveal_type(not b\"0\")  # revealed: Literal[False]\nreveal_type(not b\"hello\" + b\"world\")  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic Type Checking in Python\nDESCRIPTION: Demonstrates type inference for basic arithmetic operations (+, -, *, //, /, %) with literal values and variables. Shows how types are revealed for operations between literals and variables of type int.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/integers.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(2 + 1)  # revealed: Literal[3]\nreveal_type(3 - 4)  # revealed: Literal[-1]\nreveal_type(3 * -1)  # revealed: Literal[-3]\nreveal_type(-3 // 3)  # revealed: Literal[-1]\nreveal_type(-3 / 3)  # revealed: float\nreveal_type(5 % 3)  # revealed: Literal[2]\n\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `Literal[2]` and `Literal[\\\"f\\\"]`\"\nreveal_type(2 + \"f\")  # revealed: Unknown\n\ndef lhs(x: int):\n    reveal_type(x + 1)  # revealed: int\n    reveal_type(x - 4)  # revealed: int\n    reveal_type(x * -1)  # revealed: int\n    reveal_type(x // 3)  # revealed: int\n    reveal_type(x / 3)  # revealed: int | float\n    reveal_type(x % 3)  # revealed: int\n\ndef rhs(x: int):\n    reveal_type(2 + x)  # revealed: int\n    reveal_type(3 - x)  # revealed: int\n    reveal_type(3 * x)  # revealed: int\n    reveal_type(-3 // x)  # revealed: int\n    reveal_type(-3 / x)  # revealed: int | float\n    reveal_type(5 % x)  # revealed: int\n\ndef both(x: int):\n    reveal_type(x + x)  # revealed: int\n    reveal_type(x - x)  # revealed: int\n    reveal_type(x * x)  # revealed: int\n    reveal_type(x // x)  # revealed: int\n    reveal_type(x / x)  # revealed: int | float\n    reveal_type(x % x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Testing Module Re-exports and Import Renaming\nDESCRIPTION: Shows how module re-exports are tracked when importing renamed modules. Tests accessing submodules through both direct and aliased imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/tracking.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom q import a, b\n\nreveal_type(b)  # revealed: <module 'a.b'>\nreveal_type(b.C)  # revealed: Literal[C]\n\nreveal_type(a.b)  # revealed: <module 'a.b'>\nreveal_type(a.b.C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nimport a as a\nimport a.b as b\n```\n\n----------------------------------------\n\nTITLE: Sorting Imports Command\nDESCRIPTION: This snippet provides the commands recommended to use Ruff for both linting and formatting imports. It explains the sequence of commands to ensure imports are sorted and then properly formatted.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nruff check --select I --fix\nruff format\n```\n\n----------------------------------------\n\nTITLE: Unknown Type with Subsumption\nDESCRIPTION: Shows how type subsumption works with Unknown types present.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown\n\ndef _(u1: int | Unknown | bool) -> None:\n    reveal_type(u1)  # revealed: int | Unknown\n```\n\n----------------------------------------\n\nTITLE: Displaying Type Variables in Python Functions and Classes\nDESCRIPTION: Shows how type variables are displayed in generic functions and classes, using a suffix to distinguish different uses of the same type variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: T, y: T) -> None:\n    # TODO: revealed: T@f\n    reveal_type(x)  # revealed: T\n\nclass C[T]:\n    def m(self, x: T) -> None:\n        # TODO: revealed: T@c\n        reveal_type(x)  # revealed: T\n```\n\n----------------------------------------\n\nTITLE: Implicit Use of Builtin Functions in Python\nDESCRIPTION: This snippet shows how builtin functions can be used implicitly without importing the builtins module, and reveals their types using reveal_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(chr)  # revealed: def chr(i: int | SupportsIndex, /) -> str\nreveal_type(str)  # revealed: Literal[str]\n```\n\n----------------------------------------\n\nTITLE: TYPE_CHECKING Conditional Import\nDESCRIPTION: Shows how to use typing.TYPE_CHECKING for conditional imports that are only available during type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass SomeType: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\nif typing.TYPE_CHECKING:\n    from module import SomeType\n\n# `SomeType` is unconditionally available here for type checkers:\ndef f(s: SomeType) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Handling Dynamic Types with Super in Python\nDESCRIPTION: Illustrates how super behaves when arguments are dynamic types (Unknown), resulting in Unknown return types when accessing members as the MRO cannot be determined.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    a: int = 1\n\ndef f(x):\n    reveal_type(x)  # revealed: Unknown\n\n    reveal_type(super(x, x))  # revealed: <super: Unknown, Unknown>\n    reveal_type(super(A, x))  # revealed: <super: Literal[A], Unknown>\n    reveal_type(super(x, A()))  # revealed: <super: Unknown, A>\n\n    reveal_type(super(x, x).a)  # revealed: Unknown\n    reveal_type(super(A, x).a)  # revealed: Unknown\n    reveal_type(super(x, A()).a)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of typing.ClassVar Type Qualifier in Python\nDESCRIPTION: Demonstrates basic usage of ClassVar with various annotation styles including simple ClassVar[int], Annotated with ClassVar, ClassVar with Annotated, untyped ClassVar, and string-postponed ClassVar. The example shows how ClassVar prevents instance-level attribute writes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar, Annotated\n\nclass C:\n    a: ClassVar[int] = 1\n    b: Annotated[ClassVar[int], \"the annotation for b\"] = 1\n    c: ClassVar[Annotated[int, \"the annotation for c\"]] = 1\n    d: ClassVar = 1\n    e: \"ClassVar[int]\" = 1\n\nreveal_type(C.a)  # revealed: int\nreveal_type(C.b)  # revealed: int\nreveal_type(C.c)  # revealed: int\n# TODO: should be Unknown | Literal[1]\nreveal_type(C.d)  # revealed: Unknown\nreveal_type(C.e)  # revealed: int\n\nc = C()\n\n# error: [invalid-attribute-access]\nc.a = 2\n# error: [invalid-attribute-access]\nc.b = 2\n# error: [invalid-attribute-access]\nc.c = 2\n# error: [invalid-attribute-access]\nc.d = 2\n# error: [invalid-attribute-access]\nc.e = 2\n```\n\n----------------------------------------\n\nTITLE: Dataclass Inheritance - Base Class\nDESCRIPTION: Demonstrates inheritance where a normal class inherits from a dataclass.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass Base:\n    x: int\n\nclass Derived(Base): ...\n\nd = Derived(1)  # OK\nreveal_type(d.x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Debugging ruff-ecosystem with PDB\nDESCRIPTION: This command executes the ruff-ecosystem tool in check mode and enables the Python debugger (PDB) using the `--pdb` flag. When an error occurs during the check, the debugger will be activated, allowing for interactive troubleshooting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem check ruff \"./target/debug/ruff\" --pdb\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Boolean Singleton Types\nDESCRIPTION: Shows type narrowing behavior when using 'is not' with boolean values. Demonstrates how the type system handles literal boolean types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is_not.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = True if flag else False\n    reveal_type(x)  # revealed: bool\n\n    if x is not False:\n        reveal_type(x)  # revealed: Literal[True]\n    else:\n        reveal_type(x)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Bounded Typevar Relationships in Python\nDESCRIPTION: Demonstrates behavior of bounded type variables including relationships with their bounds and other types. Shows how final classes and gradual typing affect these relationships.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom typing_extensions import final\n\ndef bounded[T: Super](t: list[T]) -> None:\n    static_assert(is_assignable_to(T, Super))\n    static_assert(not is_assignable_to(T, Sub))\n    static_assert(not is_assignable_to(Super, T))\n    static_assert(not is_assignable_to(Sub, T))\n\n    static_assert(is_subtype_of(T, Super))\n    static_assert(not is_subtype_of(T, Sub))\n    static_assert(not is_subtype_of(Super, T))\n    static_assert(not is_subtype_of(Sub, T))\n\ndef bounded_by_gradual[T: Any](t: list[T]) -> None:\n    static_assert(is_assignable_to(T, Any))\n    static_assert(is_assignable_to(Any, T))\n    static_assert(is_assignable_to(T, Super))\n    static_assert(not is_assignable_to(Super, T))\n    static_assert(is_assignable_to(T, Sub))\n    static_assert(not is_assignable_to(Sub, T))\n\n    static_assert(not is_subtype_of(T, Any))\n    static_assert(not is_subtype_of(Any, T))\n    static_assert(not is_subtype_of(T, Super))\n    static_assert(not is_subtype_of(Super, T))\n    static_assert(not is_subtype_of(T, Sub))\n    static_assert(not is_subtype_of(Sub, T))\n\n@final\nclass FinalClass: ...\n\ndef bounded_final[T: FinalClass](t: list[T]) -> None:\n    static_assert(is_assignable_to(T, FinalClass))\n    static_assert(not is_assignable_to(FinalClass, T))\n\n    static_assert(is_subtype_of(T, FinalClass))\n    static_assert(not is_subtype_of(FinalClass, T))\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with callable instance as __new__ method in Python\nDESCRIPTION: Demonstrates the use of a callable instance as the __new__ method, including type checking and error handling for different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Callable:\n    def __call__(self, cls, x: int) -> \"Foo\":\n        return object.__new__(cls)\n\nclass Foo:\n    __new__ = Callable()\n\nreveal_type(Foo(1))  # revealed: Foo\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\nreveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Extended String Literal Type Narrowing\nDESCRIPTION: Demonstrates type narrowing behavior with string Literal types against a longer string literal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: Literal[\"a\", \"b\", \"c\", \"e\"]):\n    if x in \"abcd\":\n        reveal_type(x)  # revealed: Literal[\"a\", \"b\", \"c\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"e\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in Elif Clauses with 'is'\nDESCRIPTION: Demonstrates type narrowing across multiple elif clauses using 'is' comparisons. Shows how the type system narrows union types in different conditional branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = None if flag1 else (1 if flag2 else True)\n\n    reveal_type(x)  # revealed: None | Literal[1, True]\n    if x is None:\n        reveal_type(x)  # revealed: None\n    elif x is True:\n        reveal_type(x)  # revealed: Literal[True]\n    else:\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Typevar Inferences in a Single Generic Function in Python\nDESCRIPTION: This snippet shows how a single generic function can instantiate its typevar to different types when called multiple times.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: T) -> T:\n    return x\n\nreveal_type(f(1))  # revealed: Literal[1]\nreveal_type(f(\"a\"))  # revealed: Literal[\"a\"]\n```\n\n----------------------------------------\n\nTITLE: Accessing Instance and Metaclass Attributes with inspect.getattr_static in Python\nDESCRIPTION: This snippet demonstrates how inspect.getattr_static can access instance attributes and attributes defined on metaclasses. It also shows a limitation where metaclass attributes are not accessible when probing an instance of the class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass D:\n    def __init__(self) -> None:\n        self.instance_attr: int = 1\n\nreveal_type(inspect.getattr_static(D(), \"instance_attr\"))  # revealed: int\n\nclass Meta(type):\n    attr: int = 1\n\nclass E(metaclass=Meta): ...\n\nreveal_type(inspect.getattr_static(E, \"attr\"))  # revealed: int\n\nreveal_type(inspect.getattr_static(E(), \"attr\", \"non_existent\"))  # revealed: Literal[\"non_existent\"]\n```\n\n----------------------------------------\n\nTITLE: Dataclass Inheritance - Both Dataclasses\nDESCRIPTION: Demonstrates inheritance between two dataclasses with proper field initialization.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass Base:\n    x: int\n\n@dataclass\nclass Derived(Base):\n    y: str\n\nd = Derived(1, \"a\")  # OK\n\nreveal_type(d.x)  # revealed: int\nreveal_type(d.y)  # revealed: str\n\n# TODO: should be an error:\nDerived(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Star Import with __all__ Declaration\nDESCRIPTION: Demonstrates how __all__ controls which symbols are exported in star imports\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n__all__ = (\"X\", \"_private\", \"__protected\", \"__dunder__\", \"___thunder___\")\n\nX: bool = True\n_private: bool = True\n__protected: bool = True\n__dunder__: bool = True\n___thunder___: bool = True\n\nY: bool = False\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\n\nreveal_type(_private)  # revealed: bool\nreveal_type(__protected)  # revealed: bool\nreveal_type(__dunder__)  # revealed: bool\nreveal_type(___thunder___)  # revealed: bool\n\nreveal_type(Y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Decorator Error Cases in Python\nDESCRIPTION: Demonstrates various error scenarios when using decorators, including unknown decorators, non-callable decorators, and incorrect signatures.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference] \"Name `unknown_decorator` used when not defined\"\n@unknown_decorator\ndef f(x): ...\n\nreveal_type(f)  # revealed: Unknown\n\n# error: [unsupported-operator]\n@(1 + \"a\")\ndef f(x): ...\n\nreveal_type(f)  # revealed: Unknown\n\nnon_callable = 1\n\n# error: [call-non-callable] \"Object of type `Literal[1]` is not callable\"\n@non_callable\ndef f(x): ...\n\nreveal_type(f)  # revealed: Unknown\n\ndef wrong_signature(f: int) -> str:\n    return \"a\"\n\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `def f(x) -> Unknown`\"\n@wrong_signature\ndef f(x): ...\n\nreveal_type(f)  # revealed: str\n\ndef takes_two_arguments(f, g) -> str:\n    return \"a\"\n\n# error: [missing-argument] \"No argument provided for required parameter `g` of function `takes_two_arguments`\"\n@takes_two_arguments\ndef f(x): ...\n\nreveal_type(f)  # revealed: str\n\ndef takes_no_argument() -> str:\n    return \"a\"\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `takes_no_argument`: expected 0, got 1\"\n@takes_no_argument\ndef g(x): ...\n```\n\n----------------------------------------\n\nTITLE: Typing.Tuple Usage Examples\nDESCRIPTION: Shows the interchangeable usage of typing.Tuple with built-in tuple, including type hints and revelations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Tuple\n\nclass A: ...\n\ndef _(c: Tuple, d: Tuple[int, A], e: Tuple[Any, ...]):\n    reveal_type(c)  # revealed: tuple\n    reveal_type(d)  # revealed: tuple[int, A]\n    reveal_type(e)  # revealed: @Todo(full tuple[...] support)\n```\n\n----------------------------------------\n\nTITLE: Static Assertions for Comparing Type[T] and Type[S]\nDESCRIPTION: This snippet makes assertions regarding the disjoint status of different metaclasses associated with types T and S. It uses static assertions to validate these relationships, emphasizing inheritance and metaclass nuances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\nfrom knot_extensions import static_assert, is_disjoint_from\n\n@final\nclass Meta1(type): ...\n\nclass Meta2(type): ...\nclass UsesMeta1(metaclass=Meta1): ...\nclass UsesMeta2(metaclass=Meta2): ...\n\nstatic_assert(is_disjoint_from(type[UsesMeta1], type[UsesMeta2]))\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Gradual and Specific Callable Types\nDESCRIPTION: This code demonstrates that gradual callable types (using ...) are not equivalent to callable types with specific parameter types. This is because gradual types have less precise type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(not is_equivalent_to(Callable[..., None], Callable[[int], None]))\nstatic_assert(not is_equivalent_to(Callable[[int], None], Callable[..., None]))\n```\n\n----------------------------------------\n\nTITLE: Multiple Negative Type Narrowing in Python\nDESCRIPTION: Demonstrates how type narrowing works with multiple nested negative conditions. Shows progressive narrowing of an integer type by excluding specific literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/nested.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int):\n    if x != 1:\n        if x != 2:\n            if x != 3:\n                reveal_type(x)  # revealed: int & ~Literal[1] & ~Literal[2] & ~Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unbounded Typevar Subtyping in Python\nDESCRIPTION: Shows how unbounded, unconstrained type variables relate to other types through subtyping and assignability checks. Demonstrates that typevars are only subtypes of themselves and object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_assignable_to, is_subtype_of, static_assert\n\nclass Super: ...\nclass Base(Super): ...\nclass Sub(Base): ...\nclass Unrelated: ...\n\ndef unbounded_unconstrained[T, U](t: list[T], u: list[U]) -> None:\n    static_assert(is_assignable_to(T, T))\n    static_assert(is_assignable_to(T, object))\n    static_assert(not is_assignable_to(T, Super))\n    static_assert(is_assignable_to(U, U))\n    static_assert(is_assignable_to(U, object))\n    static_assert(not is_assignable_to(U, Super))\n    static_assert(not is_assignable_to(T, U))\n    static_assert(not is_assignable_to(U, T))\n\n    static_assert(is_subtype_of(T, T))\n    static_assert(is_subtype_of(T, object))\n    static_assert(not is_subtype_of(T, Super))\n    static_assert(is_subtype_of(U, U))\n    static_assert(is_subtype_of(U, object))\n    static_assert(not is_subtype_of(U, Super))\n    static_assert(not is_subtype_of(T, U))\n    static_assert(not is_subtype_of(U, T))\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Boolean Literals in Python\nDESCRIPTION: Shows type inference with boolean literals and variables with boolean literal types, where 'not True' is Literal[False] and 'not False' is Literal[True].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nw = True\nreveal_type(w)  # revealed: Literal[True]\n\nx = False\nreveal_type(x)  # revealed: Literal[False]\n\nreveal_type(not w)  # revealed: Literal[False]\n\nreveal_type(not x)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Never Return Type with Raise Statement\nDESCRIPTION: Example showing how raise statements are treated as Never type which is assignable to any return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> str:\n    raise ValueError()\n\nreveal_type(f())  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with LiteralString in Python\nDESCRIPTION: Shows how LiteralString types can be narrowed through equality checks and other comparisons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\nlorem: LiteralString = \"lorem\" * 1_000_000_000\n\nreveal_type(lorem)  # revealed: LiteralString\n\nif lorem == \"ipsum\":\n    reveal_type(lorem)  # revealed: Literal[\"ipsum\"]\n\nreveal_type(lorem)  # revealed: LiteralString\n\nif \"\" < lorem == \"ipsum\":\n    reveal_type(lorem)  # revealed: Literal[\"ipsum\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Import Cycle and MRO in Python\nDESCRIPTION: This example shows an import cycle between two files and how it affects the Method Resolution Order (MRO) of classes. The cycle allows classes to inherit from each other across files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\nreveal_type(A.__mro__)  # revealed: tuple[Literal[A], Literal[object]]\nimport b\n\nclass C(b.B): ...\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[B], Literal[A], Literal[object]]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import A\n\nclass B(A): ...\n\nreveal_type(B.__mro__)  # revealed: tuple[Literal[B], Literal[A], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Testing Submodule and Attribute Precedence\nDESCRIPTION: Tests the precedence between submodules and attributes of the same name. Demonstrates that submodules take priority over attributes defined in __init__.py.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/tracking.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sub.b\nimport attr.b\n\n# In the Python interpreter, `attr.b` is Literal[1]\nreveal_type(sub.b)  # revealed: <module 'sub.b'>\nreveal_type(attr.b)  # revealed: <module 'attr.b'>\n```\n\nLANGUAGE: python\nCODE:\n```\nb = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom . import b as _\n\nb = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Subclassing typing.Any in Python\nDESCRIPTION: Shows how to create a subclass of typing.Any and its behavior. The spec allows subclassing Any, but the behavior around assignments has some nuances that need to be handled correctly.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/any.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nclass Subclass(Any): ...\n\nreveal_type(Subclass.__mro__)  # revealed: tuple[Literal[Subclass], Any, Literal[object]]\n\nx: Subclass = 1  # error: [invalid-assignment]\n# TODO: no diagnostic\ny: int = Subclass()  # error: [invalid-assignment]\n\ndef _(s: Subclass):\n    reveal_type(s)  # revealed: Subclass\n```\n\n----------------------------------------\n\nTITLE: Chained Comparisons with Non-Boolean Results\nDESCRIPTION: Shows type checking behavior for chained comparisons where elements incorrectly implement __bool__. Demonstrates how comparison operations are desugared.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 5\n\nclass Comparable:\n    def __lt__(self, other) -> NotBoolable:\n        return NotBoolable()\n\n    def __gt__(self, other) -> NotBoolable:\n        return NotBoolable()\n\na = (1, Comparable())\nb = (1, Comparable())\n\n# error: [unsupported-bool-conversion]\na < b < b\n\na < b  # fine\n```\n\n----------------------------------------\n\nTITLE: Illustrating Method Typevars Distinct from Class Typevars in Python\nDESCRIPTION: This example shows how typevars in methods that don't match class typevars make the method a generic function in that variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\nS = TypeVar(\"S\")\n\n# TODO: no error\n# error: [invalid-base]\nclass Legacy(Generic[T]):\n    def m(self, x: T, y: S) -> S:\n        return y\n\nlegacy: Legacy[int] = Legacy()\n# TODO: revealed: str\nreveal_type(legacy.m(1, \"string\"))  # revealed: @Todo(Support for `typing.TypeVar` instances in type expressions)\n```\n\n----------------------------------------\n\nTITLE: For Loop with Else Clause\nDESCRIPTION: Example of type analysis with for-else construct where the loop completes without breaking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\nfor x in IntIterable():\n    pass\nelse:\n    x = \"foo\"\n\nreveal_type(x)  # revealed: Literal[\"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Starred Expressions in Python Comprehensions\nDESCRIPTION: Demonstrates the use of starred expressions in list comprehensions and their requirement for iterable objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass NotIterable: ...\n\nclass Iterator:\n    def __next__(self) -> int:\n        return 42\n\nclass Iterable:\n    def __iter__(self) -> Iterator:\n        return Iterator()\n\n# This is fine:\nx = [*Iterable()]\n\n# error: [not-iterable] \"Object of type `NotIterable` is not iterable\"\ny = [*NotIterable()]\n```\n\n----------------------------------------\n\nTITLE: Boolean Literal Arithmetic Operations in Python\nDESCRIPTION: Demonstrates type checking results for arithmetic operations between boolean literals (True/False). Shows that most operations result in Literal types except division which returns float. Includes basic arithmetic, power operations, and bitwise operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/booleans.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = True\nb = False\n\nreveal_type(a + a)  # revealed: Literal[2]\nreveal_type(a + b)  # revealed: Literal[1]\nreveal_type(b + a)  # revealed: Literal[1]\nreveal_type(b + b)  # revealed: Literal[0]\n\nreveal_type(a - a)  # revealed: Literal[0]\nreveal_type(a - b)  # revealed: Literal[1]\nreveal_type(b - a)  # revealed: Literal[-1]\nreveal_type(b - b)  # revealed: Literal[0]\n\nreveal_type(a * a)  # revealed: Literal[1]\nreveal_type(a * b)  # revealed: Literal[0]\nreveal_type(b * a)  # revealed: Literal[0]\nreveal_type(b * b)  # revealed: Literal[0]\n\nreveal_type(a % a)  # revealed: Literal[0]\nreveal_type(b % a)  # revealed: Literal[0]\n\nreveal_type(a // a)  # revealed: Literal[1]\nreveal_type(b // a)  # revealed: Literal[0]\n\nreveal_type(a**a)  # revealed: Literal[1]\nreveal_type(a**b)  # revealed: Literal[1]\nreveal_type(b**a)  # revealed: Literal[0]\nreveal_type(b**b)  # revealed: Literal[1]\n\n# Division\nreveal_type(a / a)  # revealed: float\nreveal_type(b / a)  # revealed: float\nb / b  # error: [division-by-zero] \"Cannot divide object of type `Literal[False]` by zero\"\na / b  # error: [division-by-zero] \"Cannot divide object of type `Literal[True]` by zero\"\n\n# bitwise OR\nreveal_type(a | a)  # revealed: Literal[True]\nreveal_type(a | b)  # revealed: Literal[True]\nreveal_type(b | a)  # revealed: Literal[True]\nreveal_type(b | b)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Conditional Type Annotation with 'if True...else' in Python\nDESCRIPTION: Demonstrates how type annotations in unreachable else blocks are ignored. The variable 'x' maintains its original string type annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nx: str\n\nif True:\n    pass\nelse:\n    x: int\n\ndef f() -> None:\n    reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Handling Variables Defined in Multiple Methods in Python\nDESCRIPTION: Demonstrates type inference for attributes assigned in multiple methods, including cases with conflicting declarations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef get_int() -> int:\n    return 0\n\ndef get_str() -> str:\n    return \"a\"\n\nclass C:\n    z: int\n\n    def __init__(self) -> None:\n        self.x = get_int()\n        self.y: int = 1\n\n    def other_method(self):\n        self.x = get_str()\n\n        # TODO: this redeclaration should be an error\n        self.y: str = \"a\"\n\n        # TODO: this redeclaration should be an error\n        self.z: str = \"a\"\n\nc_instance = C()\n\nreveal_type(c_instance.x)  # revealed: Unknown | int | str\nreveal_type(c_instance.y)  # revealed: int\nreveal_type(c_instance.z)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Unpacking Non-Iterable Value in Python\nDESCRIPTION: Demonstrates the error that occurs when attempting to unpack a non-iterable value (integer) into multiple variables. This operation fails because integers are not iterable objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unpacking.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na, b = 1  # error: [not-iterable]\n```\n\n----------------------------------------\n\nTITLE: Using Default Values with inspect.getattr_static in Python\nDESCRIPTION: This snippet demonstrates how to use default values with inspect.getattr_static for both existing and non-existent attributes. It also shows a case where a diagnostic could potentially be emitted for accessing a non-existent attribute without a default value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(inspect.getattr_static(C, \"normal\", \"default-arg\"))  # revealed: int\nreveal_type(inspect.getattr_static(C, \"non_existent\", \"default-arg\"))  # revealed: Literal[\"default-arg\"]\n\n# TODO: we could emit a diagnostic here\nreveal_type(inspect.getattr_static(C, \"non_existent\"))  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Linear Metaclass Inheritance\nDESCRIPTION: Shows how metaclasses are inherited in a linear inheritance chain.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass M(type): ...\nclass A(metaclass=M): ...\nclass B(A): ...\n\nreveal_type(B.__class__)  # revealed: Literal[M]\n```\n\n----------------------------------------\n\nTITLE: Metaclass Descriptor Implementation\nDESCRIPTION: Example showing descriptor protocol implementation with metaclasses and their precedence chain\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Any\n\nclass Meta1(type):\n    meta_data_descriptor: DataDescriptor = DataDescriptor()\n    meta_non_data_descriptor: NonDataDescriptor = NonDataDescriptor()\n\nclass C1(metaclass=Meta1):\n    class_data_descriptor: DataDescriptor = DataDescriptor()\n    class_non_data_descriptor: NonDataDescriptor = NonDataDescriptor()\n```\n\n----------------------------------------\n\nTITLE: Building Red Knot Type Checker\nDESCRIPTION: Cargo command to build the Red Knot binary in release mode\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/knot_benchmark/README.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --bin red_knot --release\n```\n\n----------------------------------------\n\nTITLE: Simple Multi-Parameter Callable\nDESCRIPTION: Shows proper implementation of Callable with multiple parameters and return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef _(c: Callable[[int, str], int]):\n    reveal_type(c)  # revealed: (int, str, /) -> int\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Comparison Classes in Python\nDESCRIPTION: This code snippet defines three custom classes (A, B, C) with overloaded comparison operators. It demonstrates how these classes behave in chained comparisons and shows the resulting type inference using reveal_type().\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/non_bool_returns.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass A:\n    def __lt__(self, other) -> A:\n        return self\n\n    def __gt__(self, other) -> bool:\n        return False\n\nclass B:\n    def __lt__(self, other) -> B:\n        return self\n\nclass C:\n    def __lt__(self, other) -> C:\n        return self\n\nx = A() < B() < C()\nreveal_type(x)  # revealed: A & ~AlwaysTruthy | B\n\ny = 0 < 1 < A() < 3\nreveal_type(y)  # revealed: Literal[False] | A\n\nz = 10 < 0 < A() < B() < C()\nreveal_type(z)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Stub Function Definitions in .pyi Files\nDESCRIPTION: Examples of valid stub function definitions in stub files with various body formats.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> int: ...\n\ndef f() -> int:\n    pass\n\ndef f() -> int:\n    \"\"\"Some docstring\"\"\"\n\ndef f() -> int:\n    \"\"\"Some docstring\"\"\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Conditionally Mutated __all__ in Python 3.11\nDESCRIPTION: Shows behavior when importing from a module with conditionally mutated __all__ in Python 3.11. The type checker correctly recognizes that X and Y are available but Z is not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\nreveal_type(Y)  # revealed: bool\n\n# error: [unresolved-reference]\nreveal_type(Z)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Custom Error Messages in Static Assertions in Python\nDESCRIPTION: Shows how to provide custom error messages for static assertions, including both literal strings and programmatically constructed messages.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\n\n# error: \"Static assertion error: I really want this to be true\"\nstatic_assert(1 + 1 == 3, \"I really want this to be true\")\n\nerror_message = \"A custom message \"\nerror_message += \"constructed from multiple string literals\"\n# error: \"Static assertion error: A custom message constructed from multiple string literals\"\nstatic_assert(False, error_message)\n```\n\n----------------------------------------\n\nTITLE: Optional Type Assignment in Python\nDESCRIPTION: Shows valid and invalid assignments with Optional[int] type annotation. The example demonstrates that while None is allowed, other types like strings are not assignable to Optional[int].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/optional.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\na: Optional[int] = 1\na = None\n# error: [invalid-assignment] \"Object of type `Literal[\"\"]` is not assignable to `int | None`\"\na = \"\"\n```\n\n----------------------------------------\n\nTITLE: Parameter Already Assigned Error in Python Function Call\nDESCRIPTION: Demonstrates an error when a parameter is assigned multiple values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    return 1\n\n# error: 18 [parameter-already-assigned] \"Multiple values provided for parameter `x` of function `f`\"\nreveal_type(f(1, x=2))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Adding Ruff Badge in Markdown\nDESCRIPTION: Code snippet for adding the Ruff badge to a project's README.md file using Markdown syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n[![Ruff](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Function Scope Resolution\nDESCRIPTION: Shows how function definitions evaluate variable references lazily, with the value being resolved at function call time rather than definition time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ndef f():\n    reveal_type(x)  # revealed: Unknown | Literal[2]\n\nx = 2\n```\n\n----------------------------------------\n\nTITLE: While Loop with Else Clause Type Narrowing\nDESCRIPTION: Shows type narrowing behavior in a while loop with an else clause, demonstrating how the type is narrowed both within the loop and in the else block.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/while.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef next_item() -> int | None:\n    return 1\n\nx = next_item()\n\nwhile x is not None:\n    reveal_type(x)  # revealed: int\n    x = next_item()\nelse:\n    reveal_type(x)  # revealed: None\n\nreveal_type(x)  # revealed: None\n```\n\n----------------------------------------\n\nTITLE: Working with __class__ Method for Python Type Inspection\nDESCRIPTION: Demonstrates how x.__class__ is equivalent to type(x) and returns the meta-type of an object for various Python types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nimport typing_extensions\n\nreveal_type(typing_extensions.__class__)  # revealed: Literal[ModuleType]\nreveal_type(type(typing_extensions))  # revealed: Literal[ModuleType]\n\na = 42\nreveal_type(a.__class__)  # revealed: Literal[int]\nreveal_type(type(a))  # revealed: Literal[int]\n\nb = \"42\"\nreveal_type(b.__class__)  # revealed: Literal[str]\n\nc = b\"42\"\nreveal_type(c.__class__)  # revealed: Literal[bytes]\n\nd = True\nreveal_type(d.__class__)  # revealed: Literal[bool]\n\ne = (42, 42)\nreveal_type(e.__class__)  # revealed: Literal[tuple]\n\ndef f(a: int, b: typing_extensions.LiteralString, c: int | str, d: type[str]):\n    reveal_type(a.__class__)  # revealed: type[int]\n    reveal_type(type(a))  # revealed: type[int]\n\n    reveal_type(b.__class__)  # revealed: Literal[str]\n    reveal_type(type(b))  # revealed: Literal[str]\n\n    reveal_type(c.__class__)  # revealed: type[int] | type[str]\n    reveal_type(type(c))  # revealed: type[int] | type[str]\n\n    # `type[type]`, a.k.a., either the class `type` or some subclass of `type`.\n    # It would be incorrect to infer `Literal[type]` here,\n    # as `c` could be some subclass of `str` with a custom metaclass.\n    # All we know is that the metaclass must be a (non-strict) subclass of `type`.\n    reveal_type(d.__class__)  # revealed: type[type]\n\nreveal_type(f.__class__)  # revealed: Literal[FunctionType]\n\nclass Foo: ...\n\nreveal_type(Foo.__class__)  # revealed: Literal[type]\n```\n\n----------------------------------------\n\nTITLE: Importing and Revealing Builtin Module in Python\nDESCRIPTION: This snippet demonstrates how to explicitly import the builtins module and reveal the type of a builtin function (chr) using reveal_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport builtins\n\nreveal_type(builtins.chr)  # revealed: def chr(i: int | SupportsIndex, /) -> str\n```\n\n----------------------------------------\n\nTITLE: Implementing a Valid __getitem__ Method for Subscript Operations in Python\nDESCRIPTION: Demonstrates a proper implementation of the __getitem__ method that returns the index value. The type checker correctly infers the return type as int.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/instance.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Identity:\n    def __getitem__(self, index: int) -> int:\n        return index\n\nreveal_type(Identity()[0])  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Class with a Method in Python\nDESCRIPTION: Demonstrates the basic structure of a class with a method, which is used to explain the descriptor protocol and method behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def f(self, x: int) -> str:\n        return \"a\"\n```\n\n----------------------------------------\n\nTITLE: Multiple Non-callable Elements in a Union Type\nDESCRIPTION: Shows type checking behavior when a union contains multiple non-callable elements along with a callable one, and how the diagnostic mentions non-callable types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    if flag:\n        f = 1\n    elif flag2:\n        f = \"foo\"\n    else:\n        def f() -> int:\n            return 1\n    # TODO we should mention all non-callable elements of the union\n    # error: [call-non-callable] \"Object of type `Literal[1]` is not callable\"\n    # revealed: Unknown | int\n    reveal_type(f())\n```\n\n----------------------------------------\n\nTITLE: Special-Case Function Attributes\nDESCRIPTION: Shows special-cased function attributes that are handled differently from regular function attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(f.__get__)  # revealed: <method-wrapper `__get__` of `f`>\nreveal_type(f.__call__)  # revealed: <method-wrapper `__call__` of `f`>\n```\n\n----------------------------------------\n\nTITLE: Testing Intersections Containing Tuples with Union Types\nDESCRIPTION: This code demonstrates equivalence between intersection types that contain tuples with differently ordered union types. It shows that the equivalence relation extends to complex combinations of intersection and union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_equivalent_to, static_assert, Intersection\n\nclass P: ...\nclass Q: ...\nclass R: ...\n\nstatic_assert(is_equivalent_to(Intersection[tuple[P | Q], R], Intersection[tuple[Q | P], R]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Operations with Bounded TypeVars in Python\nDESCRIPTION: Illustrates how unions with bounded typevars simplify in certain cases. The union of a bounded typevar with its bound simplifies to the bound, while other unions may not simplify.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef bounded[T: Base](t: T) -> None:\n    def _(x: T | Super) -> None:\n        reveal_type(x)  # revealed: Super\n\n    def _(x: T | Base) -> None:\n        reveal_type(x)  # revealed: Base\n\n    def _(x: T | Sub) -> None:\n        reveal_type(x)  # revealed: T | Sub\n\n    def _(x: T | Unrelated) -> None:\n        reveal_type(x)  # revealed: T | Unrelated\n\n    def _(x: T | Any) -> None:\n        reveal_type(x)  # revealed: T | Any\n```\n\n----------------------------------------\n\nTITLE: Testing Subtyping Relationships in Python\nDESCRIPTION: Demonstrates using is_subtype_of to test subtyping relationships between types, including class hierarchies and union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_subtype_of, static_assert\n\nstatic_assert(is_subtype_of(bool, int))\nstatic_assert(not is_subtype_of(str, int))\n\nstatic_assert(is_subtype_of(bool, int | str))\nstatic_assert(is_subtype_of(str, int | str))\nstatic_assert(not is_subtype_of(bytes, int | str))\n\nclass Base: ...\nclass Derived(Base): ...\nclass Unrelated: ...\n\nstatic_assert(is_subtype_of(Derived, Base))\nstatic_assert(not is_subtype_of(Base, Derived))\nstatic_assert(is_subtype_of(Base, Base))\n\nstatic_assert(not is_subtype_of(Unrelated, Base))\nstatic_assert(not is_subtype_of(Base, Unrelated))\n```\n\n----------------------------------------\n\nTITLE: Error Cases: Calling __get__ for Methods in Python\nDESCRIPTION: Demonstrates various error cases when calling the __get__ method for functions, enforcing the correct signature as defined in typeshed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import getattr_static\n\nclass C:\n    def f(self, x: int) -> str:\n        return \"a\"\n\nmethod_wrapper = getattr_static(C, \"f\").__get__\n\nreveal_type(method_wrapper)  # revealed: <method-wrapper `__get__` of `f`>\n\n# All of these are fine:\nmethod_wrapper(C(), C)\nmethod_wrapper(C())\nmethod_wrapper(C(), None)\nmethod_wrapper(None, C)\n\n# Passing `None` without an `owner` argument is an\n# error: [no-matching-overload] \"No overload of method wrapper `__get__` of function `f` matches arguments\"\nmethod_wrapper(None)\n\n# Passing something that is not assignable to `type` as the `owner` argument is an\n# error: [no-matching-overload] \"No overload of method wrapper `__get__` of function `f` matches arguments\"\nmethod_wrapper(None, 1)\n\n# Passing `None` as the `owner` argument when `instance` is `None` is an\n# error: [no-matching-overload] \"No overload of method wrapper `__get__` of function `f` matches arguments\"\nmethod_wrapper(None, None)\n\n# Calling `__get__` without any arguments is an\n# error: [no-matching-overload] \"No overload of method wrapper `__get__` of function `f` matches arguments\"\nmethod_wrapper()\n\n# Calling `__get__` with too many positional arguments is an\n# error: [no-matching-overload] \"No overload of method wrapper `__get__` of function `f` matches arguments\"\nmethod_wrapper(C(), C, \"one too many\")\n```\n\n----------------------------------------\n\nTITLE: Trailing Comma in Error Codes List in Python\nDESCRIPTION: Demonstrates that trailing commas are allowed in the error codes list of a knot: ignore directive.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na = 10 / 0  # knot: ignore[division-by-zero,]\n```\n\n----------------------------------------\n\nTITLE: Classmethod Argument Passing\nDESCRIPTION: Shows how the cls parameter is implicitly passed when calling classmethods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(C.f(1))  # revealed: str\nreveal_type(C().f(1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Nested Module Imports in Python\nDESCRIPTION: Demonstrates importing from a nested module structure and revealing the type of the imported class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport a.b\n\nreveal_type(a.b.C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Union Including a Special-cased Function\nDESCRIPTION: Shows how special-cased functions like str() and repr() are handled in unions, with their return types forming a union of literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        f = str\n    else:\n        f = repr\n    reveal_type(str(\"string\"))  # revealed: Literal[\"string\"]\n    reveal_type(repr(\"string\"))  # revealed: Literal[\"'string'\"]\n    reveal_type(f(\"string\"))  # revealed: Literal[\"string\", \"'string'\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Default Values in Python Function Parameters\nDESCRIPTION: This snippet demonstrates how Python handles cases where the default value type is not assignable to the annotated type. It shows both an error case and a valid case using Any.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-parameter-default]\ndef f(x: int = \"foo\"):\n    reveal_type(x)  # revealed: int\n\n# The check is assignable-to, not subtype-of, so this is fine:\nfrom typing import Any\n\ndef g(x: Any = \"foo\"):\n    reveal_type(x)  # revealed: Any | Literal[\"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Instance Variables with Class Defaults\nDESCRIPTION: Demonstrates behavior of instance attributes with class-level default values, including type revelation and value assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    variable_with_class_default1: str = \"value in class body\"\n    variable_with_class_default2 = 1\n\n    def instance_method(self):\n        self.variable_with_class_default1 = \"value set in instance method\"\n\nreveal_type(C.variable_with_class_default1)\nreveal_type(C.variable_with_class_default2)\n\nc_instance = C()\n\nreveal_type(c_instance.variable_with_class_default1)\nreveal_type(c_instance.variable_with_class_default2)\n```\n\n----------------------------------------\n\nTITLE: Multiple Predicates Type Narrowing - Python\nDESCRIPTION: Demonstrates type narrowing with multiple predicates using Literal types and combined conditions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(flag1: bool, flag2: bool):\n    class A: ...\n    x: A | None | Literal[1] = A() if flag1 else None if flag2 else 1\n\n    x is None or isinstance(x, A) or reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Importing and Revealing Type of Conditionally Imported/Assigned Variable in Python\nDESCRIPTION: This snippet demonstrates importing a variable that was conditionally imported or assigned. It shows how type revealing works in this scenario with a stub declaration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom b import x\n\nreveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: While-Else Variable Boundness (No Break) in Python\nDESCRIPTION: Demonstrates variable boundness checking in while-else construct without breaks, showing different behavior for loop and else block variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    while flag:\n        y = 1\n    else:\n        x = 1\n\n    # no error, `x` is always bound\n    x\n    # error: [possibly-unresolved-reference]\n    y\n```\n\n----------------------------------------\n\nTITLE: Simple String Literal Type Analysis in Python\nDESCRIPTION: Demonstrates basic string literal type inference using reveal_type(), including string concatenation examples. Shows how Python infers literal types for standalone strings and concatenated strings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/string.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(\"Hello\")  # revealed: Literal[\"Hello\"]\nreveal_type(\"world\")  # revealed: Literal[\"world\"]\nreveal_type(\"Guten \" + \"Tag\")  # revealed: Literal[\"Guten Tag\"]\nreveal_type(\"bon \" + \"jour\")  # revealed: Literal[\"bon jour\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unbound Variable Reference Detection in Python\nDESCRIPTION: This code snippet demonstrates how unbound variable references are detected and handled in static analysis. It shows that an error is reported when a variable is used before it's defined, and explains how type inference assigns 'Unknown' type to prevent cascading errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/unbound.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = foo  # error: [unresolved-reference] \"Name `foo` used when not defined\"\nfoo = 1\n\n# No error `unresolved-reference` diagnostic is reported for `x`. This is\n# desirable because we would get a lot of cascading errors even though there\n# is only one root cause (the unbound variable `foo`).\n\n# revealed: Unknown\nreveal_type(x)\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Type Equivalence in Python Static Typing\nDESCRIPTION: This code demonstrates basic equivalence relations between types using the `is_equivalent_to` function. It shows equivalence between identical literals and type/type[object], while demonstrating non-equivalence for Any, Unknown, and different literal combinations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom typing_extensions import Literal\nfrom knot_extensions import Unknown, is_equivalent_to, static_assert\n\nstatic_assert(is_equivalent_to(Literal[1, 2], Literal[1, 2]))\nstatic_assert(is_equivalent_to(type[object], type))\n\nstatic_assert(not is_equivalent_to(Any, Any))\nstatic_assert(not is_equivalent_to(Unknown, Unknown))\nstatic_assert(not is_equivalent_to(Any, None))\nstatic_assert(not is_equivalent_to(Literal[1, 2], Literal[1, 0]))\nstatic_assert(not is_equivalent_to(Literal[1, 2], Literal[1, 2, 3]))\n```\n\n----------------------------------------\n\nTITLE: String Slicing Operations in Python\nDESCRIPTION: Shows various string slicing operations including standard slices, negative indices, omitted start/end positions, and step values. The snippet demonstrates how type information is preserved for literal string slices and identifies errors for invalid operations like zero step size.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/string.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(m: int, n: int, s2: str):\n    s = \"abcde\"\n\n    reveal_type(s[0:0])  # revealed: Literal[\"\"]\n    reveal_type(s[0:1])  # revealed: Literal[\"a\"]\n    reveal_type(s[0:2])  # revealed: Literal[\"ab\"]\n    reveal_type(s[0:5])  # revealed: Literal[\"abcde\"]\n    reveal_type(s[0:6])  # revealed: Literal[\"abcde\"]\n    reveal_type(s[1:3])  # revealed: Literal[\"bc\"]\n\n    reveal_type(s[-3:5])  # revealed: Literal[\"cde\"]\n    reveal_type(s[-4:-2])  # revealed: Literal[\"bc\"]\n    reveal_type(s[-10:10])  # revealed: Literal[\"abcde\"]\n\n    reveal_type(s[0:])  # revealed: Literal[\"abcde\"]\n    reveal_type(s[2:])  # revealed: Literal[\"cde\"]\n    reveal_type(s[5:])  # revealed: Literal[\"\"]\n    reveal_type(s[:2])  # revealed: Literal[\"ab\"]\n    reveal_type(s[:0])  # revealed: Literal[\"\"]\n    reveal_type(s[:2])  # revealed: Literal[\"ab\"]\n    reveal_type(s[:10])  # revealed: Literal[\"abcde\"]\n    reveal_type(s[:])  # revealed: Literal[\"abcde\"]\n\n    reveal_type(s[::-1])  # revealed: Literal[\"edcba\"]\n    reveal_type(s[::2])  # revealed: Literal[\"ace\"]\n    reveal_type(s[-2:-5:-1])  # revealed: Literal[\"dcb\"]\n    reveal_type(s[::-2])  # revealed: Literal[\"eca\"]\n    reveal_type(s[-1::-3])  # revealed: Literal[\"eb\"]\n\n    reveal_type(s[None:2:None])  # revealed: Literal[\"ab\"]\n    reveal_type(s[1:None:1])  # revealed: Literal[\"bcde\"]\n    reveal_type(s[None:None:None])  # revealed: Literal[\"abcde\"]\n\n    start = 1\n    stop = None\n    step = 2\n    reveal_type(s[start:stop:step])  # revealed: Literal[\"bd\"]\n\n    reveal_type(s[False:True])  # revealed: Literal[\"a\"]\n    reveal_type(s[True:3])  # revealed: Literal[\"bc\"]\n\n    s[0:4:0]  # error: [zero-stepsize-in-slice]\n    s[:4:0]  # error: [zero-stepsize-in-slice]\n    s[0::0]  # error: [zero-stepsize-in-slice]\n    s[::0]  # error: [zero-stepsize-in-slice]\n\n    substring1 = s[m:n]\n    # TODO: Support overloads... Should be `LiteralString`\n    reveal_type(substring1)  # revealed: @Todo(return type of overloaded function)\n\n    substring2 = s2[0:5]\n    # TODO: Support overloads... Should be `str`\n    reveal_type(substring2)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with callable instance as __init__ method in Python\nDESCRIPTION: Demonstrates the use of a callable instance as the __init__ method, including type checking and error handling for different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass Callable:\n    def __call__(self, x: int) -> None:\n        pass\n\nclass Foo:\n    __init__ = Callable()\n\nreveal_type(Foo(1))  # revealed: Foo\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\nreveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness in Class Hierarchies with Python Type System\nDESCRIPTION: This code illustrates how disjointness works in class hierarchies. It shows that subclasses are not disjoint from their parent classes, and non-final sibling classes are not disjoint from each other because they could share a common subclass. However, final classes are disjoint from other classes that don't share an inheritance path.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_disjoint_from, static_assert, Intersection, is_subtype_of\nfrom typing import final\n\nclass A: ...\nclass B1(A): ...\nclass B2(A): ...\n\n# B1 and B2 are subclasses of A, so they are not disjoint from A:\nstatic_assert(not is_disjoint_from(A, B1))\nstatic_assert(not is_disjoint_from(A, B2))\n\n# The two subclasses B1 and B2 are also not disjoint ...\nstatic_assert(not is_disjoint_from(B1, B2))\n\n# ... because they could share a common subclass ...\nclass C(B1, B2): ...\n\n# ... which lies in their intersection:\nstatic_assert(is_subtype_of(C, Intersection[B1, B2]))\n\n# However, if a class is marked final, it can not be subclassed ...\n@final\nclass FinalSubclass(A): ...\n\nstatic_assert(not is_disjoint_from(FinalSubclass, A))\n\n# ... which makes it disjoint from B1, B2:\nstatic_assert(is_disjoint_from(B1, FinalSubclass))\nstatic_assert(is_disjoint_from(B2, FinalSubclass))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Import and Function Definition in Python\nDESCRIPTION: This snippet shows a scenario where a function 'f' is either imported or defined based on a condition. It demonstrates how this affects type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    from c import f\nelse:\n    def f(): ...\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Conditional Type Annotation in Python\nDESCRIPTION: Shows how type annotations in conditionally executed code paths result in union types. The variable 'x' could be either a string or an int depending on the runtime condition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nx: str\n\nif flag():\n    x: int\n\ndef f() -> None:\n    reveal_type(x)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Incorrect Cls Parameter Annotation\nDESCRIPTION: Shows error detection when cls parameter is incorrectly annotated in a classmethod.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass D:\n    @classmethod\n    def f(cls: D):\n        # This function is wrongly annotated, it should be `type[D]` instead of `D`\n        pass\n\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `D`, found `Literal[D]`\"\nD.f()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating complex annotation accepting int and float values\nDESCRIPTION: Shows how Python type checkers allow passing int and float values to functions expecting complex parameters, as 'complex' annotation means 'int | float | complex'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/int_float_complex.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef takes_complex(x: complex):\n    pass\n\ndef passes_to_complex(x: float, y: int):\n    # no errors!\n    takes_complex(x)\n    takes_complex(y)\n\ndef assigns_to_complex(x: float, y: int):\n    # no errors!\n    a: complex = x\n    b: complex = y\n\ndef takes_int(x: int):\n    pass\n\ndef takes_float(x: float):\n    pass\n\ndef passes_complex(x: complex):\n    # error: [invalid-argument-type]\n    takes_int(x)\n    # error: [invalid-argument-type]\n    takes_float(x)\n\ndef assigns_complex(x: complex):\n    # error: [invalid-assignment]\n    y: int = x\n    # error: [invalid-assignment]\n    z: float = x\n\ndef f(x: complex):\n    reveal_type(x)  # revealed: int | float | complex\n```\n\n----------------------------------------\n\nTITLE: Union of Return Types in Python Functions\nDESCRIPTION: Demonstrates how a function can return a union type (int | str) when different return types are possible based on a condition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        def f() -> int:\n            return 1\n    else:\n        def f() -> str:\n            return \"foo\"\n    reveal_type(f())  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Object Type Assignability Rules in Python\nDESCRIPTION: Demonstrates that object is Python's top type and all types are assignable to it. Shows various type relationships with the object type using static assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Unknown\nfrom typing import Literal, Any\n\nstatic_assert(is_assignable_to(str, object))\nstatic_assert(is_assignable_to(Literal[1], object))\nstatic_assert(is_assignable_to(object, object))\nstatic_assert(is_assignable_to(type, object))\nstatic_assert(is_assignable_to(Any, object))\nstatic_assert(is_assignable_to(Unknown, object))\nstatic_assert(is_assignable_to(type[object], object))\nstatic_assert(is_assignable_to(type[str], object))\nstatic_assert(is_assignable_to(type[Any], object))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Eager Class Scope Resolution\nDESCRIPTION: Illustrates how class definitions evaluate variable references eagerly at definition time, capturing the current value in the enclosing scope.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    x = 1\n\n    class A:\n        reveal_type(x)  # revealed: Literal[1]\n\n        y = x\n\n    x = 2\n\n    reveal_type(A.y)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Invalid Dataclass Usage Examples\nDESCRIPTION: Shows examples of invalid dataclass instantiation patterns that should raise errors, including incorrect argument counts and types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# TODO: should be an error: too few arguments\nPerson()\n\n# TODO: should be an error: too many arguments\nPerson(\"Eve\", 20, \"too many arguments\")\n\n# TODO: should be an error: wrong argument type\nPerson(\"Eve\", \"string instead of int\")\n\n# TODO: should be an error: wrong argument types\nPerson(20, \"Eve\")\n```\n\n----------------------------------------\n\nTITLE: Nested Module Import with Renaming in Python\nDESCRIPTION: Demonstrates importing a nested module with renaming and revealing the type of its class member.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport a.b as b\n\nreveal_type(b.C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with both __new__ and __init__ methods in Python\nDESCRIPTION: Demonstrates the behavior when a class defines both __new__ and __init__ methods with identical signatures, showing how errors are reported for both methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __new__(cls, x: int) -> \"Foo\":\n        return object.__new__(cls)\n\n    def __init__(self, x: int): ...\n```\n\n----------------------------------------\n\nTITLE: Basic Classmethod Type Binding\nDESCRIPTION: Demonstrates how @classmethod binds to class and instance objects, showing type revelations for both access patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass C:\n    @classmethod\n    def f(cls: type[C], x: int) -> str:\n        return \"a\"\n\nreveal_type(C.f)  # revealed: bound method Literal[C].f(x: int) -> str\nreveal_type(C().f)  # revealed: bound method type[C].f(x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Basic Type Narrowing Without Mutation\nDESCRIPTION: Demonstrates that type narrowing has no persistent effect after if-else statements when the variable is not mutated in any branch.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/post_if_statement.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int | None):\n    if x is None:\n        pass\n    else:\n        pass\n\n    reveal_type(x)  # revealed: int | None\n```\n\n----------------------------------------\n\nTITLE: Assigning Instance Attributes with Class-Level Defaults in Python\nDESCRIPTION: Demonstrates setting attributes on instances and class objects with class-level defaults. Shows valid assignments and invalid assignments that result in type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    attr: int = 0\n\ninstance = C()\ninstance.attr = 1  # fine\ninstance.attr = \"wrong\"  # error: [invalid-assignment]\n\nC.attr = 1  # fine\nC.attr = \"wrong\"  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Callable Type Behavior Testing in Python\nDESCRIPTION: Tests callable type assignability rules with focus on return types and gradual typing behavior using static assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, Unknown, static_assert, is_assignable_to\nfrom typing import Any, Callable\n\nstatic_assert(is_assignable_to(Callable[[], Any], Callable[[], int]))\nstatic_assert(is_assignable_to(Callable[[], int], Callable[[], Any]))\n# Additional assertions...\n```\n\n----------------------------------------\n\nTITLE: Evaluating First Expression in Python Boolean Operations\nDESCRIPTION: This snippet demonstrates that the first expression in 'or' and 'and' operations is always evaluated, regardless of short-circuiting. It uses the walrus operator for assignment and reveal_type() for type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if (x := 1) or flag:\n        reveal_type(x)  # revealed: Literal[1]\n\n    if (x := 1) and flag:\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Fallback to Regular bool Type for Complex str.startswith Calls in Python\nDESCRIPTION: Shows how type checking falls back to a regular bool type when using str.startswith with additional parameters like start/end indices or with tuple arguments, where the result cannot be determined at compile time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/str_startswith.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(\"abc\".startswith(\"b\", 1))  # revealed: bool\nreveal_type(\"abc\".startswith(\"bc\", 1, 3))  # revealed: bool\n\nreveal_type(\"abc\".startswith((\"a\", \"x\")))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Lexicographic Tuple Comparisons in Python\nDESCRIPTION: Shows how lexicographic comparisons work for tuples when the comparison can be determined before reaching incomparable elements. The results are definitive boolean literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\na = (1, 2)\nb = (999999, \"hello\")\n\nreveal_type(a == b)  # revealed: Literal[False]\nreveal_type(a != b)  # revealed: Literal[True]\nreveal_type(a < b)  # revealed: Literal[True]\nreveal_type(a <= b)  # revealed: Literal[True]\nreveal_type(a > b)  # revealed: Literal[False]\nreveal_type(a >= b)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Testing Type Inference for Byte Literal Comparisons in Python\nDESCRIPTION: This code demonstrates how type inference works with byte literal comparisons. It uses reveal_type() to show that the Python type checker can infer precise Literal[True] or Literal[False] types for various comparison operations between byte literals, including equality, inequality, ordering, containment, and identity tests.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/byte_literals.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(b\"abc\" == b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"abc\" == b\"ab\")  # revealed: Literal[False]\n\nreveal_type(b\"abc\" != b\"abc\")  # revealed: Literal[False]\nreveal_type(b\"abc\" != b\"ab\")  # revealed: Literal[True]\n\nreveal_type(b\"abc\" < b\"abd\")  # revealed: Literal[True]\nreveal_type(b\"abc\" < b\"abb\")  # revealed: Literal[False]\n\nreveal_type(b\"abc\" <= b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"abc\" <= b\"abb\")  # revealed: Literal[False]\n\nreveal_type(b\"abc\" > b\"abd\")  # revealed: Literal[False]\nreveal_type(b\"abc\" > b\"abb\")  # revealed: Literal[True]\n\nreveal_type(b\"abc\" >= b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"abc\" >= b\"abd\")  # revealed: Literal[False]\n\nreveal_type(b\"\" in b\"\")  # revealed: Literal[True]\nreveal_type(b\"\" in b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"abc\" in b\"\")  # revealed: Literal[False]\nreveal_type(b\"ab\" in b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"abc\" in b\"abc\")  # revealed: Literal[True]\nreveal_type(b\"d\" in b\"abc\")  # revealed: Literal[False]\nreveal_type(b\"ac\" in b\"abc\")  # revealed: Literal[False]\nreveal_type(b\"\\x81\\x82\" in b\"\\x80\\x81\\x82\")  # revealed: Literal[True]\nreveal_type(b\"\\x82\\x83\" in b\"\\x80\\x81\\x82\")  # revealed: Literal[False]\n\nreveal_type(b\"ab\" not in b\"abc\")  # revealed: Literal[False]\nreveal_type(b\"ac\" not in b\"abc\")  # revealed: Literal[True]\n\nreveal_type(b\"abc\" is b\"abc\")  # revealed: bool\nreveal_type(b\"abc\" is b\"ab\")  # revealed: Literal[False]\n\nreveal_type(b\"abc\" is not b\"abc\")  # revealed: bool\nreveal_type(b\"abc\" is not b\"ab\")  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Basic Builtin Types in Python\nDESCRIPTION: This code demonstrates how disjointness relations work between basic built-in Python types. It shows examples of types that are disjoint (like bool and str) and types that are not disjoint (like bool and int, or Any with other types).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString, Any\nfrom knot_extensions import Intersection, Not, TypeOf, is_disjoint_from, static_assert\n\nstatic_assert(is_disjoint_from(bool, str))\nstatic_assert(not is_disjoint_from(bool, bool))\nstatic_assert(not is_disjoint_from(bool, int))\nstatic_assert(not is_disjoint_from(bool, object))\n\nstatic_assert(not is_disjoint_from(Any, bool))\nstatic_assert(not is_disjoint_from(Any, Any))\nstatic_assert(not is_disjoint_from(Any, Not[Any]))\n\nstatic_assert(not is_disjoint_from(LiteralString, LiteralString))\nstatic_assert(not is_disjoint_from(str, LiteralString))\nstatic_assert(not is_disjoint_from(str, type))\nstatic_assert(not is_disjoint_from(str, type[Any]))\n```\n\n----------------------------------------\n\nTITLE: Testing bool() Function with Invalid Arguments\nDESCRIPTION: Demonstrates incorrect usage of bool() function with too many arguments and invalid bool conversion.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NotBool:\n    __bool__ = None\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to class `bool`: expected 1, got 2\"\nbool(1, 2)\n\n# TODO: We should emit an `unsupported-bool-conversion` error here because the argument doesn't implement `__bool__` correctly.\nbool(NotBool())\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Finally Block with Reassignment\nDESCRIPTION: This snippet demonstrates type inference in a try-finally block where the variable is reassigned in the finally clause. It shows how the final type is determined by the assignment in the finally block, which is always executed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef could_raise_returns_str() -> str:\n    return \"foo\"\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nfinally:\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union of Dunder Methods in Python\nDESCRIPTION: This code snippet shows how a union of dunder methods is handled. It defines classes with conditional __getitem__ methods and demonstrates that the return type is correctly inferred as a union of the possible return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class C:\n        if flag:\n            def __getitem__(self, key: int) -> str:\n                return str(key)\n        else:\n            def __getitem__(self, key: int) -> bytes:\n                return bytes()\n\n    c = C()\n    reveal_type(c[0])  # revealed: str | bytes\n\n    if flag:\n        class D:\n            def __getitem__(self, key: int) -> str:\n                return str(key)\n\n    else:\n        class D:\n            def __getitem__(self, key: int) -> bytes:\n                return bytes()\n\n    d = D()\n    reveal_type(d[0])  # revealed: str | bytes\n```\n\n----------------------------------------\n\nTITLE: Handling Union Return Types from __getitem__ Methods in Python\nDESCRIPTION: Shows how conditional implementation of __getitem__ with different return types leads to a union type. The type checker correctly infers the return type as int | str.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/instance.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Identity:\n        if flag:\n            def __getitem__(self, index: int) -> int:\n                return index\n        else:\n            def __getitem__(self, index: int) -> str:\n                return str(index)\n\n    reveal_type(Identity()[0])  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Eager List Comprehension Resolution\nDESCRIPTION: Shows how list comprehensions evaluate variable references eagerly at definition time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    x = 1\n\n    # revealed: Literal[1]\n    [reveal_type(x) for a in range(1)]\n\n    x = 2\n```\n\n----------------------------------------\n\nTITLE: Importing Possibly Unbound Variables in Python\nDESCRIPTION: This snippet demonstrates importing possibly unbound variables from a module. It shows how type revealing works for imported variables that might be unbound.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# error: [possibly-unbound-import] \"Member `y` of module `maybe_unbound` is possibly unbound\"\nfrom maybe_unbound import x, y\n\nreveal_type(x)  # revealed: Unknown | Literal[3]\nreveal_type(y)  # revealed: Unknown | Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Possibly Unbound Variable with Ambiguous Condition in Python\nDESCRIPTION: Shows how variables defined in conditionally executed code paths are considered possibly unbound. Accessing 'x' results in a possibly-unresolved-reference error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_43\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nif flag():\n    x = 1\n\n# error: [possibly-unresolved-reference]\nx\n```\n\n----------------------------------------\n\nTITLE: Empty Tuple Type Inference in Python\nDESCRIPTION: Demonstrates type inference for an empty tuple using reveal_type(). Shows that empty tuples have the type annotation tuple[].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/collections/tuple.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(())  # revealed: tuple[()]\n```\n\n----------------------------------------\n\nTITLE: Singleton Pattern Matching in Python\nDESCRIPTION: This snippet demonstrates singleton pattern matching in Python. It shows how matching against True, False, and None works, and how it affects type inference in different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(target: Literal[True, False]):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    # TODO: with exhaustiveness checking, this should be Literal[2, 3]\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n\ndef _(target: bool):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    # TODO: with exhaustiveness checking, this should be Literal[2, 3]\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n\ndef _(target: None):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[4]\n\ndef _(target: None | Literal[True]):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    # TODO: with exhaustiveness checking, this should be Literal[2, 4]\n    reveal_type(y)  # revealed: Literal[1, 2, 4]\n\n# bool is an int subclass\ndef _(target: int):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n\ndef _(target: str):\n    y = 1\n\n    match target:\n        case True:\n            y = 2\n        case False:\n            y = 3\n        case None:\n            y = 4\n\n    reveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Testing EllipsisType as Singleton in Python 3.10+\nDESCRIPTION: Tests that types.EllipsisType is recognized as a singleton type in Python 3.10+, where the standard library directly exposes this type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\nimport types\nfrom knot_extensions import static_assert, is_singleton\n\nstatic_assert(is_singleton(types.EllipsisType))\n```\n\n----------------------------------------\n\nTITLE: Testing Diamond Inheritance MRO (Example 2)\nDESCRIPTION: Tests type inference for diamond-shaped inheritance pattern\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass O: ...\nclass X(O): ...\nclass Y(O): ...\nclass A(X, Y): ...\nclass B(Y, X): ...\n\nreveal_type(A.__mro__)  # revealed: tuple[Literal[A], Literal[X], Literal[Y], Literal[O], Literal[object]]\nreveal_type(B.__mro__)  # revealed: tuple[Literal[B], Literal[Y], Literal[X], Literal[O], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with possibly unbound callable as __init__ method in Python\nDESCRIPTION: Shows the behavior and type checking for a class with a possibly unbound callable as the __init__ method, including error handling for different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    class Callable:\n        if flag:\n            def __call__(self, x: int) -> None:\n                pass\n\n    class Foo:\n        __init__ = Callable()\n\n    # error: [call-non-callable] \"Object of type `Callable` is not callable (possibly unbound `__call__` method)\"\n    reveal_type(Foo(1))  # revealed: Foo\n    # TODO should be - error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\n    # but we currently infer the signature of `__call__` as unknown, so it accepts any arguments\n    # error: [call-non-callable] \"Object of type `Callable` is not callable (possibly unbound `__call__` method)\"\n    reveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Evaluating Truthy Values with bool() Function in Python\nDESCRIPTION: This snippet shows how the bool() function evaluates various truthy values in Python. It demonstrates that these values are inferred as Literal[True].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(bool(1))  # revealed: Literal[True]\nreveal_type(bool((0,)))  # revealed: Literal[True]\nreveal_type(bool(\"NON EMPTY\"))  # revealed: Literal[True]\nreveal_type(bool(True))  # revealed: Literal[True]\n\ndef foo(): ...\n\nreveal_type(bool(foo))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Intersection Operations with Bounded TypeVars in Python\nDESCRIPTION: Shows how intersections with bounded typevars simplify in different scenarios. Intersections with bound or supertypes simplify to the typevar, while intersections with disjoint types simplify to Never.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef bounded[T: Base](t: T) -> None:\n    def _(x: Intersection[T, Super]) -> None:\n        reveal_type(x)  # revealed: T\n\n    def _(x: Intersection[T, Base]) -> None:\n        reveal_type(x)  # revealed: T\n\n    def _(x: Intersection[T, Sub]) -> None:\n        reveal_type(x)  # revealed: T & Sub\n\n    def _(x: Intersection[T, None]) -> None:\n        reveal_type(x)  # revealed: Never\n\n    def _(x: Intersection[T, Any]) -> None:\n        reveal_type(x)  # revealed: T & Any\n```\n\n----------------------------------------\n\nTITLE: Using Python 3.11's Native LiteralString\nDESCRIPTION: Demonstrates using the native typing.LiteralString available in Python 3.11+, specified through environment configuration in TOML.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\n----------------------------------------\n\nTITLE: Common Operations with LiteralString in Python\nDESCRIPTION: Demonstrates common string operations with LiteralString, including concatenation, joining, and formatting, along with their inferred types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\nfoo: LiteralString = \"foo\"\nreveal_type(foo)  # revealed: Literal[\"foo\"]\n\nbar: LiteralString = \"bar\"\nreveal_type(foo + bar)  # revealed: Literal[\"foobar\"]\n\nbaz: LiteralString = \"baz\"\nbaz += foo\nreveal_type(baz)  # revealed: Literal[\"bazfoo\"]\n\nqux = (foo, bar)\nreveal_type(qux)  # revealed: tuple[Literal[\"foo\"], Literal[\"bar\"]]\n\n# TODO: Infer \"LiteralString\"\nreveal_type(foo.join(qux))  # revealed: @Todo(return type of overloaded function)\n\ntemplate: LiteralString = \"{}, {}\"\nreveal_type(template)  # revealed: Literal[\"{}, {}\"]\n# TODO: Infer `LiteralString`\nreveal_type(template.format(foo, bar))  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Edge Case: Nested Classes and Attribute Access\nDESCRIPTION: Shows how attribute access works with nested class hierarchies, with proper scoping of instance attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nclass Outer:\n    def __init__(self):\n        self.x: int = 1\n\n    class Middle:\n        # has no 'x' attribute\n\n        class Inner:\n            def __init__(self):\n                self.x: str = \"a\"\n\nreveal_type(Outer().x)  # revealed: int\n\n# error: [unresolved-attribute]\nOuter.Middle().x\n\nreveal_type(Outer.Middle.Inner().x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Protocol Method Definitions with Return Types\nDESCRIPTION: Examples of Protocol class implementations with return type annotations and generic type variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol, TypeVar\n\nclass Bar(Protocol):\n    def f(self) -> int: ...\n\nclass Baz(Bar):\n    # error: [invalid-return-type]\n    def f(self) -> int: ...\n\nT = TypeVar(\"T\")\n\nclass Qux(Protocol[T]):\n    # TODO: no error\n    # error: [invalid-return-type]\n    def f(self) -> int: ...\n\nclass Foo(Protocol):\n    def f[T](self, v: T) -> T: ...\n\nt = (Protocol, int)\nreveal_type(t[0])  # revealed: typing.Protocol\n\nclass Lorem(t[0]):\n    def f(self) -> int: ...\n```\n\n----------------------------------------\n\nTITLE: Class Union Operation Prior to Python 3.10\nDESCRIPTION: Shows the error that occurs when attempting to use the | operator for class unions in Python versions before 3.10.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/classes.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\n# error: \"Operator `|` is unsupported between objects of type `Literal[A]` and `Literal[B]`\"\nreveal_type(A | B)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Parentheses in Call-Chain Assignment: Ruff vs Black\nDESCRIPTION: This snippet highlights how Ruff removes parentheses around call-chain assignment values, while Black preserves them. Both formatters remove such parentheses in simpler assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef update_emission_strength():\n    (\n        get_rgbw_emission_node_tree(self)\n        .nodes[\"Emission\"]\n        .inputs[\"Strength\"]\n        .default_value\n    ) = (self.emission_strength * 2)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Input\ndef update_emission_strength():\n    value = (self.emission_strength * 2)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\ndef update_emission_strength():\n    value = self.emission_strength * 2\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\ndef update_emission_strength():\n    value = self.emission_strength * 2\n```\n\n----------------------------------------\n\nTITLE: Power Operation Type Checking in Python\nDESCRIPTION: Shows type inference for power operations (**) with different combinations of literals and variables. Demonstrates when Literal types are used versus general int types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/integers.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlargest_u32 = 4_294_967_295\nreveal_type(2**2)  # revealed: Literal[4]\nreveal_type(1 ** (largest_u32 + 1))  # revealed: int\nreveal_type(2**largest_u32)  # revealed: int\n\ndef variable(x: int):\n    reveal_type(x**2)  # revealed: @Todo(return type of overloaded function)\n    reveal_type(2**x)  # revealed: @Todo(return type of overloaded function)\n    reveal_type(x**x)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: While-Else Loop (No Break) Type Checking in Python\nDESCRIPTION: Shows type inference in while-else construct without break statements, demonstrating how the else clause affects variable types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1\n    while flag:\n        x = 2\n    else:\n        reveal_type(x)  # revealed: Literal[1, 2]\n        x = 3\n\n    reveal_type(x)  # revealed: Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Defining Lists with Boolean Literals (Ruff)\nDESCRIPTION: These snippets demonstrate how Ruff formats lists containing boolean literals.  Ruff preserves the single set of parentheses around the `True` value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nitems = [(True)]\nitems = [(True)]\n```\n\n----------------------------------------\n\nTITLE: Importing Re-exported Symbols from Stub Files in Python\nDESCRIPTION: This snippet demonstrates successful imports of re-exported symbols from a stub file. It shows that both Any and Literal from typing, and foo from a module can be imported without errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom b import Any, Literal, foo\n\nreveal_type(Any)  # revealed: typing.Any\nreveal_type(Literal)  # revealed: typing.Literal\nreveal_type(foo)  # revealed: <module 'foo'>\n```\n\n----------------------------------------\n\nTITLE: Non-Boolean Return Types in __contains__ for Python Membership Tests\nDESCRIPTION: Shows how Python coerces non-boolean return values from __contains__ to boolean values when evaluating membership tests with 'in' and 'not in' operators.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __contains__(self, item: str) -> str:\n        return \"foo\"\n\nreveal_type(\"hello\" in A())  # revealed: bool\nreveal_type(\"hello\" not in A())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Wildcard Pattern Matching in Python\nDESCRIPTION: This snippet shows how wildcard pattern matching works in Python. It uses a match statement with a wildcard case, which affects the type inference of the variable 'y'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(target: int):\n    match target:\n        case 1:\n            y = 2\n        case _:\n            y = 3\n\n    reveal_type(y)  # revealed: Literal[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Working with Module Attributes in Python\nDESCRIPTION: Demonstrates accessing and modifying module attributes with type validation, showing various assignment scenarios including errors for type mismatches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nimport mod\n\nreveal_type(mod.global_symbol)  # revealed: str\nmod.global_symbol = \"b\"\n\n# error: [invalid-assignment] \"Object of type `Literal[1]` is not assignable to attribute `global_symbol` of type `str`\"\nmod.global_symbol = 1\n\n# error: [invalid-assignment] \"Object of type `Literal[1]` is not assignable to attribute `global_symbol` of type `str`\"\n(_, mod.global_symbol) = (..., 1)\n\n# TODO: this should be an error, but we do not understand list unpackings yet.\n[_, mod.global_symbol] = [1, 2]\n\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\n# error: [invalid-assignment] \"Object of type `int` is not assignable to attribute `global_symbol` of type `str`\"\nfor mod.global_symbol in IntIterable():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Testing Callable Compatibility with Unannotated Parameters\nDESCRIPTION: Demonstrates that functions with unannotated parameters of different kinds are still compatible with the gradual Callable type. This shows how type compatibility works even when parameter types are not explicitly annotated.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef positional_only(a, b, /) -> None: ...\ndef positional_or_keyword(a, b) -> None: ...\ndef variadic(*args) -> None: ...\ndef keyword_only(*, a, b) -> None: ...\ndef keyword_variadic(**kwargs) -> None: ...\ndef mixed(a, /, b, *args, c, **kwargs) -> None: ...\n\nstatic_assert(is_assignable_to(CallableTypeOf[positional_only], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[positional_or_keyword], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[variadic], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[keyword_only], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[keyword_variadic], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[mixed], Callable[..., None]))\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespace Package with Multiple Search Paths in TOML\nDESCRIPTION: Sets up the environment for a namespace package with stubs spread across multiple search paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/stubs1\", \"/stubs2\", \"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Membership Test Comparisons with Tuples\nDESCRIPTION: Shows type checking behavior for 'in' and 'not in' operators with tuples, including cases with literal values and variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef _(n: int):\n    a = (1, 2)\n    b = ((3, 4), (1, 2))\n    c = ((1, 2, 3), (4, 5, 6))\n    d = ((n, n), (n, n))\n\n    reveal_type(a in b)  # revealed: Literal[True]\n    reveal_type(a not in b)  # revealed: Literal[False]\n\n    reveal_type(a in c)  # revealed: Literal[False]\n    reveal_type(a not in c)  # revealed: Literal[True]\n\n    reveal_type(a in d)  # revealed: bool\n    reveal_type(a not in d)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in nested `else` branch in Python\nDESCRIPTION: This function demonstrates a nested `if` statement where the exception is raised in the inner `else` branch.  It shows how the type of variable `x` can be affected by different execution paths and exception handling using `reveal_type`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_nested_else_branch(cond1: bool, cond2: bool):\n    x = \"before\"\n    try:\n        if cond1:\n            x = \"else1\"\n            reveal_type(x)  # revealed: Literal[\"else1\"]\n        else:\n            if cond2:\n                x = \"else2\"\n                reveal_type(x)  # revealed: Literal[\"else2\"]\n            else:\n                x = \"raise\"\n                reveal_type(x)  # revealed: Literal[\"raise\"]\n                raise ValueError\n            reveal_type(x)  # revealed: Literal[\"else2\"]\n        reveal_type(x)  # revealed: Literal[\"else1\", \"else2\"]\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"else2\", \"raise\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"else2\", \"raise\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"else1\", \"else2\"]\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"else2\", \"raise\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"else1\", \"else2\", \"raise\"]\n```\n\n----------------------------------------\n\nTITLE: Callable Type Truthiness Checking\nDESCRIPTION: Demonstrates truthiness type checking for callable types and specific callable instances. Shows how different callable types are handled by the type system.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/truthiness.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef f(x: Callable, y: Callable[[int], str]):\n    reveal_type(bool(x))  # revealed: bool\n    reveal_type(bool(y))  # revealed: bool\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom types import FunctionType\n\nclass A:\n    def method(self): ...\n\nreveal_type(bool(A().method))  # revealed: Literal[True]\nreveal_type(bool(f.__get__))  # revealed: Literal[True]\nreveal_type(bool(FunctionType.__get__))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Implementing __len__ with Enums in Python\nDESCRIPTION: This snippet shows custom class implementations of `__len__` that return Enum values. It demonstrates how `len()` handles these Enum values when calculating length.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum, auto\nfrom typing import Literal\n\nclass SomeEnum(Enum):\n    AUTO = auto()\n    INT = 2\n    STR = \"4\"\n    TUPLE = (8, \"16\")\n    INT_2 = 3_2\n\nclass Auto:\n    def __len__(self) -> Literal[SomeEnum.AUTO]:\n        return SomeEnum.AUTO\n\nclass Int:\n    def __len__(self) -> Literal[SomeEnum.INT]:\n        return SomeEnum.INT\n\nclass Str:\n    def __len__(self) -> Literal[SomeEnum.STR]:\n        return SomeEnum.STR\n\nclass Tuple:\n    def __len__(self) -> Literal[SomeEnum.TUPLE]:\n        return SomeEnum.TUPLE\n\nclass IntUnion:\n    def __len__(self) -> Literal[SomeEnum.INT, SomeEnum.INT_2]:\n        return SomeEnum.INT\n\nreveal_type(len(Auto()))  # revealed: int\nreveal_type(len(Int()))  # revealed: int\nreveal_type(len(Str()))  # revealed: int\nreveal_type(len(Tuple()))  # revealed: int\nreveal_type(len(IntUnion()))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Three Argument type() Function Calls\nDESCRIPTION: Demonstrates creating dynamic instances of the type class using three arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Base: ...\n\nreveal_type(type(\"Foo\", (), {}))  # revealed: type\n\nreveal_type(type(\"Foo\", (Base,), {\"attr\": 1}))  # revealed: type\n```\n\n----------------------------------------\n\nTITLE: Invalid List Comprehension Syntax Examples in Python\nDESCRIPTION: Demonstrates four different cases of invalid list comprehension syntax: missing 'in' keyword, missing iteration variable, missing iterable, and missing both 'in' keyword and iterable. Includes type inference results and expected error messages.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/invalid_syntax.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\n# Missing 'in' keyword.\n\n# It's reasonably clear here what they *meant* to write,\n# so we'll still infer the correct type:\n\n# error: [invalid-syntax] \"Expected 'in', found name\"\n# revealed: int\n[reveal_type(a) for a IntIterable()]\n\n\n# Missing iteration variable\n\n# error: [invalid-syntax] \"Expected an identifier, but found a keyword 'in' that cannot be used here\"\n# error: [invalid-syntax] \"Expected 'in', found name\"\n# error: [unresolved-reference]\n# revealed: Unknown\n[reveal_type(b) for in IntIterable()]\n\n\n# Missing iterable\n\n# error: [invalid-syntax] \"Expected an expression\"\n# revealed: Unknown\n[reveal_type(c) for c in]\n\n\n# Missing 'in' keyword and missing iterable\n\n# error: [invalid-syntax] \"Expected 'in', found ']'\"\n# revealed: Unknown\n[reveal_type(d) for d]\n```\n\n----------------------------------------\n\nTITLE: Managing Possibly Non-callable __call__ Attribute in Python\nDESCRIPTION: This snippet demonstrates a scenario where the __call__ attribute might be either a callable method or a non-callable value, depending on a condition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class NonCallable:\n        if flag:\n            __call__ = 1\n        else:\n            def __call__(self) -> int:\n                return 1\n\n    a = NonCallable()\n    # error: [call-non-callable] \"Object of type `Literal[1]` is not callable\"\n    reveal_type(a())  # revealed: Unknown | int\n```\n\n----------------------------------------\n\nTITLE: If Expression with Walrus Operator Type Revelation\nDESCRIPTION: Shows if-expression using walrus operator (:=) for assignment within conditions, revealing types for multiple variables affected by the conditional logic.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_expression.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    y = 0\n    z = 0\n    x = (y := 1) if flag else (z := 2)\n    reveal_type(x)  # revealed: Literal[1, 2]\n    reveal_type(y)  # revealed: Literal[0, 1]\n    reveal_type(z)  # revealed: Literal[0, 2]\n```\n\n----------------------------------------\n\nTITLE: Basic Type Narrowing with issubclass\nDESCRIPTION: Demonstrates basic type narrowing behavior using issubclass with conditional type assignment between int and str types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/issubclass.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    t = int if flag else str\n\n    if issubclass(t, bytes):\n        reveal_type(t)  # revealed: Never\n\n    if issubclass(t, object):\n        reveal_type(t)  # revealed: Literal[int, str]\n\n    if issubclass(t, int):\n        reveal_type(t)  # revealed: Literal[int]\n    else:\n        reveal_type(t)  # revealed: Literal[str]\n\n    if issubclass(t, str):\n        reveal_type(t)  # revealed: Literal[str]\n        if issubclass(t, int):\n            reveal_type(t)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Return Value Type Check Suppression\nDESCRIPTION: Demonstrates @no_type_check behavior with undefined return type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test() -> Undefined:\n    return x + 5\n```\n\n----------------------------------------\n\nTITLE: Illustrating Class Typevar Usage in Methods in Python\nDESCRIPTION: This example demonstrates how typevars used in methods of a generic class are bound to the class's type parameter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    def m1(self, x: T) -> T:\n        return x\n\n    def m2(self, x: T) -> T:\n        return x\n\nc: C[int] = C[int]()\nc.m1(1)\nc.m2(1)\n# error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\\\"string\\\"]\"`\nc.m2(\"string\")\n```\n\n----------------------------------------\n\nTITLE: Illustrating Class Scope Limitations for Typevars in Python\nDESCRIPTION: This example demonstrates that class typevars are only available in the class's scope and not in nested scopes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    ok1: list[T] = []\n\n    class Bad:\n        # TODO: error\n        bad: list[T] = []\n\n    class Inner[S]: ...\n    ok2: Inner[T]\n```\n\n----------------------------------------\n\nTITLE: Inferring Literal Boolean Types with str.startswith for String Literals in Python\nDESCRIPTION: Demonstrates how type checking can infer exact Literal[True] or Literal[False] values for simple string.startswith() calls when both the string and prefix are string literals. This is especially useful for sys.platform checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/str_startswith.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(\"abc\".startswith(\"\"))  # revealed: Literal[True]\nreveal_type(\"abc\".startswith(\"a\"))  # revealed: Literal[True]\nreveal_type(\"abc\".startswith(\"ab\"))  # revealed: Literal[True]\nreveal_type(\"abc\".startswith(\"abc\"))  # revealed: Literal[True]\n\nreveal_type(\"abc\".startswith(\"abcd\"))  # revealed: Literal[False]\nreveal_type(\"abc\".startswith(\"bc\"))  # revealed: Literal[False]\n\nreveal_type(\"AbC\".startswith(\"\"))  # revealed: Literal[True]\nreveal_type(\"AbC\".startswith(\"A\"))  # revealed: Literal[True]\nreveal_type(\"AbC\".startswith(\"Ab\"))  # revealed: Literal[True]\nreveal_type(\"AbC\".startswith(\"AbC\"))  # revealed: Literal[True]\n\nreveal_type(\"AbC\".startswith(\"a\"))  # revealed: Literal[False]\nreveal_type(\"AbC\".startswith(\"aB\"))  # revealed: Literal[False]\n\nreveal_type(\"\".startswith(\"\"))  # revealed: Literal[True]\n\nreveal_type(\"\".startswith(\" \"))  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Complex Number Type Inference\nDESCRIPTION: Shows type inference for complex number literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(2j)  # revealed: complex\n```\n\n----------------------------------------\n\nTITLE: Binary Operations Returning Different Types in Python\nDESCRIPTION: Demonstrates that magic methods for binary operations are not required to return the same type as self. Shows type inference for these cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> int:\n        return 1\n\n    def __rsub__(self, other) -> int:\n        return 1\n\nclass B: ...\n\nreveal_type(A() + B())  # revealed: int\nreveal_type(B() - A())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Sequence Type to Bypass Zero Step Size Error in Python\nDESCRIPTION: This snippet demonstrates how to create a custom sequence class that accepts a zero step size in slicing operations without triggering the 'zero-stepsize-in-slice' diagnostic in Ruff. The class implements the __getitem__ method to handle slice objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/stepsize_zero.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MySequence:\n    def __getitem__(self, s: slice) -> int:\n        return 0\n\nMySequence()[0:1:0]  # No error\n```\n\n----------------------------------------\n\nTITLE: Value Literals Type Narrowing\nDESCRIPTION: Demonstrates type narrowing behavior for literal values in boolean contexts using if statements and logical operators. Shows how types are narrowed for integers, strings, bytes, and None values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef foo() -> Literal[0, -1, True, False, \"\", \"foo\", b\"\", b\"bar\", None] | tuple[()]:\n    return 0\n\nx = foo()\n\nif x:\n    reveal_type(x)  # revealed: Literal[-1, True, \"foo\", b\"bar\"]\nelse:\n    reveal_type(x)  # revealed: Literal[0, False, \"\", b\"\"] | None | tuple[()]\n```\n\n----------------------------------------\n\nTITLE: Same Type Reflected Dunder Behavior\nDESCRIPTION: Shows that reflected dunder methods are not tried between objects of the same type, following Python's operator method resolution order.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __radd__(self, other: \"Foo\") -> \"Foo\":\n        return self\n\n# error: [unsupported-operator]\n# revealed: Unknown\nreveal_type(Foo() + Foo())\n```\n\n----------------------------------------\n\nTITLE: Basic assert_never Usage in Python\nDESCRIPTION: Demonstrates basic functionality of assert_never with various input types. Shows how assert_never validates that arguments are of type Never and raises type-assertion-failure for non-Never types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_never.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_never, Never, Any\nfrom knot_extensions import Unknown\n\ndef _(never: Never, any_: Any, unknown: Unknown, flag: bool):\n    assert_never(never)  # fine\n\n    assert_never(0)  # error: [type-assertion-failure]\n    assert_never(\"\")  # error: [type-assertion-failure]\n    assert_never(None)  # error: [type-assertion-failure]\n    assert_never([])  # error: [type-assertion-failure]\n    assert_never({})  # error: [type-assertion-failure]\n    assert_never(())  # error: [type-assertion-failure]\n    assert_never(1 if flag else never)  # error: [type-assertion-failure]\n\n    assert_never(any_)  # error: [type-assertion-failure]\n    assert_never(unknown)  # error: [type-assertion-failure]\n```\n\n----------------------------------------\n\nTITLE: Formatting F-Strings in Python\nDESCRIPTION: Illustrates how Ruff formats expression parts within f-strings while Black preserves the original formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Input\nf'test{inner   + \"nested_string\"} including math {5 ** 3 + 10}'\n\n# Black\nf'test{inner   + \"nested_string\"} including math {5 ** 3 + 10}'\n\n# Ruff\nf\"test{inner + 'nested_string'} including math {5**3 + 10}\"\n```\n\n----------------------------------------\n\nTITLE: Testing Callable Compatibility with Various Parameter Kinds\nDESCRIPTION: Shows how different function parameter types (positional-only, keyword-only, variadic, etc.) are all compatible with a gradual Callable type. This demonstrates the flexibility of the gradual typing notation with different parameter specifications.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef positional_only(a: int, b: int, /) -> None: ...\ndef positional_or_keyword(a: int, b: int) -> None: ...\ndef variadic(*args: int) -> None: ...\ndef keyword_only(*, a: int, b: int) -> None: ...\ndef keyword_variadic(**kwargs: int) -> None: ...\ndef mixed(a: int, /, b: int, *args: int, c: int, **kwargs: int) -> None: ...\n\nstatic_assert(is_assignable_to(CallableTypeOf[positional_only], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[positional_or_keyword], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[variadic], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[keyword_only], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[keyword_variadic], Callable[..., None]))\nstatic_assert(is_assignable_to(CallableTypeOf[mixed], Callable[..., None]))\n```\n\n----------------------------------------\n\nTITLE: Nested Type Aliases\nDESCRIPTION: Shows how type aliases can be used within other type alias definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntype IntOrStr = int | str\ntype IntOrStrOrBytes = IntOrStr | bytes\n\nx: IntOrStrOrBytes = 1\n\ndef f() -> None:\n    reveal_type(x)  # revealed: int | str | bytes\n```\n\n----------------------------------------\n\nTITLE: Tuple Type isinstance() Check\nDESCRIPTION: Shows type narrowing with tuple of types in isinstance() checks. Demonstrates how multiple type options are handled in type narrowing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag1: bool, flag2: bool):\n    x = 1 if flag else \"a\"\n\n    if isinstance(x, (int, str)):\n        reveal_type(x)  # revealed: Literal[1, \"a\"]\n    else:\n        reveal_type(x)  # revealed: Never\n\n    if isinstance(x, (int, bytes)):\n        reveal_type(x)  # revealed: Literal[1]\n\n    if isinstance(x, (bytes, str)):\n        reveal_type(x)  # revealed: Literal[\"a\"]\n\n    if isinstance(x, (int, object)):\n        reveal_type(x)  # revealed: Literal[1, \"a\"]\n    else:\n        reveal_type(x)  # revealed: Never\n\n    y = 1 if flag1 else \"a\" if flag2 else b\"b\"\n    if isinstance(y, (int, str)):\n        reveal_type(y)  # revealed: Literal[1, \"a\"]\n\n    if isinstance(y, (int, bytes)):\n        reveal_type(y)  # revealed: Literal[1, b\"b\"]\n\n    if isinstance(y, (str, bytes)):\n        reveal_type(y)  # revealed: Literal[\"a\", b\"b\"]\n```\n\n----------------------------------------\n\nTITLE: Negated Integer Type Inference\nDESCRIPTION: Shows type inference for negative integers and double-negated integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nx = -1\ny = -1234567890987654321\nz = --987\nreveal_type(x)  # revealed: Literal[-1]\nreveal_type(y)  # revealed: Literal[-1234567890987654321]\nreveal_type(z)  # revealed: Literal[987]\n```\n\n----------------------------------------\n\nTITLE: Union of Literal Types in Python\nDESCRIPTION: Shows how multiple Literal values are treated as unions and how nested Literals are flattened. Demonstrates type revelation for various combinations of Literal unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef x(\n    a1: Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None],\n    a2: Literal[\"w\"] | Literal[\"r\"],\n    a3: Literal[Literal[\"w\"], Literal[\"r\"], Literal[Literal[\"w+\"]]],\n    a4: Literal[True] | Literal[1, 2] | Literal[\"foo\"],\n):\n    reveal_type(a1)  # revealed: Literal[1, 2, 3, 5, \"foo\"] | None\n    reveal_type(a2)  # revealed: Literal[\"w\", \"r\"]\n    reveal_type(a3)  # revealed: Literal[\"w\", \"r\", \"w+\"]\n    reveal_type(a4)  # revealed: Literal[True, 1, 2, \"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Terminal Statements in Basic Conditional Blocks\nDESCRIPTION: Demonstrates how `raise` as a terminal statement affects variable binding analysis. In function `f`, the variable `x` is only bound in one branch, but since the other branch ends with a terminal statement, the reference is considered resolved.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f(cond: bool) -> str:\n    if cond:\n        x = \"test\"\n    else:\n        raise ValueError\n    return x\n\ndef g(cond: bool):\n    if cond:\n        x = \"test\"\n        reveal_type(x)  # revealed: Literal[\"test\"]\n    else:\n        x = \"terminal\"\n        reveal_type(x)  # revealed: Literal[\"terminal\"]\n        raise ValueError\n    reveal_type(x)  # revealed: Literal[\"test\"]\n```\n\n----------------------------------------\n\nTITLE: Insufficient Values in Python Unpacking\nDESCRIPTION: Illustrates the error that occurs when attempting to unpack a tuple with fewer values than target variables. The tuple contains only one value but two variables are specified for unpacking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unpacking.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na, b = (1,)  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Basic List and Dictionary Comprehensions in Python\nDESCRIPTION: Demonstrates basic list and dictionary comprehensions using custom IntIterable and IterableOfIterables classes. Shows type revelation for single and nested iterations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\n# revealed: int\n[reveal_type(x) for x in IntIterable()]\n\nclass IteratorOfIterables:\n    def __next__(self) -> IntIterable:\n        return IntIterable()\n\nclass IterableOfIterables:\n    def __iter__(self) -> IteratorOfIterables:\n        return IteratorOfIterables()\n\n# revealed: tuple[int, IntIterable]\n[reveal_type((x, y)) for y in IterableOfIterables() for x in y]\n\n# revealed: int\n{reveal_type(x): 0 for x in IntIterable()}\n\n# revealed: int\n{0: reveal_type(x) for x in IntIterable()}\n```\n\n----------------------------------------\n\nTITLE: Resolving Basic Star Imports in Python\nDESCRIPTION: Example showing how star imports fail when the imported module doesn't properly define what should be exported. The AttributeError occurs at runtime when the imported module doesn't have the expected attribute.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *  # fails with `AttributeError: module 'foo' has no attribute 'b'` at runtime\n```\n\n----------------------------------------\n\nTITLE: Casting with Special Types in Python: `Any`, `Unknown`, and `Todo`\nDESCRIPTION: This snippet illustrates how `cast` behaves with special types like `Any`, `Unknown`, and `Todo`. It shows that casting from `Unknown` to `Any` is not considered redundant, while casting between equivalent union types including `Any` is flagged as redundant.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/cast.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown\n\ndef f(x: Any, y: Unknown, z: Any | str | int):\n    a = cast(dict[str, Any], x)\n    reveal_type(a)  # revealed: @Todo(generics)\n\n    b = cast(Any, y)\n    reveal_type(b)  # revealed: Any\n\n    c = cast(str | int | Any, z)  # error: [redundant-cast]\n```\n\n----------------------------------------\n\nTITLE: Wildcard Import with Override Behavior\nDESCRIPTION: Shows how wildcard imports can override existing definitions in the importing module's namespace\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n```\n\nLANGUAGE: python\nCODE:\n```\nX = 42\nreveal_type(X)  # revealed: Literal[42]\n\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Attempting to Import Non-exported Symbols from Stub Files in Python\nDESCRIPTION: This snippet shows that attempting to import symbols that are not re-exported in the stub file results in unresolved import errors. The imported symbols are revealed as Unknown.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: 15 [unresolved-import] \"Module `b` has no member `foo`\"\n# error: 20 [unresolved-import] \"Module `b` has no member `Any`\"\n# error: 25 [unresolved-import] \"Module `b` has no member `Literal`\"\nfrom b import foo, Any, Literal\n\nreveal_type(Any)  # revealed: Unknown\nreveal_type(Literal)  # revealed: Unknown\nreveal_type(foo)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Basic Final Type Usage in Python\nDESCRIPTION: Demonstrates basic usage of typing.Final with different annotation patterns and type revealing. Shows both declaration and attempted reassignment scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final, Annotated\n\nFINAL_A: int = 1\nFINAL_B: Annotated[Final[int], \"the annotation for FINAL_B\"] = 1\nFINAL_C: Final[Annotated[int, \"the annotation for FINAL_C\"]] = 1\nFINAL_D: Final = 1\nFINAL_E: \"Final[int]\" = 1\n\nreveal_type(FINAL_A)  # revealed: Literal[1]\nreveal_type(FINAL_B)  # revealed: Literal[1]\nreveal_type(FINAL_C)  # revealed: Literal[1]\nreveal_type(FINAL_D)  # revealed: Literal[1]\nreveal_type(FINAL_E)  # revealed: Literal[1]\n\n# TODO: All of these should be errors:\nFINAL_A = 2\nFINAL_B = 2\nFINAL_C = 2\nFINAL_D = 2\nFINAL_E = 2\n```\n\n----------------------------------------\n\nTITLE: Analyzing Negative Contributions to Intersection Types with Literal Strings in Python\nDESCRIPTION: This snippet explores negative contributions to intersection types, focusing on equality comparisons with literal strings. It demonstrates type narrowing and expected type revelations for various comparison operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = \"x\" * 1_000_000_000\ny = \"y\" * 1_000_000_000\nreveal_type(x)  # revealed: LiteralString\n\nif x != \"abc\":\n    reveal_type(x)  # revealed: LiteralString & ~Literal[\"abc\"]\n\n    # TODO: This should be `Literal[False]`\n    reveal_type(x == \"abc\")  # revealed: bool\n    # TODO: This should be `Literal[False]`\n    reveal_type(\"abc\" == x)  # revealed: bool\n    reveal_type(x == \"something else\")  # revealed: bool\n    reveal_type(\"something else\" == x)  # revealed: bool\n\n    # TODO: This should be `Literal[True]`\n    reveal_type(x != \"abc\")  # revealed: bool\n    # TODO: This should be `Literal[True]`\n    reveal_type(\"abc\" != x)  # revealed: bool\n    reveal_type(x != \"something else\")  # revealed: bool\n    reveal_type(\"something else\" != x)  # revealed: bool\n\n    reveal_type(x == y)  # revealed: bool\n    reveal_type(y == x)  # revealed: bool\n    reveal_type(x != y)  # revealed: bool\n    reveal_type(y != x)  # revealed: bool\n\n    reveal_type(x >= \"abc\")  # revealed: bool\n    reveal_type(\"abc\" >= x)  # revealed: bool\n\n    reveal_type(x in \"abc\")  # revealed: bool\n    reveal_type(\"abc\" in x)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Supported Binary Operations on Literal Union Types\nDESCRIPTION: Demonstrates successful binary operations on union types when the operation is supported for all possible type combinations. The result is a union of all possible outcomes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/unions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef f3(two_or_three: Literal[2, 3], a_or_b: Literal[\"a\", \"b\"]):\n    reveal_type(two_or_three + two_or_three)  # revealed: Literal[4, 5, 6]\n    reveal_type(two_or_three**two_or_three)  # revealed: Literal[4, 8, 9, 27]\n\n    reveal_type(a_or_b + a_or_b)  # revealed: Literal[\"aa\", \"ab\", \"ba\", \"bb\"]\n\n    reveal_type(two_or_three * a_or_b)  # revealed: Literal[\"aa\", \"bb\", \"aaa\", \"bbb\"]\n```\n\n----------------------------------------\n\nTITLE: Understanding Attribute Expressions in Python Type Annotations\nDESCRIPTION: This snippet shows how attribute expressions are handled in type annotations, including cases where built-in types are shadowed by local variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport builtins\n\nint = \"foo\"\na: builtins.int = 42\n\n# error: [invalid-assignment] \"Object of type `Literal[\"bar\"]` is not assignable to `int`\"\nb: builtins.int = \"bar\"\n\nc: builtins.tuple[builtins.tuple[builtins.int, builtins.int], builtins.int] = ((42, 42), 42)\n\n# error: [invalid-assignment] \"Object of type `Literal[\"foo\"]` is not assignable to `tuple[tuple[int, int], int]`\"\nc: builtins.tuple[builtins.tuple[builtins.int, builtins.int], builtins.int] = \"foo\"\n```\n\n----------------------------------------\n\nTITLE: Missing Arguments Errors in Python Function Calls\nDESCRIPTION: Demonstrates various scenarios of missing required arguments in function calls.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    return 1\n\n# error: 13 [missing-argument] \"No argument provided for required parameter `x` of function `f`\"\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int, y: str = \"foo\") -> int:\n    return 1\n\n# error: 13 [missing-argument] \"No argument provided for required parameter `x` of function `f`\"\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int = 1) -> int:\n    return 1\n\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int, *y: str) -> int:\n    return 1\n\n# error: 13 [missing-argument] \"No argument provided for required parameter `x` of function `f`\"\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(*args: int) -> int:\n    return 1\n\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(**kwargs: int) -> int:\n    return 1\n\nreveal_type(f())  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int, y: int) -> int:\n    return 1\n\n# error: 13 [missing-argument] \"No arguments provided for required parameters `x`, `y` of function `f`\"\nreveal_type(f())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Implementing Not-boolable Union in Python\nDESCRIPTION: This snippet demonstrates a class with a __bool__ attribute that can be either None or an integer. It shows how the type system handles boolean conversion for such objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef test(cond: bool):\n    class NotBoolable:\n        __bool__: int | None = None if cond else 3\n\n    # error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\n    if NotBoolable():\n        ...\n```\n\n----------------------------------------\n\nTITLE: Class Attribute Precedence Over __getattr__\nDESCRIPTION: Demonstrates that defined class attributes take precedence over the __getattr__ method in type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(c.class_attr)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Normal and Descriptor Attributes in Python\nDESCRIPTION: This snippet defines two classes: Descriptor with a __get__ method, and C with a normal integer attribute and a descriptor attribute. It demonstrates the setup for comparing regular attribute access with inspect.getattr_static.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nclass Descriptor:\n    def __get__(self, instance, owner) -> str:\n        return \"a\"\n\nclass C:\n    normal: int = 1\n    descriptor: Descriptor = Descriptor()\n```\n\n----------------------------------------\n\nTITLE: Boolean Literal Handling\nDESCRIPTION: Shows how boolean literals are combined and simplified in union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(\n    u1: Literal[True, False],\n    u2: bool | Literal[True],\n    u3: Literal[True] | bool,\n    u4: Literal[True] | Literal[True, 17],\n    u5: Literal[True, False, True, 17],\n) -> None:\n    reveal_type(u1)  # revealed: bool\n    reveal_type(u2)  # revealed: bool\n    reveal_type(u3)  # revealed: bool\n    reveal_type(u4)  # revealed: Literal[True, 17]\n    reveal_type(u5)  # revealed: bool | Literal[17]\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Invalid __next__ Method in Python\nDESCRIPTION: Tests type inference when an iterator's __next__ method might be invalid due to incorrect parameter signature or being unbound. The system should emit diagnostics while inferring possible return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\ndef _(flag: bool):\n    class Iterator1:\n        if flag:\n            def __next__(self) -> int:\n                return 42\n        else:\n            def __next__(self, invalid_extra_arg) -> str:\n                return \"foo\"\n\n    class Iterator2:\n        if flag:\n            def __next__(self) -> int:\n                return 42\n        else:\n            __next__: None = None\n\n    class Iterable1:\n        def __iter__(self) -> Iterator1:\n            return Iterator1()\n\n    class Iterable2:\n        def __iter__(self) -> Iterator2:\n            return Iterator2()\n\n    # error: [not-iterable]\n    for x in Iterable1():\n        reveal_type(x)  # revealed: int | str\n\n    # error: [not-iterable]\n    for y in Iterable2():\n        # TODO: `int` would probably be better here:\n        reveal_type(y)  # revealed: int | Unknown\n```\n\n----------------------------------------\n\nTITLE: Multiple Unknown Types Collapsing\nDESCRIPTION: Shows how multiple Unknown types are collapsed in unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown\n\ndef _(u1: Unknown | Unknown | str, u2: Unknown | str | Unknown, u3: str | Unknown | Unknown) -> None:\n    reveal_type(u1)  # revealed: Unknown | str\n    reveal_type(u2)  # revealed: Unknown | str\n    reveal_type(u3)  # revealed: str | Unknown\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Declarations and Bindings in Python Classes\nDESCRIPTION: Explores various scenarios of attribute declarations and bindings in both class body and __init__ method. Demonstrates type inference for these mixed cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    only_declared_in_body: str | None\n    declared_in_body_and_init: str | None\n\n    declared_in_body_defined_in_init: str | None\n\n    bound_in_body_declared_in_init = \"a\"\n\n    bound_in_body_and_init = None\n\n    def __init__(self, flag) -> None:\n        self.only_declared_in_init: str | None\n        self.declared_in_body_and_init: str | None = None\n\n        self.declared_in_body_defined_in_init = \"a\"\n\n        self.bound_in_body_declared_in_init: str | None\n\n        if flag:\n            self.bound_in_body_and_init = \"a\"\n\nc_instance = C(True)\n\nreveal_type(c_instance.only_declared_in_body)  # revealed: str | None\nreveal_type(c_instance.only_declared_in_init)  # revealed: str | None\nreveal_type(c_instance.declared_in_body_and_init)  # revealed: str | None\n\nreveal_type(c_instance.declared_in_body_defined_in_init)  # revealed: str | None\n\n# TODO: This should be `str | None`. Fixing this requires an overhaul of the `Symbol` API,\n# which is planned in https://github.com/astral-sh/ruff/issues/14297\nreveal_type(c_instance.bound_in_body_declared_in_init)  # revealed: Unknown | str | None\n\nreveal_type(c_instance.bound_in_body_and_init)  # revealed: Unknown | None | Literal[\"a\"]\n```\n\n----------------------------------------\n\nTITLE: Mixed AND/OR Type Narrowing - Python\nDESCRIPTION: Shows type narrowing behavior when mixing 'and' and 'or' operators in the same expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(flag1: bool, flag2: bool):\n    class A: ...\n    x: A | None | Literal[1] = A() if flag1 else None if flag2 else 1\n\n    isinstance(x, A) or x is not None and reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Type Qualifiers in Type Expressions with Error Messages\nDESCRIPTION: Shows how using type qualifiers in type expressions generates error messages. Demonstrates the invalid usage of Final, ClassVar, Required, NotRequired, and ReadOnly in function parameter type expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_type_qualifiers.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Final, ClassVar, Required, NotRequired, ReadOnly\n\ndef _(\n    a: (\n        Final  # error: [invalid-type-form] \"Type qualifier `typing.Final` is not allowed in type expressions (only in annotation expressions)\"\n        | int\n    ),\n    b: (\n        ClassVar  # error: [invalid-type-form] \"Type qualifier `typing.ClassVar` is not allowed in type expressions (only in annotation expressions)\"\n        | int\n    ),\n    c: Required,  # error: [invalid-type-form] \"Type qualifier `typing.Required` is not allowed in type expressions (only in annotation expressions, and only with exactly one argument)\"\n    d: NotRequired,  # error: [invalid-type-form] \"Type qualifier `typing.NotRequired` is not allowed in type expressions (only in annotation expressions, and only with exactly one argument)\"\n    e: ReadOnly,  # error: [invalid-type-form] \"Type qualifier `typing.ReadOnly` is not allowed in type expressions (only in annotation expressions, and only with exactly one argument)\"\n) -> None:\n    reveal_type(a)  # revealed: Unknown | int\n    reveal_type(b)  # revealed: Unknown | int\n    reveal_type(c)  # revealed: Unknown\n    reveal_type(d)  # revealed: Unknown\n    reveal_type(e)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Inferring Annotated Assignments in Python Stub Files\nDESCRIPTION: This snippet demonstrates how annotated assignments in stub files are inferred correctly, preserving literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nx: int = 1\nreveal_type(x) # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: No Type Narrowing with Custom type() Function\nDESCRIPTION: Shows that type narrowing does not occur when the built-in type() function is shadowed by a custom implementation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef type(x):\n    return int\n\ndef _(x: A | B):\n    if type(x) is A:\n        reveal_type(x)  # revealed: A | B\n    else:\n        reveal_type(x)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Module Member Resolution in Python\nDESCRIPTION: Shows how to import a module and access its class member. The class C from module b is assigned to D, and its type is revealed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport b\n\nD = b.C\nreveal_type(D)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid __getitem__ Method Parameter Type in Python\nDESCRIPTION: Tests type inference for a class with an __getitem__ method that has an incompatible parameter type (str instead of int). This is invalid for iteration but still allows type inference of the return value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\nclass Iterable:\n    # invalid because it will implicitly be passed an `int`\n    # by the interpreter\n    def __getitem__(self, key: str) -> int:\n        return 42\n\n# error: [not-iterable]\nfor x in Iterable():\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Verifying Singleton Types in Python\nDESCRIPTION: Demonstrates checking for singleton types using is_singleton. Tests None, Literal, and regular types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_singleton, static_assert\nfrom typing import Literal\n\nstatic_assert(is_singleton(None))\nstatic_assert(is_singleton(Literal[True]))\n\nstatic_assert(not is_singleton(int))\nstatic_assert(not is_singleton(Literal[\"a\"]))\n```\n\n----------------------------------------\n\nTITLE: Method Union in Augmented Assignment\nDESCRIPTION: Shows how conditional implementation of dunder methods affects type inference, resulting in union types for the operation results.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Foo:\n        if flag:\n            def __iadd__(self, other: int) -> str:\n                return \"Hello, world!\"\n        else:\n            def __iadd__(self, other: int) -> int:\n                return 42\n\n    f = Foo()\n    f += 12\n\n    reveal_type(f)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Handling Possibly Unbound Attributes with inspect.getattr_static in Python\nDESCRIPTION: This snippet demonstrates how inspect.getattr_static handles attributes that may or may not be bound depending on runtime conditions. It shows that the return type can be a union of the attribute type and the default value type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\ndef _(flag: bool):\n    class C:\n        if flag:\n            x: int = 1\n\n    reveal_type(inspect.getattr_static(C, \"x\", \"default\"))  # revealed: int | Literal[\"default\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Desugared __getitem__ Lookup in Python\nDESCRIPTION: This code snippet demonstrates how the __getitem__ dunder method is looked up and called internally. It shows that dunder methods are not looked up on the object directly, but on its type, and how descriptors are handled.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef find_name_in_mro(typ: type, name: str) -> Any:\n    # See implementation in https://docs.python.org/3/howto/descriptor.html#invocation-from-an-instance\n    pass\n\ndef getitem_desugared(obj: object, key: object) -> object:\n    getitem_callable = find_name_in_mro(type(obj), \"__getitem__\")\n    if hasattr(getitem_callable, \"__get__\"):\n        getitem_callable = getitem_callable.__get__(obj, type(obj))\n\n    return getitem_callable(key)\n```\n\n----------------------------------------\n\nTITLE: Stub Functions in Python Protocols\nDESCRIPTION: This snippet shows how stub functions are defined in Python protocols, including generic protocols. It demonstrates the use of ellipsis (...) as a placeholder for default values in protocol methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\nclass Foo(Protocol):\n    def x(self, y: bool = ...): ...\n    def y[T](self, y: T = ...) -> T: ...\n\nclass GenericFoo[T](Protocol):\n    def x(self, y: bool = ...) -> T: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `break` Statement Behavior in Python Loops\nDESCRIPTION: This code snippet contains multiple functions that illustrate different scenarios of using the `break` statement in Python loops. It shows how `break` affects variable scoping, control flow, and type inference in various loop and conditional structures.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef resolved_reference(cond: bool) -> str:\n    while True:\n        if cond:\n            x = \"test\"\n        else:\n            break\n        return x\n    return x  # error: [unresolved-reference]\n\ndef break_in_then_branch(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"break\"\n            reveal_type(x)  # revealed: Literal[\"break\"]\n            break\n        else:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"break\", \"loop\"]\n\ndef break_in_else_branch(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        else:\n            x = \"break\"\n            reveal_type(x)  # revealed: Literal[\"break\"]\n            break\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop\", \"break\"]\n\ndef break_in_both_branches(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"break1\"\n            reveal_type(x)  # revealed: Literal[\"break1\"]\n            break\n        else:\n            x = \"break2\"\n            reveal_type(x)  # revealed: Literal[\"break2\"]\n            break\n    reveal_type(x)  # revealed: Literal[\"before\", \"break1\", \"break2\"]\n\ndef break_in_nested_then_branch(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop1\"\n            reveal_type(x)  # revealed: Literal[\"loop1\"]\n        else:\n            if cond2:\n                x = \"break\"\n                reveal_type(x)  # revealed: Literal[\"break\"]\n                break\n            else:\n                x = \"loop2\"\n                reveal_type(x)  # revealed: Literal[\"loop2\"]\n            reveal_type(x)  # revealed: Literal[\"loop2\"]\n        reveal_type(x)  # revealed: Literal[\"loop1\", \"loop2\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop1\", \"break\", \"loop2\"]\n\ndef break_in_nested_else_branch(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop1\"\n            reveal_type(x)  # revealed: Literal[\"loop1\"]\n        else:\n            if cond2:\n                x = \"loop2\"\n                reveal_type(x)  # revealed: Literal[\"loop2\"]\n            else:\n                x = \"break\"\n                reveal_type(x)  # revealed: Literal[\"break\"]\n                break\n            reveal_type(x)  # revealed: Literal[\"loop2\"]\n        reveal_type(x)  # revealed: Literal[\"loop1\", \"loop2\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop1\", \"loop2\", \"break\"]\n\ndef break_in_both_nested_branches(cond1: bool, cond2: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond1:\n            x = \"loop\"\n            reveal_type(x)  # revealed: Literal[\"loop\"]\n        else:\n            if cond2:\n                x = \"break1\"\n                reveal_type(x)  # revealed: Literal[\"break1\"]\n                break\n            else:\n                x = \"break2\"\n                reveal_type(x)  # revealed: Literal[\"break2\"]\n                break\n        reveal_type(x)  # revealed: Literal[\"loop\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"loop\", \"break1\", \"break2\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Statically Known Truthiness in Python Boolean Expressions\nDESCRIPTION: This code shows how Python handles boolean expressions with statically known truthiness (True). It demonstrates different behaviors for 'or' and 'and' operations when combined with assignments and type revelations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nif True or (x := 1):\n    # error: [unresolved-reference]\n    reveal_type(x)  # revealed: Unknown\n\nif True and (x := 1):\n    reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Detection with Inferred Types in Python\nDESCRIPTION: This example shows how Ruff can detect errors when using inferred types, such as when passing a potentially None value to a function expecting an int.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef accepts_int(i: int) -> None:\n    pass\n\ndef f(w: Wrapper) -> None:\n    # This is fine\n    v: int | None = w.value\n\n    # This function call is incorrect, because `w.value` could be `None`. We therefore emit the following\n    # error: \"Argument to this function is incorrect: Expected `int`, found `Unknown | None`\"\n    c = accepts_int(w.value)\n```\n\n----------------------------------------\n\nTITLE: Importing Declared Symbol from Module in Python\nDESCRIPTION: Shows how importing a symbol that is declared in always-executed code succeeds. The symbol is correctly imported with its declared type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n# no error\nfrom module import symbol\n```\n\n----------------------------------------\n\nTITLE: Examining len() with Tuples and Star Unpacking in Python\nDESCRIPTION: This snippet shows how `len()` behaves with tuples of various sizes and compositions, including empty tuples and tuples with star unpacking. It also highlights some TODO items for handling constructor calls and star unpacks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(len(()))  # revealed: Literal[0]\nreveal_type(len((1,)))  # revealed: Literal[1]\nreveal_type(len((1, 2)))  # revealed: Literal[2]\n\n# TODO: Handle constructor calls\nreveal_type(len(tuple()))  # revealed: int\n\n# TODO: Handle star unpacks; Should be: Literal[0]\nreveal_type(len((*[],)))  # revealed: Literal[1]\n\n# TODO: Handle star unpacks; Should be: Literal[1]\nreveal_type(  # revealed: Literal[2]\n    len(\n        (\n            *[],\n            1,\n        )\n    )\n)\n\n# TODO: Handle star unpacks; Should be: Literal[2]\nreveal_type(len((*[], 1, 2)))  # revealed: Literal[3]\n\n# TODO: Handle star unpacks; Should be: Literal[0]\nreveal_type(len((*[], *{})))  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Too Many Values in Python Unpacking\nDESCRIPTION: Shows the error that occurs when trying to unpack a tuple with more values than target variables. The tuple contains three values but only two variables are provided for unpacking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unpacking.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na, b = (1, 2, 3)  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Using Optional Type Annotation in Python\nDESCRIPTION: Demonstrates how typing.Optional is equivalent to using a type with None in a Union. The reveal_type function shows the actual type interpretations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/optional.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\na: Optional[int]\na1: Optional[bool]\na2: Optional[Optional[bool]]\na3: Optional[None]\n\ndef f():\n    # revealed: int | None\n    reveal_type(a)\n    # revealed: bool | None\n    reveal_type(a1)\n    # revealed: bool | None\n    reveal_type(a2)\n    # revealed: None\n    reveal_type(a3)\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Conditionally Mutated __all__ in Python 3.10\nDESCRIPTION: Shows behavior when importing from a module with conditionally mutated __all__ in Python 3.10. The type checker should recognize that Z is available but Y is not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\n# TODO: should reveal `Unknown` & emit `[unresolved-reference]\nreveal_type(X)  # revealed: bool\n\n# error: [unresolved-reference]\nreveal_type(Y)  # revealed: Unknown\n\nreveal_type(Z)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Type Inference in Try-Except-Finally Block with Variable Reassignment\nDESCRIPTION: Demonstrates type inference behavior when a variable is reassigned across try, except, and finally blocks. Shows how the type of variable 'x' changes through different execution paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C: ...\n\ndef could_raise_returns_A() -> A:\n    return A()\n\ndef could_raise_returns_B() -> B:\n    return B()\n\ndef could_raise_returns_C() -> C:\n    return C()\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_A()\n    reveal_type(x)  # revealed: A\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | A\n    x = could_raise_returns_B()\n    reveal_type(x)  # revealed: B\n    x = could_raise_returns_C()\n    reveal_type(x)  # revealed: C\nfinally:\n    # TODO: should be `Literal[1] | A | B | C`\n    reveal_type(x)  # revealed: A | C\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Nested Generic Function Calls\nDESCRIPTION: Examples demonstrating type inference in nested calls to multiple generic functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: T) -> tuple[T, int]:\n    return (x, 1)\n\ndef g[T](x: T) -> T | None:\n    return x\n\nreveal_type(f(g(\"a\")))  # revealed: tuple[Literal[\"a\"] | None, int]\nreveal_type(g(f(\"a\")))  # revealed: tuple[Literal[\"a\"], int] | None\n```\n\n----------------------------------------\n\nTITLE: Error: Context Manager with Non-callable __exit__ Attribute\nDESCRIPTION: Demonstrates the error when __exit__ is defined as a non-callable attribute instead of a method, making it an invalid context manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nclass Manager:\n    def __enter__(self) -> Self:\n        return self\n    __exit__: int = 32\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not correctly implement `__exit__`\"\nwith Manager():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Callable Comparison Operators in Python\nDESCRIPTION: Demonstrates using callable objects as comparison dunders (__eq__, __lt__) that always return True. Shows type checking behavior with reveal_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass AlwaysTrue:\n    def __call__(self, other: object) -> Literal[True]:\n        return True\n\nclass A:\n    __eq__: AlwaysTrue = AlwaysTrue()\n    __lt__: AlwaysTrue = AlwaysTrue()\n\nreveal_type(A() == A())  # revealed: Literal[True]\nreveal_type(A() < A())  # revealed: Literal[True]\nreveal_type(A() > A())  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Singleton and Single-Valued Type Behavior in Python\nDESCRIPTION: Illustrates behavior of singleton and single-valued types in relation to type variables, including bounded and constrained cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_singleton, is_single_valued, static_assert\nfrom typing_extensions import Literal\n\ndef unbounded_unconstrained[T](t: list[T]) -> None:\n    static_assert(not is_singleton(T))\n    static_assert(not is_single_valued(T))\n\ndef bounded[T: None](t: list[T]) -> None:\n    static_assert(not is_singleton(T))\n    static_assert(not is_single_valued(T))\n\ndef constrained_non_singletons[T: (int, str)](t: list[T]) -> None:\n    static_assert(not is_singleton(T))\n    static_assert(not is_single_valued(T))\n\ndef constrained_singletons[T: (Literal[True], Literal[False])](t: list[T]) -> None:\n    static_assert(is_singleton(T))\n\ndef constrained_single_valued[T: (Literal[True], tuple[()])](t: list[T]) -> None:\n    static_assert(is_single_valued(T))\n```\n\n----------------------------------------\n\nTITLE: Invalid __bool__ Method Implementation\nDESCRIPTION: Demonstrates type system behavior when a class implements __bool__ incorrectly by assigning an integer instead of a method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\na = NotBoolable()\n\n# error: [unsupported-bool-conversion]\n10 and a and True\n```\n\n----------------------------------------\n\nTITLE: Static Type Assertions for Inheritance and Disjoint Types in Python\nDESCRIPTION: This snippet performs static type checks to ensure that certain types are disjoint, specifically focusing on types related to random and mathematical operations. It checks for disjointness across functions and their types using static assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(not is_disjoint_from(type[A], type[B]))\n\nimport random\nimport math\n\nstatic_assert(is_disjoint_from(TypeOf[random], TypeOf[math]))\nstatic_assert(not is_disjoint_from(TypeOf[random], ModuleType))\nstatic_assert(not is_disjoint_from(TypeOf[random], object))\n\ndef f(): ...\ndef g(): ...\n\nstatic_assert(is_disjoint_from(TypeOf[f], TypeOf[g]))\nstatic_assert(not is_disjoint_from(TypeOf[f], FunctionType))\nstatic_assert(not is_disjoint_from(TypeOf[f], object))\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Formatting in Ruff (TOML)\nDESCRIPTION: Configuration to enable preview formatting in Ruff using pyproject.toml or ruff.toml. This setting enables preview mode for formatting without affecting lint rules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.format]\npreview = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[format]\npreview = true\n```\n\n----------------------------------------\n\nTITLE: Implementing __bool__ with NoReturn in Python\nDESCRIPTION: This snippet demonstrates a class with a __bool__ method that returns NoReturn. It shows a potential issue with type checking for objects that can't be converted to boolean.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NoReturn\n\nclass NotBoolable:\n    def __bool__(self) -> NoReturn:\n        raise NotImplementedError(\"This object can't be converted to a boolean\")\n\n# TODO: This should emit an error that `NotBoolable` can't be converted to a bool but it currently doesn't\n#   because `Never` is assignable to `bool`. This probably requires dead code analysis to fix.\nif NotBoolable():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types with __getattr__ Name Parameter\nDESCRIPTION: Demonstrates how to restrict valid attribute access using Literal types on the name parameter of __getattr__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Date:\n    def __getattr__(self, name: Literal[\"day\", \"month\", \"year\"]) -> int:\n        return 0\n\ndate = Date()\n\nreveal_type(date.day)  # revealed: int\nreveal_type(date.month)  # revealed: int\nreveal_type(date.year)  # revealed: int\n\n# error: [unresolved-attribute] \"Type `Date` has no attribute `century`\"\nreveal_type(date.century)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in Chained 'is' Comparisons\nDESCRIPTION: Illustrates type narrowing behavior in chained 'is' comparisons with boolean values. Shows how the type system interprets and narrows types in complex conditional expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(x_flag: bool, y_flag: bool):\n    x = True if x_flag else False\n    y = True if y_flag else False\n\n    reveal_type(x)  # revealed: bool\n    reveal_type(y)  # revealed: bool\n\n    if y is x is False:  # Interpreted as `(y is x) and (x is False)`\n        reveal_type(x)  # revealed: Literal[False]\n        reveal_type(y)  # revealed: bool\n    else:\n        reveal_type(x)  # revealed: bool\n        reveal_type(y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Basic Union Types with Literals\nDESCRIPTION: Demonstrates basic union type declarations using the | operator and Literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(u1: int | str, u2: Literal[0] | Literal[1]) -> None:\n    reveal_type(u1)  # revealed: int | str\n    reveal_type(u2)  # revealed: Literal[0, 1]\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Non-callable __getitem__ Method in Python\nDESCRIPTION: Tests type inference when __getitem__ might not be callable at runtime. This examines two different patterns: one with a conditional __call__ implementation and another with a conditional method definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\ndef _(flag: bool):\n    class CustomCallable:\n        if flag:\n            def __call__(self, *args, **kwargs) -> int:\n                return 42\n        else:\n            __call__: None = None\n\n    class Iterable1:\n        __getitem__: CustomCallable = CustomCallable()\n\n    class Iterable2:\n        if flag:\n            def __getitem__(self, key: int) -> int:\n                return 42\n        else:\n            __getitem__: None = None\n\n    # error: [not-iterable]\n    for x in Iterable1():\n        # TODO... `int` might be ideal here?\n        reveal_type(x)  # revealed: int | Unknown\n\n    # error: [not-iterable]\n    for y in Iterable2():\n        # TODO... `int` might be ideal here?\n        reveal_type(y)  # revealed: int | Unknown\n```\n\n----------------------------------------\n\nTITLE: Single Argument type() Function Call\nDESCRIPTION: Shows how type() function returns an object's meta-type when called with a single argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(type(1))  # revealed: Literal[int]\n```\n\n----------------------------------------\n\nTITLE: Definite Boundness in Class Unions\nDESCRIPTION: Demonstrates type checking behavior when an attribute is definitely unbound in one class of a union type. Shows how type checker handles access and assignment to possibly unbound attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    class C1:\n        x = 1\n\n    class C2: ...\n\n    class C3:\n        x = 3\n\n    C = C1 if flag1 else C2 if flag2 else C3\n\n    # error: [possibly-unbound-attribute] \"Attribute `x` on type `Literal[C1, C2, C3]` is possibly unbound\"\n    reveal_type(C.x)  # revealed: Unknown | Literal[1, 3]\n\n    # error: [invalid-assignment] \"Object of type `Literal[100]` is not assignable to attribute `x` on type `Literal[C1, C2, C3]`\"\n    C.x = 100\n\n    # error: [possibly-unbound-attribute] \"Attribute `x` on type `C1 | C2 | C3` is possibly unbound\"\n    reveal_type(C().x)  # revealed: Unknown | Literal[1, 3]\n\n    # error: [invalid-assignment] \"Object of type `Literal[100]` is not assignable to attribute `x` on type `C1 | C2 | C3`\"\n    C().x = 100\n```\n\n----------------------------------------\n\nTITLE: Importing Bound Symbol from Module in Python\nDESCRIPTION: Demonstrates how importing a symbol that is defined in always-executed code succeeds. The variable 'symbol' is considered bound in the module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n# no error\nfrom module import symbol\n```\n\n----------------------------------------\n\nTITLE: Evaluating Ambiguous Values with bool() Function in Python\nDESCRIPTION: This snippet shows how the bool() function handles ambiguous values like empty containers in Python. The type system infers these as general bool types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(bool([]))  # revealed: bool\nreveal_type(bool({}))  # revealed: bool\nreveal_type(bool(set()))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Extra Whitespace in knot: ignore Comments in Python\nDESCRIPTION: Demonstrates that extra whitespace in knot: ignore comments is allowed and does not affect their functionality.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\na = 10 / 0  # knot   :   ignore\na = 10 / 0  # knot: ignore  [    division-by-zero   ]\n```\n\n----------------------------------------\n\nTITLE: Descriptor Behavior with Super in Python\nDESCRIPTION: Illustrates how accessing attributes through super invokes the descriptor protocol with different behaviors depending on whether the second argument is a class or an instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def a1(self): ...\n    @classmethod\n    def a2(cls): ...\n\nclass B(A): ...\n\n# A.__dict__[\"a1\"].__get__(B(), B)\nreveal_type(super(B, B()).a1)  # revealed: bound method B.a1() -> Unknown\n# A.__dict__[\"a2\"].__get__(B(), B)\nreveal_type(super(B, B()).a2)  # revealed: bound method type[B].a2() -> Unknown\n\n# A.__dict__[\"a1\"].__get__(None, B)\nreveal_type(super(B, B).a1)  # revealed: def a1(self) -> Unknown\n# A.__dict__[\"a2\"].__get__(None, B)\nreveal_type(super(B, B).a2)  # revealed: bound method Literal[B].a2() -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Exceptions with except*\nDESCRIPTION: Example of using except* with multiple exception types (TypeError and AttributeError) in an exception group.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    help()\nexcept* (TypeError, AttributeError) as e:\n    # TODO: more precise would be `ExceptionGroup[TypeError | AttributeError]` --Alex\n    # (needs homogeneous tuples + generics)\n    reveal_type(e)  # revealed: BaseExceptionGroup\n```\n\n----------------------------------------\n\nTITLE: Conditional Global vs Builtin Type Union\nDESCRIPTION: Demonstrates how Python handles type unions when a builtin name is conditionally defined as a global variable. The type system combines both the builtin type and the conditional type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/builtin.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef returns_bool() -> bool:\n    return True\n\nif returns_bool():\n    chr: int = 1\n\ndef f():\n    reveal_type(chr)  # revealed: int | (def chr(i: int | SupportsIndex, /) -> str)\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Literal Types\nDESCRIPTION: Illustrates type narrowing behavior when comparing against literal values. Shows how the type system narrows numeric literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else 2\n\n    if x != 1:\n        reveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Invalid Async Comprehension Cases in Python\nDESCRIPTION: Demonstrates invalid async comprehension cases when using synchronous iteration protocol instead of async.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Iterator:\n    def __next__(self) -> int:\n        return 42\n\nclass Iterable:\n    def __iter__(self) -> Iterator:\n        return Iterator()\n\n# revealed: @Todo(async iterables/iterators)\n[reveal_type(x) async for x in Iterable()]\n```\n\n----------------------------------------\n\nTITLE: functools.cache Decorator in Python\nDESCRIPTION: Shows the usage of functools.cache decorator and its type implications.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import cache\n\n@cache\ndef f(x: int) -> int:\n    return x**2\n\n# TODO: Should be `_lru_cache_wrapper[int]`\nreveal_type(f)  # revealed: @Todo(generics)\n\n# TODO: Should be `int`\nreveal_type(f(1))  # revealed: @Todo(generics)\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Version for except* Support\nDESCRIPTION: TOML configuration to specify Python 3.11 as the required version for except* syntax support.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\n----------------------------------------\n\nTITLE: Nested List Comprehensions in Python\nDESCRIPTION: Shows nested list comprehension implementation with IntIterable class, demonstrating how nested iterations handle type revelation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\n# revealed: tuple[int, int]\n[[reveal_type((x, y)) for x in IntIterable()] for y in IntIterable()]\n```\n\n----------------------------------------\n\nTITLE: Accessing String Elements via Indexing in Python\nDESCRIPTION: Demonstrates string indexing with positive and negative indices, boolean indices, and out-of-bounds error cases. The snippet reveals the type of each operation to show how string indexing resolves to specific literals or error conditions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/string.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ns = \"abcde\"\n\nreveal_type(s[0])  # revealed: Literal[\"a\"]\nreveal_type(s[1])  # revealed: Literal[\"b\"]\nreveal_type(s[-1])  # revealed: Literal[\"e\"]\nreveal_type(s[-2])  # revealed: Literal[\"d\"]\n\nreveal_type(s[False])  # revealed: Literal[\"a\"]\nreveal_type(s[True])  # revealed: Literal[\"b\"]\n\na = s[8]  # error: [index-out-of-bounds] \"Index 8 is out of bounds for string `Literal[\"abcde\"]` with length 5\"\nreveal_type(a)  # revealed: Unknown\n\nb = s[-8]  # error: [index-out-of-bounds] \"Index -8 is out of bounds for string `Literal[\"abcde\"]` with length 5\"\nreveal_type(b)  # revealed: Unknown\n\ndef _(n: int):\n    a = \"abcde\"[n]\n    # TODO: Support overloads... Should be `str`\n    reveal_type(a)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in `then` branch in Python\nDESCRIPTION: This function demonstrates how a `raise` statement within the `then` branch of an `if` statement inside a `try` block affects variable visibility in the `except`, `else`, and `finally` clauses. The function uses `reveal_type` to show the possible types of `x` based on whether the exception is raised.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_then_branch(cond: bool):\n    x = \"before\"\n    try:\n        if cond:\n            x = \"raise\"\n            reveal_type(x)  # revealed: Literal[\"raise\"]\n            raise ValueError\n        else:\n            x = \"else\"\n            reveal_type(x)  # revealed: Literal[\"else\"]\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise\", \"else\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise\", \"else\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"raise\", \"else\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"raise\", \"else\"]\n```\n\n----------------------------------------\n\nTITLE: Partially Bound __iadd__ Implementation\nDESCRIPTION: Demonstrates type checking behavior with conditionally implemented __iadd__ methods and their interaction with operator overloading.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Foo:\n        if flag:\n            def __iadd__(self, other: str) -> int:\n                return 42\n\n    f = Foo()\n\n    # error: [unsupported-operator] \"Operator `+=` is unsupported between objects of type `Foo` and `Literal[\\\"Hello, world!\\\"]`\"\n    f += \"Hello, world!\"\n\n    reveal_type(f)  # revealed: int | Unknown\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff using standalone installers\nDESCRIPTION: This snippet shows how to install Ruff using standalone installers on macOS, Linux, and Windows. It also demonstrates how to install a specific version of Ruff.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ # On macOS and Linux.\n$ curl -LsSf https://astral.sh/ruff/install.sh | sh\n\n$ # On Windows.\n$ powershell -c \"irm https://astral.sh/ruff/install.ps1 | iex\"\n\n$ # For a specific version.\n$ curl -LsSf https://astral.sh/ruff/0.5.0/install.sh | sh\n$ powershell -c \"irm https://astral.sh/ruff/0.5.0/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Extending Lint Rule Selection in Ruff LSP\nDESCRIPTION: Specifies additional rules to enable in addition to those in 'lint.select'. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.extendSelect\": [\"W\"]\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      lint = {\n        extendSelect = {\"W\"}\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"lint\": {\n            \"extendSelect\": [\"W\"]\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Read-only Property Error Handling in Python\nDESCRIPTION: Shows error handling when attempting to write to a read-only property.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def attr(self) -> int:\n        return 1\n\nc = C()\n\n# error: [invalid-assignment]\nc.attr = 2\n```\n\n----------------------------------------\n\nTITLE: Variable Access Skipping Class Scope\nDESCRIPTION: Demonstrates how variable lookup skips class scope when accessing from a method, preferring to look in the outer function scope instead of the class scope.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/nonlocal.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    x = 1\n\n    class C:\n        x = 2\n        def g():\n            reveal_type(x)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Error: Context Manager with Non-callable __enter__ Attribute\nDESCRIPTION: Shows the error when __enter__ is defined as a non-callable attribute instead of a method, making it an invalid context manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Manager:\n    __enter__: int = 42\n\n    def __exit__(self, exc_tpe, exc_value, traceback): ...\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not correctly implement `__enter__`\"\nwith Manager():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Various String Types for Annotations in Python\nDESCRIPTION: Demonstrates different string types (raw, f-strings, bytes, multi-line) as type annotations, showing which are valid and which produce errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f1(\n    # error: [raw-string-type-annotation] \"Type expressions cannot use raw string literal\"\n    a: r\"int\",\n    # error: [fstring-type-annotation] \"Type expressions cannot use f-strings\"\n    b: f\"int\",\n    # error: [byte-string-type-annotation] \"Type expressions cannot use bytes literal\"\n    c: b\"int\",\n    d: \"int\",\n    # error: [implicit-concatenated-string-type-annotation] \"Type expressions cannot span multiple string literals\"\n    e: \"in\" \"t\",\n    # error: [escape-character-in-forward-annotation] \"Type expressions cannot contain escape characters\"\n    f: \"\\N{LATIN SMALL LETTER I}nt\",\n    # error: [escape-character-in-forward-annotation] \"Type expressions cannot contain escape characters\"\n    g: \"\\x69nt\",\n    h: \"\"\"int\"\"\",\n    # error: [byte-string-type-annotation] \"Type expressions cannot use bytes literal\"\n    i: \"b'int'\",\n):\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n    reveal_type(c)  # revealed: Unknown\n    reveal_type(d)  # revealed: int\n    reveal_type(e)  # revealed: Unknown\n    reveal_type(f)  # revealed: Unknown\n    reveal_type(g)  # revealed: Unknown\n    reveal_type(h)  # revealed: int\n    reveal_type(i)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Incompatible Declarations with Multiple Conditions in Python\nDESCRIPTION: This snippet shows how Ruff handles type conflicts in multiple conditional branches. It demonstrates an error when assigning an integer to a variable that could be 'str', 'int', or 'Unknown' based on different conditions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    if flag1:\n        x: str\n    elif flag2:\n        x: int\n\n    # Here, the declared type for `x` is `int | str | Unknown`.\n    x = 1  # error: [conflicting-declarations] \"Conflicting declared types for `x`: str, int\"\n```\n\n----------------------------------------\n\nTITLE: Class Attribute Inheritance\nDESCRIPTION: Shows inheritance patterns for class and instance attributes, including type checking and validation across class hierarchies.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    declared_in_body: int | None = 1\n    base_class_attribute_1: str | None\n    base_class_attribute_2: str | None\n    base_class_attribute_3: str | None\n\n    def __init__(self) -> None:\n        self.defined_in_init: str | None = \"value in base\"\n\nclass Intermediate(Base):\n    base_class_attribute_1: str | None = None\n    base_class_attribute_2: str\n    base_class_attribute_3: str | int | None\n\nclass Derived(Intermediate): ...\n```\n\n----------------------------------------\n\nTITLE: Usage Example: Variadic Keyword Arguments\nDESCRIPTION: Example showing usage of **kwargs with SIM910 rule detection.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef function(**kwargs):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Basic Class Literal Type Usage in Python\nDESCRIPTION: Demonstrates basic usage of type[] with a simple class definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\ndef _(c: type[A]):\n    reveal_type(c)  # revealed: type[A]\n```\n\n----------------------------------------\n\nTITLE: Simple If Expression Type Revelation\nDESCRIPTION: Demonstrates basic if-expression with literal type revelation showing possible values of 1 or 2 based on boolean flag.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_expression.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else 2\n    reveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Violating Previous Type Annotation in Python\nDESCRIPTION: This snippet shows an invalid assignment where a value is assigned that doesn't match a previously declared type annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx: int\nx = \"foo\"  # error: [invalid-assignment] \"Object of type `Literal[\"foo\"]` is not assignable to `int`\"\n```\n\n----------------------------------------\n\nTITLE: Installing Required Libraries for TensorFlow Lite Super Resolution\nDESCRIPTION: This snippet installs the necessary Python libraries (matplotlib, tensorflow, and tensorflow-hub) for running the super resolution example.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n!pip install matplotlib tensorflow tensorflow-hub\n```\n\n----------------------------------------\n\nTITLE: Missing Dunder Method\nDESCRIPTION: Shows error when attempting to use an operator on a class without the corresponding dunder method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\n# error: [unsupported-operator]\n# revealed: Unknown\nreveal_type(A() + A())\n```\n\n----------------------------------------\n\nTITLE: Additional Limitations with Type Information from Outside Unreachable Sections in Python\nDESCRIPTION: Demonstrates multiple examples of false positives that occur because diagnostics depend on type information from outside the unreachable section. The examples show various rule types affected by this limitation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nif False:\n    def f(x: int): ...\n    def g(*, a: int, b: int): ...\n\n    class C:\n        x: int = 1\n\n    class D:\n        def __call__(self):\n            pass\n\n    number: Literal[1] = 1\nelse:\n    def f(x: str): ...\n    def g(*, a: int): ...\n\n    class C:\n        x: str = \"a\"\n\n    class D: ...\n    number: Literal[0] = 0\n\nif False:\n    # TODO\n    # error: [invalid-argument-type]\n    f(2)\n\n    # TODO\n    # error: [unknown-argument]\n    g(a=2, b=3)\n\n    # TODO\n    # error: [invalid-assignment]\n    C.x = 2\n\n    d: D = D()\n    # TODO\n    # error: [call-non-callable]\n    d()\n\n    # TODO\n    # error: [division-by-zero]\n    1 / number\n```\n\n----------------------------------------\n\nTITLE: Stub Functions in Python Abstract Methods\nDESCRIPTION: This snippet demonstrates how stub functions are defined as abstract methods in Python classes. It shows the use of the @abstractmethod decorator and ellipsis (...) for default values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/parameters.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import abstractmethod\n\nclass Bar:\n    @abstractmethod\n    def x(self, y: bool = ...): ...\n    @abstractmethod\n    def y[T](self, y: T = ...) -> T: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating OR Operator Type Inference in Python\nDESCRIPTION: This snippet shows type inference for various expressions using the OR operator in Python. It reveals the inferred types for different combinations of literals and variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(foo: str):\n    reveal_type(True or False)  # revealed: Literal[True]\n    reveal_type(\"x\" or \"y\" or \"z\")  # revealed: Literal[\"x\"]\n    reveal_type(\"\" or \"y\" or \"z\")  # revealed: Literal[\"y\"]\n    reveal_type(False or \"z\")  # revealed: Literal[\"z\"]\n    reveal_type(False or True)  # revealed: Literal[True]\n    reveal_type(False or False)  # revealed: Literal[False]\n    reveal_type(foo or False)  # revealed: str & ~AlwaysFalsy | Literal[False]\n    reveal_type(foo or True)  # revealed: str & ~AlwaysFalsy | Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Unsupported Binary Operations on Optional Types\nDESCRIPTION: Demonstrates that binary operations like addition are not supported between an integer and an optional integer (int | None) because the operation isn't defined for all possible combinations of types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/unions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f1(i: int, u: int | None):\n    # error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `int` and `int | None`\"\n    reveal_type(i + u)  # revealed: Unknown\n    # error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `int | None` and `int`\"\n    reveal_type(u + i)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Multiple Decorators in Python\nDESCRIPTION: Demonstrates the application of multiple decorators to a single function and their order of execution.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef maps_to_str(f) -> str:\n    return \"a\"\n\ndef maps_to_int(f) -> int:\n    return 1\n\ndef maps_to_bytes(f) -> bytes:\n    return b\"a\"\n\n@maps_to_str\n@maps_to_int\n@maps_to_bytes\ndef f(x): ...\n\nreveal_type(f)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Defining Stub File for Simple Stub Package in Python\nDESCRIPTION: Creates a stub file (__init__.pyi) for the 'Foo' class with type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    name: str\n    age: int\n```\n\n----------------------------------------\n\nTITLE: Value Pattern Matching in Python\nDESCRIPTION: This snippet demonstrates value pattern matching and its implications on type inference. It shows how custom __eq__ implementations can affect the matching process and type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import final\n\n@final\nclass C:\n    pass\n\ndef _(subject: C):\n    y = 1\n    match subject:\n        case 2:\n            y = 3\n    reveal_type(y)  # revealed: Literal[1, 3]\n```\n\n----------------------------------------\n\nTITLE: Handling Unresolvable Module Imports in Python\nDESCRIPTION: Demonstrates error handling for unresolvable module imports, including both top-level and submodule imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport zqzqzqzqzqzqzq  # error: [unresolved-import] \"Cannot resolve import `zqzqzqzqzqzqzq`\"\n```\n\nLANGUAGE: python\nCODE:\n```\n# Topmost component resolvable, submodule not resolvable:\nimport a.foo  # error: [unresolved-import] \"Cannot resolve import `a.foo`\"\n\n# Topmost component unresolvable:\nimport b.foo  # error: [unresolved-import] \"Cannot resolve import `b.foo`\"\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Binary Operations with Classes Inheriting from Any in Python\nDESCRIPTION: Explores the behavior of binary operations when one operand is an instance of a class inheriting from Any. Demonstrates the complexities in type inference for these cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom does_not_exist import Foo  # error: [unresolved-import]\n\nreveal_type(Foo)  # revealed: Unknown\n\nclass X:\n    def __add__(self, other: object) -> int:\n        return 42\n\nclass Y(Foo): ...\n\n# TODO: Should be `int | Unknown`; see above discussion.\nreveal_type(X() + Y())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Complex Union Type Inference\nDESCRIPTION: Examples showing type inference with multiple union parameters and constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef union_and_nonunion_params[T](x: T | int, y: T) -> T:\n    return y\n\nreveal_type(union_and_nonunion_params(1, \"a\"))  # revealed: Literal[\"a\"]\nreveal_type(union_and_nonunion_params(\"a\", \"a\"))  # revealed: Literal[\"a\"]\nreveal_type(union_and_nonunion_params(1, 1))  # revealed: Literal[1]\nreveal_type(union_and_nonunion_params(3, 1))  # revealed: Literal[1]\nreveal_type(union_and_nonunion_params(\"a\", 1))  # revealed: Literal[\"a\", 1]\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Mode for Formatting in Ruff LSP\nDESCRIPTION: Controls whether to enable Ruff's preview mode when formatting. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.format.preview\": true\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      format = {\n        preview = true\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"format\": {\n            \"preview\": true\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Whitespace in knot: ignore Comments in Python\nDESCRIPTION: Shows that whitespace around the colon and after the ignore keyword is optional in knot: ignore comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\na = 10 / 0  #knot:ignore[division-by-zero]\n```\n\n----------------------------------------\n\nTITLE: Assigning Data Descriptor Attributes in Python\nDESCRIPTION: Demonstrates assigning to data descriptor attributes, which implicitly calls the descriptor's __set__ method. Shows valid and invalid assignments based on the descriptor's signature.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Descriptor:\n    def __set__(self, instance: object, value: int) -> None:\n        pass\n\nclass C:\n    attr: Descriptor = Descriptor()\n\ninstance = C()\ninstance.attr = 1  # fine\n\n# TODO: ideally, we would mention why this is an invalid assignment (wrong argument type for `value` parameter)\ninstance.attr = \"wrong\"  # error: [invalid-assignment]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass WrongDescriptor:\n    def __set__(self, instance: object, value: int, extra: int) -> None:\n        pass\n\nclass C:\n    attr: WrongDescriptor = WrongDescriptor()\n\ninstance = C()\n\n# TODO: ideally, we would mention why this is an invalid assignment (wrong number of arguments for `__set__`)\ninstance.attr = 1  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Invalid Async For Loop Implementation in Python\nDESCRIPTION: Demonstrates incorrect usage of synchronous iteration protocol in an async context. Shows an iterator class implementing __next__ instead of the required async iteration methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/async_for.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def foo():\n    class Iterator:\n        def __next__(self) -> int:\n            return 42\n\n    class Iterable:\n        def __iter__(self) -> Iterator:\n            return Iterator()\n\n    async for x in Iterator():\n        pass\n\n    # TODO: should reveal `Unknown` because `__aiter__` is not defined\n    # revealed: @Todo(async iterables/iterators)\n    # error: [possibly-unresolved-reference]\n    reveal_type(x)\n```\n\n----------------------------------------\n\nTITLE: Handling Subscript Operations on Objects with No __getitem__ Method in Python\nDESCRIPTION: Demonstrates that attempting to use subscript notation on a class without a __getitem__ method results in a type error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/instance.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NotSubscriptable: ...\n\na = NotSubscriptable()[0]  # error: \"Cannot subscript object of type `NotSubscriptable` with no `__getitem__` method\"\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Non-Single-Valued Types\nDESCRIPTION: Demonstrates that type narrowing does not occur when comparing with non-single-valued types like general integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, a: int, y: int):\n    x = a if flag else None\n\n    if x != y:\n        reveal_type(x)  # revealed: int | None\n```\n\n----------------------------------------\n\nTITLE: Method Calls on Tuple in Python\nDESCRIPTION: Shows method calls on tuple type, demonstrating type inference for the index method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f(t: tuple[int, str]) -> None:\n    reveal_type(t.index(\"a\"))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Concatenating Heterogeneous Tuples in Python\nDESCRIPTION: This snippet demonstrates concatenation operations on heterogeneous tuples. It shows how the types are revealed for various combinations, including literal values, empty tuples, and tuples with different types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/tuples.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type((1, 2) + (3, 4))  # revealed: tuple[Literal[1], Literal[2], Literal[3], Literal[4]]\nreveal_type(() + (1, 2))  # revealed: tuple[Literal[1], Literal[2]]\nreveal_type((1, 2) + ())  # revealed: tuple[Literal[1], Literal[2]]\nreveal_type(() + ())  # revealed: tuple[()]\n\ndef _(x: tuple[int, str], y: tuple[None, tuple[int]]):\n    reveal_type(x + y)  # revealed: tuple[int, str, None, tuple[int]]\n    reveal_type(y + x)  # revealed: tuple[None, tuple[int], int, str]\n```\n\n----------------------------------------\n\nTITLE: For Loop with Previous Variable Definition\nDESCRIPTION: Shows type inference when loop variable was previously defined with a different type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\nx = \"foo\"\n\nfor x in IntIterable():\n    pass\n\nreveal_type(x)  # revealed: Literal[\"foo\"] | int\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference in Nested Scopes with Exception Handling in Python\nDESCRIPTION: This code demonstrates how variable shadowing and type inference work across nested scopes in try-except-finally blocks. It shows how the type of variable 'x' evolves through different execution paths, and includes comments showing the revealed types at each point. The example also points out some current limitations in type inference for exception handling control flow.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\nclass E: ...\n\ndef could_raise_returns_A() -> A:\n    return A()\n\ndef could_raise_returns_B() -> B:\n    return B()\n\ndef could_raise_returns_C() -> C:\n    return C()\n\ndef could_raise_returns_D() -> D:\n    return D()\n\ndef could_raise_returns_E() -> E:\n    return E()\n\nx = 1\n\ntry:\n\n    def foo(param=could_raise_returns_A()):\n        x = could_raise_returns_A()\n\n        try:\n            reveal_type(x)  # revealed: A\n            x = could_raise_returns_B()\n            reveal_type(x)  # revealed: B\n        except:\n            reveal_type(x)  # revealed: A | B\n            x = could_raise_returns_C()\n            reveal_type(x)  # revealed: C\n            x = could_raise_returns_D()\n            reveal_type(x)  # revealed: D\n        finally:\n            # TODO: should be `A | B | C | D`\n            reveal_type(x)  # revealed: B | D\n        reveal_type(x)  # revealed: B | D\n    x = foo\n    reveal_type(x)  # revealed: def foo(param=A) -> Unknown\nexcept:\n    reveal_type(x)  # revealed: Literal[1] | (def foo(param=A) -> Unknown)\n\n    class Bar:\n        x = could_raise_returns_E()\n        reveal_type(x)  # revealed: E\n\n    x = Bar\n    reveal_type(x)  # revealed: Literal[Bar]\nfinally:\n    # TODO: should be `Literal[1] | Literal[foo] | Literal[Bar]`\n    reveal_type(x)  # revealed: (def foo(param=A) -> Unknown) | Literal[Bar]\n\nreveal_type(x)  # revealed: (def foo(param=A) -> Unknown) | Literal[Bar]\n```\n\n----------------------------------------\n\nTITLE: Non-reflected Precedence in Binary Operations in Python\nDESCRIPTION: Explains the precedence rules for non-reflected binary operations when both operands define their respective methods. Demonstrates with examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other: \"B\") -> int:\n        return 42\n\nclass B:\n    def __radd__(self, other: \"A\") -> str:\n        return \"foo\"\n\nreveal_type(A() + B())  # revealed:  int\n\n# Edge case: C is a subtype of C, *but* if the two sides are of *equal* types,\n# the lhs *still* takes precedence\nclass C:\n    def __add__(self, other: \"C\") -> int:\n        return 42\n\n    def __radd__(self, other: \"C\") -> str:\n        return \"foo\"\n\nreveal_type(C() + C())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Invalid Test Format Example in Rust\nDESCRIPTION: Example showing an invalid inline test format where the test block is not properly isolated from other comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Some random comment\n//\n// test_ok this_is_the_test_name\n// def foo():\n//     pass\nprintln!(\"some rust code\");\n```\n\n----------------------------------------\n\nTITLE: Testing Function Return Type Equivalence in Python\nDESCRIPTION: Shows that a function with no explicit return type is gradual equivalent to a callable with a return type of Any.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f1():\n    return\n\nstatic_assert(is_gradual_equivalent_to(CallableTypeOf[f1], Callable[[], Any]))\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Positional-Only Parameters in Python\nDESCRIPTION: Demonstrates a lambda expression with positional-only parameters and its type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda a, b, /, c: c)  # revealed: (a, b, /, c) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Violating Previous Assignment in Python Type Checking\nDESCRIPTION: This snippet shows an error where a type declaration conflicts with a previous assignment. Ruff catches the invalid declaration of 'str' type for a variable already inferred as 'Literal[1]'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nx: str  # error: [invalid-declaration] \"Cannot declare type `str` for inferred type `Literal[1]\"\"\n```\n\n----------------------------------------\n\nTITLE: Basic Version Check Example\nDESCRIPTION: Demonstrates basic static version checking using sys.version_info to conditionally define features based on Python version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nclass C:\n    if sys.version_info >= (3, 9):\n        SomeFeature: str = \"available\"\n\n# C.SomeFeature is unconditionally available here, because we are on Python 3.9 or newer:\nreveal_type(C.SomeFeature)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Incompatible Declarations in Python Conditional Blocks\nDESCRIPTION: This example demonstrates how Ruff detects conflicting type declarations in different conditional blocks. It shows an error when assigning an integer to a variable declared as either 'str' or 'int' in different branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        x: str\n    else:\n        x: int\n\n    x = 1  # error: [conflicting-declarations] \"Conflicting declared types for `x`: str, int\"\n```\n\n----------------------------------------\n\nTITLE: Incompatible Declarations with Invalid Assignment in Python\nDESCRIPTION: This example shows how Ruff detects both conflicting declarations and invalid assignments. It demonstrates errors when assigning a bytes object to a variable declared as either 'str' or 'int' in different branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        x: str\n    else:\n        x: int\n\n    # error: [conflicting-declarations]\n    # error: [invalid-assignment]\n    x = b\"foo\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Setter Signature Example in Python\nDESCRIPTION: Shows error handling for incorrect setter method signature.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def attr(self) -> int:\n        return 1\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `(Any, Any, /) -> None`, found `def attr(self) -> None`\"\n    @attr.setter\n    def attr(self) -> None:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Inheritance Behavior with typing.Type in Python\nDESCRIPTION: Demonstrates the Method Resolution Order (MRO) when inheriting from typing.Type. Shows that Type inheritance includes builtins.type and typing.Generic in the resolution chain.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/typing_dot_Type.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Type\n\nclass C(Type): ...\n\n# Runtime value: `(C, type, typing.Generic, object)`\n# TODO: Add `Generic` to the MRO\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[type], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Dealing with Possibly Unbound Callable in Python\nDESCRIPTION: This snippet illustrates a case where a class with a __call__ method might not be defined in all code paths, potentially leading to unresolved reference errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        class PossiblyUnbound:\n            def __call__(self) -> int:\n                return 1\n\n    # error: [possibly-unresolved-reference]\n    a = PossiblyUnbound()\n    reveal_type(a())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Accessing Symbols from Cyclic Star Imports\nDESCRIPTION: Shows that both A and B are accessible when importing from module a, despite the cyclic import pattern. Python resolves these imports without runtime errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\n\nreveal_type(A)  # revealed: bool\nreveal_type(B)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Defining Legacy Type Variables in Python\nDESCRIPTION: This snippet shows the basic usage of TypeVar to create a type variable. It demonstrates the legacy method of defining type variables, which is still available in newer Python versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/legacy.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n```\n\n----------------------------------------\n\nTITLE: Same Value __slots__ Inheritance Issues\nDESCRIPTION: Shows that even when parent classes have identical __slots__ content, inheriting from both still causes incompatibility errors due to Python's handling of slots in inheritance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = (\"a\", \"b\")\n\nclass B:\n    __slots__ = (\"a\", \"b\")\n\nclass C(\n    A,  # error: [incompatible-slots]\n    B,  # error: [incompatible-slots]\n): ...\n```\n\n----------------------------------------\n\nTITLE: Configuring '-stubs' Named Module in TOML\nDESCRIPTION: Sets up the environment for a module named with '-stubs' suffix.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Type as Base Class Example\nDESCRIPTION: Demonstrates using type[] as a base class (with current limitations).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# TODO: this is a false positive\n# error: [invalid-base] \"Invalid class base with type `GenericAlias` (all bases must be a class, `Any`, `Unknown` or `Todo`)\"\nclass Foo(type[int]): ...\n\n# TODO: should be `tuple[Literal[Foo], Literal[type], Literal[object]]\nreveal_type(Foo.__mro__)  # revealed: tuple[Literal[Foo], Unknown, Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Nested Class Type Check Suppression\nDESCRIPTION: Illustrates @no_type_check behavior with nested class definitions and their methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test() -> int:\n    class Nested:\n        def inner(self):\n            return a + 5\n```\n\n----------------------------------------\n\nTITLE: Constrained Typevar Behavior in Python\nDESCRIPTION: Demonstrates how constrained type variables interact with unions, intersections, and gradual typing. Shows relationships between constraints and the type variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection\n\ndef constrained[T: (Base, Unrelated)](t: list[T]) -> None:\n    static_assert(not is_assignable_to(T, Super))\n    static_assert(not is_assignable_to(T, Base))\n    static_assert(not is_assignable_to(T, Sub))\n    static_assert(not is_assignable_to(T, Unrelated))\n    static_assert(is_assignable_to(T, Super | Unrelated))\n    static_assert(is_assignable_to(T, Base | Unrelated))\n    static_assert(not is_assignable_to(T, Sub | Unrelated))\n    static_assert(not is_assignable_to(Super, T))\n    static_assert(not is_assignable_to(Unrelated, T))\n    static_assert(not is_assignable_to(Super | Unrelated, T))\n    static_assert(is_assignable_to(Intersection[Base, Unrelated], T))\n```\n\n----------------------------------------\n\nTITLE: Explicit Class Shadowing in Python\nDESCRIPTION: This snippet shows the correct way to explicitly shadow a class by using type annotation when reassigning the class name. No diagnostic error is raised in this case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/class.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\nC: int = 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unbound Class Variable Behavior in Python\nDESCRIPTION: This example shows how name lookups within a class scope fall back to globals, but lookups of class attributes don't. It demonstrates conditional attribute assignment within a class and how type checking reveals possible unboundedness.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/unbound.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nflag = coinflip()\nx = 1\n\nclass C:\n    y = x\n    if flag:\n        x = 2\n\n# error: [possibly-unbound-attribute] \"Attribute `x` on type `Literal[C]` is possibly unbound\"\nreveal_type(C.x)  # revealed: Unknown | Literal[2]\nreveal_type(C.y)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always True Conditional Expression in Python\nDESCRIPTION: Shows type inference for if-expressions with a statically known true condition. Both the result of the expression and the variable assigned in the evaluated branch are correctly typed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx = (y := 1) if True else (y := 2)\n\nreveal_type(x)  # revealed: Literal[1]\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Testing Callable Type Equivalence in Python\nDESCRIPTION: Demonstrates gradual equivalence for callable types, showing how parameter types, return types, and variadic arguments affect equivalence. Includes tests with different parameter kinds and default values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown, CallableTypeOf, is_gradual_equivalent_to, static_assert\nfrom typing import Any, Callable\n\nstatic_assert(is_gradual_equivalent_to(Callable[..., int], Callable[..., int]))\nstatic_assert(is_gradual_equivalent_to(Callable[..., Any], Callable[..., Unknown]))\nstatic_assert(is_gradual_equivalent_to(Callable[[int, Any], None], Callable[[int, Unknown], None]))\n\nstatic_assert(not is_gradual_equivalent_to(Callable[[int, Any], None], Callable[[Any, int], None]))\nstatic_assert(not is_gradual_equivalent_to(Callable[[int, str], None], Callable[[int, str, bytes], None]))\nstatic_assert(not is_gradual_equivalent_to(Callable[..., None], Callable[[], None]))\n```\n\n----------------------------------------\n\nTITLE: Illustrating Generic Class Restrictions within Generic Functions in Python\nDESCRIPTION: This example shows that generic classes defined within generic functions should use distinct typevars from the function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\ndef f[T](x: T, y: T) -> None:\n    class Ok[S]: ...\n    # TODO: error for reuse of typevar\n    class Bad1[T]: ...\n    # TODO: no non-subscriptable error, error for reuse of typevar\n    # error: [non-subscriptable]\n    class Bad2(Iterable[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Multiple Unused Comments in Python\nDESCRIPTION: Demonstrates how multiple unused error codes in a single knot: ignore directive generate separate unused-ignore-comment warnings for each code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'division-by-zero'\"\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'unresolved-reference'\"\na = 10 / 2  # knot: ignore[division-by-zero, unresolved-reference]\n\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'invalid-assignment'\"\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'unresolved-reference'\"\na = 10 / 0  # knot: ignore[invalid-assignment, division-by-zero, unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Creating an instance of the `object` class in Python\nDESCRIPTION: Demonstrates the behavior of instantiating the `object` class directly, including type revelation and error handling for unexpected arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(object())  # revealed: object\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to class `object`: expected 0, got 1\"\nreveal_type(object(1))  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Boolean Type Checking with Custom __bool__ Methods\nDESCRIPTION: Tests type checking behavior when class __bool__ methods are set to the built-in bool function or conditionally defined. Shows how the type system handles potential recursion and conditional method definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/truthiness.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass BoolIsBool:\n    __bool__ = bool\n\nreveal_type(bool(BoolIsBool()))  # revealed: bool\n```\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nclass Boom:\n    if flag():\n        __bool__ = bool\n    else:\n        __bool__ = int\n\nreveal_type(bool(Boom()))  # revealed: bool\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef flag() -> bool:\n    return True\n\nclass PossiblyUnboundTrue:\n    if flag():\n        def __bool__(self) -> Literal[True]:\n            return True\n\nreveal_type(bool(PossiblyUnboundTrue()))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Collapsing Last Context Manager: Ruff vs Black\nDESCRIPTION: This snippet highlights how Ruff collapses the last context manager in a `with` statement onto a single line, if possible, while Black breaks the last context manager slightly differently.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Black\nwith tempfile.TemporaryDirectory() as d1:\n    symlink_path = Path(d1).joinpath(\"testsymlink\")\n    with tempfile.TemporaryDirectory(dir=d1) as d2, tempfile.TemporaryDirectory(\n        dir=d1\n    ) as d4, tempfile.TemporaryDirectory(dir=d2) as d3, tempfile.NamedTemporaryFile(\n        dir=d4\n    ) as source_file, tempfile.NamedTemporaryFile(\n        dir=d3\n    ) as lock_file:\n        pass\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\nwith tempfile.TemporaryDirectory() as d1:\n    symlink_path = Path(d1).joinpath(\"testsymlink\")\n    with tempfile.TemporaryDirectory(dir=d1) as d2, tempfile.TemporaryDirectory(\n        dir=d1\n    ) as d4, tempfile.TemporaryDirectory(dir=d2) as d3, tempfile.NamedTemporaryFile(\n        dir=d4\n    ) as source_file, tempfile.NamedTemporaryFile(dir=d3) as lock_file:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Nested Comments with Type Error Suppression in Python\nDESCRIPTION: Examples showing how `type: ignore` works when combined with other comment directives in different orders.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\na = test \\\n  + 2  # fmt: skip # type: ignore\n\na = test \\\n  + 2  # type: ignore # fmt: skip\n```\n\n----------------------------------------\n\nTITLE: Determined Truthiness Classes\nDESCRIPTION: Demonstrates type narrowing for classes with fixed boolean values through __bool__ method implementation. Shows how types with determined truthiness are handled in boolean contexts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass T:\n    def __bool__(self) -> Literal[True]:\n        return True\n\nclass F:\n    def __bool__(self) -> Literal[False]:\n        return False\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in Chained Comparisons\nDESCRIPTION: Shows how type narrowing works in chained 'is not' comparisons, particularly focusing on boolean values and complex conditional logic.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is_not.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(x_flag: bool, y_flag: bool):\n    x = True if x_flag else False\n    y = True if y_flag else False\n\n    reveal_type(x)  # revealed: bool\n    reveal_type(y)  # revealed: bool\n\n    if y is not x is not False:  # Interpreted as `(y is not x) and (x is not False)`\n        reveal_type(x)  # revealed: Literal[True]\n        reveal_type(y)  # revealed: bool\n    else:\n        # The negation of the clause above is (y is x) or (x is False)\n        # So we can't narrow the type of x or y here, because each arm of the `or` could be true\n\n        reveal_type(x)  # revealed: bool\n        reveal_type(y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Indexing Bytes Objects in Python\nDESCRIPTION: Demonstrates accessing individual elements in bytes objects using various indexing techniques including positive indices, negative indices, and boolean values. Shows type checking with reveal_type calls and error handling for out-of-bounds indices.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/bytes.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nb = b\"\\x00abc\\xff\"\n\nreveal_type(b[0])  # revealed: Literal[b\"\\x00\"]\nreveal_type(b[1])  # revealed: Literal[b\"a\"]\nreveal_type(b[4])  # revealed: Literal[b\"\\xff\"]\n\nreveal_type(b[-1])  # revealed: Literal[b\"\\xff\"]\nreveal_type(b[-2])  # revealed: Literal[b\"c\"]\nreveal_type(b[-5])  # revealed: Literal[b\"\\x00\"]\n\nreveal_type(b[False])  # revealed: Literal[b\"\\x00\"]\nreveal_type(b[True])  # revealed: Literal[b\"a\"]\n\nx = b[5]  # error: [index-out-of-bounds] \"Index 5 is out of bounds for bytes literal `Literal[b\"\\x00abc\\xff\"]` with length 5\"\nreveal_type(x)  # revealed: Unknown\n\ny = b[-6]  # error: [index-out-of-bounds] \"Index -6 is out of bounds for bytes literal `Literal[b\"\\x00abc\\xff\"]` with length 5\"\nreveal_type(y)  # revealed: Unknown\n\ndef _(n: int):\n    a = b\"abcde\"[n]\n    # TODO: Support overloads... Should be `bytes`\n    reveal_type(a)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Illegal Final Type Expressions in Python\nDESCRIPTION: Shows invalid usage of Final in union types and type expressions, where Final is only allowed in annotation expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nclass C:\n    # error: [invalid-type-form] \"Type qualifier `typing.Final` is not allowed in type expressions (only in annotation expressions)\"\n    x: Final | int\n\n    # error: [invalid-type-form] \"Type qualifier `typing.Final` is not allowed in type expressions (only in annotation expressions)\"\n    y: int | Final[str]\n```\n\n----------------------------------------\n\nTITLE: Heterogeneous Tuple Type Inference in Python\nDESCRIPTION: Shows type inference for heterogeneous tuples containing different types and nested structures. Demonstrates how literal types and nested tuples are represented in type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/collections/tuple.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type((1, \"a\"))  # revealed: tuple[Literal[1], Literal[\"a\"]]\n\nreveal_type((1, (2, 3)))  # revealed: tuple[Literal[1], tuple[Literal[2], Literal[3]]]\n\nreveal_type(((1, \"a\"), 2))  # revealed: tuple[tuple[Literal[1], Literal[\"a\"]], Literal[2]]\n```\n\n----------------------------------------\n\nTITLE: Or Pattern Match with Guard Type Narrowing\nDESCRIPTION: Shows type narrowing behavior for or patterns with guard conditions, demonstrating union type handling within guard expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case \"foo\" | 42 | None if reveal_type(x):  # revealed: Literal[\"foo\", 42] | None\n        pass\n    case \"foo\" | tuple() if reveal_type(x):  # revealed: Literal[\"foo\"] | tuple\n        pass\n    case True | False if reveal_type(x):  # revealed: bool\n        pass\n    case 3.14 | 2.718 | 1.414 if reveal_type(x):  # revealed: float\n        pass\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Comparing Heterogeneous Tuples with Definite Results in Python\nDESCRIPTION: Demonstrates value comparisons between heterogeneous tuples where the results can be definitively inferred as boolean literals. This includes comparisons of identical tuples and tuples with different values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = (1, \"test\", (3, 13), True)\nb = (1, \"test\", (3, 14), False)\n\nreveal_type(a == a)  # revealed: Literal[True]\nreveal_type(a != a)  # revealed: Literal[False]\nreveal_type(a < a)  # revealed: Literal[False]\nreveal_type(a <= a)  # revealed: Literal[True]\nreveal_type(a > a)  # revealed: Literal[False]\nreveal_type(a >= a)  # revealed: Literal[True]\n\nreveal_type(a == b)  # revealed: Literal[False]\nreveal_type(a != b)  # revealed: Literal[True]\nreveal_type(a < b)  # revealed: Literal[True]\nreveal_type(a <= b)  # revealed: Literal[True]\nreveal_type(a > b)  # revealed: Literal[False]\nreveal_type(a >= b)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AND Operator Type Inference in Python\nDESCRIPTION: This snippet illustrates type inference for expressions using the AND operator in Python. It shows the inferred types for various combinations of literals and variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(foo: str):\n    reveal_type(True and False)  # revealed: Literal[False]\n    reveal_type(False and True)  # revealed: Literal[False]\n    reveal_type(foo and False)  # revealed: str & ~AlwaysTruthy | Literal[False]\n    reveal_type(foo and True)  # revealed: str & ~AlwaysTruthy | Literal[True]\n    reveal_type(\"x\" and \"y\" and \"z\")  # revealed: Literal[\"z\"]\n    reveal_type(\"x\" and \"y\" and \"\")  # revealed: Literal[\"\"]\n    reveal_type(\"\" and \"y\")  # revealed: Literal[\"\"]\n```\n\n----------------------------------------\n\nTITLE: Supporting PEP-604 Union Types in Python\nDESCRIPTION: This snippet demonstrates the usage of PEP-604 union types in function parameter annotations and how they are interpreted.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef foo(v: str | int | None, w: str | str | None, x: str | str):\n    reveal_type(v)  # revealed: str | int | None\n    reveal_type(w)  # revealed: str | None\n    reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Defining a Variable in a Python Stub File\nDESCRIPTION: This snippet shows a stub file declaration for a variable 'x'. It's used in the following reimport with stub declaration example.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nx: int\n```\n\n----------------------------------------\n\nTITLE: Evaluating Falsy Values with bool() Function in Python\nDESCRIPTION: This snippet demonstrates how the bool() function evaluates various falsy values in Python. It shows that these values are inferred as Literal[False].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(bool(0))  # revealed: Literal[False]\nreveal_type(bool(()))  # revealed: Literal[False]\nreveal_type(bool(None))  # revealed: Literal[False]\nreveal_type(bool(\"\"))  # revealed: Literal[False]\nreveal_type(bool(False))  # revealed: Literal[False]\nreveal_type(bool())  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Handling Type Annotations in Conditional Imports in Python\nDESCRIPTION: Shows how Ruff handles type annotations, including stringified ones, in conditionally imported modules. This example demonstrates how to conditionally import and use Self type based on Python version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport typing\n\nif sys.version_info >= (3, 11):\n    from typing import Self\n\n    class C:\n        def name_expr(self) -> Self:\n            return self\n\n        def name_expr_stringified(self) -> \"Self\":\n            return self\n\n        def attribute_expr(self) -> typing.Self:\n            return self\n\n        def attribute_expr_stringified(self) -> \"typing.Self\":\n            return self\n```\n\n----------------------------------------\n\nTITLE: Partial Binding with __add__ Method\nDESCRIPTION: Shows the interaction between __add__ and conditionally implemented __iadd__ methods in type checking context.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Foo:\n        def __add__(self, other: str) -> str:\n            return \"Hello, world!\"\n        if flag:\n            def __iadd__(self, other: str) -> int:\n                return 42\n\n    f = Foo()\n    f += \"Hello, world!\"\n\n    reveal_type(f)  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Inheritance with Annotated Type in Python\nDESCRIPTION: This snippet shows inheritance behavior with the Annotated type. Inheriting from Annotated[T, ...] is equivalent to inheriting from T itself.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Annotated\n\nclass C(Annotated[int, \"foo\"]): ...\n\n# TODO: Should be `tuple[Literal[C], Literal[int], Literal[object]]`\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], @Todo(Inference of subscript on special form), Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Basic Multi-target Assignment with Type Revelation\nDESCRIPTION: Demonstrates basic multi-target assignment in Python where multiple variables are assigned the same value. Uses reveal_type to show that both variables receive the same literal type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/multi_target.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = y = 1\nreveal_type(x)  # revealed: Literal[1]\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Possibly Unbound Annotated Variables in Python\nDESCRIPTION: This snippet shows a scenario similar to the first one, but with type annotation for the conditionally assigned variable 'y'. It demonstrates how type annotation affects type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    y: int = 3\n\nx = y  # error: [possibly-unresolved-reference]\n\n# revealed: Literal[3]\nreveal_type(x)\n\n# revealed: Literal[3]\n# error: [possibly-unresolved-reference]\nreveal_type(y)\n```\n\n----------------------------------------\n\nTITLE: Static Condition Type Inference\nDESCRIPTION: Shows how type checkers handle if-expressions with statically known conditions, resulting in specific literal types based on truthiness evaluation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/if.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1 if True else 2)  # revealed: Literal[1]\nreveal_type(1 if \"not empty\" else 2)  # revealed: Literal[1]\nreveal_type(1 if (1,) else 2)  # revealed: Literal[1]\nreveal_type(1 if 1 else 2)  # revealed: Literal[1]\n\nreveal_type(1 if False else 2)  # revealed: Literal[2]\nreveal_type(1 if None else 2)  # revealed: Literal[2]\nreveal_type(1 if \"\" else 2)  # revealed: Literal[2]\nreveal_type(1 if 0 else 2)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Class Method Variable Access\nDESCRIPTION: Shows class variable behavior when accessed within class methods, including type revelation and instance access patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @classmethod\n    def class_method(cls):\n        cls.pure_class_variable = \"value set in class method\"\n\nC.class_method()\n\nreveal_type(C.pure_class_variable)\n\nC.pure_class_variable = \"overwritten on class\"\n\nreveal_type(C.pure_class_variable)\n\nc_instance = C()\nreveal_type(c_instance.pure_class_variable)\n\nc_instance.pure_class_variable = \"value set on instance\"\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with assert_type\nDESCRIPTION: Shows how assert_type works with narrowed types after isinstance checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\ndef _(x: int | str):\n    if isinstance(x, int):\n        reveal_type(x)  # revealed: int\n        assert_type(x, int)  # fine\n```\n\n----------------------------------------\n\nTITLE: Importing Modules at Different Scopes in Python\nDESCRIPTION: This snippet demonstrates importing modules at different scopes in Python. It shows a global import, an import within a function definition, and another global import. This illustrates how imports can be used at various levels of code organization.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ok\n\n\ndef foo() -> None:\n    import e\n\n\nimport no_ok\n```\n\n----------------------------------------\n\nTITLE: Using SupportsIndex Protocol in Python Type Hints\nDESCRIPTION: Demonstrates valid usage of typing.SupportsIndex protocol with different numeric types including integers and literal integers. Shows type hint assignments for variables that support the index protocol.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/protocols.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import SupportsIndex, Literal\n\ndef _(some_int: int, some_literal_int: Literal[1], some_indexable: SupportsIndex):\n    a: SupportsIndex = some_int\n    b: SupportsIndex = some_literal_int\n    c: SupportsIndex = some_indexable\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions CI for Ruff\nDESCRIPTION: Basic GitHub Actions workflow configuration to run Ruff linter with automatic inline annotations. Sets up Python environment and installs dependencies.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/integrations.md#2025-04-17_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: CI\non: push\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install ruff\n      # Update output format to enable automatic inline annotations.\n      - name: Run Ruff\n        run: ruff check --output-format=github .\n```\n\n----------------------------------------\n\nTITLE: Inheritance Constraints for Special Forms\nDESCRIPTION: This snippet illustrates the inheritance constraints for special type forms. Most special forms cannot be used as base classes, with `typing.Callable` being a notable exception. The example shows error messages for invalid inheritance patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_special_forms.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\nfrom typing_extensions import Self, Unpack, TypeGuard, TypeIs, Concatenate\n\nclass A(Self): ...  # error: [invalid-base]\nclass B(Unpack): ...  # error: [invalid-base]\nclass C(TypeGuard): ...  # error: [invalid-base]\nclass D(TypeIs): ...  # error: [invalid-base]\nclass E(Concatenate): ...  # error: [invalid-base]\nclass F(Callable): ...\n\nreveal_type(F.__mro__)  # revealed: tuple[Literal[F], @Todo(Support for Callable as a base class), Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Preceding Decorator Error Handling\nDESCRIPTION: Demonstrates that errors in decorators before @no_type_check are not suppressed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@unknown_decorator  # error: [unresolved-reference]\n@no_type_check\ndef test() -> int:\n    # TODO: this should not be an error\n    # error: [unresolved-reference]\n    return a + 5\n```\n\n----------------------------------------\n\nTITLE: Showing Unresolved Import From Resolved Module in Python\nDESCRIPTION: This snippet illustrates an unresolved import from a resolved module. The module 'a' exists but does not have a member 'thing', resulting in an error and unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import thing  # error: \"Module `a` has no member `thing`\"\n\nreveal_type(thing)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Operations with Unbounded Unconstrained TypeVars in Python\nDESCRIPTION: Shows how unions involving unbounded unconstrained typevars cannot be simplified since there's no guarantee what type the typevar will be specialized to.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nclass Super: ...\nclass Base(Super): ...\nclass Sub(Base): ...\nclass Unrelated: ...\n\ndef unbounded_unconstrained[T](t: T) -> None:\n    def _(x: T | Super) -> None:\n        reveal_type(x)  # revealed: T | Super\n\n    def _(x: T | Base) -> None:\n        reveal_type(x)  # revealed: T | Base\n\n    def _(x: T | Sub) -> None:\n        reveal_type(x)  # revealed: T | Sub\n\n    def _(x: T | Unrelated) -> None:\n        reveal_type(x)  # revealed: T | Unrelated\n\n    def _(x: T | Any) -> None:\n        reveal_type(x)  # revealed: T | Any\n```\n\n----------------------------------------\n\nTITLE: Inferring bool Type for Non-Literal String Parameters in str.startswith Calls\nDESCRIPTION: Demonstrates how type checking infers a regular bool type when either the string instance or prefix parameter is not a string literal, as the result cannot be determined at compile time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/str_startswith.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\ndef _(string_instance: str, literalstring: LiteralString):\n    reveal_type(string_instance.startswith(\"a\"))  # revealed: bool\n    reveal_type(literalstring.startswith(\"a\"))  # revealed: bool\n\n    reveal_type(\"a\".startswith(string_instance))  # revealed: bool\n    reveal_type(\"a\".startswith(literalstring))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Metaclass Augmented Assignment Implementation\nDESCRIPTION: Shows how augmented assignment operations work with metaclasses and class objects through custom __iadd__ implementation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Meta(type):\n    def __iadd__(cls, other: int) -> str:\n        return \"\"\n\nclass C(metaclass=Meta): ...\n\ncls = C\ncls += 1\n\nreveal_type(cls)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Unresolvable Super Calls in Python\nDESCRIPTION: Demonstrates cases where implicit super() calls fail because appropriate class and argument cannot be determined, resulting in runtime errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\n# error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\nreveal_type(super())  # revealed: Unknown\n\ndef f():\n    # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n    super()\n\n# No first argument in its scope\nclass A:\n    # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n    s = super()\n\n    def f(self):\n        def g():\n            # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n            super()\n        # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n        lambda: super()\n\n        # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n        (super() for _ in range(10))\n\n    @staticmethod\n    def h():\n        # error: [unavailable-implicit-super-arguments] \"Cannot determine implicit arguments for 'super()' in this context\"\n        super()\n```\n\n----------------------------------------\n\nTITLE: Deeply Nested Module Imports in Python\nDESCRIPTION: Shows importing from a deeply nested module structure and revealing the type of the imported class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport a.b.c\n\nreveal_type(a.b.c.C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: NoReturn Type Equivalence with Tuples in Python\nDESCRIPTION: Code demonstrating that NoReturn (an alias for Never) behaves the same way as Never with regard to tuple type equivalence.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/tuples_containing_never.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(is_equivalent_to(NoReturn, tuple[NoReturn]))\nstatic_assert(is_equivalent_to(NoReturn, tuple[NoReturn, int]))\nstatic_assert(is_equivalent_to(NoReturn, tuple[int, NoReturn]))\nstatic_assert(is_equivalent_to(NoReturn, tuple[int, NoReturn, str]))\nstatic_assert(is_equivalent_to(NoReturn, tuple[int, tuple[str, NoReturn]]))\nstatic_assert(is_equivalent_to(NoReturn, tuple[tuple[str, NoReturn], int]))\n```\n\n----------------------------------------\n\nTITLE: Running Python Fuzzer\nDESCRIPTION: Shell command to execute the Python-based fuzzer for testing the parser with randomly generated code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nuvx --from ./python/py-fuzzer fuzz\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Exception Types with except*\nDESCRIPTION: Example of using except* with a mix of Exception and BaseException types (KeyboardInterrupt and AttributeError).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    help()\nexcept* (KeyboardInterrupt, AttributeError) as e:\n    # TODO: more precise would be `BaseExceptionGroup[KeyboardInterrupt | AttributeError]` --Alex\n    reveal_type(e)  # revealed: BaseExceptionGroup\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unused Variable in Python\nDESCRIPTION: This function defines two variables but only uses one, potentially causing an unused variable warning. It prints a formatted string using an f-string.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/valid.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef unused_variable():\n    x = 1\n    y = 2\n    print(f\"cell one: {y}\")\n\nunused_variable()\n```\n\n----------------------------------------\n\nTITLE: Statically Known Branch Examples\nDESCRIPTION: Examples showing unreachable code in statically determinable conditional branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f1():\n    if 2 + 3 > 10:\n        # TODO: we should mark this as unreachable\n        print(\"unreachable\")\n\ndef f2():\n    if True:\n        return\n\n    # TODO: we should mark this as unreachable\n    print(\"unreachable\")\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always False 'or' Boolean Expression in Python\nDESCRIPTION: Demonstrates type inference with short-circuit evaluation in 'or' expressions when operands are falsy until a truthy value is encountered. Evaluation stops at the first truthy value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n(x := 0) or (x := 1)\n\nreveal_type(x)  # revealed: Literal[1]\n\n(y := 0) or (y := 0) or (y := 1) or (y := 2)\n\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Equality Comparisons\nDESCRIPTION: Demonstrates why type narrowing cannot occur with equality comparisons due to possible custom __eq__ implementations in metaclasses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass IsEqualToEverything(type):\n    def __eq__(cls, other):\n        return True\n\nclass A(metaclass=IsEqualToEverything): ...\nclass B(metaclass=IsEqualToEverything): ...\n\ndef _(x: A | B):\n    if type(x) == A:\n        reveal_type(x)  # revealed: A | B\n\n    if type(x) != A:\n        reveal_type(x)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Testing NoDefaultType as Singleton in Python 3.12\nDESCRIPTION: Tests that _NoDefaultType is recognized as a singleton type in Python 3.12. Sets the Python version using TOML configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.12\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import _NoDefaultType\nfrom knot_extensions import is_singleton, static_assert\n\nstatic_assert(is_singleton(_NoDefaultType))\n```\n\n----------------------------------------\n\nTITLE: Reflected Precedence for Subtypes in Binary Operations in Python\nDESCRIPTION: Demonstrates the precedence rules for reflected binary operations when the right-hand operand is a subtype of the left-hand operand. Shows examples with different class hierarchies.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> str:\n        return \"foo\"\n\n    def __radd__(self, other) -> str:\n        return \"foo\"\n\nclass MyString(str): ...\n\nclass B(A):\n    def __radd__(self, other) -> MyString:\n        return MyString()\n\nreveal_type(A() + B())  # revealed: MyString\n\n# N.B. Still a subtype of `A`, even though `A` does not appear directly in the class's `__bases__`\nclass C(B): ...\n\nreveal_type(A() + C())  # revealed: MyString\n```\n\n----------------------------------------\n\nTITLE: Basic Wildcard Import Example\nDESCRIPTION: Demonstrates basic functionality of wildcard imports with type inference and unresolved reference handling\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\nprint(Y)  # error: [unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Never Type Assignability Rules in Python\nDESCRIPTION: Demonstrates that Never type (bottom type) is assignable to all other types as it represents an empty set with no inhabitants.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to, Unknown\nfrom typing_extensions import Never, Any, Literal\n\nstatic_assert(is_assignable_to(Never, str))\nstatic_assert(is_assignable_to(Never, Literal[1]))\nstatic_assert(is_assignable_to(Never, object))\n# Additional assertions...\n```\n\n----------------------------------------\n\nTITLE: Assignability Rules for LiteralString in Python\nDESCRIPTION: Illustrates the assignability rules for LiteralString: Literal strings can be assigned to LiteralString, and LiteralString can be assigned to str, but not vice versa.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\n\ndef _(flag: bool):\n    foo_1: Literal[\"foo\"] = \"foo\"\n    bar_1: LiteralString = foo_1  # fine\n\n    foo_2 = \"foo\" if flag else \"bar\"\n    reveal_type(foo_2)  # revealed: Literal[\"foo\", \"bar\"]\n    bar_2: LiteralString = foo_2  # fine\n\n    foo_3: LiteralString = \"foo\" * 1_000_000_000\n    bar_3: str = foo_2  # fine\n\n    baz_1: str = repr(object())\n    qux_1: LiteralString = baz_1  # error: [invalid-assignment]\n\n    baz_2: LiteralString = \"baz\" * 1_000_000_000\n    qux_2: Literal[\"qux\"] = baz_2  # error: [invalid-assignment]\n\n    baz_3 = \"foo\" if flag else 1\n    reveal_type(baz_3)  # revealed: Literal[\"foo\", 1]\n    qux_3: LiteralString = baz_3  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Class, Module and Function Literals in Python\nDESCRIPTION: This code shows how disjointness works with class literals, represented through TypeOf. Different class literals are disjoint from each other. A class is not disjoint from its own type, but is disjoint from other unrelated types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom types import ModuleType, FunctionType\nfrom knot_extensions import TypeOf, is_disjoint_from, static_assert\n\nclass A: ...\nclass B: ...\n\ntype LiteralA = TypeOf[A]\ntype LiteralB = TypeOf[B]\n\n# Class literals for different classes are always disjoint.\n# They are singleton types that only contain the class object itself.\nstatic_assert(is_disjoint_from(LiteralA, LiteralB))\n\n# The class A is a subclass of A, so A is not disjoint from type[A]:\nstatic_assert(not is_disjoint_from(LiteralA, type[A]))\n\n# The class A is disjoint from type[B] because it's not a subclass of B:\nstatic_assert(is_disjoint_from(LiteralA, type[B]))\n\n# However, type[A] is not disjoint from type[B], as there could be\n```\n\n----------------------------------------\n\nTITLE: Nested If Statement Analysis\nDESCRIPTION: Shows type inference in nested conditional statements.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    y = 0\n\n    if flag:\n        if flag2:\n            y = 1\n\n    reveal_type(y)  # revealed: Literal[0, 1]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constraint Removal with TypeVars in Python\nDESCRIPTION: Shows how removing constraints from typevars is modeled as an intersection with a negation, and how these operations simplify depending on the constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Not\n\ndef remove_constraint[T: (int, str, bool)](t: T) -> None:\n    def _(x: Intersection[T, Not[int]]) -> None:\n        reveal_type(x)  # revealed: str & ~int\n\n    def _(x: Intersection[T, Not[str]]) -> None:\n        # With OneOf this would be OneOf[int, bool]\n        reveal_type(x)  # revealed: T & ~str\n\n    def _(x: Intersection[T, Not[bool]]) -> None:\n        reveal_type(x)  # revealed: T & ~bool\n\n    def _(x: Intersection[T, Not[int], Not[str]]) -> None:\n        reveal_type(x)  # revealed: Never\n\n    def _(x: Intersection[T, Not[None]]) -> None:\n        reveal_type(x)  # revealed: T\n\n    def _(x: Intersection[T, Not[Any]]) -> None:\n        reveal_type(x)  # revealed: T & Any\n```\n\n----------------------------------------\n\nTITLE: Builtin types attributes in Python\nDESCRIPTION: This snippet defines a class with attributes of various built-in types (int, str, bytes, bool, float, complex, tuple, range, slice, type, None). It tests the type checker's ability to correctly infer the types of these attributes when accessed as class members. The revealed types for each attribute are shown in the comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n```py\nclass C:\n    a_int: int = 1\n    a_str: str = \"a\"\n    a_bytes: bytes = b\"a\"\n    a_bool: bool = True\n    a_float: float = 1.0\n    a_complex: complex = 1 + 1j\n    a_tuple: tuple[int] = (1,)\n    a_range: range = range(1)\n    a_slice: slice = slice(1)\n    a_type: type = int\n    a_none: None = None\n\nreveal_type(C.a_int)  # revealed: int\nreveal_type(C.a_str)  # revealed: str\nreveal_type(C.a_bytes)  # revealed: bytes\nreveal_type(C.a_bool)  # revealed: bool\nreveal_type(C.a_float)  # revealed: int | float\nreveal_type(C.a_complex)  # revealed: int | float | complex\nreveal_type(C.a_tuple)  # revealed: tuple[int]\nreveal_type(C.a_range)  # revealed: range\nreveal_type(C.a_slice)  # revealed: slice\nreveal_type(C.a_type)  # revealed: type\nreveal_type(C.a_none)  # revealed: None\n```\n```\n\n----------------------------------------\n\nTITLE: Special Functions Error Handling in Python\nDESCRIPTION: Shows error handling for special functions like reveal_type, static_assert, len, and type API predicates.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\n# error: [missing-argument] \"No argument provided for required parameter `obj` of function `reveal_type`\"\nreveal_type()\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `reveal_type`: expected 1, got 2\"\nreveal_type(1, 2)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\n\n# error: [missing-argument] \"No argument provided for required parameter `condition` of function `static_assert`\"\nstatic_assert()\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `static_assert`: expected 2, got 3\"\nstatic_assert(True, 2, 3)\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: [missing-argument] \"No argument provided for required parameter `obj` of function `len`\"\nlen()\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to function `len`: expected 1, got 2\"\nlen([], 1)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_subtype_of, is_fully_static\n\n# error: [missing-argument]\nis_subtype_of()\n\n# error: [missing-argument]\nis_subtype_of(int)\n\n# error: [too-many-positional-arguments]\nis_subtype_of(int, int, int)\n\n# error: [too-many-positional-arguments]\nis_subtype_of(int, int, int, int)\n\n# error: [missing-argument]\nis_fully_static()\n\n# error: [too-many-positional-arguments]\nis_fully_static(int, int)\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Unbound __iter__ with Non-callable __getitem__ in Python\nDESCRIPTION: Tests type inference when __iter__ is possibly unbound and __getitem__ is non-callable. This verifies that the correct element type is inferred in the for loop despite emitting a diagnostic about non-iterability.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Iterator:\n        def __next__(self) -> int:\n            return 42\n\n    class Iterable:\n        if flag:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n        __getitem__: None = None\n\n    # error: [not-iterable] \"Object of type `Iterable` may not be iterable because it may not have an `__iter__` method and its `__getitem__` attribute has type `None`, which is not callable\"\n    for x in Iterable():\n        reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Conditional Class Attributes in Python\nDESCRIPTION: Demonstrates how conditionally defined class attributes are resolved. Only the attribute definition in the always-executed branch is used, determining the type of 'C.x'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    if True:\n        x: int = 1\n    else:\n        x: str = \"a\"\n\nreveal_type(C.x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Dynamic __all__ Definition in Python Modules\nDESCRIPTION: Example showing dynamic creation of __all__ attribute, which complicates static analysis. This demonstrates how dynamically constructed __all__ can make it difficult to determine what is actually exported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> str:\n    return \"f\"\n\ndef g() -> int:\n    return 42\n\n# TODO we should emit a warning here for the dynamically constructed `__all__` member.\n__all__ = [f()]\n```\n\n----------------------------------------\n\nTITLE: Post-hoc Modifications to __slots__\nDESCRIPTION: Demonstrates how modifying __slots__ within a class definition affects inheritance compatibility. Even when starting with empty slots, adding slots can create incompatibility issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = ()\n    __slots__ += (\"a\", \"b\")\n\nreveal_type(A.__slots__)  # revealed: tuple[Literal[\"a\"], Literal[\"b\"]]\n\nclass B:\n    __slots__ = (\"c\", \"d\")\n\nclass C(\n    A,  # error: [incompatible-slots]\n    B,  # error: [incompatible-slots]\n): ...\n```\n\n----------------------------------------\n\nTITLE: Imported isinstance() Check\nDESCRIPTION: Demonstrates type narrowing with imported isinstance() function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom builtins import isinstance as imported_isinstance\n\ndef _(flag: bool):\n    x = 1 if flag else \"a\"\n\n    if imported_isinstance(x, int):\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement on sys.version_info in Python\nDESCRIPTION: Demonstrates type checking with a match statement on Python version information. Based on the Python version (3.13), only the corresponding case will be executed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nminor = \"too old\"\n\nmatch sys.version_info.minor:\n    case 12:\n        minor = 12\n    case 13:\n        minor = 13\n    case _:\n        pass\n\nreveal_type(minor)  # revealed: Literal[13]\n```\n\n----------------------------------------\n\nTITLE: Invalid except* Handler Examples\nDESCRIPTION: Examples of invalid except* handlers demonstrating incorrect usage with non-exception types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/except_star.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    help()\nexcept* 3 as e:  # error: [invalid-exception-caught]\n    # TODO: Should be `BaseExceptionGroup[Unknown]` --Alex\n    reveal_type(e)  # revealed: BaseExceptionGroup\n\ntry:\n    help()\nexcept* (AttributeError, 42) as e:  # error: [invalid-exception-caught]\n    # TODO: Should be `BaseExceptionGroup[AttributeError | Unknown]` --Alex\n    reveal_type(e)  # revealed: BaseExceptionGroup\n```\n\n----------------------------------------\n\nTITLE: Static Assertions on Callable Types Disjointness\nDESCRIPTION: This snippet checks the disjointness of various callable types, utilizing static assertions to validate that no two callable types are disjoint. It references the knot_extensions and typing_extensions libraries to assert the relationships between callables and their subtypes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, is_disjoint_from, static_assert\nfrom typing_extensions import Callable, Literal, Never\n\ndef mixed(a: int, /, b: str, *args: int, c: int = 2, **kwargs: int) -> None: ...\n\nstatic_assert(not is_disjoint_from(Callable[[], Never], CallableTypeOf[mixed]))\nstatic_assert(not is_disjoint_from(Callable[[int, str], float], CallableTypeOf[mixed]))\n\nstatic_assert(not is_disjoint_from(Callable[..., None], Callable[[], None]))\nstatic_assert(not is_disjoint_from(Callable[..., None], Callable[..., None]))\nstatic_assert(not is_disjoint_from(Callable[..., None], Callable[[Literal[1]], None]))\n\nstatic_assert(not is_disjoint_from(Callable[[], Never], Callable[[], Never]))\nstatic_assert(not is_disjoint_from(Callable[[Never], str], Callable[[Never], int]))\n```\n\n----------------------------------------\n\nTITLE: Annotated Assignment with String Type Annotations in Python\nDESCRIPTION: Shows how string type annotations work with variable assignments, including both valid and invalid assignments with deferred type references.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\na: \"int\" = 1\nb: \"'int'\" = 1\nc: \"Foo\"\n# error: [invalid-assignment] \"Object of type `Literal[1]` is not assignable to `Foo`\"\nd: \"Foo\" = 1\n\nclass Foo: ...\n\nc = Foo()\n\nreveal_type(a)  # revealed: Literal[1]\nreveal_type(b)  # revealed: Literal[1]\nreveal_type(c)  # revealed: Foo\nreveal_type(d)  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Extending Configuration with src in ruff.toml\nDESCRIPTION: This snippet demonstrates the same configuration, but using `ruff.toml`. It highlights that extending configurations requires specifying the source directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n\"extend = \"../pyproject.toml\"\nsrc = [\"../src\"]\"\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Inheritance MRO\nDESCRIPTION: Tests type inference for multiple inheritance with linear MRO\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C(A, B): ...\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[A], Literal[B], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Deeply Qualified Module Import Type Usage\nDESCRIPTION: Shows type[] usage with deeply nested module imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport a.b\n\ndef f(c: type[a.b.C]):\n    reveal_type(c)  # revealed: type[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Type[object] Behavior in Python\nDESCRIPTION: Illustrates the differences between type[object] and type[Any], showing type revelation and assignment behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/dynamic.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: type[object]):\n    reveal_type(x)  # revealed: type\n    reveal_type(x.__repr__)  # revealed: bound method type.__repr__() -> str\n\nclass A: ...\n\nx: type[object] = object\nx: type[object] = type\nx: type[object] = A\nx: type[object] = A()  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Multi-line Parameters Test\nDESCRIPTION: Tests invalid argument type detection with parameters spread across multiple lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef foo(\n    x: int,\n    y: int,\n    z: int,\n) -> int:\n    return x * y * z\n\nfoo(1, \"hello\", 3)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Using type[...] with Union Types in Python\nDESCRIPTION: Shows how to use type annotations with unions of classes. When using type[A | B], the constructor returns a union type of A or B.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/subclass_of.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(subclass_of_ab: type[A | B]):\n    reveal_type(subclass_of_ab())  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with String Tuple Membership\nDESCRIPTION: Shows type checking behavior when testing string membership in a tuple. The type remains str in both branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str):\n    if x in (\"a\", \"b\", \"c\"):\n        reveal_type(x)  # revealed: str\n    else:\n        reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Class Restrictions within Generic Classes in Python\nDESCRIPTION: This snippet shows that nested generic classes should use distinct typevars from their parent classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\nclass C[T]:\n    class Ok1[S]: ...\n    # TODO: error for reuse of typevar\n    class Bad1[T]: ...\n    # TODO: no non-subscriptable error, error for reuse of typevar\n    # error: [non-subscriptable]\n    class Bad2(Iterable[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Mixed Decorator Classmethod\nDESCRIPTION: Shows how classmethods behave when combined with other decorators in different orders.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\ndef does_nothing[T](f: T) -> T:\n    return f\n\nclass C:\n    @classmethod\n    @does_nothing\n    def f1(cls: type[C], x: int) -> str:\n        return \"a\"\n\n    @does_nothing\n    @classmethod\n    def f2(cls: type[C], x: int) -> str:\n        return \"a\"\n\nreveal_type(C.f1(1))  # revealed: str\nreveal_type(C().f1(1))  # revealed: str\nreveal_type(C.f2(1))  # revealed: str\nreveal_type(C().f2(1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Testing Type Alias Syntax Error in Python\nDESCRIPTION: Shows parser behavior when using 'pass' keyword in a type alias declaration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [invalid-syntax]\ntype pass = 1\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Multiple Conditions and Simplification\nDESCRIPTION: Shows type narrowing with conditional assignments and subsequent negative checks. Demonstrates how the type system simplifies the remaining possible values after each condition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/nested.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = 1 if flag1 else 2 if flag2 else 3\n\n    if x != 1:\n        reveal_type(x)  # revealed: Literal[2, 3]\n        if x != 2:\n            reveal_type(x)  # revealed: Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Error: Invalid __enter__ Method Signature in Context Manager\nDESCRIPTION: Shows the error when the __enter__ method has an invalid signature (missing 'self' parameter), making it an incorrectly implemented context manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Manager:\n    def __enter__() -> str:\n        return \"foo\"\n\n    def __exit__(self, exc_type, exc_value, traceback): ...\n\ncontext_expr = Manager()\n\n# error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because it does not correctly implement `__enter__`\"\nwith context_expr as f:\n    reveal_type(f)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Usage Example: Match Case With Unnecessary Parentheses\nDESCRIPTION: Code example showing match-case statement with unnecessary parentheses that would be flagged for removal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmatch value:\n    case (pattern):\n        ...\n```\n\n----------------------------------------\n\nTITLE: Simple Relative Import in Python\nDESCRIPTION: This snippet shows a simple relative import from a sibling module within the same package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom .foo import X\n\nreveal_type(X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Method Calls on LiteralString in Python\nDESCRIPTION: Demonstrates method calls on LiteralString type, showing type inference for the find method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\ndef f(s: LiteralString) -> None:\n    reveal_type(s.find(\"a\"))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: If-Elif-Else Without Else Assignment\nDESCRIPTION: Shows type inference when the else branch contains no assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    y = 0\n\n    if flag:\n        y = 1\n    elif flag2:\n        y = 2\n    else:\n        pass\n\n    reveal_type(y)  # revealed: Literal[0, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Special-Case Int Literal Attributes\nDESCRIPTION: Shows special-cased int literal attributes that preserve the literal type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nreveal_type((2).numerator)  # revealed: Literal[2]\nreveal_type((2).real)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Return Statements in Nested Conditional Blocks\nDESCRIPTION: Shows how return statements in nested if-else statements affect control flow and type tracking. Demonstrates type inference when terminal statements appear at different nesting levels.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef return_in_nested_then_branch(cond1: bool, cond2: bool):\n    if cond1:\n        x = \"test1\"\n        reveal_type(x)  # revealed: Literal[\"test1\"]\n    else:\n        if cond2:\n            x = \"terminal\"\n            reveal_type(x)  # revealed: Literal[\"terminal\"]\n            return\n        else:\n            x = \"test2\"\n            reveal_type(x)  # revealed: Literal[\"test2\"]\n        reveal_type(x)  # revealed: Literal[\"test2\"]\n    reveal_type(x)  # revealed: Literal[\"test1\", \"test2\"]\n\ndef return_in_nested_else_branch(cond1: bool, cond2: bool):\n    if cond1:\n        x = \"test1\"\n        reveal_type(x)  # revealed: Literal[\"test1\"]\n    else:\n        if cond2:\n            x = \"test2\"\n            reveal_type(x)  # revealed: Literal[\"test2\"]\n        else:\n            x = \"terminal\"\n            reveal_type(x)  # revealed: Literal[\"terminal\"]\n            return\n        reveal_type(x)  # revealed: Literal[\"test2\"]\n    reveal_type(x)  # revealed: Literal[\"test1\", \"test2\"]\n\ndef return_in_both_nested_branches(cond1: bool, cond2: bool):\n    if cond1:\n        x = \"test\"\n        reveal_type(x)  # revealed: Literal[\"test\"]\n    else:\n        x = \"terminal0\"\n        if cond2:\n            x = \"terminal1\"\n            reveal_type(x)  # revealed: Literal[\"terminal1\"]\n            return\n        else:\n            x = \"terminal2\"\n            reveal_type(x)  # revealed: Literal[\"terminal2\"]\n            return\n    reveal_type(x)  # revealed: Literal[\"test\"]\n```\n\n----------------------------------------\n\nTITLE: Handling Possibly Unbound __call__ Method in Python\nDESCRIPTION: This snippet shows a scenario where the __call__ method might not be defined for all instances of a class, leading to a potential error when calling the instance as a function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class PossiblyNotCallable:\n        if flag:\n            def __call__(self) -> int:\n                return 1\n\n    a = PossiblyNotCallable()\n    result = a()  # error: \"Object of type `PossiblyNotCallable` is not callable (possibly unbound `__call__` method)\"\n    reveal_type(result)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Complex Boolean Expression Type Inference in Python\nDESCRIPTION: This snippet shows type inference for complex boolean expressions combining AND and OR operators with different literals. It demonstrates how the type system evaluates these expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(\"x\" and \"y\" or \"z\")  # revealed: Literal[\"y\"]\nreveal_type(\"x\" or \"y\" and \"z\")  # revealed: Literal[\"x\"]\nreveal_type(\"\" and \"y\" or \"z\")  # revealed: Literal[\"z\"]\nreveal_type(\"\" or \"y\" and \"z\")  # revealed: Literal[\"z\"]\nreveal_type(\"x\" and \"y\" or \"\")  # revealed: Literal[\"y\"]\nreveal_type(\"x\" or \"y\" and \"\")  # revealed: Literal[\"x\"]\n```\n\n----------------------------------------\n\nTITLE: Consistent Super Behavior with Union Types in Python\nDESCRIPTION: Demonstrates how super() constructed separately for each branch of a union still behaves consistently, showing correct type inference and error checking for attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef f(flag: bool):\n    if flag:\n        class A:\n            x = 1\n            y: int = 1\n\n            a: str = \"hello\"\n\n        class B(A): ...\n        s = super(B, B())\n    else:\n        class C:\n            x = 2\n            y: int | str = \"test\"\n\n        class D(C): ...\n        s = super(D, D())\n\n    reveal_type(s)  # revealed: <super: Literal[B], B> | <super: Literal[D], D>\n\n    reveal_type(s.x)  # revealed: Unknown | Literal[1, 2]\n    reveal_type(s.y)  # revealed: int | str\n\n    # error: [possibly-unbound-attribute] \"Attribute `a` on type `<super: Literal[B], B> | <super: Literal[D], D>` is possibly unbound\"\n    reveal_type(s.a)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement with Wildcard Pattern in Python\nDESCRIPTION: Shows type analysis for a match statement with a wildcard pattern where the scrutinee is statically known to match one of the non-wildcard patterns. The variable 'x' will always have the value 2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nmatch \"a\":\n    case \"a\":\n        x = 2\n    case \"b\":\n        x = 3\n    case _:\n        pass\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Revealing Types of Unary Addition Operations in Python\nDESCRIPTION: Demonstrates how unary addition (+) affects the revealed types of literal values and boolean True. The type checker identifies that the result maintains the same literal value type as the operand.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/integers.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(+0)  # revealed: Literal[0]\nreveal_type(+1)  # revealed: Literal[1]\nreveal_type(+True)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Visualizing Super Resolution Results with Matplotlib\nDESCRIPTION: This snippet uses matplotlib to display the original low-resolution image, the super-resolution result from ESRGAN, and a bicubic interpolation for comparison.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlr = tf.cast(tf.squeeze(lr, axis=0), tf.uint8)\nplt.figure(figsize = (1, 1))\nplt.title('LR')\nplt.imshow(lr.numpy());\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)        \nplt.title(f'ESRGAN (x4)')\nplt.imshow(sr.numpy());\n\nbicubic = tf.image.resize(lr, [200, 200], tf.image.ResizeMethod.BICUBIC)\nbicubic = tf.cast(bicubic, tf.uint8)\nplt.subplot(1, 2, 2)   \nplt.title('Bicubic')\nplt.imshow(bicubic.numpy());\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Alias Assignment\nDESCRIPTION: Demonstrates type checking with invalid assignment to a type alias.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntype OptionalInt = int | None\n\n# error: [invalid-assignment]\nx: OptionalInt = \"1\"\n```\n\n----------------------------------------\n\nTITLE: Return Type Revelation in Python\nDESCRIPTION: Demonstration of how reveal_type shows the annotated return type rather than the inferred type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(f())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Implementing __len__ with Negative Integers in Python\nDESCRIPTION: This snippet demonstrates a custom class implementation of `__len__` that returns a negative integer. It highlights the need for a diagnostic to be emitted in this case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Negative:\n    def __len__(self) -> Literal[-1]:\n        return -1\n\n# TODO: Emit a diagnostic\nreveal_type(len(Negative()))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Class Pattern Match Type Narrowing\nDESCRIPTION: Shows type narrowing when matching against class patterns. Demonstrates how the type of x changes within different case blocks for classes A and B.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nclass A: ...\nclass B: ...\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case A():\n        reveal_type(x)  # revealed: A\n    case B():\n        # TODO could be `B & ~A`\n        reveal_type(x)  # revealed: B\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Creating Type Intersections in Python\nDESCRIPTION: Shows how to use the Intersection special form to combine multiple types. Includes examples of type revelation, subtype testing, and complex intersection type composition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not, is_subtype_of, static_assert\nfrom typing_extensions import Literal, Never\n\nclass S: ...\nclass T: ...\n\ndef x(x1: Intersection[S, T], x2: Intersection[S, Not[T]]) -> None:\n    reveal_type(x1)  # revealed: S & T\n    reveal_type(x2)  # revealed: S & ~T\n\ndef y(y1: Intersection[int, object], y2: Intersection[int, bool], y3: Intersection[int, Never]) -> None:\n    reveal_type(y1)  # revealed: int\n    reveal_type(y2)  # revealed: bool\n    reveal_type(y3)  # revealed: Never\n\ndef z(z1: Intersection[int, Not[Literal[1]], Not[Literal[2]]]) -> None:\n    reveal_type(z1)  # revealed: int & ~Literal[1] & ~Literal[2]\n\nclass A: ...\nclass B: ...\nclass C: ...\n\ntype ABC = Intersection[A, B, C]\n\nstatic_assert(is_subtype_of(ABC, A))\nstatic_assert(is_subtype_of(ABC, B))\nstatic_assert(is_subtype_of(ABC, C))\n\nclass D: ...\n\nstatic_assert(not is_subtype_of(ABC, D))\n```\n\n----------------------------------------\n\nTITLE: Conditional Type Annotation with 'if False...else' in Python\nDESCRIPTION: Demonstrates how type annotations in always-executed else blocks override previous annotations. The variable 'x' becomes an int despite the earlier string annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nx: str\n\nif False:\n    pass\nelse:\n    x: int\n\ndef f() -> None:\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Custom isinstance() Function\nDESCRIPTION: Demonstrates that type narrowing doesn't occur with custom isinstance() implementations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    def isinstance(x, t):\n        return True\n    x = 1 if flag else \"a\"\n\n    if isinstance(x, int):\n        reveal_type(x)  # revealed: Literal[1, \"a\"]\n```\n\n----------------------------------------\n\nTITLE: Comparing Tuples of Different Lengths in Python\nDESCRIPTION: Illustrates how comparisons are handled when tuples have different lengths. The results are still definitive boolean literals, taking into account the lexicographic ordering of tuples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na = (1, 2, 3)\nb = (1, 2, 3, 4)\n\nreveal_type(a == b)  # revealed: Literal[False]\nreveal_type(a != b)  # revealed: Literal[True]\nreveal_type(a < b)  # revealed: Literal[True]\nreveal_type(a <= b)  # revealed: Literal[True]\nreveal_type(a > b)  # revealed: Literal[False]\nreveal_type(a >= b)  # revealed: Literal[False]\n\nc = (\"a\", \"b\", \"c\", \"d\")\nd = (\"a\", \"b\", \"c\")\n\nreveal_type(c == d)  # revealed: Literal[False]\nreveal_type(c != d)  # revealed: Literal[True]\nreveal_type(c < d)  # revealed: Literal[False]\nreveal_type(c <= d)  # revealed: Literal[False]\nreveal_type(c > d)  # revealed: Literal[True]\nreveal_type(c >= d)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Implicit Global Variable Access in Function\nDESCRIPTION: Demonstrates how Python handles references to variables that are defined globally when accessed from within a function scope.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/nonlocal.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ndef f():\n    reveal_type(x)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Accessing attributes on Never type in Python\nDESCRIPTION: This example illustrates that arbitrary attributes can be accessed on the `Never` type without triggering type errors. It showcases that assigning `Never` to an attribute on `Never` is also permissible. The revealed type of `never.arbitrary_attribute` is `Never`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_48\n\nLANGUAGE: python\nCODE:\n```\n```py\nfrom typing_extensions import Never\n\ndef f(never: Never):\n    reveal_type(never.arbitrary_attribute)  # revealed: Never\n\n    # Assigning `Never` to an attribute on `Never` is also allowed:\n    never.another_attribute = never\n```\n```\n\n----------------------------------------\n\nTITLE: Multiple Error Code Suppression in Python\nDESCRIPTION: Shows how to suppress multiple specific error types in a single line by listing them in the knot: ignore directive separated by commas.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\ndef test(a: f\"f-string type annotation\", b: b\"byte-string-type-annotation\"): ...  # knot: ignore[fstring-type-annotation, byte-string-type-annotation]\n```\n\n----------------------------------------\n\nTITLE: Undeclared and Unbound Symbol Usage in Python\nDESCRIPTION: Demonstrates type inference for undeclared and unbound symbols, showing Unknown type inference and error raising.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    a: int = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom mod import a\n\nreveal_type(a)  # revealed: Unknown\n\n# Modifications allowed in this case:\na = None\n```\n\n----------------------------------------\n\nTITLE: Using Typing Module Aliases in Function Parameters with Type Revelation\nDESCRIPTION: This snippet demonstrates how typing module aliases map to their standard library counterparts. It defines a function with parameters using various typing module aliases (both bare and parametrized versions) and reveals their actual types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/stdlib_typing_aliases.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\ndef f(\n    list_bare: typing.List,\n    list_parametrized: typing.List[int],\n    dict_bare: typing.Dict,\n    dict_parametrized: typing.Dict[int, str],\n    set_bare: typing.Set,\n    set_parametrized: typing.Set[int],\n    frozen_set_bare: typing.FrozenSet,\n    frozen_set_parametrized: typing.FrozenSet[str],\n    chain_map_bare: typing.ChainMap,\n    chain_map_parametrized: typing.ChainMap[int],\n    counter_bare: typing.Counter,\n    counter_parametrized: typing.Counter[int],\n    default_dict_bare: typing.DefaultDict,\n    default_dict_parametrized: typing.DefaultDict[str, int],\n    deque_bare: typing.Deque,\n    deque_parametrized: typing.Deque[str],\n    ordered_dict_bare: typing.OrderedDict,\n    ordered_dict_parametrized: typing.OrderedDict[int, str],\n):\n    reveal_type(list_bare)  # revealed: list\n    reveal_type(list_parametrized)  # revealed: list\n\n    reveal_type(dict_bare)  # revealed: dict\n    reveal_type(dict_parametrized)  # revealed: dict\n\n    reveal_type(set_bare)  # revealed: set\n    reveal_type(set_parametrized)  # revealed: set\n\n    reveal_type(frozen_set_bare)  # revealed: frozenset\n    reveal_type(frozen_set_parametrized)  # revealed: frozenset\n\n    reveal_type(chain_map_bare)  # revealed: ChainMap\n    reveal_type(chain_map_parametrized)  # revealed: ChainMap\n\n    reveal_type(counter_bare)  # revealed: Counter\n    reveal_type(counter_parametrized)  # revealed: Counter\n\n    reveal_type(default_dict_bare)  # revealed: defaultdict\n    reveal_type(default_dict_parametrized)  # revealed: defaultdict\n\n    reveal_type(deque_bare)  # revealed: deque\n    reveal_type(deque_parametrized)  # revealed: deque\n\n    reveal_type(ordered_dict_bare)  # revealed: OrderedDict\n    reveal_type(ordered_dict_parametrized)  # revealed: OrderedDict\n```\n\n----------------------------------------\n\nTITLE: Abstract Method Return Types\nDESCRIPTION: Examples of abstract method definitions with return type annotations in abstract base classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom abc import ABC, abstractmethod\n\nclass Foo(ABC):\n    @abstractmethod\n    def f(self) -> int: ...\n    @abstractmethod\n    def g[T](self, x: T) -> T: ...\n\nclass Bar[T](ABC):\n    @abstractmethod\n    def f(self) -> int: ...\n    @abstractmethod\n    def g[T](self, x: T) -> T: ...\n\n# error: [invalid-return-type]\ndef f() -> int: ...\n@abstractmethod  # Semantically meaningless, accepted nevertheless\ndef g() -> int: ...\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Collection-based AST Nodes in Python Type Expressions\nDESCRIPTION: This snippet demonstrates invalid collection-based AST nodes in type expressions, including dict literals, set literals, dict comprehensions, list comprehensions, set comprehensions, generator expressions, and list literals in certain contexts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/invalid.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(\n    a: {1: 2},  # error: [invalid-type-form] \"Dict literals are not allowed in type expressions\"\n    b: {1, 2},  # error: [invalid-type-form] \"Set literals are not allowed in type expressions\"\n    c: {k: v for k, v in [(1, 2)]},  # error: [invalid-type-form] \"Dict comprehensions are not allowed in type expressions\"\n    d: [k for k in [1, 2]],  # error: [invalid-type-form] \"List comprehensions are not allowed in type expressions\"\n    e: {k for k in [1, 2]},  # error: [invalid-type-form] \"Set comprehensions are not allowed in type expressions\"\n    f: (k for k in [1, 2]),  # error: [invalid-type-form] \"Generator expressions are not allowed in type expressions\"\n    g: [int, str],  # error: [invalid-type-form] \"List literals are not allowed in this context in a type expression\"\n):\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n    reveal_type(c)  # revealed: Unknown\n    reveal_type(d)  # revealed: Unknown\n    reveal_type(e)  # revealed: Unknown\n    reveal_type(f)  # revealed: Unknown\n    reveal_type(g)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Imported Class Literal Type Usage\nDESCRIPTION: Shows how to use type[] with imported classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom a import A\n\ndef f(c: type[A]):\n    reveal_type(c)  # revealed: type[A]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n```\n\n----------------------------------------\n\nTITLE: Testing NoDefaultType as Singleton in Python 3.13\nDESCRIPTION: Tests that _NoDefaultType is recognized as a singleton type in Python 3.13, importing from typing rather than typing_extensions. Sets the Python version using TOML configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.13\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import _NoDefaultType\nfrom knot_extensions import is_singleton, static_assert\n\nstatic_assert(is_singleton(_NoDefaultType))\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with descriptor as __new__ method in Python\nDESCRIPTION: Shows the behavior of using a descriptor as the __new__ method, including type checking and error handling for different argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass SomeCallable:\n    def __call__(self, cls, x: int) -> \"Foo\":\n        obj = object.__new__(cls)\n        obj.x = x\n        return obj\n\nclass Descriptor:\n    def __get__(self, instance, owner) -> SomeCallable:\n        return SomeCallable()\n\nclass Foo:\n    __new__: Descriptor = Descriptor()\n\nreveal_type(Foo(1))  # revealed: Foo\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\nreveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Invalid __slots__ Definitions in Python\nDESCRIPTION: Shows examples of invalid __slots__ definitions, including non-string values, non-identifier strings, and generator expressions. These definitions are problematic and should emit diagnostics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass NonString1:\n    __slots__ = 42\n\nclass NonString2:\n    __slots__ = b\"ar\"\n\nclass NonIdentifier1:\n    __slots__ = \"42\"\n\nclass NonIdentifier2:\n    __slots__ = (\"lorem\", \"42\")\n\nclass NonIdentifier3:\n    __slots__ = (e for e in (\"lorem\", \"42\"))\n```\n\n----------------------------------------\n\nTITLE: Complex Lambda Expression with Mixed Parameter Types in Python\nDESCRIPTION: Demonstrates a complex lambda expression combining various parameter types and their type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# revealed: (a, b, /, c=Literal[True], *args, *, d=Literal[\"default\"], e=Literal[5], **kwargs) -> Unknown\nreveal_type(lambda a, b, /, c=True, *args, d=\"default\", e=5, **kwargs: None)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Comparison Operators in Python Type Checking\nDESCRIPTION: Example function showing various type checking errors when using comparison operators with incompatible types. Includes cases with literals, objects, and custom classes that demonstrate invalid usage of 'in', 'not in', and '<' operators.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/unsupported.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag1: bool, flag2: bool):\n    class A: ...\n    a = 1 in 7  # error: \"Operator `in` is not supported for types `Literal[1]` and `Literal[7]`\"\n    reveal_type(a)  # revealed: bool\n\n    b = 0 not in 10  # error: \"Operator `not in` is not supported for types `Literal[0]` and `Literal[10]`\"\n    reveal_type(b)  # revealed: bool\n\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `object` and `int`, in comparing `object` with `Literal[5]`\"\n    c = object() < 5\n    reveal_type(c)  # revealed: Unknown\n\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `int` and `object`, in comparing `Literal[5]` with `object`\"\n    d = 5 < object()\n    reveal_type(d)  # revealed: Unknown\n\n    int_literal_or_str_literal = 1 if flag else \"foo\"\n    # error: \"Operator `in` is not supported for types `Literal[42]` and `Literal[1]`, in comparing `Literal[42]` with `Literal[1, \"foo\"]`\"\n    e = 42 in int_literal_or_str_literal\n    reveal_type(e)  # revealed: bool\n\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `int` and `str`, in comparing `tuple[Literal[1], Literal[2]]` with `tuple[Literal[1], Literal[\"hello\"]]`\"\n    f = (1, 2) < (1, \"hello\")\n    reveal_type(f)  # revealed: Unknown\n\n    # error: [unsupported-operator] \"Operator `<` is not supported for types `A` and `A`, in comparing `tuple[bool, A]` with `tuple[bool, A]`\"\n    g = (flag1, A()) < (flag2, A())\n    reveal_type(g)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Union Types in Python\nDESCRIPTION: Shows how type inference handles 'not' with variables that can have different types depending on control flow, resulting in a mix of concrete literal types and general bool types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        p = 1\n        q = 3.3\n        r = \"hello\"\n        s = \"world\"\n        t = 0\n    else:\n        p = \"hello\"\n        q = 4\n        r = \"\"\n        s = 0\n        t = \"\"\n\n    reveal_type(not p)  # revealed: Literal[False]\n    reveal_type(not q)  # revealed: bool\n    reveal_type(not r)  # revealed: bool\n    reveal_type(not s)  # revealed: bool\n    reveal_type(not t)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Class Instance Assignment\nDESCRIPTION: Shows class definition and instance creation with semicolon.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\np = Point(0, 0);\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Version in Environment\nDESCRIPTION: TOML configuration setting the Python version requirement to 3.9\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\n----------------------------------------\n\nTITLE: Emitting Diagnostics for Definitely Wrong Code in Unreachable Sections in Python\nDESCRIPTION: Shows that even in unreachable code blocks, Ruff still emits diagnostics for code that is definitely incorrect, such as unsupported operators and division by zero operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    1 + \"a\"  # error: [unsupported-operator]\n\ndef f():\n    return\n\n    1 / 0  # error: [division-by-zero]\n```\n\n----------------------------------------\n\nTITLE: Importing from Modules with Empty __all__\nDESCRIPTION: Shows behavior when importing from modules with empty __all__ attributes. No symbols should be imported, but the type checker currently allows access to X and Y.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\nfrom b import *\n\n# TODO: both of these should have [unresolved-reference] diagnostics and reveal `Unknown`\nreveal_type(X)  # revealed: bool\nreveal_type(Y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Defining Re-exports in Python Stub File\nDESCRIPTION: This stub file (b.pyi) demonstrates how to re-export symbols. It imports and re-exports foo as a module, and Any and Literal from typing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport foo as foo\nfrom typing import Any as Any, Literal as Literal\n```\n\n----------------------------------------\n\nTITLE: Unsupported String Slice Types in Python\nDESCRIPTION: Demonstrates a case where string values are incorrectly used as slice indices. The TODO comment explains that this should raise an error once the type system has better support for overloads, generics, and more precise annotations for string slicing operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/string.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# TODO: It would be great if we raised an error here. This can be done once\n# we have support for overloads and generics, and once typeshed has a more\n# precise annotation for `str.__getitem__`, that makes use of the generic\n# `slice[..]` type. We could then infer `slice[str, str]` here and see that\n# it doesn't match the signature of `str.__getitem__`.\n\"foo\"[\"bar\":\"baz\"]\n```\n\n----------------------------------------\n\nTITLE: Guard with Object Implementing __bool__ Incorrectly in Python\nDESCRIPTION: This snippet demonstrates a case where a guard condition is used with an object that implements __bool__ incorrectly. It shows how this affects type inference and raises an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/match.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\ndef _(target: int, flag: NotBoolable):\n    y = 1\n    match target:\n        # error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\n        case 1 if flag:\n            y = 2\n        case 2:\n            y = 3\n\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Power Edge Cases Type Checking in Python\nDESCRIPTION: Demonstrates type inference for power operations with zero and negative numbers, showing when int or float types are returned.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/integers.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1**0)  # revealed: Literal[1]\nreveal_type(0**1)  # revealed: Literal[0]\nreveal_type(0**0)  # revealed: Literal[1]\nreveal_type((-1) ** 2)  # revealed: Literal[1]\nreveal_type(2 ** (-1))  # revealed: float\nreveal_type((-1) ** (-1))  # revealed: float\n```\n\n----------------------------------------\n\nTITLE: Handling Non-callable __call__ Attribute in Python\nDESCRIPTION: This snippet shows what happens when the __call__ attribute is set to a non-callable value, resulting in a type error when attempting to call the instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass NonCallable:\n    __call__ = 1\n\na = NonCallable()\n# error: [call-non-callable] \"Object of type `Literal[1]` is not callable\"\nreveal_type(a())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Except-Else Block\nDESCRIPTION: This snippet demonstrates type inference in a try-except-else block. It shows how the final inferred type is determined by the possible execution paths through the try, except, and else suites.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef could_raise_returns_str() -> str:\n    return \"foo\"\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\nelse:\n    reveal_type(x)  # revealed: str\n    x = 3\n    reveal_type(x)  # revealed: Literal[3]\n\nreveal_type(x)  # revealed: Literal[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Classes with Attributes\nDESCRIPTION: Creates a deeply nested class structure with attributes that can be accessed through the module import path.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nclass Outer:\n    class Nested:\n        class Inner:\n            attr: int = 1\n```\n\n----------------------------------------\n\nTITLE: Conditionally Defined __all__ in Python 3.11\nDESCRIPTION: Demonstrates how __all__ can be conditionally defined in a statically known branch based on Python version. The type checker can statically resolve which branch applies for Python 3.11.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\n----------------------------------------\n\nTITLE: Bare Type Usage in Python\nDESCRIPTION: Shows the interpretation of bare 'type' annotation and its behavior with different assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/dynamic.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: type):\n    reveal_type(x)  # revealed: type\n    reveal_type(x.__repr__)  # revealed: bound method type.__repr__() -> str\n\nclass A: ...\n\nx: type = object\nx: type = type\nx: type = A\nx: type = A()  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Invalid Protocol Usage Example in Python Type Checking\nDESCRIPTION: Shows an invalid use case of typing.Protocol in type expressions, which results in an error. Demonstrates what is not supported in the current implementation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/protocols.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol\n\n# error: [invalid-type-form] \"`typing.Protocol` is not allowed in type expressions\"\ndef f(x: Protocol) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Invalid Metaclass Example\nDESCRIPTION: Demonstrates an invalid metaclass that doesn't inherit from type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass M: ...\nclass A(metaclass=M): ...\n\n# TODO: emit a diagnostic for the invalid metaclass\nreveal_type(A.__class__)  # revealed: Literal[M]\n```\n\n----------------------------------------\n\nTITLE: TYPE_CHECKING from typing_extensions\nDESCRIPTION: Demonstrates TYPE_CHECKING usage when imported from typing_extensions, showing identical behavior to typing.TYPE_CHECKING.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TYPE_CHECKING\n\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Simple If Statement Type Analysis\nDESCRIPTION: Demonstrates type inference for a variable modified within a simple if statement block. Shows how the type system tracks possible values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    y = 1\n    y = 2\n\n    if flag:\n        y = 3\n\n    reveal_type(y)  # revealed: Literal[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Union Type Inference in If-Expression\nDESCRIPTION: Demonstrates how type inference works with boolean flags in if-expressions, resulting in a union of literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/if.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    reveal_type(1 if flag else 2)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Slicing Bytes Objects in Python\nDESCRIPTION: Demonstrates accessing subsets of bytes objects using slice notation. Shows type checking with reveal_type calls, error handling for invalid slice parameters like zero step size, and includes TODOs about overload support in function contexts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/bytes.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nb: bytes = b\"\\x00abc\\xff\"\n\nreveal_type(b[0:2])  # revealed: Literal[b\"\\x00a\"]\nreveal_type(b[-3:])  # revealed: Literal[b\"bc\\xff\"]\n\nb[0:4:0]  # error: [zero-stepsize-in-slice]\nb[:4:0]  # error: [zero-stepsize-in-slice]\nb[0::0]  # error: [zero-stepsize-in-slice]\nb[::0]  # error: [zero-stepsize-in-slice]\n\ndef _(m: int, n: int):\n    byte_slice1 = b[m:n]\n    # TODO: Support overloads... Should be `bytes`\n    reveal_type(byte_slice1)  # revealed: @Todo(return type of overloaded function)\n\ndef _(s: bytes) -> bytes:\n    byte_slice2 = s[0:5]\n    # TODO: Support overloads... Should be `bytes`\n    return reveal_type(byte_slice2)  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Non-callable Elements in a Union Type\nDESCRIPTION: Demonstrates the error that occurs when trying to call a union type where one element is not callable, resulting in a diagnostic message.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        f = 1\n    else:\n        def f() -> int:\n            return 1\n    x = f()  # error: [call-non-callable] \"Object of type `Literal[1]` is not callable\"\n    reveal_type(x)  # revealed: Unknown | int\n```\n\n----------------------------------------\n\nTITLE: Special Handling of Equality and Inequality in Tuple Comparisons in Python\nDESCRIPTION: Demonstrates the unique behavior of equality and inequality operators in lexicographic comparisons of tuples. These operators can provide definite results even when other comparison operators remain ambiguous.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str, y: int):\n    reveal_type(\"foo\" == \"bar\")  # revealed: Literal[False]\n    reveal_type((\"foo\",) == (\"bar\",))  # revealed: Literal[False]\n    reveal_type((4, \"foo\") == (4, \"bar\"))  # revealed: Literal[False]\n    reveal_type((y, \"foo\") == (y, \"bar\"))  # revealed: Literal[False]\n\n    a = (x, y, \"foo\")\n\n    reveal_type(a == a)  # revealed: bool\n    reveal_type(a != a)  # revealed: bool\n    reveal_type(a < a)  # revealed: bool\n    reveal_type(a <= a)  # revealed: bool\n    reveal_type(a > a)  # revealed: bool\n    reveal_type(a >= a)  # revealed: bool\n\n    b = (x, y, \"bar\")\n\n    reveal_type(a == b)  # revealed: Literal[False]\n    reveal_type(a != b)  # revealed: Literal[True]\n    reveal_type(a < b)  # revealed: bool\n    reveal_type(a <= b)  # revealed: bool\n    reveal_type(a > b)  # revealed: bool\n    reveal_type(a >= b)  # revealed: bool\n\n    c = (x, y, \"foo\", \"different_length\")\n\n    reveal_type(a == c)  # revealed: Literal[False]\n    reveal_type(a != c)  # revealed: Literal[True]\n    reveal_type(a < c)  # revealed: bool\n    reveal_type(a <= c)  # revealed: bool\n    reveal_type(a > c)  # revealed: bool\n    reveal_type(a >= c)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Analyzing Negative Contributions to Intersection Types with Integers in Python\nDESCRIPTION: This snippet demonstrates negative contributions to intersection types using integer comparisons. It shows type narrowing and expected type revelations for equality checks with integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int):\n    if x != 1:\n        reveal_type(x)  # revealed: int & ~Literal[1]\n\n        reveal_type(x != 1)  # revealed: bool\n        reveal_type(x != 2)  # revealed: bool\n\n        reveal_type(x == 1)  # revealed: bool\n        reveal_type(x == 2)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Default Argument in Python Function\nDESCRIPTION: This function demonstrates the potential issue of using a mutable default argument (set). Mutable default arguments can lead to unexpected behavior if the function is called multiple times.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/valid.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef mutable_argument(z=set()):\n  print(f\"cell two: {z}\")\n\nmutable_argument()\n```\n\n----------------------------------------\n\nTITLE: Old-Style Union of Classes Type Usage\nDESCRIPTION: Shows type[] usage with typing.Union for class unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nclass BasicUser: ...\nclass ProUser: ...\n\nclass A:\n    class B:\n        class C: ...\n\ndef f(a: type[Union[BasicUser, ProUser, A.B.C]], b: type[Union[str]], c: type[Union[BasicUser, Union[ProUser, A.B.C]]]):\n    reveal_type(a)  # revealed: type[BasicUser] | type[ProUser] | type[C]\n    reveal_type(b)  # revealed: type[str]\n    reveal_type(c)  # revealed: type[BasicUser] | type[ProUser] | type[C]\n```\n\n----------------------------------------\n\nTITLE: Unreachable Bindings After Terminal Statements in Python\nDESCRIPTION: This example shows how Ruff's type checker handles bindings after terminal statements. Code after a return statement is considered unreachable, resulting in the 'Never' type, while code in other branches is correctly analyzed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef f(cond: bool) -> str:\n    x = \"before\"\n    if cond:\n        reveal_type(x)  # revealed: Literal[\"before\"]\n        return \"a\"\n        x = \"after-return\"\n        reveal_type(x)  # revealed: Never\n    else:\n        x = \"else\"\n    return reveal_type(x)  # revealed: Literal[\"else\"]\n```\n\n----------------------------------------\n\nTITLE: Multiple OR Conditions Type Narrowing - Python\nDESCRIPTION: Shows type narrowing with multiple 'or' conditions in different arrangements, demonstrating type revelation patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool, flag3: bool, flag4: bool):\n    class A: ...\n    x: A | None = A() if flag1 else None\n\n    flag2 or isinstance(x, A) or reveal_type(x)  # revealed: None\n    isinstance(x, A) or flag3 or reveal_type(x)  # revealed: None\n    reveal_type(x) or isinstance(x, A) or flag4  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Nested Expression Semicolon\nDESCRIPTION: Example of semicolon usage within a conditional block\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Nested expressions isn't relevant\nif True:\n    x;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Possibly Unbound Variables in Python\nDESCRIPTION: This snippet shows a scenario where a variable 'y' is conditionally assigned, leading to a possibly unresolved reference. It also demonstrates type revealing for both 'x' and 'y'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    y = 3\n\nx = y  # error: [possibly-unresolved-reference]\n\n# revealed: Literal[3]\nreveal_type(x)\n\n# revealed: Literal[3]\n# error: [possibly-unresolved-reference]\nreveal_type(y)\n```\n\n----------------------------------------\n\nTITLE: Custom Literal Implementation Detection\nDESCRIPTION: Shows how Python handles Literal types from non-standard modules and the typing_extensions module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom other import Literal\n\n# TODO: can we add a subdiagnostic here saying something like:\n#\n#     `other.Literal` and `typing.Literal` have similar names, but are different symbols and don't have the same semantics\n#\n# ?\n#\n# error: [invalid-type-form] \"Int literals are not allowed in this context in a type expression\"\na1: Literal[26]\n\ndef f():\n    reveal_type(a1)  # revealed: @Todo(generics)\n```\n\n----------------------------------------\n\nTITLE: Revealing Unknown Type for Later-Defined Builtin in Python\nDESCRIPTION: This snippet reveals the type of a builtin symbol that depends on a later-defined symbol, resulting in an Unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(foo)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: One Non-callable, One Wrong Argument in Union\nDESCRIPTION: Demonstrates error handling when a union contains both a non-callable element and a callable element that receives incorrect arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\ndef f1(): ...\ndef _(flag: bool):\n    if flag:\n        f = f1\n    else:\n        f = C()\n\n    # TODO: we should either show all union errors here, or prioritize the not-callable error\n    # error: [too-many-positional-arguments] \"Too many positional arguments to function `f1`: expected 0, got 1\"\n    x = f(3)\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Simple String Type Annotation in Python\nDESCRIPTION: Demonstrates a basic string type annotation where a variable is annotated with a quoted type name. When using string annotations, the type is resolved correctly.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f(v: \"int\"):\n    reveal_type(v)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Union Types in Python\nDESCRIPTION: This code shows disjointness properties of union types (expressed as Literal with multiple values). Unions are disjoint when they have no common members, but non-disjoint when they share at least one member.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal\nfrom knot_extensions import Intersection, is_disjoint_from, static_assert\n\nstatic_assert(is_disjoint_from(Literal[1, 2], Literal[3]))\nstatic_assert(is_disjoint_from(Literal[1, 2], Literal[3, 4]))\n\nstatic_assert(not is_disjoint_from(Literal[1, 2], Literal[2]))\nstatic_assert(not is_disjoint_from(Literal[1, 2], Literal[2, 3]))\n```\n\n----------------------------------------\n\nTITLE: Division by Zero Type Checking in Python\nDESCRIPTION: Shows type checking behavior for division by zero cases, including regular division, floor division, and modulo operations. Demonstrates error handling for different numeric types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/integers.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = 1 / 0  # error: \"Cannot divide object of type `Literal[1]` by zero\"\nreveal_type(a)  # revealed: float\n\nb = 2 // 0  # error: \"Cannot floor divide object of type `Literal[2]` by zero\"\nreveal_type(b)  # revealed: int\n\nc = 3 % 0  # error: \"Cannot reduce object of type `Literal[3]` modulo zero\"\nreveal_type(c)  # revealed: int\n\n# error: \"Cannot divide object of type `int` by zero\"\nreveal_type(int() / 0)  # revealed: int | float\n\n# error: \"Cannot divide object of type `Literal[1]` by zero\"\nreveal_type(1 / False)  # revealed: float\n# error: [division-by-zero] \"Cannot divide object of type `Literal[True]` by zero\"\nTrue / False\n# error: [division-by-zero] \"Cannot divide object of type `Literal[True]` by zero\"\nbool(1) / False\n\n# error: \"Cannot divide object of type `float` by zero\"\nreveal_type(1.0 / 0)  # revealed: int | float\n\nclass MyInt(int): ...\n\n# No error for a subclass of int\nreveal_type(MyInt(3) / 0)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Never Type Handling\nDESCRIPTION: Demonstrates how Never and NoReturn types are removed from unions as they represent empty sets.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Never, NoReturn\n\ndef never(u1: int | Never, u2: int | Never | str) -> None:\n    reveal_type(u1)  # revealed: int\n    reveal_type(u2)  # revealed:  int | str\n\ndef noreturn(u1: int | NoReturn, u2: int | NoReturn | str) -> None:\n    reveal_type(u1)  # revealed: int\n    reveal_type(u2)  # revealed:  int | str\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Typeshed in Test Configuration\nDESCRIPTION: This TOML configuration snippet shows how to override the default typeshed with a custom one for specific tests. It sets the typeshed path to \"/typeshed\".\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Variable Integer Literal Type Inference\nDESCRIPTION: Demonstrates type inference for an integer literal assigned to a variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Nested Boolean Expressions with Short-Circuit Evaluation in Python\nDESCRIPTION: This code demonstrates the behavior of nested boolean expressions with short-circuit evaluation. It shows how variable assignments and type revelations interact in complex conditional statements using 'and' and 'or' operators.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    if flag1 or ((x := 1) and flag2):\n        # error: [possibly-unresolved-reference]\n        reveal_type(x)  # revealed: Literal[1]\n\n    if ((y := 1) and flag1) or flag2:\n        reveal_type(y)  # revealed: Literal[1]\n\n    # error: [possibly-unresolved-reference]\n    if (flag1 and (z := 1)) or reveal_type(z):  # revealed: Literal[1]\n        # error: [possibly-unresolved-reference]\n        reveal_type(z)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: NoReturn Type Annotation Example\nDESCRIPTION: Example showing unreachable code after a function call annotated with NoReturn type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import NoReturn\n\ndef always_raises() -> NoReturn:\n    raise Exception()\n\ndef f():\n    always_raises()\n\n    # TODO: we should mark this as unreachable\n    print(\"unreachable\")\n```\n\n----------------------------------------\n\nTITLE: Testing Identity Operator Type Checking in Python\nDESCRIPTION: Demonstrates how type checking works with Python's identity operators ('is' and 'is not') across different object types including custom class instances, None values, and generic objects. Shows how the type checker infers literal boolean values in some cases and general boolean types in others.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/identity.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\ndef _(a1: A, a2: A, o: object):\n    n1 = None\n    n2 = None\n\n    reveal_type(a1 is a1)  # revealed: bool\n    reveal_type(a1 is a2)  # revealed: bool\n\n    reveal_type(n1 is n1)  # revealed: Literal[True]\n    reveal_type(n1 is n2)  # revealed: Literal[True]\n\n    reveal_type(a1 is n1)  # revealed: Literal[False]\n    reveal_type(n1 is a1)  # revealed: Literal[False]\n\n    reveal_type(a1 is o)  # revealed: bool\n    reveal_type(n1 is o)  # revealed: bool\n\n    reveal_type(a1 is not a1)  # revealed: bool\n    reveal_type(a1 is not a2)  # revealed: bool\n\n    reveal_type(n1 is not n1)  # revealed: Literal[False]\n    reveal_type(n1 is not n2)  # revealed: Literal[False]\n\n    reveal_type(a1 is not n1)  # revealed: Literal[True]\n    reveal_type(n1 is not a1)  # revealed: Literal[True]\n\n    reveal_type(a1 is not o)  # revealed: bool\n    reveal_type(n1 is not o)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Global Statement in Function\nDESCRIPTION: Shows behavior when importing from a module that creates global variables within function scope. The type checker correctly identifies f but struggles with g which is created dynamically.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\n\nreveal_type(f)  # revealed: def f() -> Unknown\n\n# TODO: we're undecided about whether we should consider this a false positive or not.\n# Mutating the global scope to add a symbol from an inner scope will not *necessarily* result\n# in the symbol being bound from the perspective of other modules (the function that creates\n# the inner scope, and adds the symbol to the global scope, might never be called!)\n# See discussion in https://github.com/astral-sh/ruff/pull/16959\n#\n# error: [unresolved-reference]\nreveal_type(g)  # revealed: Unknown\n\n# this diagnostic is accurate, though!\n# error: [unresolved-reference]\nreveal_type(h)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Stub Class Attribute Declaration Example\nDESCRIPTION: Example of a Python type stub file that defines a class with an attribute without an explicit assignment. In stubs, the notation 'symbol: type' is treated the same as 'symbol: type = ...'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/class.md#2025-04-17_snippet_1\n\nLANGUAGE: pyi\nCODE:\n```\nfrom typing import ClassVar\n\nclass C:\n    class_or_instance_var: int\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'while False' Loop in Python\nDESCRIPTION: Demonstrates type analysis with a statically known false loop condition. The loop body is never executed, so the variable 'x' remains 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nwhile False:\n    x = 2\n\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Using Union from typing_extensions in Python\nDESCRIPTION: Demonstrates the usage of Union from the typing_extensions module, which provides backward compatibility for newer typing features on older Python versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Union\n\na: Union[int, str]\n\ndef f():\n    # revealed: int | str\n    reveal_type(a)\n```\n\n----------------------------------------\n\nTITLE: Invalid Exception Raise Cases\nDESCRIPTION: Demonstrates valid and invalid cases of raising exceptions. Shows type checking for different raise statement scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/basic.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    raise AttributeError()  # fine\nexcept:\n    ...\n\ntry:\n    raise FloatingPointError  # fine\nexcept:\n    ...\n\ntry:\n    raise 1  # error: [invalid-raise]\nexcept:\n    ...\n\ntry:\n    raise int  # error: [invalid-raise]\nexcept:\n    ...\n\ndef _(e: Exception | type[Exception]):\n    raise e  # fine\n\ndef _(e: Exception | type[Exception] | None):\n    raise e  # error: [invalid-raise]\n```\n\n----------------------------------------\n\nTITLE: Error: Context Expression with Conditionally Defined __enter__ Method\nDESCRIPTION: Illustrates the error when __enter__ method is only defined conditionally, making it possibly unbound.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/with/sync.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Manager:\n        if flag:\n            def __enter__(self) -> str:\n                return \"abcd\"\n\n        def __exit__(self, *args): ...\n\n    # error: [invalid-context-manager] \"Object of type `Manager` cannot be used with `with` because the method `__enter__` is possibly unbound\"\n    with Manager() as f:\n        reveal_type(f)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Using Ellipsis as Function Parameter Default Values in Stub Files\nDESCRIPTION: In stub files (.pyi), the ellipsis literal can be used as a placeholder default value for function parameters regardless of the parameter's type annotation. The type system properly recognizes the annotated type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int = ...) -> None:\n    reveal_type(x)  # revealed: int\n\ndef f2(x: str = ...) -> None:\n    reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Accessing Variable One Level Up in Nested Function\nDESCRIPTION: Demonstrates type inference for a variable accessed one level up in a nested function scope. The outer variable x is accessed from an inner function g().\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/nonlocal.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    x = 1\n    def g():\n        reveal_type(x)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Accessing Bytes-Literal Attributes\nDESCRIPTION: Shows how attributes on bytes literals are delegated to builtins.bytes, with methods properly typed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(b\"foo\".join)  # revealed: bound method Literal[b\"foo\"].join(iterable_of_bytes: @Todo(generics), /) -> bytes\n# revealed: bound method Literal[b\"foo\"].endswith(suffix: @Todo(Support for `typing.TypeAlias`), start: SupportsIndex | None = ellipsis, end: SupportsIndex | None = ellipsis, /) -> bool\nreveal_type(b\"foo\".endswith)\n```\n\n----------------------------------------\n\nTITLE: String Literal Type Narrowing with String Membership\nDESCRIPTION: Shows type narrowing when testing string Literal types against a string literal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(x: Literal[\"a\", \"b\", \"c\", \"d\"]):\n    if x in \"abc\":\n        reveal_type(x)  # revealed: Literal[\"a\", \"b\", \"c\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"d\"]\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Basic Types in Python Type Expressions\nDESCRIPTION: This snippet demonstrates various invalid types that are not allowed in type expressions, including type[int], AlwaysTruthy, AlwaysFalsy, Literal types, tuple, Never, and variables of certain types. It shows the expected error messages and reveal_type results.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/invalid.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport typing\nfrom knot_extensions import AlwaysTruthy, AlwaysFalsy\nfrom typing_extensions import Literal, Never\n\nclass A: ...\n\ndef _(\n    a: type[int],\n    b: AlwaysTruthy,\n    c: AlwaysFalsy,\n    d: Literal[True],\n    e: Literal[\"bar\"],\n    f: Literal[b\"foo\"],\n    g: tuple[int, str],\n    h: Never,\n    i: int,\n    j: A,\n):\n    def foo(): ...\n    def invalid(\n        a_: a,  # error: [invalid-type-form] \"Variable of type `type[int]` is not allowed in a type expression\"\n        b_: b,  # error: [invalid-type-form]\n        c_: c,  # error: [invalid-type-form]\n        d_: d,  # error: [invalid-type-form]\n        e_: e,  # error: [invalid-type-form]\n        f_: f,  # error: [invalid-type-form]\n        g_: g,  # error: [invalid-type-form]\n        h_: h,  # error: [invalid-type-form]\n        i_: typing,  # error: [invalid-type-form]\n        j_: foo,  # error: [invalid-type-form]\n        k_: i,  # error: [invalid-type-form] \"Variable of type `int` is not allowed in a type expression\"\n        l_: j,  # error: [invalid-type-form] \"Variable of type `A` is not allowed in a type expression\"\n    ):\n        reveal_type(a_)  # revealed: Unknown\n        reveal_type(b_)  # revealed: Unknown\n        reveal_type(c_)  # revealed: Unknown\n        reveal_type(d_)  # revealed: Unknown\n        reveal_type(e_)  # revealed: Unknown\n        reveal_type(f_)  # revealed: Unknown\n        reveal_type(g_)  # revealed: Unknown\n        reveal_type(h_)  # revealed: Unknown\n        reveal_type(i_)  # revealed: Unknown\n        reveal_type(j_)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Non-disjoint Types Definition\nDESCRIPTION: Defines and tests non-disjoint types P, Q, and R using static assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_disjoint_from\n\nclass P: ...\nclass Q: ...\nclass R: ...\n\nstatic_assert(not is_disjoint_from(P, Q))\nstatic_assert(not is_disjoint_from(P, R))\nstatic_assert(not is_disjoint_from(Q, R))\n```\n\n----------------------------------------\n\nTITLE: Basic While Loop Type Checking in Python\nDESCRIPTION: Demonstrates basic while loop type inference with a boolean flag controlling the loop and tracking of variable values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1\n    while flag:\n        x = 2\n\n    reveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with conditional __init__ method in Python\nDESCRIPTION: Demonstrates type checking and error handling for a class with a conditionally defined __init__ method, covering various argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    class Foo:\n        if flag:\n            def __init__(self, x: int): ...\n        else:\n            def __init__(self, x: int, y: int = 1): ...\n\n    reveal_type(Foo(1))  # revealed: Foo\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"1\"]`\"\n    reveal_type(Foo(\"1\"))  # revealed: Foo\n    # error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__init__`\"\n    reveal_type(Foo())  # revealed: Foo\n    # error: [too-many-positional-arguments] \"Too many positional arguments to bound method `__init__`: expected 1, got 2\"\n    reveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Handling Union with Incorrect __bool__ Implementation in Python\nDESCRIPTION: This snippet shows a union type where one variant has an incorrect __bool__ implementation. It demonstrates how the type system handles boolean conversion for such unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef test(cond: bool):\n    class NotBoolable:\n        __bool__: None = None\n\n    a = 10 if cond else NotBoolable()\n\n    # error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `Literal[10] | NotBoolable`; its `__bool__` method isn't callable\"\n    if a:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Operation Magic Methods in Python Class Instances\nDESCRIPTION: Defines three classes to demonstrate binary operations: Yes (implements all binary operation methods), Sub (inherits from Yes), and No (implements none). Shows type revelation for operations between instances of the same and different classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Yes:\n    def __add__(self, other) -> Literal[\"+\"]:\n        return \"+\"\n\n    def __sub__(self, other) -> Literal[\"-\"]:\n        return \"-\"\n\n    def __mul__(self, other) -> Literal[\"*\"]:\n        return \"*\"\n\n    def __matmul__(self, other) -> Literal[\"@\"]:\n        return \"@\"\n\n    def __truediv__(self, other) -> Literal[\"/\"]:\n        return \"/\"\n\n    def __mod__(self, other) -> Literal[\"%\"]:\n        return \"%\"\n\n    def __pow__(self, other) -> Literal[\"**\"]:\n        return \"**\"\n\n    def __lshift__(self, other) -> Literal[\"<<\"]:\n        return \"<<\"\n\n    def __rshift__(self, other) -> Literal[\">>\"]:\n        return \">>\"\n\n    def __or__(self, other) -> Literal[\"|\"]:\n        return \"|\"\n\n    def __xor__(self, other) -> Literal[\"^\"]:\n        return \"^\"\n\n    def __and__(self, other) -> Literal[\"&\"]:\n        return \"&\"\n\n    def __floordiv__(self, other) -> Literal[\"//\"]:\n        return \"//\"\n\nclass Sub(Yes): ...\nclass No: ...\n\n# Yes implements all of the dunder methods.\nreveal_type(Yes() + Yes())  # revealed: Literal[\"+\"]\nreveal_type(Yes() - Yes())  # revealed: Literal[\"-\"]\nreveal_type(Yes() * Yes())  # revealed: Literal[\"*\"]\nreveal_type(Yes() @ Yes())  # revealed: Literal[\"@\"]\nreveal_type(Yes() / Yes())  # revealed: Literal[\"/\"]\nreveal_type(Yes() % Yes())  # revealed: Literal[\"%\"]\nreveal_type(Yes() ** Yes())  # revealed: Literal[\"**\"]\nreveal_type(Yes() << Yes())  # revealed: Literal[\"<<\"]\nreveal_type(Yes() >> Yes())  # revealed: Literal[\">>\"] \nreveal_type(Yes() | Yes())  # revealed: Literal[\"|\"]\nreveal_type(Yes() ^ Yes())  # revealed: Literal[\"^\"]\nreveal_type(Yes() & Yes())  # revealed: Literal[\"&\"]\nreveal_type(Yes() // Yes())  # revealed: Literal[\"//\"]\n\n# Sub inherits Yes's implementation of the dunder methods.\nreveal_type(Sub() + Sub())  # revealed: Literal[\"+\"]\nreveal_type(Sub() - Sub())  # revealed: Literal[\"-\"]\nreveal_type(Sub() * Sub())  # revealed: Literal[\"*\"]\nreveal_type(Sub() @ Sub())  # revealed: Literal[\"@\"]\nreveal_type(Sub() / Sub())  # revealed: Literal[\"/\"]\nreveal_type(Sub() % Sub())  # revealed: Literal[\"%\"]\nreveal_type(Sub() ** Sub())  # revealed: Literal[\"**\"]\nreveal_type(Sub() << Sub())  # revealed: Literal[\"<<\"]\nreveal_type(Sub() >> Sub())  # revealed: Literal[\">>\"] \nreveal_type(Sub() | Sub())  # revealed: Literal[\"|\"]\nreveal_type(Sub() ^ Sub())  # revealed: Literal[\"^\"]\nreveal_type(Sub() & Sub())  # revealed: Literal[\"&\"]\nreveal_type(Sub() // Sub())  # revealed: Literal[\"//\"]\n\n# No does not implement any of the dunder methods.\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() + No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `-` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() - No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `*` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() * No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `@` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() @ No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `/` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() / No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `%` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() % No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `**` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() ** No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `<<` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() << No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `>>` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() >> No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `|` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() | No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `^` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() ^ No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `&` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() & No())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `//` is unsupported between objects of type `No` and `No`\"\nreveal_type(No() // No())  # revealed: Unknown\n\n# Yes does not implement any of the reflected dunder methods.\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() + Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `-` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() - Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `*` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() * Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `@` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() @ Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `/` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() / Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `%` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() % Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `**` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() ** Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `<<` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() << Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `>>` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() >> Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `|` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() | Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `^` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() ^ Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `&` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() & Yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `//` is unsupported between objects of type `No` and `Yes`\"\nreveal_type(No() // Yes())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Class Types isinstance() Check\nDESCRIPTION: Shows type narrowing behavior with custom class types and union/intersection types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\nclass C: ...\n\nx = object()\n\nif isinstance(x, A):\n    reveal_type(x)  # revealed: A\n    if isinstance(x, B):\n        reveal_type(x)  # revealed: A & B\n    else:\n        reveal_type(x)  # revealed: A & ~B\n\nif isinstance(x, (A, B)):\n    reveal_type(x)  # revealed: A | B\nelif isinstance(x, (A, C)):\n    reveal_type(x)  # revealed: C & ~A & ~B\nelse:\n    reveal_type(x)  # revealed: ~A & ~B & ~C\n```\n\n----------------------------------------\n\nTITLE: Examining Unbound Function Local Variables in Python\nDESCRIPTION: This snippet shows how an unbound function local that has definitions in the scope does not fall back to globals. It demonstrates that referencing 'x' before its local definition results in an error, even though a global 'x' exists.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/unbound.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ndef f():\n    # error: [unresolved-reference]\n    # revealed: Unknown\n    reveal_type(x)\n    x = 2\n    # revealed: Literal[2]\n    reveal_type(x)\n```\n\n----------------------------------------\n\nTITLE: Continue Statements in Multiple Conditional Branches\nDESCRIPTION: Shows how continue statements in different branches of conditionals impact type tracking. Demonstrates the analysis challenges with tracking variable values when continue statements appear in multiple code paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef continue_in_both_branches(cond: bool, i: int):\n    x = \"before\"\n    for _ in range(i):\n        if cond:\n            x = \"continue1\"\n            reveal_type(x)  # revealed: Literal[\"continue1\"]\n            continue\n        else:\n            x = \"continue2\"\n            reveal_type(x)  # revealed: Literal[\"continue2\"]\n            continue\n    # TODO: Should be Literal[\"before\", \"continue1\", \"continue2\"]\n    reveal_type(x)  # revealed: Literal[\"before\"]\n```\n\n----------------------------------------\n\nTITLE: Comparing Union Types with Union Types in Python\nDESCRIPTION: This snippet shows how comparison operations behave when both sides of the comparison are union types. It demonstrates that the full cross product of options needs to be considered when inferring the resulting type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/unions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag_s: bool, flag_l: bool):\n    small = 1 if flag_s else 2\n    large = 2 if flag_l else 3\n\n    reveal_type(small <= large)  # revealed: Literal[True]\n    reveal_type(small >= large)  # revealed: bool\n\n    reveal_type(small < large)  # revealed: bool\n    reveal_type(small > large)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: If-Elif-Else With Intervening Assignment\nDESCRIPTION: Demonstrates type analysis with additional variable assignments within conditional blocks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    y = 0\n\n    if flag:\n        y = 1\n        z = 3\n    elif flag2:\n        y = 2\n    else:\n        pass\n\n    reveal_type(y)  # revealed: Literal[0, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Using TypeOf Special Form in Python\nDESCRIPTION: Demonstrates the TypeOf special form for getting inferred types of expressions. Shows usage in type checking and annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import TypeOf, is_subtype_of, static_assert\n\n# This is incorrect and therefore fails with ...\n# error: \"Static assertion error: argument evaluates to `False`\"\nstatic_assert(is_subtype_of(str, type[str]))\n\n# Correct, returns True:\nstatic_assert(is_subtype_of(TypeOf[str], type[str]))\n\nclass Base: ...\nclass Derived(Base): ...\n```\n\n----------------------------------------\n\nTITLE: Boolean Variable Arithmetic Operations in Python\nDESCRIPTION: Shows type checking results for arithmetic operations between boolean variables and integers/booleans. Demonstrates that operations with variables typically result in more general types (int or float) rather than Literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/booleans.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(a: bool):\n    def lhs_is_int(x: int):\n        reveal_type(x + a)  # revealed: int\n        reveal_type(x - a)  # revealed: int\n        reveal_type(x * a)  # revealed: int\n        reveal_type(x // a)  # revealed: int\n        reveal_type(x / a)  # revealed: int | float\n        reveal_type(x % a)  # revealed: int\n\n    def rhs_is_int(x: int):\n        reveal_type(a + x)  # revealed: int\n        reveal_type(a - x)  # revealed: int\n        reveal_type(a * x)  # revealed: int\n        reveal_type(a // x)  # revealed: int\n        reveal_type(a / x)  # revealed: int | float\n        reveal_type(a % x)  # revealed: int\n\n    def lhs_is_bool(x: bool):\n        reveal_type(x + a)  # revealed: int\n        reveal_type(x - a)  # revealed: int\n        reveal_type(x * a)  # revealed: int\n        reveal_type(x // a)  # revealed: int\n        reveal_type(x / a)  # revealed: int | float\n        reveal_type(x % a)  # revealed: int\n\n    def rhs_is_bool(x: bool):\n        reveal_type(a + x)  # revealed: int\n        reveal_type(a - x)  # revealed: int\n        reveal_type(a * x)  # revealed: int\n        reveal_type(a // x)  # revealed: int\n        reveal_type(a / x)  # revealed: int | float\n        reveal_type(a % x)  # revealed: int\n\n    def both_are_bool(x: bool, y: bool):\n        reveal_type(x + y)  # revealed: int\n        reveal_type(x - y)  # revealed: int\n        reveal_type(x * y)  # revealed: int\n        reveal_type(x // y)  # revealed: int\n        reveal_type(x / y)  # revealed: int | float\n        reveal_type(x % y)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Environment for Benchmarking\nDESCRIPTION: Create a Python virtual environment and install dependencies for running benchmarks using uv.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nuv venv --project ./scripts/benchmarks\nuv sync --project ./scripts/benchmarks\n```\n\n----------------------------------------\n\nTITLE: Lambda as Decorator in Python\nDESCRIPTION: Illustrates the use of a lambda function as a decorator and its type implications.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/decorators.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@lambda f: f\ndef g(x: int) -> str:\n    return \"a\"\n\n# TODO: This should be `Literal[g]` or `(int, /) -> str`\nreveal_type(g)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for TensorFlow Lite Super Resolution\nDESCRIPTION: This snippet imports the required Python modules (tensorflow, tensorflow_hub, and matplotlib) and prints the TensorFlow version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport tensorflow as tf\nimport tensorflow_hub as hub\nimport matplotlib.pyplot as plt\nprint(tf.__version__)\n```\n\n----------------------------------------\n\nTITLE: Unpacking Ellipsis Literal in Assignment Statements in Stub Files\nDESCRIPTION: In stub files, unpacking an ellipsis literal as part of an assignment statement is valid and no diagnostic is emitted. Both variables receive the Unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx, y = ...\nreveal_type(x)  # revealed: Unknown\nreveal_type(y)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Dataclass with Disabled Init\nDESCRIPTION: Shows behavior when init=False is set in dataclass decorator, preventing __init__ method generation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass(init=False)\nclass C:\n    x: int\n\nC()  # Okay\n\n# error: [too-many-positional-arguments]\nC(1)\n\nrepr(C())\n\nC() == C()\n```\n\n----------------------------------------\n\nTITLE: Testing Equivalence of Tuples with Differently Ordered Union/Intersection Types\nDESCRIPTION: This code demonstrates that tuples containing equivalent but differently ordered unions/intersections are themselves equivalent. It tests tuple equivalence with simple union types and more complex intersection types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_equivalent_to, TypeOf, static_assert, Intersection, Not\nfrom typing import Literal\n\nclass P: ...\nclass Q: ...\nclass R: ...\nclass S: ...\n\nstatic_assert(is_equivalent_to(tuple[P | Q], tuple[Q | P]))\nstatic_assert(is_equivalent_to(tuple[P | None], tuple[None | P]))\nstatic_assert(\n    is_equivalent_to(tuple[Intersection[P, Q] | Intersection[R, Not[S]]], tuple[Intersection[Not[S], R] | Intersection[Q, P]])\n)\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of LiteralString within Literal in Python\nDESCRIPTION: Shows that LiteralString cannot be used within Literal type annotations, resulting in invalid-type-form errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\n\nbad_union: Literal[\"hello\", LiteralString]  # error: [invalid-type-form]\nbad_nesting: Literal[LiteralString]  # error: [invalid-type-form]\n```\n\n----------------------------------------\n\nTITLE: Handling Long Paths in Python Imports\nDESCRIPTION: Demonstrates handling of extremely long module names in imports, which can be problematic on Windows systems.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\nsystem = \"os\"\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom AveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPathAveryLongPath import (\n    Foo,\n)\n\nreveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Operations with Constrained TypeVars in Python\nDESCRIPTION: Shows how unions with constrained typevars simplify based on the relationship between the type and the constraints. Unions simplify differently depending on the subtype relationship.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef constrained[T: (Base, Sub)](t: T) -> None:\n    def _(x: T | Super) -> None:\n        reveal_type(x)  # revealed: Super\n\n    def _(x: T | Base) -> None:\n        reveal_type(x)  # revealed: Base\n\n    def _(x: T | Sub) -> None:\n        reveal_type(x)  # revealed: T\n\n    def _(x: T | Unrelated) -> None:\n        reveal_type(x)  # revealed: T | Unrelated\n\n    def _(x: T | Any) -> None:\n        reveal_type(x)  # revealed: T | Any\n```\n\n----------------------------------------\n\nTITLE: String Kinds in typing.Literal Type Annotations in Python\nDESCRIPTION: Shows how different string types (raw, bytes, concatenated, etc.) are handled within typing.Literal context, which is more permissive than direct type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef f(v: Literal[\"a\", r\"b\", b\"c\", \"d\" \"e\", \"\\N{LATIN SMALL LETTER F}\", \"\\x67\", \"\"\"h\"\"\"]):\n    reveal_type(v)  # revealed: Literal[\"a\", \"b\", \"de\", \"f\", \"g\", \"h\", b\"c\"]\n```\n\n----------------------------------------\n\nTITLE: Subtype Hierarchies\nDESCRIPTION: Defines and tests subtype relationships between classes A, B, C, B1, and B2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_subtype_of, is_disjoint_from\n\nclass A: ...\nclass B(A): ...\nclass C(B): ...\n\nstatic_assert(is_subtype_of(B, A))\nstatic_assert(is_subtype_of(C, B))\nstatic_assert(is_subtype_of(C, A))\n\nstatic_assert(not is_subtype_of(A, B))\nstatic_assert(not is_subtype_of(B, C))\nstatic_assert(not is_subtype_of(A, C))\n\nclass B1(A): ...\nclass B2(A): ...\n\nstatic_assert(is_subtype_of(B1, A))\nstatic_assert(is_subtype_of(B2, A))\n\nstatic_assert(not is_subtype_of(A, B1))\nstatic_assert(not is_subtype_of(A, B2))\n\nstatic_assert(not is_subtype_of(B1, B2))\nstatic_assert(not is_subtype_of(B2, B1))\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'for' inside 'if True' in Python\nDESCRIPTION: Demonstrates type analysis when a for loop is nested inside an always-true condition. The variable 'x' can be either 1 or 2 after execution, depending on whether the iterable is empty.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef iterable() -> list[object]:\n    return [1, \"\"]\n\nx = 1\n\nif True:\n    for _ in iterable():\n        x = 2\nelse:\n    x = 3\n\nreveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Working with Unbound Super Objects in Python\nDESCRIPTION: Shows the behavior of unbound super objects created with super(cls) which are treated as plain super instances and don't support name lookup via the MRO.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    a: int = 42\n\nclass B(A): ...\n\nreveal_type(super(B))  # revealed: super\n\n# error: [unresolved-attribute] \"Type `super` has no attribute `a`\"\nsuper(B).a\n```\n\n----------------------------------------\n\nTITLE: Unresolved Module in Star Import\nDESCRIPTION: Shows the error when attempting to star-import from a module that doesn't exist. The type checker emits an unresolved-import diagnostic.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# TODO: not a great error message\nfrom foo import *  # error: [unresolved-import] \"Cannot resolve import `foo`\"\n```\n\n----------------------------------------\n\nTITLE: Analyzing Possibly Unbound Variables in Class and Global Scope\nDESCRIPTION: This code demonstrates how variables can be unbound in both class and global scope when conditionally defined. It shows how references to 'x' in the class scope can resolve to either the global 'x' or the class-local 'x' depending on execution flow.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/unbound.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    x = \"abc\"\n\nclass C:\n    if coinflip():\n        x = 1\n\n    # error: [possibly-unresolved-reference]\n    y = x\n\nreveal_type(C.y)  # revealed: Unknown | Literal[1, \"abc\"]\n```\n\n----------------------------------------\n\nTITLE: Performing Exact Platform Comparison in Python\nDESCRIPTION: Python code demonstrating exact equality comparison with sys.platform. The type checker can determine the result of these comparisons at compile time based on the configured platform.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.platform == \"freebsd8\")  # revealed: Literal[True]\nreveal_type(sys.platform == \"linux\")  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dunder Method Overwrite Attempt on Instance in Python\nDESCRIPTION: This code snippet shows that attempting to overwrite a dunder method on an instance does not affect the behavior of implicit dunder calls. The __getitem__ method on the class is still called despite the attempt to set it to None on the instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __getitem__(self, key: int) -> str:\n        return str(key)\n\n    def f(self):\n        # TODO: This should emit an `invalid-assignment` diagnostic once we understand the type of `self`\n        self.__getitem__ = None\n\n# This is still fine, and simply calls the `__getitem__` method on the class\nreveal_type(C()[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-callable __bool__ in Python\nDESCRIPTION: This snippet shows a class with a non-callable __bool__ attribute. It demonstrates how the type system handles boolean conversion for such objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: None = None\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\nif NotBoolable():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Inheritance Chain with __slots__ Incompatibility\nDESCRIPTION: Demonstrates how incompatibility can occur even when inheriting from classes that don't directly define __slots__ but inherit them from parent classes with incompatible slots.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = (\"a\", \"b\")\n\nclass B(A): ...\n\nclass C:\n    __slots__ = (\"c\", \"d\")\n\nclass D(C): ...\nclass E(\n    B,  # error: [incompatible-slots]\n    D,  # error: [incompatible-slots]\n): ...\n```\n\n----------------------------------------\n\nTITLE: Constraints in Later Test Expressions\nDESCRIPTION: Demonstrates how type constraints from earlier conditions affect later test expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef check(x) -> bool:\n    return bool(x)\n\ndef _(flag: bool):\n    x = 1 if flag else None\n    y = 0\n\n    if x is None:\n        pass\n    elif check(y := x):\n        pass\n\n    reveal_type(y)  # revealed: Literal[0, 1]\n```\n\n----------------------------------------\n\nTITLE: Invalid TYPE_CHECKING Assignments\nDESCRIPTION: Shows various invalid assignments to TYPE_CHECKING that result in errors, including incorrect values and incompatible type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING = True\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: bool = True\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: int = 1\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: str = \"str\"\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: str = False\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: Literal[False] = False\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: Literal[True] = False\n```\n\n----------------------------------------\n\nTITLE: Invalid Super Arguments in Python\nDESCRIPTION: Shows cases where super() calls fail due to violating conditions: first argument must be a valid class, and second argument must be either an instance or subclass of the first, resulting in TypeError at runtime.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int):\n    # error: [invalid-super-argument] \"`int` is not a valid class\"\n    super(x, x)\n\n    type IntAlias = int\n    # error: [invalid-super-argument] \"`typing.TypeAliasType` is not a valid class\"\n    super(IntAlias, 0)\n\n# error: [invalid-super-argument] \"`Literal[\"\"]` is not an instance or subclass of `Literal[int]` in `super(Literal[int], Literal[\"\"])` call\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with Custom Configuration File (Legacy)\nDESCRIPTION: Example of providing a custom configuration file using the deprecated ruff-lsp settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.args\": \"--config ~/.config/custom_ruff_config.toml\",\n    \"ruff.format.args\": \"--config ~/.config/custom_ruff_config.toml\"\n}\n```\n\n----------------------------------------\n\nTITLE: Literal Type Comparisons with sys.version_info\nDESCRIPTION: Demonstrates how comparing sys.version_info with 2-element tuples produces Literal type results\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info >= (3, 9))  # revealed: Literal[True]\nreveal_type((3, 9) <= sys.version_info)  # revealed: Literal[True]\n\nreveal_type(sys.version_info > (3, 9))  # revealed: Literal[True]\nreveal_type((3, 9) < sys.version_info)  # revealed: Literal[True]\n\nreveal_type(sys.version_info < (3, 9))  # revealed: Literal[False]\nreveal_type((3, 9) > sys.version_info)  # revealed: Literal[False]\n\nreveal_type(sys.version_info <= (3, 9))  # revealed: Literal[False]\nreveal_type((3, 9) >= sys.version_info)  # revealed: Literal[False]\n\nreveal_type(sys.version_info == (3, 9))  # revealed: Literal[False]\nreveal_type((3, 9) == sys.version_info)  # revealed: Literal[False]\n\nreveal_type(sys.version_info != (3, 9))  # revealed: Literal[True]\nreveal_type((3, 9) != sys.version_info)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Basic While Loop Variable Boundness Check in Python\nDESCRIPTION: Tests variable boundness tracking in a basic while loop, showing error detection for potentially unbound variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    while flag:\n        x = 1\n\n    # error: [possibly-unresolved-reference]\n    x\n```\n\n----------------------------------------\n\nTITLE: Valid str() Function Calls\nDESCRIPTION: Shows various valid ways to call the str() function with different arguments and encodings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nstr()\nstr(\"\")\nstr(b\"\")\nstr(1)\nstr(object=1)\n\nstr(b\"M\\xc3\\xbcsli\", \"utf-8\")\nstr(b\"M\\xc3\\xbcsli\", \"utf-8\", \"replace\")\n\nstr(b\"M\\x00\\xfc\\x00s\\x00l\\x00i\\x00\", encoding=\"utf-16\")\nstr(b\"M\\x00\\xfc\\x00s\\x00l\\x00i\\x00\", encoding=\"utf-16\", errors=\"ignore\")\n\nstr(bytearray.fromhex(\"4d c3 bc 73 6c 69\"), \"utf-8\")\nstr(bytearray(), \"utf-8\")\n\nstr(encoding=\"utf-8\", object=b\"M\\xc3\\xbcsli\")\nstr(b\"\", errors=\"replace\")\nstr(encoding=\"utf-8\")\nstr(errors=\"replace\")\n```\n\n----------------------------------------\n\nTITLE: False Negative: Possibly Unbound __slots__\nDESCRIPTION: Shows a case where incompatibility might not be detected due to conditional definition of __slots__. The static analyzer cannot determine if there will be incompatibility at runtime.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A:\n        if flag:\n            __slots__ = (\"a\", \"b\")\n\n    class B:\n        __slots__ = (\"c\", \"d\")\n\n    # Might or might not be fine at runtime\n    class C(A, B): ...\n```\n\n----------------------------------------\n\nTITLE: Unsupported Tuple Comparisons in Python\nDESCRIPTION: Demonstrates cases where tuple comparisons are not supported due to incompatible types. Equality and inequality still provide definite results, while other comparisons result in errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = (1, 2)\nb = (1, \"hello\")\n\n# TODO: should be Literal[False], once we implement (in)equality for mismatched literals\nreveal_type(a == b)  # revealed: bool\n\n# TODO: should be Literal[True], once we implement (in)equality for mismatched literals\nreveal_type(a != b)  # revealed: bool\n\n# error: [unsupported-operator] \"Operator `<` is not supported for types `int` and `str`, in comparing `tuple[Literal[1], Literal[2]]` with `tuple[Literal[1], Literal[\"hello\"]]\"\nreveal_type(a < b)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `<=` is not supported for types `int` and `str`, in comparing `tuple[Literal[1], Literal[2]]` with `tuple[Literal[1], Literal[\"hello\"]]\"\nreveal_type(a <= b)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `>` is not supported for types `int` and `str`, in comparing `tuple[Literal[1], Literal[2]]` with `tuple[Literal[1], Literal[\"hello\"]]\"\nreveal_type(a > b)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `>=` is not supported for types `int` and `str`, in comparing `tuple[Literal[1], Literal[2]]` with `tuple[Literal[1], Literal[\"hello\"]]\"\nreveal_type(a >= b)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'while True' with 'break' and 'else' in Python\nDESCRIPTION: Shows type analysis for a while loop with an always-true condition, a break statement, and an else clause. The loop body executes once and breaks, so the else block is skipped.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nwhile True:\n    x = 1\n    break\nelse:\n    x = 2\n\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Binary Operations on Float Type (Treated as int | float Union)\nDESCRIPTION: Shows that float type annotations are treated as a union of int and float, resulting in int | float return types for arithmetic operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/unions.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f4(x: float, y: float):\n    reveal_type(x + y)  # revealed: int | float\n    reveal_type(x - y)  # revealed: int | float\n    reveal_type(x * y)  # revealed: int | float\n    reveal_type(x / y)  # revealed: int | float\n    reveal_type(x // y)  # revealed: int | float\n    reveal_type(x % y)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Invalid Parameterization of Annotated Type in Python\nDESCRIPTION: This snippet demonstrates invalid parameterizations of the Annotated type, showing that it requires at least two arguments when used in a type expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Annotated\n\n# error: [invalid-type-form] \"`typing.Annotated` requires at least two arguments when used in a type expression\"\ndef _(x: Annotated):\n    reveal_type(x)  # revealed: Unknown\n\ndef _(flag: bool):\n    if flag:\n        X = Annotated\n    else:\n        X = bool\n\n    # error: [invalid-type-form] \"`typing.Annotated` requires at least two arguments when used in a type expression\"\n    def f(y: X):\n        reveal_type(y)  # revealed: Unknown | bool\n\n# error: [invalid-type-form] \"`typing.Annotated` requires at least two arguments when used in a type expression\"\ndef _(x: Annotated | bool):\n    reveal_type(x)  # revealed: Unknown | bool\n\n# error: [invalid-type-form]\ndef _(x: Annotated[()]):\n    reveal_type(x)  # revealed: Unknown\n\n# error: [invalid-type-form]\ndef _(x: Annotated[int]):\n    reveal_type(x)  # revealed: int\n\n# error: [invalid-type-form]\ndef _(x: Annotated[(int,)]):\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Import Module Attribute vs Submodule - Reversed Combined Import\nDESCRIPTION: Shows how the order of imports affects type inference, though differs from runtime behavior where from-import would prioritize the integer attribute\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom a import b\nimport a.b\n\n# Python would say `int` for `b`\nreveal_type(b)  # revealed: <module 'a.b'>\nreveal_type(a.b)  # revealed: <module 'a.b'>\n```\n\n----------------------------------------\n\nTITLE: Downloading Test Image for Super Resolution\nDESCRIPTION: This snippet downloads a test image (insect head) to be used for demonstrating the super resolution capability.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntest_img_path = tf.keras.utils.get_file('lr.jpg', 'https://raw.githubusercontent.com/tensorflow/examples/master/lite/examples/super_resolution/android/app/src/main/assets/lr-1.jpg')\n```\n\n----------------------------------------\n\nTITLE: Invalid Parameterization of typing.Any in Python\nDESCRIPTION: Demonstrates that typing.Any cannot be parameterized with type arguments. Attempting to use Any with type parameters results in an invalid-type-form error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/any.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\n# error: [invalid-type-form] \"Type `typing.Any` expected no type parameter\"\ndef f(x: Any[int]):\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Identity Comparisons with Tuples\nDESCRIPTION: Demonstrates type checking for 'is' and 'is not' operators with tuples, including comparisons between different tuple types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\na = (1, 2)\nb = (\"a\", \"b\")\nc = (1, 2, 3)\n\nreveal_type(a is (1, 2))  # revealed: bool\nreveal_type(a is not (1, 2))  # revealed: bool\n\n# TODO should be Literal[False] once we implement comparison of mismatched literal types\nreveal_type(a is b)  # revealed: bool\n# TODO should be Literal[True] once we implement comparison of mismatched literal types\nreveal_type(a is not b)  # revealed: bool\n\nreveal_type(a is c)  # revealed: Literal[False]\nreveal_type(a is not c)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Configuring Known First-Party Modules in pyproject.toml\nDESCRIPTION: This example shows how to configure Ruff to always treat specific modules as first-party, regardless of their location. It involves setting the `known-first-party` option within the `[tool.ruff.lint.isort]` section and enabling isort checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff]\nsrc = [\"src\", \"tests\"]\n\n[tool.ruff.lint]\nselect = [\n    # Pyflakes\n    \"F\",\n    # Pycodestyle\n    \"E\",\n    \"W\",\n    # isort\n    \"I001\"\n]\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"my_module1\", \"my_module2\"]\"\n```\n\n----------------------------------------\n\nTITLE: Basic Python Set Type Inference\nDESCRIPTION: Demonstrates type inference of a basic Python set literal using reveal_type for static type checking. The type checker reveals the type as 'set'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/collections/set.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type({1, 2})  # revealed: set\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid AST Nodes in Python Type Expressions\nDESCRIPTION: This snippet shows various invalid AST nodes that are not allowed in type expressions, including literals, boolean operations, named expressions, unary operations, lambda expressions, if expressions, await expressions, yield expressions, comparisons, function calls, f-strings, and slices.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/invalid.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef bar() -> None:\n    return None\n\ndef _(\n    a: 1,  # error: [invalid-type-form] \"Int literals are not allowed in this context in a type expression\"\n    b: 2.3,  # error: [invalid-type-form] \"Float literals are not allowed in type expressions\"\n    c: 4j,  # error: [invalid-type-form] \"Complex literals are not allowed in type expressions\"\n    d: True,  # error: [invalid-type-form] \"Boolean literals are not allowed in this context in a type expression\"\n    e: int | b\"foo\",  # error: [invalid-type-form] \"Bytes literals are not allowed in this context in a type expression\"\n    f: 1 and 2,  # error: [invalid-type-form] \"Boolean operations are not allowed in type expressions\"\n    g: 1 or 2,  # error: [invalid-type-form] \"Boolean operations are not allowed in type expressions\"\n    h: (foo := 1),  # error: [invalid-type-form] \"Named expressions are not allowed in type expressions\"\n    i: not 1,  # error: [invalid-type-form] \"Unary operations are not allowed in type expressions\"\n    j: lambda: 1,  # error: [invalid-type-form] \"`lambda` expressions are not allowed in type expressions\"\n    k: 1 if True else 2,  # error: [invalid-type-form] \"`if` expressions are not allowed in type expressions\"\n    l: await 1,  # error: [invalid-type-form] \"`await` expressions are not allowed in type expressions\"\n    m: (yield 1),  # error: [invalid-type-form] \"`yield` expressions are not allowed in type expressions\"\n    n: (yield from [1]),  # error: [invalid-type-form] \"`yield from` expressions are not allowed in type expressions\"\n    o: 1 < 2,  # error: [invalid-type-form] \"Comparison expressions are not allowed in type expressions\"\n    p: bar(),  # error: [invalid-type-form] \"Function calls are not allowed in type expressions\"\n    q: int | f\"foo\",  # error: [invalid-type-form] \"F-strings are not allowed in type expressions\"\n    r: [1, 2, 3][1:2],  # error: [invalid-type-form] \"Slices are not allowed in type expressions\"\n):\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n    reveal_type(c)  # revealed: Unknown\n    reveal_type(d)  # revealed: Unknown\n    reveal_type(e)  # revealed: int | Unknown\n    reveal_type(f)  # revealed: Unknown\n    reveal_type(g)  # revealed: Unknown\n    reveal_type(h)  # revealed: Unknown\n    reveal_type(i)  # revealed: Unknown\n    reveal_type(j)  # revealed: Unknown\n    reveal_type(k)  # revealed: Unknown\n    reveal_type(p)  # revealed: Unknown\n    reveal_type(q)  # revealed: int | Unknown\n    reveal_type(r)  # revealed: @Todo(generics)\n```\n\n----------------------------------------\n\nTITLE: Playground Setup Commands\nDESCRIPTION: Commands for setting up and running the Ruff formatter playground\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd playground && npm install && npm run dev:wasm && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Default Configurations for Ruff\nDESCRIPTION: This TOML snippet provides the default configuration for Ruff using pyproject.toml. It excludes certain directories, sets formatting standards similar to Black, and configures linting options. The configuration assumes Python 3.9 as the target version and allows configuration for string quote styles, line endings, and magic commas.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\n# Exclude a variety of commonly ignored directories.\nexclude = [\n    \".bzr\",\n    \".direnv\",\n    \".eggs\",\n    \".git\",\n    \".git-rewrite\",\n    \".hg\",\n    \".ipynb_checkpoints\",\n    \".mypy_cache\",\n    \".nox\",\n    \".pants.d\",\n    \".pyenv\",\n    \".pytest_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".svn\",\n    \".tox\",\n    \".venv\",\n    \".vscode\",\n    \"__pypackages__\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"node_modules\",\n    \"site-packages\",\n    \"venv\",\n]\n\n# Same as Black.\nline-length = 88\nindent-width = 4\n\n# Assume Python 3.9\ntarget-version = \"py39\"\n\n[tool.ruff.lint]\n# Enable Pyflakes (`F`) and a subset of the pycodestyle (`E`)  codes by default.\n# Unlike Flake8, Ruff doesn't enable pycodestyle warnings (`W`) or\n# McCabe complexity (`C901`) by default.\nselect = [\"E4\", \"E7\", \"E9\", \"F\"]\nignore = []\n\n# Allow fix for all enabled rules (when `--fix`) is provided.\nfixable = [\"ALL\"]\nunfixable = []\n\n# Allow unused variables when underscore-prefixed.\ndummy-variable-rgx = \"^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$\"\n\n[tool.ruff.format]\n# Like Black, use double quotes for strings.\nquote-style = \"double\"\n\n# Like Black, indent with spaces, rather than tabs.\nindent-style = \"space\"\n\n# Like Black, respect magic trailing commas.\nskip-magic-trailing-comma = false\n\n# Like Black, automatically detect the appropriate line ending.\nline-ending = \"auto\"\n\n# Enable auto-formatting of code examples in docstrings. Markdown,\n# reStructuredText code/literal blocks and doctests are all supported.\n#\n# This is currently disabled by default, but it is planned for this\n# to be opt-out in the future.\ndocstring-code-format = false\n\n# Set the line length limit used when formatting code snippets in\n# docstrings.\n#\n# This only has an effect when the `docstring-code-format` setting is\n# enabled.\ndocstring-code-line-length = \"dynamic\"\n\n```\n\n----------------------------------------\n\nTITLE: Size Limit on Unions of Literals in Python\nDESCRIPTION: Demonstrates how large unions of literal types collapse to their nearest super-type (int, bytes, str) beyond a certain size limit to maintain performance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef _(literals_2: Literal[0, 1], b: bool, flag: bool):\n    literals_4 = 2 * literals_2 + literals_2  # Literal[0, 1, 2, 3]\n    literals_16 = 4 * literals_4 + literals_4  # Literal[0, 1, .., 15]\n    literals_64 = 4 * literals_16 + literals_4  # Literal[0, 1, .., 63]\n    literals_128 = 2 * literals_64 + literals_2  # Literal[0, 1, .., 127]\n\n    # Going beyond the MAX_UNION_LITERALS limit (currently 200):\n    literals_256 = 16 * literals_16 + literals_16\n    reveal_type(literals_256)  # revealed: int\n\n    # Going beyond the limit when another type is already part of the union\n    bool_and_literals_128 = b if flag else literals_128  # bool | Literal[0, 1, ..., 127]\n    literals_128_shifted = literals_128 + 128  # Literal[128, 129, ..., 255]\n\n    # Now union the two:\n    reveal_type(bool_and_literals_128 if flag else literals_128_shifted)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Functions in Python\nDESCRIPTION: Shows type inference when applying 'not' to function objects, where functions are always considered truthy, resulting in Literal[False].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    return 1\n\nreveal_type(not f)  # revealed: Literal[False]\n# TODO Unknown should not be part of the type of typing.reveal_type\n# reveal_type(not reveal_type)  revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Intersection Operations with Unbounded Unconstrained TypeVars in Python\nDESCRIPTION: Illustrates how intersections with unbounded unconstrained typevars cannot be simplified, as the typevar could be specialized to any type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection\nfrom typing import Any\n\nclass Super: ...\nclass Base(Super): ...\nclass Sub(Base): ...\nclass Unrelated: ...\n\ndef unbounded_unconstrained[T](t: T) -> None:\n    def _(x: Intersection[T, Super]) -> None:\n        reveal_type(x)  # revealed: T & Super\n\n    def _(x: Intersection[T, Base]) -> None:\n        reveal_type(x)  # revealed: T & Base\n\n    def _(x: Intersection[T, Sub]) -> None:\n        reveal_type(x)  # revealed: T & Sub\n\n    def _(x: Intersection[T, Unrelated]) -> None:\n        reveal_type(x)  # revealed: T & Unrelated\n\n    def _(x: Intersection[T, Any]) -> None:\n        reveal_type(x)  # revealed: T & Any\n```\n\n----------------------------------------\n\nTITLE: Possibly Undeclared and Bound Symbol Usage in Python\nDESCRIPTION: Shows type inference for possibly undeclared but bound symbols, using unions of declared and inferred types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef any() -> Any: ...\ndef flag() -> bool:\n    return True\n\na = 1\nb = 2\nc = 3\nd = any()\nif flag():\n    a: int\n    b: Any\n    c: str  # error: [invalid-declaration]\n    d: int\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import a, b, c, d\n\nreveal_type(a)  # revealed: int\nreveal_type(b)  # revealed: Literal[2] | Any\nreveal_type(c)  # revealed: Literal[3] | Unknown\nreveal_type(d)  # revealed: Any | int\n\n# External modifications of `a` that violate the declared type are not allowed:\n# error: [invalid-assignment]\na = None\n```\n\n----------------------------------------\n\nTITLE: Basic Python Version Check\nDESCRIPTION: Verifies that the global Python version configuration from root section is correctly applied.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[:2] == (3, 10))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Class Subscription Errors in Python\nDESCRIPTION: Shows the error that occurs when attempting to subscript a class that doesn't implement __class_getitem__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NotSubscriptable: ...\n\na = NotSubscriptable[0]  # error: \"Cannot subscript object of type `Literal[NotSubscriptable]` with no `__class_getitem__` method\"\n```\n\n----------------------------------------\n\nTITLE: Testing Partial Variadic Function Type Equivalence in Python\nDESCRIPTION: Shows that functions with only *args or only **kwargs are not gradual equivalent to callables with ... as the parameter type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef variadic_args(*args):\n    return\n\ndef variadic_kwargs(**kwargs):\n    return\n\nstatic_assert(not is_gradual_equivalent_to(CallableTypeOf[variadic_args], Callable[..., Any]))\nstatic_assert(not is_gradual_equivalent_to(CallableTypeOf[variadic_kwargs], Callable[..., Any]))\n```\n\n----------------------------------------\n\nTITLE: Positional-Only Parameters Test\nDESCRIPTION: Tests invalid argument type detection with positional-only parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, y: int, z: int, /) -> int:\n    return x * y * z\n\nfoo(1, \"hello\", 3)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Custom Builtin Definition in PYI File\nDESCRIPTION: This PYI file defines a custom builtin class and symbol to be used with the custom typeshed configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_3\n\nLANGUAGE: pyi\nCODE:\n```\nclass Custom: ...\n\ncustom_builtin: Custom\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always False Conditional Expression in Python\nDESCRIPTION: Shows type inference for if-expressions with a statically known false condition. Both the result of the expression and the variable assigned in the evaluated branch are correctly typed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nx = (y := 1) if False else (y := 2)\n\nreveal_type(x)  # revealed: Literal[2]\nreveal_type(y)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Limitations of Custom Error Messages in Static Assertions\nDESCRIPTION: Demonstrates the limitations of string inference for custom error messages in static assertions, showing the fallback to default messages.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nshouted_message = \"A custom message\".upper()\n# error: \"Static assertion error: argument evaluates to `False`\"\nstatic_assert(False, shouted_message)\n```\n\n----------------------------------------\n\nTITLE: Static Classmethod Access\nDESCRIPTION: Shows runtime behavior when accessing classmethod as a static member using getattr_static.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import getattr_static\n\nclass C:\n    @classmethod\n    def f(cls): ...\n\nreveal_type(getattr_static(C, \"f\"))  # revealed: def f(cls) -> Unknown\nreveal_type(getattr_static(C, \"f\").__get__)  # revealed: <method-wrapper `__get__` of `f`>\n```\n\n----------------------------------------\n\nTITLE: While-Else Variable Boundness with Break in Python\nDESCRIPTION: Shows variable boundness analysis in while-else construct with potential break statements.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    while flag:\n        x = 1\n        if flag2:\n            break\n    else:\n        y = 1\n\n    # error: [possibly-unresolved-reference]\n    x\n    # error: [possibly-unresolved-reference]\n    y\n```\n\n----------------------------------------\n\nTITLE: Simple Boolean Function Calls in Python\nDESCRIPTION: This snippet demonstrates type inference for a simple function that assigns boolean values based on a condition. It shows how the type system infers the result as a boolean.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        x = True\n    else:\n        x = False\n\n    reveal_type(x)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Function Shadowing with Multiple Definitions in Python\nDESCRIPTION: Illustrates how function declarations can shadow previous declarations without error. Shows the revealed types at different points as shadowing occurs between variables and functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/function.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nf = 1\nreveal_type(f)  # revealed: Literal[1]\n\ndef f(): ...\n\nreveal_type(f)  # revealed: def f() -> Unknown\n\ndef f(x: int) -> int:\n    raise NotImplementedError\n\nreveal_type(f)  # revealed: def f(x: int) -> int\n\nf: int = 1\nreveal_type(f)  # revealed: Literal[1]\n\ndef f(): ...\n\nreveal_type(f)  # revealed: def f() -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Keyword-Only Parameters in Python\nDESCRIPTION: Shows a lambda expression with keyword-only parameters and its type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda a, *, b=2, c: b)  # revealed: (a, *, b=Literal[2], c) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'while True' Loop in Python\nDESCRIPTION: Shows type analysis with an always-true loop condition that contains a break statement. The loop body is executed once before breaking, so the variable 'x' becomes 2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nwhile True:\n    x = 2\n    break\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: If-Elif Without Else Analysis\nDESCRIPTION: Demonstrates type tracking in an if-elif chain without an else clause.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    y = 1\n    y = 2\n\n    if flag:\n        y = 3\n    elif flag2:\n        y = 4\n\n    reveal_type(y)  # revealed: Literal[2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Aliased type()\nDESCRIPTION: Demonstrates that type narrowing works even when the type() function is aliased to another name.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B):\n    alias_for_type = type\n\n    if alias_for_type(x) is A:\n        reveal_type(x)  # revealed: A\n```\n\n----------------------------------------\n\nTITLE: Importing Typing Module with Function Definition in Python\nDESCRIPTION: This snippet imports the Any type from typing module and the collections module, followed by a simple function definition. The code includes a comment indicating a newline should be added after imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nimport collections\n# Newline should be added here\ndef foo():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Mixed Union Styles Type Usage\nDESCRIPTION: Demonstrates combining new-style and old-style union syntax with type[].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nclass BasicUser: ...\nclass ProUser: ...\n\nclass A:\n    class B:\n        class C: ...\n\ndef f(a: type[BasicUser | Union[ProUser, A.B.C]], b: type[Union[BasicUser | Union[ProUser, A.B.C | str]]]):\n    reveal_type(a)  # revealed: type[BasicUser] | type[ProUser] | type[C]\n    reveal_type(b)  # revealed: type[BasicUser] | type[ProUser] | type[C] | type[str]\n```\n\n----------------------------------------\n\nTITLE: Basic Class Initialization Error Example\nDESCRIPTION: Demonstrates error cases when initializing a class with missing required parameters for both __new__ and __init__ methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(Foo())  # revealed: Foo\n\nreveal_type(Foo(1))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Conditional Class Definitions in Python\nDESCRIPTION: Shows how conditionally defined classes replace previous definitions. The class 'C' is defined with different attributes depending on the condition, and only the definition in the always-executed branch is used.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nif True:\n    class C:\n        x: int = 1\n\nelse:\n    class C:\n        x: str = \"a\"\n\nreveal_type(C.x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Multiple AND Conditions Type Narrowing - Python\nDESCRIPTION: Illustrates type narrowing with multiple 'and' conditions in different arrangements, showing how type revelation varies based on condition order.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/boolean.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool, flag3: bool, flag4: bool):\n    class A: ...\n    x: A | None = A() if flag1 else None\n\n    flag2 and isinstance(x, A) and reveal_type(x)  # revealed: A\n    isinstance(x, A) and flag2 and reveal_type(x)  # revealed: A\n    reveal_type(x) and isinstance(x, A) and flag3  # revealed: A | None\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Statically Known Arms\nDESCRIPTION: Demonstrates type narrowing behavior with static boolean values in conditional expressions\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B):\n    if isinstance(x, A) and True:\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: B & ~A\n\n    if True and isinstance(x, A):\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: B & ~A\n\n    if False and isinstance(x, A):\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: A | B\n\n    if False or isinstance(x, A):\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: B & ~A\n\n    if True or isinstance(x, A):\n        reveal_type(x)  # revealed: A | B\n    else:\n        reveal_type(x)  # revealed: B & ~A\n\n    reveal_type(x)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: LiteralString Truthiness\nDESCRIPTION: Shows type narrowing behavior specifically for LiteralString types in boolean contexts. Demonstrates how empty and non-empty string literals are handled.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\ndef _(x: LiteralString):\n    if x:\n        reveal_type(x)  # revealed: LiteralString & ~Literal[\"\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"\"]\n\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement on sys.platform in Python\nDESCRIPTION: Shows how type checking can determine which branch of a match statement on sys.platform will execute based on the runtime environment. Only the 'darwin' variable is accessible.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nmatch sys.platform:\n    case \"linux\":\n        linux = True\n    case \"darwin\":\n        darwin = True\n    case \"win32\":\n        win32 = True\n    case _:\n        other = True\n\n# error: [unresolved-reference]\nlinux\n\n# no error\ndarwin\n\n# error: [unresolved-reference]\nwin32\n\n# error: [unresolved-reference]\nother\n```\n\n----------------------------------------\n\nTITLE: Gradual Type Checking\nDESCRIPTION: Shows how assert_type handles gradual typing with Any and Unknown types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom typing_extensions import Literal, assert_type\n\nfrom knot_extensions import Unknown\n\n# Any and Unknown are considered equivalent\ndef _(a: Unknown, b: Any):\n    reveal_type(a)  # revealed: Unknown\n    assert_type(a, Any)  # fine\n\n    reveal_type(b)  # revealed: Any\n    assert_type(b, Unknown)  # fine\n\ndef _(a: type[Unknown], b: type[Any]):\n    reveal_type(a)  # revealed: type[Unknown]\n    assert_type(a, type[Any])  # fine\n\n    reveal_type(b)  # revealed: type[Any]\n    assert_type(b, type[Unknown])  # fine\n```\n\n----------------------------------------\n\nTITLE: Alpine Docker Image Tag Update\nDESCRIPTION: Configuration change for Alpine-based Docker images, updating the default tag from 3.20 to 3.21 released in December 2024.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nruff:alpine -> 3.21\nruff:alpine3.20 -> deprecated\n```\n\n----------------------------------------\n\nTITLE: Bound Variable with 'if False...else' in Python\nDESCRIPTION: Demonstrates how variables defined in always-executed else blocks are considered bound. The variable 'x' is accessible without errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    pass\nelse:\n    x = 1\n\n# x is always bound, no error\nx\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Annotated Type Usage in Python\nDESCRIPTION: This snippet shows various usages of the Annotated type, illustrating that Annotated[T, ...] is equivalent to T, with metadata arguments being ignored.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Annotated\n\ndef _(x: Annotated[int, \"foo\"]):\n    reveal_type(x)  # revealed: int\n\ndef _(x: Annotated[int, lambda: 0 + 1 * 2 // 3, _(4)]):\n    reveal_type(x)  # revealed: int\n\ndef _(x: Annotated[int, \"arbitrary\", \"metadata\", \"elements\", \"are\", \"fine\"]):\n    reveal_type(x)  # revealed: int\n\ndef _(x: Annotated[tuple[str, int], bytes]):\n    reveal_type(x)  # revealed: tuple[str, int]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unresolved Import From Statement in Python\nDESCRIPTION: This example demonstrates an unresolved import from statement. The import of 'baz' from 'bar' cannot be resolved, leading to an error and unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom bar import baz  # error: \"Cannot resolve import `bar`\"\n\nreveal_type(baz)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Import Error with typing.Never in Python 3.10\nDESCRIPTION: Demonstrates that trying to import Never from typing in Python 3.10 will result in an unresolved import error, as it's only available from Python 3.11.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/never.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom typing import Never\n```\n\n----------------------------------------\n\nTITLE: Python 3.9 Ellipsis Type Configuration and Usage\nDESCRIPTION: Shows the environment configuration for Python 3.9 and demonstrates how ellipsis type is revealed in that version. In Python 3.9, ellipsis is typed simply as 'ellipsis'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/ellipsis.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(...)  # revealed: ellipsis\n```\n\n----------------------------------------\n\nTITLE: Unknown Argument Error in Python Function Call\nDESCRIPTION: Shows an error when passing an unknown argument to a function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    return 1\n\n# error: 20 [unknown-argument] \"Argument `y` does not match any known parameter of function `f`\"\nreveal_type(f(x=1, y=2))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Defining '-stubs' Named Module in Python\nDESCRIPTION: Creates a stub file for a module named with '-stubs' suffix, which isn't a valid stub package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    name: str\n    age: int\n```\n\n----------------------------------------\n\nTITLE: Formatting Trailing End-of-Line Comments in Python\nDESCRIPTION: Demonstrates how Ruff and Black handle trailing end-of-line comments differently. While Black collapses statements with comments, Ruff expands them to preserve comment context.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Input\nwhile (\n    cond1  # almost always true\n    and cond2  # almost never true\n):\n    print(\"Do something\")\n\n# Black\nwhile cond1 and cond2:  # almost always true  # almost never true\n    print(\"Do something\")\n```\n\n----------------------------------------\n\nTITLE: Using __getitem__ Method for Membership Tests in Python\nDESCRIPTION: Demonstrates the fallback mechanism where Python uses __getitem__ with sequential integer keys (0, 1, 2...) until finding the item or catching an IndexError to determine membership.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __getitem__(self, key: int) -> str:\n        return \"foo\"\n\nreveal_type(\"hello\" in A())  # revealed: bool\nreveal_type(\"hello\" not in A())  # revealed: bool\nreveal_type(42 in A())  # revealed: bool\nreveal_type(42 not in A())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Conditional Arms with Boolean Flags\nDESCRIPTION: Shows how boolean flags affect type narrowing in conditional statements\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(flag: bool, x: A | B):\n    if isinstance(x, A) and flag:\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: A | B\n\n    if flag and isinstance(x, A):\n        reveal_type(x)  # revealed: A\n    else:\n        reveal_type(x)  # revealed: A | B\n\n    reveal_type(x)  # revealed: A | B\n```\n\n----------------------------------------\n\nTITLE: Using type[...] with a Non-Trivial Constructor Class in Python\nDESCRIPTION: Shows type checking behavior with a class having a constructor that requires parameters. Includes examples of valid and invalid constructor calls with type error annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/subclass_of.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self, x: int): ...\n\ndef _(subclass_of_c: type[C]):\n    reveal_type(subclass_of_c(1))  # revealed: C\n\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\\\"a\\\"]\"\n    reveal_type(subclass_of_c(\"a\"))  # revealed: C\n    # error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__init__`\"\n    reveal_type(subclass_of_c())  # revealed: C\n    # error: [too-many-positional-arguments] \"Too many positional arguments to bound method `__init__`: expected 1, got 2\"\n    reveal_type(subclass_of_c(1, 2))  # revealed: C\n```\n\n----------------------------------------\n\nTITLE: Possibly-Unbound Attributes in Class Union\nDESCRIPTION: Shows type checking behavior when an attribute is possibly-unbound in at least one class of a union type. Demonstrates how conditional attribute definition affects type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag1: bool, flag2: bool):\n    class C1:\n        x = 1\n\n    class C2:\n        if flag:\n            x = 2\n\n    class C3:\n        x = 3\n\n    C = C1 if flag1 else C2 if flag2 else C3\n\n    # error: [possibly-unbound-attribute] \"Attribute `x` on type `Literal[C1, C2, C3]` is possibly unbound\"\n    reveal_type(C.x)  # revealed: Unknown | Literal[1, 2, 3]\n\n    # error: [possibly-unbound-attribute]\n    C.x = 100\n\n    # error: [possibly-unbound-attribute] \"Attribute `x` on type `C1 | C2 | C3` is possibly unbound\"\n    reveal_type(C().x)  # revealed: Unknown | Literal[1, 2, 3]\n\n    # error: [possibly-unbound-attribute]\n    C().x = 100\n```\n\n----------------------------------------\n\nTITLE: Invalid Parameter Type Callable\nDESCRIPTION: Shows incorrect usage of Callable with invalid parameter type arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\n# error: [invalid-type-form] \"The first argument to `Callable` must be either a list of types, ParamSpec, Concatenate, or `...`\"\ndef _(c: Callable[int, str]):\n    reveal_type(c)  # revealed: (...) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Python Module with Integer Variable Definition\nDESCRIPTION: This snippet defines a Python module 'a/b.py' with an integer variable 'c'. It provides context for the invalid nested module import example, showing the actual structure of the imported module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/invalid_syntax.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nc: int = 1\n```\n\n----------------------------------------\n\nTITLE: Testing String Literal and LiteralString Type Assignability in Python\nDESCRIPTION: Demonstrates the hierarchy of string-related types where string literals are assignable to both LiteralString and str types, and LiteralString is assignable to str but not vice versa.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to\nfrom typing_extensions import Literal, LiteralString\n\nstatic_assert(is_assignable_to(Literal[\"foo\"], Literal[\"foo\"]))\nstatic_assert(is_assignable_to(Literal[\"foo\"], LiteralString))\nstatic_assert(is_assignable_to(Literal[\"foo\"], str))\n\nstatic_assert(is_assignable_to(LiteralString, str))\n\nstatic_assert(not is_assignable_to(Literal[\"foo\"], Literal[\"bar\"]))\nstatic_assert(not is_assignable_to(str, Literal[\"foo\"]))\nstatic_assert(not is_assignable_to(str, LiteralString))\n```\n\n----------------------------------------\n\nTITLE: Constrained Typevar Examples\nDESCRIPTION: Examples demonstrating behavior of constrained typevars versus union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef same_constrained_types[T: (int, str)](t1: T, t2: T) -> T:\n    return t1 + t2\n\ndef unions_are_different(t1: int | str, t2: int | str) -> int | str:\n    return t1 + t2\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Type Stubs\nDESCRIPTION: Python code demonstrating usage of custom type stubs with type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nb: BuiltinClass = builtin_symbol\n\nclass OtherClass: ...\n\no: OtherClass = builtin_symbol  # error: [invalid-assignment]\n\n# Make sure that 'sys' has a proper entry in the auto-generated 'VERSIONS' file\nimport sys\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Module Attributes\nDESCRIPTION: Demonstrates accessing attributes in nested classes through a module import path, with type checking for assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nimport outer.nested.inner\n\nreveal_type(outer.nested.inner.Outer.Nested.Inner.attr)  # revealed: int\n\n# error: [invalid-assignment]\nouter.nested.inner.Outer.Nested.Inner.attr = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local Type Inference in Python\nDESCRIPTION: This snippet shows how local type inference works with annotations. The type of 'y' is inferred as Literal[1] despite the int annotation on 'x'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nx: int\ny = x\n\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Using Async Comprehension at Top Level in Python\nDESCRIPTION: A valid async comprehension used at the top level that asynchronously iterates over the elements generator. This syntax is supported in all Python versions with async comprehension support.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/async_comprehension.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n[x async for x in elements(5)]  # okay, async at top level\n```\n\n----------------------------------------\n\nTITLE: Assigning Pure Instance Attributes in Python\nDESCRIPTION: Shows setting pure instance attributes on instances and class objects. Demonstrates that these attributes can only be set on instances, with an error when attempting to set on the class object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self):\n        self.attr: int = 0\n\ninstance = C()\ninstance.attr = 1  # fine\ninstance.attr = \"wrong\"  # error: [invalid-assignment]\n\nC.attr = 1  # error: [invalid-attribute-access]\n```\n\n----------------------------------------\n\nTITLE: Reachability Analysis with Known Terminal Statements in Python\nDESCRIPTION: This example demonstrates how Ruff's type checker models reachability using visibility constraints when a return statement is known to always execute. The assignment after the always-executed return is not visible to the reveal_type call.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef _(cond: bool):\n    x = \"a\"\n    if cond:\n        x = \"b\"\n        if True:\n            return\n\n    reveal_type(x)  # revealed: Literal[\"a\"]\n```\n\n----------------------------------------\n\nTITLE: argparse.Namespace __getattr__ Example\nDESCRIPTION: Shows how the standard library's argparse.Namespace implements __getattr__, revealing arbitrary attributes as Any type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\n\ndef _(ns: argparse.Namespace):\n    reveal_type(ns.whatever)  # revealed: Any\n```\n\n----------------------------------------\n\nTITLE: Star Import with Visibility Constraints\nDESCRIPTION: Shows how visibility constraints affect symbol availability in star imports based on Python version\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nif sys.version_info >= (3, 11):\n    X: bool = True\nelse:\n    Y: bool = False\n    Z: int = 42\n```\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nZ: bool = True\n\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\n\n# error: [unresolved-reference]\nreveal_type(Y)  # revealed: Unknown\n\nreveal_type(Z)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Partial Declarations in Try-Except Block in Python (No Error)\nDESCRIPTION: This example shows another case where Ruff avoids raising a conflicting-declarations error. It demonstrates partial declarations within a try-except block, referencing a specific GitHub issue for more context.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    try:\n        x: int = 1\n    except:\n        x = 2\n\n    x = 3\n```\n\n----------------------------------------\n\nTITLE: Basic super() Function Type Checking Examples in Python\nDESCRIPTION: Demonstrates various invalid super() function calls and their corresponding type errors. Shows how the type system enforces that the second argument must be an instance or subclass of the first argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# revealed: Unknown\nreveal_type(super(int, str()))\n\n# error: [invalid-super-argument] \"`Literal[str]` is not an instance or subclass of `Literal[int]` in `super(Literal[int], Literal[str])` call\"\n# revealed: Unknown\nreveal_type(super(int, str))\n\nclass A: ...\nclass B(A): ...\n\n# error: [invalid-super-argument] \"`A` is not an instance or subclass of `Literal[B]` in `super(Literal[B], A)` call\"\n# revealed: Unknown\nreveal_type(super(B, A()))\n\n# error: [invalid-super-argument] \"`object` is not an instance or subclass of `Literal[B]` in `super(Literal[B], object)` call\"\n# revealed: Unknown\nreveal_type(super(B, object()))\n\n# error: [invalid-super-argument] \"`Literal[A]` is not an instance or subclass of `Literal[B]` in `super(Literal[B], Literal[A])` call\"\n# revealed: Unknown\nreveal_type(super(B, A))\n\n# error: [invalid-super-argument] \"`Literal[object]` is not an instance or subclass of `Literal[B]` in `super(Literal[B], Literal[object])` call\"\n# revealed: Unknown\nreveal_type(super(B, object))\n\nsuper(object, object()).__class__\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Pyupgrade on CPython\nDESCRIPTION: Run a benchmark for Pyupgrade on the CPython codebase, measuring its performance in upgrading Python syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nhyperfine --ignore-failure --warmup 5 --prepare \"git reset --hard HEAD\" \\\n  \"find . -type f -name \\\"*.py\\\" | xargs -P 0 pyupgrade --py311-plus\"\n```\n\n----------------------------------------\n\nTITLE: False Negative: Different __slots__ Types Based on Condition\nDESCRIPTION: Demonstrates how conditional logic can create different __slots__ configurations that might lead to undetected incompatibilities because the static analyzer cannot determine the runtime configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A:\n        if flag:\n            __slots__ = (\"a\", \"b\")\n        else:\n            __slots__ = ()\n\n    class B:\n        __slots__ = (\"c\", \"d\")\n\n    # Might or might not be fine at runtime\n    class C(A, B): ...\n```\n\n----------------------------------------\n\nTITLE: Conditional Global vs Builtin with Annotation\nDESCRIPTION: Shows the same type union behavior when the conditional global variable is explicitly annotated. The type system still maintains the union between the builtin and the annotated type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/builtin.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef returns_bool() -> bool:\n    return True\n\nif returns_bool():\n    chr: int = 1\n\ndef f():\n    reveal_type(chr)  # revealed: int | (def chr(i: int | SupportsIndex, /) -> str)\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Comparison for Different Classes in Python\nDESCRIPTION: Demonstrates how to implement rich comparison methods for comparing instances of different classes, where class A implements comparison methods for class B.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass EqReturnType: ...\nclass NeReturnType: ...\nclass LtReturnType: ...\nclass LeReturnType: ...\nclass GtReturnType: ...\nclass GeReturnType: ...\n\nclass A:\n    def __eq__(self, other: B) -> EqReturnType:\n        return EqReturnType()\n\n    def __ne__(self, other: B) -> NeReturnType:\n        return NeReturnType()\n\n    def __lt__(self, other: B) -> LtReturnType:\n        return LtReturnType()\n\n    def __le__(self, other: B) -> LeReturnType:\n        return LeReturnType()\n\n    def __gt__(self, other: B) -> GtReturnType:\n        return GtReturnType()\n\n    def __ge__(self, other: B) -> GeReturnType:\n        return GeReturnType()\n\nclass B: ...\n\nreveal_type(A() == B())  # revealed: EqReturnType\nreveal_type(A() != B())  # revealed: NeReturnType\nreveal_type(A() < B())  # revealed: LtReturnType\nreveal_type(A() <= B())  # revealed: LeReturnType\nreveal_type(A() > B())  # revealed: GtReturnType\nreveal_type(A() >= B())  # revealed: GeReturnType\n```\n\n----------------------------------------\n\nTITLE: Static Assertions for AlwaysTruthy and AlwaysFalsy\nDESCRIPTION: This snippet utilizes static assertions to verify relationships between types defined as AlwaysTruthy and AlwaysFalsy. It checks their disjoint status against None and Literal types using knot_extensions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import AlwaysFalsy, AlwaysTruthy, is_disjoint_from, static_assert\nfrom typing import Literal\n\nstatic_assert(is_disjoint_from(None, AlwaysTruthy))\nstatic_assert(not is_disjoint_from(None, AlwaysFalsy))\n\nstatic_assert(is_disjoint_from(AlwaysFalsy, AlwaysTruthy))\nstatic_assert(not is_disjoint_from(str, AlwaysFalsy))\nstatic_assert(not is_disjoint_from(str, AlwaysTruthy))\n\nstatic_assert(is_disjoint_from(Literal[1, 2], AlwaysFalsy))\nstatic_assert(not is_disjoint_from(Literal[0, 1], AlwaysTruthy))\n```\n\n----------------------------------------\n\nTITLE: Handling Conflicting Type Qualifiers with ClassVar in Python\nDESCRIPTION: Shows how ClassVar behaves when there are conflicting type qualifiers in conditional branches. The type system considers 'a' to be a ClassVar since it conservatively unions the qualifiers, preventing instance-level writes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\ndef flag() -> bool:\n    return True\n\nclass C:\n    if flag():\n        a: ClassVar[int] = 1\n    else:\n        a: str\n\nreveal_type(C.a)  # revealed: int | str\n\nc = C()\n\n# error: [invalid-attribute-access]\nc.a = 2\n```\n\n----------------------------------------\n\nTITLE: Mixed Type Literal Narrowing with Tuple Membership\nDESCRIPTION: Shows type narrowing behavior when testing mixed string and integer Literal types against a tuple.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: Literal[\"a\", \"b\", \"c\", 1]):\n    if x in (\"a\", \"b\", \"c\", 2):\n        reveal_type(x)  # revealed: Literal[\"a\", \"b\", \"c\"]\n    else:\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Unary Operators on Class Objects\nDESCRIPTION: Shows how unary operators behave when applied to class objects rather than instances. Demonstrates that instance methods are not available to the class itself without metaclass implementation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/custom.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Yes:\n    def __pos__(self) -> bool:\n        return False\n\n    def __neg__(self) -> str:\n        return \"negative\"\n\n    def __invert__(self) -> int:\n        return 17\n\nclass Sub(Yes): ...\nclass No: ...\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `Literal[Yes]`\"\nreveal_type(+Yes)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `Literal[Yes]`\"\nreveal_type(-Yes)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `Literal[Yes]`\"\nreveal_type(~Yes)  # revealed: Unknown\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `Literal[Sub]`\"\nreveal_type(+Sub)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `Literal[Sub]`\"\nreveal_type(-Sub)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `Literal[Sub]`\"\nreveal_type(~Sub)  # revealed: Unknown\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `Literal[No]`\"\nreveal_type(+No)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `Literal[No]`\"\nreveal_type(-No)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `Literal[No]`\"\nreveal_type(~No)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Trailing Whitespace in knot: ignore Comments in Python\nDESCRIPTION: Demonstrates that trailing whitespace after a knot: ignore directive is allowed but generally should be avoided for clean code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\na = 10 / 0  # knot: ignore[division-by-zero]      \n            #                               ^^^^^^ trailing whitespace\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Module Name in Python Import\nDESCRIPTION: This snippet shows an invalid import statement where the module name is missing after the 'from' keyword. It results in a syntax error and unknown type inference for the imported object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/invalid_syntax.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom import bar  # error: [invalid-syntax]\n\nreveal_type(bar)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: No Fallback Behavior for __contains__ in Python Membership Tests\nDESCRIPTION: Illustrates how having a __contains__ method with type constraints prevents fallback to __iter__ or __getitem__ when using 'in' with incompatible types, leading to errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass CheckContains: ...\nclass CheckIter: ...\nclass CheckGetItem: ...\n\nclass CheckIterIterator:\n    def __next__(self) -> CheckIter:\n        return CheckIter()\n\nclass A:\n    def __contains__(self, item: CheckContains) -> bool:\n        return True\n\n    def __iter__(self) -> CheckIterIterator:\n        return CheckIterIterator()\n\n    def __getitem__(self, key: int) -> CheckGetItem:\n        return CheckGetItem()\n\nreveal_type(CheckContains() in A())  # revealed: bool\n\n# error: [unsupported-operator] \"Operator `in` is not supported for types `CheckIter` and `A`\"\nreveal_type(CheckIter() in A())  # revealed: bool\n# error: [unsupported-operator] \"Operator `in` is not supported for types `CheckGetItem` and `A`\"\nreveal_type(CheckGetItem() in A())  # revealed: bool\n\nclass B:\n    def __iter__(self) -> CheckIterIterator:\n        return CheckIterIterator()\n\n    def __getitem__(self, key: int) -> CheckGetItem:\n        return CheckGetItem()\n\nreveal_type(CheckIter() in B())  # revealed: bool\n# Always use `__iter__`, regardless of iterated type; there's no NotImplemented\n# in this case, so there's no fallback to `__getitem__`\nreveal_type(CheckGetItem() in B())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Importing Unbound Symbol from Module in Python\nDESCRIPTION: Shows how importing a symbol that is only defined in unreachable code results in an unresolved import error. The variable 'symbol' is considered unbound in the module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom module import symbol\n```\n\n----------------------------------------\n\nTITLE: Invalid Boolean Conversion in While Loop Condition\nDESCRIPTION: Demonstrates error detection for objects with incorrectly implemented __bool__ method in while loop conditions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\nwhile NotBoolable():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Outer Reference List Comprehensions in Python\nDESCRIPTION: Demonstrates list comprehensions that reference variables from outer comprehensions using custom iterable classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\nclass IteratorOfIterables:\n    def __next__(self) -> IntIterable:\n        return IntIterable()\n\nclass IterableOfIterables:\n    def __iter__(self) -> IteratorOfIterables:\n        return IteratorOfIterables()\n\n# revealed: tuple[int, IntIterable]\n[[reveal_type((x, y)) for x in y] for y in IterableOfIterables()]\n```\n\n----------------------------------------\n\nTITLE: Formatting Nested Expressions in Python\nDESCRIPTION: Demonstrates the different approaches to formatting long conditional expressions and type annotations between Black and Ruff.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Black\n[\n    \"____________________________\",\n    \"foo\",\n    \"bar\",\n    (\n        \"baz\"\n        if some_really_looooooooong_variable\n        else \"some other looooooooooooooong value\"\n    ),\n]\n\n# Ruff\n[\n    \"____________________________\",\n    \"foo\",\n    \"bar\",\n    \"baz\"\n    if some_really_looooooooong_variable\n    else \"some other looooooooooooooong value\",\n]\n```\n\n----------------------------------------\n\nTITLE: Importing Math Module with Matplotlib Configuration in Python\nDESCRIPTION: Imports the math module and configures matplotlib to display plots inline in a Jupyter notebook. Assigns the value of pi to a variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command_expected.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\n%matplotlib inline\n\n\n_ = math.pi\n```\n\n----------------------------------------\n\nTITLE: Defining PEP 695 Type Variables in Python\nDESCRIPTION: Demonstrates the new syntax for defining type variables introduced by PEP 695. The example shows how to define a type variable T and reveals its type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f[T]():\n    reveal_type(type(T))  # revealed: Literal[TypeVar]\n    reveal_type(T)  # revealed: T\n    reveal_type(T.__name__)  # revealed: Literal[\"T\"]\n```\n\n----------------------------------------\n\nTITLE: Unsupported Binary Operations on Heterogeneous Union Types\nDESCRIPTION: Shows that operations like addition cannot be performed on union types (int | str) because the operation isn't defined for all possible type combinations, such as int + str.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/unions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f2(i: int, s: str, int_or_str: int | str):\n    i + i\n    s + s\n    # error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `int | str` and `int | str`\"\n    reveal_type(int_or_str + int_or_str)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Deep Generic Parameter Type Inference\nDESCRIPTION: Example showing type inference for nested generic types in parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f[T](x: list[T]) -> T:\n    return x[0]\n\nreveal_type(f([1.0, 2.0]))  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Equivalence of Complex Union Types with Callable Types\nDESCRIPTION: This code demonstrates that differently ordered unions inside Callable types inside unions can still be equivalent. It shows that the equivalence relation extends to complex nested type structures with callables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\nfrom knot_extensions import is_equivalent_to, static_assert\n\nstatic_assert(is_equivalent_to(int | Callable[[int | str], None], Callable[[str | int], None] | int))\n```\n\n----------------------------------------\n\nTITLE: Basic Intersection Types in Python\nDESCRIPTION: Demonstrates basic intersection type syntax using Intersection and Not operators with classes P and Q.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\n\nclass P: ...\nclass Q: ...\n\ndef _(\n    i1: Intersection[P, Q],\n    i2: Intersection[P, Not[Q]],\n    i3: Intersection[Not[P], Q],\n    i4: Intersection[Not[P], Not[Q]],\n) -> None:\n    reveal_type(i1)  # revealed: P & Q\n    reveal_type(i2)  # revealed: P & ~Q\n    reveal_type(i3)  # revealed: Q & ~P\n    reveal_type(i4)  # revealed: ~P & ~Q\n```\n\n----------------------------------------\n\nTITLE: No Type Narrowing with Keyword Arguments\nDESCRIPTION: Shows that type() cannot be used with keyword arguments for type narrowing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str | int):\n    # error: [no-matching-overload] \"No overload of class `type` matches arguments\"\n    if type(object=x) is str:\n        reveal_type(x)  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Callable Type Equivalence\nDESCRIPTION: This code tests equivalence between complex callable types with combinations of positional-only parameters, regular parameters, default values, variadic parameters, and keyword parameters. It demonstrates that structural equivalence is maintained despite different parameter names and default values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f5(a1: int, /, b: float, c: bool = False, *args1: int, d: int = 1, e: str, **kwargs1: float) -> None: ...\ndef f6(a2: int, /, b: float, c: bool = True, *args2: int, d: int = 2, e: str, **kwargs2: float) -> None: ...\n\nstatic_assert(is_equivalent_to(CallableTypeOf[f5], CallableTypeOf[f6]))\nstatic_assert(is_equivalent_to(CallableTypeOf[f5] | bool | CallableTypeOf[f6], CallableTypeOf[f6] | bool | CallableTypeOf[f5]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested Mixed Re-export in Python\nDESCRIPTION: This series of snippets shows a chain of modules where one module explicitly re-exports a symbol. Despite this, importing from the top-level module still results in an error due to lack of re-export in other modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `a` has no member `Any`\"\nfrom a import Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `c` has no member `Any`\"\nfrom c import Any as Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nreveal_type(Any)  # revealed: typing.Any\n```\n\n----------------------------------------\n\nTITLE: Tuple Unpacking Operations\nDESCRIPTION: Shows tuple unpacking patterns with and without semicolons and comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Tuple unpacking without a semicolon\nx, y = 1, 2\n```\n\nLANGUAGE: python\nCODE:\n```\n# Tuple unpacking with a semicolon (irrelevant)\nx, y = 1, 2;\nx, y = 1, 2;  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Defining Pentagon Stub in Namespace Package\nDESCRIPTION: Creates a stub file for the 'Pentagon' class in a namespace package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Pentagon:\n    sides: int\n    area: float\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with conditional __new__ method in Python\nDESCRIPTION: Demonstrates type checking and error handling for a class with a conditionally defined __new__ method, covering various argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    class Foo:\n        if flag:\n            def __new__(cls, x: int): ...\n        else:\n            def __new__(cls, x: int, y: int = 1): ...\n\n    reveal_type(Foo(1))  # revealed: Foo\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"1\"]`\"\n    reveal_type(Foo(\"1\"))  # revealed: Foo\n    # error: [missing-argument] \"No argument provided for required parameter `x` of function `__new__`\"\n    reveal_type(Foo())  # revealed: Foo\n    # error: [too-many-positional-arguments] \"Too many positional arguments to function `__new__`: expected 1, got 2\"\n    reveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: TypeAliasType Properties\nDESCRIPTION: Demonstrates the behavior of TypeAliasType comparisons and assertions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_equivalent_to, is_disjoint_from, TypeOf\n\ntype Alias1 = int\ntype Alias2 = int\n\ntype TypeAliasType1 = TypeOf[Alias1]\ntype TypeAliasType2 = TypeOf[Alias2]\n\nstatic_assert(not is_equivalent_to(TypeAliasType1, TypeAliasType2))\nstatic_assert(is_disjoint_from(TypeAliasType1, TypeAliasType2))\n```\n\n----------------------------------------\n\nTITLE: Defining a Set with a Numeric Literal (Black)\nDESCRIPTION: This snippet shows how Black formats a set containing a numeric literal with parentheses. Black removes the parentheses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nitems = {123}\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Custom Class Instances in Python\nDESCRIPTION: Shows how type inference works with custom class instances based on their __bool__ and __len__ methods. Classes with a __bool__ method that returns a literal value result in precise type inference, while others result in general bool type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass AlwaysTrue:\n    def __bool__(self) -> Literal[True]:\n        return True\n\n# revealed: Literal[False]\nreveal_type(not AlwaysTrue())\n\nclass AlwaysFalse:\n    def __bool__(self) -> Literal[False]:\n        return False\n\n# revealed: Literal[True]\nreveal_type(not AlwaysFalse())\n\n# At runtime, no `__bool__` and no `__len__` means truthy, but we can't rely on that, because\n# a subclass could add a `__bool__` method.\nclass NoBoolMethod: ...\n\n# revealed: bool\nreveal_type(not NoBoolMethod())\n\n# And we can't rely on `__len__` for the same reason: a subclass could add `__bool__`.\nclass LenZero:\n    def __len__(self) -> Literal[0]:\n        return 0\n\n# revealed: bool\nreveal_type(not LenZero())\n\nclass LenNonZero:\n    def __len__(self) -> Literal[1]:\n        return 1\n\n# revealed: bool\nreveal_type(not LenNonZero())\n\nclass WithBothLenAndBool1:\n    def __bool__(self) -> Literal[False]:\n        return False\n\n    def __len__(self) -> Literal[2]:\n        return 2\n\n# revealed: Literal[True]\nreveal_type(not WithBothLenAndBool1())\n\nclass WithBothLenAndBool2:\n    def __bool__(self) -> Literal[True]:\n        return True\n\n    def __len__(self) -> Literal[0]:\n        return 0\n\n# revealed: Literal[False]\nreveal_type(not WithBothLenAndBool2())\n\nclass MethodBoolInvalid:\n    def __bool__(self) -> int:\n        return 0\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `MethodBoolInvalid`; the return type of its bool method (`int`) isn't assignable to `bool\"\n# revealed: bool\nreveal_type(not MethodBoolInvalid())\n\n# Don't trust a possibly-unbound `__bool__` method:\ndef get_flag() -> bool:\n    return True\n\nclass PossiblyUnboundBool:\n    if get_flag():\n        def __bool__(self) -> Literal[False]:\n            return False\n\n# revealed: bool\nreveal_type(not PossiblyUnboundBool())\n```\n\n----------------------------------------\n\nTITLE: Invalid Unpacking of Ellipsis Literal in For Loops in Stub Files\nDESCRIPTION: Iterating over an ellipsis literal as part of a for loop is invalid even in stub files, resulting in a \"not-iterable\" diagnostic. The type checker still reveals the variables as Unknown types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [not-iterable] \"Object of type `ellipsis` is not iterable\"\nfor a, b in ...:\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Nested If Expression Type Revelation\nDESCRIPTION: Illustrates nested if-expressions with multiple conditions, showing type revelation for three possible literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_expression.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    x = 1 if flag else 2 if flag2 else 3\n    reveal_type(x)  # revealed: Literal[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Fallback to Metaclass in Python\nDESCRIPTION: Demonstrates how method lookup falls back to the metaclass when not found on the class itself, creating a bound method to the class object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass Meta(type):\n    def f(cls, arg: int) -> str:\n        return \"a\"\n\nclass C(metaclass=Meta):\n    pass\n\nreveal_type(C.f)  # revealed: bound method Literal[C].f(arg: int) -> str\nreveal_type(C.f(1))  # revealed: str\n\n# error: [unresolved-attribute] \"Type `C` has no attribute `f`\"\nC().f\n\nfrom typing import Any, Literal\n\nclass D(metaclass=Meta):\n    def f(arg: int) -> Literal[\"a\"]:\n        return \"a\"\n\nreveal_type(D.f(1))  # revealed: Literal[\"a\"]\n\ndef flag() -> bool:\n    return True\n\nclass E(metaclass=Meta):\n    if flag():\n        def f(arg: int) -> Any:\n            return \"a\"\n\nreveal_type(E.f(1))  # revealed: str | Any\n```\n\n----------------------------------------\n\nTITLE: Aliasing typing.Any in Python\nDESCRIPTION: Shows that aliasing typing.Any to a different name still preserves its behavior as the Any type. The type system recognizes the aliased name as equivalent to Any.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/any.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any as RenamedAny\n\nx: RenamedAny = 1\nx = \"foo\"\n\ndef f():\n    reveal_type(x)  # revealed: Any\n```\n\n----------------------------------------\n\nTITLE: Synthetic Arguments Test\nDESCRIPTION: Tests invalid argument type detection with synthetic arguments using __call__ method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __call__(self, x: int) -> int:\n        return 1\n\nc = C()\nc(\"wrong\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Classmethod Descriptor Behavior\nDESCRIPTION: Demonstrates the behavior of classmethod descriptor __get__ method with various arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(getattr_static(C, \"f\").__get__(None, C))  # revealed: bound method Literal[C].f() -> Unknown\nreveal_type(getattr_static(C, \"f\").__get__(C(), C))  # revealed: bound method Literal[C].f() -> Unknown\nreveal_type(getattr_static(C, \"f\").__get__(C()))  # revealed: bound method type[C].f() -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure Example\nDESCRIPTION: Example directory structure showing package and project root organization in a Python project using Ruff.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nmy_project\n├── pyproject.toml\n└── src\n    └── foo\n        ├── __init__.py\n        └── bar\n            ├── __init__.py\n            └── baz.py\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with possibly unbound callable as __new__ method in Python\nDESCRIPTION: Shows the behavior and type checking for a class with a possibly unbound callable as the __new__ method, including error handling for different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    class Callable:\n        if flag:\n            def __call__(self, cls, x: int) -> \"Foo\":\n                return object.__new__(cls)\n\n    class Foo:\n        __new__ = Callable()\n\n    # error: [call-non-callable] \"Object of type `Callable` is not callable (possibly unbound `__call__` method)\"\n    reveal_type(Foo(1))  # revealed: Foo\n    # TODO should be - error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\n    # but we currently infer the signature of `__call__` as unknown, so it accepts any arguments\n    # error: [call-non-callable] \"Object of type `Callable` is not callable (possibly unbound `__call__` method)\"\n    reveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Invalid type() Function Calls with Incorrect Argument Types\nDESCRIPTION: Demonstrates type() function calls with incorrect argument types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Base: ...\n\n# error: [no-matching-overload] \"No overload of class `type` matches arguments\"\ntype(b\"Foo\", (), {})\n\n# error: [no-matching-overload] \"No overload of class `type` matches arguments\"\ntype(\"Foo\", Base, {})\n\n# TODO: this should be an error\ntype(\"Foo\", (1, 2), {})\n\n# TODO: this should be an error\ntype(\"Foo\", (Base,), {b\"attr\": 1})\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Multiple Single-Valued Options\nDESCRIPTION: Shows type narrowing behavior when comparing variables that each have multiple possible literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = 1 if flag1 else 2\n    y = 2 if flag2 else 3\n\n    if x != y:\n        reveal_type(x)  # revealed: Literal[1, 2]\n    else:\n        # TODO should be Literal[2]\n        reveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Indexing Into Python Lists with Numbers and Slices\nDESCRIPTION: Demonstrates basic list indexing operations with numeric indices and slices, showing expected type checking behavior. Includes examples of valid operations and an invalid string-based index that should generate an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/lists.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = [1, 2, 3]\nreveal_type(x)  # revealed: list\n\n# TODO reveal int\nreveal_type(x[0])  # revealed: @Todo(return type of overloaded function)\n\n# TODO reveal list\nreveal_type(x[0:1])  # revealed: @Todo(return type of overloaded function)\n\n# TODO error\nreveal_type(x[\"a\"])  # revealed: @Todo(return type of overloaded function)\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Singleton Types in Python\nDESCRIPTION: Demonstrates various basic singleton types and non-singleton types using the is_singleton function from knot_extensions. Tests literal types, None, Never, and various other type constructs.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, Never, Callable\nfrom knot_extensions import is_singleton, static_assert\n\nstatic_assert(is_singleton(None))\nstatic_assert(is_singleton(Literal[True]))\nstatic_assert(is_singleton(Literal[False]))\n\nstatic_assert(is_singleton(type[bool]))\n\nstatic_assert(not is_singleton(Never))\nstatic_assert(not is_singleton(str))\n\nstatic_assert(not is_singleton(Literal[345]))\nstatic_assert(not is_singleton(Literal[1, 2]))\n\nstatic_assert(not is_singleton(tuple[()]))\nstatic_assert(not is_singleton(tuple[None]))\nstatic_assert(not is_singleton(tuple[None, Literal[True]]))\n\nstatic_assert(not is_singleton(Callable[..., None]))\nstatic_assert(not is_singleton(Callable[[int, str], None]))\n```\n\n----------------------------------------\n\nTITLE: Importing Possibly Unbound Annotated Variables in Python\nDESCRIPTION: This snippet demonstrates importing possibly unbound annotated variables. It shows how type annotation affects the revealed type of imported variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [possibly-unbound-import] \"Member `y` of module `maybe_unbound_annotated` is possibly unbound\"\nfrom maybe_unbound_annotated import x, y\n\nreveal_type(x)  # revealed: Unknown | Literal[3]\nreveal_type(y)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Import Type Declaration from Regular Module\nDESCRIPTION: Shows type inference when importing from a regular .py module that includes both type declaration and value definition. Variable y inherits the int type from x defined in b.py.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stubs.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom b import x\n\ny = x\nreveal_type(y)  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\nx: int = 1\n```\n\n----------------------------------------\n\nTITLE: Type Checking with Nested Functions and Terminal Statements in Python\nDESCRIPTION: This example demonstrates how free references inside nested functions should handle variable bindings from the containing scope. The expected behavior is that the inner function should see all bindings for 'x' at the end of the containing scope, regardless of where return statements are placed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef top_level_return(cond1: bool, cond2: bool):\n    x = 1\n\n    def g():\n        # TODO eliminate Unknown\n        reveal_type(x)  # revealed: Unknown | Literal[1, 2, 3]\n    if cond1:\n        if cond2:\n            x = 2\n        else:\n            x = 3\n    return\n\ndef return_from_if(cond1: bool, cond2: bool):\n    x = 1\n\n    def g():\n        # TODO: Literal[1, 2, 3]\n        reveal_type(x)  # revealed: Unknown | Literal[1]\n    if cond1:\n        if cond2:\n            x = 2\n        else:\n            x = 3\n        return\n\ndef return_from_nested_if(cond1: bool, cond2: bool):\n    x = 1\n\n    def g():\n        # TODO: Literal[1, 2, 3]\n        reveal_type(x)  # revealed: Unknown | Literal[1, 3]\n    if cond1:\n        if cond2:\n            x = 2\n            return\n        else:\n            x = 3\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Jupyter Magic Commands with Import in Python\nDESCRIPTION: This snippet demonstrates the use of multiple Jupyter notebook magic commands (%time) along with a Python import statement. It shows how magic commands can be stacked before an import operation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%time\n%%time\nimport pathlib\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Forms with Intersection and Not\nDESCRIPTION: Demonstrates error cases where Intersection is used without arguments or Not is used without exactly one argument, resulting in invalid type forms.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\n\n# error: [invalid-type-form] \"`knot_extensions.Intersection` requires at least one argument when used in a type expression\"\ndef f(x: Intersection) -> None:\n    reveal_type(x)  # revealed: Unknown\n\n# error: [invalid-type-form] \"`knot_extensions.Not` requires exactly one argument when used in a type expression\"\ndef f(x: Not) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Accessing sys.platform Type with Linux Platform Configuration\nDESCRIPTION: Python code that imports sys and reveals the type of sys.platform when configured for Linux platform. The type is revealed as a string literal \"linux\".\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.platform)  # revealed: Literal[\"linux\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Typeshed in TOML\nDESCRIPTION: This TOML configuration specifies a custom typeshed directory to be used for type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Type Annotation with 'if False' in Python\nDESCRIPTION: Shows how type annotations in unreachable code paths (if False) are ignored. The variable 'x' maintains its original string type annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nx: str\n\nif False:\n    x: int\n\ndef f() -> None:\n    reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Violating Type Annotation in Python Assignment\nDESCRIPTION: This snippet demonstrates an invalid assignment where the assigned value doesn't match the declared type annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx: int = \"foo\"  # error: [invalid-assignment] \"Object of type `Literal[\"foo\"]` is not assignable to `int`\"\n```\n\n----------------------------------------\n\nTITLE: Selecting Preview Rules in Ruff (TOML)\nDESCRIPTION: Configuration to select specific preview rules in Ruff using pyproject.toml or ruff.toml. This example demonstrates how to extend the selected rule set with a hypothetical preview rule.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nextend-select = [\"HYP001\"]\n```\n\nLANGUAGE: toml\nCODE:\n```\n[lint]\nextend-select = [\"HYP001\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Pentagon Stub in Inconsistent Package\nDESCRIPTION: Creates a stub file for the 'Pentagon' class in an inconsistent stub package setup.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass Pentagon:\n    sides: int\n    area: float\n```\n\n----------------------------------------\n\nTITLE: Example Stacklevel Warning\nDESCRIPTION: Example showing B028 rule check for explicit stacklevel in warnings.warn\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nwarnings.warn(\"message\", stacklevel=2)\n```\n\n----------------------------------------\n\nTITLE: Simple `type: ignore` Usage in Python\nDESCRIPTION: A basic example of suppressing a type error on a single line using the `type: ignore` comment directive.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = 4 + test  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Starred Assignment in Python Classes\nDESCRIPTION: Shows how starred assignments work with class attributes, including type inference for both regular and starred parts of the assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self) -> None:\n        self.a, *self.b = (1, 2, 3)\n\nc_instance = C()\nreveal_type(c_instance.a)  # revealed: Unknown | Literal[1]\nreveal_type(c_instance.b)  # revealed: Unknown | @Todo(starred unpacking)\n```\n\n----------------------------------------\n\nTITLE: Collapsing Multiple Any/Unknown Contributions in Intersections\nDESCRIPTION: Demonstrates how multiple Any or Unknown types in an intersection simplify, as the intersection of unknown sets is still an unknown set.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not, Unknown\nfrom typing_extensions import Any\n\nclass P: ...\n\ndef any(\n    i1: Intersection[Any, Any],\n    i2: Intersection[P, Any, Any],\n    i3: Intersection[Any, P, Any],\n    i4: Intersection[Any, Any, P],\n) -> None:\n    reveal_type(i1)  # revealed: Any\n    reveal_type(i2)  # revealed: P & Any\n    reveal_type(i3)  # revealed: Any & P\n    reveal_type(i4)  # revealed: Any & P\n\ndef unknown(\n    i1: Intersection[Unknown, Unknown],\n    i2: Intersection[P, Unknown, Unknown],\n    i3: Intersection[Unknown, P, Unknown],\n    i4: Intersection[Unknown, Unknown, P],\n) -> None:\n    reveal_type(i1)  # revealed: Unknown\n    reveal_type(i2)  # revealed: P & Unknown\n    reveal_type(i3)  # revealed: Unknown & P\n    reveal_type(i4)  # revealed: Unknown & P\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing Limitations with Inheritance\nDESCRIPTION: Demonstrates current limitations in type narrowing when dealing with class inheritance hierarchies.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/type.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Base: ...\nclass Derived(Base): ...\n\ndef _(x: Base):\n    if type(x) is Base:\n        # Ideally, this could be narrower, but there is now way to\n        # express a constraint like `Base & ~ProperSubtypeOf[Base]`.\n        reveal_type(x)  # revealed: Base\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Export with Different Name in Python\nDESCRIPTION: This snippet shows that re-exporting a symbol with a different name does not follow the re-export convention. Attempting to import Foo from module 'a' results in an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `a` has no member `Foo`\"\nfrom a import Foo\n\nreveal_type(Foo)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import AnyFoo as Foo\n\nreveal_type(Foo)  # revealed: Literal[AnyFoo]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass AnyFoo: ...\n```\n\n----------------------------------------\n\nTITLE: Type Equivalence Checking\nDESCRIPTION: Demonstrates type equivalence rules and constraints when using assert_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Type, Union\nfrom typing_extensions import assert_type\n\n# Subtype does not count\ndef _(x: bool):\n    assert_type(x, int)  # error: [type-assertion-failure]\n\ndef _(a: type[int], b: type[Any]):\n    assert_type(a, type[Any])  # error: [type-assertion-failure]\n    assert_type(b, type[int])  # error: [type-assertion-failure]\n\n# The expression constructing the type is not taken into account\ndef _(a: type[int]):\n    assert_type(a, Type[int])  # fine\n```\n\n----------------------------------------\n\nTITLE: Testing Attribute Expression Syntax Error in Python\nDESCRIPTION: Demonstrates parser handling when using 'pass' keyword in attribute access.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# TODO: Check when support for attribute expressions is added\n\n# error: [invalid-syntax]\n# error: [unresolved-reference] \"Name `foo` used when not defined\"\nfor x in foo.pass:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Non-Matching Match Statement with Wildcard in Python\nDESCRIPTION: Demonstrates type analysis for a match statement with a wildcard pattern where the scrutinee doesn't match non-wildcard patterns. Without a wildcard action, the variable 'x' remains 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nmatch \"something else\":\n    case \"a\":\n        x = 2\n    case \"b\":\n        x = 3\n    case _:\n        pass\n\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Using Namespace Package Stubs in Python\nDESCRIPTION: Demonstrates usage of the stubbed 'Pentagon' and 'Hexagon' classes from a namespace package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom shapes.polygons.hexagon import Hexagon\nfrom shapes.polygons.pentagon import Pentagon\n\nreveal_type(Pentagon().sides)  # revealed: int\nreveal_type(Hexagon().area)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Callable Types and their Static Status in Python\nDESCRIPTION: Demonstrates how callable types in Python can be either fully-static or not, depending on their parameter and return types. Callable types with explicit parameters and return types that are fully-static are themselves fully-static.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_fully_static.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Callable, Any\nfrom knot_extensions import Unknown, is_fully_static, static_assert\n\nstatic_assert(is_fully_static(Callable[[], int]))\nstatic_assert(is_fully_static(Callable[[int, str], int]))\n\nstatic_assert(not is_fully_static(Callable[..., int]))\nstatic_assert(not is_fully_static(Callable[[], Any]))\nstatic_assert(not is_fully_static(Callable[[int, Unknown], int]))\n```\n\n----------------------------------------\n\nTITLE: Unknown Type Preservation\nDESCRIPTION: Demonstrates how Unknown types are preserved in unions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown\n\ndef _(u1: Unknown | str, u2: str | Unknown) -> None:\n    reveal_type(u1)  # revealed: Unknown | str\n    reveal_type(u2)  # revealed: str | Unknown\n```\n\n----------------------------------------\n\nTITLE: Aliased isinstance() Check\nDESCRIPTION: Shows that type narrowing works with aliased isinstance() function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    isinstance_alias = isinstance\n\n    x = 1 if flag else \"a\"\n\n    if isinstance_alias(x, int):\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Different Return Types\nDESCRIPTION: This code demonstrates that callable types with different return types or missing return types are not equivalent. It shows that the return type is a significant part of a callable's type identity.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef f3(): ...\ndef f4() -> None: ...\n\nstatic_assert(not is_equivalent_to(Callable[[], int], Callable[[], None]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f3], CallableTypeOf[f3]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f3], CallableTypeOf[f4]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f4], CallableTypeOf[f3]))\n```\n\n----------------------------------------\n\nTITLE: String Annotations with typing.Literal in Python\nDESCRIPTION: Shows how to use string annotations with the typing.Literal construct, demonstrating both direct string literals and string-annotated literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef f1(v: Literal[\"Foo\", \"Bar\"], w: 'Literal[\"Foo\", \"Bar\"]'):\n    reveal_type(v)  # revealed: Literal[\"Foo\", \"Bar\"]\n    reveal_type(w)  # revealed: Literal[\"Foo\", \"Bar\"]\n\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Annotated Conditional Globals\nDESCRIPTION: Shows type resolution for annotated conditional ModuleType attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n__file__: int = 42\n\ndef returns_bool() -> bool:\n    return True\n\nif returns_bool():\n    __name__: int = 1\n\nreveal_type(__file__)  # revealed: Literal[42]\nreveal_type(__name__)  # revealed: Literal[1] | str\n```\n\n----------------------------------------\n\nTITLE: Mixed Type Literal Narrowing with String Membership\nDESCRIPTION: Shows type narrowing behavior and error handling when testing mixed type Literals against a string.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: Literal[1, \"a\", \"b\", \"c\", \"d\"]):\n    # error: [unsupported-operator]\n    if x in \"abc\":\n        reveal_type(x)  # revealed: Literal[\"a\", \"b\", \"c\"]\n    else:\n        reveal_type(x)  # revealed: Literal[1, \"d\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Commutativity of Type Equivalence in Python\nDESCRIPTION: This code demonstrates that the equivalence relation is commutative. It shows that if type A is equivalent to type B, then type B is also equivalent to type A, using examples with type/type[object] and different Literal combinations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal\nfrom knot_extensions import is_equivalent_to, static_assert\n\nstatic_assert(is_equivalent_to(type, type[object]))\nstatic_assert(not is_equivalent_to(Literal[1, 0], Literal[1, 2]))\nstatic_assert(not is_equivalent_to(Literal[1, 2, 3], Literal[1, 2]))\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Mixed Value Types\nDESCRIPTION: Shows type narrowing behavior when comparing variables where one has literal values and the other has both literal and non-literal values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool, a: int):\n    x = 1 if flag1 else 2\n    y = 2 if flag2 else a\n\n    if x != y:\n        reveal_type(x)  # revealed: Literal[1, 2]\n    else:\n        reveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Line Continuation Type Error Suppression in Python\nDESCRIPTION: Examples showing how `type: ignore` comments after line continuations apply to all previous lines in the continued expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\na = test \\\n  + 2  # type: ignore\n\na = test \\\n  + a \\\n  + 2  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Named and Unnamed Callable Parameters\nDESCRIPTION: This code demonstrates that a callable type with named parameters is not equivalent to a callable type with unnamed parameters, even if the parameter types match.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(not is_equivalent_to(CallableTypeOf[f5], Callable[[int], None]))\n```\n\n----------------------------------------\n\nTITLE: Conditional Type Annotation with 'if True' in Python\nDESCRIPTION: Shows how type annotations in always-executed code paths (if True) override previous annotations. The variable 'x' becomes an int despite the earlier string annotation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nx: str\n\nif True:\n    x: int\n\ndef f() -> None:\n    reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Typevar Single Usage Examples\nDESCRIPTION: Examples showing incorrect usage of typevars when they're only used once. In these cases, object or specific types should be used instead.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef typevar_not_needed[T](x: T) -> None:\n    pass\n\ndef bounded_typevar_not_needed[T: int](x: T) -> None:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Special-cased Class Truthiness Assertions\nDESCRIPTION: Static assertions for various built-in Python types that are known to be always truthy. Demonstrates type checking for system types and typing utilities.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/truthiness.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport types\nimport typing\nimport sys\nfrom knot_extensions import AlwaysTruthy, static_assert, is_subtype_of\nfrom typing_extensions import _NoDefaultType\n\nstatic_assert(is_subtype_of(sys.version_info.__class__, AlwaysTruthy))\nstatic_assert(is_subtype_of(types.EllipsisType, AlwaysTruthy))\nstatic_assert(is_subtype_of(_NoDefaultType, AlwaysTruthy))\nstatic_assert(is_subtype_of(slice, AlwaysTruthy))\nstatic_assert(is_subtype_of(types.FunctionType, AlwaysTruthy))\nstatic_assert(is_subtype_of(types.MethodType, AlwaysTruthy))\nstatic_assert(is_subtype_of(typing.TypeVar, AlwaysTruthy))\nstatic_assert(is_subtype_of(typing.TypeAliasType, AlwaysTruthy))\nstatic_assert(is_subtype_of(types.MethodWrapperType, AlwaysTruthy))\nstatic_assert(is_subtype_of(types.WrapperDescriptorType, AlwaysTruthy))\n```\n\n----------------------------------------\n\nTITLE: Multiple Semicolon-Separated Expressions\nDESCRIPTION: Multiple expressions on single line separated by semicolon.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Semicolons with multiple expressions\nx; x\n```\n\n----------------------------------------\n\nTITLE: Incorrect Case Module Definition\nDESCRIPTION: Example module 'A.py' demonstrating incorrect casing scenario\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    x: int = 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PEP 695 Syntax for Method Typevars in Python\nDESCRIPTION: This snippet shows how PEP 695 syntax makes it clearer that a method uses a separate typevar from the class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    def m[S](self, x: T, y: S) -> S:\n        return y\n\nc: C[int] = C()\nreveal_type(c.m(1, \"string\"))  # revealed: Literal[\"string\"]\n```\n\n----------------------------------------\n\nTITLE: Reveal Type Stub Definition\nDESCRIPTION: Simple type stub implementation of reveal_type function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_10\n\nLANGUAGE: pyi\nCODE:\n```\ndef reveal_type(obj, /): ...\n```\n\n----------------------------------------\n\nTITLE: Handling Pragma Comments in Python\nDESCRIPTION: Shows how Ruff handles pragma comments differently from Black, preserving their position and meaning by expanding trailing end-of-line comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Input\n[\n    first(),  # noqa\n    second()\n]\n\n# Black\n[first(), second()]  # noqa\n\n# Ruff\n[\n    first(),  # noqa\n    second(),\n]\n```\n\n----------------------------------------\n\nTITLE: Instance Attribute Dunder Method\nDESCRIPTION: Demonstrates that dunder methods must be defined on the class, not as instance attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef add_impl(self, other) -> int:\n    return 1\n\nclass A:\n    def __init__(self):\n        self.__add__ = add_impl\n\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `A` and `A`\"\n# revealed: Unknown\nreveal_type(A() + A())\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Formatter in TOML\nDESCRIPTION: Demonstrates how to configure Ruff formatter options in pyproject.toml and ruff.toml files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nline-length = 100\n\n[tool.ruff.format]\nquote-style = \"single\"\nindent-style = \"tab\"\ndocstring-code-format = true\n```\n\nLANGUAGE: toml\nCODE:\n```\nline-length = 100\n\n[format]\nquote-style = \"single\"\nindent-style = \"tab\"\ndocstring-code-format = true\n```\n\n----------------------------------------\n\nTITLE: Dataclass Internal Type Information\nDESCRIPTION: Shows internal type information and method signatures for dataclass implementations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/dataclasses.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int | None = None\n\nreveal_type(type(Person))  # revealed: Literal[type]\nreveal_type(Person.__mro__)  # revealed: tuple[Literal[Person], Literal[object]]\n\n# TODO: proper signature\nreveal_type(Person.__init__)  # revealed: (*args: Any, **kwargs: Any) -> None\n\nreveal_type(Person.__repr__)  # revealed: def __repr__(self) -> str\n\nreveal_type(Person.__eq__)  # revealed: def __eq__(self, value: object, /) -> bool\n```\n\n----------------------------------------\n\nTITLE: Multiple Expressions with Semicolons\nDESCRIPTION: Example of multiple expressions on the same line separated by semicolons\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Semicolons with multiple expressions\nx; x;\n```\n\n----------------------------------------\n\nTITLE: Standard Library Function Test\nDESCRIPTION: Tests invalid argument type detection with standard library functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\njson.loads(5)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Suppressing Multiline Type Errors in Python\nDESCRIPTION: Examples showing how type errors in multiline expressions can be suppressed with `type: ignore` comments at different positions. The suppression works when placed at the start or end of the diagnostic range.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\ny = (\n    4 / 0  # type: ignore\n)\n\ny = (\n    4 /  # type: ignore\n    0\n)\n\ny = (\n    4 /\n    0  # type: ignore\n)\n```\n\n----------------------------------------\n\nTITLE: Implicit Function Shadowing Error in Python\nDESCRIPTION: Shows a case where implicitly shadowing a function generates an error. When reassigning a function name without a type annotation, a diagnostic is produced.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/function.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f(): ...\n\nf = 1  # error: \"Implicit shadowing of function `f`; annotate to make it explicit if this is intentional\"\n```\n\n----------------------------------------\n\nTITLE: Union Type Assertions\nDESCRIPTION: Shows how assert_type handles union types regardless of order.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\ndef _(a: str | int):\n    assert_type(a, str | int)\n    assert_type(a, int | str)\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Expressions Without Parameters in Python\nDESCRIPTION: Demonstrates lambda expressions without parameters and their type inference. It also shows an example of an unresolved reference error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/lambda.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(lambda: 1)  # revealed: () -> Unknown\n\n# error: [unresolved-reference]\nreveal_type(lambda: a)  # revealed: () -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Ruff Linting\nDESCRIPTION: TOML configuration example showing how to exclude Jupyter Notebook files from linting while still enabling formatting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Testing NotImplementedType as Singleton in Python 3.10+\nDESCRIPTION: Tests types.NotImplementedType in Python 3.10+, noting that it's currently a TypeAlias of builtins._NotImplementedType and is not yet recognized as a singleton type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\nimport types\nfrom knot_extensions import static_assert, is_singleton\n\n# TODO: types.NotImplementedType is a TypeAlias of builtins._NotImplementedType\n# Once TypeAlias support is added, it should satisfy `is_singleton`\nreveal_type(types.NotImplementedType)  # revealed: Unknown | Literal[_NotImplementedType]\nstatic_assert(not is_singleton(types.NotImplementedType))\n```\n\n----------------------------------------\n\nTITLE: Incorrect Package Import Usage\nDESCRIPTION: Examples of failed imports due to incorrect package path casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom DB.a import Foo\n\n# error: [unresolved-import]\nfrom DB.A import Foo\n\n# error: [unresolved-import]\nfrom db.A import Foo\n```\n\n----------------------------------------\n\nTITLE: Wrong Argument Type Errors in Python Function Calls\nDESCRIPTION: Demonstrates various scenarios of passing incorrect argument types to functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int, /) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(*args: int) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(x=\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(*, x: int) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(x=\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(**kwargs: int) -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]`\"\nreveal_type(f(x=\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: int = 1, y: str = \"foo\") -> int:\n    return 1\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `str`, found `Literal[2]`\"\n# error: 20 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"bar\"]`\"\nreveal_type(f(y=2, x=\"bar\"))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Module with Conditionally Mutated __all__ for Python 3.11\nDESCRIPTION: Example of a module that conditionally mutates its __all__ list based on Python version. For Python 3.11, it adds X and Y to the list.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\n__all__ = []\nX: bool = True\n\nif sys.version_info >= (3, 11):\n    __all__.extend([\"X\", \"Y\"])\n    Y: bool = True\nelse:\n    __all__.append(\"Z\")\n    Z: bool = True\n```\n\n----------------------------------------\n\nTITLE: Following Decorator Error Handling\nDESCRIPTION: Shows how errors in decorators following @no_type_check are suppressed, matching Python's runtime decorator semantics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\n@unknown_decorator\ndef test() -> int:\n    # TODO: this should not be an error\n    # error: [unresolved-reference]\n    return a + 5\n```\n\n----------------------------------------\n\nTITLE: Inspecting Bound Method Attributes in Python\nDESCRIPTION: Shows how to access and reveal the types of bound method attributes __self__ and __func__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbound_method = C().f\n\nreveal_type(bound_method.__self__)  # revealed: C\nreveal_type(bound_method.__func__)  # revealed: def f(self, x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: New-Style Union of Classes Type Usage\nDESCRIPTION: Demonstrates type[] usage with Python's new-style union syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass BasicUser: ...\nclass ProUser: ...\n\nclass A:\n    class B:\n        class C: ...\n\ndef _(u: type[BasicUser | ProUser | A.B.C]):\n    # revealed: type[BasicUser] | type[ProUser] | type[C]\n    reveal_type(u)\n```\n\n----------------------------------------\n\nTITLE: Class Hierarchy Type Narrowing\nDESCRIPTION: Demonstrates type narrowing with class inheritance hierarchies including base and derived classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/issubclass.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Base: ...\nclass Derived1(Base): ...\nclass Derived2(Base): ...\nclass Unrelated: ...\n\ndef _(flag1: bool, flag2: bool, flag3: bool):\n    t1 = Derived1 if flag1 else Derived2\n\n    if issubclass(t1, Base):\n        reveal_type(t1)  # revealed: Literal[Derived1, Derived2]\n\n    if issubclass(t1, Derived1):\n        reveal_type(t1)  # revealed: Literal[Derived1]\n    else:\n        reveal_type(t1)  # revealed: Literal[Derived2]\n\n    t2 = Derived1 if flag2 else Base\n\n    if issubclass(t2, Base):\n        reveal_type(t2)  # revealed: Literal[Derived1, Base]\n\n    t3 = Derived1 if flag3 else Unrelated\n\n    if issubclass(t3, Base):\n        reveal_type(t3)  # revealed: Literal[Derived1]\n    else:\n        reveal_type(t3)  # revealed: Literal[Unrelated]\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Integer Literals in Python\nDESCRIPTION: Demonstrates type inference with integer literals, where 'not 0' is Literal[True] and 'not' with any non-zero integer is Literal[False], regardless of sign or magnitude.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(not 1)  # revealed: Literal[False]\nreveal_type(not 1234567890987654321)  # revealed: Literal[False]\nreveal_type(not 0)  # revealed: Literal[True]\nreveal_type(not -1)  # revealed: Literal[False]\nreveal_type(not -1234567890987654321)  # revealed: Literal[False]\nreveal_type(not --987)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Relative Import at Top of Search Path in Python\nDESCRIPTION: This snippet demonstrates a relative import at the top of a search path, which results in a runtime error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom .parser import X  # error: [unresolved-import]\n```\n\n----------------------------------------\n\nTITLE: Configuring Log File Path for Ruff LSP\nDESCRIPTION: Sets the path for the Ruff LSP server log file. If not set, logs are written to stderr. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.logFile\": \"~/path/to/ruff.log\"\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      logFile = \"~/path/to/ruff.log\"\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"logFile\": \"~/path/to/ruff.log\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Expression String Annotations in Python\nDESCRIPTION: Demonstrates using string annotations for complex type expressions including union types and generic types like tuples. The type checker correctly resolves these string expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f1(v: \"int | str\", w: \"tuple[int, str]\"):\n    reveal_type(v)  # revealed: int | str\n    reveal_type(w)  # revealed: tuple[int, str]\n```\n\n----------------------------------------\n\nTITLE: Testing Type Equivalence in Python\nDESCRIPTION: Shows how to use is_equivalent_to to test whether two types are equivalent, with examples of both equivalent and non-equivalent cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_equivalent_to, static_assert\nfrom typing_extensions import Never, Union\n\nstatic_assert(is_equivalent_to(type, type[object]))\nstatic_assert(is_equivalent_to(tuple[int, Never], Never))\nstatic_assert(is_equivalent_to(int | str, Union[int, str]))\n\nstatic_assert(not is_equivalent_to(int, str))\nstatic_assert(not is_equivalent_to(int | str, int | str | bytes))\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Unbound __iter__ with Definite __getitem__ in Python\nDESCRIPTION: Tests type inference when __iter__ might be unbound but __getitem__ is definitely defined. In this case, no error should be emitted as __getitem__ provides a valid fallback mechanism for iteration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Iterator:\n    def __next__(self) -> str:\n        return \"foo\"\n\ndef _(flag: bool):\n    class Iterable:\n        if flag:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n\n        def __getitem__(self, key: int) -> bytes:\n            return b\"foo\"\n\n    for x in Iterable():\n        reveal_type(x)  # revealed: str | bytes\n```\n\n----------------------------------------\n\nTITLE: Conditionally Defined __all__ Exporter for Python 3.10\nDESCRIPTION: Same module with conditionally defined __all__ as before, but will be interpreted for Python 3.10 environment. The else branch will be selected in this case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nX: bool = True\n\nif sys.version_info >= (3, 11):\n    __all__ = [\"X\", \"Y\"]\n    Y: bool = True\nelse:\n    __all__ = (\"Z\",)\n    Z: bool = True\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Multiple Except Branches and Finally\nDESCRIPTION: Shows type inference with multiple exception handlers and a finally block, demonstrating how variable types propagate through different exception paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass D: ...\nclass E: ...\n\ndef could_raise_returns_D() -> D:\n    return D()\n\ndef could_raise_returns_E() -> E:\n    return E()\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_A()\n    reveal_type(x)  # revealed: A\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | A\n    x = could_raise_returns_B()\n    reveal_type(x)  # revealed: B\n    x = could_raise_returns_C()\n    reveal_type(x)  # revealed: C\nexcept ValueError:\n    reveal_type(x)  # revealed: Literal[1] | A\n    x = could_raise_returns_D()\n    reveal_type(x)  # revealed: D\n    x = could_raise_returns_E()\n    reveal_type(x)  # revealed: E\nfinally:\n    # TODO: should be `Literal[1] | A | B | C | D | E`\n    reveal_type(x)  # revealed: A | C | E\n\nreveal_type(x)  # revealed: A | C | E\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Rule Tests - Shell Commands\nDESCRIPTION: Shell command for testing a new rule (E402) in Ruff using cargo run. The command checks a specific fixture file with the rule enabled via --select flag.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p ruff -- check crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.py --no-cache --preview --select E402\n```\n\n----------------------------------------\n\nTITLE: Intersection Type Unions\nDESCRIPTION: Demonstrates simplification of unions containing intersection types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\n\nclass P: ...\nclass Q: ...\n\ndef _(\n    i1: Intersection[P, Q] | Intersection[P, Q],\n    i2: Intersection[P, Q] | Intersection[Q, P],\n) -> None:\n    reveal_type(i1)  # revealed: P & Q\n    reveal_type(i2)  # revealed: P & Q\n```\n\n----------------------------------------\n\nTITLE: Testing Parameter Name and Default Value Equivalence in Python\nDESCRIPTION: Demonstrates how parameter names, default values, and parameter kinds affect gradual equivalence between callable types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f1(a): ...\ndef f2(b): ...\n\nstatic_assert(not is_gradual_equivalent_to(CallableTypeOf[f1], CallableTypeOf[f2]))\n\ndef f3(a=1): ...\ndef f4(a=2): ...\ndef f5(a): ...\n\nstatic_assert(is_gradual_equivalent_to(CallableTypeOf[f3], CallableTypeOf[f4]))\nstatic_assert(\n    is_gradual_equivalent_to(CallableTypeOf[f3] | bool | CallableTypeOf[f4], CallableTypeOf[f4] | bool | CallableTypeOf[f3])\n)\nstatic_assert(not is_gradual_equivalent_to(CallableTypeOf[f3], CallableTypeOf[f5]))\n\ndef f6(a, /): ...\n\nstatic_assert(not is_gradual_equivalent_to(CallableTypeOf[f1], CallableTypeOf[f6]))\n```\n\n----------------------------------------\n\nTITLE: Shadowing Variables with Different Type Annotations in Python\nDESCRIPTION: Demonstrates a function where a variable 'x' is declared with different type annotations in different scopes. Initially declared conditionally as either str or int, then shadowed with bytes type. This pattern is valid in Python's type system.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/variable_declaration.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        x: str\n    else:\n        x: int\n\n    x: bytes = b\"foo\"\n```\n\n----------------------------------------\n\nTITLE: Using Timeit Magic Command in Jupyter\nDESCRIPTION: Empty timeit magic command for measuring execution time of code in a Jupyter notebook cell. This command allows performance measurement of Python code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command_expected.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\n```\n\n----------------------------------------\n\nTITLE: Testing Function Definition Syntax Error in Python\nDESCRIPTION: Demonstrates parser handling when using keywords 'True' and 'for' in function definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [invalid-syntax]\n# error: [invalid-syntax]\n# error: [invalid-syntax]\n# error: [invalid-syntax]\ndef True(for):\n    # error: [invalid-syntax]\n    # error: [invalid-syntax]\n    pass\n```\n\n----------------------------------------\n\nTITLE: Bound Variable with 'if True' in Python\nDESCRIPTION: Shows how variables defined in always-executed code paths are considered bound. The variable 'x' is accessible without errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nif True:\n    x = 1\n\n# x is always bound, no error\nx\n```\n\n----------------------------------------\n\nTITLE: Multiple Search Path Import Usage\nDESCRIPTION: Example of importing from multiple search paths with different casings\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom A import Foo\nfrom a import Bar\n\nreveal_type(Foo().x)  # revealed: int\nreveal_type(Bar().x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with uvx\nDESCRIPTION: Commands to install and use Ruff directly with uvx for linting and formatting Python code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuvx ruff check   # Lint all files in the current directory.\nuvx ruff format  # Format all files in the current directory.\n```\n\n----------------------------------------\n\nTITLE: Edge Case: Shadowing of 'self' Parameter\nDESCRIPTION: Demonstrates an edge case where the 'self' parameter is shadowed with a different type, causing type confusion.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nclass Other:\n    x: int = 1\n\nclass C:\n    def __init__(self) -> None:\n        # Redeclaration of self. `self` does not refer to the instance anymore.\n        self: Other = Other()\n        self.x: int = 1\n\n# TODO: this should be an error\nC().x\n```\n\n----------------------------------------\n\nTITLE: Configuring First-Party Sources in pyproject.toml\nDESCRIPTION: This snippet shows how to configure Ruff to treat the \"src\" directory as the primary source for first-party imports. This helps Ruff accurately identify internal project modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff]\n# Ruff supports a top-level `src` option in lieu of isort's `src_paths` setting.\n# All paths are relative to the project root, which is the directory containing the pyproject.toml.\nsrc = [\"src\"]\"\n```\n\n----------------------------------------\n\nTITLE: All Non-callable Union Elements in Python\nDESCRIPTION: Shows the error when trying to call a union type where none of the elements are callable, resulting in a simpler diagnostic message.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        f = 1\n    else:\n        f = \"foo\"\n\n    x = f()  # error: [call-non-callable] \"Object of type `Literal[1, \\\"foo\\\"]` is not callable\"\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Dynamic Types\nDESCRIPTION: Shows that mixed dynamic types (combinations of Any and Unknown) are not currently simplified, but may be in the future.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom knot_extensions import Intersection, Not, Unknown\n\ndef mixed(\n    i1: Intersection[Any, Unknown],\n    i2: Intersection[Any, Not[Unknown]],\n    i3: Intersection[Not[Any], Unknown],\n    i4: Intersection[Not[Any], Not[Unknown]],\n) -> None:\n    reveal_type(i1)  # revealed: Any & Unknown\n    reveal_type(i2)  # revealed: Any & Unknown\n    reveal_type(i3)  # revealed: Any & Unknown\n    reveal_type(i4)  # revealed: Any & Unknown\n```\n\n----------------------------------------\n\nTITLE: Child Inheritance Python Version Check\nDESCRIPTION: Verifies that nested children correctly inherit their parent section's Python version configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[:2] == (3, 12))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Mixed Arguments Test\nDESCRIPTION: Tests invalid argument type detection with a mix of different argument types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, /, y: int, *, z: int = 0) -> int:\n    return x * y * z\n\nfoo(1, 2, z=\"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Metaclass Conflict Example 1\nDESCRIPTION: Shows a conflict when two base classes have different metaclasses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass M1(type): ...\nclass M2(type): ...\nclass A(metaclass=M1): ...\nclass B(metaclass=M2): ...\n\n# error: [conflicting-metaclass]\nclass C(A, B): ...\n\nreveal_type(C.__class__)  # revealed: type[Unknown]\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of None Type in Python\nDESCRIPTION: This code shows disjointness relations between None and other types. None is disjoint from most concrete types like integers, strings, and booleans, but not from object (since None is an object) or unions that include None.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\nfrom knot_extensions import is_disjoint_from, static_assert, Intersection, Not\n\nstatic_assert(is_disjoint_from(None, Literal[True]))\nstatic_assert(is_disjoint_from(None, Literal[1]))\nstatic_assert(is_disjoint_from(None, Literal[\"test\"]))\nstatic_assert(is_disjoint_from(None, Literal[b\"test\"]))\nstatic_assert(is_disjoint_from(None, LiteralString))\nstatic_assert(is_disjoint_from(None, int))\nstatic_assert(is_disjoint_from(None, type[object]))\n\nstatic_assert(not is_disjoint_from(None, None))\nstatic_assert(not is_disjoint_from(None, int | None))\nstatic_assert(not is_disjoint_from(None, object))\n\nstatic_assert(is_disjoint_from(Intersection[int, Not[str]], None))\nstatic_assert(is_disjoint_from(None, Intersection[int, Not[str]]))\n```\n\n----------------------------------------\n\nTITLE: Assigning Possibly-Unbound Attributes in Python\nDESCRIPTION: Shows attempting to set attributes that are not defined in all branches, resulting in possibly-unbound attribute errors for both class and instance assignments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    class C:\n        if flag:\n            attr: int = 0\n\n    C.attr = 1  # error: [possibly-unbound-attribute]\n\n    instance = C()\n    instance.attr = 1  # error: [possibly-unbound-attribute]\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment for Linux Platform in TOML\nDESCRIPTION: TOML configuration that specifies the project should be configured specifically for Linux platform. This constrains the sys.platform type to a specific literal value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-platform = \"linux\"\n```\n\n----------------------------------------\n\nTITLE: Property Getter and Setter Implementation in Python\nDESCRIPTION: Demonstrates implementing both getter and setter methods for a property with type validation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    @property\n    def my_property(self) -> int:\n        return 1\n\n    @my_property.setter\n    def my_property(self, value: int) -> None:\n        pass\n\nc = C()\nreveal_type(c.my_property)  # revealed: int\nc.my_property = 2\n\n# error: [invalid-assignment]\nc.my_property = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Format Suppression Examples in Python\nDESCRIPTION: Illustrates how to use format suppression comments in Python code to control Ruff's formatting behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\nnot_formatted=3\nalso_not_formatted=4\n# fmt: on\n```\n\nLANGUAGE: python\nCODE:\n```\n[\n    # fmt: off\n    '1',\n    # fmt: on\n    '2',\n]\n```\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\n[\n    '1',\n    '2',\n]\n# fmt: on\n```\n\nLANGUAGE: python\nCODE:\n```\nif True:\n    pass\nelif False: # fmt: skip\n    pass\n\n@Test\n@Test2 # fmt: skip\ndef test(): ...\n\na = [1, 2, 3, 4, 5] # fmt: skip\n\ndef test(a, b, c, d, e, f) -> int: # fmt: skip\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\na = call(\n    [\n        '1',  # fmt: skip\n        '2',\n    ],\n    b\n)\n```\n\nLANGUAGE: python\nCODE:\n```\na = call(\n  [\n    '1',\n    '2',\n  ],\n  b\n)  # fmt: skip\n```\n\n----------------------------------------\n\nTITLE: Evaluating bool() Function with Redefined Builtin in Python\nDESCRIPTION: This snippet demonstrates how the type system handles a redefined builtin bool function and a custom boolean function. It shows the difference in type inference between the two.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nredefined_builtin_bool: type[bool] = bool\n\ndef my_bool(x) -> bool:\n    return True\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import redefined_builtin_bool, my_bool\n\nreveal_type(redefined_builtin_bool(0))  # revealed: Literal[False]\nreveal_type(my_bool(0))  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Importing from Stub File with __all__\nDESCRIPTION: Shows behavior when importing from a stub file that uses __all__ to control exports. Currently, the type checker fails to recognize that X should be available due to its presence in __all__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom b import *\n\n# TODO: should not error, should reveal `bool`\n# (`X` is re-exported from `b.pyi` due to presence in `__all__`)\n# See https://github.com/astral-sh/ruff/issues/16159\n#\n# error: [unresolved-reference]\nreveal_type(X)  # revealed: Unknown\n\n# This diagnostic is accurate: `Y` does not use the \"redundant alias\" convention in `b.pyi`,\n# nor is it included in `b.__all__`, so it is not exported from `b.pyi`\n#\n# error: [unresolved-reference]\nreveal_type(Y)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Comparing Ruff and isort import sorting\nDESCRIPTION: This snippet compares how Ruff and isort handle import sorting, specifically focusing on aliased imports and grouping from the same module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy import cos, int8, int16, int32, int64, tan, uint8, uint16, uint32, uint64\nfrom numpy import sin as np_sin\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy import cos, int8, int16, int32, int64\nfrom numpy import sin as np_sin\nfrom numpy import tan, uint8, uint16, uint32, uint64\n```\n\n----------------------------------------\n\nTITLE: Deeply Nested Class Literal Type Usage\nDESCRIPTION: Demonstrates type[] usage with deeply nested class structures.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    class B:\n        class C: ...\n\ndef f(c: type[A.B.C]):\n    reveal_type(c)  # revealed: type[C]\n```\n\n----------------------------------------\n\nTITLE: Error Messages in Static Assertions in Python\nDESCRIPTION: Demonstrates the different error messages produced by static_assert for various failure cases, including custom boolean conversion issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\n\nstatic_assert(2 * 3 == 6)\n\n# error: \"Static assertion error: argument evaluates to `False`\"\nstatic_assert(2 * 3 == 7)\n\n# error: \"Static assertion error: argument of type `bool` has an ambiguous static truthiness\"\nstatic_assert(int(2.0 * 3.0) == 6)\n\nclass InvalidBoolDunder:\n    def __bool__(self) -> int:\n        return 1\n\n# error: [unsupported-bool-conversion]  \"Boolean conversion is unsupported for type `InvalidBoolDunder`; the return type of its bool method (`int`) isn't assignable to `bool\"\nstatic_assert(InvalidBoolDunder())\n```\n\n----------------------------------------\n\nTITLE: Wildcard Import Re-export Behavior\nDESCRIPTION: Demonstrates how wildcard imports re-export symbols while explicit imports do not\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n```\n\nLANGUAGE: python\nCODE:\n```\nY: bool = False\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\nfrom b import Y\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom c import X\n\nfrom c import Y  # error: [unresolved-import]\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always True 'and' Boolean Expression in Python\nDESCRIPTION: Shows how type inference handles evaluation in 'and' expressions when all operands are truthy. All assignment expressions are evaluated, and the final one determines the type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n(x := 1) and (x := 2)\n\nreveal_type(x)  # revealed: Literal[2]\n\n(y := 1) and (y := 2) and (y := 3) and (y := 4)\n\nreveal_type(y)  # revealed: Literal[4]\n```\n\n----------------------------------------\n\nTITLE: Initializing Ruff Fuzzers Setup Command\nDESCRIPTION: Command to initialize the fuzzing environment by installing cargo-fuzz and optionally downloading a testing dataset. Creates the necessary corpus directory shared by all fuzzers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/fuzz/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./fuzz/init-fuzzers.sh\n```\n\n----------------------------------------\n\nTITLE: Property Implementation Details in Python\nDESCRIPTION: Demonstrates the internal workings of property descriptors including getter and setter mechanics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __init__(self):\n        self._attr: int = 0\n\n    @property\n    def attr(self) -> int:\n        return self._attr\n\n    @attr.setter\n    def attr(self, value: str) -> None:\n        self._attr = len(value)\n```\n\n----------------------------------------\n\nTITLE: argparse.Namespace __setattr__ Example\nDESCRIPTION: Shows how the standard library's argparse.Namespace implements __setattr__, allowing arbitrary attributes to be set.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\n\ndef _(ns: argparse.Namespace):\n    ns.whatever = 42\n```\n\n----------------------------------------\n\nTITLE: Assignment to self from nested function in Python\nDESCRIPTION: This snippet demonstrates assigning an attribute to `self` from within a nested function inside a class's `__init__` method. It highlights the type inference behavior in this scenario, especially differences between Mypy and Pyright. The revealed type of `C().x` is `Unknown` in this case.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n```py\nclass C:\n    def __init__(self) -> None:\n        def set_attribute(value: str):\n            self.x: str = value\n        set_attribute(\"a\")\n\n# TODO: ideally, this would be `str`. Mypy supports this, pyright does not.\n# error: [unresolved-attribute]\nreveal_type(C().x)  # revealed: Unknown\n```\n```\n\n----------------------------------------\n\nTITLE: Assignment Expressions (Walrus Operator)\nDESCRIPTION: Shows assignment expressions using the walrus operator with and without semicolons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Assignment expression without a semicolon\n(x := 1)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Assignment expression with a semicolon\n(x := 1);\n(x := 1);  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Testing Single Inheritance MRO\nDESCRIPTION: Tests type inference for single inheritance from a non-object base class\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B(A): ...\n\nreveal_type(B.__mro__)  # revealed: tuple[Literal[B], Literal[A], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Implicit Class Shadowing Error in Python\nDESCRIPTION: This snippet demonstrates an implicit class shadowing error that occurs when reassigning a class name without type annotation. This code will produce an error in the Ruff linter.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/class.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\nC = 1  # error: \"Implicit shadowing of class `C`; annotate to make it explicit if this is intentional\"\n```\n\n----------------------------------------\n\nTITLE: Tuple Type Assertions\nDESCRIPTION: Demonstrates tuple type checking rules with assert_type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Any, assert_type\n\nfrom knot_extensions import Unknown\n\ndef _(a: tuple[int, str, bytes]):\n    assert_type(a, tuple[int, str, bytes])  # fine\n\n    assert_type(a, tuple[int, str])  # error: [type-assertion-failure]\n    assert_type(a, tuple[int, str, bytes, None])  # error: [type-assertion-failure]\n    assert_type(a, tuple[int, bytes, str])  # error: [type-assertion-failure]\n\ndef _(a: tuple[Any, ...], b: tuple[Unknown, ...]):\n    assert_type(a, tuple[Any, ...])  # fine\n    assert_type(a, tuple[Unknown, ...])  # fine\n\n    assert_type(b, tuple[Unknown, ...])  # fine\n    assert_type(b, tuple[Any, ...])  # fine\n```\n\n----------------------------------------\n\nTITLE: Invalid Boolean Conversion Handling\nDESCRIPTION: Shows error handling for objects with incorrectly implemented __bool__ method, demonstrating Ruff's static type checking capabilities.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_expression.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\n3 if NotBoolable() else 4\n```\n\n----------------------------------------\n\nTITLE: Caching checkouts for ruff-ecosystem\nDESCRIPTION: This command runs the ruff-ecosystem tool in check mode and specifies a directory for caching checkouts. This can speed up repeated runs by reusing previously checked out repositories.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem check ruff \"./target/debug/ruff\" --cache ./repos\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespace Stubs for Non-Namespace Package in TOML\nDESCRIPTION: Sets up the environment for namespace stubs corresponding to a non-namespace runtime package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_20\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Single Keyword Argument Test\nDESCRIPTION: Tests invalid argument type detection with a single keyword argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, y: int, z: int = 0) -> int:\n    return x * y * z\n\nfoo(1, 2, \"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Configuring RED_KNOT_LOG to show Salsa query execution messages\nDESCRIPTION: Environment variable setup to display Salsa query execution messages alongside Red Knot traces at the trace level.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRED_KNOT_LOG=ruff=trace,red_knot=trace,salsa=info\n```\n\n----------------------------------------\n\nTITLE: Conditional Global ModuleType Attributes\nDESCRIPTION: Demonstrates type resolution when ModuleType attributes are conditionally defined as globals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n__file__ = 42\n\ndef returns_bool() -> bool:\n    return True\n\nif returns_bool():\n    __name__ = 1\n\nreveal_type(__file__)  # revealed: Literal[42]\nreveal_type(__name__)  # revealed: Literal[1] | str\n```\n\n----------------------------------------\n\nTITLE: Defining Stubs-Only Package in Python\nDESCRIPTION: Creates a stub file for the 'Foo' class in a stubs-only configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    name: str\n    age: int\n```\n\n----------------------------------------\n\nTITLE: EFM Language Server Configuration for Ruff\nDESCRIPTION: YAML configuration for using Ruff with efm-langserver for linting and formatting Python files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntools:\n  python-ruff:\n    lint-command: \"ruff check --stdin-filename ${INPUT} --output-format concise --quiet -\"\n    lint-stdin: true\n    lint-formats:\n      - \"%f:%l:%c: %m\"\n    format-command: \"ruff format --stdin-filename ${INPUT} --quiet -\"\n    format-stdin: true\n```\n\n----------------------------------------\n\nTITLE: Minimizing Crash Input Command\nDESCRIPTION: Command to minimize the input that triggered a crash while still maintaining the crash behavior. Uses cargo-fuzz's built-in test case minimization functionality.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/fuzz/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo fuzz tmin -s none name_of_fuzzer artifacts/name_of_fuzzer/crash-...\n```\n\n----------------------------------------\n\nTITLE: Defining Hexagon Stub in Inconsistent Package\nDESCRIPTION: Creates a stub file for the 'Hexagon' class in an inconsistent stub package setup.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass Hexagon:\n    sides: int\n    area: float\n```\n\n----------------------------------------\n\nTITLE: New Module Type Stub\nDESCRIPTION: Type stub for a module requiring newer Python version.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_6\n\nLANGUAGE: pyi\nCODE:\n```\nclass NewClass: ...\n```\n\n----------------------------------------\n\nTITLE: Single Type isinstance() Check\nDESCRIPTION: Demonstrates type narrowing behavior when using isinstance() with a single type argument. Shows how the type system narrows variables based on type checks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else \"a\"\n\n    if isinstance(x, int):\n        reveal_type(x)  # revealed: Literal[1]\n\n    if isinstance(x, str):\n        reveal_type(x)  # revealed: Literal[\"a\"]\n        if isinstance(x, int):\n            reveal_type(x)  # revealed: Never\n\n    if isinstance(x, (int, object)):\n        reveal_type(x)  # revealed: Literal[1, \"a\"]\n```\n\n----------------------------------------\n\nTITLE: ClassVar Inheritance with Conflicting Type Qualifiers in Python\nDESCRIPTION: Demonstrates how ClassVar behaves when a derived class redefines an attribute that was declared as ClassVar in the base class. The type system conservatively retains the ClassVar status, preventing instance-level writes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    a: ClassVar[int] = 1\n\nclass Derived(Base):\n    if flag():\n        a: int\n\nreveal_type(Derived.a)  # revealed: int\n\nd = Derived()\n\n# error: [invalid-attribute-access]\nd.a = 2\n```\n\n----------------------------------------\n\nTITLE: Type Class Type Check\nDESCRIPTION: Demonstrates type checking of the type class itself.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(type.__class__)  # revealed: Literal[type]\n```\n\n----------------------------------------\n\nTITLE: Nested While Loops Type Narrowing\nDESCRIPTION: Illustrates type narrowing in nested while loops using Literal types, showing how the type gets progressively narrowed in each loop level.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/while.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef next_item() -> Literal[1, 2, 3]:\n    raise NotImplementedError\n\nx = next_item()\n\nwhile x != 1:\n    reveal_type(x)  # revealed: Literal[2, 3]\n\n    while x != 2:\n        # TODO: this should be Literal[1, 3]; Literal[3] is only correct\n        # in the first loop iteration\n        reveal_type(x)  # revealed: Literal[3]\n        x = next_item()\n\n    x = next_item()\n```\n\n----------------------------------------\n\nTITLE: Usage Example: Wildcard Import Detection\nDESCRIPTION: Example of a wildcard import that would be detected by ruff analyze graph.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom module import *\n```\n\n----------------------------------------\n\nTITLE: Basic Integer Literal Type Inference\nDESCRIPTION: Shows how Python infers the literal type for a simple integer value.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Mismatched TypeVar Name in Python\nDESCRIPTION: This snippet demonstrates an error case where the string argument to TypeVar does not match the variable name it is assigned to. The TypeVar parameter must match the variable name exactly.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/legacy.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\n# TODO: error\nT = TypeVar(\"Q\")\n```\n\n----------------------------------------\n\nTITLE: Too Many Positional Arguments Errors in Python Function Calls\nDESCRIPTION: Shows various scenarios of passing too many positional arguments to functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> int:\n    return 1\n\n# error: 15 [too-many-positional-arguments] \"Too many positional arguments to function `f`: expected 0, got 1\"\nreveal_type(f(\"foo\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> int:\n    return 1\n\n# error: 15 [too-many-positional-arguments] \"Too many positional arguments to function `f`: expected 0, got 2\"\nreveal_type(f(\"foo\", \"bar\"))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(*args: int) -> int:\n    return 1\n\nreveal_type(f(1, 2, 3))  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f(**kwargs: int) -> int:\n    return 1\n\nreveal_type(f(foo=1, bar=2))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Module with Public and Private Variables\nDESCRIPTION: Defines a module with public variable X and private variables _Y and _Z. Used to test invalid import syntax combinations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n_Y: bool = False\n_Z: bool = True\n```\n\n----------------------------------------\n\nTITLE: Module with Empty Tuple __all__\nDESCRIPTION: Example of a module that defines an empty tuple as __all__, indicating that no symbols should be exported when star-imported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n\n__all__ = ()\n```\n\n----------------------------------------\n\nTITLE: Tuple Unpacking Attribute Assignment in Python\nDESCRIPTION: Demonstrates type inference for class attributes defined through tuple unpacking, including both direct assignments and function return values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef returns_tuple() -> tuple[int, str]:\n    return (1, \"a\")\n\nclass C:\n    a1, b1 = (1, \"a\")\n    c1, d1 = returns_tuple()\n\n    def __init__(self) -> None:\n        self.a2, self.b2 = (1, \"a\")\n        self.c2, self.d2 = returns_tuple()\n\nc_instance = C()\n\nreveal_type(c_instance.a1)  # revealed: Unknown | Literal[1]\nreveal_type(c_instance.b1)  # revealed: Unknown | Literal[\"a\"]\nreveal_type(c_instance.c1)  # revealed: Unknown | int\nreveal_type(c_instance.d1)  # revealed: Unknown | str\n\nreveal_type(c_instance.a2)  # revealed: Unknown | Literal[1]\nreveal_type(c_instance.b2)  # revealed: Unknown | Literal[\"a\"]\nreveal_type(c_instance.c2)  # revealed: Unknown | int\nreveal_type(c_instance.d2)  # revealed: Unknown | str\n```\n\n----------------------------------------\n\nTITLE: Legacy Generic Class Inheritance\nDESCRIPTION: Example of class inheritance using legacy generic syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/classes.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass D(C[T]): ...\n```\n\n----------------------------------------\n\nTITLE: Explicit Function Shadowing with Type Annotation in Python\nDESCRIPTION: Demonstrates how to explicitly shadow a function by providing a type annotation. This is allowed as it clearly indicates the intention to change the type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/shadowing/function.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f(): ...\n\nf: int = 1\n```\n\n----------------------------------------\n\nTITLE: Special-Case Bool Literal Attributes\nDESCRIPTION: Shows special-cased bool literal attributes that preserve numeric literal type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(True.numerator)  # revealed: Literal[1]\nreveal_type(False.real)  # revealed: Literal[0]\n```\n\n----------------------------------------\n\nTITLE: Union Parameter Type Inference\nDESCRIPTION: Examples of type inference with union parameters and constraints.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef union_param[T](x: T | None) -> T:\n    if x is None:\n        raise ValueError\n    return x\n\nreveal_type(union_param(\"a\"))  # revealed: Literal[\"a\"]\nreveal_type(union_param(1))  # revealed: Literal[1]\nreveal_type(union_param(None))  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Unknown Object MRO Access\nDESCRIPTION: Shows behavior when attempting to access __mro__ attribute on unresolved imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom does_not_exist import unknown_object\n\nreveal_type(unknown_object)\nreveal_type(unknown_object.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'is not None' Check\nDESCRIPTION: Demonstrates how type checking narrows union types when using 'is not None' comparison. Shows type revelation before, during, and after the conditional check.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is_not.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = None if flag else 1\n\n    if x is not None:\n        reveal_type(x)  # revealed: Literal[1]\n    else:\n        reveal_type(x)  # revealed: None\n\n    reveal_type(x)  # revealed: None | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Basic Empty Callable Example\nDESCRIPTION: Demonstrates using a bare Callable without type arguments, which defaults to unknown return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/callable.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef _(c: Callable):\n    reveal_type(c)  # revealed: (...) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Invalid Base Class Definition in Python\nDESCRIPTION: Demonstrates an invalid base class definition where a numeric literal (2) is used as a base class, which should trigger an [invalid-base] error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/regression/14334_diagnostics_in_wrong_file.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-base]\nclass Base(2): ...\n```\n\n----------------------------------------\n\nTITLE: Public Variable Boundness in Python\nDESCRIPTION: Demonstrates how variable boundness in outer scopes affects inner scopes. The variable 'x' defined in an always-executed branch is accessible in function 'f'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nif True:\n    x = 1\n\ndef f():\n    # x is always bound, no error\n    x\n```\n\n----------------------------------------\n\nTITLE: Comparing Nested Tuples in Python\nDESCRIPTION: Demonstrates comparisons of nested tuples (Matryoshka tuples). The results are definitive boolean literals, as the nested structure doesn't affect the comparison logic.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\na = (1, True, \"Hello\")\nb = (a, a, a)\nc = (b, b, b)\n\nreveal_type(c == c)  # revealed: Literal[True]\nreveal_type(c != c)  # revealed: Literal[False]\nreveal_type(c < c)  # revealed: Literal[False]\nreveal_type(c <= c)  # revealed: Literal[True]\nreveal_type(c > c)  # revealed: Literal[False]\nreveal_type(c >= c)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Type Checking Complex Number Literal in Python\nDESCRIPTION: Uses reveal_type() to demonstrate that Python infers the 'complex' type for imaginary number literals denoted with the j suffix. The example shows type checking of the literal 2j.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/complex.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(2j)  # revealed: complex\n```\n\n----------------------------------------\n\nTITLE: Empty Dictionary Type Revelation in Python\nDESCRIPTION: Demonstrates using reveal_type to show the inferred type of an empty dictionary literal. This is commonly used during static type checking to verify type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/collections/dictionary.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type({})  # revealed: dict\n```\n\n----------------------------------------\n\nTITLE: Nested Quote String Literal Type Analysis in Python\nDESCRIPTION: Shows how reveal_type() handles string literals containing nested quotes, demonstrating proper escaping of quotes in type annotations. Includes examples with both single and double quoted strings containing nested quotation marks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/string.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type('I say \"hello\" to you')  # revealed: Literal[\"I say \\\"hello\\\" to you\"]\n\n# revealed: Literal[\"You say \\\"hey\\\" back\"]\nreveal_type(\"You say \\\"hey\\\" back\")  # fmt: skip\n\nreveal_type('No \"closure here')  # revealed: Literal[\"No \\\"closure here\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Hexagon Class in Regular Package\nDESCRIPTION: Defines the actual implementation of the 'Hexagon' class without type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass Hexagon: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff using pyproject.toml\nDESCRIPTION: Example of Ruff configuration using the standard pyproject.toml file format. This demonstrates setting the line length and specifying the Google docstring convention for pydocstyle.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nline-length = 88\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Various Object Attributes with inspect.getattr_static in Python\nDESCRIPTION: This snippet shows how inspect.getattr_static can be used to access attributes on different types of objects, including built-in modules, functions, and primitive types. It demonstrates the versatility of the function across various Python objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/getattr_static.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(inspect.getattr_static(sys, \"dont_write_bytecode\"))  # revealed: bool\n# revealed: def getattr_static(obj: object, attr: str, default: Any | None = ellipsis) -> Any\nreveal_type(inspect.getattr_static(inspect, \"getattr_static\"))\n\nreveal_type(inspect.getattr_static(1, \"real\"))  # revealed: property\n```\n\n----------------------------------------\n\nTITLE: Multiple Parameters Test\nDESCRIPTION: Tests invalid argument type detection with multiple function parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, y: int, z: int) -> int:\n    return x * y * z\n\nfoo(1, \"hello\", 3)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Using '-stubs' Named Module in Python\nDESCRIPTION: Demonstrates the invalid usage of a '-stubs' named module, resulting in import and type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import Foo  # error: [unresolved-import]\n\nreveal_type(Foo().name)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Conditionally Defined __all__ Exporter for Python 3.11\nDESCRIPTION: Example of a module that conditionally defines different __all__ contents based on Python version. Shows branch selection for Python 3.11.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nX: bool = True\n\nif sys.version_info >= (3, 11):\n    __all__ = [\"X\", \"Y\"]\n    Y: bool = True\nelse:\n    __all__ = (\"Z\",)\n    Z: bool = True\n```\n\n----------------------------------------\n\nTITLE: Testing Operator Precedence with Subclasses\nDESCRIPTION: Demonstrates how reflected dunder methods in subclasses take precedence over superclass regular dunders. Shows type checking results for various operators between Yes() and Sub() instances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(Yes() + Sub())  # revealed: Literal[\"r+\"]\nreveal_type(Yes() - Sub())  # revealed: Literal[\"r-\"]\nreveal_type(Yes() * Sub())  # revealed: Literal[\"r*\"]\nreveal_type(Yes() @ Sub())  # revealed: Literal[\"r@\"]\nreveal_type(Yes() / Sub())  # revealed: Literal[\"r/\"]\nreveal_type(Yes() % Sub())  # revealed: Literal[\"r%\"]\nreveal_type(Yes() ** Sub())  # revealed: Literal[\"r**\"]\nreveal_type(Yes() << Sub())  # revealed: Literal[\"r<<\"]\nreveal_type(Yes() >> Sub())  # revealed: Literal[\"r>>\"]\nreveal_type(Yes() | Sub())  # revealed: Literal[\"r|\"]\nreveal_type(Yes() ^ Sub())  # revealed: Literal[\"r^\"]\nreveal_type(Yes() & Sub())  # revealed: Literal[\"r&\"]\nreveal_type(Yes() // Sub())  # revealed: Literal[\"r//\"]\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Benchmarks with Cargo\nDESCRIPTION: Commands for executing and comparing benchmarks using cargo bench. Includes commands for establishing a baseline, comparing against it, and running specific lexer benchmarks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_benchmark/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Run once on the \"baseline\".\ncargo bench -p ruff_benchmark -- --save-baseline=main\n\n# Compare against the \"baseline\".\ncargo bench -p ruff_benchmark -- --baseline=main\n\n# Run the lexer benchmarks.\ncargo bench -p ruff_benchmark lexer -- --baseline=main\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Native Server Mode in JSON\nDESCRIPTION: Controls whether to use the native language server, ruff-lsp, or automatically decide between them based on Ruff version and extension settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.nativeServer\": \"on\"\n}\n```\n\n----------------------------------------\n\nTITLE: Instance Attribute Precedence Over __getattr__\nDESCRIPTION: Demonstrates that instance attributes take precedence over the __getattr__ method in type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Note: we could attempt to union with the fallback type of `__getattr__` here, as we currently do not\n# attempt to determine if instance attributes are always bound or not. Neither mypy nor pyright do this,\n# so it's not a priority.\nreveal_type(c.instance_attr)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Using Namespace Stubs for Non-Namespace Package in Python\nDESCRIPTION: Demonstrates the usage of namespace stubs for a non-namespace runtime package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom shapes.polygons.pentagon import Pentagon\nfrom shapes.polygons.hexagon import Hexagon\n\nreveal_type(Pentagon().sides)  # revealed: int\nreveal_type(Hexagon().area)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Mocking Virtual Environment in Test Configuration\nDESCRIPTION: This TOML configuration demonstrates how to mock a virtual environment for a specific test. It sets the Python environment to a \".venv\" directory.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython = \".venv\"\n```\n\n----------------------------------------\n\nTITLE: Intersection Type Assertions\nDESCRIPTION: Demonstrates intersection type checking with positive and negative parts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\nfrom knot_extensions import Intersection, Not\n\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\n\ndef _(a: A):\n    if isinstance(a, B) and not isinstance(a, C) and not isinstance(a, D):\n        reveal_type(a)  # revealed: A & B & ~C & ~D\n\n        assert_type(a, Intersection[A, B, Not[C], Not[D]])\n        assert_type(a, Intersection[B, A, Not[D], Not[C]])\n```\n\n----------------------------------------\n\nTITLE: Revealing actual type of float annotations\nDESCRIPTION: Shows how the Ruff type checker reveals the actual union type ('int | float') when inspecting a variable annotated as float, instead of simplifying to just 'float'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/int_float_complex.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f(x: float):\n    reveal_type(x)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Configuring Virtual Environment with Python Version\nDESCRIPTION: This TOML configuration sets up a mock virtual environment with a specific Python version. It demonstrates how to combine virtual environment mocking with version specification.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython = \".venv\"\npython-version = \"3.13\"\n```\n\n----------------------------------------\n\nTITLE: Semicolons with Comments\nDESCRIPTION: Example showing semicolon usage with inline and standalone comments\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Comments, newlines and whitespace\nx; # comment\n\n# another comment\n```\n\n----------------------------------------\n\nTITLE: Regression Test for Intersections with Non-disjoint Types\nDESCRIPTION: Demonstrates a regression test for a specific case of adding a type to an intersection with many non-disjoint types, referenced in a PR discussion.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import AlwaysFalsy, Intersection, Unknown\nfrom typing_extensions import Literal\n\ndef _(x: Intersection[str, Unknown, AlwaysFalsy, Literal[\"\"]]):\n    reveal_type(x)  # revealed: Unknown & Literal[\"\"]\n```\n\n----------------------------------------\n\nTITLE: Undefined Deferred Types with String Annotations in Python\nDESCRIPTION: Shows what happens when a string annotation refers to a type that is never defined. This results in an unresolved reference error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference]\ndef f(v: \"Foo\"):\n    reveal_type(v)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Importing Non-existent Module in Python\nDESCRIPTION: This snippet demonstrates an attempt to import a non-existent module, resulting in an unresolved import error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom .foo import X  # error: [unresolved-import]\n\nreveal_type(X)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with AND Operator\nDESCRIPTION: Demonstrates type narrowing behavior when using the 'and' operator in conditionals with type checks\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/boolean.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\ndef _(x: A | B):\n    if isinstance(x, A) and isinstance(x, B):\n        reveal_type(x)  # revealed:  A & B\n    else:\n        reveal_type(x)  # revealed:  B & ~A | A & ~B\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TypeVar Narrowing with Disjoint Constraints in Python\nDESCRIPTION: Shows how type narrowing can simplify redundant negatives when constraints are disjoint.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef h[T: (P, None)](t: T) -> None:\n    if t is None:\n        reveal_type(t)  # revealed: None\n        p: None = t\n    else:\n        reveal_type(t)  # revealed: P\n        p: P = t\n```\n\n----------------------------------------\n\nTITLE: Type Function Call Without Required Arguments\nDESCRIPTION: Example showing an invalid call to Python's built-in type() function that triggers a no-matching-overload error due to insufficient arguments. The type() function requires more parameters when creating a new class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/no_matching_overload.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntype(\"Foo\", ())\n```\n\n----------------------------------------\n\nTITLE: Undeclared and Possibly Unbound Symbol Usage in Python\nDESCRIPTION: Shows type inference for undeclared and possibly unbound symbols, currently not raising errors in inconsistent cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nif flag:\n    a = 1\n    b: SomeUnknownName = 1  # error: [unresolved-reference]\n```\n\nLANGUAGE: python\nCODE:\n```\n# TODO: this should raise an error. Once we fix this, update the section description and the table\n# on top of this document.\nfrom mod import a, b\n\nreveal_type(a)  # revealed: Unknown | Literal[1]\nreveal_type(b)  # revealed: Unknown\n\n# All external modifications of `a` are allowed:\na = None\n```\n\n----------------------------------------\n\nTITLE: Using Global Statement in Non-Global Scope\nDESCRIPTION: A module that defines a function with a global statement, declaring that g and h are global variables. The function assigns a value to g but not h.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    global g, h\n\n    g: bool = True\n\nf()\n```\n\n----------------------------------------\n\nTITLE: Using Ellipsis in Regular Python Files\nDESCRIPTION: In non-stub files, ellipsis literals receive no special treatment and can only be assigned if EllipsisType is assignable to the annotated type, which usually results in type errors for concrete type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: 7 [invalid-parameter-default] \"Default value of type `ellipsis` is not assignable to annotated parameter type `int`\"\ndef f(x: int = ...) -> None: ...\n\n# error: 1 [invalid-assignment] \"Object of type `ellipsis` is not assignable to `int`\"\na: int = ...\nb = ...\nreveal_type(b)  # revealed: ellipsis\n```\n\n----------------------------------------\n\nTITLE: Basic Invalid Argument Type Test\nDESCRIPTION: Demonstrates basic invalid argument type detection where a string is passed to a function expecting an integer.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int) -> int:\n    return x * x\n\nfoo(\"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TypeVar Intersection Assignability Properties in Python\nDESCRIPTION: Illustrates that the intersection of a typevar with any other type is assignable to (and if fully static, a subtype of) itself.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_assignable_to, is_subtype_of, static_assert, Not\n\ndef intersection_is_assignable[T](t: T) -> None:\n    static_assert(is_assignable_to(Intersection[T, None], T))\n    static_assert(is_assignable_to(Intersection[T, Not[None]], T))\n\n    static_assert(is_subtype_of(Intersection[T, None], T))\n    static_assert(is_subtype_of(Intersection[T, Not[None]], T))\n```\n\n----------------------------------------\n\nTITLE: Importing from Non-Existent Module in Python\nDESCRIPTION: This snippet demonstrates the error diagnostic when attempting to import from a module that does not exist. It shows how Ruff detects and reports unresolved imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom does_not_exist import add  # error: [unresolved-import]\n\nstat = add(10, 15)\n```\n\n----------------------------------------\n\nTITLE: Descriptor Access Pattern Implementation\nDESCRIPTION: Implements different descriptor access patterns for class, instance, and metaclass access with specific return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass TailoredForClassObjectAccess:\n    def __get__(self, instance: None, owner: type[C]) -> int:\n        return 1\n\nclass TailoredForInstanceAccess:\n    def __get__(self, instance: C, owner: type[C] | None = None) -> str:\n        return \"a\"\n\nclass TailoredForMetaclassAccess:\n    def __get__(self, instance: type[C], owner: type[Meta]) -> bytes:\n        return b\"a\"\n\nclass Meta(type):\n    metaclass_access: TailoredForMetaclassAccess = TailoredForMetaclassAccess()\n\nclass C(metaclass=Meta):\n    class_object_access: TailoredForClassObjectAccess = TailoredForClassObjectAccess()\n    instance_access: TailoredForInstanceAccess = TailoredForInstanceAccess()\n```\n\n----------------------------------------\n\nTITLE: Default Value Type Check Suppression\nDESCRIPTION: Shows how @no_type_check affects parameter default value type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test(a: int = \"test\"):\n    return x + 5\n```\n\n----------------------------------------\n\nTITLE: Handling Negation of Dynamic Types\nDESCRIPTION: Shows how negations of dynamic types (Any and Unknown) are simplified, with the principle that the negation of an unknown set of runtime values is still an unknown set.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not, Unknown\nfrom typing_extensions import Any, Never\n\nclass P: ...\n\ndef any(\n    i1: Not[Any],\n    i2: Intersection[P, Not[Any]],\n    i3: Intersection[Never, Not[Any]],\n) -> None:\n    reveal_type(i1)  # revealed: Any\n    reveal_type(i2)  # revealed: P & Any\n    reveal_type(i3)  # revealed: Never\n\ndef unknown(\n    i1: Not[Unknown],\n    i2: Intersection[P, Not[Unknown]],\n    i3: Intersection[Never, Not[Unknown]],\n) -> None:\n    reveal_type(i1)  # revealed: Unknown\n    reveal_type(i2)  # revealed: P & Unknown\n    reveal_type(i3)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Relative Import in site-packages in Python\nDESCRIPTION: This snippet shows relative imports in site-packages, which are correctly resolved even when the site-packages search path is a subdirectory of the first-party search path.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import A\n\nreveal_type(A)  # revealed: Literal[A]\n```\n\n----------------------------------------\n\nTITLE: Defining Hexagon Stub in Namespace Package\nDESCRIPTION: Creates a stub file for the 'Hexagon' class in a namespace package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass Hexagon:\n    sides: int\n    area: float\n```\n\n----------------------------------------\n\nTITLE: Configuring Docstring Convention in pyproject.toml\nDESCRIPTION: This snippet shows how to configure the docstring convention (e.g., Google, NumPy, PEP 257) in Ruff using `pyproject.toml`.  It focuses on setting the `convention` option under `[tool.ruff.lint.pydocstyle]`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n\"[tool.ruff.lint.pydocstyle]\nconvention = \"google\"  # Accepts: \"google\", \"numpy\", or \"pep257\".\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Stub Package with __init__.py in TOML\nDESCRIPTION: Sets up the environment for a stub package using __init__.py instead of __init__.pyi.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_22\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with File Path - VS Code\nDESCRIPTION: Example of configuring Ruff using a configuration file path in VS Code settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.configuration\": \"~/path/to/ruff.toml\"\n}\n```\n\n----------------------------------------\n\nTITLE: Misspelled Type Error Suppression in Python\nDESCRIPTION: Example showing how a misspelled `type: ignore` comment results in both the original error and an invalid ignore comment error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference]\n# error: [invalid-ignore-comment]\na = test + 2  # type: ignoree\n```\n\n----------------------------------------\n\nTITLE: Invalid Old-Style Iteration with __getitem__ in Python\nDESCRIPTION: Shows how a __getitem__ method that doesn't accept integer arguments fails to support membership tests, resulting in unsupported-operator diagnostics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __getitem__(self, key: str) -> str:\n        return \"foo\"\n\n# error: [unsupported-operator] \"Operator `in` is not supported for types `int` and `A`, in comparing `Literal[42]` with `A`\"\nreveal_type(42 in A())  # revealed: bool\n# error: [unsupported-operator] \"Operator `in` is not supported for types `str` and `A`, in comparing `Literal[\"hello\"]` with `A`\"\nreveal_type(\"hello\" in A())  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Workers KV Implementation Documentation\nDESCRIPTION: Documentation for key-value store based on Cloudflare Workers KV, used for storing code snippets and generating shareable playground URLs.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/playground/api/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# api\\n\\nKey-value store based on [Workers KV](https://developers.cloudflare.com/workers/runtime-apis/kv/).\\n\\nUsed to persist code snippets in the playground and generate shareable URLs.\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Version for PEP 695\nDESCRIPTION: TOML configuration to specify Python 3.12 as the required version for PEP 695 type aliases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/pep695_type_aliases.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.12\"\n```\n\n----------------------------------------\n\nTITLE: Using Await at Module Level in Python\nDESCRIPTION: This snippet demonstrates using 'await' at the module level. While it doesn't cause a syntax error, it will result in a runtime TypeError when executed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/await_scope.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nawait 1  # runtime TypeError but not a syntax error\n```\n\n----------------------------------------\n\nTITLE: EllipsisType Handling Python 3.9 and Below\nDESCRIPTION: Shows type narrowing with EllipsisType in Python 3.9 and below. Includes TOML configuration and demonstrates legacy handling of ellipsis type narrowing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = ... if flag else 42\n\n    reveal_type(x)  # revealed: ellipsis | Literal[42]\n\n    if x is ...:\n        reveal_type(x)  # revealed: ellipsis\n    else:\n        reveal_type(x)  # revealed: Literal[42]\n```\n\n----------------------------------------\n\nTITLE: Using ClassVar Outside of a Class in Python\nDESCRIPTION: Shows ClassVar being used outside of a class context. Although the code notes this should be an error, the current implementation allows it.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/classvar.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\n# TODO: this should be an error\nx: ClassVar[int] = 1\n```\n\n----------------------------------------\n\nTITLE: Invalid Getter Signature Example in Python\nDESCRIPTION: Shows error handling for incorrect getter method signature.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `((Any, /) -> Any) | None`, found `def attr(self, x: int) -> int`\"\n    @property\n    def attr(self, x: int) -> int:\n        return 1\n```\n\n----------------------------------------\n\nTITLE: Invalid Literal Usage in Python\nDESCRIPTION: Demonstrates invalid usage of Literal types, specifically showing the error when Literal is used without arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\n# error: [invalid-type-form] \"`typing.Literal` requires at least one argument when used in a type expression\"\ndef _(x: Literal):\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Generating MkDocs Documentation - Shell Commands\nDESCRIPTION: Commands for generating and serving MkDocs documentation locally. Includes steps for both regular contributors and Astral org members.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuv run --no-project --isolated --with-requirements docs/requirements.txt scripts/generate_mkdocs.py\n```\n\nLANGUAGE: shell\nCODE:\n```\nuvx --with-requirements docs/requirements.txt -- mkdocs serve -f mkdocs.public.yml\n```\n\nLANGUAGE: shell\nCODE:\n```\nuvx --with-requirements docs/requirements-insiders.txt -- mkdocs serve -f mkdocs.insiders.yml\n```\n\n----------------------------------------\n\nTITLE: Selecting Lint Rules in Ruff LSP\nDESCRIPTION: Specifies rules to enable by default for linting. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.select\": [\"E\", \"F\"]\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      lint = {\n        select = {\"E\", \"F\"}\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"lint\": {\n            \"select\": [\"E\", \"F\"]\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignment Error Test\nDESCRIPTION: Demonstrates testing type checking errors with error assertions\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx: str = 1  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Identity Comparisons with Intersection Types in Python\nDESCRIPTION: This snippet explores identity comparisons in the context of intersection types. It demonstrates type narrowing when comparing objects to None and reveals the resulting types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\ndef _(o: object):\n    a = A()\n    n = None\n\n    if o is not None:\n        reveal_type(o)  # revealed:  ~None\n        reveal_type(o is n)  # revealed: Literal[False]\n        reveal_type(o is not n)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Defining a Set with a Numeric Literal (Ruff)\nDESCRIPTION: This snippet shows how Ruff formats a set containing a numeric literal. Ruff preserves the parentheses around the literal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nitems = {(123)}\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Tuple Types in Python\nDESCRIPTION: This code demonstrates disjointness relations between different tuple types. It shows that tuples with different element types are disjoint, tuples of different lengths are disjoint, but tuples with overlapping element types are not disjoint.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, Never\nfrom knot_extensions import TypeOf, is_disjoint_from, static_assert\n\nstatic_assert(is_disjoint_from(tuple[()], TypeOf[object]))\nstatic_assert(is_disjoint_from(tuple[()], TypeOf[Literal]))\n\nstatic_assert(is_disjoint_from(tuple[None], None))\nstatic_assert(is_disjoint_from(tuple[None], Literal[b\"a\"]))\nstatic_assert(is_disjoint_from(tuple[None], Literal[\"a\"]))\nstatic_assert(is_disjoint_from(tuple[None], Literal[1]))\nstatic_assert(is_disjoint_from(tuple[None], Literal[True]))\n\nstatic_assert(is_disjoint_from(tuple[Literal[1]], tuple[Literal[2]]))\nstatic_assert(is_disjoint_from(tuple[Literal[1], Literal[2]], tuple[Literal[1]]))\nstatic_assert(is_disjoint_from(tuple[Literal[1], Literal[2]], tuple[Literal[1], Literal[3]]))\n\nstatic_assert(not is_disjoint_from(tuple[Literal[1], Literal[2]], tuple[Literal[1], int]))\n```\n\n----------------------------------------\n\nTITLE: Long Relative Import in Python\nDESCRIPTION: This snippet shows a long relative import going up multiple directory levels.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom ...foo import X\n\nreveal_type(X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Raising Exception in both nested branches in Python\nDESCRIPTION: This function demonstrates how `raise` statements in both nested branches of an `if` statement within a `try` block affect variable visibility.  It uses `reveal_type` to determine the possible types of `x` in different parts of the `try...except...finally` structure.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef raise_in_both_nested_branches(cond1: bool, cond2: bool):\n    x = \"before\"\n    try:\n        if cond1:\n            x = \"else\"\n            reveal_type(x)  # revealed: Literal[\"else\"]\n        else:\n            if cond2:\n                x = \"raise1\"\n                reveal_type(x)  # revealed: Literal[\"raise1\"]\n                raise ValueError\n            else:\n                x = \"raise2\"\n                reveal_type(x)  # revealed: Literal[\"raise2\"]\n                raise ValueError\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    except ValueError:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise1\", \"raise2\"]\n    except:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise1\", \"raise2\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"else\"]\n    finally:\n        # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n        reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise1\", \"raise2\"]\n    # Exceptions can occur anywhere, so \"before\" and \"raise\" are valid possibilities\n    reveal_type(x)  # revealed: Literal[\"before\", \"else\", \"raise1\", \"raise2\"]\n```\n\n----------------------------------------\n\nTITLE: Basic Metaclass Usage\nDESCRIPTION: Shows basic metaclass usage with a class definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass M(type): ...\nclass B(metaclass=M): ...\n\nreveal_type(B.__class__)  # revealed: Literal[M]\n```\n\n----------------------------------------\n\nTITLE: Complex Type Narrowing\nDESCRIPTION: Shows type narrowing behavior for complex intersection and union types in boolean contexts. Demonstrates how multiple type constraints are combined.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass A: ...\nclass B: ...\n\ndef instance() -> A | B:\n    return A()\n\ndef literals() -> Literal[0, 42, \"\", \"hello\"]:\n    return 42\n```\n\n----------------------------------------\n\nTITLE: Attribute Access on Bound Methods in Python\nDESCRIPTION: Demonstrates how attribute access on bound methods defers to types.MethodType and can access attributes of the underlying function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(bound_method.__hash__)  # revealed: bound method MethodType.__hash__() -> int\nreveal_type(bound_method.__kwdefaults__)  # revealed: @Todo(generics) | None\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always False 'and' Boolean Expression in Python\nDESCRIPTION: Shows how type inference handles short-circuit evaluation in 'and' expressions with a false first operand. Only the first assignment expression is evaluated.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n(x := 0) and (x := 1)\n\nreveal_type(x)  # revealed: Literal[0]\n\n(y := 0) and (y := 1) and (y := 2) and (y := 3)\n\nreveal_type(y)  # revealed: Literal[0]\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment for All Platforms in TOML\nDESCRIPTION: TOML configuration that specifies the project should work with all Python platforms. This setting causes sys.platform to be treated as a LiteralString type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-platform = \"all\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Fix Safety\nDESCRIPTION: TOML configuration for customizing which fixes are considered safe or unsafe\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nextend-safe-fixes = [\"F601\"]\nextend-unsafe-fixes = [\"UP034\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'for' and 'break' inside 'if True' in Python\nDESCRIPTION: Demonstrates type analysis when a for loop with a break statement is inside an always-true condition. The variable 'x' can be either 3 or 4 after execution, depending on whether the break is executed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef iterable() -> list[object]:\n    return [1, \"\"]\n\nx = 1\n\nif True:\n    x = 2\n    for _ in iterable():\n        x = 3\n        break\n    else:\n        x = 4\nelse:\n    x = 5\n\nreveal_type(x)  # revealed: Literal[3, 4]\n```\n\n----------------------------------------\n\nTITLE: Manual Property Construction in Python\nDESCRIPTION: Shows how to manually construct a property using the property class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def attr_getter(self) -> int:\n        return 1\n    attr = property(attr_getter)\n\nc = C()\nreveal_type(c.attr)  # revealed: Unknown | int\n```\n\n----------------------------------------\n\nTITLE: Gradual Typing with Possibly-Unbound Attributes\nDESCRIPTION: Illustrates gradual typing behavior with possibly-unbound attributes, showing how Any types interact with more specific types in attribute declarations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef _(flag: bool):\n    class Base:\n        x: Any\n\n    class Derived(Base):\n        if flag:\n            # Redeclaring `x` with a more static type is okay in terms of LSP.\n            x: int\n\n    reveal_type(Derived().x)  # revealed: int | Any\n\n    Derived().x = 1\n    Derived().x = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Advanced CallableTypeOf Usage in Python\nDESCRIPTION: Shows advanced usage of CallableTypeOf with class methods and reveals type information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __init__(self, x: int) -> None:\n        pass\n\n    def __call__(self, x: int) -> str:\n        return \"foo\"\n\ndef _(\n    c1: CallableTypeOf[f1],\n    c2: CallableTypeOf[f2],\n    c3: CallableTypeOf[f3],\n    c4: CallableTypeOf[Foo],\n    c5: CallableTypeOf[Foo(42).__call__],\n) -> None:\n    reveal_type(c1)  # revealed: () -> Unknown\n    reveal_type(c2)  # revealed: () -> int\n    reveal_type(c3)  # revealed: (x: int, y: str) -> None\n\n    # TODO: should be `(x: int) -> Foo`\n    reveal_type(c4)  # revealed: (...) -> Foo\n\n    reveal_type(c5)  #  revealed: (x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with descriptor as __init__ method in Python\nDESCRIPTION: Shows the behavior of using a descriptor as the __init__ method, including type checking and error handling for different argument scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass SomeCallable:\n    # TODO: at runtime `__init__` is checked to return `None` and\n    # a `TypeError` is raised if it doesn't. However, apparently\n    # this is not true when the descriptor is used as `__init__`.\n    # However, we may still want to check this.\n    def __call__(self, x: int) -> str:\n        return \"a\"\n\nclass Descriptor:\n    def __get__(self, instance, owner) -> SomeCallable:\n        return SomeCallable()\n\nclass Foo:\n    __init__: Descriptor = Descriptor()\n\nreveal_type(Foo(1))  # revealed: Foo\n# error: [missing-argument] \"No argument provided for required parameter `x` of bound method `__call__`\"\nreveal_type(Foo())  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Python 3.10 Environment Configuration in TOML\nDESCRIPTION: Configures the Python version to 3.10 in a TOML configuration file, enabling support for new-style union syntax using the '|' operator.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Different Parameter Types\nDESCRIPTION: This code demonstrates that callable types with different parameter types or untyped parameters are not equivalent. It shows that parameter type annotations contribute to the callable's type identity.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef f9(a: int) -> None: ...\ndef f10(a: str) -> None: ...\ndef f11(a) -> None: ...\n\nstatic_assert(not is_equivalent_to(CallableTypeOf[f9], CallableTypeOf[f10]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f10], CallableTypeOf[f11]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f11], CallableTypeOf[f10]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f11], CallableTypeOf[f11]))\n```\n\n----------------------------------------\n\nTITLE: Importing Possibly Unbound Symbol from Module in Python\nDESCRIPTION: Shows how importing a symbol that is defined in conditionally executed code results in a possibly-unbound-import error. The variable 'symbol' is considered possibly unbound in the module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n# error: [possibly-unbound-import]\nfrom module import symbol\n```\n\n----------------------------------------\n\nTITLE: Defining Stub Package with __init__.py in Python\nDESCRIPTION: Creates a stub package using __init__.py instead of the recommended __init__.pyi.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nclass Pentagon:\n    sides: int\n    area: float\n\nclass Hexagon:\n    sides: int\n    area: float\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Interpreter for Ruff in VS Code\nDESCRIPTION: Specifies a list of paths to Python interpreters. Only the first interpreter is used. The usage depends on the 'ruff.nativeServer' setting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.interpreter\": [\"/home/user/.local/bin/python\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Module Wildcard Import Chain\nDESCRIPTION: Illustrates how wildcard imports work across multiple module levels\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import *\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom c import *\n\nreveal_type(X)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Empty Tuple Is Not Equivalent to Never\nDESCRIPTION: A static assertion demonstrating that an empty tuple type is not equivalent to Never, unlike tuples containing Never.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/tuples_containing_never.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(not is_equivalent_to(Never, tuple[()]))\n```\n\n----------------------------------------\n\nTITLE: Duplicate Type Collapsing\nDESCRIPTION: Shows how duplicate types in unions are automatically collapsed into a single occurrence.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/union_types.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(u1: int | int | str, u2: int | str | int) -> None:\n    reveal_type(u1)  # revealed: int | str\n    reveal_type(u2)  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Linter Arguments (Legacy)\nDESCRIPTION: Example of configuring Ruff linter arguments using the deprecated ruff-lsp settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.args\": \"--select=E,F --unfixable=F401 --unsafe-fixes\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Inline Tests Command\nDESCRIPTION: Shell command to generate Python files from inline tests in the parser codebase.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --package ruff_python_parser --test generate_inline_tests\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff using various package managers\nDESCRIPTION: This snippet demonstrates how to install Ruff globally or add it to a project using uv, pip, or pipx. It shows the commands for different installation methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/faq.md#2025-04-17_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ # Install Ruff globally.\n$ uv tool install ruff@latest\n\n$ # Or add Ruff to your project.\n$ uv add --dev ruff\n\n$ # With pip.\n$ pip install ruff\n\n$ # With pipx.\n$ pipx install ruff\n```\n\n----------------------------------------\n\nTITLE: Type Union for Possibly Unbound Attributes\nDESCRIPTION: Shows how the type system handles possibly unbound attributes by creating a union of the attribute type and the __getattr__ return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(c.possibly_unbound)  # revealed: bytes | GetAttrReturnType\n```\n\n----------------------------------------\n\nTITLE: Issues with __contains__ Methods That Return Non-Boolable Types in Python\nDESCRIPTION: Demonstrates runtime errors that occur when a __contains__ method returns an object that can't be converted to bool because it doesn't implement __bool__ correctly.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/membership_test.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\nclass WithContains:\n    def __contains__(self, item) -> NotBoolable:\n        return NotBoolable()\n\n# error: [unsupported-bool-conversion]\n10 in WithContains()\n# error: [unsupported-bool-conversion]\n10 not in WithContains()\n```\n\n----------------------------------------\n\nTITLE: Inability to Suppress Syntax Errors in Python\nDESCRIPTION: Demonstrates that syntax errors cannot be suppressed with knot: ignore, resulting in both the syntax error and an unused-ignore-comment warning.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [unused-ignore-comment]\ndef test($):  # knot: ignore\n    pass\n```\n\n----------------------------------------\n\nTITLE: Variable Boundness with Chained Conditionals in Python\nDESCRIPTION: Shows how variable boundness is determined with chained conditional statements. Variables defined in at least one always-executed branch are considered bound.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    x = 1\nif True:\n    x = 2\n\n# x is always bound, no error\nx\n\nif False:\n    y = 1\nif True:\n    y = 2\n\n# y is always bound, no error\ny\n\nif False:\n    z = 1\nif False:\n    z = 2\n\n# z is never bound:\n# error: [unresolved-reference]\nz\n```\n\n----------------------------------------\n\nTITLE: Testing Tuple Type Equivalence in Python\nDESCRIPTION: Demonstrates gradual equivalence tests for tuple types. Shows that tuples with the same elements in the same order are equivalent, and those with different orders or different elements are not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown, is_gradual_equivalent_to, static_assert\nfrom typing import Any\n\nstatic_assert(is_gradual_equivalent_to(tuple[str, Any], tuple[str, Unknown]))\n\nstatic_assert(not is_gradual_equivalent_to(tuple[str, int], tuple[str, int, bytes]))\nstatic_assert(not is_gradual_equivalent_to(tuple[str, int], tuple[int, str]))\n```\n\n----------------------------------------\n\nTITLE: Import Type Declaration from Stub File\nDESCRIPTION: Demonstrates type inference when importing a variable defined in a .pyi stub file. The reveal_type shows that variable y inherits the int type from x defined in b.pyi.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stubs.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom b import x\n\ny = x\nreveal_type(y)  # revealed: int\n```\n\nLANGUAGE: python\nCODE:\n```\nx: int\n```\n\n----------------------------------------\n\nTITLE: Multiple Assignment Operations\nDESCRIPTION: Demonstrates multiple assignment operations with and without semicolons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Multiple assignment without a semicolon\nx = y = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n# Multiple assignment with a semicolon\nx = y = 1;\nx = y = 1;\n```\n\n----------------------------------------\n\nTITLE: Invalid Callable Form Example\nDESCRIPTION: Shows how an invalid Callable form with incorrect parameter specification results in Unknown return type and accepts any parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/annotation.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-type-form]\ndef _(c: Callable[42, str]):\n    reveal_type(c())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Defining Lists with Boolean Literals (Black)\nDESCRIPTION: These snippets show how Black formats lists containing boolean literals with parentheses. Black removes the extra parentheses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nitems = [True]\nitems = [True]\n```\n\n----------------------------------------\n\nTITLE: Testing Type Operations with Class Factories\nDESCRIPTION: Demonstrates type checking behavior with functions returning class types. Shows that operator operations are not supported between class types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef yes() -> type[Yes]:\n    return Yes\n\ndef sub() -> type[Sub]:\n    return Sub\n\ndef no() -> type[No]:\n    return No\n\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `type[Yes]` and `type[Yes]`\"\nreveal_type(yes() + yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `type[Sub]` and `type[Sub]`\"\nreveal_type(sub() + sub())  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `type[No]` and `type[No]`\"\nreveal_type(no() + no())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Bare Import of Module in Python\nDESCRIPTION: This snippet shows a bare import of a module and accessing its attribute.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom . import foo\n\nreveal_type(foo.X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Class Pattern Match with Guard Type Narrowing\nDESCRIPTION: Illustrates type narrowing with class patterns that include guard conditions. Shows type changes within guard expressions for classes A and B.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/match.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_object() -> object:\n    return object()\n\nclass A:\n    def y() -> int:\n        return 1\n\nclass B: ...\n\nx = get_object()\n\nreveal_type(x)  # revealed: object\n\nmatch x:\n    case A() if reveal_type(x):  # revealed: A\n        pass\n    case B() if reveal_type(x):  # revealed: B\n        pass\n\nreveal_type(x)  # revealed: object\n```\n\n----------------------------------------\n\nTITLE: Testing Variadic Function Type Equivalence in Python\nDESCRIPTION: Demonstrates that functions with both *args and **kwargs (whether annotated as Any or unannotated) are gradual equivalent to callables with ... as the parameter type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef variadic_without_annotation(*args, **kwargs):\n    return\n\ndef variadic_with_annotation(*args: Any, **kwargs: Any) -> Any:\n    return\n\nstatic_assert(is_gradual_equivalent_to(CallableTypeOf[variadic_without_annotation], Callable[..., Any]))\nstatic_assert(is_gradual_equivalent_to(CallableTypeOf[variadic_with_annotation], Callable[..., Any]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating False Negatives in Existing Type Checkers with Python\nDESCRIPTION: This snippet illustrates how Mypy and Pyright's type inference can lead to false negatives in certain scenarios, while Ruff's approach more accurately reflects the lack of knowledge about types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass OptionalInt:\n    value = 10\n\ndef reset(o):\n    o.value = None\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom optional_int import OptionalInt, reset\n\no = OptionalInt()\nreset(o)  # Oh no...\n\n# Mypy and Pyright infer a fully-static type of `int` here, which appears to make the\n# subsequent division operation safe -- but it is not. We infer the following type:\nreveal_type(o.value)  # revealed: Unknown | Literal[10]\n\nprint(o.value // 2)  # Runtime error!\n```\n\n----------------------------------------\n\nTITLE: Invalid Expressions in String Type Annotations in Python\nDESCRIPTION: Demonstrates various Python expressions that are syntactically valid strings but not valid as type annotations. This shows how the type checker handles invalid type expressions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na: \"1 or 2\"\nb: \"(x := 1)\"\nc: \"1 + 2\"\nd: \"lambda x: x\"\ne: \"x if True else y\"\nf: \"{'a': 1, 'b': 2}\"\ng: \"{1, 2}\"\nh: \"[i for i in range(5)]\"\ni: \"{i for i in range(5)}\"\nj: \"{i: i for i in range(5)}\"\nk: \"(i for i in range(5))\"\nl: \"await 1\"\n# error: [invalid-syntax-in-forward-annotation]\nm: \"yield 1\"\n# error: [invalid-syntax-in-forward-annotation]\nn: \"yield from 1\"\no: \"1 < 2\"\np: \"call()\"\nr: \"[1, 2]\"\ns: \"(1, 2)\"\n```\n\n----------------------------------------\n\nTITLE: Testing Single-Valued Types in Python\nDESCRIPTION: Shows usage of is_single_valued to check for types that represent a single value. Includes examples with None, Literal, and union types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_single_valued, static_assert\nfrom typing import Literal\n\nstatic_assert(is_single_valued(None))\nstatic_assert(is_single_valued(Literal[True]))\nstatic_assert(is_single_valued(Literal[\"a\"]))\n\nstatic_assert(not is_single_valued(int))\nstatic_assert(not is_single_valued(Literal[\"a\"] | Literal[\"b\"]))\n```\n\n----------------------------------------\n\nTITLE: Importing Non-Existent Module Without 'from' in Python\nDESCRIPTION: This example illustrates the error when attempting to import a non-existent module without using the 'from' keyword. It shows how Ruff handles direct imports of unresolvable modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport does_not_exist  # error: [unresolved-import]\n\nx = does_not_exist.foo\n```\n\n----------------------------------------\n\nTITLE: Nesting Async Comprehension in Regular Comprehension in Python\nDESCRIPTION: A nested comprehension with an async inner loop inside a regular outer loop. This syntax is an error in Python 3.10 but became valid in later Python versions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/async_comprehension.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n[[x async for x in elements(5)] for i in range(5)]  # error on 3.10, okay after\n```\n\n----------------------------------------\n\nTITLE: Function Literals Type Narrowing\nDESCRIPTION: Shows how function objects are treated in boolean contexts, demonstrating that functions are always considered truthy values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/truthiness.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\ndef foo(hello: int) -> bytes:\n    return b\"\"\n\ndef bar(world: str, *args, **kwargs) -> float:\n    return 0.0\n\nx = foo if flag() else bar\n\nif x:\n    reveal_type(x)  # revealed: (def foo(hello: int) -> bytes) | (def bar(world: str, *args, **kwargs) -> int | float)\nelse:\n    reveal_type(x)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Handling Union over Callables with Possibly Unbound __call__ in Python\nDESCRIPTION: This snippet demonstrates a complex scenario involving a union of types where one type might have an unbound __call__ method, leading to potential errors when calling instances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef outer(cond1: bool):\n    class Test:\n        if cond1:\n            def __call__(self): ...\n\n    class Other:\n        def __call__(self): ...\n\n    def inner(cond2: bool):\n        if cond2:\n            a = Test()\n        else:\n            a = Other()\n\n            # error: [call-non-callable] \"Object of type `Test` is not callable (possibly unbound `__call__` method)\"\n        a()\n```\n\n----------------------------------------\n\nTITLE: Eager Set Comprehension Resolution\nDESCRIPTION: Demonstrates how set comprehensions evaluate variable references eagerly at definition time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    x = 1\n\n    # revealed: Literal[1]\n    {reveal_type(x) for a in range(1)}\n\n    x = 2\n```\n\n----------------------------------------\n\nTITLE: Using Stub Package with __init__.py in Python\nDESCRIPTION: Demonstrates usage of the stubbed 'Pentagon' and 'Hexagon' classes from a package using __init__.py.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom shapes import Hexagon, Pentagon\n\nreveal_type(Pentagon().sides)  # revealed: int\nreveal_type(Hexagon().area)  # revealed: int | float\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Different Parameter Counts\nDESCRIPTION: This code demonstrates that callable types with different numbers of parameters are not equivalent. It imports the necessary modules for testing callable type equivalence.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, is_equivalent_to, static_assert\nfrom typing import Callable\n```\n\nLANGUAGE: python\nCODE:\n```\ndef f1(a: int) -> None: ...\ndef f2(a: int, b: int) -> None: ...\n\nstatic_assert(not is_equivalent_to(CallableTypeOf[f1], CallableTypeOf[f2]))\n```\n\n----------------------------------------\n\nTITLE: Final Classes Type Usage\nDESCRIPTION: Shows type[] behavior with @final decorated classes in Python 3.10.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom types import EllipsisType\nfrom typing import final\n\n@final\nclass Foo: ...\n\ndef _(x: type[Foo], y: type[EllipsisType]):\n    reveal_type(x)  # revealed: Literal[Foo]\n    reveal_type(y)  # revealed: Literal[EllipsisType]\n```\n\n----------------------------------------\n\nTITLE: Invalid Inheritance from Type Qualifiers in Python\nDESCRIPTION: Demonstrates that inheritance from type qualifiers (Final, ClassVar, Required, NotRequired, ReadOnly) is not supported and generates invalid-base errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_type_qualifiers.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Final, ClassVar, Required, NotRequired, ReadOnly\n\nclass A(Final): ...  # error: [invalid-base]\nclass B(ClassVar): ...  # error: [invalid-base]\nclass C(Required): ...  # error: [invalid-base]\nclass D(NotRequired): ...  # error: [invalid-base]\nclass E(ReadOnly): ...  # error: [invalid-base]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with Inline Settings - Neovim\nDESCRIPTION: Example of configuring Ruff using inline configuration in Neovim settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_3\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    configuration = {\n      lint = {\n        unfixable = {\"F401\"},\n        [\"extend-select\"] = {\"TID251\"},\n        [\"flake8-tidy-imports\"] = {\n          [\"banned-api\"] = {\n            [\"typing.TypedDict\"] = {\n              msg = \"Use `typing_extensions.TypedDict` instead\"\n            }\n          }\n        }\n      },\n      format = {\n        [\"quote-style\"] = \"single\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Defined __all__ in Python 3.10\nDESCRIPTION: Shows environment configuration for Python 3.10, which affects how the conditionally defined __all__ will be resolved in subsequent code examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Running Ruff with Docker\nDESCRIPTION: Provides examples of running Ruff using Docker, including how to use a specific version and how to use it with Podman on SELinux.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ docker run -v .:/io --rm ghcr.io/astral-sh/ruff check\n$ docker run -v .:/io --rm ghcr.io/astral-sh/ruff:0.3.0 check\n\n$ # Or, for Podman on SELinux.\n$ docker run -v .:/io:Z --rm ghcr.io/astral-sh/ruff check\n```\n\n----------------------------------------\n\nTITLE: Code-Specific Type Error Suppression in Python\nDESCRIPTION: Example of using code-specific `type: ignore` comments with Mypy. Red Knot ignores the specific code and suppresses all errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\na = test  # type: ignore[name-defined]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'while False...else' in Python\nDESCRIPTION: Shows type analysis when a while loop with an always-false condition has an else clause. The else block is always executed, resulting in 'x' having the value 2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nwhile False:\n    x = 1\nelse:\n    x = 2\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Running Parser Benchmarks\nDESCRIPTION: Shell command to run performance benchmarks for the parser component.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench --package ruff_benchmark --bench parser\n```\n\n----------------------------------------\n\nTITLE: Import Module Attribute vs Submodule - Combined Import\nDESCRIPTION: Demonstrates behavior when using both direct import and from-import in the same file\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport a.b\nfrom a import b\n\nreveal_type(b)  # revealed: <module 'a.b'>\nreveal_type(a.b)  # revealed: <module 'a.b'>\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Inconsistent Default Values\nDESCRIPTION: This code demonstrates that callable types where one has a default parameter value and the other doesn't are not equivalent. The presence of default values affects the callable's type equivalence.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef f12(a: int) -> None: ...\ndef f13(a: int = 2) -> None: ...\n\nstatic_assert(not is_equivalent_to(CallableTypeOf[f12], CallableTypeOf[f13]))\nstatic_assert(not is_equivalent_to(CallableTypeOf[f13], CallableTypeOf[f12]))\n```\n\n----------------------------------------\n\nTITLE: Multiple Invalid Arguments Test\nDESCRIPTION: Tests detection of multiple invalid argument types in a single function call.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, y: int, z: int) -> int:\n    return x * y * z\n\n# error: [invalid-argument-type]\n# error: [invalid-argument-type]\n# error: [invalid-argument-type]\nfoo(\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Correct Case Module Definition\nDESCRIPTION: Example module 'a.py' with correct casing containing a Foo class definition\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    x: int = 1\n```\n\n----------------------------------------\n\nTITLE: Multiline String Type Error Suppression in Python\nDESCRIPTION: Example demonstrating how a `type: ignore` comment can be applied at the end of a multiline string to suppress type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\na: int = 4\na = \"\"\"\n  This is a multiline string and the suppression is at its end\n\"\"\"  # type: ignore\n```\n\n----------------------------------------\n\nTITLE: Testing Byte Literal Type Assignability in Python\nDESCRIPTION: Demonstrates how byte literal types (like Literal[b\"foo\"]) are assignable to the bytes type but not to string types, and different byte literals are not assignable to each other.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to\nfrom typing_extensions import Literal, LiteralString\n\nstatic_assert(is_assignable_to(Literal[b\"foo\"], bytes))\nstatic_assert(is_assignable_to(Literal[b\"foo\"], Literal[b\"foo\"]))\n\nstatic_assert(not is_assignable_to(Literal[b\"foo\"], str))\nstatic_assert(not is_assignable_to(Literal[b\"foo\"], LiteralString))\nstatic_assert(not is_assignable_to(Literal[b\"foo\"], Literal[b\"bar\"]))\nstatic_assert(not is_assignable_to(Literal[b\"foo\"], Literal[\"foo\"]))\nstatic_assert(not is_assignable_to(Literal[\"foo\"], Literal[b\"foo\"]))\n```\n\n----------------------------------------\n\nTITLE: Advanced Ruff Configuration in Zed - JSON\nDESCRIPTION: This JSON configures additional options for Ruff in Zed to manage code actions like fixing lint violations and organizing imports on save.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"languages\": {\n    \"Python\": {\n      \"language_servers\": [\"ruff\"],\n      \"format_on_save\": \"on\",\n      \"formatter\": [\n        {\n          \"code_actions\": {\n            \"source.fixAll.ruff\": true,\n            \"source.organizeImports.ruff\": true\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Assignment Statements\nDESCRIPTION: Demonstrates basic variable assignment with and without semicolons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Assignment statement without a semicolon\nx = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n# Assignment statement with a semicolon\nx = 1;\nx = 1;\n```\n\n----------------------------------------\n\nTITLE: Airflow Mock Repository README\nDESCRIPTION: Documentation explaining the purpose of this mock repository - used as a test subset for module resolution testing in Airflow\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_resolver/resources/test/airflow/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# airflow\n\nThis is a mock subset of the Airflow repository, used to test module resolution.\n```\n\n----------------------------------------\n\nTITLE: Generating Super Resolution Image using TensorFlow Lite\nDESCRIPTION: This snippet loads the test image, prepares it for input, initializes the TFLite interpreter, runs inference on the model, and post-processes the output to obtain the super resolution image.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlr = tf.io.read_file(test_img_path)\nlr = tf.image.decode_jpeg(lr)\nlr = tf.expand_dims(lr, axis=0)\nlr = tf.cast(lr, tf.float32)\n\n# Load TFLite model and allocate tensors.\ninterpreter = tf.lite.Interpreter(model_path=esrgan_model_path)\ninterpreter.allocate_tensors()\n\n# Get input and output tensors.\ninput_details = interpreter.get_input_details()\noutput_details = interpreter.get_output_details()\n\n# Run the model\ninterpreter.set_tensor(input_details[0]['index'], lr)\ninterpreter.invoke()\n\n# Extract the output and postprocess it\noutput_data = interpreter.get_tensor(output_details[0]['index'])\nsr = tf.squeeze(output_data, axis=0)\nsr = tf.clip_by_value(sr, 0, 255)\nsr = tf.round(sr)\nsr = tf.cast(sr, tf.uint8)\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Inheritance with Cycles\nDESCRIPTION: Demonstrates MRO behavior with cyclic inheritance combined with multiple inheritance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Spam: ...\nclass Foo(Bar): ...\nclass Bar(Baz): ...\nclass Baz(Foo, Spam): ...\n\nreveal_type(Foo.__mro__)\nreveal_type(Bar.__mro__)\nreveal_type(Baz.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Python 3.10 Ellipsis Type Configuration and Usage\nDESCRIPTION: Shows the environment configuration for Python 3.10 and demonstrates how ellipsis type is revealed in that version. In Python 3.10, ellipsis is typed as 'EllipsisType'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/ellipsis.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(...)  # revealed: EllipsisType\n```\n\n----------------------------------------\n\nTITLE: Implementing Reflected Binary Operations in Python\nDESCRIPTION: Shows the implementation of reflected binary operations using magic methods. It demonstrates how type inference works for these reflected operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __radd__(self, other) -> \"A\":\n        return self\n\n    def __rsub__(self, other) -> \"A\":\n        return self\n\n    def __rmul__(self, other) -> \"A\":\n        return self\n\n    def __rmatmul__(self, other) -> \"A\":\n        return self\n\n    def __rtruediv__(self, other) -> \"A\":\n        return self\n\n    def __rfloordiv__(self, other) -> \"A\":\n        return self\n\n    def __rmod__(self, other) -> \"A\":\n        return self\n\n    def __rpow__(self, other) -> \"A\":\n        return self\n\n    def __rlshift__(self, other) -> \"A\":\n        return self\n\n    def __rrshift__(self, other) -> \"A\":\n        return self\n\n    def __rand__(self, other) -> \"A\":\n        return self\n\n    def __rxor__(self, other) -> \"A\":\n        return self\n\n    def __ror__(self, other) -> \"A\":\n        return self\n\nclass B: ...\n\nreveal_type(B() + A())  # revealed: A\nreveal_type(B() - A())  # revealed: A\nreveal_type(B() * A())  # revealed: A\nreveal_type(B() @ A())  # revealed: A\nreveal_type(B() / A())  # revealed: A\nreveal_type(B() // A())  # revealed: A\nreveal_type(B() % A())  # revealed: A\nreveal_type(B() ** A())  # revealed: A\nreveal_type(B() << A())  # revealed: A\nreveal_type(B() >> A())  # revealed: A\nreveal_type(B() & A())  # revealed: A\nreveal_type(B() ^ A())  # revealed: A\nreveal_type(B() | A())  # revealed: A\n```\n\n----------------------------------------\n\nTITLE: Multiple Typevar Occurrences\nDESCRIPTION: Examples showing how multiple occurrences of the same typevar must have the same type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef different_types[T, S](cond: bool, t: T, s: S) -> T:\n    if cond:\n        return t\n    else:\n        return s\n\ndef same_types[T](cond: bool, t1: T, t2: T) -> T:\n    if cond:\n        return t1\n    else:\n        return t2\n```\n\n----------------------------------------\n\nTITLE: Keyword-Only Arguments Test\nDESCRIPTION: Tests invalid argument type detection with keyword-only arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int, y: int, *, z: int = 0) -> int:\n    return x * y * z\n\nfoo(1, 2, z=\"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Finally Block without Reassignment\nDESCRIPTION: This snippet shows type inference in a try-finally block where the variable is not reassigned in the finally clause. It demonstrates the complexity of inferring types inside the finally block and after the entire try-finally block.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nfinally:\n    # TODO: should be Literal[1] | str\n    reveal_type(x)  # revealed: str\n\nreveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Big Integer Type Inference\nDESCRIPTION: Demonstrates type inference for large integer literals using underscores as separators.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx = 10_000_000_000_000_000_000\nreveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Invalid Single Constraint for TypeVar in Python\nDESCRIPTION: This snippet illustrates an invalid use of TypeVar with only one constraint. TypeVar requires at least two constraints if any are specified. Using a single constraint is disallowed and should result in an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/legacy.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\n# TODO: error: [invalid-type-variable-constraints]\nT = TypeVar(\"T\", int)\n```\n\n----------------------------------------\n\nTITLE: Importing Path and Math Modules in Python\nDESCRIPTION: This code snippet demonstrates importing the Path class from the pathlib module, along with the random and math modules in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nimport random\nimport math\n```\n\n----------------------------------------\n\nTITLE: Invalid External Modification of __slots__\nDESCRIPTION: Shows that while __slots__ can be modified within a class definition, external modifications are invalid and generate errors. This reflects Python's internal handling of slots.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = (\"a\",)\n\n    # Modifying `__slots__` from within the class body is fine:\n    __slots__ = (\"a\", \"b\")\n\n# No `Unknown` here:\nreveal_type(A.__slots__)  # revealed: tuple[Literal[\"a\"], Literal[\"b\"]]\n\n# But modifying it externally is not:\n\n# error: [invalid-assignment]\nA.__slots__ = (\"a\",)\n\n# error: [invalid-assignment]\nA.__slots__ = (\"a\", \"b_new\")\n\n# error: [invalid-assignment]\nA.__slots__ = (\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Descriptor Protocol for Dunder Methods in Python\nDESCRIPTION: This code snippet demonstrates that the descriptor protocol is invoked when looking up a dunder method. It defines a Descriptor class and uses it for the __getitem__ dunder in ClassWithDescriptorDunder.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass SomeCallable:\n    def __call__(self, key: int) -> str:\n        return str(key)\n\nclass Descriptor:\n    def __get__(self, instance: ClassWithDescriptorDunder, owner: type[ClassWithDescriptorDunder]) -> SomeCallable:\n        return SomeCallable()\n\nclass ClassWithDescriptorDunder:\n    __getitem__: Descriptor = Descriptor()\n\nclass_with_descriptor_dunder = ClassWithDescriptorDunder()\n\nreveal_type(class_with_descriptor_dunder[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Import with Stub Declaration in Python\nDESCRIPTION: This snippet shows a scenario where a variable 'x' is either imported from a module with a stub declaration or assigned a value. It demonstrates how this affects type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool:\n    return True\n\nif coinflip():\n    from c import x\nelse:\n    x = 1\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Tuple Comparisons in Python\nDESCRIPTION: Shows cases where tuple comparisons result in ambiguous outcomes. The types of the tuple elements are not fully known, leading to boolean results instead of boolean literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: bool, y: int):\n    a = (x,)\n    b = (y,)\n\n    reveal_type(a == a)  # revealed: bool\n    reveal_type(a != a)  # revealed: bool\n    reveal_type(a < a)  # revealed: bool\n    reveal_type(a <= a)  # revealed: bool\n    reveal_type(a > a)  # revealed: bool\n    reveal_type(a >= a)  # revealed: bool\n\n    reveal_type(a == b)  # revealed: bool\n    reveal_type(a != b)  # revealed: bool\n    reveal_type(a < b)  # revealed: bool\n    reveal_type(a <= b)  # revealed: bool\n    reveal_type(a > b)  # revealed: bool\n    reveal_type(a >= b)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Pure Class Variable Assignment\nDESCRIPTION: Demonstrates assignment behavior for pure class variables marked with ClassVar, including invalid assignments and inheritance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nc_instance.pure_class_variable1 = \"value set on instance\"\n\nC.pure_class_variable1 = \"overwritten on class\"\n\nC.pure_class_variable1 = 1\n\nclass Subclass(C):\n    pure_class_variable1: ClassVar[str] = \"overwritten on subclass\"\n\nreveal_type(Subclass.pure_class_variable1)\n```\n\n----------------------------------------\n\nTITLE: Basic Python Imports\nDESCRIPTION: Demonstrates standard Python import statements, including built-in modules and a third-party path handling module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort_expected.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\nimport random\nfrom pathlib import Path\n```\n\n----------------------------------------\n\nTITLE: Disabling Ruff Extension in VS Code\nDESCRIPTION: Controls whether to enable the Ruff extension in VS Code. Modifying this setting requires restarting VS Code to take effect.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.enable\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Type[Any] Class Property Tests in Python\nDESCRIPTION: Demonstrates how Any and Unknown types behave with class properties and nested class access.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/dynamic.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom does_not_exist import SomethingUnknown  # error: [unresolved-import]\n\nreveal_type(SomethingUnknown)  # revealed: Unknown\n\ndef test(x: Any, y: SomethingUnknown):\n    reveal_type(x.__class__)  # revealed: type[Any]\n    reveal_type(x.__class__.__class__.__class__.__class__)  # revealed: type[Any]\n    reveal_type(y.__class__)  # revealed: type[Unknown]\n    reveal_type(y.__class__.__class__.__class__.__class__)  # revealed: type[Unknown]\n```\n\n----------------------------------------\n\nTITLE: Importing User-defined TYPE_CHECKING - Usage\nDESCRIPTION: Demonstrates importing and using TYPE_CHECKING from both regular module and stub file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom constants import TYPE_CHECKING\n\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\n\nfrom stub import TYPE_CHECKING\n\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Adding Ruff Badge in RST\nDESCRIPTION: Code snippet for adding the Ruff badge to a project's README.rst file using reStructuredText syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_12\n\nLANGUAGE: rst\nCODE:\n```\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json\n    :target: https://github.com/astral-sh/ruff\n    :alt: Ruff\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement on Single-Valued Types in Python\nDESCRIPTION: Demonstrates type analysis for a match statement where the scrutinee is statically known to match one of the patterns. The variable 'x' will always have the value 2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nmatch \"a\":\n    case \"a\":\n        x = 2\n    case \"b\":\n        x = 3\n\nreveal_type(x)  # revealed: Literal[2]\n```\n\n----------------------------------------\n\nTITLE: Invalid Opening Parentheses Type Error Suppression in Python\nDESCRIPTION: Example showing that unlike Pyright, both Ruff and Mypy don't support `type: ignore` comments directly after opening parentheses to suppress errors inside the parentheses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# fmt: off\n# error: [unused-ignore-comment]\na = (  # type: ignore\n    test + 4  # error: [unresolved-reference]\n)\n```\n\n----------------------------------------\n\nTITLE: Formatting Multiline String Arguments in Python\nDESCRIPTION: Shows how Ruff preserves indentation of multiline string arguments in call expressions, unlike Black which may modify the indentation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Input\ncall(\n  \"\"\"\"\n  A multiline\n  string\n  \"\"\"\n)\n\ndedent(\"\"\"\"\n    A multiline\n    string\n\"\"\")\n```\n\n----------------------------------------\n\nTITLE: Invalid Typevar Usage Without Parameters\nDESCRIPTION: Example showing problematic typevar usage where the typevar doesn't appear in parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/functions.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef absurd[T]() -> T:\n    # There's no way to construct a T!\n    raise ValueError(\"absurd\")\n```\n\n----------------------------------------\n\nTITLE: Defining Addition Function in Python\nDESCRIPTION: This snippet defines a simple addition function in Python. It takes two parameters and returns their sum.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/vscode_language_id_expected.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfunction add(x, y) {\n    return x + y;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment for Benchmarks\nDESCRIPTION: Commands to create and set up a virtual environment with required dependencies for comparison benchmarking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/benchmarks/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv venv --project ./scripts/benchmarks\nuv sync --project ./scripts/benchmarks\n```\n\n----------------------------------------\n\nTITLE: Implementing __len__ with Literal Booleans in Python\nDESCRIPTION: This snippet demonstrates custom class implementations of `__len__` that return Literal boolean types. It shows how `len()` converts these boolean values to integers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass LiteralTrue:\n    def __len__(self) -> Literal[True]:\n        return True\n\nclass LiteralFalse:\n    def __len__(self) -> Literal[False]:\n        return False\n\nreveal_type(len(LiteralTrue()))  # revealed: Literal[1]\nreveal_type(len(LiteralFalse()))  # revealed: Literal[0]\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration\nDESCRIPTION: TOML configuration specifying Python version requirement for NoneType handling.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/issubclass.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Reveal Type Configuration\nDESCRIPTION: TOML configuration for reveal_type functionality.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Declared and Possibly Unbound Symbol Usage in Python\nDESCRIPTION: Shows type inference for declared but possibly unbound symbols, where the declared type is trusted without raising errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\ndef any() -> Any: ...\ndef flag() -> bool:\n    return True\n\na: int\nb: str\nc: Any\nd: int\n\nif flag:\n    a = 1\n    b = 2  # error: [invalid-assignment]\n    c = 3\n    d = any()\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import a, b, c, d\n\nreveal_type(a)  # revealed: int\nreveal_type(b)  # revealed: str\nreveal_type(c)  # revealed: Any\nreveal_type(d)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Nested Function Type Check Suppression\nDESCRIPTION: Shows how @no_type_check affects nested function definitions, suppressing type errors in inner function scopes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test() -> int:\n    def nested():\n        return a + 5\n```\n\n----------------------------------------\n\nTITLE: Empty List with Dangling Comment in Python\nDESCRIPTION: Example of a dangling comment inside an empty list, where the comment is neither leading nor trailing due to being surrounded by non-trivia tokens.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n[\n    # This needs to be handled as a dangling comment\n]\n```\n\n----------------------------------------\n\nTITLE: Type-Annotated Assignments\nDESCRIPTION: Demonstrates type-annotated assignments with and without semicolons and comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Annotated assignment statement without a semicolon\nx: int = 1\n```\n\nLANGUAGE: python\nCODE:\n```\n# Annotated assignment statement without a semicolon\nx: int = 1;\nx: int = 1;  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Union of Binding Errors in Function Calls\nDESCRIPTION: Shows how errors from different callable variants in a union are handled, particularly when passing too many arguments to functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f1(): ...\ndef f2(): ...\ndef _(flag: bool):\n    if flag:\n        f = f1\n    else:\n        f = f2\n\n    # TODO: we should show all errors from the union, not arbitrarily pick one union element\n    # error: [too-many-positional-arguments] \"Too many positional arguments to function `f1`: expected 0, got 1\"\n    x = f(3)\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Formatter Settings (Native Server)\nDESCRIPTION: Updated example of configuring Ruff formatter settings using the new native server settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lineLength\": 80,\n    \"ruff.configuration\": {\n        \"format\": {\n            \"quote-style\": \"double\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Closing Bracket in knot: ignore Directive in Python\nDESCRIPTION: Demonstrates that omitting the closing bracket in a knot: ignore directive results in an invalid-ignore-comment error and fails to suppress the errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference] \"Name `x` used when not defined\"\n# error: [invalid-ignore-comment] \"Invalid `knot: ignore` comment: expected a comma separating the rule codes\"\na = x / 2  # knot: ignore[unresolved-reference\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference for Undeclared Symbols in Python\nDESCRIPTION: This snippet shows how Ruff infers the type 'Unknown | None' for an undeclared symbol, allowing for more flexible assignments while maintaining type safety.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Wrapper:\n    value = None\n\nwrapper = Wrapper()\n\nreveal_type(wrapper.value)  # revealed: Unknown | None\n\nwrapper.value = 1\n```\n\n----------------------------------------\n\nTITLE: Handling Union Types with Super in Python\nDESCRIPTION: Shows how super behaves with union types, creating separate super objects for each branch and combining them into a union type, including error checking for possibly unbound attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\nclass B:\n    b: int = 42\n\nclass C(A, B): ...\nclass D(B, A): ...\n\ndef f(x: C | D):\n    reveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[A], Literal[B], Literal[object]]\n    reveal_type(D.__mro__)  # revealed: tuple[Literal[D], Literal[B], Literal[A], Literal[object]]\n\n    s = super(A, x)\n    reveal_type(s)  # revealed: <super: Literal[A], C> | <super: Literal[A], D>\n\n    # error: [possibly-unbound-attribute] \"Attribute `b` on type `<super: Literal[A], C> | <super: Literal[A], D>` is possibly unbound\"\n    s.b\n\ndef f(flag: bool):\n    x = str() if flag else str(\"hello\")\n    reveal_type(x)  # revealed: Literal[\"\", \"hello\"]\n    reveal_type(super(str, x))  # revealed: <super: Literal[str], str>\n\ndef f(x: int | str):\n    # error: [invalid-super-argument] \"`str` is not an instance or subclass of `Literal[int]` in `super(Literal[int], str)` call\"\n    super(int, x)\n```\n\n----------------------------------------\n\nTITLE: Variadic Keyword Arguments Test\nDESCRIPTION: Tests invalid argument type detection with variadic keyword arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef foo(**numbers: int) -> int:\n    return len(numbers)\n\nfoo(a=1, b=2, c=3, d=\"hello\", e=5)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Possibly-Unbound Dunder Method in Python\nDESCRIPTION: This code snippet shows how a possibly-unbound dunder method is handled. It defines a class with a conditional __getitem__ method and demonstrates that calling it results in a call-possibly-unbound-method error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class C:\n        if flag:\n            def __getitem__(self, key: int) -> str:\n                return str(key)\n\n    c = C()\n    # error: [call-possibly-unbound-method]\n    reveal_type(c[0])  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TypeVar Narrowing with Constrained TypeVars in Python\nDESCRIPTION: Shows how narrowing expressions can eliminate possibilities of constrained typevars, and how type checking handles these narrowed types in conditional blocks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass P: ...\nclass Q: ...\nclass R: ...\n\ndef f[T: (P, Q)](t: T) -> None:\n    if isinstance(t, P):\n        reveal_type(t)  # revealed: P\n        p: P = t\n    else:\n        reveal_type(t)  # revealed: Q & ~P\n        q: Q = t\n\n    if isinstance(t, Q):\n        reveal_type(t)  # revealed: Q\n        q: Q = t\n    else:\n        reveal_type(t)  # revealed: P & ~Q\n        p: P = t\n\ndef g[T: (P, Q, R)](t: T) -> None:\n    if isinstance(t, P):\n        reveal_type(t)  # revealed: P\n        p: P = t\n    elif isinstance(t, Q):\n        reveal_type(t)  # revealed: Q & ~P\n        q: Q = t\n    else:\n        reveal_type(t)  # revealed: R & ~P & ~Q\n        r: R = t\n\n    if isinstance(t, P):\n        reveal_type(t)  # revealed: P\n        p: P = t\n    elif isinstance(t, Q):\n        reveal_type(t)  # revealed: Q & ~P\n        q: Q = t\n    elif isinstance(t, R):\n        reveal_type(t)  # revealed: R & ~P & ~Q\n        r: R = t\n    else:\n        reveal_type(t)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Equality with Non-Boolean Results\nDESCRIPTION: Demonstrates how tuple equality comparisons handle elements that return non-boolean results from their __eq__ methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: None = None\n\nclass A:\n    def __eq__(self, other) -> NotBoolable:\n        return NotBoolable()\n\n# error: [unsupported-bool-conversion]\n(A(),) == (A(),)\n```\n\n----------------------------------------\n\nTITLE: Correct Package Import Usage\nDESCRIPTION: Example of correct package import with proper casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom db.a import Foo\n\nreveal_type(Foo().x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Mismatching Signatures in Union Callable Types\nDESCRIPTION: Demonstrates type checking behavior when calling a union of functions with incompatible parameter types, showing how argument type errors are handled.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f1(a: int) -> int:\n    return a\n\ndef f2(a: str) -> str:\n    return a\n\ndef _(flag: bool):\n    if flag:\n        f = f1\n    else:\n        f = f2\n\n    # error: [invalid-argument-type] \"Argument to this function is incorrect: Expected `str`, found `Literal[3]`\"\n    x = f(3)\n    reveal_type(x)  # revealed: int | str\n```\n\n----------------------------------------\n\nTITLE: Code-Specific Suppression in Python\nDESCRIPTION: Shows how to suppress a specific error type by including the error code in brackets after knot: ignore.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na = 4 + test  # knot: ignore[unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Class Union with Non-Class Object for __class_getitem__\nDESCRIPTION: Demonstrates a TODO case where a variable might be either a class with __class_getitem__ or a non-class object, showing the current behavior and expected typing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        class Eggs:\n            def __class_getitem__(self, x: int) -> str:\n                return \"foo\"\n\n    else:\n        Eggs = 1\n\n    a = Eggs[42]  # error: \"Cannot subscript object of type `Literal[Eggs] | Literal[1]` with no `__getitem__` method\"\n\n    # TODO: should _probably_ emit `str | Unknown`\n    reveal_type(a)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Accessing Bool-Literal Attributes\nDESCRIPTION: Shows how attributes on bool literals are delegated to builtins.bool, with methods properly typed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_40\n\nLANGUAGE: python\nCODE:\n```\n# revealed: bound method Literal[True].__and__(**kwargs: @Todo(todo signature **kwargs)) -> @Todo(return type of overloaded function)\nreveal_type(True.__and__)\n# revealed: bound method Literal[False].__or__(**kwargs: @Todo(todo signature **kwargs)) -> @Todo(return type of overloaded function)\nreveal_type(False.__or__)\n```\n\n----------------------------------------\n\nTITLE: Importing Modules and Assigning Variables in Python\nDESCRIPTION: This snippet demonstrates importing the math and os modules in Python, and assigning the value of pi from the math module to a variable. The os module is imported but not used in this snippet.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/no_trailing_newline.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\nimport os\n\n_ = math.pi\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Resolved Import of Symbol From Unresolved Import in Python\nDESCRIPTION: This example shows how an unresolved import in one file affects imports in another file. The unresolved import of 'foo' in 'a.py' leads to an unknown type when imported in another file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport foo as foo  # error: \"Cannot resolve import `foo`\"\n\nreveal_type(foo)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom a import foo\n\nreveal_type(foo)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Module with Empty List __all__\nDESCRIPTION: Example of a module that defines an empty list as __all__, indicating that no symbols should be exported when star-imported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nY: bool = True\n\n__all__ = []\n```\n\n----------------------------------------\n\nTITLE: Testing Self-Inheritance and Direct Cycles\nDESCRIPTION: Demonstrates handling of classes that inherit from themselves and direct cyclic inheritance patterns.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Foo(Foo): ...\n\nreveal_type(Foo)\nreveal_type(Foo.__mro__)\n\nclass Bar: ...\nclass Baz: ...\nclass Boz(Bar, Baz, Boz): ...\n\nreveal_type(Boz)\nreveal_type(Boz.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Downloading and Converting ESRGAN Model to TensorFlow Lite Format\nDESCRIPTION: This snippet loads the ESRGAN model from TensorFlow Hub, creates a concrete function, and converts it to TensorFlow Lite format. The converted model is then saved to a file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_server/resources/test/fixtures/tensorflow_test_notebook.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmodel = hub.load(\"https://tfhub.dev/captain-pool/esrgan-tf2/1\")\nconcrete_func = model.signatures[tf.saved_model.DEFAULT_SERVING_SIGNATURE_DEF_KEY]\n\n@tf.function(input_signature=[tf.TensorSpec(shape=[1, 50, 50, 3], dtype=tf.float32)])\ndef f(input):\n  return concrete_func(input);\n\nconverter = tf.lite.TFLiteConverter.from_concrete_functions([f.get_concrete_function()], model)\nconverter.optimizations = [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\n\n# Save the TF Lite model.\nwith tf.io.gfile.GFile('ESRGAN.tflite', 'wb') as f:\n  f.write(tflite_model)\n\nesrgan_model_path = './ESRGAN.tflite'\n```\n\n----------------------------------------\n\nTITLE: Handling Subscript Operations on Objects with Non-Callable __getitem__ in Python\nDESCRIPTION: Shows that having a __getitem__ attribute that is not callable (set to None) also results in a type error when attempting to use subscript notation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/instance.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass NotSubscriptable:\n    __getitem__ = None\n\n# error: \"Method `__getitem__` of type `Unknown | None` is not callable on object of type `NotSubscriptable`\"\na = NotSubscriptable()[0]\n```\n\n----------------------------------------\n\nTITLE: Type Checking Boolean Literals in Python\nDESCRIPTION: Demonstrates how boolean literals True and False are typed as Literal[True] and Literal[False] respectively when using reveal_type for type checking. This example shows the specific literal typing behavior rather than a generic bool type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/boolean.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(True)  # revealed: Literal[True]\nreveal_type(False)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Disjoint Types with Literals\nDESCRIPTION: Demonstrates disjoint types using Literal values and their relationship with int type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_disjoint_from, is_subtype_of\nfrom typing import Literal\n\nstatic_assert(is_disjoint_from(Literal[1], Literal[2]))\nstatic_assert(is_disjoint_from(Literal[1], Literal[3]))\nstatic_assert(is_disjoint_from(Literal[2], Literal[3]))\n\nstatic_assert(is_subtype_of(Literal[1], int))\nstatic_assert(is_subtype_of(Literal[2], int))\nstatic_assert(is_subtype_of(Literal[3], int))\n```\n\n----------------------------------------\n\nTITLE: String Type Narrowing with String Membership\nDESCRIPTION: Demonstrates type checking behavior when testing string membership in a string literal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: str):\n    if x in \"abc\":\n        reveal_type(x)  # revealed: str\n    else:\n        reveal_type(x)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Printing Hello World in Python\nDESCRIPTION: This snippet imports the 'os' module and prints 'hello world'. It serves as a basic Python code example in the test notebook.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/vscode_language_id.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nprint(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: Python 3.11 LiteralString Example\nDESCRIPTION: Shows the usage of native typing.LiteralString in Python 3.11 or later.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import LiteralString\n\nx: LiteralString = \"foo\"\n\ndef f():\n    reveal_type(x)  # revealed: LiteralString\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff on openSUSE Tumbleweed\nDESCRIPTION: Demonstrates the command to install Ruff on openSUSE Tumbleweed using the zypper package manager.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ sudo zypper install python3-ruff\n```\n\n----------------------------------------\n\nTITLE: Stub File with Re-exports via __all__\nDESCRIPTION: A stub file (b.pyi) that imports X and Y from module a, but only includes X in its __all__, which controls what is re-exported when star-imported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom a import X, Y\n\n__all__ = [\"X\"]\n```\n\n----------------------------------------\n\nTITLE: Testing Callable Types as Singletons\nDESCRIPTION: Tests various callable types to determine which are singleton types. Only the type of types.FunctionType.__get__ is recognized as a singleton, while other callable-related types are not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport types\nfrom typing import Callable\nfrom knot_extensions import static_assert, is_singleton, TypeOf\n\nclass A:\n    def method(self): ...\n\nstatic_assert(is_singleton(TypeOf[types.FunctionType.__get__]))\n\nstatic_assert(not is_singleton(Callable[[], None]))\nstatic_assert(not is_singleton(TypeOf[A().method]))\nstatic_assert(not is_singleton(TypeOf[A.method.__get__]))\n```\n\n----------------------------------------\n\nTITLE: Using Uninitialized Constants in Python Stub Files\nDESCRIPTION: This example demonstrates how Python stub files allow the declaration of variables without initialization, where the variables can still be referenced without causing undefined variable errors. Type checkers treat declarations like 'CONSTANT: Literal[42]' as bindings even without explicit assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/locals.md#2025-04-17_snippet_0\n\nLANGUAGE: pyi\nCODE:\n```\nfrom typing import Literal\n\nCONSTANT: Literal[42]\n\n# No error here, even though the variable is not initialized.\nuses_constant: int = CONSTANT\n```\n\n----------------------------------------\n\nTITLE: Using --force-exclude with Ruff to enforce exclusion patterns\nDESCRIPTION: These commands demonstrate the --force-exclude flag which enforces exclusion patterns even when a directory or file is explicitly specified on the command line, resulting in no files being checked.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n∴ cargo run -p ruff -- check crates/ruff_linter/resources/test/project/examples/excluded/ --force-exclude\nwarning: No Python files found under the given path(s)\n∴ cargo run -p ruff -- check crates/ruff_linter/resources/test/project/examples/excluded/script.py --force-exclude\nwarning: No Python files found under the given path(s)\n```\n\n----------------------------------------\n\nTITLE: Handling Augmented Assignments in Python Classes\nDESCRIPTION: Explores type inference for attributes involved in augmented assignments, demonstrating potential improvements in type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Weird:\n    def __iadd__(self, other: None) -> str:\n        return \"a\"\n\nclass C:\n    def __init__(self) -> None:\n        self.w = Weird()\n        self.w += None\n\n# TODO: Mypy and pyright do not support this, but it would be great if we could\n# infer `Unknown | str` or at least `Unknown | Weird | str` here.\nreveal_type(C().w)  # revealed: Unknown | Weird\n```\n\n----------------------------------------\n\nTITLE: Running Ecosystem CI Tests - Shell Commands\nDESCRIPTION: Commands for running Ruff ecosystem CI tests locally to check linter and formatter differences against real-world projects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nuvx --from ./python/ruff-ecosystem ruff-ecosystem check ruff \"./target/debug/ruff\"\n```\n\nLANGUAGE: shell\nCODE:\n```\nuvx --from ./python/ruff-ecosystem ruff-ecosystem format ruff \"./target/debug/ruff\"\n```\n\n----------------------------------------\n\nTITLE: Deeply Nested Module Import with Renaming in Python\nDESCRIPTION: Shows importing a deeply nested module with renaming and revealing the type of its class member.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/basic.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport a.b.c as c\n\nreveal_type(c.C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code for Ruff Code Actions on Save\nDESCRIPTION: This JSON snippet shows how to configure VS Code settings to automatically fix all issues and organize imports using Ruff on save for Python files. It demonstrates setting up code actions in the editor settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/features.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"[python]\": {\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.ruff\": \"explicit\",\n      \"source.organizeImports.ruff\": \"explicit\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Characters in Error Codes in Python\nDESCRIPTION: Shows that using invalid characters in error codes results in an invalid-ignore-comment error while still allowing other errors to be reported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# error: [division-by-zero]\n# error: [invalid-ignore-comment] \"Invalid `knot: ignore` comment: expected a alphanumeric character or `-` or `_` as code\"\na = 10 / 0  # knot: ignore[*-*]\n```\n\n----------------------------------------\n\nTITLE: Definition of Module b.py in Python\nDESCRIPTION: A simple module definition file that defines a variable y with value 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ny = 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Pentagon Class in Regular Package\nDESCRIPTION: Defines the actual implementation of the 'Pentagon' class without type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass Pentagon: ...\n```\n\n----------------------------------------\n\nTITLE: Basic Static Assertions in Python\nDESCRIPTION: Shows how to use static_assert for type-check time enforcement of properties. Includes examples of various static expression evaluations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\nfrom typing import TYPE_CHECKING\nimport sys\n\nstatic_assert(True)\nstatic_assert(False)  # error: \"Static assertion error: argument evaluates to `False`\"\n\nstatic_assert(False or True)\nstatic_assert(True and True)\nstatic_assert(False or False)  # error: \"Static assertion error: argument evaluates to `False`\"\nstatic_assert(False and True)  # error: \"Static assertion error: argument evaluates to `False`\"\n\nstatic_assert(1 + 1 == 2)\nstatic_assert(1 + 1 == 3)  # error: \"Static assertion error: argument evaluates to `False`\"\n\nstatic_assert(\"a\" in \"abc\")\nstatic_assert(\"d\" in \"abc\")  # error: \"Static assertion error: argument evaluates to `False`\"\n\nn = None\nstatic_assert(n is None)\n\nstatic_assert(TYPE_CHECKING)\n\nstatic_assert(sys.version_info >= (3, 6))\n```\n\n----------------------------------------\n\nTITLE: Eager Dict Comprehension Resolution\nDESCRIPTION: Shows how dictionary comprehensions evaluate variable references eagerly at definition time.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    x = 1\n\n    # revealed: Literal[1]\n    {a: reveal_type(x) for a in range(1)}\n\n    x = 2\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'if True' inside 'for' Loop in Python\nDESCRIPTION: Demonstrates how type narrowing works when an always-true condition is inside a for loop. The variable 'x' can have a value of either 1 or 3 after execution due to control flow analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef iterable() -> list[object]:\n    return [1, \"\"]\n\nx = 1\n\nfor _ in iterable():\n    x = 2\n    if True:\n        x = 3\n\nreveal_type(x)  # revealed: Literal[1, 3]\n```\n\n----------------------------------------\n\nTITLE: Accessing Int-Literal Attributes\nDESCRIPTION: Demonstrates how attributes on int literals are delegated to builtins.int, with methods and properties properly typed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nreveal_type((2).bit_length)  # revealed: bound method Literal[2].bit_length() -> int\nreveal_type((2).denominator)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Any Non-callable Variant in Function Union\nDESCRIPTION: Shows the error when one variant in a union is not callable, demonstrating how the type checker prioritizes the non-callable error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f1(a: int): ...\ndef _(flag: bool):\n    if flag:\n        f = f1\n    else:\n        f = \"This is a string literal\"\n\n    # error: [call-non-callable] \"Object of type `Literal[\\\"This is a string literal\\\"]` is not callable\"\n    x = f(3)\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Using lint: Prefix in Error Codes in Python\nDESCRIPTION: Demonstrates that using the lint: prefix for error codes is not supported and results in an unknown-rule error with a suggestion for the correct code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# error:[unknown-rule] \"Unknown rule `lint:division-by-zero`. Did you mean `division-by-zero`?\"\n# error: [division-by-zero]\na = 10 / 0  # knot: ignore[lint:division-by-zero]\n```\n\n----------------------------------------\n\nTITLE: User-defined TYPE_CHECKING with Type Annotation\nDESCRIPTION: Demonstrates TYPE_CHECKING with explicit type annotation. Shows conditional execution and type inference behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nTYPE_CHECKING: bool = False\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\nif TYPE_CHECKING:\n    type_checking = True\nif not TYPE_CHECKING:\n    runtime = True\n\nreveal_type(type_checking)  # revealed: Literal[True]\n# error: [unresolved-reference]\nreveal_type(runtime)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Invalid Optional Usage Without Type Argument in Python\nDESCRIPTION: Shows the error that occurs when Optional is used without specifying a type argument. This is invalid as Optional requires exactly one type argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/optional.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\n# error: [invalid-type-form] \"`typing.Optional` requires exactly one argument when used in a type expression\"\ndef f(x: Optional) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Demonstrating type error when using float values with int annotations\nDESCRIPTION: Shows that the special case only works one way - a float value cannot be passed to a function expecting an int, nor assigned to a variable annotated as int.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/int_float_complex.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef takes_int(x: int):\n    pass\n\ndef passes_float_to_int(x: float):\n    # error: [invalid-argument-type]\n    takes_int(x)\n\ndef assigns_float_to_int(x: float):\n    # error: [invalid-assignment]\n    y: int = x\n```\n\n----------------------------------------\n\nTITLE: Testing Ellipsis Type as Singleton in Python 3.9\nDESCRIPTION: Tests that the type of Ellipsis and ellipsis literal (...) are recognized as singleton types in Python 3.9, even though the type is not exposed directly in the standard library.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_singleton, static_assert\n\nstatic_assert(is_singleton(Ellipsis.__class__))\nstatic_assert(is_singleton((...).__class__))\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Modules in Python\nDESCRIPTION: Demonstrates type inference when applying 'not' to module objects, showing that modules are always considered truthy, resulting in Literal[False].\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport b\nimport warnings\n\nreveal_type(not b)  # revealed: Literal[False]\nreveal_type(not warnings)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Fuzzer Command\nDESCRIPTION: Command to execute a specific fuzzer with a timeout parameter. The -s none flag disables sanitizers, though this must be omitted for Apple M1 devices using nightly compiler.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/fuzz/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo fuzz run -s none name_of_fuzzer -- -timeout=1\n```\n\n----------------------------------------\n\nTITLE: Illegal Type Parameters Example\nDESCRIPTION: Shows invalid usage of type[] with multiple parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\nclass B: ...\n\n# error: [invalid-type-form]\n_: type[A, B]\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of typing.Union in Python\nDESCRIPTION: Shows an invalid usage of typing.Union when no type arguments are provided, resulting in a type checking error. The Union type requires at least one type argument.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/union.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\n# error: [invalid-type-form] \"`typing.Union` requires at least one argument when used in a type expression\"\ndef f(x: Union) -> None:\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Indirect Cyclic Inheritance\nDESCRIPTION: Shows behavior with indirect cycles in class inheritance chains.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Foo(Bar): ...\nclass Bar(Baz): ...\nclass Baz(Foo): ...\n\nreveal_type(Foo.__mro__)\nreveal_type(Bar.__mro__)\nreveal_type(Baz.__mro__)\n```\n\n----------------------------------------\n\nTITLE: For Loop with OS Variable Shadowing\nDESCRIPTION: Shows a for loop that shadows the previously imported 'os' module name by using it as a loop variable. This is generally considered a bad practice as it makes the original os module inaccessible.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pyflakes/F402.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfor os in range(3):\n    pass\n```\n\n----------------------------------------\n\nTITLE: F-String Expressions\nDESCRIPTION: Demonstrates f-string usage with and without semicolons and comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nf\"x = {x}\"\n```\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nf\"x = {x}\";\nf\"x = {x}\";  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Tuple Parenthesization in For Loops: Ruff and Black\nDESCRIPTION: This snippet demonstrates the exception to the tuple parenthesization rule in `for` loops. Both Ruff and Black avoid inserting unnecessary parentheses in `for` loops.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Input\nfor a, [b, d,] in c:\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\nfor a, [\n    b,\n    d,\n] in c:\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\nfor a, [\n    b,\n    d,\n] in c:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Unbound Iterable Error Cases in Python\nDESCRIPTION: Shows error cases when using unbound iterables in comprehensions and type revelation behavior with undefined variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comprehensions/basic.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference] \"Name `x` used when not defined\"\n# revealed: Unknown\n[reveal_type(z) for z in x]\n\nclass IntIterator:\n    def __next__(self) -> int:\n        return 42\n\nclass IntIterable:\n    def __iter__(self) -> IntIterator:\n        return IntIterator()\n\n# error: [not-iterable] \"Object of type `int` is not iterable\"\n# revealed: tuple[int, Unknown]\n[reveal_type((x, z)) for x in IntIterable() for z in x]\n```\n\n----------------------------------------\n\nTITLE: Star Import in Nested Scope\nDESCRIPTION: Demonstrates that star imports in nested scopes are not allowed in Python. The type checker should emit a syntax error but currently doesn't detect this issue.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\n```\n\n----------------------------------------\n\nTITLE: Python Imports with Matplotlib Magic Command\nDESCRIPTION: Contains imports with a multi-line Jupyter notebook magic command for matplotlib, followed by additional module imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort_expected.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom pathlib import Path\n\n%matplotlib \\\n    --inline\n\nimport abc\nimport math\n```\n\n----------------------------------------\n\nTITLE: Updating Fix Representation in JSON API (Ruff)\nDESCRIPTION: Changes the representation of fixes in Ruff's JSON API from a single edit to a list of edits. This allows for fixes that require multiple edits across a file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"message\": \"Remove unused import: `sys`\",\n    \"content\": \"\",\n    \"location\": {\"row\": 1, \"column\": 0},\n    \"end_location\": {\"row\": 2, \"column\": 0}\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"message\": \"Remove unused import: `sys`\",\n    \"edits\": [\n        {\n            \"content\": \"\",\n            \"location\": {\"row\": 1, \"column\": 0},\n            \"end_location\": {\"row\": 2, \"column\": 0},\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Object Class Type Check\nDESCRIPTION: Shows type checking of the built-in object class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(object.__class__)  # revealed: Literal[type]\n```\n\n----------------------------------------\n\nTITLE: Conditional Formatting Consistency: Ruff\nDESCRIPTION: This snippet demonstrates that Ruff's formatting for single `with` items matches the formatting of other compound statements such as `if`.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef test():\n    if (\n        pyspark.sql.SparkSession.builder.config(\n            key=\"spark.python.worker.reuse\", value=True\n        )\n        .config(key=\"spark.ui.enabled\", value=False)\n        .master(\"local-cluster[2, 1, 1024]\")\n        .getOrCreate()\n    ):\n        # ignore spark log output\n        spark.sparkContext.setLogLevel(\"OFF\")\n        print(score_model(spark, data_path, model_uri))\n```\n\n----------------------------------------\n\nTITLE: Nested Expression Type Error Suppression in Python\nDESCRIPTION: Example demonstrating how `type: ignore` in nested expressions works differently between type checkers. In Pyright, a suppression in a child expression also suppresses errors in the outer expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import cast\n\ny = (\n    # error: [unsupported-operator]\n    cast(\n        int,\n        2 + \"test\",  # type: ignore\n    )\n    + \"other\"\n)\n```\n\n----------------------------------------\n\nTITLE: Dotted Relative Import in Python\nDESCRIPTION: This snippet demonstrates a dotted relative import from a nested subpackage.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom .foo.bar.baz import X\n\nreveal_type(X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unbound Typevars with Legacy Syntax in Python\nDESCRIPTION: This example demonstrates how unbound typevars should not appear in generic function bodies or class bodies apart from method definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\nS = TypeVar(\"S\")\n\ndef f(x: T) -> None:\n    x: list[T] = []\n    # TODO: error\n    y: list[S] = []\n\n# TODO: no error\n# error: [invalid-base]\nclass C(Generic[T]):\n    # TODO: error\n    x: list[S] = []\n\n    # This is not an error, as shown in the previous test\n    def m(self, x: S) -> S:\n        return x\n```\n\n----------------------------------------\n\nTITLE: Benchmark-driven Development with Criterion.rs\nDESCRIPTION: Use Criterion.rs to compare benchmark results against a saved baseline, useful for tracking performance changes during development.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n# Run once on your \"baseline\" code\ncargo bench -p ruff_benchmark -- --save-baseline=main\n\n# Then iterate with\ncargo bench -p ruff_benchmark -- --baseline=main\n```\n\n----------------------------------------\n\nTITLE: Wrong Position Dunder Methods\nDESCRIPTION: Demonstrates behavior when dunder methods are implemented but in incorrect positions for the operation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __add__(self, other) -> int:\n        return 1\n\nclass B:\n    def __radd__(self, other) -> int:\n        return 1\n\nclass C: ...\n\n# error: [unsupported-operator]\n# revealed: Unknown\nreveal_type(C() + A())\n\n# error: [unsupported-operator]\n# revealed: Unknown\nreveal_type(B() + C())\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Functions in Python\nDESCRIPTION: This snippet demonstrates defining multiple functions in Python. It includes a potential style issue (E302) related to blank lines between function definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# E302\ndef a():\n    pass\n\ndef b():\n    pass\n# end\n```\n\n----------------------------------------\n\nTITLE: Combined Version and Platform Analysis Configuration\nDESCRIPTION: Configuration for combined platform and version-based branch analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\npython-platform = \"darwin\"\n```\n\n----------------------------------------\n\nTITLE: Custom Random Magic Command with Python Import\nDESCRIPTION: Custom magic command '%%random' that contains an import statement for the pathlib module. The comment indicates this cell might be ignored during execution.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command_expected.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%%random\n# This cell is ignored\nimport pathlib\n```\n\n----------------------------------------\n\nTITLE: Metaclass Attribute Access Without Shadowing\nDESCRIPTION: Demonstrates how metaclass attributes and non-data descriptors are accessible when not shadowed by class-level attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Meta4(type):\n    meta_attribute: Literal[\"value on metaclass\"] = \"value on metaclass\"\n    meta_non_data_descriptor: NonDataDescriptor = NonDataDescriptor()\n\nclass C4(metaclass=Meta4): ...\n\nreveal_type(C4.meta_attribute)  # revealed: Literal[\"value on metaclass\"]\nreveal_type(C4.meta_non_data_descriptor)  # revealed: Literal[\"non-data\"]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Non-Matching Match Statement in Python\nDESCRIPTION: Shows type analysis for a match statement where the scrutinee is statically known not to match any pattern. The variable 'x' remains unchanged with value 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n\nmatch \"something else\":\n    case \"a\":\n        x = 2\n    case \"b\":\n        x = 3\n\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'while False' with 'break' and 'else' in Python\nDESCRIPTION: Demonstrates type analysis for a while loop with an always-false condition, a break statement, and an else clause. The else block is executed, resulting in 'x' having the value 4.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nwhile False:\n    x = 2\n    break\n    x = 3\nelse:\n    x = 4\n\nreveal_type(x)  # revealed: Literal[4]\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Class MRO - No Base Class\nDESCRIPTION: Tests type inference for a simple class with no explicit base class\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: False Negative: Built-ins with Implicit Layouts\nDESCRIPTION: Demonstrates a case where incompatibility between built-in types with implicit slot layouts is not detected by the static analyzer, despite potential issues at runtime.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# False negative: [incompatible-slots]\nclass A(int, str): ...\n```\n\n----------------------------------------\n\nTITLE: Importing Possibly Undeclared Variables in Python\nDESCRIPTION: This snippet demonstrates importing a possibly undeclared variable. It shows how the declared type is still available for the imported variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom maybe_undeclared import x\n\nreveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Basic Method Calls on Class Objects and Instances in Python\nDESCRIPTION: Demonstrates method calls on base and derived classes, showing type inference and error detection for invalid arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def method_on_base(self, x: int | None) -> str:\n        return \"a\"\n\nclass Derived(Base):\n    def method_on_derived(self, x: bytes) -> tuple[int, str]:\n        return (1, \"a\")\n\nreveal_type(Base().method_on_base(1))  # revealed: str\nreveal_type(Base.method_on_base(Base(), 1))  # revealed: str\n\nBase().method_on_base(\"incorrect\")  # error: [invalid-argument-type]\nBase().method_on_base()  # error: [missing-argument]\nBase().method_on_base(1, 2)  # error: [too-many-positional-arguments]\n\nreveal_type(Derived().method_on_base(1))  # revealed: str\nreveal_type(Derived().method_on_derived(b\"abc\"))  # revealed: tuple[int, str]\nreveal_type(Derived.method_on_base(Derived(), 1))  # revealed: str\nreveal_type(Derived.method_on_derived(Derived(), b\"abc\"))  # revealed: tuple[int, str]\n```\n\n----------------------------------------\n\nTITLE: Unsupported File-level Suppression Comments in Python\nDESCRIPTION: Demonstrates that file-level suppression comments are intentionally unsupported, resulting in unused-ignore-comment warnings and errors still being reported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# error: [unused-ignore-comment]\n# knot: ignore[division-by-zero]\n\na = 4 / 0  # error: [division-by-zero]\n```\n\n----------------------------------------\n\nTITLE: Enum classes type checking in Python\nDESCRIPTION: This code demonstrates the current lack of support for enum classes in the type checker. Accessing attributes on an enum class results in the inferred type being `@Todo(Attribute access on enum classes)`. The example defines a simple enum `Foo` with a member `BAR` to illustrate this limitation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n```py\nimport enum\n\nreveal_type(enum.Enum.__members__)  # revealed: @Todo(Attribute access on enum classes)\n\nclass Foo(enum.Enum):\n    BAR = 1\n\nreveal_type(Foo.BAR)  # revealed: @Todo(Attribute access on enum classes)\nreveal_type(Foo.BAR.value)  # revealed: @Todo(Attribute access on enum classes)\nreveal_type(Foo.__members__)  # revealed: @Todo(Attribute access on enum classes)\n```\n```\n\n----------------------------------------\n\nTITLE: Using AlwaysTruthy and AlwaysFalsy Types in Python\nDESCRIPTION: Demonstrates the special types representing objects with known truthiness. Shows subtype testing and error handling when used with type parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal\n\nfrom knot_extensions import AlwaysFalsy, AlwaysTruthy, is_subtype_of, static_assert\n\nstatic_assert(is_subtype_of(Literal[True], AlwaysTruthy))\nstatic_assert(is_subtype_of(Literal[False], AlwaysFalsy))\n\nstatic_assert(not is_subtype_of(int, AlwaysFalsy))\nstatic_assert(not is_subtype_of(str, AlwaysFalsy))\n\ndef _(t: AlwaysTruthy, f: AlwaysFalsy):\n    reveal_type(t)  # revealed: AlwaysTruthy\n    reveal_type(f)  # revealed: AlwaysFalsy\n\ndef f(\n    a: AlwaysTruthy[int],  # error: [invalid-type-form]\n    b: AlwaysFalsy[str],  # error: [invalid-type-form]\n):\n    reveal_type(a)  # revealed: Unknown\n    reveal_type(b)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Functions with Potential E306 Issue in Python\nDESCRIPTION: This snippet shows how to define nested functions in Python. It includes a potential style issue (E306) related to blank lines before nested function definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# E306:3:5\ndef a():\n    x = 1\n    def b():\n        pass\n# end\n```\n\n----------------------------------------\n\nTITLE: Cross-File Invalid Argument Test\nDESCRIPTION: Tests invalid argument type detection across different files using package imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x: int) -> int:\n    return x * x\n```\n\nLANGUAGE: python\nCODE:\n```\nimport package\n\npackage.foo(\"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Comparison Expression in Conditional Block\nDESCRIPTION: A comparison expression nested inside a conditional block, demonstrating that context matters when evaluating expressions. This shows that the same expression may not trigger B018 when properly used in a control structure.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Nested expressions isn't relevant\nif True:\n    x == 1\n```\n\n----------------------------------------\n\nTITLE: Failed Deferred Annotations in Regular Python Code\nDESCRIPTION: Shows how annotations in regular Python files are not deferred by default, causing unresolved reference errors when forward references are used. Also demonstrates that improper __future__ imports don't enable deferred annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import with_statement as annotations\n\n# error: [unresolved-reference]\ndef get_foo() -> Foo: ...\n\nclass Foo: ...\n\nreveal_type(get_foo())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Defining an Integer Value in Python\nDESCRIPTION: A simple Python snippet defining the integer value 1. This is a basic literal value that could be used as a variable initialization or for demonstration purposes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pyflakes/F821_22.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n1\n```\n\n----------------------------------------\n\nTITLE: Using Optional from typing_extensions in Python\nDESCRIPTION: Demonstrates using Optional from the typing_extensions module instead of the standard typing module, with the same behavior where Optional[int] is interpreted as int | None.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/optional.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Optional\n\na: Optional[int]\n\ndef f():\n    # revealed: int | None\n    reveal_type(a)\n```\n\n----------------------------------------\n\nTITLE: Testing Equivalence of Callable Types with Different Parameter Names\nDESCRIPTION: This code demonstrates that callable types with different parameter names for positional-only, variadic, and keyword-variadic parameters are still equivalent. The names of these special parameters don't affect type equivalence.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef f3(a1: int, /, *args1: int, **kwargs2: int) -> None: ...\ndef f4(a2: int, /, *args2: int, **kwargs1: int) -> None: ...\n\nstatic_assert(is_equivalent_to(CallableTypeOf[f3], CallableTypeOf[f4]))\nstatic_assert(is_equivalent_to(CallableTypeOf[f3] | bool | CallableTypeOf[f4], CallableTypeOf[f4] | bool | CallableTypeOf[f3]))\n```\n\n----------------------------------------\n\nTITLE: Reveal Type Definition in PYI File\nDESCRIPTION: This PYI file defines the reveal_type function used for type revelation in the examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_4\n\nLANGUAGE: pyi\nCODE:\n```\ndef reveal_type(obj, /): ...\n```\n\n----------------------------------------\n\nTITLE: Running Ruff from Command Line\nDESCRIPTION: Demonstrates how to run Ruff for linting and formatting after installation, using the command line interface.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ ruff check   # Lint all files in the current directory.\n$ ruff format  # Format all files in the current directory.\n```\n\n----------------------------------------\n\nTITLE: Overridden TOML Configuration\nDESCRIPTION: Demonstrates overwriting the global Python version configuration in a child section to 3.11.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment in Python\nDESCRIPTION: A simple variable assignment setting x to the integer value 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n```\n\n----------------------------------------\n\nTITLE: Running Red Knot with profiling enabled\nDESCRIPTION: Command to run Red Knot with profiling enabled, which generates a folded stack trace file for performance analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nRED_KNOT_LOG_PROFILE=1 red_knot -- --current-directory=../test -vvv\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in Python\nDESCRIPTION: This snippet defines a simple function 'f' with no implementation. It's used in the following reimport examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(): ...\n```\n\n----------------------------------------\n\nTITLE: Nested Class Literal Type Usage\nDESCRIPTION: Shows how to use type[] with nested class definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    class B: ...\n\ndef f(c: type[A.B]):\n    reveal_type(c)  # revealed: type[B]\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Environment with TOML in Markdown\nDESCRIPTION: This snippet demonstrates how to use a TOML-based configuration within a Markdown file to set up the test environment. It specifies the Python version to be used for the tests.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Importing Unbound Symbol in Python\nDESCRIPTION: This snippet demonstrates an attempt to import an unbound symbol, resulting in errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom .foo import x  # error: [unresolved-import]\n\nreveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Never Type Iterability in Python\nDESCRIPTION: Tests type inference when iterating over a value of the Never type. The system should infer that the element type is also Never, representing unreachable code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Never\n\ndef f(never: Never):\n    for x in never:\n        reveal_type(x)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Invalid Inheritance with Unparameterized Annotated Type in Python\nDESCRIPTION: This snippet demonstrates an invalid inheritance case where Annotated is not parameterized, resulting in a runtime error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Annotated\n\n# At runtime, this is an error.\n# error: [invalid-base]\nclass C(Annotated): ...\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Unknown, Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Ruff Against Other Linting Tools\nDESCRIPTION: Compare Ruff's performance against other popular Python linting tools like Pyflakes, Autoflake, Pycodestyle, and Flake8.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nhyperfine --ignore-failure --warmup 5 \\\n  \"./target/release/ruff check ./crates/ruff_linter/resources/test/cpython/ --no-cache\" \\\n  \"pyflakes crates/ruff_linter/resources/test/cpython\" \\\n  \"autoflake --recursive --expand-star-imports --remove-all-unused-imports --remove-unused-variables --remove-duplicate-keys resources/test/cpython\" \\\n  \"pycodestyle crates/ruff_linter/resources/test/cpython\" \\\n  \"flake8 crates/ruff_linter/resources/test/cpython\"\n```\n\n----------------------------------------\n\nTITLE: Custom Typeshed Configuration\nDESCRIPTION: TOML configuration for custom typeshed path.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Calling a Function in Python\nDESCRIPTION: This snippet demonstrates how to call a previously defined function in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfn()\n```\n\n----------------------------------------\n\nTITLE: Variadic Arguments Test\nDESCRIPTION: Tests invalid argument type detection with variadic arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef foo(*numbers: int) -> int:\n    return len(numbers)\n\nfoo(1, 2, 3, \"hello\", 5)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Empty Python Code Cell\nDESCRIPTION: This is an empty Python code cell. It contains no executable code and serves as a placeholder or separator in the document.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/valid.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Analyzing Type Inference in Try-Except Block with Multiple Except Clauses\nDESCRIPTION: This snippet shows type inference in a try-except block with multiple except clauses. It demonstrates how the final inferred type is a union of types from all possible execution paths.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef could_raise_returns_str() -> str:\n    return \"foo\"\n\nx = 1\n\ntry:\n    reveal_type(x)  # revealed: Literal[1]\n    x = could_raise_returns_str()\n    reveal_type(x)  # revealed: str\nexcept TypeError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 2\n    reveal_type(x)  # revealed: Literal[2]\nexcept ValueError:\n    reveal_type(x)  # revealed: Literal[1] | str\n    x = 3\n    reveal_type(x)  # revealed: Literal[3]\n\nreveal_type(x)  # revealed: str | Literal[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Accessing sys.version_info Named Fields\nDESCRIPTION: Shows type revelations when accessing sys.version_info fields by name\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info.major >= 3)  # revealed: Literal[True]\nreveal_type(sys.version_info.minor >= 9)  # revealed: Literal[True]\nreveal_type(sys.version_info.minor >= 10)  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Unbound Variable with 'if False' in Python\nDESCRIPTION: Shows how variables defined only in unreachable code paths are considered unbound. Attempting to access 'x' results in an unresolved reference error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    x = 1\n\n# error: [unresolved-reference]\nx\n```\n\n----------------------------------------\n\nTITLE: Target Union with Multiple Type Possibilities\nDESCRIPTION: Demonstrates type checking with union types as targets for augmented assignment operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class Foo:\n        def __iadd__(self, other: int) -> str:\n            return \"Hello, world!\"\n\n    if flag:\n        f = Foo()\n    else:\n        f = 42\n    f += 12\n\n    reveal_type(f)  # revealed: str | Literal[54]\n```\n\n----------------------------------------\n\nTITLE: Unused Suppression Comment in Python\nDESCRIPTION: Demonstrates what happens when a knot: ignore directive is used for an error that doesn't occur on that line, resulting in an unused-ignore-comment error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntest = 10\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'possibly-unresolved-reference'\"\na = test + 3  # knot: ignore[possibly-unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Using Await in a Class Definition in Python\nDESCRIPTION: This snippet demonstrates using 'await' directly inside a class definition. This causes a SyntaxError as 'await' can only be used inside functions, not in class bodies.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/await_scope.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass _:\n    await 1  # SyntaxError: await outside function\n```\n\n----------------------------------------\n\nTITLE: Helix Editor Ruff Configuration\nDESCRIPTION: TOML configuration for setting up Ruff language server in Helix editor with various settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[language-server.ruff]\ncommand = \"ruff\"\nargs = [\"server\"]\n\n[language-server.ruff.config.settings]\nlineLength = 80\n\n[language-server.ruff.config.settings.lint]\nselect = [\"E4\", \"E7\"]\npreview = false\n\n[language-server.ruff.config.settings.format]\npreview = true\n```\n\n----------------------------------------\n\nTITLE: Custom Magic Command with Pathlib Import in Python\nDESCRIPTION: This snippet demonstrates a custom %%random magic command with a commented-out import of the pathlib module. Note that this cell would be ignored in typical Jupyter notebook execution.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%%random\n# This cell is ignored\nimport pathlib\n```\n\n----------------------------------------\n\nTITLE: Invalid Boolean Conversion Analysis\nDESCRIPTION: Shows type checking for objects with incorrectly implemented __bool__ methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\nif NotBoolable():\n    ...\n# error: [unsupported-bool-conversion] \"Boolean conversion is unsupported for type `NotBoolable`; its `__bool__` method isn't callable\"\nelif NotBoolable():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Handling Nested Scopes in Unreachable Code in Python\nDESCRIPTION: Demonstrates how diagnostics are suppressed for nested function and class definitions inside unreachable code blocks. Even though the code is unreachable, no diagnostics are emitted for variables defined in the outer scope used within these nested definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    x = 1\n\n    def f():\n        print(x)\n\n    class C:\n        def __init__(self):\n            print(x)\n```\n\n----------------------------------------\n\nTITLE: Unknown Rule in knot: ignore Directive in Python\nDESCRIPTION: Shows that using an unknown rule name in a knot: ignore directive results in an unknown-rule error rather than suppressing any errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# error: [unknown-rule] \"Unknown rule `is-equal-14`\"\na = 10 + 4  # knot: ignore[is-equal-14]\n```\n\n----------------------------------------\n\nTITLE: Invalid str() Function Calls\nDESCRIPTION: Shows invalid str() function calls with incorrect arguments and invalid encodings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/builtins.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nstr(1, 2)  # error: [no-matching-overload]\nstr(o=1)  # error: [no-matching-overload]\n\n# First argument is not a bytes-like object:\nstr(\"Müsli\", \"utf-8\")  # error: [no-matching-overload]\n\n# Second argument is not a valid encoding:\nstr(b\"M\\xc3\\xbcsli\", b\"utf-8\")  # error: [no-matching-overload]\n```\n\n----------------------------------------\n\nTITLE: Invalid Callable Object Error in Python\nDESCRIPTION: Demonstrates an error when trying to call a non-callable object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnonsense = 123\nx = nonsense()  # error: \"Object of type `Literal[123]` is not callable\"\n```\n\n----------------------------------------\n\nTITLE: Testing NotImplemented Type as Singleton in Python 3.9\nDESCRIPTION: Tests that the type of NotImplemented is recognized as a singleton type in Python 3.9, even though the type is not directly exposed in the standard library.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_singleton.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_singleton, static_assert\n\nstatic_assert(is_singleton(NotImplemented.__class__))\n```\n\n----------------------------------------\n\nTITLE: Invalid Subclassing of LiteralString in Python\nDESCRIPTION: Shows that LiteralString cannot be used as a base class for inheritance, resulting in an invalid-base error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\nclass C(LiteralString): ...  # error: [invalid-base]\n```\n\n----------------------------------------\n\nTITLE: Module with Conditionally Mutated __all__ for Python 3.10\nDESCRIPTION: Same module with conditionally mutated __all__ as before, but will be interpreted for Python 3.10 environment. The else branch will be selected, adding Z to __all__.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\n__all__ = []\nX: bool = True\n\nif sys.version_info >= (3, 11):\n    __all__.extend([\"X\", \"Y\"])\n    Y: bool = True\nelse:\n    __all__.append(\"Z\")\n    Z: bool = True\n```\n\n----------------------------------------\n\nTITLE: Defining an Async Generator Function in Python\nDESCRIPTION: A simple async generator function that yields a single value. This function is used as the async iterable in the following examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/async_comprehension.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def elements(n): yield n\n```\n\n----------------------------------------\n\nTITLE: Derived Class Classmethod Binding\nDESCRIPTION: Demonstrates how classmethods bind to derived classes and their instances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nclass Derived(C):\n    pass\n\nreveal_type(Derived.f)  # revealed: bound method Literal[Derived].f(x: int) -> str\nreveal_type(Derived().f)  # revealed: bound method type[Derived].f(x: int) -> str\n\nreveal_type(Derived.f(1))  # revealed: str\nreveal_type(Derived().f(1))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Opening Parenthesis Type Error Suppression in Python\nDESCRIPTION: Example showing a suppression that applies to errors before the opening parenthesis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na: Test = (  # type: ignore\n  Test()  # error: [unresolved-reference]\n)  # fmt: skip\n```\n\n----------------------------------------\n\nTITLE: Recommended Ruff Rule Configuration\nDESCRIPTION: Comprehensive TOML configuration example showing recommended rule selections for common use cases\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nselect = [\n    # pycodestyle\n    \"E\",\n    # Pyflakes\n    \"F\",\n    # pyupgrade\n    \"UP\",\n    # flake8-bugbear\n    \"B\",\n    # flake8-simplify\n    \"SIM\",\n    # isort\n    \"I\",\n]\n```\n\n----------------------------------------\n\nTITLE: Correct Case Import Usage\nDESCRIPTION: Demonstration of successful import with correct casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom a import Foo\n\nreveal_type(Foo().x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment in Python\nDESCRIPTION: Assigns the integer value 6 to a variable named colors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/undefined_name.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncolors = 6\n```\n\n----------------------------------------\n\nTITLE: Configuring noqa Suppression for Jupyter Notebooks\nDESCRIPTION: TOML configuration example showing how to disable specific linting rules for Jupyter Notebook files using the per-file-ignores setting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint.per-file-ignores]\n\"*.ipynb\" = [\"E501\"] # disable line-too-long in notebooks\n```\n\n----------------------------------------\n\nTITLE: Simple knot: ignore Suppression in Python\nDESCRIPTION: Demonstrates the basic usage of knot: ignore to suppress any type check error on a line without specifying an error code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = 4 + test  # knot: ignore\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Callable Behavior of Never Type in Python\nDESCRIPTION: This code snippet illustrates that the Never type can be called with any number and type of arguments, always resulting in a Never type. It uses the reveal_type function to show the inferred type of different calls to a Never instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/never.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Never\n\ndef f(never: Never):\n    reveal_type(never())  # revealed: Never\n    reveal_type(never(1))  # revealed: Never\n    reveal_type(never(1, \"a\", never, x=None))  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Error in Python Assignment\nDESCRIPTION: This Python snippet shows an invalid assignment where a string is assigned to a variable annotated as an integer. It's used to demonstrate how type errors are reported in the test framework.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx: int = \"foo\"  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Case Import Usage\nDESCRIPTION: Example of failed import due to incorrect casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom a import Foo\n```\n\n----------------------------------------\n\nTITLE: Imported Type Revelation Test\nDESCRIPTION: Shows how to use reveal_type with explicit import from typing module\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import reveal_type\n\nreveal_type(\"foo\")  # revealed: Literal[\"foo\"]\n```\n\n----------------------------------------\n\nTITLE: Conditionally Mutated __all__ in Python 3.10\nDESCRIPTION: Environment configuration for Python 3.10, which affects how conditionally mutated __all__ will be resolved in subsequent code examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_19\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: CST Output Example Using LibCST\nDESCRIPTION: Example output from 'cargo dev print-cst' command showing the Concrete Syntax Tree representation including whitespace and comments using LibCST parser.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nModule {\n    body: [\n        Compound(\n            If(\n                If {\n                    test: Name(\n                        Name {\n                            value: \"True\",\n                            lpar: [],\n                            rpar: [],\n                        },\n                    ),\n                    body: SimpleStatementSuite(\n                        SimpleStatementSuite {\n                            body: [\n                                Pass(\n                                    Pass {\n                                        semicolon: None,\n                                    },\n                                ),\n                            ],\n                            leading_whitespace: SimpleWhitespace(\n                                \" \",\n                            ),\n                            trailing_whitespace: TrailingWhitespace {\n                                whitespace: SimpleWhitespace(\n                                    \" \",\n                                ),\n                                comment: Some(\n                                    Comment(\n                                        \"# comment\",\n                                    ),\n                                ),\n                                newline: Newline(\n                                    None,\n                                    Real,\n                                ),\n                            },\n                        },\n                    ),\n                    orelse: None,\n                    leading_lines: [],\n                    whitespace_before_test: SimpleWhitespace(\n                        \" \",\n                    ),\n                    whitespace_after_test: SimpleWhitespace(\n                        \"\",\n                    ),\n                    is_elif: false,\n                },\n            ),\n        ),\n    ],\n    header: [],\n    footer: [],\n    default_indent: \"    \",\n    default_newline: \"\\n\",\n    has_trailing_newline: true,\n    encoding: \"utf-8\",\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Function Literal Operations\nDESCRIPTION: Shows that operator operations are not supported between function objects. Tests various operators with function literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    pass\n\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `def f() -> Unknown` and `def f() -> Unknown`\"\nreveal_type(f + f)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `-` is unsupported between objects of type `def f() -> Unknown` and `def f() -> Unknown`\"\nreveal_type(f - f)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `*` is unsupported between objects of type `def f() -> Unknown` and `def f() -> Unknown`\"\nreveal_type(f * f)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `@` is unsupported between objects of type `def f() -> Unknown` and `def f() -> Unknown`\"\nreveal_type(f @ f)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Addition with Single Newline\nDESCRIPTION: Basic addition operation followed by a single newline.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n1+1\n\n\n```\n\n----------------------------------------\n\nTITLE: Excluding Jupyter Notebooks from Ruff Formatting\nDESCRIPTION: TOML configuration example showing how to exclude Jupyter Notebook files from only the formatting functionality while still enabling linting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/BREAKING_CHANGES.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.format]\nexclude = [\"*.ipynb\"]\n```\n\n----------------------------------------\n\nTITLE: Using asyncio.sleep() in Python\nDESCRIPTION: This snippet shows different ways of using asyncio.sleep(), including valid top-level usage, usage within a conditional block, and an invalid usage inside a regular function. The last usage triggers a linting error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pylint/await_outside_async.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nawait asyncio.sleep(1)  # This is okay\n\nif True:\n    await asyncio.sleep(1)  # This is okay\n\ndef foo():\n    await asyncio.sleep(1)  # # [await-outside-async]\n```\n\n----------------------------------------\n\nTITLE: Testing Operator Behavior with Unrelated Classes\nDESCRIPTION: Shows how superclass regular dunders are used when operating with unrelated classes. Demonstrates type checking results for operations between Yes() and No() instances.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(Yes() + No())  # revealed: Literal[\"+\"]\nreveal_type(Yes() - No())  # revealed: Literal[\"-\"]\nreveal_type(Yes() * No())  # revealed: Literal[\"*\"]\nreveal_type(Yes() @ No())  # revealed: Literal[\"@\"]\nreveal_type(Yes() / No())  # revealed: Literal[\"/\"]\nreveal_type(Yes() % No())  # revealed: Literal[\"%\"]\nreveal_type(Yes() ** No())  # revealed: Literal[\"**\"]\nreveal_type(Yes() << No())  # revealed: Literal[\"<<\"]\nreveal_type(Yes() >> No())  # revealed: Literal[\">>\"]\nreveal_type(Yes() | No())  # revealed: Literal[\"|\"]\nreveal_type(Yes() ^ No())  # revealed: Literal[\"^\"]\nreveal_type(Yes() & No())  # revealed: Literal[\"&\"]\nreveal_type(Yes() // No())  # revealed: Literal[\"//\"]\n```\n\n----------------------------------------\n\nTITLE: Importing _typeshed Types in Implementation Files\nDESCRIPTION: Shows how to properly import types from _typeshed in .py files using TYPE_CHECKING conditional to prevent runtime imports.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/vendor/typeshed/stdlib/_typeshed/README.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from _typeshed import ...\n```\n\n----------------------------------------\n\nTITLE: Relative Import with Unknown Nested Module in Python\nDESCRIPTION: This example demonstrates the error when attempting to import from a non-existent nested module using relative import. It shows how Ruff handles multi-level relative imports to non-existent modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom .does_not_exist.foo.bar import add  # error: [unresolved-import]\n\nstat = add(10, 15)\n```\n\n----------------------------------------\n\nTITLE: Importing Modules and Accessing Mathematical Constant in Python\nDESCRIPTION: This code snippet imports the math and os modules, and then accesses the pi constant from the math module. It demonstrates basic module importing and constant usage in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/before_fix.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\nimport os\n\nmath.pi\n```\n\n----------------------------------------\n\nTITLE: Setting Import Strategy for Ruff in VS Code\nDESCRIPTION: Specifies the strategy for loading the 'ruff' executable in VS Code. Can be set to 'fromEnvironment' or 'useBundled'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.importStrategy\": \"useBundled\"\n}\n```\n\n----------------------------------------\n\nTITLE: Version Info Branch Analysis Configuration\nDESCRIPTION: Configuration for Python version-based branch analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Testing Truthiness with Static Assertions in Python\nDESCRIPTION: Shows how static_assert handles various truthiness cases for different Python types, including literals, empty collections, and strings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert\n\nstatic_assert(True)\nstatic_assert(False)  # error: \"Static assertion error: argument evaluates to `False`\"\n\nstatic_assert(None)  # error: \"Static assertion error: argument of type `None` is statically known to be falsy\"\n\nstatic_assert(1)\nstatic_assert(0)  # error: \"Static assertion error: argument of type `Literal[0]` is statically known to be falsy\"\n\nstatic_assert((0,))\nstatic_assert(())  # error: \"Static assertion error: argument of type `tuple[()]` is statically known to be falsy\"\n\nstatic_assert(\"a\")\nstatic_assert(\"\")  # error: \"Static assertion error: argument of type `Literal[\"\"]` is statically known to be falsy\"\n\nstatic_assert(b\"a\")\nstatic_assert(b\"\")  # error: \"Static assertion error: argument of type `Literal[b\"\"]` is statically known to be falsy\"\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Conditionally Defined __all__ in Python 3.10\nDESCRIPTION: Shows behavior when importing from a module with conditionally defined __all__ in Python 3.10. The type checker should recognize that Z is available but Y is not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\n# TODO: should reveal `Unknown` and emit `[unresolved-reference]`\nreveal_type(X)  # revealed: bool\n\n# error: [unresolved-reference]\nreveal_type(Y)  # revealed: Unknown\n\nreveal_type(Z)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Handling Positive and Negative Type Contributions in Python\nDESCRIPTION: Demonstrates simplification of intersections between positive types and negated disjoint types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\nfrom typing import Literal\n\ndef _(\n    i1: Intersection[Literal[1], Not[Literal[2]]],\n    i2: Intersection[Not[Literal[2]], Literal[1]],\n    i3: Intersection[Literal[1], Not[Literal[2]], int],\n    i4: Intersection[Literal[1], int, Not[Literal[2]]],\n    i5: Intersection[int, Literal[1], Not[Literal[2]]],\n) -> None:\n    reveal_type(i1)  # revealed: Literal[1]\n    reveal_type(i2)  # revealed: Literal[1]\n    reveal_type(i3)  # revealed: Literal[1]\n    reveal_type(i4)  # revealed: Literal[1]\n    reveal_type(i5)  # revealed: Literal[1]\n\ndef example_none(\n    i1: Intersection[int, Not[None]],\n    i2: Intersection[Not[None], int],\n) -> None:\n    reveal_type(i1)  # revealed: int\n    reveal_type(i2)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Potentially Unbound Function Error in Python\nDESCRIPTION: Shows an error when trying to call a potentially unbound function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/function.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        def foo() -> int:\n            return 42\n    # error: [possibly-unresolved-reference]\n    reveal_type(foo())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Testing Reveal Type\nDESCRIPTION: Python code demonstrating reveal_type functionality with custom typeshed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(())  # revealed: tuple[()]\n```\n\n----------------------------------------\n\nTITLE: Multi-line Error Assertion Test\nDESCRIPTION: Shows how to write error assertions on separate lines\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-assignment]\nx: str = 1\n```\n\n----------------------------------------\n\nTITLE: Testing Class with No __iter__ and Non-callable __getitem__ in Python\nDESCRIPTION: Tests type inference for a class that lacks an __iter__ method and has a non-callable __getitem__ attribute. This should be flagged as non-iterable with an unknown element type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\nclass Bad:\n    __getitem__: None = None\n\n# error: [not-iterable]\nfor x in Bad():\n    reveal_type(x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Invalid Use of TypeVar in Larger Expressions in Python\nDESCRIPTION: This example illustrates an incorrect usage of TypeVar, where it is used as part of a larger expression instead of being directly assigned to a variable. This is not allowed and should result in an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/legacy.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\n# TODO: error\nTestList = list[TypeVar(\"W\")]\n```\n\n----------------------------------------\n\nTITLE: Configuring ZMQ Shell Node Interactivity\nDESCRIPTION: Sets the configuration for ZMQInteractiveShell's AST node interactivity behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%config ZMQInteractiveShell.ast_node_interactivity=\"last_expr_or_assign\"\n```\n\n----------------------------------------\n\nTITLE: Nested String Type Annotation in Python\nDESCRIPTION: Shows a string type annotation with nested quotes. Even with the extra quotes, the type is correctly resolved to 'int'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/string.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f(v: \"'int'\"):\n    reveal_type(v)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Printing 'Hello world!' in Python\nDESCRIPTION: A simple Python print statement that outputs the string 'Hello world!' to the standard output. This is one of the most basic operations in Python programming and is often used as a first example when learning the language.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pydocstyle/D100.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Hello world!\")\n```\n\n----------------------------------------\n\nTITLE: Method Calls Test\nDESCRIPTION: Tests invalid argument type detection with bound method calls.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def square(self, x: int) -> int:\n        return x * x\n\nc = C()\nc.square(\"hello\")  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Cyclic Star Import Module A\nDESCRIPTION: First module in a cyclic star import example. Module a imports all from b and defines A. This would normally cause an infinite import loop but Python allows it.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom b import *\n\nA: bool = True\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Excessive Blank Lines in Python\nDESCRIPTION: This snippet demonstrates defining a function in Python with excessive blank lines before it. It includes a potential style issue related to blank lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n\n\n\n\ndef fn():\n\tpass\n# end\n```\n\n----------------------------------------\n\nTITLE: Using Custom Builtin and Revealing Unknown Type in Python\nDESCRIPTION: This snippet demonstrates the use of a custom builtin symbol and reveals an unknown type for a standard builtin that is no longer accessible due to the custom typeshed configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(custom_builtin)  # revealed: Custom\n\n# error: [unresolved-reference]\nreveal_type(str)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Compatible Signatures with Error Handling\nDESCRIPTION: Shows a class implementation where __new__ accepts variable arguments while __init__ has strict parameter requirements. Includes error cases for missing and excess arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    def __new__(cls, *args, **kwargs):\n        return object.__new__(cls)\n\n    def __init__(self, x: int) -> None:\n        self.x = x\n\nreveal_type(Foo())  # revealed: Foo\nreveal_type(Foo(1))  # revealed: Foo\n\nreveal_type(Foo(1, 2))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Rust Helper Struct Implementation\nDESCRIPTION: Example implementation of a formatting helper struct in Rust\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub(crate) fn empty_parenthesized<'content>(\n    comments: &'content [SourceComment],\n    has_plus_prefix: bool,\n) -> FormatEmptyParenthesized<'content> {\n    FormatEmptyParenthesized {\n        comments,\n        has_plus_prefix,\n    }\n}\n\npub(crate) struct FormatEmptyParenthesized<'content> {\n    comments: &'content [SourceComment],\n    has_plus_prefix: bool,\n}\n\nimpl Format<PyFormatContext<'_>> for FormatEmptyParenthesized<'_> {\n    fn fmt(&self, f: &mut Formatter<PyFormatContext>) -> FormatResult<()> {\n        if self.has_plus_prefix {\n            text(\"+\").fmt(f)?\n        }\n        write!(\n            f,\n            [\n                text(\"(\"),\n                soft_block_indent(&dangling_comments(&self.comments)),\n                text(\")\")\n            ]\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Assertions Test\nDESCRIPTION: Demonstrates stacking multiple assertions for a single line\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-assignment]\n# revealed: Literal[1]\nx: str = reveal_type(1)\n```\n\n----------------------------------------\n\nTITLE: Various Invalid Star Import Syntaxes\nDESCRIPTION: Examples of various invalid star import syntax patterns. The type checker should handle these gracefully without crashing, while emitting appropriate syntax error diagnostics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *, _Y  # error: [invalid-syntax]\nfrom a import _Y, *, _Z  # error: [invalid-syntax]\nfrom a import *, _Y as fooo  # error: [invalid-syntax]\nfrom a import *, *, _Y  # error: [invalid-syntax]\n```\n\n----------------------------------------\n\nTITLE: Selecting Preview Rules in Ruff (CLI)\nDESCRIPTION: Command-line instruction to select specific preview rules in Ruff. This command extends the selected rule set with a hypothetical preview rule.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/preview.md#2025-04-17_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nruff check --extend-select HYP001\n```\n\n----------------------------------------\n\nTITLE: Metaclass Conflict Example 2\nDESCRIPTION: Demonstrates another conflict scenario with explicit metaclass specification.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass M1(type): ...\nclass M2(type): ...\nclass A(metaclass=M1): ...\n\n# error: [conflicting-metaclass]\nclass B(A, metaclass=M2): ...\n\nreveal_type(B.__class__)  # revealed: type[Unknown]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unresolved Import Statement in Python\nDESCRIPTION: This snippet shows an unresolved import statement and its effect on type checking. The import of 'bar' cannot be resolved, resulting in an error and unknown type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport bar  # error: \"Cannot resolve import `bar`\"\n\nreveal_type(bar)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Empty Submodule Definition\nDESCRIPTION: Content of a/b.py submodule (empty file)\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Dynamic Types Without Self-cancellation\nDESCRIPTION: Illustrates that dynamic types do not cancel each other out in intersections, as intersecting an unknown set with its negation is not necessarily empty.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom knot_extensions import Intersection, Not, Unknown\n\ndef any(\n    i1: Intersection[Any, Not[Any]],\n    i2: Intersection[Not[Any], Any],\n) -> None:\n    reveal_type(i1)  # revealed: Any\n    reveal_type(i2)  # revealed: Any\n\ndef unknown(\n    i1: Intersection[Unknown, Not[Unknown]],\n    i2: Intersection[Not[Unknown], Unknown],\n) -> None:\n    reveal_type(i1)  # revealed: Unknown\n    reveal_type(i2)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Assignment Expression\nDESCRIPTION: Demonstrates parenthesized assignment expressions with comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Parentheses with comments\n(\n    x := 1  # comment\n)  # comment\n```\n\nLANGUAGE: python\nCODE:\n```\n# Parentheses with comments\n(\n    x := 1  # comment\n);  # comment\n```\n\n----------------------------------------\n\nTITLE: Incorrect Descriptor Implementation\nDESCRIPTION: Shows an example of incorrectly implemented descriptor with missing parameters in __get__ method.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/descriptor_protocol.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass Descriptor:\n    # `__get__` method with missing parameters:\n    def __get__(self) -> int:\n        return 1\n\nclass C:\n    descriptor: Descriptor = Descriptor()\n```\n\n----------------------------------------\n\nTITLE: Installing Inferno for flamegraph generation\nDESCRIPTION: Command to install the Inferno tool, which is used to convert trace data into visual flamegraphs for performance analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncargo install inferno\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing and Exhaustiveness Checking with assert_never\nDESCRIPTION: Shows advanced usage of assert_never for type narrowing and exhaustiveness checking in conditional statements and pattern matching. Includes examples of both successful and erroneous implementations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_never.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_never, Literal\n\nclass A: ...\nclass B: ...\nclass C: ...\n\ndef if_else_isinstance_success(obj: A | B):\n    if isinstance(obj, A):\n        pass\n    elif isinstance(obj, B):\n        pass\n    elif isinstance(obj, C):\n        pass\n    else:\n        assert_never(obj)\n\ndef if_else_isinstance_error(obj: A | B):\n    if isinstance(obj, A):\n        pass\n    # B is missing\n    elif isinstance(obj, C):\n        pass\n    else:\n        # error: [type-assertion-failure] \"Expected type `Never`, got `B & ~A & ~C` instead\"\n        assert_never(obj)\n\ndef if_else_singletons_success(obj: Literal[1, \"a\"] | None):\n    if obj == 1:\n        pass\n    elif obj == \"a\":\n        pass\n    elif obj is None:\n        pass\n    else:\n        assert_never(obj)\n\ndef if_else_singletons_error(obj: Literal[1, \"a\"] | None):\n    if obj == 1:\n        pass\n    elif obj is \"A\":  # \"A\" instead of \"a\"\n        pass\n    elif obj is None:\n        pass\n    else:\n        # error: [type-assertion-failure] \"Expected type `Never`, got `Literal[\"a\"]` instead\"\n        assert_never(obj)\n\ndef match_singletons_success(obj: Literal[1, \"a\"] | None):\n    match obj:\n        case 1:\n            pass\n        case \"a\":\n            pass\n        case None:\n            pass\n        case _ as obj:\n            # TODO: Ideally, we would not emit an error here\n            # error: [type-assertion-failure] \"Expected type `Never`, got `@Todo\"\n            assert_never(obj)\n\ndef match_singletons_error(obj: Literal[1, \"a\"] | None):\n    match obj:\n        case 1:\n            pass\n        case \"A\":  # \"A\" instead of \"a\"\n            pass\n        case None:\n            pass\n        case _ as obj:\n            # TODO: We should emit an error here, but the message should\n            # show the type `Literal[\"a\"]` instead of `@Todo(…)`.\n            # error: [type-assertion-failure] \"Expected type `Never`, got `@Todo\"\n            assert_never(obj)\n```\n\n----------------------------------------\n\nTITLE: Non-literal Type Comparisons with sys.version_info\nDESCRIPTION: Shows type revelations when comparing sys.version_info with tuples of varying lengths\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info >= (3, 9, 1))  # revealed: bool\nreveal_type(sys.version_info >= (3, 9, 1, \"final\", 0))  # revealed: bool\n\nreveal_type(sys.version_info >= (3, 9, 1, \"final\", 0, 5))  # revealed: bool\n\nreveal_type(sys.version_info == (3, 8, 1, \"finallllll\", 0))  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Basic Type Revelation Test in Python\nDESCRIPTION: Demonstrates the simplest possible test case using reveal_type() to check type inference\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Union Type Version Configuration\nDESCRIPTION: TOML configuration for union type examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Running ruff-ecosystem format with format comparison\nDESCRIPTION: This command runs the ruff-ecosystem tool in format mode, comparing with changes to code that is already formatted. The `--format-comparison` flag specifies to do `ruff-then-ruff` comparison.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/ruff-ecosystem/README.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nruff-ecosystem format ruff \"./target/debug/ruff\" --format-comparison ruff-then-ruff\n```\n\n----------------------------------------\n\nTITLE: Using Simple Stub Package in Python\nDESCRIPTION: Demonstrates usage of the stubbed 'Foo' class with type revealing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import Foo\n\nreveal_type(Foo().name)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Failed Parser Test Example in Rust\nDESCRIPTION: Example showing how to write an inline test that verifies parser error handling using test_err format for invalid Python syntax.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// test_err this_is_the_test_name\n// [1, 2\nprintln!(\"some rust code\");\n```\n\n----------------------------------------\n\nTITLE: Invalid Matplotlib Magic Command Assignment in Python\nDESCRIPTION: Example showing incorrect usage of %matplotlib magic command being assigned to variables, both with and without type hints. This code would raise a syntax error as magic commands cannot be directly assigned to variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_project/resources/test/corpus/83_jupyter_notebook_ipython_magic.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    foo1 = %matplotlib --list\n    foo2: list[str] = %matplotlib --list\n```\n\n----------------------------------------\n\nTITLE: Suppressing unused-ignore-comment Warnings in Python\nDESCRIPTION: Demonstrates various ways to suppress the unused-ignore-comment warning itself, including combining it with other error codes and with type: ignore.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: [unused-ignore-comment]\na = 10 / 2  # knot: ignore[division-by-zero]\na = 10 / 2  # knot: ignore[division-by-zero, unused-ignore-comment]\na = 10 / 2  # knot: ignore[unused-ignore-comment, division-by-zero]\na = 10 / 2  # knot: ignore[unused-ignore-comment] # type: ignore\na = 10 / 2  # type: ignore # knot: ignore[unused-ignore-comment]\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Python-based Test Runner\nDESCRIPTION: This bash command shows how to use the Python-based test runner 'mdtest.py' to execute tests. This runner includes a watch mode for automatic test re-runs on file changes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nuv run crates/red_knot_python_semantic/mdtest.py\n```\n\n----------------------------------------\n\nTITLE: Float Type Inference\nDESCRIPTION: Demonstrates type inference for floating-point numbers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1.0)  # revealed: float\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Functions with Comments in Python\nDESCRIPTION: This snippet shows how to define nested functions in Python with comments. It includes a potential style issue (E303) related to excessive blank lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# E303\ndef fn():\n    _ = None\n\n\n    # arbitrary comment\n\n    def inner():  # E306 not expected (pycodestyle detects E306)\n        pass\n# end\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing Configuration\nDESCRIPTION: TOML configuration specifying Python version for type narrowing examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Building WASM Module in Release Mode\nDESCRIPTION: Command to build the WASM module in release mode to prevent stack overflow issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/playground/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run --workspace knot-playground build:wasm\n```\n\n----------------------------------------\n\nTITLE: Invalid Star Import with Additional Names\nDESCRIPTION: Demonstrates behavior when star import is combined with explicit imports in the same statement, which is invalid syntax. The type checker still attempts to resolve public names to minimize cascading errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *, _Y  # error: [invalid-syntax]\n\n# The import statement above is invalid syntax,\n# but it's pretty obvious that the user wanted to do a `*` import,\n# so we import all public names from `a` anyway, to minimize cascading errors\nreveal_type(X)  # revealed: bool\nreveal_type(_Y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Handling Never in Intersections in Python Type System\nDESCRIPTION: Demonstrates how intersections with Never type simplify to Never, regardless of other types involved, including dynamic types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\nfrom typing_extensions import Never, Any\n\nclass P: ...\nclass Q: ...\n\ndef _(\n    i1: Intersection[P, Never],\n    i2: Intersection[Never, P],\n    i3: Intersection[Any, Never],\n    i4: Intersection[Never, Not[Any]],\n) -> None:\n    reveal_type(i1)  # revealed: Never\n    reveal_type(i2)  # revealed: Never\n    reveal_type(i3)  # revealed: Never\n    reveal_type(i4)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: String Literal Handling\nDESCRIPTION: Shows string literal handling with and without semicolons and comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Hello world!\"\"\"\n```\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Hello world!\"\"\";  # comment\n# comment\n```\n\n----------------------------------------\n\nTITLE: Empty Python Module Definition\nDESCRIPTION: This snippet shows an empty Python module definition for 'a/__init__.py'. It's part of the context for the invalid nested module import example.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/invalid_syntax.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Call Chain Breaking: Ruff vs Black\nDESCRIPTION: This snippet demonstrates differences in how Ruff and Black break call chains. Black may expand arguments for the last call in the chain, while Ruff does so only if necessary to fit within the configured line width.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Input\ndf.drop(\n    columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]\n).drop_duplicates().rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(path / \"aaaaaa.csv\", index=False)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\ndf.drop(\n    columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]\n).drop_duplicates().rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(\n    path / \"aaaaaa.csv\", index=False\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\ndf.drop(\n    columns=[\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]\n).drop_duplicates().rename(\n    columns={\n        \"a\": \"a\",\n    }\n).to_csv(path / \"aaaaaa.csv\", index=False)\n```\n\n----------------------------------------\n\nTITLE: Configuring Format Exclusions for .pyi Files in ruff.toml\nDESCRIPTION: TOML configuration to exclude .pyi files from formatting while still including them in linting using ruff.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[format]\nexclude = [\"*.pyi\"]\n```\n\n----------------------------------------\n\nTITLE: Type Behavior with Non-singleton Types\nDESCRIPTION: Illustrates that type narrowing does not occur with non-singleton types, as identical values may have different memory addresses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/is_not.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = 345\ny = 345\n\nif x is not y:\n    reveal_type(x)  # revealed: Literal[345]\nelse:\n    reveal_type(x)  # revealed: Literal[345]\n```\n\n----------------------------------------\n\nTITLE: Comment with Multiple Newlines\nDESCRIPTION: Code block with a comment followed by multiple empty lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# a comment and some newlines\n\n\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Attribute and Dictionary Assignment\nDESCRIPTION: Demonstrates attribute access and dictionary assignment patterns with semicolons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Assignment statement where the left is an attribute access doesn't\n# print the value.\np.x = 1;\n```\n\nLANGUAGE: python\nCODE:\n```\ndata = {}\n\n# Neither does the subscript node\ndata[\"foo\"] = 1;\n```\n\n----------------------------------------\n\nTITLE: AST Output Example Using Ruff Python Parser\nDESCRIPTION: Example output from 'cargo dev print-ast' command showing the Abstract Syntax Tree representation of a simple Python if statement with comments. Demonstrates node structure with byte offsets.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n[\n    If(\n        StmtIf {\n            range: 0..13,\n            test: Constant(\n                ExprConstant {\n                    range: 3..7,\n                    value: Bool(\n                        true,\n                    ),\n                    kind: None,\n                },\n            ),\n            body: [\n                Pass(\n                    StmtPass {\n                        range: 9..13,\n                    },\n                ),\n            ],\n            orelse: [],\n        },\n    ),\n]\n```\n\n----------------------------------------\n\nTITLE: Testing Function Parameter Type Equivalence in Python\nDESCRIPTION: Shows that parameters with no annotations are treated as having the Any type for gradual equivalence purposes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef f2(a, b, /) -> None:\n    return\n\nstatic_assert(is_gradual_equivalent_to(CallableTypeOf[f2], Callable[[Any, Any], None]))\n```\n\n----------------------------------------\n\nTITLE: Profiling Ruff on Linux with perf\nDESCRIPTION: Use perf to profile Ruff's performance on Linux, generating data for flamegraph visualization.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench -p ruff_benchmark --no-run --profile=profiling && perf record --call-graph dwarf -F 9999 cargo bench -p ruff_benchmark --profile=profiling -- --profile-time=1\n```\n\n----------------------------------------\n\nTITLE: Invalid TYPE_CHECKING Assignments in Stub Files\nDESCRIPTION: Demonstrates invalid TYPE_CHECKING assignments and type annotations in stub files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: str\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: str = False\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: Literal[False] = ...\n\n# error: [invalid-type-checking-constant]\nTYPE_CHECKING: object = \"str\"\n```\n\n----------------------------------------\n\nTITLE: Referencing a Variable in Python\nDESCRIPTION: This snippet demonstrates referencing a previously defined variable in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsome_computation\n```\n\n----------------------------------------\n\nTITLE: Incorrect Extension Import Usage\nDESCRIPTION: Example of failed import due to incorrect file extension casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom a import Foo\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Never Type in Python\nDESCRIPTION: This code demonstrates that the Never type is disjoint from every type, including itself. This is because Never represents a type that has no values (i.e., it's impossible to create a value of type Never).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Never\nfrom knot_extensions import is_disjoint_from, static_assert\n\nstatic_assert(is_disjoint_from(Never, Never))\nstatic_assert(is_disjoint_from(Never, None))\nstatic_assert(is_disjoint_from(Never, int))\nstatic_assert(is_disjoint_from(Never, object))\n```\n\n----------------------------------------\n\nTITLE: Multi-file Import Test\nDESCRIPTION: Demonstrates testing across multiple files with imports\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom b import C\nreveal_type(C)  # revealed: Literal[C]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: pass\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Variable Constraint in Python\nDESCRIPTION: Illustrates an invalid use of type variable constraints where only one constraint is specified, which is disallowed according to PEP 695.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-type-variable-constraints] \"TypeVar must have at least two constrained types\"\ndef f[T: (int,)]():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Generating flamegraph and flamechart visualizations\nDESCRIPTION: Commands to convert the folded stack trace into SVG visualizations using Inferno's flamegraph tools.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# flamegraph\ncat tracing.folded | inferno-flamegraph > tracing-flamegraph.svg\n\n# flamechart\ncat tracing.folded | inferno-flamegraph --flamechart > tracing-flamechart.svg\n```\n\n----------------------------------------\n\nTITLE: Handling Call Binding Errors with Wrong Argument Type in Python\nDESCRIPTION: This snippet shows how type checking can catch errors when calling a callable instance with arguments of the wrong type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    def __call__(self, x: int) -> int:\n        return 1\n\nc = C()\n\n# error: 15 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `Literal[\"foo\"]\"\nreveal_type(c(\"foo\"))  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop Unreachable Code Example\nDESCRIPTION: Example demonstrating code that becomes unreachable after an infinite loop.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f1():\n    while True:\n        pass\n\n    # TODO: we should mark this as unreachable\n    print(\"unreachable\")\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Conditionally Defined __all__ in Python 3.11\nDESCRIPTION: Shows the behavior when importing from a module with conditionally defined __all__ in Python 3.11. The type checker correctly recognizes that X and Y are available but Z is not.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\nreveal_type(X)  # revealed: bool\nreveal_type(Y)  # revealed: bool\n\n# error: [unresolved-reference]\nreveal_type(Z)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: List Assignment with Named Assignments and Conditionals\nDESCRIPTION: Shows list assignment operations involving named assignments within conditional expressions. Illustrates type checking considerations with valid numeric indexing and invalid string-based indexing that should generate errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/lists.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = [1, 2, 3]\nx[0 if (y := 2) else 1] = 5\n\n# TODO error? (indeterminite index type)\nx[\"a\" if (y := 2) else 1] = 6\n\n# TODO error (can't index via string)\nx[\"a\" if (y := 2) else \"b\"] = 6\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff with Custom Configuration File (Native Server)\nDESCRIPTION: Updated example of providing a custom configuration file using the new native server settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/migration.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.configuration\": \"~/.config/custom_ruff_config.toml\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Python Modules and Accessing Math Constant\nDESCRIPTION: This code imports the math and os modules, then accesses the pi constant from the math module. The os module is imported but not used in this snippet.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/add_missing_cell_id.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\nimport os\n\nmath.pi\n```\n\n----------------------------------------\n\nTITLE: Partial Declarations in Python (No Error)\nDESCRIPTION: This snippet demonstrates a case where Ruff does not raise a conflicting-declarations error. It shows a partial declaration in a conditional block followed by an assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/declaration/error.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        x: int\n\n    x = 1\n```\n\n----------------------------------------\n\nTITLE: Simplifying Subtype Relationships in Python Type System\nDESCRIPTION: Shows simplification of intersections involving subtype relationships by removing superfluous supertypes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\nfrom typing import Any\n\nclass A: ...\nclass B(A): ...\nclass C(B): ...\nclass Unrelated: ...\n\ndef _(\n    i01: Intersection[A, B],\n    i02: Intersection[B, A],\n    i03: Intersection[A, C],\n    i04: Intersection[C, A],\n    i05: Intersection[B, C],\n    i06: Intersection[C, B],\n    i07: Intersection[A, B, C],\n    i08: Intersection[C, B, A],\n    i09: Intersection[B, C, A],\n    i10: Intersection[A, B, Unrelated],\n    i11: Intersection[B, A, Unrelated],\n    i12: Intersection[B, Unrelated, A],\n    i13: Intersection[A, Unrelated, B],\n    i14: Intersection[Unrelated, A, B],\n    i15: Intersection[Unrelated, B, A],\n    i16: Intersection[A, B, Any],\n    i17: Intersection[B, A, Any],\n    i18: Intersection[B, Any, A],\n    i19: Intersection[A, Any, B],\n    i20: Intersection[Any, A, B],\n    i21: Intersection[Any, B, A],\n) -> None:\n```\n\n----------------------------------------\n\nTITLE: Bare Import from Package in Python\nDESCRIPTION: This snippet shows a bare import from the package's __init__.py file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/relative.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom . import X\n\nreveal_type(X)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Using a Decorator with Excessive Blank Lines in Python\nDESCRIPTION: This snippet shows how to use a decorator in Python. It includes a potential style issue (E304) related to blank lines after the decorator.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# E304\n@decorator\n\ndef function():\n    pass\n# end\n```\n\n----------------------------------------\n\nTITLE: Possibly Undeclared and Unbound Symbol Usage in Python\nDESCRIPTION: Shows type inference for possibly undeclared and definitely unbound symbols, currently not raising errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nif flag():\n    a: int\n```\n\nLANGUAGE: python\nCODE:\n```\n# TODO: this should raise an error. Once we fix this, update the section description and the table\n# on top of this document.\nfrom mod import a\n\nreveal_type(a)  # revealed: int\n\n# External modifications to `a` that violate the declared type are not allowed:\n# error: [invalid-assignment]\na = None\n```\n\n----------------------------------------\n\nTITLE: Module Dict Precedence Example\nDESCRIPTION: Shows how types.ModuleType.__dict__ takes precedence over global variable __dict__ in different module contexts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n__dict__ = \"foo\"\n\nreveal_type(__dict__)  # revealed: Literal[\"foo\"]\n```\n\nLANGUAGE: python\nCODE:\n```\nimport foo\nfrom foo import __dict__ as foo_dict\n\n# TODO: needs support generics; should be `dict[str, Any]` for both of these:\nreveal_type(foo.__dict__)  # revealed: @Todo(generics)\nreveal_type(foo_dict)  # revealed: @Todo(generics)\n```\n\n----------------------------------------\n\nTITLE: Different Source Order Test\nDESCRIPTION: Tests invalid argument type detection when the call site appears before the function definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef bar():\n    foo(\"hello\")  # error: [invalid-argument-type]\n\ndef foo(x: int) -> int:\n    return x * x\n```\n\n----------------------------------------\n\nTITLE: Simplifying Disjoint Type Intersections in Python\nDESCRIPTION: Shows how intersections of disjoint types simplify to Never, even with additional type parameters present.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not\nfrom typing import Literal, Any\n\nclass P: ...\n\ndef _(\n    i01: Intersection[Literal[1], Literal[2]],\n    i02: Intersection[Literal[2], Literal[1]],\n    i03: Intersection[Literal[1], Literal[2], P],\n    i04: Intersection[Literal[1], P, Literal[2]],\n    i05: Intersection[P, Literal[1], Literal[2]],\n    i06: Intersection[Literal[1], Literal[2], Any],\n    i07: Intersection[Literal[1], Any, Literal[2]],\n    i08: Intersection[Any, Literal[1], Literal[2]],\n) -> None:\n    reveal_type(i01)  # revealed: Never\n    reveal_type(i02)  # revealed: Never\n    reveal_type(i03)  # revealed: Never\n    reveal_type(i04)  # revealed: Never\n    reveal_type(i05)  # revealed: Never\n    reveal_type(i06)  # revealed: Never\n    reveal_type(i07)  # revealed: Never\n    reveal_type(i08)  # revealed: Never\n\ndef example_type_bool_type_str(\n    i: Intersection[type[bool], type[str]],\n) -> None:\n    reveal_type(i)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Printing Pasted Strings in Python\nDESCRIPTION: This code snippet demonstrates the use of the print() function in combination with a paste() function to output concatenated strings. It joins the strings \"Hello\" and \"WoRld\" and prints the result.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/R.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint(paste(\"Hello\",\"WoRld\"))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Functions as Descriptors in Generic Classes in Python\nDESCRIPTION: This snippet illustrates how functions in generic classes act as descriptors, carrying specializations through the descriptor protocol.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import getattr_static\n\nclass C[T]:\n    def f(self, x: T) -> str:\n        return \"a\"\n\nreveal_type(getattr_static(C[int], \"f\"))  # revealed: def f(self, x: int) -> str\nreveal_type(getattr_static(C[int], \"f\").__get__)  # revealed: <method-wrapper `__get__` of `f[int]`>\nreveal_type(getattr_static(C[int], \"f\").__get__(None, C[int]))  # revealed: def f(self, x: int) -> str\n# revealed: bound method C[int].f(x: int) -> str\nreveal_type(getattr_static(C[int], \"f\").__get__(C[int](), C[int]))\n\nreveal_type(C[int].f)  # revealed: def f(self, x: int) -> str\nreveal_type(C[int]().f)  # revealed: bound method C[int].f(x: int) -> str\n\nbound_method = C[int]().f\nreveal_type(bound_method.__self__)  # revealed: C[int]\nreveal_type(bound_method.__func__)  # revealed: def f(self, x: int) -> str\n\nreveal_type(C[int]().f(1))  # revealed: str\nreveal_type(bound_method(1))  # revealed: str\n\nC[int].f(1)  # error: [missing-argument]\nreveal_type(C[int].f(C[int](), 1))  # revealed: str\n\nclass D[U](C[U]):\n    pass\n\nreveal_type(D[int]().f)  # revealed: bound method D[int].f(x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixable Rules\nDESCRIPTION: TOML configuration example for specifying which rules should be auto-fixed\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint]\nfixable = [\"ALL\"]\nunfixable = [\"F401\"]\n```\n\n----------------------------------------\n\nTITLE: Basic Return Type Validation in Python\nDESCRIPTION: Examples of basic function return type validation where return values must be assignable to the annotated return type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/function/return_type.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> int:\n    return 1\n```\n\n----------------------------------------\n\nTITLE: Redefinition of TypeVar in Python\nDESCRIPTION: This example shows an attempt to redefine a type variable, which is not allowed. Type variables must not be redefined once they are created.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/legacy.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n# TODO: error\nT = TypeVar(\"T\")\n```\n\n----------------------------------------\n\nTITLE: Invalid System Command Assignment in Python\nDESCRIPTION: Example showing incorrect usage of !pwd system command being assigned to variables, both with and without type hints. This code would raise a syntax error as system commands cannot be directly assigned to variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_project/resources/test/corpus/83_jupyter_notebook_ipython_magic.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    bar1 = !pwd\n    bar2: str = !pwd\n```\n\n----------------------------------------\n\nTITLE: Invalid Final Type Parameters in Python\nDESCRIPTION: Demonstrates invalid usage of Final type qualifier with multiple type parameters, which is not allowed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nclass C:\n    # error: [invalid-type-form] \"Type qualifier `typing.Final` expects exactly one type parameter\"\n    x: Final[int, str] = 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Export Using __all__ in Python\nDESCRIPTION: This snippet shows an attempt to export a symbol using __all__. Currently, this raises an error as the type checker doesn't understand __all__ yet.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# TODO: This should *not* be an error but we don't understand `__all__` yet.\n# error: \"Module `a` has no member `Foo`\"\nfrom a import Foo\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import Foo\n\n__all__ = ['Foo']\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Avoiding Recompilation with Environment Variable\nDESCRIPTION: Command showing how to use the MYPY_PRIMER_NO_REBUILD environment variable to prevent unnecessary recompilation of Red Knot when running multiple comparisons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/mypy_primer.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nMYPY_PRIMER_NO_REBUILD=1 mypy_primer …\n```\n\n----------------------------------------\n\nTITLE: Testing Explicit Object Inheritance\nDESCRIPTION: Tests type inference for a class explicitly inheriting from object\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass C(object): ...\n\nreveal_type(C.__mro__)  # revealed: tuple[Literal[C], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff LSP in Neovim\nDESCRIPTION: Basic setup configuration for Ruff language server in Neovim using nvim-lspconfig plugin. Includes initialization options and settings configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/setup.md#2025-04-17_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup({\n  init_options = {\n    settings = {\n      -- Ruff language server settings go here\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Specific Ruff Rules\nDESCRIPTION: Benchmark Ruff with a subset of rules (LineTooLong and DocLineTooLong) to measure performance for specific linting tasks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --release && hyperfine --warmup 10 \\\n  \"./target/release/ruff check ./crates/ruff_linter/resources/test/cpython/ --no-cache -e --select W505,E501\"\n```\n\n----------------------------------------\n\nTITLE: User-defined TYPE_CHECKING without Type Annotation\nDESCRIPTION: Shows behavior of manually defined TYPE_CHECKING constant without type annotation. Demonstrates conditional code execution based on TYPE_CHECKING.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nTYPE_CHECKING = False\nreveal_type(TYPE_CHECKING)  # revealed: Literal[True]\nif TYPE_CHECKING:\n    type_checking = True\nif not TYPE_CHECKING:\n    runtime = True\n\n# type_checking is treated as unconditionally assigned.\nreveal_type(type_checking)  # revealed: Literal[True]\n# error: [unresolved-reference]\nreveal_type(runtime)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Unary Operators with Type Returns\nDESCRIPTION: Shows behavior of unary operators when applied to functions returning class types. Demonstrates that type objects don't inherit instance methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/custom.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Yes:\n    def __pos__(self) -> bool:\n        return False\n\n    def __neg__(self) -> str:\n        return \"negative\"\n\n    def __invert__(self) -> int:\n        return 17\n\nclass Sub(Yes): ...\nclass No: ...\n\ndef yes() -> type[Yes]:\n    return Yes\n\ndef sub() -> type[Sub]:\n    return Sub\n\ndef no() -> type[No]:\n    return No\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `type[Yes]`\"\nreveal_type(+yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `type[Yes]`\"\nreveal_type(-yes())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `type[Yes]`\"\nreveal_type(~yes())  # revealed: Unknown\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `type[Sub]`\"\nreveal_type(+sub())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `type[Sub]`\"\nreveal_type(-sub())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `type[Sub]`\"\nreveal_type(~sub())  # revealed: Unknown\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `type[No]`\"\nreveal_type(+no())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `type[No]`\"\nreveal_type(-no())  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `type[No]`\"\nreveal_type(~no())  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Illustrating No Implicit Shadowing in Python Imports\nDESCRIPTION: This snippet demonstrates that importing a symbol does not allow implicit shadowing. Attempting to assign a different type to an imported symbol results in a type error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/errors.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nx: int\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import x\n\nx = \"foo\"  # error: [invalid-assignment] \"Object of type `Literal[\"foo\"]\"\n```\n\n----------------------------------------\n\nTITLE: Testing Object Class MRO\nDESCRIPTION: Tests type inference for the object class itself\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(object.__mro__)  # revealed: tuple[Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Expression with Semicolon\nDESCRIPTION: Single expression terminated with a semicolon.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Semicolons shouldn't affect the output\nx;\n```\n\n----------------------------------------\n\nTITLE: Testing Version-Specific Imports\nDESCRIPTION: Python code testing module imports with version restrictions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom old_module import OldClass\n\n# error: [unresolved-import] \"Cannot resolve import `new_module`\"\nfrom new_module import NewClass\n```\n\n----------------------------------------\n\nTITLE: Using 'not' with Incorrectly Implemented __bool__ in Python\nDESCRIPTION: Demonstrates an error case where a class incorrectly implements the __bool__ method as an attribute rather than a method, resulting in an unsupported-bool-conversion error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/not.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\n# error: [unsupported-bool-conversion]\nnot NotBoolable()\n```\n\n----------------------------------------\n\nTITLE: Analyzing Return Statements in Try-Except Blocks\nDESCRIPTION: Demonstrates the interaction between try-except blocks and terminal statements. Shows how type inference works when a return statement appears within a try block, affecting the variable types in except, else, and finally clauses.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef return_in_try(cond: bool):\n    x = \"before\"\n    try:\n        if cond:\n            x = \"test\"\n            return\n    except:\n        # TODO: Literal[\"before\"]\n        reveal_type(x)  # revealed: Literal[\"before\", \"test\"]\n    else:\n        reveal_type(x)  # revealed: Literal[\"before\"]\n    finally:\n        reveal_type(x)  # revealed: Literal[\"before\", \"test\"]\n    reveal_type(x)  # revealed: Literal[\"before\", \"test\"]\n```\n\n----------------------------------------\n\nTITLE: Rust While Statement Structure Definition\nDESCRIPTION: Definition of the AST structure for while statements in Rust, showing the components that make up a while loop node.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub struct StmtWhile {\n    pub range: TextRange,\n    pub test: Box<Expr<TextRange>>,\n    pub body: Vec<Stmt<TextRange>>,\n    pub orelse: Vec<Stmt<TextRange>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Python Environment Configuration\nDESCRIPTION: TOML configuration specifying Python version 3.9 for the environment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.9\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Assignment Expression\nDESCRIPTION: Shows walrus operator usage in conditional statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nif (x := 1):\n    # It should be the top level statement\n    x\n```\n\n----------------------------------------\n\nTITLE: Aliased TYPE_CHECKING Usage\nDESCRIPTION: Shows how TYPE_CHECKING behaves when imported with an alias. The constant maintains its Literal[True] type inference.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TYPE_CHECKING as TC\n\nreveal_type(TC)  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Unused ignore-comment Directive in Python\nDESCRIPTION: Shows a case where an unused-ignore-comment directive itself generates an unused-ignore-comment warning because it's not needed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'unused-ignore-comment'\"\na = 10 / 0  # knot: ignore[division-by-zero, unused-ignore-comment]\n```\n\n----------------------------------------\n\nTITLE: Literate Style Test Example\nDESCRIPTION: Shows how multiple code blocks are merged in literate testing style\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\ndef f(x: Literal[1]):\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\nf(2)  # error: [invalid-argument-type]\n```\n\n----------------------------------------\n\nTITLE: Module Attribute Access Resolution\nDESCRIPTION: Demonstrates how ModuleType attributes can be accessed on module-literal types and shows inheritance from builtins.object.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\nreveal_type(typing.__name__)  # revealed: str\nreveal_type(typing.__init__)  # revealed: bound method ModuleType.__init__(name: str, doc: str | None = ellipsis) -> None\n\n# These come from `builtins.object`, not `types.ModuleType`:\nreveal_type(typing.__eq__)  # revealed: bound method ModuleType.__eq__(value: object, /) -> bool\n\nreveal_type(typing.__class__)  # revealed: Literal[ModuleType]\n\n# TODO: needs support generics; should be `dict[str, Any]`:\nreveal_type(typing.__dict__)  # revealed: @Todo(generics)\n```\n\n----------------------------------------\n\nTITLE: Typeshed Stub Definitions\nDESCRIPTION: Type stub definitions showing how implicit globals override builtins.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass object: ...\nclass int: ...\nclass bytes: ...\n\n__name__: int = 42\n```\n\nLANGUAGE: python\nCODE:\n```\nclass ModuleType:\n    __name__: bytes\n```\n\nLANGUAGE: python\nCODE:\n```\ndef reveal_type(obj, /): ...\n```\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(__name__)  # revealed: bytes\n```\n\n----------------------------------------\n\nTITLE: Revealing Python Types for str() and repr() Functions with Literal Types\nDESCRIPTION: This code demonstrates how Python type checking handles string conversion using `str()` and `repr()` functions with various literal types. It shows that literal types maintain their literal nature when converted to strings, with slight differences in representation format between `str()` and `repr()`, especially for string literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/str_repr.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, LiteralString\n\ndef _(\n    a: Literal[1],\n    b: Literal[True],\n    c: Literal[False],\n    d: Literal[\"ab'cd\"],\n    e: LiteralString,\n    f: int,\n):\n    reveal_type(str(a))  # revealed: Literal[\"1\"]\n    reveal_type(str(b))  # revealed: Literal[\"True\"]\n    reveal_type(str(c))  # revealed: Literal[\"False\"]\n    reveal_type(str(d))  # revealed: Literal[\"ab'cd\"]\n    reveal_type(str(e))  # revealed: LiteralString\n    reveal_type(str(f))  # revealed: str\n\n    reveal_type(repr(a))  # revealed: Literal[\"1\"]\n    reveal_type(repr(b))  # revealed: Literal[\"True\"]\n    reveal_type(repr(c))  # revealed: Literal[\"False\"]\n    reveal_type(repr(d))  # revealed: Literal[\"'ab\\\\'cd'\"]\n    reveal_type(repr(e))  # revealed: LiteralString\n    reveal_type(repr(f))  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Search Path Module a Definition\nDESCRIPTION: Second search path module definition with Bar class\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Bar:\n    x: str = \"test\"\n```\n\n----------------------------------------\n\nTITLE: Unary Operators on Function Literals\nDESCRIPTION: Demonstrates that unary operators are not supported on function objects, resulting in type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/custom.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    pass\n\n# error: [unsupported-operator] \"Unary operator `+` is unsupported for type `def f() -> Unknown`\"\nreveal_type(+f)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `-` is unsupported for type `def f() -> Unknown`\"\nreveal_type(-f)  # revealed: Unknown\n# error: [unsupported-operator] \"Unary operator `~` is unsupported for type `def f() -> Unknown`\"\nreveal_type(~f)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Version-Specific Typeshed Configuration\nDESCRIPTION: TOML configuration specifying Python version and typeshed directory for version testing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\ntypeshed = \"/typeshed\"\n```\n\n----------------------------------------\n\nTITLE: Cannot Suppress revealed-type Diagnostics in Python\nDESCRIPTION: Shows that revealed-type diagnostics cannot be suppressed with knot: ignore, and attempting to do so results in an unknown-rule error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\na = 10\n# revealed: Literal[10]\n# error: [unknown-rule] \"Unknown rule `revealed-type`\"\nreveal_type(a)  # knot: ignore[revealed-type]\n```\n\n----------------------------------------\n\nTITLE: Running Fuzzer Command\nDESCRIPTION: Command line instruction for running the fuzzer script from the repository root using the uv package manager\nSOURCE: https://github.com/astral-sh/ruff/blob/main/python/py-fuzzer/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuvx --from ./python/py-fuzzer fuzz -h\n```\n\n----------------------------------------\n\nTITLE: Unreachable Code Detection with 'if False' in Python\nDESCRIPTION: Demonstrates that no diagnostic is emitted for code inside a statically known unreachable branch. The reference to the undefined variable 'x' doesn't trigger an error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    x\n```\n\n----------------------------------------\n\nTITLE: Simplifying Intersections of LiteralString with AlwaysTruthy and AlwaysFalsy\nDESCRIPTION: Shows how intersections between LiteralString, AlwaysTruthy, and AlwaysFalsy can be simplified based on string emptiness, since LiteralString inhabitants have __class__ set to exactly str.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Intersection, Not, AlwaysTruthy, AlwaysFalsy, Unknown\nfrom typing_extensions import LiteralString\n\ndef f(\n    a: Intersection[LiteralString, AlwaysTruthy],\n    b: Intersection[LiteralString, AlwaysFalsy],\n    c: Intersection[LiteralString, Not[AlwaysTruthy]],\n    d: Intersection[LiteralString, Not[AlwaysFalsy]],\n    e: Intersection[AlwaysFalsy, LiteralString],\n    f: Intersection[Not[AlwaysTruthy], LiteralString],\n    g: Intersection[AlwaysTruthy, LiteralString],\n    h: Intersection[Not[AlwaysFalsy], LiteralString],\n    i: Intersection[Unknown, LiteralString, AlwaysFalsy],\n    j: Intersection[Not[AlwaysTruthy], Unknown, LiteralString],\n):\n    reveal_type(a)  # revealed: LiteralString & ~Literal[\"\"]\n    reveal_type(b)  # revealed: Literal[\"\"]\n    reveal_type(c)  # revealed: Literal[\"\"]\n    reveal_type(d)  # revealed: LiteralString & ~Literal[\"\"]\n    reveal_type(e)  # revealed: Literal[\"\"]\n    reveal_type(f)  # revealed: Literal[\"\"]\n    reveal_type(g)  # revealed: LiteralString & ~Literal[\"\"]\n    reveal_type(h)  # revealed: LiteralString & ~Literal[\"\"]\n    reveal_type(i)  # revealed: Unknown & Literal[\"\"]\n    reveal_type(j)  # revealed: Unknown & Literal[\"\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Python 3.10 Environment for Class Unions\nDESCRIPTION: TOML configuration to specify Python 3.10 as the required version for using class union operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/classes.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Profiling Ruff on Mac with cargo-instruments\nDESCRIPTION: Use cargo-instruments to profile Ruff's performance on Mac systems.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ncargo instruments -t time --bench linter --profile profiling -p ruff_benchmark -- --profile-time=1\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Correct Blank Lines in Python\nDESCRIPTION: This snippet demonstrates defining a function in Python with correct usage of blank lines, marked as 'Ok'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Ok\ndef function1():\n\tpass\n\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Comments and Potential E305 Issue in Python\nDESCRIPTION: This snippet demonstrates defining a function with comments and calling it. It includes a potential style issue (E305) related to blank lines before function definitions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# E305:7:1\ndef fn():\n    print()\n\n    # comment\n\n    # another comment\nfn()\n# end\n```\n\n----------------------------------------\n\nTITLE: Import Aliases with sys.version_info\nDESCRIPTION: Demonstrates type behavior when sys.version_info is imported and aliased\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sys import version_info\nfrom sys import version_info as foo\n\nreveal_type(version_info >= (3, 9))  # revealed: Literal[True]\nreveal_type(foo >= (3, 9))  # revealed: Literal[True]\n\nbar = version_info\nreveal_type(bar >= (3, 9))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Enabling Preview Mode for Linting in Ruff LSP\nDESCRIPTION: Controls whether to enable Ruff's preview mode when linting. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.preview\": true\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      lint = {\n        preview = true\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"lint\": {\n            \"preview\": true\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested Non-exports in Python\nDESCRIPTION: This series of snippets shows a chain of modules where none re-export an import. Attempting to import Any from module 'a' results in an error, as it's not re-exported through the chain.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `a` has no member `Any`\"\nfrom a import Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `b` has no member `Any`\"\nfrom b import Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `c` has no member `Any`\"\nfrom c import Any\n\nreveal_type(Any)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nreveal_type(Any)  # revealed: typing.Any\n```\n\n----------------------------------------\n\nTITLE: Creating Empty __init__.py Files for Package Structure\nDESCRIPTION: Creates empty __init__.py files to establish a nested package structure.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Custom Sys Module Stub\nDESCRIPTION: Type stub file for customizing the sys module version string.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_2\n\nLANGUAGE: pyi\nCODE:\n```\nversion = \"my custom Python\"\n```\n\n----------------------------------------\n\nTITLE: Testing Inconsistent MRO Resolution\nDESCRIPTION: Demonstrates error handling for inconsistent method resolution order when inheriting from unknown objects.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mro.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Foo(unknown_object_1, unknown_object_2): ...\n\nreveal_type(Foo.__mro__)\n```\n\n----------------------------------------\n\nTITLE: Implementing Regular Package for Simple Stub in Python\nDESCRIPTION: Defines the actual implementation of the 'Foo' class without type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Using !pwd Shell Command with Type Annotations\nDESCRIPTION: Shows usage of the !pwd shell command (to get current working directory) both with and without type annotations in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/unused_variable.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    bar1 = !pwd\n    bar2: str = !pwd\n```\n\n----------------------------------------\n\nTITLE: Checking an excluded directory directly with Ruff\nDESCRIPTION: This command demonstrates that passing an excluded directory directly to Ruff will still report errors in the contained files, as the exclude pattern is only applied when checking parent directories.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n∴ cargo run -p ruff -- check crates/ruff_linter/resources/test/project/examples/excluded/\ncrates/ruff_linter/resources/test/project/examples/excluded/script.py:1:8: F401 [*] `os` imported but unused\nFound 1 error.\n[*] 1 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Subclassing the Unknown Type in Python\nDESCRIPTION: Shows how Unknown can be subclassed similar to Any, and demonstrates error handling when using it incorrectly with type parameters.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass C(Unknown): ...\n\n# revealed: tuple[Literal[C], Unknown, Literal[object]]\nreveal_type(C.__mro__)\n\n# error: \"Special form `knot_extensions.Unknown` expected no type parameter\"\nu: Unknown[str]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Extension Module Definition\nDESCRIPTION: Module with incorrect file extension casing\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    x: int = 1\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript-like Function in Python\nDESCRIPTION: This code snippet defines a function named 'add' that takes two parameters and returns their sum. Although the syntax resembles JavaScript, it's written in a Python code cell.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/kernelspec_language.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfunction add(x, y) {\n    return x + y;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Gradual Type Equivalence in Python\nDESCRIPTION: Demonstrates basic gradual type equivalence tests using static_assert and is_gradual_equivalent_to. Tests equivalence between Any, Unknown, Never, and various literal types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom typing_extensions import Literal, LiteralString, Never\nfrom knot_extensions import AlwaysFalsy, AlwaysTruthy, TypeOf, Unknown, is_gradual_equivalent_to, static_assert\n\nstatic_assert(is_gradual_equivalent_to(Any, Any))\nstatic_assert(is_gradual_equivalent_to(Unknown, Unknown))\nstatic_assert(is_gradual_equivalent_to(Any, Unknown))\n\nstatic_assert(is_gradual_equivalent_to(Never, Never))\nstatic_assert(is_gradual_equivalent_to(AlwaysTruthy, AlwaysTruthy))\nstatic_assert(is_gradual_equivalent_to(AlwaysFalsy, AlwaysFalsy))\nstatic_assert(is_gradual_equivalent_to(LiteralString, LiteralString))\n\nstatic_assert(is_gradual_equivalent_to(Literal[True], Literal[True]))\nstatic_assert(is_gradual_equivalent_to(Literal[False], Literal[False]))\nstatic_assert(is_gradual_equivalent_to(TypeOf[0:1:2], TypeOf[0:1:2]))\n\nstatic_assert(is_gradual_equivalent_to(TypeOf[str], TypeOf[str]))\nstatic_assert(is_gradual_equivalent_to(type, type[object]))\n\nstatic_assert(not is_gradual_equivalent_to(type, type[Any]))\nstatic_assert(not is_gradual_equivalent_to(type[object], type[Any]))\n```\n\n----------------------------------------\n\nTITLE: Ecosystem Check Commands\nDESCRIPTION: Commands for running large-scale ecosystem compatibility checks\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl https://raw.githubusercontent.com/akx/ruff-usage-aggregate/master/data/known-github-tomls-clean.jsonl > github_search.jsonl\npython scripts/check_ecosystem.py --checkouts target/checkouts --projects github_search.jsonl -v $(which true) $(which true)\ncargo run --bin ruff_dev -- format-dev --stability-check --error-file target/formatter-ecosystem-errors.txt --multi-project target/checkouts\n```\n\n----------------------------------------\n\nTITLE: Custom sys Module Version Info\nDESCRIPTION: Definition of a custom version_info tuple in a user-defined sys module\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nversion_info: tuple[int, int] = (4, 2)\n```\n\n----------------------------------------\n\nTITLE: Configuring Inconsistent Stub Packages in TOML\nDESCRIPTION: Sets up the environment for inconsistent stub packages with mixed namespace and regular packages.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/stubs1\", \"/stubs2\", \"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Basic Variable Assignment\nDESCRIPTION: Simple assignment of value 1 to variable x.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n```\n\n----------------------------------------\n\nTITLE: Setting RED_KNOT_LOG to show all debug messages\nDESCRIPTION: Environment variable configuration to display debug messages from all crates in the Red Knot/Ruff project.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRED_KNOT_LOG=debug\n```\n\n----------------------------------------\n\nTITLE: Using noqa Comments\nDESCRIPTION: Example of using noqa comments to suppress specific lint violations inline\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/linter.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Ignore F841.\nx = 1  # noqa: F841\n\n# Ignore E741 and F841.\ni = 1  # noqa: E741, F841\n```\n\n----------------------------------------\n\nTITLE: String vs Tuple __slots__ Inheritance\nDESCRIPTION: Demonstrates incompatibility between classes defining __slots__ as a string versus a tuple containing a string. These different representations cause inheritance issues.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = \"abc\"\n\nclass B:\n    __slots__ = (\"abc\",)\n\nclass AB(\n    A,  # error: [incompatible-slots]\n    B,  # error: [incompatible-slots]\n): ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment for FreeBSD8 Platform in TOML\nDESCRIPTION: TOML configuration that specifies the project should be configured specifically for FreeBSD8 platform. This is used for the subsequent platform comparison examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_platform.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-platform = \"freebsd8\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Pi Constant from Math Module in Python\nDESCRIPTION: This snippet demonstrates how to import the math module from Python's standard library and access the predefined pi constant. The math module provides mathematical functions and constants for numerical operations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/after_fix.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\n\nmath.pi\n```\n\n----------------------------------------\n\nTITLE: Python Imports with Comments and Function Definition\nDESCRIPTION: Shows imports with type annotations followed by a comment indicating a newline should be added before the function definition. Includes a simple function declaration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort_expected.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport collections\nfrom typing import Any\n\n\n# Newline should be added here\ndef foo():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Importing from Module with Dynamic __all__\nDESCRIPTION: Shows the behavior when importing from a module with dynamically constructed __all__. The type checker treats the module as having no __all__, importing all symbols to avoid false positives.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\n# At runtime, `f` is imported but `g` is not; to avoid false positives, however,\n# we treat `a` as though it does not have `__all__` at all,\n# which would imply that both symbols would be present.\nreveal_type(f)  # revealed: def f() -> str\nreveal_type(g)  # revealed: def g() -> int\n```\n\n----------------------------------------\n\nTITLE: Missing Final Assignment in Python\nDESCRIPTION: Demonstrates potentially invalid usage of Final without right-hand side assignment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_qualifiers/final.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\n# TODO: This should be an error\nNO_RHS: Final\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule Ignores for Jupyter Notebooks in pyproject.toml\nDESCRIPTION: TOML configuration to ignore specific linting rules (T20 in this example) only for Jupyter Notebook files in pyproject.toml.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/configuration.md#2025-04-17_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff.lint.per-file-ignores]\n\"*.ipynb\" = [\"T20\"]\n```\n\n----------------------------------------\n\nTITLE: Multi-line `with` context managers with Python 3.9+\nDESCRIPTION: This snippet demonstrates the use of parentheses around the context managers to allow for clearer breaks across multiple lines when targetting Python 3.9 or newer.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nwith tempfile.TemporaryDirectory() as d1:\n    symlink_path = Path(d1).joinpath(\"testsymlink\")\n    with (\n        tempfile.TemporaryDirectory(dir=d1) as d2,\n        tempfile.TemporaryDirectory(dir=d1) as d4,\n        tempfile.TemporaryDirectory(dir=d2) as d3,\n        tempfile.NamedTemporaryFile(dir=d4) as source_file,\n        tempfile.NamedTemporaryFile(dir=d3) as lock_file,\n    ):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Child Section TOML Configuration\nDESCRIPTION: Sets a new Python version configuration for a section and its children to 3.12.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.12\"\n```\n\n----------------------------------------\n\nTITLE: Mismatched Error Code Suppression in Python\nDESCRIPTION: Shows what happens when the specified error code doesn't match the actual error, generating both an unresolved-reference error and an unused-ignore-comment warning.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference]\n# error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'possibly-unresolved-reference'\"\na = test + 3  # knot: ignore[possibly-unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Tuple Comparisons with Non-Boolean Rich Comparison Methods in Python\nDESCRIPTION: Illustrates how tuple comparisons are affected by rich comparison methods that return non-boolean types. The final result can still be a boolean value for equality and inequality comparisons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass EqReturnType: ...\nclass NeReturnType: ...\nclass LtReturnType: ...\nclass LeReturnType: ...\nclass GtReturnType: ...\nclass GeReturnType: ...\n\nclass A:\n    def __eq__(self, o: object) -> EqReturnType:\n        return EqReturnType()\n\n    def __ne__(self, o: object) -> NeReturnType:\n        return NeReturnType()\n\n    def __lt__(self, o: A) -> LtReturnType:\n        return LtReturnType()\n\n    def __le__(self, o: A) -> LeReturnType:\n        return LeReturnType()\n\n    def __gt__(self, o: A) -> GtReturnType:\n        return GtReturnType()\n\n    def __ge__(self, o: A) -> GeReturnType:\n        return GeReturnType()\n\na = (A(), A())\n\nreveal_type(a == a)  # revealed: bool\nreveal_type(a != a)  # revealed: bool\nreveal_type(a < a)  # revealed: LtReturnType | Literal[False]\nreveal_type(a <= a)  # revealed: LeReturnType | Literal[True]\nreveal_type(a > a)  # revealed: GtReturnType | Literal[False]\nreveal_type(a >= a)  # revealed: GeReturnType | Literal[True]\n\n# If lexicographic comparison is finished before comparing A()\nb = (\"1_foo\", A())\nc = (\"2_bar\", A())\n\nreveal_type(b == c)  # revealed: Literal[False]\nreveal_type(b != c)  # revealed: Literal[True]\nreveal_type(b < c)  # revealed: Literal[True]\nreveal_type(b <= c)  # revealed: Literal[True]\nreveal_type(b > c)  # revealed: Literal[False]\nreveal_type(b >= c)  # revealed: Literal[False]\n\nclass LtReturnTypeOnB: ...\n\nclass B:\n    def __lt__(self, o: B) -> LtReturnTypeOnB:\n        return LtReturnTypeOnB()\n\nreveal_type((A(), B()) < (A(), B()))  # revealed: LtReturnType | LtReturnTypeOnB | Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Timing System Module Import in Python\nDESCRIPTION: This snippet uses the %%timeit magic command to measure the execution time of importing the sys module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/ipy_escape_command.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%timeit\nimport sys\n```\n\n----------------------------------------\n\nTITLE: For Loop with Path Variable Shadowing\nDESCRIPTION: Demonstrates a for loop that shadows the previously imported 'path' alias by using it as a loop variable. Like the previous example, this makes the original path alias inaccessible.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pyflakes/F402.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor path in range(3):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Simple Comparison Expression in Python\nDESCRIPTION: A basic comparison expression that checks if x equals 1, with a comment indicating this is a simple case. This likely demonstrates the B018 rule for useless comparisons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Simple case\nx == 1\n```\n\n----------------------------------------\n\nTITLE: Subscriptability Limitations of Special Forms\nDESCRIPTION: This code demonstrates subscriptability constraints for special forms like `TypeAlias` and `Self`. The example shows error messages that occur when attempting to use type parameters with special forms that don't support them.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_special_forms.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self, TypeAlias\n\nX: TypeAlias[T] = int  # error: [invalid-type-form]\n\nclass Foo[T]:\n    # error: [invalid-type-form] \"Special form `typing.Self` expected no type parameter\"\n    # error: [invalid-type-form] \"Special form `typing.Self` expected no type parameter\"\n    def method(self: Self[int]) -> Self[int]:\n        reveal_type(self)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Shadowing typing.Any with a Local Class in Python\nDESCRIPTION: Demonstrates that defining a local class named Any shadows the typing.Any import. The type system treats the local class as a distinct type, not as the Any type from the typing module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/any.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Any: ...\n\nx: Any\n\ndef f():\n    reveal_type(x)  # revealed: Any\n\n# This verifies that we're not accidentally seeing typing.Any, since str is assignable\n# to that but not to our locally defined class.\ny: Any = \"not an Any\"  # error: [invalid-assignment]\n```\n\n----------------------------------------\n\nTITLE: Non-Deferred Self-Reference Annotations in Class Definitions\nDESCRIPTION: Demonstrates how self-references fail without __future__.annotations, showing unresolved reference errors. String literal annotations are shown as a workaround.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    # error: [unresolved-reference]\n    this: Foo\n    ok: \"Foo\"\n    # error: [unresolved-reference]\n    _ = Foo()\n    # error: [unresolved-reference]\n    [Foo for _ in range(1)]\n    a = int\n\n    # error: [unresolved-reference]\n    def f(self, x: Foo):\n        reveal_type(x)  # revealed: Unknown\n    # error: [unresolved-reference]\n    def g(self) -> Foo:\n        _: Foo = self\n        return self\n\n    class Bar:\n        # error: [unresolved-reference]\n        foo: Foo\n        b = int\n\n        # error: [unresolved-reference]\n        def f(self, x: Foo):\n            return self\n        # error: [unresolved-reference]\n        def g(self) -> Bar:\n            return self\n        # error: [unresolved-reference]\n        def h[T: Bar](self):\n            pass\n\n        class Baz[T: Foo]:\n            pass\n\n        # error: [unresolved-reference]\n        type S = a\n        type T = b\n\n    def h[T: Bar]():\n        # error: [unresolved-reference]\n        return Bar()\n    type Qux = Foo\n\ndef _():\n    class C:\n        # error: [unresolved-reference]\n        def f(self) -> C:\n            return self\n```\n\n----------------------------------------\n\nTITLE: Importing OS Module and Printing in Python\nDESCRIPTION: This code snippet imports the 'os' module and prints 'hello world' to the console. It demonstrates basic Python syntax and module importing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/kernelspec_language.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nprint(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: Importing Math and OS Modules and Accessing Pi Constant in Python\nDESCRIPTION: This snippet imports the math and os modules, and then accesses the pi constant from the math module. It demonstrates how to import multiple modules and use a built-in constant.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/no_cell_id.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport math\nimport os\n\nmath.pi\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Invalid __iter__ Methods in Python\nDESCRIPTION: Tests type inference when __iter__ might be invalid due to incorrect parameter signature or being unbound. The system should emit diagnostics while still attempting to infer element types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\nclass Iterator:\n    def __next__(self) -> int:\n        return 42\n\ndef _(flag: bool):\n    class Iterable1:\n        if flag:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n        else:\n            def __iter__(self, invalid_extra_arg) -> Iterator:\n                return Iterator()\n\n    # error: [not-iterable]\n    for x in Iterable1():\n        reveal_type(x)  # revealed: int\n\n    class Iterable2:\n        if flag:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n        else:\n            __iter__: None = None\n\n    # error: [not-iterable]\n    for x in Iterable2():\n        # TODO: `int` would probably be better here:\n        reveal_type(x)  # revealed: int | Unknown\n```\n\n----------------------------------------\n\nTITLE: Setting Up Ruff Benchmarks\nDESCRIPTION: Shell command to clone the CPython repository as a benchmarking target.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/benchmarks/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/benchmarks/setup.sh\n```\n\n----------------------------------------\n\nTITLE: Root TOML Configuration - Python Version Setting\nDESCRIPTION: Defines the root-level TOML configuration setting Python version to 3.10.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.10\"\n```\n\n----------------------------------------\n\nTITLE: Old Module Type Stub\nDESCRIPTION: Type stub for a backwards-compatible module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_5\n\nLANGUAGE: pyi\nCODE:\n```\nclass OldClass: ...\n```\n\n----------------------------------------\n\nTITLE: Nested Expression Context\nDESCRIPTION: Expression within an if statement block showing nested context.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Nested expressions isn't relevant\nif True:\n    x\n```\n\n----------------------------------------\n\nTITLE: Basic Star Import with Underscore Prefixed Names\nDESCRIPTION: Demonstrates how underscore-prefixed names are handled in star imports without __all__ declaration\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n_private: bool = False\n__protected: bool = False\n__dunder__: bool = False\n___thunder___: bool = False\n\nY: bool = True\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom exporter import *\n\n# error: [unresolved-reference]\nreveal_type(_private)  # revealed: Unknown\n# error: [unresolved-reference]\nreveal_type(__protected)  # revealed: Unknown\n# error: [unresolved-reference]\nreveal_type(__dunder__)  # revealed: Unknown\n# error: [unresolved-reference]\nreveal_type(___thunder___)  # revealed: Unknown\n\nreveal_type(Y)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Special-cased Class Truthiness Configuration\nDESCRIPTION: Environment configuration for Python version specification in TOML format.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/truthiness.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.12\"\n```\n\n----------------------------------------\n\nTITLE: Tuple Parenthesization: Ruff vs Black\nDESCRIPTION: This snippet illustrates how Ruff and Black handle parentheses around tuples, especially when tuples span multiple lines. Ruff tends to parenthesize tuples more aggressively, while Black removes parentheses more often. Ruff consistently inserts parentheses around multi-line tuples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Input\n(a, b), (c, d,)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Black\n(a, b), (\n    c,\n    d,\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\n(\n    (a, b),\n    (\n        c,\n        d,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Running Local Datastore with Wrangler\nDESCRIPTION: Command to run the local datastore using Wrangler CLI for development purposes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/playground/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx wrangler dev --local\n```\n\n----------------------------------------\n\nTITLE: Invalid Own-Line Type Error Suppression in Python\nDESCRIPTION: Example showing that file-level suppressions must come before any non-trivia token, including module docstrings. After that, they're treated as unused blanket directives.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\nFile level suppressions must come before any non-trivia token,\nincluding module docstrings.\n\"\"\"\n\n# error: [unused-ignore-comment] \"Unused blanket `type: ignore` directive\"\n# type: ignore\n\na = 10 / 0  # error: [division-by-zero]\nb = a / 0  # error: [division-by-zero]\n```\n\n----------------------------------------\n\nTITLE: Function Literals for Checking Callable Type Variations in Python\nDESCRIPTION: Demonstrates using function literals to check more variations of callable types. This approach allows defining parameters without annotations and no return type, showing which function signatures are fully-static.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_fully_static.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, is_fully_static, static_assert\n\ndef f00() -> None: ...\ndef f01(a: int, b: str) -> None: ...\ndef f11(): ...\ndef f12(a, b): ...\ndef f13(a, b: int): ...\ndef f14(a, b: int) -> None: ...\ndef f15(a, b) -> None: ...\n\nstatic_assert(is_fully_static(CallableTypeOf[f00]))\nstatic_assert(is_fully_static(CallableTypeOf[f01]))\n\nstatic_assert(not is_fully_static(CallableTypeOf[f11]))\nstatic_assert(not is_fully_static(CallableTypeOf[f12]))\nstatic_assert(not is_fully_static(CallableTypeOf[f13]))\nstatic_assert(not is_fully_static(CallableTypeOf[f14]))\nstatic_assert(not is_fully_static(CallableTypeOf[f15]))\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Function in Python\nDESCRIPTION: This snippet shows how to define a function in Python that prints a string when called.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef fn():\n    print(\"Hey!\")\n```\n\n----------------------------------------\n\nTITLE: Working with the Unknown Type in Python\nDESCRIPTION: Demonstrates the Unknown type which represents unannotated types, different from Any. Includes examples of type assignability and static testing with Unknown.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import Unknown, static_assert, is_assignable_to, is_fully_static\n\nstatic_assert(is_assignable_to(Unknown, int))\nstatic_assert(is_assignable_to(int, Unknown))\n\nstatic_assert(not is_fully_static(Unknown))\n\ndef explicit_unknown(x: Unknown, y: tuple[str, Unknown], z: Unknown = 1) -> None:\n    reveal_type(x)  # revealed: Unknown\n    reveal_type(y)  # revealed: tuple[str, Unknown]\n    reveal_type(z)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Multiple Expressions on One Line with Semicolon\nDESCRIPTION: Two comparison expressions on the same line separated by a semicolon, testing how the linter handles multiple potentially useless comparisons in a single line of code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Semicolons with multiple expressions\nx == 1; x == 1\n```\n\n----------------------------------------\n\nTITLE: Nested Section Python Version Check\nDESCRIPTION: Tests if the root configuration is correctly inherited in deeply nested sections.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[:2] == (3, 10))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Attributes Declared in Type Stubs\nDESCRIPTION: Shows how attributes declared in type stubs can be accessed directly from the class object. The type checker treats such attributes as bound on the class, not as pure instance attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/class.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar, Literal\n\nfrom b import C\n\n# No error here, since we treat `class_or_instance_var` as bound on the class.\nreveal_type(C.class_or_instance_var)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Using Await in a Regular Function in Python\nDESCRIPTION: This snippet shows the use of 'await' inside a regular (non-async) function. This results in a SyntaxError as 'await' can only be used inside async functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/syntax_errors/await_scope.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    await 1  # SyntaxError: await outside async function\n```\n\n----------------------------------------\n\nTITLE: Displaying an Integer Value in Python\nDESCRIPTION: This snippet calls the display() function with an integer argument. The display() function is commonly used in interactive Python environments like Jupyter notebooks to output values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pyflakes/F821_22.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndisplay(1)\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Match Statement with Guard in Python\nDESCRIPTION: Demonstrates how type analysis handles a match statement with a case guard. Since the guard's truthiness can't be determined statically, the variable 'x' could be either 1 or 2.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nx = 1\n\nmatch \"a\":\n    case \"a\" if flag():\n        x = 2\n    case \"b\":\n        x = 3\n    case _:\n        pass\n\nreveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Usage Example: Overlong If Guard in Match Case\nDESCRIPTION: Code example demonstrating a match-case statement with a long if guard that would be parenthesized.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmatch value:\n    case pattern if some_very_long_condition and another_long_condition:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Python Comment Examples\nDESCRIPTION: Examples of leading and trailing comments in Python code\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Leading comment (always own line)\nprint(\"hello world\")  # Trailing comment (end-of-line)\n```\n\n----------------------------------------\n\nTITLE: Empty Error Codes List in Python\nDESCRIPTION: Shows that using an empty error codes list in a knot: ignore directive is always considered useless and generates an unused-ignore-comment warning.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# error: [division-by-zero]\n# error: [unused-ignore-comment] \"Unused `knot: ignore` without a code\"\na = 4 / 0  # knot: ignore[]\n```\n\n----------------------------------------\n\nTITLE: Package Module Definition\nDESCRIPTION: Module definition within a package structure\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    x: int = 1\n```\n\n----------------------------------------\n\nTITLE: Default Ruff Configuration\nDESCRIPTION: Default configuration for Ruff in TOML format, specifying excluded directories and formatting settings.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/README.md#2025-04-17_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n# Exclude a variety of commonly ignored directories.\nexclude = [\n    \".bzr\",\n    \".direnv\",\n    \".eggs\",\n    \".git\",\n    \".git-rewrite\",\n    \".hg\",\n    \".ipynb_checkpoints\",\n    \".mypy_cache\",\n    \".nox\",\n    \".pants.d\",\n    \".pyenv\",\n    \".pytest_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".svn\",\n    \".tox\",\n    \".venv\",\n    \".vscode\",\n    \"__pypackages__\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"node_modules\",\n    \"site-packages\",\n    \"venv\",\n]\n\n# Same as Black.\nline-length = 88\nindent-width = 4\n```\n\n----------------------------------------\n\nTITLE: While-Else Loop with Break Type Checking in Python\nDESCRIPTION: Illustrates type checking in while-else construct with potential break statements, showing how control flow affects variable types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    x = 1\n    y = 0\n    while flag:\n        x = 2\n        if flag2:\n            y = 4\n            break\n    else:\n        y = x\n        x = 3\n\n    reveal_type(x)  # revealed: Literal[2, 3]\n    reveal_type(y)  # revealed: Literal[4, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Operators for Negative Contributions in Python\nDESCRIPTION: This snippet shows how unsupported operators are handled for negative contributions to intersection types. It demonstrates that no error is raised when using the 'in' operator with a negated type.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Container:\n    def __contains__(self, x) -> bool:\n        return False\n\nclass NonContainer: ...\n\ndef _(x: object):\n    if isinstance(x, Container):\n        if not isinstance(x, NonContainer):\n            reveal_type(x)  # revealed: Container & ~NonContainer\n\n            # No error here!\n            reveal_type(2 in x)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Testing For Loop Syntax Error in Python\nDESCRIPTION: Shows parser behavior when using 'while' keyword as an iterator variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [invalid-syntax]\n# error: [unresolved-reference] \"Name `pass` used when not defined\"\nfor while in pass:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Re-exports in __init__.pyi in Python\nDESCRIPTION: This snippet shows that importing non-exported names from an __init__.pyi file raises errors. The imported symbols are revealed as Unknown, except for explicitly re-exported modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# error: 15 \"Module `a` has no member `Foo`\"\n# error: 20 \"Module `a` has no member `c`\"\nfrom a import Foo, c, foo\n\nreveal_type(Foo)  # revealed: Unknown\nreveal_type(c)  # revealed: Unknown\nreveal_type(foo)  # revealed: <module 'a.foo'>\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom .b import c\nfrom .foo import Foo\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Variable Access with Annotation-only Assignment\nDESCRIPTION: Shows how type inference handles variable access when there's an annotation-only assignment in an intermediate scope.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/nonlocal.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    x = 1\n    def g():\n        # it's pretty weird to have an annotated assignment in a function where the\n        # name is otherwise not defined; maybe should be an error?\n        x: int\n        def h():\n            reveal_type(x)  # revealed: Unknown | Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Printing Hello World in Python\nDESCRIPTION: This snippet demonstrates a basic print statement in Python, outputting the message 'hello world' to the console.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/vscode_language_id_expected.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: Incorrect Tuple Assignments in Python\nDESCRIPTION: This snippet shows examples of incorrect tuple assignments that violate the declared type annotations, resulting in type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-assignment] \"Object of type `tuple[Literal[1], Literal[2]]` is not assignable to `tuple[()]`\"\na: tuple[()] = (1, 2)\n\n# error: [invalid-assignment] \"Object of type `tuple[Literal[\"foo\"]]` is not assignable to `tuple[int]`\"\nb: tuple[int] = (\"foo\",)\n\n# error: [invalid-assignment] \"Object of type `tuple[list, Literal[\"foo\"]]` is not assignable to `tuple[str | int, str]`\"\nc: tuple[str | int, str] = ([], \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic Computation in Python\nDESCRIPTION: This snippet shows a simple addition operation in Python, assigning the result to a variable.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsome_computation = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Expression with Multiple Comments\nDESCRIPTION: Single expression with inline and separate line comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Comments, newlines and whitespace\nx  # comment\n\n# another comment\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Microbenchmarks\nDESCRIPTION: Execute microbenchmarks for Ruff's linter and formatter components using Cargo.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ncargo benchmark\n```\n\n----------------------------------------\n\nTITLE: Single Symbol If-Elif-Else Analysis\nDESCRIPTION: Demonstrates type tracking for a single variable defined across all branches of an if-elif-else statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_statement.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool, flag2: bool):\n    if flag:\n        y = 1\n    elif flag2:\n        y = 2\n    else:\n        y = 3\n\n    reveal_type(y)  # revealed: Literal[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Running Parser Test Suite\nDESCRIPTION: Shell command to execute the full parser test suite.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --package ruff_python_parser\n```\n\n----------------------------------------\n\nTITLE: Importing OS Modules in Python\nDESCRIPTION: Demonstrates importing the os module and os.path with an alias. These modules provide operating system functionality and path manipulation utilities.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pyflakes/F402.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport os.path as path\n```\n\n----------------------------------------\n\nTITLE: Conditional Function Definitions in Python\nDESCRIPTION: Demonstrates how conditionally defined functions replace or shadow previous definitions. Function 'f' is redefined in an always-executed branch, while 'g' keeps its original definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f() -> int:\n    return 1\n\ndef g() -> int:\n    return 1\n\nif True:\n    def f() -> str:\n        return \"\"\n\nelse:\n    def g() -> str:\n        return \"\"\n\nreveal_type(f())  # revealed: str\nreveal_type(g())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies Specification\nDESCRIPTION: Lists required Python packages with version constraints. Includes core dependencies like PyYAML and ruff, along with documentation tools like mkdocs and its plugins. Features a specific git reference for mkdocs-material-insiders package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/requirements-insiders.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nPyYAML==6.0.2\nruff==0.9.10\nmkdocs==1.6.1\nmkdocs-material @ git+ssh://git@github.com/astral-sh/mkdocs-material-insiders.git@39da7a5e761410349e9a1b8abf593b0cdd5453ff\nmkdocs-redirects==1.2.2\nmdformat==0.7.22\nmdformat-mkdocs==4.1.2\n```\n\n----------------------------------------\n\nTITLE: Defining Lists with Boolean Literals (Input)\nDESCRIPTION: These snippets demonstrate how lists containing boolean literals with varying levels of parentheses are defined in the original input.  These are the 'before' state before any formatting is applied by Black or Ruff.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nitems = [(True)]\nitems = [(((((True)))))]\n```\n\n----------------------------------------\n\nTITLE: Git Commit Hash Reference\nDESCRIPTION: A 40-character SHA-1 Git commit hash that uniquely identifies a specific commit in the repository history.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/vendor/typeshed/source_commit.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nf65bdc1acde54fda93c802459280da74518d2eef\n```\n\n----------------------------------------\n\nTITLE: Python Package Requirements with Fixed Versions\nDESCRIPTION: Defines exact versions of Python packages required for the project, including Ruff for linting, MkDocs for documentation generation, and various Markdown formatting tools.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nPyYAML==6.0.2\nruff==0.9.10\nmkdocs==1.6.1\nmkdocs-material==9.5.38\nmkdocs-redirects==1.2.2\nmdformat==0.7.22\nmdformat-mkdocs==4.1.2\n```\n\n----------------------------------------\n\nTITLE: Chained Comparisons with Custom Bool Implementation\nDESCRIPTION: Shows how Python handles chained comparisons when objects don't properly implement __bool__. Demonstrates type checking errors with custom classes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass NotBoolable:\n    __bool__: int = 3\n\nclass Comparable:\n    def __lt__(self, item) -> NotBoolable:\n        return NotBoolable()\n\n    def __gt__(self, item) -> NotBoolable:\n        return NotBoolable()\n\n10 < Comparable() < 20\n10 < Comparable() < Comparable()\n\nComparable() < Comparable()  # fine\n```\n\n----------------------------------------\n\nTITLE: Invalid Forms of Callable Annotations in Python\nDESCRIPTION: Explains that invalid forms of Callable annotations are never fully-static because they are represented with the `(...) -> Unknown` signature. Shows examples of invalid Callable annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_fully_static.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstatic_assert(not is_fully_static(Callable))\n# error: [invalid-type-form]\nstatic_assert(not is_fully_static(Callable[int, int]))\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Negation with Not in Python\nDESCRIPTION: Demonstrates how to use the Not special form to negate types. Shows type revealing, static type checking, and handling of negated literals.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_api.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\nfrom knot_extensions import Not, static_assert\n\ndef negate(n1: Not[int], n2: Not[Not[int]], n3: Not[Not[Not[int]]]) -> None:\n    reveal_type(n1)  # revealed: ~int\n    reveal_type(n2)  # revealed: int\n    reveal_type(n3)  # revealed: ~int\n\n# error: \"Special form `knot_extensions.Not` expected exactly one type parameter\"\nn: Not[int, str]\n\ndef static_truthiness(not_one: Not[Literal[1]]) -> None:\n    # TODO: `bool` is not incorrect, but these would ideally be `Literal[True]` and `Literal[False]`\n    # respectively, since all possible runtime objects that are created by the literal syntax `1`\n    # are members of the type `Literal[1]`\n    reveal_type(not_one is not 1)  # revealed: bool\n    reveal_type(not_one is 1)  # revealed: bool\n\n    # But these are both `bool`, rather than `Literal[True]` or `Literal[False]`\n    # as there are many runtime objects that inhabit the type `~Literal[1]`\n    # but still compare equal to `1`. Two examples are `1.0` and `True`.\n    reveal_type(not_one != 1)  # revealed: bool\n    reveal_type(not_one == 1)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Missing Comma in Error Codes List in Python\nDESCRIPTION: Shows that omitting a comma between error codes results in an invalid-ignore-comment error and fails to suppress the errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/knot_ignore.md#2025-04-17_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference]\n# error: [invalid-ignore-comment] \"Invalid `knot: ignore` comment: expected a comma separating the rule codes\"\na = x / 0  # knot: ignore[division-by-zero unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Running Markdown Tests with Cargo\nDESCRIPTION: This bash command demonstrates how to run only the Markdown-based tests using Cargo. It filters the tests using the 'mdtest__' prefix.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md#2025-04-17_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncargo test -p red_knot_python_semantic -- mdtest__\n```\n\n----------------------------------------\n\nTITLE: Installing UV Package Manager on Unix Systems\nDESCRIPTION: Command to download and install the UV package manager on Unix-based systems using curl\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/knot_benchmark/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n\n----------------------------------------\n\nTITLE: Type Ignore Comments in @no_type_check Blocks\nDESCRIPTION: Demonstrates handling of type ignore comments within @no_type_check decorated functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test():\n    # error: [unused-ignore-comment] \"Unused `knot: ignore` directive: 'unresolved-reference'\"\n    return x + 5  # knot: ignore[unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Only Reflected Operation Supported in Binary Operations in Python\nDESCRIPTION: Demonstrates a case where only the reflected operation is supported, similar to how built-in types like int and float behave with addition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __sub__(self, other: \"A\") -> \"A\":\n        return A()\n\nclass B:\n    def __rsub__(self, other: A) -> \"B\":\n        return B()\n\nreveal_type(A() - B())  # revealed: B\n```\n\n----------------------------------------\n\nTITLE: Setting up tracing in Rust tests\nDESCRIPTION: Code snippet showing how to implement tracing functionality within Rust tests using the setup_logging helper function.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse ruff_db::testing::setup_logging;\n\n#[test]\nfn test() {\n  let _logging = setup_logging();\n\n  tracing::info!(\"This message will be printed to stderr\");\n}\n```\n\n----------------------------------------\n\nTITLE: Single Comment in Python\nDESCRIPTION: Code block containing only a single line comment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# just a comment in this cell\n```\n\n----------------------------------------\n\nTITLE: Division by Zero Error with Union Types\nDESCRIPTION: Demonstrates that if any element in a union type could lead to division by zero, a division-by-zero error will be reported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/unions.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef f5(m: int, n: Literal[-1, 0, 1]):\n    # error: [division-by-zero] \"Cannot divide object of type `int` by zero\"\n    return m / n\n```\n\n----------------------------------------\n\nTITLE: Empty Python Code Block\nDESCRIPTION: Code block containing only newlines with no actual code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\n\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Multiple Expression Pattern\nDESCRIPTION: Multiple expressions with B018 warning comment on first expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Only skip the last expression\nx  # B018\nx\n```\n\n----------------------------------------\n\nTITLE: Duplicate Matplotlib Magic Commands in Python Function\nDESCRIPTION: A Python function containing duplicate Jupyter magic commands for listing matplotlib backends. The redundant command %matplotlib --list is used twice consecutively.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/unused_variable_expected.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    %matplotlib --list\n    %matplotlib --list\n```\n\n----------------------------------------\n\nTITLE: Rust Node Rule Implementation\nDESCRIPTION: Example implementation of a Node formatting rule in Rust\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl FormatNodeRule<StmtReturn> for FormatStmtReturn {\n    fn fmt_fields(&self, item: &StmtReturn, f: &mut PyFormatter) -> FormatResult<()> {\n        let StmtReturn { range: _, value } = item;\n        if let Some(value) = value {\n            write!(\n                f,\n                [\n                    text(\"return\"),\n                    space(),\n                    value.format().with_options(Parenthesize::IfBreaks)\n                ]\n            )\n        } else {\n            text(\"return\").fmt(f)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Line Semicolon Usage\nDESCRIPTION: Example showing multiple lines with semicolons where only the last semicolon should be flagged as E703\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Only skip the last expression\nx;  # E703\nx;\n```\n\n----------------------------------------\n\nTITLE: Testing Disjointness of Type Intersections in Python\nDESCRIPTION: This code demonstrates complex disjointness relationships involving type intersections. It shows how disjointness propagates through intersections, and how negated types (Not[T]) interact with their positive counterparts in determining disjointness.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Literal, final, Any\nfrom knot_extensions import Intersection, is_disjoint_from, static_assert, Not\n\n@final\nclass P: ...\n\n@final\nclass Q: ...\n\n@final\nclass R: ...\n\n# For three pairwise disjoint classes ...\nstatic_assert(is_disjoint_from(P, Q))\nstatic_assert(is_disjoint_from(P, R))\nstatic_assert(is_disjoint_from(Q, R))\n\n# ... their intersections are also disjoint:\nstatic_assert(is_disjoint_from(Intersection[P, Q], R))\nstatic_assert(is_disjoint_from(Intersection[P, R], Q))\nstatic_assert(is_disjoint_from(Intersection[Q, R], P))\n\n# On the other hand, for non-disjoint classes ...\nclass X: ...\nclass Y: ...\nclass Z: ...\n\nstatic_assert(not is_disjoint_from(X, Y))\nstatic_assert(not is_disjoint_from(X, Z))\nstatic_assert(not is_disjoint_from(Y, Z))\n\n# ... their intersections are also not disjoint:\nstatic_assert(not is_disjoint_from(Intersection[X, Y], Z))\nstatic_assert(not is_disjoint_from(Intersection[X, Z], Y))\nstatic_assert(not is_disjoint_from(Intersection[Y, Z], X))\n\n# If one side has a positive fully-static element and the other side has a negative of that element, they are disjoint\nstatic_assert(is_disjoint_from(int, Not[int]))\nstatic_assert(is_disjoint_from(Intersection[X, Y, Not[Z]], Intersection[X, Z]))\nstatic_assert(is_disjoint_from(Intersection[X, Not[Literal[1]]], Literal[1]))\n\nclass Parent: ...\nclass Child(Parent): ...\n\nstatic_assert(not is_disjoint_from(Parent, Child))\nstatic_assert(not is_disjoint_from(Parent, Not[Child]))\nstatic_assert(not is_disjoint_from(Not[Parent], Not[Child]))\nstatic_assert(is_disjoint_from(Not[Parent], Child))\nstatic_assert(is_disjoint_from(Intersection[X, Not[Parent]], Child))\nstatic_assert(is_disjoint_from(Intersection[X, Not[Parent]], Intersection[X, Child]))\n\nstatic_assert(not is_disjoint_from(Intersection[Any, X], Intersection[Any, Not[Y]]))\nstatic_assert(not is_disjoint_from(Intersection[Any, Not[Y]], Intersection[Any, X]))\n\nstatic_assert(is_disjoint_from(Intersection[int, Any], Not[int]))\nstatic_assert(is_disjoint_from(Not[int], Intersection[int, Any]))\n```\n\n----------------------------------------\n\nTITLE: Relative Import with Unknown Current Module in Python\nDESCRIPTION: This snippet illustrates the error when using a relative import (.) in a context where the current module is unknown or unresolvable. It shows how Ruff handles relative imports in ambiguous contexts.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom .does_not_exist import add  # error: [unresolved-import]\n\nstat = add(10, 15)\n```\n\n----------------------------------------\n\nTITLE: Declared and Unbound Symbol Usage in Python\nDESCRIPTION: Illustrates type inference for declared but unbound symbols, where the declared type is used without error raising.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/boundness_declaredness/public.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\na: int\nb: Any\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom mod import a, b\n\nreveal_type(a)  # revealed: int\nreveal_type(b)  # revealed: Any\n```\n\n----------------------------------------\n\nTITLE: Accessing Function-Literal Attributes\nDESCRIPTION: Shows how attributes on function literals are delegated to types.FunctionType, with some special-cased attributes.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f(): ...\n\nreveal_type(f.__defaults__)  # revealed: @Todo(full tuple[...] support) | None\nreveal_type(f.__kwdefaults__)  # revealed: @Todo(generics) | None\n```\n\n----------------------------------------\n\nTITLE: Managing Call Binding Errors with Wrong Self Type in Python\nDESCRIPTION: This snippet illustrates a case where the self parameter of the __call__ method has an incorrect type annotation, leading to type errors when calling the instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/callable_instance.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    # TODO this definition should also be an error; `C` must be assignable to type of `self`\n    def __call__(self: int) -> int:\n        return 1\n\nc = C()\n\n# error: 13 [invalid-argument-type] \"Argument to this function is incorrect: Expected `int`, found `C`\"\nreveal_type(c())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Installing UV Package Manager on Windows\nDESCRIPTION: PowerShell command to download and install the UV package manager on Windows systems\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/knot_benchmark/README.md#2025-04-17_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Single-Valued Types\nDESCRIPTION: Demonstrates type narrowing with custom class types. Shows how the type system handles comparisons between single-valued types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not_eq.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A: ...\n    class B: ...\n    C = A if flag else B\n\n    if C != A:\n        reveal_type(C)  # revealed: Literal[B]\n    else:\n        # TODO should be Literal[A]\n        reveal_type(C)  # revealed: Literal[A, B]\n```\n\n----------------------------------------\n\nTITLE: Rust While Statement Formatter Implementation\nDESCRIPTION: Rust implementation for formatting while statements, showing how different types of comments are handled and placed in the output.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn fmt_fields(&self, item: &StmtWhile, f: &mut PyFormatter) -> FormatResult<()> {\n\n    // ...\n\n    // See FormatStmtWhile for the real, more complex implementation\n    let first_while_body_stmt = item.body.first().unwrap().end();\n    let trailing_condition_comments_end =\n        dangling_comments.partition_point(|comment| comment.slice().end() < first_while_body_stmt);\n    let (trailing_condition_comments, or_else_comments) =\n        dangling_comments.split_at(trailing_condition_comments_end);\n\n    write!(\n        f,\n        [\n            text(\"while\"),\n            space(),\n            test.format(),\n            text(\":\"),\n            trailing_comments(trailing_condition_comments),\n            block_indent(&body.format())\n            leading_comments(or_else_comments),\n            text(\"else:\"),\n            block_indent(&orelse.format())\n        ]\n    )?\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Match Statement Syntax Error in Python\nDESCRIPTION: Shows parser behavior when using keywords incorrectly in match-case statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [invalid-syntax]\n# error: [unresolved-reference] \"Name `match` used when not defined\"\nmatch while:\n    # error: [invalid-syntax]\n    # error: [invalid-syntax]\n    # error: [invalid-syntax]\n    # error: [unresolved-reference] \"Name `case` used when not defined\"\n    case in:\n        # error: [invalid-syntax]\n        # error: [invalid-syntax]\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining Empty JSON Object\nDESCRIPTION: Creates an empty JSON object, which can be used as a base for configuration or to represent an intentionally empty state.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/wrong_schema.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Running Lexer Benchmarks\nDESCRIPTION: Shell command to run performance benchmarks for the lexer component.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench --package ruff_benchmark --bench lexer\n```\n\n----------------------------------------\n\nTITLE: Empty Python Code Block with E303 Comment\nDESCRIPTION: This snippet is an empty code block with a comment indicating a potential E303 style issue.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# E303\n```\n\n----------------------------------------\n\nTITLE: Callable Instances as Dunders in Binary Operations in Python\nDESCRIPTION: Shows an unusual but supported case where a callable instance is used as a dunder method for binary operations. Demonstrates type inference in this scenario.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/instances.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    def __call__(self, other) -> int:\n        return 42\n\nclass B:\n    __add__ = A()\n\nreveal_type(B() + B())  # revealed: Unknown | int\n\nclass B2:\n    __add__: A = A()\n\nreveal_type(B2() + B2())  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Overridden Python Version Check\nDESCRIPTION: Verifies that the overwritten Python version configuration is correctly applied.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[:2] == (3, 11))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Invalid Parameterization of LiteralString in Python\nDESCRIPTION: Demonstrates that LiteralString cannot be parameterized with other types, resulting in invalid-type-form errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal_string.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import LiteralString\n\na: LiteralString[str]  # error: [invalid-type-form]\nb: LiteralString[\"foo\"]  # error: [invalid-type-form]\n```\n\n----------------------------------------\n\nTITLE: Custom Builtin Type Stub Definition\nDESCRIPTION: Custom type stub file defining a basic builtin class and symbol.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_1\n\nLANGUAGE: pyi\nCODE:\n```\nclass BuiltinClass: ...\n\nbuiltin_symbol: BuiltinClass\n```\n\n----------------------------------------\n\nTITLE: Navigating to Benchmark Directory\nDESCRIPTION: Command to change directory to the benchmark location\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/knot_benchmark/README.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd scripts/knot_benchmark\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment in Python\nDESCRIPTION: Simple variable assignment without semicolon\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n```\n\n----------------------------------------\n\nTITLE: Importing Undeclared Symbol from Module in Python\nDESCRIPTION: Demonstrates how importing a symbol that is only declared (but not defined) in unreachable code results in an unresolved import error. The type of 'symbol' is Unknown.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_50\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-import]\nfrom module import symbol\n\nreveal_type(symbol)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Using IPython Magic Command with Function Definition in Python\nDESCRIPTION: This snippet defines a function and uses the IPython magic command %matplotlib inline. It showcases how to integrate IPython-specific functionality within Python code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/unformatted.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# A cell with IPython escape command\ndef some_function(foo, bar):\n    pass\n%matplotlib inline\n```\n\n----------------------------------------\n\nTITLE: GitHub Workflow Path Reference\nDESCRIPTION: Path to the GitHub workflow file responsible for automated typeshed synchronization.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_vendored/README.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n.github/workflows/sync_typeshed.yaml\n```\n\n----------------------------------------\n\nTITLE: Edge Case: Assignment to Attribute Not on Instance\nDESCRIPTION: Demonstrates that assigning to an attribute on another object doesn't make it available on the instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nclass Other:\n    x: int = 1\n\nclass C:\n    def __init__(self, other: Other) -> None:\n        other.x = 1\n\ndef f(c: C):\n    # error: [unresolved-attribute]\n    reveal_type(c.x)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Basic Function Body Type Check Suppression with @no_type_check\nDESCRIPTION: Demonstrates how @no_type_check suppresses type checking errors in the main function body, allowing undefined variable usage.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\ndef test() -> int:\n    return a + 5\n```\n\n----------------------------------------\n\nTITLE: Handling Class-Declared but Unbound Variables in Python\nDESCRIPTION: Demonstrates the behavior of variables declared in the class body but not bound anywhere. Shows how these are treated as pure instance variables.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass C:\n    only_declared: str\n\nc_instance = C()\n\nreveal_type(c_instance.only_declared)  # revealed: str\n\n# Mypy and pyright do not show an error here. We treat this as a pure instance variable.\n# error: [unresolved-attribute] \"Attribute `only_declared` can only be accessed on instances, not on the class object `Literal[C]` itself.\"\nreveal_type(C.only_declared)  # revealed: Unknown\n\n# error: [invalid-attribute-access] \"Cannot assign to instance attribute `only_declared` from the class object `Literal[C]`\"\nC.only_declared = \"overwritten on class\"\n```\n\n----------------------------------------\n\nTITLE: Testing Possibly Unbound __iter__ and __getitem__ in Python\nDESCRIPTION: Tests type inference when both __iter__ and __getitem__ methods may be unbound depending on runtime conditions. The system should infer the element type as a union of the possible return types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/loops/for.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\nclass Iterator:\n    def __next__(self) -> int:\n        return 42\n\ndef _(flag1: bool, flag2: bool):\n    class Iterable:\n        if flag1:\n            def __iter__(self) -> Iterator:\n                return Iterator()\n        if flag2:\n            def __getitem__(self, key: int) -> bytes:\n                return bytes()\n\n    # error: [not-iterable]\n    for x in Iterable():\n        reveal_type(x)  # revealed: int | bytes\n```\n\n----------------------------------------\n\nTITLE: Conditionally Mutated __all__ in Python 3.11\nDESCRIPTION: Environment configuration for Python 3.11, which affects how conditionally mutated __all__ will be resolved in subsequent code examples.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\n----------------------------------------\n\nTITLE: Simple Variable Reference\nDESCRIPTION: Basic reference to variable x with a comment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Simple case\nx\n```\n\n----------------------------------------\n\nTITLE: Running Red Knot Benchmarks\nDESCRIPTION: Command to execute the benchmarks using UV package manager\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/knot_benchmark/README.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nuv run benchmark\n```\n\n----------------------------------------\n\nTITLE: Rust Tuple Formatting Example\nDESCRIPTION: Example of formatting a tuple with conditional line breaks in Rust\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nwrite!(\n    f,\n    [group(&format_args![\n        text(\"(\"),\n        soft_block_indent(&format_args![\n            item1.format()\n            text(\",\"),\n            soft_line_break_or_space(),\n            item2.format(),\n            if_group_breaks(&text(\",\"))\n        ]),\n        text(\")\")\n    ])])\n```\n\n----------------------------------------\n\nTITLE: Preparing CPython for Pylint Benchmarking\nDESCRIPTION: Remove specific files from the CPython repository to prepare it for Pylint benchmarking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nrm Lib/test/bad_coding.py \\\n  Lib/test/bad_coding2.py \\\n  Lib/test/bad_getattr.py \\\n  Lib/test/bad_getattr2.py \\\n  Lib/test/bad_getattr3.py \\\n  Lib/test/badcert.pem \\\n  Lib/test/badkey.pem \\\n  Lib/test/badsyntax_3131.py \\\n  Lib/test/badsyntax_future10.py \\\n  Lib/test/badsyntax_future3.py \\\n  Lib/test/badsyntax_future4.py \\\n  Lib/test/badsyntax_future5.py \\\n  Lib/test/badsyntax_future6.py \\\n  Lib/test/badsyntax_future7.py \\\n  Lib/test/badsyntax_future8.py \\\n  Lib/test/badsyntax_future9.py \\\n  Lib/test/badsyntax_pep3120.py \\\n  Lib/test/test_asyncio/test_runners.py \\\n  Lib/test/test_copy.py \\\n  Lib/test/test_inspect.py \\\n  Lib/test/test_typing.py\n```\n\n----------------------------------------\n\nTITLE: Static Assertions on Callables and Literal Types Disjointness\nDESCRIPTION: This snippet confirms that callable types are disjoint from literal types using static assertions. It checks a series of callable definitions against various literal values asserting their disjoint nature.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import CallableTypeOf, is_disjoint_from, static_assert\nfrom typing_extensions import Callable, Literal, Never\n\nstatic_assert(is_disjoint_from(Callable[[], None], Literal[\"\"]))\nstatic_assert(is_disjoint_from(Callable[[], None], Literal[b\"\" ]))\nstatic_assert(is_disjoint_from(Callable[[], None], Literal[1]))\nstatic_assert(is_disjoint_from(Callable[[], None], Literal[True]))\n```\n\n----------------------------------------\n\nTITLE: Importing os and pathlib Modules in Python\nDESCRIPTION: This snippet demonstrates importing the os module and accessing os.path, as well as importing the pathlib module. These modules are commonly used for file and path operations in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nos.path\n\nimport pathlib\n```\n\n----------------------------------------\n\nTITLE: Handling Complex Type Expressions with Python's `cast` Function\nDESCRIPTION: This snippet demonstrates how `cast` handles complex type expressions, particularly with Callable and nested dictionary types. It shows that complex types do not trigger spurious `[redundant-cast]` diagnostics.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/directives/cast.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef f(x: Callable[[dict[str, int]], None], y: tuple[dict[str, int]]):\n    a = cast(Callable[[list[bytes]], None], x)\n    b = cast(tuple[list[bytes]], y)\n```\n\n----------------------------------------\n\nTITLE: Class Decoration Limitations\nDESCRIPTION: Shows that @no_type_check is not supported on class definitions, as the behavior is not specified in the typing spec.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/no_type_check.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import no_type_check\n\n@no_type_check\nclass Test:\n    def test(self):\n        return a + 5  # error: [unresolved-reference]\n```\n\n----------------------------------------\n\nTITLE: Possibly Unbound __class_getitem__ Method with Union Types\nDESCRIPTION: Shows an error case where a class might conditionally implement __class_getitem__, leading to a potentially unbound method error during static type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    if flag:\n        class Spam:\n            def __class_getitem__(self, x: int) -> str:\n                return \"foo\"\n\n    else:\n        class Spam: ...\n    # error: [call-possibly-unbound-method] \"Method `__class_getitem__` of type `Literal[Spam, Spam]` is possibly unbound\"\n    # revealed: str\n    reveal_type(Spam[42])\n```\n\n----------------------------------------\n\nTITLE: Function with Invalid Star Import\nDESCRIPTION: Shows a function containing a star import, which is invalid Python syntax. The type checker should emit a syntax error for this code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    # TODO: we should emit a syntax errror here (tracked by https://github.com/astral-sh/ruff/issues/11934)\n    from exporter import *\n\n    # error: [unresolved-reference]\n    reveal_type(X)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Testing Non-Equivalence of Callable Types with Different Parameter Names\nDESCRIPTION: This code demonstrates that callable types with different parameter names are not equivalent. Unlike positional-only or variadic parameters, regular parameter names are part of the callable's type identity.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef f5(a: int) -> None: ...\ndef f6(b: int) -> None: ...\n\nstatic_assert(not is_equivalent_to(CallableTypeOf[f5], CallableTypeOf[f6]))\n```\n\n----------------------------------------\n\nTITLE: Example diff output after adding noqa directives (diff)\nDESCRIPTION: This shows the output of `git diff` after running the `--add-noqa` command. It highlights the addition of the `# noqa: UP035` directive to a line in the `calculate.py` file where a violation of the `UP035` rule was detected.  This effectively ignores the existing violation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/tutorial.md#2025-04-17_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/numbers/src/numbers/calculate.py b/numbers/src/numbers/calculate.py\nindex 71fca60c8d..e92d839f1b 100644\n--- a/numbers/src/numbers/calculate.py\n+++ b/numbers/src/numbers/calculate.py\n@@ -1,4 +1,4 @@\n-from typing import Iterable\n+from typing import Iterable  # noqa: UP035\n```\n\n----------------------------------------\n\nTITLE: Implementing __len__ with Incorrect Signatures in Python\nDESCRIPTION: This snippet shows custom class implementations of `__len__` with incorrect signatures, either with optional or required arguments. It highlights the need for diagnostics to be emitted in these cases.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/expression/len.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass SecondOptionalArgument:\n    def __len__(self, v: int = 0) -> Literal[0]:\n        return 0\n\nclass SecondRequiredArgument:\n    def __len__(self, v: int) -> Literal[1]:\n        return 1\n\n# TODO: Emit a diagnostic\nreveal_type(len(SecondOptionalArgument()))  # revealed: Literal[0]\n\n# TODO: Emit a diagnostic\nreveal_type(len(SecondRequiredArgument()))  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Generator Expression Resolution\nDESCRIPTION: Illustrates how generator expressions typically evaluate eagerly in practice, though they can have delayed evaluation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/eager.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    x = 1\n\n    # revealed: Literal[1]\n    list(reveal_type(x) for a in range(1))\n\n    x = 2\n```\n\n----------------------------------------\n\nTITLE: Basic Float Type Revelation in Python\nDESCRIPTION: Shows how to use reveal_type() to check the type of a float literal. The reveal_type function is a special construct used in type checking that shows the inferred type of an expression.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/float.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(1.0)  # revealed: float\n```\n\n----------------------------------------\n\nTITLE: Integer Overflow Type Inference\nDESCRIPTION: Shows type inference behavior for integers outside the i64 range.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/literal/integer.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(9223372036854775808)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Binary Expression Collapsing: Ruff vs Black\nDESCRIPTION: This snippet illustrates how Ruff may collapse composite binary expressions more aggressively than Black if it allows the expression to fit within the configured line width.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Black\nassert AAAAAAAAAAAAAAAAAAAAAA.bbbbbb.fooo(\n    aaaaaaaaaaaa=aaaaaaaaaaaa\n).ccccc() == (len(aaaaaaaaaa) + 1) * fooooooooooo * (\n    foooooo + 1\n) * foooooo * len(\n    list(foo(bar(4, foo), foo))\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Ruff\nassert AAAAAAAAAAAAAAAAAAAAAA.bbbbbb.fooo(\n    aaaaaaaaaaaa=aaaaaaaaaaaa\n).ccccc() == (len(aaaaaaaaaa) + 1) * fooooooooooo * (\n    foooooo + 1\n) * foooooo * len(list(foo(bar(4, foo), foo)))\n```\n\n----------------------------------------\n\nTITLE: Setting Attributes on Union Types in Python\nDESCRIPTION: Illustrates setting attributes on union types, demonstrating cases where the assignment may fail due to type incompatibility or where the type checker may not catch potential errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool) -> None:\n    if flag:\n        class C1:\n            attr: int = 0\n\n    else:\n        class C1:\n            attr: str = \"\"\n\n    # TODO: The error message here could be improved to explain why the assignment fails.\n    C1.attr = 1  # error: [invalid-assignment]\n\n    class C2:\n        if flag:\n            attr: int = 0\n        else:\n            attr: str = \"\"\n\n    # TODO: This should be an error\n    C2.attr = 1\n```\n\n----------------------------------------\n\nTITLE: Instantiating a class with no __init__ or __new__ methods in Python\nDESCRIPTION: Shows the default behavior when instantiating a class that doesn't define __init__ or __new__ methods, including type revelation and error handling for unexpected arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/constructor.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n\nreveal_type(Foo())  # revealed: Foo\n\n# error: [too-many-positional-arguments] \"Too many positional arguments to bound method `__init__`: expected 0, got 1\"\nreveal_type(Foo(1))  # revealed: Foo\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Typevar Usage Outside Generic Contexts in Python\nDESCRIPTION: This snippet shows incorrect usage of typevars outside of generic function or class definitions, which should result in errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n# TODO: error\nx: T\n\nclass C:\n    # TODO: error\n    x: T\n\ndef f() -> None:\n    # TODO: error\n    x: T\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Types on Class and Instance in Python\nDESCRIPTION: Illustrates the different types returned when accessing a method on a class object versus an instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(C.f)  # revealed: def f(self, x: int) -> str\nreveal_type(C().f)  # revealed: bound method C.f(x: int) -> str\n```\n\n----------------------------------------\n\nTITLE: Using typing.Never in Python 3.11\nDESCRIPTION: Shows how to import and use typing.Never in Python 3.11, where it is natively available in the typing module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/never.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-version = \"3.11\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Never\n\nreveal_type(Never)  # revealed: typing.Never\n```\n\n----------------------------------------\n\nTITLE: Cyclic Star Import Module B\nDESCRIPTION: Second module in a cyclic star import example. Module b imports all from a and defines B, creating a circular dependency that Python handles without exceptions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom a import *\n\nB: bool = True\n```\n\n----------------------------------------\n\nTITLE: Comparison Expression with Comments and Whitespace\nDESCRIPTION: A comparison expression surrounded by comments and whitespace, testing that the linter correctly identifies the expression regardless of surrounding non-code elements.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Comments, newlines and whitespace\nx == 1 # comment\n\n# another comment\n```\n\n----------------------------------------\n\nTITLE: Platform Check Analysis Configuration\nDESCRIPTION: Configuration for platform-based branch analysis.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\npython-platform = \"linux\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Set with a Numeric Literal (Input)\nDESCRIPTION: This snippet shows how a set containing a numeric literal is defined in the original input, prior to formatting by Black or Ruff.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/formatter/black.md#2025-04-17_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nitems = {(123)}\n```\n\n----------------------------------------\n\nTITLE: File-Level Type Error Suppression in Python\nDESCRIPTION: Example showing how to suppress all type errors in a file using a `type: ignore` comment at the file level.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# type: ignore\n\na = 10 / 0\nb = a / 0\n```\n\n----------------------------------------\n\nTITLE: Configuring RED_KNOT_LOG to show messages for a specific file\nDESCRIPTION: Environment variable setup that filters tracing output to only display messages related to a specific file.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRED_KNOT_LOG=red_knot[{file=/home/micha/astral/test/x.py}]=trace\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'not isinstance' Check\nDESCRIPTION: Shows type narrowing behavior when using 'not isinstance' check with a Union type. Demonstrates how a variable of type Union[int, str] gets narrowed to specific literal types in each branch.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/not.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else \"a\"\n\n    if not isinstance(x, (int)):\n        reveal_type(x)  # revealed: Literal[\"a\"]\n    else:\n        reveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Implementing Cyclical Class References in Python Type Stubs\nDESCRIPTION: Demonstrates how classes can reference themselves in their base class definitions within type stubs. This pattern is commonly used in typeshed, for example in the str class definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/class.md#2025-04-17_snippet_0\n\nLANGUAGE: pyi\nCODE:\n```\nclass Foo[T]: ...\n\nclass Bar(Foo[Bar]): ...\n\nreveal_type(Bar)  # revealed: Literal[Bar]\nreveal_type(Bar.__mro__)  # revealed: tuple[Literal[Bar], Literal[Foo[Bar]], Literal[object]]\n```\n\n----------------------------------------\n\nTITLE: Duplicate Shell Commands in Python Function\nDESCRIPTION: A Python function containing duplicate shell commands using Jupyter's magic command syntax. The !pwd command to print working directory is used twice consecutively.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/unused_variable_expected.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    !pwd\n    !pwd\n```\n\n----------------------------------------\n\nTITLE: Method Calls on KnownInstance Types in Python 3.12\nDESCRIPTION: Shows method calls on KnownInstance types, specifically for TypeAliasType in Python 3.12.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/methods.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntype IntOrStr = int | str\n\nreveal_type(IntOrStr.__or__)  # revealed: bound method typing.TypeAliasType.__or__(right: Any) -> _SpecialForm\n```\n\n----------------------------------------\n\nTITLE: Unbound Variable with 'if True...else' in Python\nDESCRIPTION: Demonstrates how variables defined only in unreachable else blocks are considered unbound. Attempting to access 'x' results in an unresolved reference error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nif True:\n    pass\nelse:\n    x = 1\n\n# error: [unresolved-reference]\nx\n```\n\n----------------------------------------\n\nTITLE: None Handling in If Expression\nDESCRIPTION: Demonstrates if-expression with None as alternative value, showing type revelation as union of Literal and None.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/conditional/if_expression.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    x = 1 if flag else None\n    reveal_type(x)  # revealed: Literal[1] | None\n```\n\n----------------------------------------\n\nTITLE: Token Stream Output Example\nDESCRIPTION: Example output from 'cargo dev print-tokens' command showing the token stream for a Python if statement. Displays token types, content, and position information.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_17\n\nLANGUAGE: text\nCODE:\n```\n0 If 2\n3 True 7\n7 Colon 8\n9 Pass 13\n14 Comment(\n    \"# comment\",\n) 23\n23 Newline 24\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Re-export in Python Stub File\nDESCRIPTION: This snippet shows a conditional re-export in a stub file. The import of Foo from module 'a' is marked as possibly unbound due to the conditional nature of the re-export.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Member `Foo` of module `a` is possibly unbound\"\nfrom a import Foo\n\nreveal_type(Foo)  # revealed: str\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom b import Foo\n\ndef coinflip() -> bool: ...\n\nif coinflip():\n    Foo: str = ...\n\nreveal_type(Foo)  # revealed: Literal[Foo] | str\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Blank Lines in Python\nDESCRIPTION: This snippet shows how to define a function in Python with blank lines before and after the definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n\ndef function2():\n\tpass\n# end\n```\n\n----------------------------------------\n\nTITLE: File-Level Type Error Suppression with Shebang in Python\nDESCRIPTION: Example showing that file-level type error suppression works even with a leading shebang line.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/suppressions/type_ignore.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env/python\n# type: ignore\n\na = 10 / 0\nb = a / 0\n```\n\n----------------------------------------\n\nTITLE: Printing Undefined Variable in Python\nDESCRIPTION: Attempts to print an undefined variable, which would raise a NameError at runtime since 'undefined' is not defined.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/undefined_name.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(undefined)\n```\n\n----------------------------------------\n\nTITLE: Importing Invalid Base Class in Python\nDESCRIPTION: Shows the import of the invalid Base class from the base module, which should not trigger an error during import.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/regression/14334_diagnostics_in_wrong_file.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# No error here\nfrom base import Base\n```\n\n----------------------------------------\n\nTITLE: Installing Hyperfine Benchmarking Tool\nDESCRIPTION: Install the Hyperfine benchmarking tool using Cargo. Hyperfine is used for running comparative benchmarks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo install hyperfine\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple[Never] Type Equivalence in Python\nDESCRIPTION: Code showing that tuple types containing Never are equivalent to Never itself using static assertions. The example demonstrates that tuples with Never in any position are equivalent to Never because such types are uninhabited.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/tuples_containing_never.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_equivalent_to\nfrom typing_extensions import Never, NoReturn\n\nstatic_assert(is_equivalent_to(Never, tuple[Never]))\nstatic_assert(is_equivalent_to(Never, tuple[Never, int]))\nstatic_assert(is_equivalent_to(Never, tuple[int, Never]))\nstatic_assert(is_equivalent_to(Never, tuple[int, Never, str]))\nstatic_assert(is_equivalent_to(Never, tuple[int, tuple[str, Never]]))\nstatic_assert(is_equivalent_to(Never, tuple[tuple[str, Never], int]))\n\ndef _(x: tuple[Never], y: tuple[int, Never], z: tuple[Never, int]):\n    reveal_type(x)  # revealed: Never\n    reveal_type(y)  # revealed: Never\n    reveal_type(z)  # revealed: Never\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Homebrew\nDESCRIPTION: Shows the command to install Ruff using Homebrew package manager for macOS and Linux.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ brew install ruff\n```\n\n----------------------------------------\n\nTITLE: Importing Unresolvable Item from Resolvable Module in Python\nDESCRIPTION: This snippet shows the error when importing an unresolvable item from an otherwise resolvable module. It demonstrates how Ruff pinpoints the specific unresolvable item in a multi-import statement.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom a import does_exist1, does_not_exist, does_exist2  # error: [unresolved-import]\n```\n\n----------------------------------------\n\nTITLE: Using the Ellipsis Symbol Instead of Literal in Stub Files\nDESCRIPTION: The special behavior only applies to the ellipsis literal (...) in stub files, not to the builtin name Ellipsis. Using the Ellipsis symbol will result in type errors.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# error: 7 [invalid-parameter-default] \"Default value of type `ellipsis` is not assignable to annotated parameter type `int`\"\ndef f(x: int = Ellipsis) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Addition with Comment and Newlines\nDESCRIPTION: Simple addition operation followed by a comment and multiple empty lines.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n1 + 1\n# a comment\n\n\n\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Always True 'or' Boolean Expression in Python\nDESCRIPTION: Demonstrates how type inference handles short-circuit evaluation in 'or' expressions with a true first operand. Only the first assignment expression is evaluated.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n(x := 1) or (x := 2)\n\nreveal_type(x)  # revealed: Literal[1]\n\n(y := 1) or (y := 2) or (y := 3) or (y := 4)\n\nreveal_type(y)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Testing Deep Nested Type Equivalence with Unions and Intersections\nDESCRIPTION: This code tests equivalence of deeply nested type structures, including unions containing tuples containing tuples containing unions, and deeply nested intersections. It demonstrates that type equivalence is preserved through arbitrary nesting.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_equivalent_to, static_assert, Intersection\n\nclass P: ...\nclass Q: ...\n\nstatic_assert(\n    is_equivalent_to(\n        tuple[tuple[tuple[P | Q]]] | P,\n        tuple[tuple[tuple[Q | P]]] | P,\n    )\n)\nstatic_assert(\n    is_equivalent_to(\n        tuple[tuple[tuple[tuple[tuple[Intersection[P, Q]]]]]],\n        tuple[tuple[tuple[tuple[tuple[Intersection[Q, P]]]]]],\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Type Assignability in Python\nDESCRIPTION: Demonstrates the basic assignability relation for fully static types that participate in subtyping. It shows how class inheritance hierarchies affect assignability, where subtypes are assignable to their supertypes but not vice versa.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import static_assert, is_assignable_to\n\nclass Parent: ...\nclass Child1(Parent): ...\nclass Child2(Parent): ...\nclass Grandchild(Child1, Child2): ...\nclass Unrelated: ...\n\nstatic_assert(is_assignable_to(int, int))\nstatic_assert(is_assignable_to(Parent, Parent))\nstatic_assert(is_assignable_to(Child1, Parent))\nstatic_assert(is_assignable_to(Grandchild, Parent))\nstatic_assert(is_assignable_to(Unrelated, Unrelated))\n\nstatic_assert(not is_assignable_to(str, int))\nstatic_assert(not is_assignable_to(object, int))\nstatic_assert(not is_assignable_to(Parent, Child1))\nstatic_assert(not is_assignable_to(Unrelated, Parent))\nstatic_assert(not is_assignable_to(Child1, Child2))\n```\n\n----------------------------------------\n\nTITLE: Rule Code Remapping\nDESCRIPTION: Rule code remapping where unsafe-markup-use is changed from RUF035 to S704.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nunsafe-markup-use: RUF035 -> S704\n```\n\n----------------------------------------\n\nTITLE: Class Definition with Dunder Methods\nDESCRIPTION: Defines classes with dunder methods and demonstrates type checking for direct class operations. Shows that operators don't work on class types without type-level dunder methods.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/binary/custom.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Yes:\n    def __add__(self, other) -> Literal[\"+\"]:\n        return \"+\"\n\nclass Sub(Yes): ...\nclass No: ...\n\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `Literal[Yes]` and `Literal[Yes]`\"\nreveal_type(Yes + Yes)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `Literal[Sub]` and `Literal[Sub]`\"\nreveal_type(Sub + Sub)  # revealed: Unknown\n# error: [unsupported-operator] \"Operator `+` is unsupported between objects of type `Literal[No]` and `Literal[No]`\"\nreveal_type(No + No)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff on Alpine Linux\nDESCRIPTION: Shows how to install Ruff on Alpine Linux using the apk package manager from the testing repositories.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ apk add ruff\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-export in One Branch in Python\nDESCRIPTION: This snippet shows a conditional import where one branch doesn't re-export the symbol. This results in an error when attempting to import Foo from module 'a', as it's not guaranteed to be exported.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Module `a` has no member `Foo`\"\nfrom a import Foo\n\nreveal_type(Foo)  # revealed: Unknown\n```\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool: ...\n\nif coinflip():\n    from b import Foo\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Testing Flow-Insensitive Import Analysis in Python\nDESCRIPTION: Demonstrates how submodule access is handled before explicit import due to flow-insensitive analysis. Shows accessing a.b.C before importing a.b is allowed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/tracking.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport a\n\n# Would be an error with flow-sensitive tracking\nreveal_type(a.b.C)  # revealed: Literal[C]\n\nimport a.b\n```\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\nLANGUAGE: python\nCODE:\n```\nclass C: ...\n```\n\n----------------------------------------\n\nTITLE: Search Path Configuration\nDESCRIPTION: TOML configuration for multiple search paths\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/search-1\", \"/search-2\"]\n```\n\n----------------------------------------\n\nTITLE: Heterogeneous Literal Union Display in Python\nDESCRIPTION: Demonstrates how heterogeneous unions of Literal types are displayed, including various data types like integers, strings, bytes, and boolean values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\ndef foo(x: int) -> int:\n    return x + 1\n\ndef bar(s: str) -> str:\n    return s\n\nclass A: ...\nclass B: ...\n\ndef union_example(\n    x: Union[\n        # unknown type\n        # error: [unresolved-reference]\n        y,\n        Literal[-1],\n        Literal[\"A\"],\n        Literal[b\"A\"],\n        Literal[b\"\\x00\"],\n        Literal[b\"\\x07\"],\n        Literal[0],\n        Literal[1],\n        Literal[\"B\"],\n        Literal[\"foo\"],\n        Literal[\"bar\"],\n        Literal[\"B\"],\n        Literal[True],\n        None,\n    ],\n):\n    reveal_type(x)  # revealed: Unknown | Literal[-1, 0, 1, \"A\", \"B\", \"foo\", \"bar\", b\"A\", b\"\\x00\", b\"\\x07\", True] | None\n```\n\n----------------------------------------\n\nTITLE: Basic Metaclass Type Check\nDESCRIPTION: Demonstrates type checking of a basic metaclass definition.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/metaclass.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass M(type): ...\n\nreveal_type(M.__class__)  # revealed: Literal[type]\n```\n\n----------------------------------------\n\nTITLE: Displaying Note in Markdown\nDESCRIPTION: This markdown snippet creates a note block to provide additional information about the documentation's scope, specifically differentiating between Ruff's built-in language server and the separate ruff-lsp project.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n!!! note\n\n    This is the documentation for Ruff's built-in language server written in Rust (`ruff server`).\n    If you are looking for the documentation for the `ruff-lsp` language server, please refer to the\n    [README](https://github.com/astral-sh/ruff-lsp) of the `ruff-lsp` repository.\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Integer Tuple Membership\nDESCRIPTION: Demonstrates type checking behavior when testing integer membership in a tuple. Shows that the type remains int in both branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/in.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef _(x: int):\n    if x in (1, 2, 3):\n        reveal_type(x)  # revealed: int\n    else:\n        reveal_type(x)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Basic ModuleType Globals Type Resolution\nDESCRIPTION: Demonstrates type resolution of common ModuleType implicit globals like __name__, __file__, etc. Shows how these globals are accessible both at module level and within classes and functions.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(__name__)  # revealed: str\nreveal_type(__file__)  # revealed: str | None\nreveal_type(__loader__)  # revealed: LoaderProtocol | None\nreveal_type(__package__)  # revealed: str | None\nreveal_type(__doc__)  # revealed: str | None\nreveal_type(__spec__)  # revealed: ModuleSpec | None\n\nreveal_type(__path__)  # revealed: @Todo(generics)\n\nclass X:\n    reveal_type(__name__)  # revealed: str\n\ndef foo():\n    reveal_type(__name__)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Re-export with Both Branches as Imports in Python\nDESCRIPTION: This snippet shows a conditional re-export where both branches are import statements. One branch re-exports while the other doesn't, resulting in a possibly unbound member error.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Member `Foo` of module `a` is possibly unbound\"\nfrom a import Foo\n\nreveal_type(Foo)  # revealed: Literal[Foo]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool: ...\n\nif coinflip():\n    from b import Foo\nelse:\n    from b import Foo as Foo\n\nreveal_type(Foo)  # revealed: Literal[Foo]\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested Formal Typevar Restrictions in Generic Classes in Python\nDESCRIPTION: This snippet illustrates that generic methods within generic classes should use distinct typevars from the class.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass C[T]:\n    def ok[S](self, a: S, b: S) -> None: ...\n\n    # TODO: error\n    def bad[T](self, a: T, b: T) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with 'if True' inside 'for...else' in Python\nDESCRIPTION: Shows type analysis when an always-true condition is inside the else clause of a for loop. The variable 'x' will always be 3 after execution since the else block is always executed when the loop completes without breaking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef iterable() -> list[object]:\n    return [1, \"\"]\n\nx = 1\n\nfor _ in iterable():\n    x = 2\nelse:\n    if True:\n        x = 3\n    else:\n        x = 4\n\nreveal_type(x)  # revealed: Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Attribute Assignment Limitations with Super in Python\nDESCRIPTION: Demonstrates that super() objects do not allow attribute assignment, even when the attribute is successfully resolved through the inheritance chain.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    a: int = 3\n\nclass B(A): ...\n\nreveal_type(super(B, B()).a)  # revealed: int\n# error: [invalid-assignment] \"Cannot assign to attribute `a` on type `<super: Literal[B], B>`\"\nsuper(B, B()).a = 3\n# error: [invalid-assignment] \"Cannot assign to attribute `a` on type `super`\"\nsuper(B).a = 5\n```\n\n----------------------------------------\n\nTITLE: Disabling Fix Violation Code Actions in Ruff LSP\nDESCRIPTION: Controls whether to display Quick Fix actions to autofix violations. This can be configured in VS Code, Neovim, or Zed.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.codeAction.fixViolation.enable\": false\n}\n```\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ruff.setup {\n  init_options = {\n    settings = {\n      codeAction = {\n        fixViolation = {\n          enable = false\n        }\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"lsp\": {\n    \"ruff\": {\n      \"initialization_options\": {\n        \"settings\": {\n          \"codeAction\": {\n            \"fixViolation\": {\n              \"enable\": false\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Instance Member Access via super() in Python\nDESCRIPTION: Illustrates limitations of accessing instance members through super(). Shows that direct attribute access on a super() object may raise 'unresolved-attribute' errors during type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/class/super.md#2025-04-17_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nclass A:\n    def __init__(self, a: int):\n        self.a = a\n\nclass B(A):\n    def __init__(self, a: int):\n        super().__init__(a)\n        # TODO: Once `Self` is supported, this should raise `unresolved-attribute` error\n        super().a\n\n# error: [unresolved-attribute] \"Type `<super: Literal[B], B>` has no attribute `a`\"\nsuper(B, B(42)).a\n```\n\n----------------------------------------\n\nTITLE: Variable Boundness with Nested Conditionals in Python\nDESCRIPTION: Demonstrates how variable boundness is determined with nested conditional statements. Variables defined only in unreachable code paths remain unbound.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_44\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nif False:\n    if True:\n        unbound1 = 1\n\nif True:\n    if False:\n        unbound2 = 1\n\nif False:\n    if False:\n        unbound3 = 1\n\nif False:\n    if flag():\n        unbound4 = 1\n\nif flag():\n    if False:\n        unbound5 = 1\n\n# error: [unresolved-reference]\n# error: [unresolved-reference]\n# error: [unresolved-reference]\n# error: [unresolved-reference]\n# error: [unresolved-reference]\n(unbound1, unbound2, unbound3, unbound4, unbound5)\n```\n\n----------------------------------------\n\nTITLE: Revealing Types of Unary Subtraction Operations in Python\nDESCRIPTION: Shows how unary subtraction (-) affects the revealed types of literal values and boolean True. The type checker identifies the negated literal values appropriately.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unary/integers.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(-0)  # revealed: Literal[0]\nreveal_type(-1)  # revealed: Literal[-1]\nreveal_type(-True)  # revealed: Literal[-1]\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Development Server\nDESCRIPTION: Commands for installing NPM dependencies and starting the development server for either ruff-playground or knot-playground workspaces.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/playground/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm start --workspace ruff-playground\nnpm start --workspace knot-playground\n```\n\n----------------------------------------\n\nTITLE: Stub File with Symbol Definitions\nDESCRIPTION: A stub file (a.pyi) that defines two boolean variables X and Y. These will be used to test re-export behavior in stub files.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nX: bool = True\nY: bool = True\n```\n\n----------------------------------------\n\nTITLE: Search Path Module A Definition\nDESCRIPTION: First search path module definition with Foo class\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/case_sensitive.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    x: int = 1\n```\n\n----------------------------------------\n\nTITLE: Installing Ruff with Conda\nDESCRIPTION: Demonstrates how to install Ruff using Conda package manager from the conda-forge channel.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/installation.md#2025-04-17_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ conda install -c conda-forge ruff\n```\n\n----------------------------------------\n\nTITLE: Import Module Attribute vs Submodule - Direct Import\nDESCRIPTION: Demonstrates how Python resolves 'import a.b' when there's both an attribute 'b' in a/__init__.py and a submodule a/b.py\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport a.b\n\nreveal_type(a.b)  # revealed: <module 'a.b'>\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Boolean Flags\nDESCRIPTION: Shows type narrowing with conditional assignment using boolean flags and subsequent if-elif-else blocks. Demonstrates how the type system tracks literal values through branches.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/elif_else.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = 1 if flag1 else 2 if flag2 else 3\n\n    if x == 1:\n        # TODO should be Literal[1]\n        reveal_type(x)  # revealed: Literal[1, 2, 3]\n    elif x == 2:\n        # TODO should be Literal[2]\n        reveal_type(x)  # revealed: Literal[2, 3]\n    else:\n        reveal_type(x)  # revealed: Literal[3]\n```\n\n----------------------------------------\n\nTITLE: Defining Module Attributes in Python\nDESCRIPTION: Defines global symbol in a module with type annotation, which can be imported and used in other modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#2025-04-17_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nglobal_symbol: str = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Mixed Import Statements with IPython Magic Command in Python\nDESCRIPTION: This snippet shows a mix of import statements including pathlib and sys, an IPython magic command to configure matplotlib, and additional imports for math and abc modules. It demonstrates multi-line syntax for the magic command.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/isort.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nimport sys\n\n%matplotlib \\\n    --inline\n\nimport math\nimport abc\n```\n\n----------------------------------------\n\nTITLE: Cannot Use an Argument as Both Value and Type Form\nDESCRIPTION: Demonstrates the error when an argument is used in both value and type form in a call, such as when some functions handle types differently.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/union.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom knot_extensions import is_fully_static\n\ndef _(flag: bool):\n    if flag:\n        f = repr\n    else:\n        f = is_fully_static\n    # error: [conflicting-argument-forms] \"Argument is used as both a value and a type form in call\"\n    reveal_type(f(int))  # revealed: str | Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unbound Typevars with PEP 695 Syntax in Python\nDESCRIPTION: This snippet shows how unbound typevars behave with PEP 695 syntax, using legacy syntax to define the unbound typevars.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/generics/scoping.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nS = TypeVar(\"S\")\n\ndef f[T](x: T) -> None:\n    x: list[T] = []\n    # TODO: error\n    y: list[S] = []\n\nclass C[T]:\n    # TODO: error\n    x: list[S] = []\n\n    def m1(self, x: S) -> S:\n        return x\n\n    def m2[S](self, x: S) -> S:\n        return x\n```\n\n----------------------------------------\n\nTITLE: Accessing sys.version_info by Index and Slice\nDESCRIPTION: Demonstrates type revelations when accessing sys.version_info using index and slice notation\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/sys_version_info.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[0] < 3)  # revealed: Literal[False]\nreveal_type(sys.version_info[1] > 9)  # revealed: Literal[False]\n\nreveal_type(sys.version_info[:5])\n\nreveal_type(sys.version_info[:2] >= (3, 9))  # revealed: Literal[True]\nreveal_type(sys.version_info[0:2] >= (3, 10))  # revealed: Literal[False]\nreveal_type(sys.version_info[:3] >= (3, 10, 1))  # revealed: Literal[False]\nreveal_type(sys.version_info[3] == \"final\")  # revealed: bool\nreveal_type(sys.version_info[3] == \"finalllllll\")  # revealed: Literal[False]\n```\n\n----------------------------------------\n\nTITLE: Class Union with __class_getitem__ in Python\nDESCRIPTION: Demonstrates how a variable can hold one of two classes with different __class_getitem__ implementations, resulting in a union type when subscripted.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/class.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag: bool):\n    class A:\n        def __class_getitem__(cls, item: int) -> str:\n            return str(item)\n\n    class B:\n        def __class_getitem__(cls, item: int) -> int:\n            return item\n\n    x = A if flag else B\n\n    reveal_type(x)  # revealed: Literal[A, B]\n    reveal_type(x[0])  # revealed: str | int\n```\n\n----------------------------------------\n\nTITLE: Assigning String Value in Python\nDESCRIPTION: This snippet demonstrates assigning a string value to a variable in Python.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsome_string = \"123123\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Re-export in One Branch in Python\nDESCRIPTION: This snippet shows a conditional re-export where only one branch performs the re-export. This results in a possibly unbound member error when importing Foo from module 'a'.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# error: \"Member `Foo` of module `a` is possibly unbound\"\nfrom a import Foo\n\nreveal_type(Foo)  # revealed: Literal[Foo]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef coinflip() -> bool: ...\n\nif coinflip():\n    from b import Foo as Foo\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Foo: ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union of Types Without Dunder Methods in Python\nDESCRIPTION: This code snippet shows how a union of types without dunder methods is handled. It defines classes with instance attributes that attempt to set __getitem__, but these are not recognized for implicit dunder calls.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/dunder.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef external_getitem(instance, key: int) -> str:\n    return str(key)\n\nclass NotSubscriptable1:\n    def __init__(self, value: int):\n        self.__getitem__ = external_getitem\n\nclass NotSubscriptable2:\n    def __init__(self, value: int):\n        self.__getitem__ = external_getitem\n\ndef _(union: NotSubscriptable1 | NotSubscriptable2):\n    # error: [non-subscriptable]\n    union[0]\n```\n\n----------------------------------------\n\nTITLE: Analyzing Positive Contributions to Intersection Types in Python\nDESCRIPTION: This snippet demonstrates how intersection types behave when definitive true/false answers are obtained for one of the types in the intersection. It shows how comparison operators are resolved for narrowed types.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nclass Base:\n    def __gt__(self, other) -> bool:\n        return False\n\nclass Child1(Base):\n    def __eq__(self, other) -> Literal[True]:\n        return True\n\nclass Child2(Base): ...\n\ndef _(x: Base):\n    c1 = Child1()\n\n    # Create an intersection type through narrowing:\n    if isinstance(x, Child1):\n        if isinstance(x, Child2):\n            reveal_type(x)  # revealed: Child1 & Child2\n\n            reveal_type(x == 1)  # revealed: Literal[True]\n\n            # Other comparison operators fall back to the base type:\n            reveal_type(x > 1)  # revealed: bool\n            reveal_type(x is c1)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Printing Defined Variable in Python\nDESCRIPTION: Prints the value of the previously defined colors variable to standard output.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/undefined_name.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(colors)\n```\n\n----------------------------------------\n\nTITLE: False Negative: Non-tuple __slots__ Definition\nDESCRIPTION: Shows how using list instead of tuple for __slots__ definition leads to undetected incompatibilities because the static analyzer treats list-based slots as dynamic values.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/slots.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass A:\n    __slots__ = [\"a\", \"b\"]  # This is treated as \"dynamic\"\n\nclass B:\n    __slots__ = (\"c\", \"d\")\n\n# False negative: [incompatible-slots]\nclass C(A, B): ...\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Ruff Release Build\nDESCRIPTION: Build Ruff in release mode and benchmark it against CPython with and without cache. This compares the performance of Ruff in different scenarios.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --release && hyperfine --warmup 10 \\\n  \"./target/release/ruff check ./crates/ruff_linter/resources/test/cpython/ --no-cache -e\" \\\n  \"./target/release/ruff check ./crates/ruff_linter/resources/test/cpython/ -e\"\n```\n\n----------------------------------------\n\nTITLE: Callable with Positional-Only Parameters\nDESCRIPTION: Shows that Callable annotations only work with positional parameters and will raise errors when trying to use keyword arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/call/annotation.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _(c: Callable[[int, str], None]):\n    # error: [unknown-argument] \"Argument `a` does not match any known parameter\"\n    # error: [unknown-argument] \"Argument `b` does not match any known parameter\"\n    # error: [missing-argument] \"No arguments provided for required parameters 1, 2\"\n    reveal_type(c(a=1, b=\"b\"))  # revealed: None\n```\n\n----------------------------------------\n\nTITLE: Defining Non-exports in Python Stub File\nDESCRIPTION: This stub file (b.pyi) demonstrates imports that are not re-exported. It imports foo, Any, and Literal, but does not re-export them, making them unavailable for import from outside.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conventions.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport foo\nfrom typing import Any, Literal\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Stricter Behavior with Type Annotations in Python\nDESCRIPTION: This example shows how users can opt for stricter type checking behavior by adding explicit type annotations to their code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass OptionalInt:\n    value: int | None = 10\n\no = OptionalInt()\n\n# The following public type is now\n# revealed: int | None\nreveal_type(o.value)\n\n# Incompatible assignments are now caught:\n# error: \"Object of type `Literal[\"a\"]` is not assignable to attribute `value` of type `int | None`\"\no.value = \"a\"\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing in Elif-Else Blocks\nDESCRIPTION: Complex example showing type narrowing across elif-else blocks with conditional assignments. Includes TODO comments indicating expected type revelations and current implementation behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals/nested.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef _(flag1: bool, flag2: bool):\n    x = 1 if flag1 else 2 if flag2 else 3\n\n    if x != 1:\n        reveal_type(x)  # revealed: Literal[2, 3]\n        if x == 2:\n            # TODO should be `Literal[2]`\n            reveal_type(x)  # revealed: Literal[2, 3]\n        elif x == 3:\n            reveal_type(x)  # revealed: Literal[3]\n        else:\n            reveal_type(x)  # revealed: Never\n\n    elif x != 2:\n        # TODO should be Literal[1]\n        reveal_type(x)  # revealed: Literal[1, 3]\n    else:\n        # TODO should be Never\n        reveal_type(x)  # revealed: Literal[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Callable Type Annotation in Python\nDESCRIPTION: Shows parser behavior when handling invalid typing.Callable annotation with missing arguments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\n# error: [invalid-syntax] \"Expected index or slice expression\"\n# error: [invalid-type-form] \"Special form `typing.Callable` expected exactly two arguments (parameter types and return type)\"\ndef _(c: Callable[]):\n    reveal_type(c)  # revealed: (...) -> Unknown\n```\n\n----------------------------------------\n\nTITLE: Module Init File Definition\nDESCRIPTION: Content of a/__init__.py defining the integer attribute 'b'\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conflicts.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nb: int = 42\n```\n\n----------------------------------------\n\nTITLE: Unsupported Type Qualifiers in Python Annotations\nDESCRIPTION: Demonstrates type qualifiers that aren't fully supported by red-knot, though they don't trigger false-positive errors when used in annotations. Includes examples for Final, Required, NotRequired, and ReadOnly qualifiers.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_type_qualifiers.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Final, Required, NotRequired, ReadOnly, TypedDict\n\nX: Final = 42\nY: Final[int] = 42\n\n# TODO: `TypedDict` is actually valid as a base\n# error: [invalid-base]\nclass Bar(TypedDict):\n    x: Required[int]\n    y: NotRequired[str]\n    z: ReadOnly[bytes]\n```\n\n----------------------------------------\n\nTITLE: Importing and Revealing Type of Conditionally Defined Function in Python\nDESCRIPTION: This snippet demonstrates importing a function that was conditionally defined or imported. It shows how type revealing works in this scenario.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/conditional.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom b import f\n\n# TODO: We should disambiguate in such cases between `b.f` and `c.f`.\nreveal_type(f)  # revealed: (def f() -> Unknown) | (def f() -> Unknown)\n```\n\n----------------------------------------\n\nTITLE: Walrus Operator Self-Addition in Python\nDESCRIPTION: Shows how the walrus operator can be used for self-addition. The variable x is first initialized to 0, then updated to x + 1 using the walrus operator, resulting in x with value 1.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/assignment/walrus.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = 0\n(x := x + 1)\nreveal_type(x)  # revealed: Literal[1]\n```\n\n----------------------------------------\n\nTITLE: Example Python Input Format\nDESCRIPTION: Sample Python code showing a simple function definition with comment\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef f():  # a\n    pass\n```\n\n----------------------------------------\n\nTITLE: Limitations of Current Approach with False Positives in Python\nDESCRIPTION: Illustrates a limitation in the current approach where Ruff emits false positive errors for type checking because it only sees the visible definition from the reachable branch when analyzing unreachable code.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nif False:\n    x: int = 1\nelse:\n    x: str = \"a\"\n\nif False:\n    # TODO We currently emit a false positive here:\n    # error: [invalid-assignment] \"Object of type `Literal[\\\"a\\\"]` is not assignable to `int`\"\n    other: int = x\nelse:\n    other: str = x\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff in pyproject.toml\nDESCRIPTION: This snippet shows the basic structure for configuring Ruff in a pyproject.toml file. It includes settings for selecting rules, ignoring specific errors, and setting line length.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/invalid_extension.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.ruff]\nselect = [\"E\", \"F\"]\nignore = [\"E402\"]\n\n# Allow lines to be as long as 120 characters.\nline-length = 120\n```\n\n----------------------------------------\n\nTITLE: Python While Loop with Comments Example\nDESCRIPTION: Example Python code showing different comment placements in a while loop structure, including condition comments and else clause comments.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nwhile True:  # Trailing condition comment\n    if f():\n        break\n    # trailing while comment\n# leading else comment\nelse:\n    print(\"while-else\")\n```\n\n----------------------------------------\n\nTITLE: Comparison Expression with Semicolon\nDESCRIPTION: A comparison expression followed by a semicolon, demonstrating that semicolons don't change how the linter evaluates the expression for B018 violations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Semicolons shouldn't affect the output\nx == 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Interdependent Builtin Symbols in PYI File\nDESCRIPTION: This PYI file defines two interdependent builtin symbols, where 'foo' depends on 'bar' which is defined later.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/builtins.md#2025-04-17_snippet_6\n\nLANGUAGE: pyi\nCODE:\n```\nfoo = bar\nbar = 1\n```\n\n----------------------------------------\n\nTITLE: Type[Unknown] Properties in Python\nDESCRIPTION: Shows how type[Unknown] behaves similarly to type[Any] in terms of type assignments and compatibility.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/type_of/dynamic.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport abc\nfrom typing import Any\nfrom does_not_exist import SomethingUnknown  # error: [unresolved-import]\n\nhas_unknown_type = SomethingUnknown.__class__\nreveal_type(has_unknown_type)  # revealed: type[Unknown]\n\ndef test(x: type[str], y: type[Any]):\n    \"\"\"Both `type[Any]` and `type[Unknown]` are assignable to all `type[]` types\"\"\"\n    a: type[Any] = x\n    b: type[str] = y\n    c: type[Any] = has_unknown_type\n    d: type[str] = has_unknown_type\n\ndef test2(a: type[Any]):\n    \"\"\"`type[Any]` and `type[Unknown]` are also assignable to all instances of `type` subclasses\"\"\"\n    b: abc.ABCMeta = a\n    b: abc.ABCMeta = has_unknown_type\n```\n\n----------------------------------------\n\nTITLE: Suppressing Diagnostics for Type Annotations in Unreachable Code in Python\nDESCRIPTION: Demonstrates how Ruff doesn't emit diagnostics for type annotations inside unreachable code sections. This includes class references in type annotations and class inheritance in unreachable blocks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef _():\n    class C:\n        class Inner: ...\n\n    return\n\n    c1: C = C()\n    c2: C.Inner = C.Inner()\n    c3: tuple[C, C] = (C(), C())\n    c4: tuple[C.Inner, C.Inner] = (C.Inner(), C.Inner())\n\n    class Sub(C): ...\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Operators for Positive Contributions in Python\nDESCRIPTION: This snippet demonstrates error handling for unsupported operators when dealing with positive contributions to intersection types. It shows how an error is raised for an unsupported 'in' operator.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/comparison/intersections.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Container:\n    def __contains__(self, x) -> bool:\n        return False\n\nclass NonContainer: ...\n\ndef _(x: object):\n    if isinstance(x, Container):\n        if isinstance(x, NonContainer):\n            reveal_type(x)  # revealed: Container & NonContainer\n\n            # error: [unsupported-operator] \"Operator `in` is not supported for types `int` and `NonContainer`\"\n            reveal_type(2 in x)  # revealed: bool\n```\n\n----------------------------------------\n\nTITLE: Running mypy_primer with Local Repository\nDESCRIPTION: Command demonstrating how to use mypy_primer with a local repository copy, allowing comparison of local branches using the --repo option.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/mypy_primer.md#2025-04-17_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nmypy_primer --repo /path/to/ruff --old origin/main --new my/local-branch …\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Exception Syntax in Python\nDESCRIPTION: This code snippet shows an invalid syntax in a try-except block. The 'except' clause is missing the exception type, which is a syntax error in Python. It also uses 'reveal_type' from typing_extensions, which is typically used for type checking.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/exception/invalid_syntax.md#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing_extensions import reveal_type\n\ntry:\n    print\nexcept as e:  # error: [invalid-syntax]\n    reveal_type(e)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Global State Reset Check\nDESCRIPTION: Confirms that configuration changes are section-scoped by verifying return to root configuration.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_config.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nreveal_type(sys.version_info[:2] == (3, 10))  # revealed: Literal[True]\n```\n\n----------------------------------------\n\nTITLE: Using Stubs-Only Package in Python\nDESCRIPTION: Demonstrates usage of the stubs-only 'Foo' class with type revealing.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom foo import Foo\n\nreveal_type(Foo().name)  # revealed: str\n```\n\n----------------------------------------\n\nTITLE: Expression Handling\nDESCRIPTION: Demonstrates expression handling with and without semicolons.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff/resources/test/fixtures/trailing_semicolon.ipynb#2025-04-17_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n# Expression without a semicolon\nx\n```\n\nLANGUAGE: python\nCODE:\n```\nx = 1\n# Expression with a semicolon\nx;\n```\n\n----------------------------------------\n\nTITLE: Successful Parser Test Example in Rust\nDESCRIPTION: Example showing how to write an inline test that verifies successful parsing of Python code within Rust source files using test_ok format.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// test_ok this_is_the_test_name\n// def foo():\n//     pass\nprintln!(\"some rust code\");\n```\n\n----------------------------------------\n\nTITLE: Example TypedDict Key Usage\nDESCRIPTION: Example showing how PEP 764 inline TypedDict keys are now visited as non-type-expressions\nSOURCE: https://github.com/astral-sh/ruff/blob/main/CHANGELOG.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_dict: TypedDict = {\"key\": value}\n```\n\n----------------------------------------\n\nTITLE: Importing User-defined TYPE_CHECKING - Stub Definition\nDESCRIPTION: Shows TYPE_CHECKING definition in a stub file with proper type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nTYPE_CHECKING: bool\n# or\nTYPE_CHECKING: bool = ...\n```\n\n----------------------------------------\n\nTITLE: Running Comparison Benchmarks\nDESCRIPTION: Shell command to execute comparison benchmarks between Ruff and other Python tools.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/scripts/benchmarks/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nscripts/benchmarks/run_comparisons.sh\n```\n\n----------------------------------------\n\nTITLE: Project Formatting Command\nDESCRIPTION: Command to format an entire project using ruff_dev\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --bin ruff_dev -- format-dev --write /path/to/my_project\n```\n\n----------------------------------------\n\nTITLE: Importing User-defined TYPE_CHECKING - Constants Module\nDESCRIPTION: Shows definition of TYPE_CHECKING in a separate constants module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/known_constants.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nTYPE_CHECKING = False\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Notification Display in JSON\nDESCRIPTION: Controls when notifications are shown in the editor. This setting is only used by the deprecated ruff-lsp, not by the native language server.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.showNotifications\": \"onWarning\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stubs-Only Package in TOML\nDESCRIPTION: Sets up the environment for a stubs-only package without the regular package.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[environment]\nextra-paths = [\"/packages\"]\n```\n\n----------------------------------------\n\nTITLE: Simple Semicolon Usage\nDESCRIPTION: Basic example of unnecessary semicolon usage after a variable reference\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E703.ipynb#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Simple case\nx;\n```\n\n----------------------------------------\n\nTITLE: Excluded ModuleType Attributes\nDESCRIPTION: Shows attributes that are not available as implicit module globals despite being present on ModuleType.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# error: [unresolved-reference]\n# revealed: Unknown\nreveal_type(__getattr__)\n\n# error: [unresolved-reference]\n# revealed: Unknown\nreveal_type(__dict__)\n\n# error: [unresolved-reference]\n# revealed: Unknown\nreveal_type(__init__)\n```\n\n----------------------------------------\n\nTITLE: Configuring Ruff Lint Run Behavior in JSON\nDESCRIPTION: Sets when Ruff linting should run - either on every keystroke or only on save. This setting is only used by the deprecated ruff-lsp, not by the native language server.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/docs/editors/settings.md#2025-04-17_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"ruff.lint.run\": \"onSave\"\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Invalid Nested Module Import in Python\nDESCRIPTION: This example demonstrates an invalid nested module import syntax. It shows how the error is flagged but notes that the diagnostics could be improved. The snippet also includes type revelations that may need adjustment.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/invalid_syntax.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# TODO: No second diagnostic\n# error: [invalid-syntax] \"Expected ',', found '.'\"\n# error: [unresolved-import] \"Module `a` has no member `c`\"\nfrom a import b.c\n\n# TODO: Should these be inferred as Unknown?\nreveal_type(b)  # revealed: <module 'a.b'>\nreveal_type(b.c)  # revealed: int\n```\n\n----------------------------------------\n\nTITLE: Implementing Regular Package with __init__.py in Python\nDESCRIPTION: Defines the actual implementation of the 'Pentagon' and 'Hexagon' classes without type annotations.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/stub_packages.md#2025-04-17_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nclass Pentagon: ...\nclass Hexagon: ...\n```\n\n----------------------------------------\n\nTITLE: Filtering RED_KNOT_LOG to show only typing traces\nDESCRIPTION: Environment variable configuration to filter tracing output to only display messages from the types module.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/tracing.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRED_KNOT_LOG=\"red_knot_python_semantic::types\"\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Ambiguous While Loop Condition in Python\nDESCRIPTION: Demonstrates how type analysis handles a while loop with a non-statically known condition. The variable 'x' could be either 1 or 2 depending on the runtime behavior.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/statically_known_branches.md#2025-04-17_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef flag() -> bool:\n    return True\n\nx = 1\n\nwhile flag():\n    x = 2\n\nreveal_type(x)  # revealed: Literal[1, 2]\n```\n\n----------------------------------------\n\nTITLE: Integration Test with collections.abc\nDESCRIPTION: Tests star import resolution with the standard library module collections.abc, which re-exports many symbols. Shows current handling of explicitly and implicitly exported symbols.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/import/star.md#2025-04-17_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport collections.abc\n\nreveal_type(collections.abc.Sequence)  # revealed: Literal[Sequence]\nreveal_type(collections.abc.Callable)  # revealed: typing.Callable\n\n# TODO: false positive as it's only re-exported from `_collections.abc` due to presence in `__all__`\n# error: [unresolved-attribute]\nreveal_type(collections.abc.Set)  # revealed: Unknown\n```\n\n----------------------------------------\n\nTITLE: Running Ruff from a parent directory with specific config\nDESCRIPTION: This command shows how running Ruff from a parent directory with a specific configuration ignores the exclude patterns, resulting in files that would normally be excluded being checked.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/project/README.md#2025-04-17_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n∴ (cd crates/ruff_linter/resources/test/project/examples && cargo run -p ruff -- check --config=docs/ruff.toml .)\ndocs/docs/concepts/file.py:5:5: F841 [*] Local variable `x` is assigned to but never used\ndocs/docs/file.py:1:1: I001 [*] Import block is un-sorted or un-formatted\ndocs/docs/file.py:8:5: F841 [*] Local variable `x` is assigned to but never used\nexcluded/script.py:5:5: F841 [*] Local variable `x` is assigned to but never used\nFound 4 errors.\n[*] 4 potentially fixable with the --fix option.\n```\n\n----------------------------------------\n\nTITLE: Simple Print Statement in Python\nDESCRIPTION: This snippet contains a single print statement that outputs a string. It demonstrates basic Python syntax for printing to the console.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/valid.ipynb#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"after empty cells\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Different Type Inference in Internal vs External Scopes in Python\nDESCRIPTION: This snippet illustrates how Ruff applies different semantics for type inference depending on whether a symbol is accessed from the same scope it was defined in or from an external scope.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Wrapper:\n    value = None\n\n    # Type as seen from the same scope:\n    reveal_type(value)  # revealed: None\n\n# Type as seen from another scope:\nreveal_type(Wrapper.value)  # revealed: Unknown | None\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Function in Python Cell\nDESCRIPTION: This snippet defines a JavaScript function 'add' within a Python-identified code cell. It demonstrates potential issues with language identification in VS Code notebooks.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_notebook/resources/test/fixtures/jupyter/vscode_language_id.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfunction add(x, y) {\n    return x + y;\n}\n```\n\n----------------------------------------\n\nTITLE: Excessive Relative Import in Python Package Structure\nDESCRIPTION: This example shows the error when using too many leading dots in a relative import within a package structure. It demonstrates how Ruff handles imports that go beyond the package root.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/diagnostics/unresolved_import.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ....foo import add  # error: [unresolved-import]\n\nstat = add(10, 15)\n```\n\n----------------------------------------\n\nTITLE: Multiple Comparison Expressions with B018 Violation\nDESCRIPTION: Two comparison expressions where the first one is marked with B018 to indicate it's a useless comparison that should trigger the linting rule, while the second is likely part of a valid context.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.ipynb#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Only skip the last expression\nx == 1  # B018\nx == 1\n```\n\n----------------------------------------\n\nTITLE: Boolean True Value in Python\nDESCRIPTION: Simple snippet demonstrating a boolean True value literal.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/W391.ipynb#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nTrue\n```\n\n----------------------------------------\n\nTITLE: Installing mypy_primer from Fork\nDESCRIPTION: Commands to install and run the forked version of mypy_primer that supports Red Knot integration. Shows how to use uvx to run directly from the repository or install as a tool.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot/docs/mypy_primer.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nuvx --from \"git+https://github.com/astral-sh/mypy_primer.git@add-red-knot-support\" mypy_primer -h\n```\n\nLANGUAGE: sh\nCODE:\n```\nuv tool install \"git+https://github.com/astral-sh/mypy_primer.git@add-red-knot-support\"\n```\n\n----------------------------------------\n\nTITLE: Custom VERSIONS File\nDESCRIPTION: Version specification file defining Python version requirements for modules.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/mdtest_custom_typeshed.md#2025-04-17_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nold_module: 3.0-\nnew_module: 3.11-\n```\n\n----------------------------------------\n\nTITLE: Testing While Loop Syntax Error in Python\nDESCRIPTION: Demonstrates parser handling when using 'in' keyword as a condition in while loop.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/invalid_syntax.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# error: [invalid-syntax]\n# error: [unresolved-reference] \"Name `in` used when not defined\"\nwhile in:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Property Class Access Example in Python\nDESCRIPTION: Shows how property behaves when accessed directly on the class rather than an instance.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/properties.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nreveal_type(C.my_property)  # revealed: property\n```\n\n----------------------------------------\n\nTITLE: Using Jupyter Magic Command with Import in Python\nDESCRIPTION: This snippet shows the use of a Jupyter notebook magic command (%time) along with a Python import statement. The %time magic is used to measure the execution time of the import operation.\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/ruff_linter/resources/test/fixtures/pycodestyle/E402.ipynb#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%time\nimport pathlib\n```\n\n----------------------------------------\n\nTITLE: Typing.Tuple Inheritance\nDESCRIPTION: Demonstrates inheritance from typing.Tuple and its impact on Method Resolution Order (MRO).\nSOURCE: https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/subscript/tuple.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Tuple\n\nclass C(Tuple): ...\n\n# revealed: tuple[Literal[C], Literal[tuple], Literal[Sequence], Literal[Reversible], Literal[Collection], Literal[Iterable], Literal[Container], @Todo(protocol), Literal[object]]\nreveal_type(C.__mro__)\n```"
  }
]