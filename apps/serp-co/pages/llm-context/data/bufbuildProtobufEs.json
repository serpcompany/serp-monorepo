[
  {
    "owner": "bufbuild",
    "repo": "protobuf-es",
    "content": "TITLE: Installing Protobuf-ES Dependencies\nDESCRIPTION: This example shows how to install the required dependencies for Protobuf-ES using npm. It installs the runtime library (`@bufbuild/protobuf`) and the code generator (`@bufbuild/protoc-gen-es`, `@bufbuild/buf`) as development dependencies.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\nnpm install @bufbuild/protobuf\nnpm install --save-dev @bufbuild/protoc-gen-es @bufbuild/buf\n```\n\n----------------------------------------\n\nTITLE: Protobuf Message Definition\nDESCRIPTION: Defines a Protobuf message named `User` with several fields, including string, boolean, nested message, repeated string, and a map.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\n\nmessage User {\n  string first_name = 1;\n  string last_name = 2;\n  bool active = 3;\n  User manager = 4;\n  repeated string locations = 5;\n  map<string, string> projects = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Protobuf Messages with Binary TypeScript\nDESCRIPTION: Shows how to serialize a Protobuf message to a binary format using `toBinary` and deserialize it back using `fromBinary`. It imports the necessary functions and the message schema. Requires a `User` type and `UserSchema` to be defined.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toBinary, fromBinary } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\ndeclare let user: User;\n\nconst bytes: Uint8Array = toBinary(UserSchema, user);\nuser = fromBinary(UserSchema, bytes);\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf-ES v2 npm packages\nDESCRIPTION: This command installs the latest version 2 of the @bufbuild/protobuf and @bufbuild/protoc-gen-es npm packages.  It updates your project dependencies to use the new versions.  Run this command in your project's root directory.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_106\n\nLANGUAGE: Shell Session\nCODE:\n```\nnpm install @bufbuild/protobuf@^2.0.0 @bufbuild/protoc-gen-es@^2.0.0\n```\n\n----------------------------------------\n\nTITLE: Checking Field Presence in Protobuf TypeScript\nDESCRIPTION: Demonstrates how to use `isFieldSet` to determine if a field has been explicitly set. It differentiates between implicit and explicit presence, showing how `isFieldSet` behaves differently based on the field's presence type.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isFieldSet } from \"@bufbuild/protobuf\";\nimport { PresenceSchema } from \"./gen/example_pb\";\n\nconst msg = create(PresenceSchema);\nisFieldSet(msg, PresenceSchema.field.a); // false\nisFieldSet(msg, PresenceSchema.field.b); // false\n\nmsg.a = false;\nmsg.b = false;\nisFieldSet(msg, PresenceSchema.field.a); // false\nisFieldSet(msg, PresenceSchema.field.b); // true\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Protobuf Messages with JSON TypeScript\nDESCRIPTION: Demonstrates how to serialize a Protobuf message to JSON format using `toJson` and deserialize it from JSON using `fromjson`.  It also shows the usage of `JsonValue` and requires a `User` type and `UserSchema` to be defined.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nimport { toJson, fromjson, type JsonValue } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\ndeclare let user: User;\n\nconst json: JsonValue = toJson(UserSchema, user);\nuser = fromjson(UserSchema, json);\n```\n\n----------------------------------------\n\nTITLE: Constructing a Protobuf Message with Initializer TypeScript\nDESCRIPTION: Illustrates how to create a Protobuf message with an initializer object. This allows setting initial values for the message's fields during creation. Nested messages can also be initialized within the initializer object.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\nconst user: User = create(UserSchema, {\n  firstName: \"Homer\",\n  active: true,\n  manager: {\n    // Manager is also a message. You can pass an initializer object here,\n    // and don't need create().\n    lastName: \"Burns\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Buf Code Generation\nDESCRIPTION: This example shows a `buf.gen.yaml` configuration file. It specifies the version of the configuration, input directories, plugins to use for code generation, and output directories. The example generates TypeScript code to `src/gen` directory using the `protoc-gen-es` plugin.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# Learn more: https://buf.build/docs/configuration/v2/buf-gen-yaml\nversion: v2\ninputs:\n  - directory: proto\nplugins:\n  - local: protoc-gen-es\n    opt: target=ts\n    out: src/gen\n```\n\n----------------------------------------\n\nTITLE: Using Protobuf Schema in TypeScript\nDESCRIPTION: This example shows how to use a compiled Protobuf schema in TypeScript. It imports the generated `UserSchema`, creates a `User` object, and then serializes it to binary and JSON formats using the `@bufbuild/protobuf` library.  Requires `@bufbuild/protobuf` as a dependency.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UserSchema } from \"./gen/user_pb.js\";\nimport { create, toBinary, toJson } from \"@bufbuild/protobuf\";\n\nlet user = create(UserSchema, {\n  firstName: \"Homer\",\n  lastName: \"Simpson\",\n  active: true,\n  locations: [\"Springfield\"],\n  projects: { SPP: \"Springfield Power Plant\" },\n  manager: {\n    firstName: \"Montgomery\",\n    lastName: \"Burns\",\n  },\n});\n\nconst bytes = toBinary(UserSchema, user);\nconst json = toJson(UserSchema, user);\n```\n\n----------------------------------------\n\nTITLE: Constructing a Protobuf Message TypeScript\nDESCRIPTION: Demonstrates how to create a Protobuf message using the `create` function from `@bufbuild/protobuf`. It imports the message type (User) and its schema (UserSchema) and then creates an instance of the message.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\nconst user: User = create(UserSchema);\n```\n\n----------------------------------------\n\nTITLE: Converting a TypeScript Enum value to a String\nDESCRIPTION: This snippet shows how to convert a TypeScript enum value to its corresponding string representation using reverse mapping. `PhoneType[val]` accesses the name associated with the enum value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nlet val: PhoneType = PhoneType.MOBILE;\nlet name = PhoneType[val]; // => \"MOBILE\"\n```\n\n----------------------------------------\n\nTITLE: Generating Code with Buf\nDESCRIPTION: Runs the Buf CLI to generate code from the Protobuf files in the `proto` directory, based on the configuration in `buf.gen.yaml`. The generated code is placed in the `src/gen` directory.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_4\n\nLANGUAGE: shellsession\nCODE:\n```\nnpx buf generate\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a map field\nDESCRIPTION: This code illustrates the generated TypeScript representation of a Protobuf map field. The 'projects' field becomes an object with string keys and string values, with an empty object as the default value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: map<string, string> projects = 6;\n */\nprojects: { [key: string]: string } = {};\n```\n\n----------------------------------------\n\nTITLE: Creating and Converting Timestamps in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create Timestamp objects from the current time, an ECMAScript Date, and a Unix timestamp. It also shows how to convert a Timestamp back to a Date and a Unix timestamp in milliseconds. It relies on the @bufbuild/protobuf/wkt package for Timestamp-related functions.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  type Timestamp,\n  timestampNow,\n  timestampFromDate,\n  timestampFromMs,\n  timestampDate,\n  timestampMs,\n} from \"@bufbuild/protobuf/wkt\";\n\n// Create a Timestamp for the current time.\nlet ts: TimeStamp = timestampNow();\n\n// Create a Timestamp message from an ECMAScript Date.\nts = timestampFromDate(new Date(1938, 0, 10));\n\n// Create a Timestamp message from a Unix timestamp in milliseconds.\nts = timestampFromMs(818035920123);\n\n// Convert a Timestamp message to an ECMAScript Date.\nlet date: Date = timestampDate(ts);\n\n// Convert a Timestamp to a Unix timestamp in milliseconds.\nlet ms: number = timestampMs(ts);\n```\n\n----------------------------------------\n\nTITLE: Installing protoc-gen-es and protobuf runtime library\nDESCRIPTION: Installs the @bufbuild/protobuf runtime library and the @bufbuild/protoc-gen-es plugin using npm. The runtime library is a dependency for the generated code, and the plugin is used to generate code from Protocol Buffer definitions.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @bufbuild/protobuf\nnpm install --save-dev @bufbuild/protoc-gen-es\n```\n\n----------------------------------------\n\nTITLE: Generating protobuf code with protoc\nDESCRIPTION: Generates code from Protocol Buffer definitions using the protoc compiler. It adds the node_modules/.bin directory to the PATH to ensure the protoc-gen-es plugin can be found, and specifies the output directory and target language using command-line arguments.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nPATH=$PATH:$(pwd)/node_modules/.bin \\\n  protoc -I . \\\n  --es_out src/gen \\\n  --es_opt target=ts \\\n  a.proto b.proto c.proto\n```\n\n----------------------------------------\n\nTITLE: Defining a string scalar field in Protobuf\nDESCRIPTION: This snippet demonstrates the definition of a scalar string field in a Protobuf message. The field 'first_name' is defined as a string with field number 1.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_14\n\nLANGUAGE: protobuf\nCODE:\n```\nstring first_name = 1;\n```\n\n----------------------------------------\n\nTITLE: Cloning Protobuf Messages TypeScript\nDESCRIPTION: Demonstrates how to create a deep copy of a Protobuf message using the `clone` function. It imports the function and the message schema. Requires `User` type and `UserSchema` to be defined.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nimport { clone } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\ndeclare const a: User;\n\nconst b = clone(UserSchema, a);\n```\n\n----------------------------------------\n\nTITLE: Redact Sensitive Fields Using Reflection (TypeScript)\nDESCRIPTION: Redacts sensitive fields from a message using the Protobuf reflection API and a custom option. The `redact` function iterates through the fields of a message, checks if the `sensitive` option is set, and clears the field if it is. Requires the custom option definition and the Protobuf message schema.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOption, type Message, type DescMessage } from \"@bufbuild/protobuf\";\nimport { reflect } from \"@bufbuild/protobuf/reflect\";\nimport { sensitive } from \"./gen/example-option_pb\";\n\nexport function redact(schema: DescMessage, message: Message) {\n  const r = reflect(schema, message);\n  for (const field of r.fields) {\n    if (getOption(field, sensitive)) {\n      // This field has the option (example.options.sensitive) = true\n      r.clear(field);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Code using protoc (Shell Session)\nDESCRIPTION: Generates TypeScript code from the protobuf definition using the `protoc` compiler with the `protoc-gen-es` plugin. The generated code will be placed in the `src/gen` directory.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protobuf-example/README.md#_snippet_3\n\nLANGUAGE: shellsession\nCODE:\n```\nprotoc -I . --es_out=src/gen --es_opt=target=ts --plugin=protoc-gen-es=./node_modules/.bin/protoc-gen-es proto/example.proto\n```\n\n----------------------------------------\n\nTITLE: BinaryWriter Serialization Example TypeScript\nDESCRIPTION: Provides an example of using `BinaryWriter` to manually serialize data for a Protobuf message. It demonstrates how to use `tag`, `string`, `bool`, and `finish` methods to write fields to the binary stream. Requires importing `BinaryWriter`, `WireType`, `UserSchema`, and `fromBinary`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { UserSchema } from \"./gen/example_pb\";\n\nconst bytes = new BinaryWriter()\n  // string first_name = 1\n  .tag(1, WireType.LengthDelimited)\n  .string(\"Homer\")\n  // bool active = 3\n  .tag(3, WireType.Varint)\n  .bool(true)\n  .finish();\n\nconst user = fromBinary(UserSchema, bytes);\nuser.firstName; // \"Homer\"\nuser.active; // true\n```\n\n----------------------------------------\n\nTITLE: Migrating from method call to function call (Diff)\nDESCRIPTION: This diff illustrates how to migrate from calling methods directly on message objects (like `toJsonString()`) to using standalone functions from `@bufbuild/protobuf`. You now pass the message schema and the message object as arguments to functions like `toJsonString()`. This change aligns with the functional approach adopted in v2.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_109\n\nLANGUAGE: Diff\nCODE:\n```\nimport type { User } from \"./gen/example_pb\";\n+ import { UserSchema } from \"./gen/example_pb\";\n+ import { toJsonString } from \"@bufbuild/protobuf\";\n\nfunction show(user: User) {\n-  alert(user.toJsonString());\n+  alert(toJsonString(UserSchema, user));\n}\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a repeated string field\nDESCRIPTION: This code shows the TypeScript representation of a repeated string field. The 'locations' field becomes an array of strings ('string[]') and is initialized with an empty array as a default value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: repeated string locations = 5;\n */\nlocations: string[] = [];\n```\n\n----------------------------------------\n\nTITLE: Size-Delimited Encoding in Typescript\nDESCRIPTION: The `sizeDelimitedEncode` function from `@bufbuild/protobuf/wire` serializes a Protobuf message into a size-delimited format, which includes the message's size as a varint prefix. This function requires a message schema (`UserSchema`) and a message object (`user`) as input. It's typically used for streaming multiple messages.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sizeDelimitedEncode } from \"@bufbuild/protobuf/wire\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\nimport { createWriteStream } from \"node:fs\";\n\ndeclare const user: User;\n\nconst stream = createWriteStream(\"delim.bin\", { encoding: \"binary\" });\nstream.write(sizeDelimitedEncode(UserSchema, user));\nstream.end();\n```\n\n----------------------------------------\n\nTITLE: Migrating from class constructor to create() function (Diff)\nDESCRIPTION: This diff shows the change required when instantiating a Protobuf message.  Instead of using the `new` keyword with the message class, you now use the `create` function from `@bufbuild/protobuf`, passing the message schema.  This reflects the removal of classes in generated code in v2.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_108\n\nLANGUAGE: Diff\nCODE:\n```\n- import { User } from \"./gen/example_pb\";\n+ import { create } from \"@bufbuild/protobuf\";\n+ import { UserSchema } from \"./gen/example_pb\";\n\n- let user = new User({\n+ let user = create(UserSchema, {\n  firstName: \"Homer\",\n});\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Field Kind Inspection in TypeScript\nDESCRIPTION: This TypeScript function `handleField` takes a `DescField` as input and exhaustively inspects its `fieldKind` property to determine the field type (scalar, enum, message, list, or map).  It then accesses specific properties based on the field kind, such as `field.scalar` for scalar fields, `field.enum` for enum fields, and so on, demonstrating how to handle different protobuf field types.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescField } from \"@bufbuild/protobuf\";\n\nfunction handleField(field: DescField) {\n  field.scalar; // ScalarType | undefined\n  field.message; // DescMessage | undefined\n  field.enum; // DescEnum | undefined\n  switch (field.fieldKind) {\n    case \"scalar\":\n      field.scalar; // ScalarType.STRING for a Protobuf field string first_name = 1\n      break;\n    case \"enum\":\n      field.enum; // DescEnum\n      break;\n    case \"message\":\n      field.message; // DescMessage\n      break;\n    case \"list\":\n      field.listKind; // \"scalar\" | \"message\" | \"enum\"\n      switch (field.listKind) {\n        case \"scalar\":\n          field.scalar; // ScalarType.INT32 for the values in `repeated int32 numbers = 2`\n          break;\n        case \"message\":\n          field.message; // DescMessage for the values in `repeated User users = 2`\n          break;\n        case \"enum\":\n          field.enum; // DescEnum for the values in `repeated PhoneType types = 2`\n          break;\n      }\n      break;\n    case \"map\":\n      field.mapKey; // ScalarType.STRING for the keys in `map<string, int32> map = 2`\n      switch (field.mapKind) {\n        case \"scalar\":\n          field.scalar; // ScalarType.INT32 for the values in `map<string, int32> map = 2`\n          break;\n        case \"message\":\n          field.message; // DescMessage for the values in `map<string, User> map = 2`\n          break;\n        case \"enum\":\n          field.enum; // DescEnum for the values in `map<string, PhoneType> map = 2`\n          break;\n      }\n      break;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Read Custom Protobuf Option in TypeScript\nDESCRIPTION: Reads the custom `sensitive` option from the `lastName` field of the `User` message schema. It uses the `getOption` function from `@bufbuild/protobuf` and imports the `sensitive` option definition. The `hasOption` function checks if the option is present.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOption, hasOption } from \"@bufbuild/protobuf\";\nimport { UserSchema } from \"./gen/example_pb\";\nimport { sensitive } from \"./gen/example-option_pb\";\n\ngetOption(UserSchema.field.lastName, sensitive); // true\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Schema\nDESCRIPTION: This example demonstrates how to define a Protobuf schema using the proto3 syntax. It defines a `User` message with fields such as `first_name`, `last_name`, `active`, `manager`, `locations`, and `projects`. This schema can then be compiled to generate code in various languages.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage User {\n  string first_name = 1;\n  string last_name = 2;\n  bool active = 3;\n  User manager = 4;\n  repeated string locations = 5;\n  map<string, string> projects = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @bufbuild/protobuf with npm\nDESCRIPTION: This command installs the @bufbuild/protobuf package using npm.  It adds the package to your project's dependencies, allowing you to use the Protocol Buffers runtime library in your ECMAScript code.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protobuf/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @bufbuild/protobuf\n```\n\n----------------------------------------\n\nTITLE: Defining a Protobuf Enumeration\nDESCRIPTION: This Protobuf code defines a simple enumeration named `PhoneType` with three possible values: `UNSPECIFIED`, `MOBILE`, and `LAND_LINE`. The values are assigned integer values starting from 0.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_30\n\nLANGUAGE: protobuf\nCODE:\n```\nenum PhoneType {\n  UNSPECIFIED = 0;\n  MOBILE = 1;\n  LAND_LINE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a File Registry from FileDescriptorSet in TypeScript\nDESCRIPTION: This code snippet demonstrates how to read a `google.protobuf.FileDescriptorSet` from a binary file (generated using `buf build`), and then create a `FileRegistry` from it.  It then iterates through the files and types within the registry, accessing their names and kinds. This shows how to load and use reflection information from compiled protobuf definitions.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nimport { readFileSync } from \"node:fs\";\nimport {\n  fromBinary,\n  createFileRegistry,\n  type DescMessage,\n} from \"@bufbuild/protobuf\";\nimport { FileDescriptorSetSchema } from \"@bufbuild/protobuf/wkt\";\n\n// Read a google.protobuf.FileDescriptorSet from disk.\n// The set can be compiled with `buf build --output set.binpb`\nconst fileDescriptorSet = fromBinary(\n  FileDescriptorSetSchema,\n  readFileSync(\"set.binpb\"),\n);\n\n// Create a FileRegistry from the google.protobuf.FileDescriptorSet message:\nconst registry = createFileRegistry(fileDescriptorSet);\n\n// Loop through files\nfor (const file of registry.files) {\n  file.name;\n}\n\n// Loop through types\nfor (const type of registry) {\n  type.kind; // \"message\" | \"enum\" | \"extension\" | \"service\"\n}\n```\n\n----------------------------------------\n\nTITLE: Walking Through Message Fields (Including Oneof) in TypeScript\nDESCRIPTION: This TypeScript function iterates through all fields of a given Protobuf message using `message.fields`, including fields within a `oneof` group.  For each field, it prints the field name and indicates whether it belongs to a `oneof` group.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescMessage } from \"@bufbuild/protobuf\";\n\nfunction walkFields(message: DescMessage) {\n  for (const field of message.fields) {\n    console.log(field.name); // prints \"text\", \"number\", \"error\"\n    field.oneof; // DescOneof | undefined\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Service Schema\nDESCRIPTION: This TypeScript code demonstrates the schema generated for the `UserService` Protobuf service. The schema, `UserService`, is of type `GenService`.  It describes the service and its methods, including the input and output types for each method. The example defines one method: `createUser`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from service example.UserService\n */\nexport declare const UserService: GenService<{\n  /**\n   * @generated from rpc example.UserService.CreateUser\n   */\n  createUser: {\n    methodKind: \"unary\";\n    input: typeof CreateUserRequestSchema;\n    output: typeof CreateUserResponseSchema;\n  };\n}>;\n```\n\n----------------------------------------\n\nTITLE: Creating a Registry in TypeScript\nDESCRIPTION: This code snippet shows how to create a registry using the `createRegistry` function, initialized with a message schema, a file descriptor (which adds all types from the file), and another registry.  This demonstrates how to compose registries from different sources.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRegistry } from \"@bufbuild/protobuf\";\nimport { UserSchema, file_example } from \"./gen/example_pb\";\n\nconst registry = createRegistry(\n  UserSchema, // Initialize with a message, enum, extension, or service descriptor\n  file_example, // add all types from the file descriptor\n  otherRegistry, // Adds all types from the other registry\n);\n```\n\n----------------------------------------\n\nTITLE: Registry Usage Example in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use a `Registry` to retrieve descriptors (messages, enums, services, extensions) by their qualified names. It also shows how to iterate through all types within the registry and access their kind.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Registry } from \"@bufbuild/protobuf\";\n\ndeclare const registry: Registry;\n\n// Retrieve a type by its qualified name\nregistry.getMessage(\"example.User\"); // DescMessage | undefined\nregistry.getEnum(\"example.PhoneType\"); // DescEnum | undefined\nregistry.getService(\"example.MyService\"); // DescService | undefined\nregistry.getExtension(\"example.sensitive\"); // DescExtension | undefined\n\n// Loop through types\nfor (const type of registry) {\n  type.kind; // \"message\" | \"enum\" | \"extension\" | \"service\"\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying a Protobuf Message TypeScript\nDESCRIPTION: Explains how to use the `isMessage` type guard to check if a value is a specific Protobuf message. It demonstrates how to safely access message fields after confirming the message type.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, isMessage } from \"@bufbuild/protobuf\";\nimport { UserSchema } from \"./gen/example_pb\";\n\nconst msg: unknown = create(UserSchema);\n\nmsg.firstName; // type error\n\nif (isMessage(msg, UserSchema)) {\n  msg.firstName; // string\n}\n```\n\n----------------------------------------\n\nTITLE: Create Protobuf Plugin (TypeScript)\nDESCRIPTION: Creates a basic Protobuf plugin using `@bufbuild/protoplugin`. This plugin generates a `_hello.ts` file for each Protobuf file in the schema, containing the text `// hello world`. The plugin uses `createEcmaScriptPlugin` for TypeScript code generation and `runNodeJs` to execute the plugin.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createEcmaScriptPlugin,\n  runNodeJs,\n  type Schema,\n} from \"@bufbuild/protoplugin\";\n\nconst plugin = createEcmaScriptPlugin({\n  name: \"protoc-gen-hello\",\n  version: \"v1\",\n  generateTs(schema: Schema) {\n    // Loop through all Protobuf files in the schema\n    for (const file of schema.files) {\n      // Generate a file for each Protobuf file\n      const f = schema.generateFile(file.name + \"_hello.ts\");\n      // Print text to the file\n      f.print(\"// hello world\");\n    }\n  },\n});\n\n// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.\nrunNodeJs(plugin);\n```\n\n----------------------------------------\n\nTITLE: Configuring Buf for Code Generation (buf.gen.yaml)\nDESCRIPTION: Configures Buf to generate code using the protoc-gen-es plugin. It specifies the input directory (proto), the plugin to use (protoc-gen-es), the output directory (src/gen), and the target language (ts).\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# Learn more: https://buf.build/docs/configuration/v2/buf-gen-yaml\nversion: v2\ninputs:\n  - directory: proto\nplugins:\n  - local: protoc-gen-es\n    out: src/gen\n    opt: target=ts\n```\n\n----------------------------------------\n\nTITLE: Configure Buf to Use Plugin\nDESCRIPTION: Configures the `buf.gen.yaml` file to use the newly created Protobuf plugin. It adds the plugin to the `plugins` section, specifying the plugin's location and output directory. This allows `buf generate` to invoke the plugin during code generation.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_92\n\nLANGUAGE: diff\nCODE:\n```\n# Learn more: https://buf.build/docs/configuration/v2/buf-gen-yaml\nversion: v2\ninputs:\n  - directory: proto\nplugins:\n  - local: protoc-gen-es\n    out: src/gen\n    opt: target=ts\n+ - local: [\"tsx\", \"./src/protoc-gen-hello.ts\"]\n+   opt: target=ts\n+   out: src/gen\n```\n\n----------------------------------------\n\nTITLE: Generating protobuf code with buf\nDESCRIPTION: Executes the buf generate command to generate code from Protocol Buffer definitions based on the buf.gen.yaml configuration file. The generated code will be placed in the output directory specified in the configuration.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx buf generate\n```\n\n----------------------------------------\n\nTITLE: Base64 Encode/Decode in Typescript\nDESCRIPTION: These functions from `@bufbuild/protobuf/wire` provide Base64 encoding and decoding for Uint8Arrays. `base64Encode` takes a Uint8Array and returns a Base64 encoded string. `base64Decode` takes a Base64 encoded string and returns a Uint8Array.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nimport { base64Encode, base64Decode } from \"@bufbuild/protobuf/wire\";\n\nbase64Encode(new Uint8Array([2, 4, 8, 16])); // \"AgQIEA==\"\nbase64Decode(\"AgQIEA==\"); // Uint8Array(4) [ 2, 4, 8, 16 ]\n```\n\n----------------------------------------\n\nTITLE: Add include_imports option to buf.gen.yaml\nDESCRIPTION: Adds the `include_imports: true` option to the `buf.gen.yaml` configuration file. This ensures that dependencies, such as validation rules from `buf.build/bufbuild/protovalidate`, are generated along with the main Protobuf files. This resolves missing import issues during code generation.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_112\n\nLANGUAGE: diff\nCODE:\n```\n# buf.gen.yaml\nversion: v2\nplugins:\n  - local: protoc-gen-es\n    out: src/gen\n+   include_imports: true\n```\n\n----------------------------------------\n\nTITLE: Parsing a Message with a Schema\nDESCRIPTION: Shows an example of parsing a message using the generated schema and `fromBinary` function from `@bufbuild/protobuf`.  It converts a byte array to a User object.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromBinary } from \"@bufbuild/protobuf\";\nimport { UserSchema } from \"./gen/example_pb\";\n\nconst bytes = new Uint8Array([10, 3, 84, 105, 109]);\nfromBinary(UserSchema, bytes); // User\n```\n\n----------------------------------------\n\nTITLE: Walking Through Message Members (Fields and Oneof) in TypeScript\nDESCRIPTION: This TypeScript function uses `message.members` to iterate through both regular fields and `oneof` groups within a Protobuf message.  It checks the `kind` of each member to determine if it's a field or a `oneof`, and iterates through the fields within `oneof` groups accordingly, printing each field's name.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescMessage } from \"@bufbuild/protobuf\";\n\nfunction walkMembers(message: DescMessage) {\n  for (const member of message.members) {\n    console.log(member.name); // prints \"text\", \"result\"\n    if (member.kind == \"oneof\") {\n      for (const field of member.fields) {\n        console.log(field.name); // prints \"number\", \"error\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Schema Lookup in TypeScript\nDESCRIPTION: This example shows how to use generated schema objects to perform type-safe lookups for fields, enum values, and methods using their local names or numbers. It accesses the name of a field, enum value, and method.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UserSchema, PhoneTypeSchema, UserService } from \"./gen/example_pb\";\n\n// Look up fields by their localName\nUserSchema.field.firstName; // DescField\nUserSchema.field.firstName.name; // \"first_name\"\n\n// Look up enum values by their number\nPhoneTypeSchema.value[PhoneType.MOBILE]; // DescEnumValue\nPhoneTypeSchema.value[PhoneType.MOBILE].name; // \"PHONE_TYPE_MOBILE\"\n\n// Look up methods by their localName\nUserService.method.createUser; // DescMethod\nUserService.method.createUser.name; // \"CreateUser\"\n```\n\n----------------------------------------\n\nTITLE: Generating Files with Filename Suffix\nDESCRIPTION: This code snippet demonstrates how to iterate through files in a schema and generate a new file for each, adding a suffix to the filename to distinguish it from files generated by other plugins.  It uses the `schema.files` property to access file descriptors and the `schema.generateFile` method to create the files. The plugin's generated files are given the suffix '_hello.ts'.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nfor (const file of schema.files) {\n  // file.name is the name of the Protobuf file, minus the .proto extensions\n  schema.generateFile(file.name + \"_hello.ts\");\n}\n```\n\n----------------------------------------\n\nTITLE: Packing and Unpacking Any Messages in TypeScript\nDESCRIPTION: This code snippet shows how to pack and unpack messages into an `Any` type using the `@bufbuild/protobuf/wkt` and `@bufbuild/protobuf` libraries. It demonstrates packing a `User` message into an `Any`, checking if the `Any` contains a specific type, and unpacking the `Any` back into a `User` message, both with and without a type registry.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Any, anyPack, anyIs } from \"@bufbuild/protobuf/wkt\";\nimport { create, createRegistry } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\nlet user: User = create(UserSchema);\n\n// Create a new Any, and pack the given message into it\nlet any: Any = anyPack(UserSchema, user);\n\n// Check if the Any contains a specific type\nanyIs(any, UserSchema); // true\nanyIs(any, \"example.User\"); // true\n\n// Try to unpack a specific message from an Any\nanyUnpack(any, UserSchema); // User | undefined\n\n// Unpack an any, using a registry of known types\nconst registry = createRegistry(UserSchema);\nanyUnpack(any, registry); // Message | undefined\n```\n\n----------------------------------------\n\nTITLE: Install Plugin Dependencies (npm)\nDESCRIPTION: Installs the necessary dependencies for creating a Protobuf plugin. These include `@bufbuild/protoplugin` for the plugin framework and `tsx` for running TypeScript in Node.js.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_89\n\nLANGUAGE: shellsession\nCODE:\n```\nnpm install @bufbuild/protoplugin tsx\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Message Type\nDESCRIPTION: Shows the TypeScript type generated for a Protobuf message. It includes the message name and the types of its fields. It uses the `Message` type from `@bufbuild/protobuf`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Message } from \"@bufbuild/protobuf\";\n\n/**\n * @generated from message example.User\n */\nexport declare type User = Message<\"example.User\"> & {\n  /**\n   * @generated from field: string first_name = 1;\n   */\n  firstName: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Nested Types Recursively in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `nestedTypes` utility to iterate through all nested types (messages, enums, extensions, and services) within a DescFile or DescMessage object. It shows how to access the type and kind of each nested type.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\nimport { nestedTypes } from \"@bufbuild/protobuf/reflect\";\nimport { file_example as file } from \"./gen/example_pb\";\n\nfor (const type of nestedTypes(file)) {\n  type; // DescMessage | DescEnum | DescExtension | DescService\n  type.kind; // \"message\" | \"enum\" | \"extension\" | \"service\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enum JSON conversion\nDESCRIPTION: This example demonstrates the use of `enumToJson`, `enumFromJson` and `isEnumJson` with the generated FormatSchema. It shows how to convert between Enum and JSON representations and type narrowing for increased type safety.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_67\n\nLANGUAGE: ts\nCODE:\n```\nconst strVal: FormatJson = enumToJson(FormatSchema, Format.BINARY);\n\nconst enumVal: Format = enumFromJson(FormatSchema, strVal);\n\nconst someString: string = \"FORMAT_BINARY\";\nif (isEnumJson(FormatSchema, someString)) {\n  someString; // FormatJson\n}\n```\n\n----------------------------------------\n\nTITLE: Apply Custom Protobuf Option\nDESCRIPTION: Applies the custom `sensitive` option to the `last_name` field in the `User` message. This indicates that the field should be treated as sensitive data. Requires the custom option definition from `options-example.proto`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_82\n\nLANGUAGE: diff\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\n\nmessage User {\n  string first_name = 1;\n- string last_name = 2;\n+ string last_name = 2 [(example.options.sensitive) = true];\n  bool active = 3;\n  User manager = 4;\n  repeated string locations = 5;\n  map<string, string> projects = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JSON Type for Protobuf Message\nDESCRIPTION: This Typescript type is automatically generated when `json_types=true` plugin option is enabled. It provides type safety when working with JSON representations of Protobuf messages, ensuring that JSON objects conform to the expected structure and field types.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_63\n\nLANGUAGE: ts\nCODE:\n```\n/**\n * @generated from message Example\n */\nexport type ExampleJson = {\n  /**\n   * @generated from field: int32 amount = 1;\n   */\n  amount?: number;\n\n  /**\n   * @generated from field: bytes data = 2;\n   */\n  data?: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing generated code with TypeScript\nDESCRIPTION: This snippet demonstrates how to import a generated file using TypeScript. It is used to measure the size of the resulting bundle after minification and compression, for a code size comparison between Protobuf-ES and google-protobuf.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/bundle-size/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Service } from \"./Service_pb\";\n// This is a placeholder for the actual code from entry-1.ts\n\n```\n\n----------------------------------------\n\nTITLE: Managing Protobuf Extensions in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to manage Protobuf extensions using functions like `setExtension`, `getExtension`, `hasExtension`, and `clearExtension` from the `@bufbuild/protobuf` library. It shows how to set, retrieve, check for existence, and clear extension values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  setExtension,\n  getExtension,\n  hasExtension,\n  clearExtension,\n} from \"@bufbuild/protobuf\";\n\nsetExtension(user, age, 77);\nhasExtension(user, age); // true\ngetExtension(user, age); // 77\nclearExtension(user, age);\nhasExtension(user, age); // false\n```\n\n----------------------------------------\n\nTITLE: ReflectList Usage Example\nDESCRIPTION: Demonstrates how to iterate through a `ReflectList` which represents a repeated field in a Protobuf message. It shows how to access elements, add new elements, and handles errors for invalid values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescField } from \"@bufbuild/protobuf\";\nimport type { ReflectMessage } from \"@bufbuild/protobuf/reflect\";\n\ndeclare const field: DescField;\ndeclare const message: ReflectMessage;\n\nif (field.fieldKind == \"list\") {\n  const list: ReflectList = message.get(field);\n  for (const item of list) {\n    // ReflectList is iterable\n  }\n  list.get(123); // can be undefined\n  list.add(123); // throws an error for invalid values\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Code with protoc (Yarn)\nDESCRIPTION: Generates TypeScript code from a Protobuf file using `protoc` with yarn. Yarn v2 and above do not use `node_modules` directly, so you need to adjust the path to the protoc-gen-es executable.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_6\n\nLANGUAGE: shellsession\nCODE:\n```\nPATH=$(dirname $(yarn bin protoc-gen-es)):$PATH\n```\n\n----------------------------------------\n\nTITLE: Using Struct as JsonObject in TypeScript\nDESCRIPTION: This snippet illustrates how a `google.protobuf.Struct` field is generated as a `JsonObject` in TypeScript using `@bufbuild/protobuf`. It shows a simple example of assigning a JavaScript object to a `struct` field in a Protobuf message. This allows for easy manipulation of dynamic data.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: google.protobuf.Struct struct = 1;\n */\nstruct?: JsonObject;\n\n\nmyMessage.struct = {\n  text: \"abc\",\n  number: 123,\n};\n```\n\n----------------------------------------\n\nTITLE: Converting a String to a TypeScript Enum Value\nDESCRIPTION: This TypeScript code demonstrates converting a string to its corresponding enum value.  It uses the enum as an object to access the value associated with the string.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nlet val: PhoneType = PhoneType[\"MOBILE\"];\n```\n\n----------------------------------------\n\nTITLE: ReflectMap Usage Example\nDESCRIPTION: Demonstrates how to iterate through a `ReflectMap` which represents a map field in a Protobuf message. It shows how to access elements, check for key existence, and handles errors for invalid keys or values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescField } from \"@bufbuild/protobuf\";\nimport type { ReflectMessage } from \"@bufbuild/protobuf/reflect\";\n\ndeclare const field: DescField;\ndeclare const message: ReflectMessage;\n\nif (field.fieldKind == \"map\") {\n  const map: ReflectMap = message.get(field);\n  for (const [key, value] of map) {\n    // ReflectMap is iterable\n  }\n  map.has(123); // boolean\n  map.get(123); // can be undefined\n  map.set(123, \"abc\"); // throws an error for invalid keys or values\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Code with protoc\nDESCRIPTION: Generates TypeScript code from a Protobuf file using the `protoc` compiler and the `protoc-gen-es` plugin. It requires adding the `node_modules/.bin` directory to the `$PATH` so that `protoc` can find the plugin.  The example demonstrates compilation of proto/example.proto to src/gen.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_5\n\nLANGUAGE: shellsession\nCODE:\n```\nPATH=$PATH:$(pwd)/node_modules/.bin \\\n    protoc -I . \\\n    --es_out src/gen \\\n    --es_opt target=ts \\\n    proto/example.proto\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Extensions\nDESCRIPTION: This Protobuf code defines an extension field named `age` of type `uint32` for the `User` message.  The `extensions` range within the `User` message specifies the range of field numbers available for extensions. The `extend` keyword associates the extension field with the `User` message.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_37\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto2\";\n\nmessage User {\n  extensions 100 to 200;\n}\n\n// The extension can also be defined in a separate file\nextend User {\n  optional uint32 age = 100;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Protobuf Messages TypeScript\nDESCRIPTION: Shows how to use the `equals` function to check if two messages of the same schema have the same field values. It imports the `equals` function and the message schema. Requires `User` type and `UserSchema` to be defined.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nimport { equals } from \"@bufbuild/protobuf\";\nimport { type User, UserSchema } from \"./gen/example_pb\";\n\ndeclare const a: User;\ndeclare const b: User;\n\nequals(UserSchema, a, b); // boolean\n```\n\n----------------------------------------\n\nTITLE: Buf Generate Output with Plugin\nDESCRIPTION: Shows the output directory after running `buf generate` with the configured plugin. A new file `example_hello.ts` is generated in the `src/gen` directory, containing the content specified by the plugin.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_93\n\nLANGUAGE: diff\nCODE:\n```\n.\n├── buf.gen.yaml\n├── package.json\n├── proto\n│   └── example.proto\n└── src\n    ├── gen\n    │   ├── example_pb.ts\n+   │   └── example_hello.ts\n    └── protoc-gen-hello.ts\n```\n\n----------------------------------------\n\nTITLE: buf.gen.yaml configuration for protoc-gen-es\nDESCRIPTION: Configuration file for buf, specifying the protoc-gen-es plugin to generate code from Protocol Buffer definitions. It sets the output directory to src/gen and includes a plugin option to target TypeScript.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Learn more: https://buf.build/docs/configuration/v2/buf-gen-yaml\nversion: v2\nplugins:\n  # This will invoke protoc-gen-es and write output to src/gen\n  - local: protoc-gen-es\n    out: src/gen\n    opt:\n      # Add more plugin options here\n      - target=ts\n```\n\n----------------------------------------\n\nTITLE: Generating Code with Buf\nDESCRIPTION: This example shows how to generate code from Protobuf files using the `buf` command-line tool. It assumes that the `buf.gen.yaml` file is configured correctly and that the Protobuf files are located in the specified input directory. Requires buf cli to be installed.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_5\n\nLANGUAGE: shellsession\nCODE:\n```\nnpx buf generate\n```\n\n----------------------------------------\n\nTITLE: Modifying Repeated Protobuf Extension Fields\nDESCRIPTION: This TypeScript code demonstrates how to modify a repeated extension field (e.g., a list of strings) by first retrieving the extension's value, modifying it, and then setting the extension with the modified value. The example showcases adding values to a repeated string extension called `hobbies`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  setExtension,\n  getExtension,\n  hasExtension,\n  clearExtension,\n} from \"@bufbuild/protobuf\";\nimport { hobbies } from \"./example_pb.js\";\n\nconst h = getExtension(user, hobbies);\nh.push(\"Baking\");\nh.push(\"Pottery\");\n\nsetExtension(user, hobbies, h);\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Plugin Options with Buf\nDESCRIPTION: Specifies multiple plugin options in the `buf.gen.yaml` file, using a YAML list. This example sets both `target` and `import_extension` options.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# buf.gen.yaml\nversion: v2\nplugins:\n  - local: protoc-gen-es\n    out: src/gen\n    opt: # multiple options\n      - target=ts\n      - import_extension=js\n```\n\n----------------------------------------\n\nTITLE: Compiling Protobuf files with buf CLI\nDESCRIPTION: This shell command compiles all Protobuf files in the directory `proto` and outputs a binary file descriptor set named `set.binpb`. This file descriptor set can then be used to create a file registry.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_79\n\nLANGUAGE: shellsession\nCODE:\n```\nbuf build proto --output set.binpb\n```\n\n----------------------------------------\n\nTITLE: Buf configuration to override field option jstype\nDESCRIPTION: This YAML snippet shows how to configure the buf tool to automatically set the `jstype` field option to `JS_STRING` for all applicable fields, effectively generating `string` instead of `bigint` for 64-bit integer fields.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n# Add to buf.gen.yaml:\nmanaged:\n  enabled: true\n  override:\n    - field_option: jstype\n      value: JS_STRING\n```\n\n----------------------------------------\n\nTITLE: JSON type Usage Example\nDESCRIPTION: Demonstrates usage of the generated JSON type with the `toJson` function. It shows how the `toJson` function returns the generated JSON type when available providing type safety when working with JSON representations.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_64\n\nLANGUAGE: ts\nCODE:\n```\nconst example = create(ExampleSchema, { amount: 123 });\nconst json: ExampleJson = toJson(ExampleSchema, example);\n\n// Without json_types=true, the following would be a type error:\njson.amount; // number | undefined\njson.data; // string | undefined\n```\n\n----------------------------------------\n\nTITLE: Download and Extract Project (Shell)\nDESCRIPTION: Downloads the example project, extracts the relevant directory, changes the current directory to it, and installs dependencies using npm. This prepares the environment for running the protobuf example.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protobuf-example/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl -L https://github.com/bufbuild/protobuf-es/archive/refs/heads/main.zip > protobuf-es-main.zip\nunzip protobuf-es-main.zip 'protobuf-es-main/packages/protobuf-example/*'\n\ncd protobuf-es-main/packages/protobuf-example\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing buf for protobuf code generation\nDESCRIPTION: Installs the buf CLI tool as a development dependency using npm. This tool is used to generate code from Protocol Buffer definitions, offering more advanced features compared to protoc.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev @bufbuild/buf\n```\n\n----------------------------------------\n\nTITLE: Regenerate Code Using Buf\nDESCRIPTION: This command regenerates the code using the buf tool. It leverages the configuration defined in `buf.gen.yaml`.\nBuf must be installed and configured correctly for this command to work.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoplugin-example/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnpx buf generate\n```\n\n----------------------------------------\n\nTITLE: Size-Delimited Decoding in Typescript\nDESCRIPTION: The `sizeDelimitedDecodeStream` function from `@bufbuild/protobuf/wire` parses size-delimited Protobuf messages from an asynchronous iterable of Uint8Arrays. It expects an `AsyncIterable<Uint8Array>` and a message schema (`UserSchema`). It yields individual message objects as they are parsed from the stream.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sizeDelimitedDecodeStream } from \"@bufbuild/protobuf/wire\";\nimport { createReadStream } from \"node:fs\";\n\nconst stream = createReadStream(\"delim.bin\");\nfor await (const user of sizeDelimitedDecodeStream(UserSchema, stream)) {\n  console.log(user);\n}\n```\n\n----------------------------------------\n\nTITLE: Generated File Schema Declaration\nDESCRIPTION: Shows the declaration of the file schema. This is used for registry creation or advanced use cases with reflection.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Describes the file example.proto.\n */\nexport declare const file_example: GenFile;\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf-ES Dependencies\nDESCRIPTION: Installs the required dependencies for Protobuf-ES, including the runtime library (@bufbuild/protobuf), the code generator (@bufbuild/protoc-gen-es), and the Buf CLI (@bufbuild/buf) as a dev dependency. Buf CLI is used for code generation.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\nnpm install @bufbuild/protobuf\nnpm install --save-dev @bufbuild/buf @bufbuild/protoc-gen-es\n```\n\n----------------------------------------\n\nTITLE: Printing a Line of Text to a File\nDESCRIPTION: This snippet demonstrates how to print a line of text to a generated file using the `f.print()` method.  It showcases printing a simple string literal. Requires an existing `GeneratedFile` object `f` obtained via `schema.generateFile`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nf.print(\"// hello world\");\n\n// Generates the line:\n// hello world\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Schema and Shape\nDESCRIPTION: This code demonstrates importing schema and shape information for a Protobuf message using `f.importSchema()` and `f.importShape()`. This is useful for generating code that interacts with Protobuf messages. It imports `create` from `@bufbuild/protobuf` and the message type and schema from the generated protobuf files.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_103\n\nLANGUAGE: typescript\nCODE:\n```\nfor (const message of file.messages) {\n  const { create } = f.runtime;\n  const schema = f.importSchema(message);\n  const shape = f.importShape(message);\n  f.print(\"const msg: \", shape, \" = \", create, \"(\", schema, \");\");\n}\n\n// Generates:\n// import { create } from \"@bufbuild/protobuf\";\n// import type { User } from \"./example_pb\";\n// import { UserSchema } from \"./example_pb\";\n// const msg: User = create(UserSchema);\n```\n\n----------------------------------------\n\nTITLE: Printing String and Array Literals\nDESCRIPTION: This snippet demonstrates how to print string and array literals to a generated file using the `f.string()` and `f.array()` methods. These methods ensure the values are properly formatted as literals in the generated code.  Relies on the `GeneratedFile` object `f`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nf.print(\"const str = \", f.string(\"hello\"), \";\");\n// Generates:\n// const str = \"hello\";\n\nf.print(\"const arr = \", f.array([1, 2, 3]), \";\");\n// Generates:\n// const arr = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Importing Symbols\nDESCRIPTION: This code demonstrates how to import symbols (like functions or variables) from other modules and use them in the generated code. The `f.import()` method creates an `ImportSymbol`, which, when printed, automatically generates the necessary import statement at the top of the file.  Requires the `react` package to be available.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\nconst useEffect = f.import(\"useEffect\", \"react\");\n```\n\n----------------------------------------\n\nTITLE: Printing with Template Literals\nDESCRIPTION: This code shows how to use template literals with the `f.print` method for generating code.  This allows for easier string interpolation. It depends on the existing `GeneratedFile` object `f`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nconst world = \"world\";\nf.print`// hello ${world}`;\n\n// Generates the line:\n// hello world\n```\n\n----------------------------------------\n\nTITLE: Setting a Protobuf Extension Field in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to set the value of the `age` extension field on a `User` message using the `setExtension` function from `@bufbuild/protobuf`. It imports the necessary modules and then sets the extension.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setExtension } from \"@bufbuild/protobuf\";\nimport { User, age } from \"./example_pb.js\";\n\nconst user = new User();\nsetExtension(user, age, 77);\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a oneof field\nDESCRIPTION: This code displays the TypeScript representation of a Protobuf `oneof` field. The `oneof` becomes an object with 'case' and 'value' properties, representing the selected field and its value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nresult:\n  | { case: \"number\";  value: number }\n  | { case: \"error\";   value: string }\n  | { case: undefined; value?: undefined } = { case: undefined };\n```\n\n----------------------------------------\n\nTITLE: Usage of Redact Function\nDESCRIPTION: Demonstrates how to use the `redact` function to redact the `lastName` field of a `User` message. It creates a new `User` message, sets the `lastName` field, calls the `redact` function, and then checks that the `lastName` field has been cleared.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from \"@bufbuild/protobuf\";\nimport { redact } from \"./redact\";\nimport { UserSchema } from \"./gen/example_pb\";\n\nconst msg = create(UserSchema, {\n  firstName: \"Homer\",\n  // This field has the option (example.options.sensitive) = true\n  lastName: \"Simpson\",\n});\n\nmsg.lastName; // \"Simpson\"\nredact(UserSchema, msg);\nmsg.lastName; // \"\"\n```\n\n----------------------------------------\n\nTITLE: List Users (Shell Session)\nDESCRIPTION: Executes the 'list' script using npm. This script retrieves and displays the list of users. Assumes npm and the 'list' script are properly configured in the project.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protobuf-example/README.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\nnpm run list\n```\n\n----------------------------------------\n\nTITLE: Defining a Protobuf Service\nDESCRIPTION: This Protobuf code defines a service called `UserService` with a single Remote Procedure Call (RPC) method, `CreateUser`. The `CreateUser` method takes a `CreateUserRequest` as input and returns a `CreateUserResponse`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_42\n\nLANGUAGE: protobuf\nCODE:\n```\nservice UserService {\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript enum example\nDESCRIPTION: This TypeScript code defines an enum named `Species` mirroring the Protobuf definition. It assigns numeric values to each enum member.  The `hamster` variable demonstrates assigning a numeric value (3) to the enum, which might be out of the declared range.  Note that TypeScript 5.0 and later behave differently with out-of-range enum values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_111\n\nLANGUAGE: TypeScript\nCODE:\n```\nenum Species {\n  UNSPECIFIED = 0,\n  CAT = 1,\n  DOG = 2,\n}\nconst hamster: Species = 3;\n```\n\n----------------------------------------\n\nTITLE: Creating and Modifying a Mutable Registry in TypeScript\nDESCRIPTION: This snippet shows how to create a mutable registry using `createMutableRegistry` and then add and remove descriptors (message schemas) from the registry. This demonstrates the dynamic nature of mutable registries.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMutableRegistry } from \"@bufbuild/protobuf\";\nimport { UserSchema } from \"./gen/example_pb\";\n\nconst registry = createMutableRegistry();\n\n// Adds a message, enum, extension, or service descriptor to the registry\nregistry.add(UserSchema);\n\n// Removes a descriptor\nregistry.remove(UserSchema);\n```\n\n----------------------------------------\n\nTITLE: Walking Through Oneof Groups and Fields in TypeScript\nDESCRIPTION: This TypeScript function demonstrates how to iterate specifically through `oneof` groups within a Protobuf message using `message.oneofs`.  For each `oneof` group, it prints the group's name and then iterates through the fields within that `oneof`, printing each field's name.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescMessage } from \"@bufbuild/protobuf\";\n\nfunction walkOneofs(message: DescMessage) {\n  for (const oneof of message.oneofs) {\n    console.log(oneof.name); // prints \"result\"\n    for (const field of oneof.fields) {\n      console.log(field.name); // prints \"number\", \"error\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Protobuf Import Example\nDESCRIPTION: Illustrates importing a Protobuf definition, specifically the validation rules from `buf.build/bufbuild/protovalidate`. This snippet shows the necessary import statement within a `.proto` file to utilize external Protobuf definitions.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_113\n\nLANGUAGE: protobuf\nCODE:\n```\nimport \"buf/validate/validate.proto\";\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a proto2 group field\nDESCRIPTION: This code shows the generated TypeScript for a proto2 group field. It includes the property declaration and assumes the message `User_MyGroup` is defined elsewhere.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: optional example.User.MyGroup mygroup = 1;\n */\nmygroup?: User_MyGroup;\n```\n\n----------------------------------------\n\nTITLE: Run Protoplugin Example\nDESCRIPTION: This command starts the example application using npm. It assumes that the dependencies have already been installed.\nIt starts the application, typically on port 3000.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoplugin-example/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a proto2 group field\nDESCRIPTION: This snippet defines a proto2 group field named 'MyGroup' containing an int32 field. Group fields are a deprecated feature.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_26\n\nLANGUAGE: protobuf\nCODE:\n```\noptional group MyGroup = 1 {\n  optional int32 int32_field = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating buf.gen.yaml for remote plugin\nDESCRIPTION: This YAML configuration updates the `buf.gen.yaml` file to specify the version 2.0.0 of the remote Protobuf-ES plugin. It ensures that the Buf CLI uses the correct plugin version when generating code. The `remote` specifies the remote plugin's location, and `out` specifies the output directory.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_107\n\nLANGUAGE: YAML\nCODE:\n```\n# buf.gen.yaml\nversion: v2\nplugins:\n  - remote: buf.build/bufbuild/es:v2.0.0\n    out: gen\n```\n\n----------------------------------------\n\nTITLE: Initializing a TypeScript Project\nDESCRIPTION: Creates a new TypeScript project, initializes npm, installs TypeScript, and configures TypeScript with `tsc --init`. This sets up the basic environment for TypeScript development.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_1\n\nLANGUAGE: shellsession\nCODE:\n```\nmkdir example\ncd example\nnpm init -y\nnpm install typescript\nnpx tsc --init\n```\n\n----------------------------------------\n\nTITLE: Printing and Using Imported Symbols\nDESCRIPTION: This snippet shows how to print and use an `ImportSymbol` obtained from the `f.import()` method.  When the `ImportSymbol` is printed, an import statement is automatically generated. This example uses the `useEffect` hook from React. Requires that `useEffect` variable be previously assigned from a call to `f.import()`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_102\n\nLANGUAGE: typescript\nCODE:\n```\nf.print(useEffect, \"(() => {\");\nf.print(\"  document.title = `You clicked ${count} times`;\");\nf.print(\"}, [count]);\");\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Redact Function\nDESCRIPTION: Improves the `redact` function by adding type inference and constraints to ensure that the schema and message match. This prevents runtime errors caused by mismatched types.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { DescMessage, MessageShape } from \"@bufbuild/protobuf\";\n\nexport function redact<Desc extends DescMessage>(\n  schema: Desc,\n  message: MessageShape<Desc>,\n) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using jstype option to generate string instead of bigint\nDESCRIPTION: This snippet demonstrates how to use the `jstype` option to force the generation of a `string` type instead of `bigint` for a 64-bit integer field in Protobuf.  This is useful when `bigint` is not available in the target environment.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_16\n\nLANGUAGE: protobuf\nCODE:\n```\nint64 field = 1 [jstype = JS_STRING]; // will generate `field: string`\n```\n\n----------------------------------------\n\nTITLE: Adding a Preamble to Generated Files\nDESCRIPTION: This code shows how to add a preamble to a generated file, providing helpful information about the plugin and the Protobuf file. The `f.preamble(file)` call generates lines indicating the plugin version and the Protobuf file's origin. This snippet depends on `schema.generateFile` being previously called to create the file object `f`. \nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nconst f = schema.generateFile(file.name + \"_hello.ts\");\nf.preamble(file);\n\n// Generates the lines:\n// @generated by protoc-gen-hello v1 with parameter \"target=ts\"\n// @generated from file example.proto (package example, syntax proto3)\n```\n\n----------------------------------------\n\nTITLE: Define Custom Protobuf Option\nDESCRIPTION: Defines a custom Protobuf option named `sensitive` as an extension to `google.protobuf.FieldOptions`. This allows marking fields as sensitive within Protobuf definitions.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_81\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example.options;\nimport \"google/protobuf/descriptor.proto\";\n\nextend google.protobuf.FieldOptions {\n  // This field should be redacted\n  bool sensitive = 8765;\n}\n```\n\n----------------------------------------\n\nTITLE: Walking through Schema Elements in TypeScript\nDESCRIPTION: This code snippet demonstrates how to iterate through messages, enumerations, services, and extensions defined in a protobuf file using the DescFile object from @bufbuild/protobuf. It accesses type names, field details, and method information.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nimport { file_example as file } from \"./gen/example_pb\";\n\n// Loop through all messages defined at the root\nfor (const message of file.messages) {\n  message; // DescMessage\n  message.typeName; // The fully qualified name, e.g. \"example.User\"\n\n  // Loop through all fields for this message\n  for (const field of message.fields) {\n    field; // DescField\n  }\n\n  // Messages, enumerations, and extensions can be nested in a message definition\n  message.nestedMessages; // DescMessage[]\n  message.nestedEnums; // DescEnum[]\n  message.nestedExtensions; // DescExtension[]\n}\n\n// Loop through all enumerations defined at the root\nfor (const enumeration of file.enums) {\n  enumeration; // DescEnum\n  enumeration.typeName; // The fully qualified name, e.g. \"example.PhoneType\"\n\n  // Loop through all values of this enumeration\n  for (const value of enumeration.values) {\n    value; // DescEnumValue\n    value.name; // The name as specified in the source, e.g. \"PHONE_TYPE_MOBILE\"\n  }\n}\n\n// Loop through all services\nfor (const service of file.services) {\n  service; // DescService\n  service.typeName; // The fully qualified name, e.g. \"example.UserService\"\n\n  // Loop through all methods of this service\n  for (const method of service.methods) {\n    method; // DescMethod\n    method.name; // The name as specified in the source, e.g. \"CreateUser\"\n  }\n}\n\n// Loop through all extensions defined at the root\nfor (const extension of file.extensions) {\n  method; // DescExtension\n  extension.typeName; // The fully qualified name, e.g. \"example.sensitive\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Enum Schema\nDESCRIPTION: This TypeScript code shows the declaration of a schema for the `PhoneType` enum. The schema, represented by `PhoneTypeSchema`, provides metadata about the enum for reflection purposes.  The type `GenEnum<PhoneType>` represents a generic enum schema.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Describes the enum example.PhoneType.\n */\nexport declare const PhoneTypeSchema: GenEnum<PhoneType>;\n```\n\n----------------------------------------\n\nTITLE: Protobuf Message Definition Example\nDESCRIPTION: This code snippet defines a simple Protobuf message named `Question` with a string field `text` and a `oneof` group named `result` that can contain either an integer `number` or a string `error`. This example illustrates the basic structure of a protobuf message with a oneof.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_71\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage Question {\n  string text = 1;\n  oneof result {\n    int32 number = 2;\n    string error = 3;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TypeScript Extension Declaration\nDESCRIPTION: This TypeScript code represents the generated declaration for the `age` extension field. It exports a constant `age` of type `GenExtension<User, number>`.  `GenExtension` is a generic type that represents a Protobuf extension, parameterized by the message it extends and the type of the extension.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from extension: optional uint32 age = 100;\n */\nexport declare const age: GenExtension<User, number>;\n```\n\n----------------------------------------\n\nTITLE: Protobuf Message Definition\nDESCRIPTION: Defines a simple Protobuf message `Example` with an integer field `amount` and a bytes field `data`.  This definition serves as a basis for demonstrating JSON type generation using `json_types=true` option.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_62\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage Example {\n  int32 amount = 1;\n  bytes data = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Enum from Protobuf\nDESCRIPTION: This TypeScript code represents the generated enum from the Protobuf definition of `PhoneType`. It mirrors the values and names defined in the Protobuf enum.  This example demonstrates the default behavior when enum values don't share a prefix.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from enum example.PhoneType\n */\nexport enum PhoneType {\n  UNSPECIFIED = 0,\n  MOBILE = 1,\n  LAND_LINE = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Test Generated Code\nDESCRIPTION: This command runs the tests for the generated code using npm. It assumes that the tests are defined in the `package.json` file.\nThis allows verification that the generated code functions as expected.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoplugin-example/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Add User (Shell Session)\nDESCRIPTION: Executes the 'add' script using npm. This script prompts the user for information to create a new user entry. Assumes npm and the 'add' script are properly configured in the project.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protobuf-example/README.md#_snippet_1\n\nLANGUAGE: shellsession\nCODE:\n```\nnpm run add\n```\n\n----------------------------------------\n\nTITLE: Exporting a Declaration\nDESCRIPTION: This code shows how to export a declaration (e.g., a constant) from the generated code using the `f.export()` method. This allows other modules to use the generated code. The first argument is the type of declaration (e.g., 'const'), and the second is the name of the declaration.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_104\n\nLANGUAGE: typescript\nCODE:\n```\nf.print(f.export(\"const\", \"foo\"), \" = 123;\");\n\n// Generates:\n// export const foo = 123;\n```\n\n----------------------------------------\n\nTITLE: Generating protobuf code with protoc using Yarn\nDESCRIPTION: Example command using Yarn to generate code from Protocol Buffer definitions.  It configures the PATH variable to include the location where yarn installs executable binaries, and then executes the protoc compiler with the es_out and es_opt parameters.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoc-gen-es/README.md#_snippet_5\n\nLANGUAGE: shellsession\nCODE:\n```\nPATH=$(dirname $(yarn bin protoc-gen-es)):$PATH\n```\n\n----------------------------------------\n\nTITLE: Printing Literals\nDESCRIPTION: This example demonstrates printing literals like numbers, booleans, and byte arrays to a generated file. It shows how numeric and boolean values are printed directly. Byte arrays are formatted as `Uint8Array` literals.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nf.print(\"const num = \", 123, \";\");\n// Generates:\n// const num = 123;\n\nf.print(\"const bool = \", true, \";\");\n// Generates:\n// const bool = true;\n\nf.print(\"const bytes = \", new Uint8Array([0xde, 0xad, 0xbe, 0xef]), \";\");\n// Generates:\n// const bytes = new Uint8Array([0xDE, 0xAD, 0xBE, 0xEF]);\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a repeated string field\nDESCRIPTION: This snippet defines a repeated field 'locations' of type string. Repeated fields are used to represent arrays of values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_20\n\nLANGUAGE: protobuf\nCODE:\n```\nrepeated string locations = 5;\n```\n\n----------------------------------------\n\nTITLE: Generated JSON Type for Protobuf Enum\nDESCRIPTION: This Typescript type is generated to represent the valid JSON string values for the `Format` enum. It is a union type of string literals, providing type safety when converting between enum values and their JSON string representations.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_66\n\nLANGUAGE: ts\nCODE:\n```\n/**\n * @generated from enum Format\n */\nexport type FormatJson = \"FORMAT_UNSPECIFIED\" | \"FORMAT_BINARY\" | \"FORMAT_JSON\";\n```\n\n----------------------------------------\n\nTITLE: Generating a TypeScript Enum with Prefix Removal\nDESCRIPTION: This TypeScript code shows the generated enum where the common prefix `PHONE_TYPE_` has been automatically removed from the enum value names.  This keeps the generated enum cleaner and more readable.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from enum example.PhoneType\n */\nexport enum PhoneType {\n  UNSPECIFIED = 0,\n  MOBILE = 1,\n  LAND_LINE = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a message field\nDESCRIPTION: This snippet shows the generated TypeScript code for a Protobuf message field. The 'manager' field of type 'User' becomes an optional property 'manager' of type 'User' in TypeScript.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: example.User manager = 4;\n */\nmanager?: User\n```\n\n----------------------------------------\n\nTITLE: Defining a Protobuf Message with Nested Enum\nDESCRIPTION: This Protobuf code defines a message `User` with a nested enum `Type`. Nested types inherit the namespace of their parent message. `User.Type` contains enum values for different user types.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_44\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage example;\n\nmessage User {\n  string first_name = 1;\n  Type type = 7;\n\n  enum Type {\n    USER = 0;\n    MANAGER = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a message field\nDESCRIPTION: This Protobuf code defines a message field 'manager' of type 'User' with field number 4. This shows how to embed one message type within another.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_18\n\nLANGUAGE: protobuf\nCODE:\n```\nUser manager = 4;\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for a proto3 optional field\nDESCRIPTION: This code shows the TypeScript representation for a proto3 optional boolean field. The `active` field becomes an optional property of type `boolean`.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: optional bool active = 3;\n */\nactive?: boolean;\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a oneof field\nDESCRIPTION: This snippet defines a `oneof` field named 'result' that can hold either an integer ('number') or a string ('error').  Only one of the fields within a `oneof` can be set at a time.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_24\n\nLANGUAGE: protobuf\nCODE:\n```\noneof result {\n  int32 number = 1;\n  string error = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a proto3 optional field\nDESCRIPTION: This snippet demonstrates the declaration of an optional boolean field named `active` in proto3. Optional fields allow tracking whether a field is explicitly set or has its default value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_28\n\nLANGUAGE: protobuf\nCODE:\n```\noptional bool active = 3;\n```\n\n----------------------------------------\n\nTITLE: Protobuf definition for a map field\nDESCRIPTION: This snippet defines a map field 'projects' with string keys and string values.  Protobuf map fields are used to represent key-value pairs.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_22\n\nLANGUAGE: protobuf\nCODE:\n```\nmap<string, string> projects = 6;\n```\n\n----------------------------------------\n\nTITLE: Generated Wrapper Message Field TypeScript\nDESCRIPTION: Example of a generated TypeScript field using a wrapper message from google/protobuf/wrappers.proto. This allows for distinguishing between the absence of a value and its default value.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: google.protobuf.BoolValue bool_value_field = 1;\n */\nboolValueField?: boolean;\n```\n\n----------------------------------------\n\nTITLE: Protobuf Enum Definition\nDESCRIPTION: Defines a simple Protobuf enum `Format` with three values: `FORMAT_UNSPECIFIED`, `FORMAT_BINARY`, and `FORMAT_JSON`. This enum definition is used to showcase the generation of a union type for JSON string values.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_65\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nenum Format {\n  FORMAT_UNSPECIFIED = 0;\n  FORMAT_BINARY = 1;\n  FORMAT_JSON = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript for string scalar field\nDESCRIPTION: This code shows how a Protobuf string scalar field is generated as a TypeScript property.  The Protobuf field 'first_name' becomes a 'firstName' property of type 'string' in TypeScript.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @generated from field: string first_name = 1;\n */\nfirstName: string;\n```\n\n----------------------------------------\n\nTITLE: Download and Setup Protoplugin Example\nDESCRIPTION: This shell script downloads the protobuf-es repository, extracts the protoplugin-example, navigates into the directory, and installs the necessary npm dependencies.\nThe dependencies must be installed before you can compile and run the plugin.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/packages/protoplugin-example/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -L https://github.com/bufbuild/protobuf-es/archive/refs/heads/main.zip > protobuf-es-main.zip\nunzip protobuf-es-main.zip 'protobuf-es-main/packages/protoplugin-example/*'\n\ncd protobuf-es-main/packages/protoplugin-example\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Protobuf enum example\nDESCRIPTION: This Protobuf code defines an enum named `Species` with three possible values: `UNSPECIFIED`, `CAT`, and `DOG`. This is used as the type for the `species` field in the `Animal` message.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_110\n\nLANGUAGE: Proto\nCODE:\n```\nenum Species {\n  UNSPECIFIED = 0;\n  CAT = 1;\n  DOG = 2;\n}\nmessage Animal {\n  Species species = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading Protobuf Example File\nDESCRIPTION: This example shows how to download an example Protobuf file (`example.proto`) into a `proto` directory using `curl`. This file can then be used as input for the code generation process.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/README.md#_snippet_4\n\nLANGUAGE: shellsession\nCODE:\n```\nmkdir proto\ncurl https://raw.githubusercontent.com/bufbuild/protobuf-es/main/packages/protobuf-example/proto/example.proto > proto/example.proto\n```\n\n----------------------------------------\n\nTITLE: Generating Deprecated Protobuf Field with JSDoc\nDESCRIPTION: This TypeScript code demonstrates the JSDoc comment added to a deprecated field in the generated code.  The comment includes a `@deprecated` tag, indicating the field should no longer be used.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * This field is deprecated\n *\n * @generated from field: string deprecated_field = 1 [deprecated = true];\n * @deprecated\n */\ndeprecatedField = \"\";\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Preamble\nDESCRIPTION: Shows the preamble generated at the top of each TypeScript file.  It includes information about the generator version, the source file, and disables eslint rules.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// @generated by protoc-gen-es v2.0.0 with parameter \"target=dts\"\n// @generated from file example.proto (package example, syntax proto3)\n/* eslint-disable */\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Message Schema\nDESCRIPTION: Shows the TypeScript schema generated for a Protobuf message. This schema can be used to parse the message.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport declare const UserSchema: GenMessage<User>;\n```\n\n----------------------------------------\n\nTITLE: Defining a Protobuf Enumeration with a Common Prefix\nDESCRIPTION: This Protobuf code defines an enumeration `PhoneType` where all values have the common prefix `PHONE_TYPE_`. This prefix is intended to be removed during TypeScript code generation.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_32\n\nLANGUAGE: protobuf\nCODE:\n```\nenum PhoneType {\n  PHONE_TYPE_UNSPECIFIED = 0;\n  PHONE_TYPE_MOBILE = 1;\n  PHONE_TYPE_LAND_LINE = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Run Protobuf Plugin Version Command\nDESCRIPTION: Runs the Protobuf plugin with the `--version` flag to display its name and version. This verifies that the plugin is correctly installed and configured.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_91\n\nLANGUAGE: shellsession\nCODE:\n```\nnpx tsx src/protoc-gen-hello.ts --version\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Import Statement\nDESCRIPTION: Demonstrates a relative import statement generated in a TypeScript file, importing the `User` type from another generated file.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { User } from \"./example_pb\";\n```\n\n----------------------------------------\n\nTITLE: Printing Multiple Arguments\nDESCRIPTION: This code demonstrates how to print multiple arguments to a file using `f.print()`. The arguments are joined together in a single line of output.  Arguments can be strings, numbers, booleans, or other printable types.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_97\n\nLANGUAGE: typescript\nCODE:\n```\nconst world = \"world\";\nf.print(\"// hello \", world);\n\n// Generates the line:\n// hello world\n```\n\n----------------------------------------\n\nTITLE: Parsing Plugin Options\nDESCRIPTION: This code shows the signature of the `parseOptions` function that can be passed to `createEcmaScriptPlugin` to handle custom plugin options. It takes an array of key-value pairs and returns a type `T` that represents the parsed options.  The framework invokes this function with any unrecognized key-value pairs.\nSOURCE: https://github.com/bufbuild/protobuf-es/blob/main/MANUAL.md#_snippet_105\n\nLANGUAGE: typescript\nCODE:\n```\nparseOptions(rawOptions: {key: string, value: string}[]): T;\n```"
  }
]