[
  {
    "owner": "emilk",
    "repo": "egui",
    "content": "TITLE: Installing Image Loaders in egui Context - Rust\nDESCRIPTION: This Rust snippet shows how to install image loaders in the egui UI context by invoking egui_extras::install_image_loaders(egui_ctx). This prepares the egui context to handle image assets in formats enabled via the image crate (e.g., JPEG, PNG). The egui_ctx parameter must be a valid egui context instance, and the feature set must be enabled as shown in the Cargo.toml snippet.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_extras/README.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\negui_extras::install_image_loaders(egui_ctx);\n```\n\n----------------------------------------\n\nTITLE: Using Egui Button in Rust\nDESCRIPTION: This snippet demonstrates the basic usage of a button within the egui library.  It showcases how to create a button and check if it has been clicked. Dependencies include the egui crate.  The output is a boolean representing whether the button was clicked. The primary functionality is a simple button click event handler.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nif ui.button(\"Click me\").clicked() { … }\n```\n\n----------------------------------------\n\nTITLE: Using the egui Image API in Rust for Loading and Displaying Images\nDESCRIPTION: Demonstrates how to load and display images dynamically from URLs or statically included binary assets in an egui UI application. Includes usage of method chaining to customize image display properties such as max width and rounding. Requires egui, and optionally egui_extras and image crates for additional image format support. Inputs are image sources (URL strings or binary inclusions), and output is the rendered image widget in the UI.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// Load from web:\nui.image(\"https://www.example.com/some_image.png\");\n\n// Include image in the binary using `include_bytes`:\nui.image(egui::include_image!(\"../assets/ferris.svg\"));\n\n// With options:\nui.add(\n    egui::Image::new(\"file://path/to/image.jpg\")\n        .max_width(200.0)\n        .rounding(10.0),\n);\n```\n\n----------------------------------------\n\nTITLE: Render-to-Texture Implementation for egui-miniquad in Rust\nDESCRIPTION: Example of rendering a 3D scene to texture and displaying it using ui.image() with the egui-miniquad integration. This technique requires converting the native texture to an egui::TextureId.\nSOURCE: https://github.com/emilk/egui/blob/master/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Example available at:\n// https://github.com/not-fl3/egui-miniquad/blob/master/examples/render_to_egui_image.rs\n```\n\n----------------------------------------\n\nTITLE: Context Data Access Pattern in egui with Rust\nDESCRIPTION: Example of accessing Context data safely using closures to prevent deadlocks. This pattern uses RwLock with closure-based access rather than mutex guards to ensure thread safety.\nSOURCE: https://github.com/emilk/egui/blob/master/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Accessing Context data safely with a closure\nctx.input(|i| i.key_down(Key::A))\n```\n\n----------------------------------------\n\nTITLE: Safely Accessing Vector Elements using let-else (Rust)\nDESCRIPTION: Presents the preferred, panic-safe method in egui for accessing the first element of a vector. It uses `.first()` which returns an `Option`, and combines it with a `let-else` statement to handle the case where the vector is empty, gracefully returning without risking a panic.\nSOURCE: https://github.com/emilk/egui/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet Some(first) = vec.first() else {\n    return;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Epaint Shape in Rust\nDESCRIPTION: The snippet demonstrates the usage of `Shape` with various attributes.  `epaint` is a crate that contains 2D shapes and text rendering capabilities.  The example shows how to define a circle. It depends on `emath`. The output is a rendered shape that can be displayed in a GUI.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nShape::Circle { center, radius, fill, stroke }\n```\n\n----------------------------------------\n\nTITLE: Builder Pattern Usage in egui with Rust\nDESCRIPTION: Example of using the builder pattern for constructing widgets in egui, along with a simplified helper function alternative. This demonstrates the standard approach to widget configuration.\nSOURCE: https://github.com/emilk/egui/blob/master/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Builder pattern approach\nui.add(Label::new(\"Hello\").text_color(RED));\n\n// Helper function approach\nui.label(\"Hello\");\n```\n\n----------------------------------------\n\nTITLE: Using Shape::Callback for Custom Rendering in Rust\nDESCRIPTION: Example of using Shape::Callback to integrate custom rendering with egui. This approach allows for rendering directly with the underlying graphics context (such as glow when using eframe).\nSOURCE: https://github.com/emilk/egui/blob/master/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Example available at:\n// https://github.com/emilk/egui/blob/master/examples/custom_3d_glow/src/main.rs\n```\n\n----------------------------------------\n\nTITLE: Setting Custom IDs for Windows and Areas\nDESCRIPTION: Example showing how to override the default ID assignment for windows and areas to avoid conflicts or ensure persistence across sessions.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n// Override default ID assignment\nwindow.id(custom_id)\narea.id(custom_id)\n```\n\n----------------------------------------\n\nTITLE: Configuring egui_extras and image Loaders in Cargo.toml - TOML\nDESCRIPTION: This TOML snippet demonstrates how to add egui_extras with the all_loaders feature and the image crate with jpeg and png support to a Rust project's dependencies. This configuration is necessary to enable broad image format support for use with egui-extras in Rust GUIs. The version specifiers allow for flexible updating, but the actual functionality depends on the correct installation of these crates.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_extras/README.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\negui_extras = { version = \"*\", features = [\"all_loaders\"] }\nimage = { version = \"0.25\", features = [\"jpeg\", \"png\"] } # Add the types you want support for\n```\n\n----------------------------------------\n\nTITLE: Adding image loading dependencies in Cargo.toml for egui Extras and Image Support in Rust\nDESCRIPTION: Specifies dependencies needed to extend egui with comprehensive image loading capabilities using egui_extras and the image crate. Includes enabling all loaders feature in egui_extras and enabling jpeg and png format support in image crate. Ensure this configuration in Cargo.toml to enable plugin-based image loading in egui apps.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\negui_extras = { version = \"0.23\", features = [\"all_loaders\"] }\nimage = { version = \"0.24\", features = [\"jpeg\", \"png\"] } # Add the types you want support for\n```\n\n----------------------------------------\n\nTITLE: Configuring Slider Value Clamping in egui\nDESCRIPTION: Example showing how to control whether slider values are clamped to their specified range using the clamp_to_range boolean option.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n// If set to true, clamp incoming and outgoing values to the slider range\nSlider::clamp_to_range(bool)\n```\n\n----------------------------------------\n\nTITLE: Installing Image Loaders for egui Context in Rust\nDESCRIPTION: Shows how to enable image loading for an egui context by calling the helper function from egui_extras. This setup is required after adding the necessary dependencies to properly load images with egui's plugin-based system. The function installs multiple image loaders for ready use in your GUI apps. The input is an egui context and there is no output other than enabling functionality.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\negui_extras::install_image_loaders(egui_ctx);\n```\n\n----------------------------------------\n\nTITLE: Memory Access Changes in egui 0.21.0\nDESCRIPTION: Example demonstrating the breaking change in egui 0.21.0 for accessing memory, which now requires using a closure pattern for mutating memory state instead of direct access.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n// Old way (pre 0.21.0)\nui.memory().toggle_popup(popup_id)\n\n// New way (0.21.0+)\nui.memory_mut(|mem| mem.toggle_popup(popup_id))\n```\n\n----------------------------------------\n\nTITLE: Setting UI Element State with Rust\nDESCRIPTION: Demonstrates how to disable all widgets in a UI section by using the set_enabled method, which results in grayed out and non-interactive elements.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n// Disable all widgets in a UI section\nui.set_enabled(false)\n```\n\n----------------------------------------\n\nTITLE: Creating Password Fields in TextEdit\nDESCRIPTION: Example of implementing password input fields in egui using the TextEdit widget with the password modifier to hide input characters for security purposes.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n// Hide input characters in a text field\nTextEdit::password()\n```\n\n----------------------------------------\n\nTITLE: Creating Hint Text in TextEdit Fields\nDESCRIPTION: Shows how to add placeholder hint text to TextEdit widgets that appears when the field is empty, providing guidance to users on what to enter.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n// Add placeholder text that shows when field is empty\nTextEdit::hint_text()\n```\n\n----------------------------------------\n\nTITLE: Example of Good Code Style in egui (Rust)\nDESCRIPTION: Demonstrates preferred Rust code style within the egui project. Highlights include clear documentation comments (docstrings) for public functions, standard function definitions, and the use of `TODO` comments with author attribution for tracking needed improvements.\nSOURCE: https://github.com/emilk/egui/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// The name of the thing.\npub fn name(&self) -> &str {\n    &self.name\n}\n\nfn foo(&self) {\n    // TODO(emilk): this can be optimized\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequential Window Opening in egui with Rust\nDESCRIPTION: This code demonstrates the logic to open multiple windows sequentially in an egui application. It manages window display order, incorporates delays between window closures, and ensures the app terminates after the last window is closed. Dependencies include the egui and winit libraries, with appropriate event handling to control flow based on window closure events and timing.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/serial_windows/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// Example code demonstrating sequential window opening\nfn main() {\n    // Initialize egui and winit event loops\n    // Show first window\n    // Wait for window to close with a delay\n    // Show second window\n    // Wait again\n    // Show third window\n    // Exit application after third window is closed\n    // Note: On Mac OS, this may not work due to known winit issue\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using TabIndex for Accessible Interface Navigation in Rust\nDESCRIPTION: Code demonstrating how to navigate egui interfaces with tab/shift-tab to focus clickable widgets, and using space or enter to interact with them. This is part of egui's accessibility features for keyboard navigation.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n// Use tab/shift-tab to focus clickable widgets\n// Use space or enter to click the selected widget\n// Use arrow keys to adjust sliders and DragValues\n```\n\n----------------------------------------\n\nTITLE: Automatically Scrolling to Widgets in egui\nDESCRIPTION: Shows two methods for programmatically scrolling to specific UI elements: using ui.scroll_to_cursor at the UI level or response.scroll_to_me on individual widget responses.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n// Scroll to the cursor position\nui.scroll_to_cursor\n\n// Scroll to a specific widget that generated this response\nresponse.scroll_to_me\n```\n\n----------------------------------------\n\nTITLE: Setting Window Position in egui\nDESCRIPTION: Demonstrates how to position a window at a specific location on screen using the current_pos method, which allows manual placement of window components.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n// Position a window at a specific location\nWindow::current_pos\n```\n\n----------------------------------------\n\nTITLE: Implementing Window Drag Bounds in egui\nDESCRIPTION: Example showing how to restrict the dragging bounds of Window and Area components in egui using the drag_bounds method to specify a rectangular constraint area.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n// Restrict window dragging to a specific area\nwindow.drag_bounds(rect)\n```\n\n----------------------------------------\n\nTITLE: Example of Bad Code Style in egui (Rust)\nDESCRIPTION: Illustrates discouraged Rust code style practices in egui. Points out overly brief comments, redundant `get_` prefixes in accessor methods, and the use of `FIXME` instead of the preferred `TODO(username)` format for comments.\nSOURCE: https://github.com/emilk/egui/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n//gets the name\npub fn get_name(&self) -> &str {\n    &self.name\n}\nfn foo(&self) {\n    //FIXME: this can be optimized\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Window Title Bars in egui\nDESCRIPTION: Shows how to hide the title bar of a window component by setting the title_bar property to false while maintaining the window functionality.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n// Remove the title bar from a window\nwindow.title_bar(false)\n```\n\n----------------------------------------\n\nTITLE: Running Egui Hello World with Cargo\nDESCRIPTION: This command uses Cargo, the Rust package manager, to build and run the 'hello_world' example project.  The `-p` flag specifies the package to execute.  The output is the execution of the Egui application, displaying various UI controls. Requires Rust and Cargo to be installed and the Egui project to be available.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/hello_world/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p hello_world\n```\n\n----------------------------------------\n\nTITLE: Running Egui File Dialog Example (Shell)\nDESCRIPTION: This command executes the `file_dialog` example program within the Egui project using the `cargo run` command. It compiles and runs the specified example demonstrating the integration of native file dialogs via the `rfd` crate.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/file_dialog/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p file_dialog\n```\n\n----------------------------------------\n\nTITLE: Running egui Demo App Locally Using Cargo in Shell\nDESCRIPTION: This shell command runs the egui demo application locally in release mode using Cargo, Rust's package manager. It requires the Rust toolchain to be installed along with the egui_demo_app crate. The command initiates the executable built from source, enabling the user to interact with the GUI demo on their machine.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_demo_app/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --release -p egui_demo_app\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Viewports Example with Egui and Eframe - Shell\nDESCRIPTION: This shell snippet demonstrates how to launch the multiple viewports example for egui using the eframe backend. It invokes cargo to run the example from the Rust project, targeting the 'multiple_viewports' package. Prerequisites include having Rust and Cargo installed as well as the egui and eframe dependencies. The command produces a native windowed application as output, allowing users to interact with multiple viewports/distinct windows. The snippet assumes the user is in the project root directory, and does not handle environment configuration or dependency installation.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/multiple_viewports/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p multiple_viewports\n```\n\n----------------------------------------\n\nTITLE: Using Emath Rect in Rust\nDESCRIPTION: This snippet shows the `Rect` usage within the `emath` crate. The `emath` crate is a minimal 2D math library. `Rect` represents a rectangle in 2D space.  It's a data structure for representing rectangular areas, useful for layout and clipping within the egui system.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nRect\n```\n\n----------------------------------------\n\nTITLE: Using Emath remap in Rust\nDESCRIPTION: This snippet demonstrates the `remap` function from `emath` crate. The `emath` crate is a minimal 2D math library. `remap` transforms a value from one range to another, useful for scaling and adapting values. Dependencies are within the `emath` crate.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nremap\n```\n\n----------------------------------------\n\nTITLE: Using Emath lerp in Rust\nDESCRIPTION: This snippet demonstrates the `lerp` function from `emath` crate. The `emath` crate provides basic 2D math utilities. `lerp` is used to perform linear interpolation, which is used in calculating intermediate values within a range. Dependencies are in the `emath` crate.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlerp\n```\n\n----------------------------------------\n\nTITLE: Running Custom Font Example with Cargo in Shell\nDESCRIPTION: This shell command executes the custom_font example from the egui project using Cargo, Rust's build tool and package manager. The -p option specifies the custom_font package to run, assuming all dependencies, especially Rust and Cargo, are installed. No additional parameters are required; executing this command will launch the application that demonstrates custom font integration in an egui UI.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_font/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p custom_font\n```\n\n----------------------------------------\n\nTITLE: Using Emath Pos2 in Rust\nDESCRIPTION: This snippet demonstrates the `Pos2` usage within the `emath` crate. The `emath` crate is the minimal 2D math library. This allows for basic manipulations used in the overall GUI structure. `Pos2` is used to define a 2D position.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nPos2\n```\n\n----------------------------------------\n\nTITLE: Using Emath Vec2 in Rust\nDESCRIPTION: This snippet is an example of using `Vec2` within the `emath` crate. The `emath` crate provides minimal 2D math utilities. The example focuses on how to utilize basic mathematical structures for 2D manipulations, providing a foundational library for computations used throughout the broader GUI logic.  It is used for vector representation.\nSOURCE: https://github.com/emilk/egui/blob/master/ARCHITECTURE.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nVec2\n```\n\n----------------------------------------\n\nTITLE: Running the egui Screenshot Example via Cargo\nDESCRIPTION: Executes the 'screenshot' example package or target within the Rust project using Cargo. This command compiles and runs the specific example code demonstrating screenshot functionality with egui/eframe.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/screenshot/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p screenshot\n```\n\n----------------------------------------\n\nTITLE: Installing Linux Dependencies for eframe\nDESCRIPTION: Command to install required system packages for running eframe applications on Linux platforms. These packages provide necessary X11 and rendering support.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/eframe/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libxkbcommon-dev libssl-dev\n```\n\n----------------------------------------\n\nTITLE: Focusing Web Canvas\nDESCRIPTION: This JavaScript snippet shows how to focus on the eframe canvas element during startup. This is crucial for fullscreen applications to capture keyboard input and other events properly.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/eframe/CHANGELOG.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\ndocument.getElementById(\"the_canvas_id\").focus();\n```\n\n----------------------------------------\n\nTITLE: Discouraged Panic-Prone Slice Indexing (Rust)\nDESCRIPTION: Shows a potentially problematic way to access the first element of a vector in Rust. Although it checks `is_empty`, direct indexing (`vec[0]`) can still panic if the logic is incorrect or changes during refactoring. This pattern is discouraged in egui.\nSOURCE: https://github.com/emilk/egui/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet first = if vec.is_empty() {\n    return;\n} else {\n    vec[0]\n};\n```\n\n----------------------------------------\n\nTITLE: Running egui Hello World Simple Example\nDESCRIPTION: Terminal command to execute the simple hello world example for egui, which demonstrates basic UI controls like Label, TextEdit, Slider, and Button.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/hello_world_simple/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p hello_world_simple\n```\n\n----------------------------------------\n\nTITLE: Setting Web Canvas CSS\nDESCRIPTION: This CSS snippet demonstrates how to make the eframe canvas fill the entire web browser window. Setting the top, left, width, and height properties ensures the canvas stretches to the edges of the viewport.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/eframe/CHANGELOG.md#_snippet_1\n\nLANGUAGE: CSS\nCODE:\n```\ntop: 0;\nleft: 0;\nwidth: 100%;\nheight: 100%;\n```\n\n----------------------------------------\n\nTITLE: Context Method Changes in egui 0.21.0\nDESCRIPTION: Example showing how to adapt code to the breaking change in egui 0.21.0 where Context methods now use closures for locking. This example shows the change from direct access to using a closure pattern.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// Old way (pre 0.21.0)\nctx.input().key_pressed(Key::A)\n\n// New way (0.21.0+)\nctx.input(|i| i.key_pressed(Key::A))\n```\n\n----------------------------------------\n\nTITLE: Building and Running Hello World Android Project with cargo-apk (Shell)\nDESCRIPTION: Provides commands to build and run the egui hello_android crate using cargo-apk for Android deployment, and standard cargo for desktop execution. Requires the cargo-apk tool installed as a prerequisite. The first command runs the Rust project on a connected Android device, while the second runs it natively on the desktop. Both commands assume the presence of the hello_android package within the workspace.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/hello_android/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Run on android\ncargo apk run -p hello_android --lib\n\n# Run on your desktop\ncargo run -p hello_android\n```\n\n----------------------------------------\n\nTITLE: Building and Starting egui Demo App as WASM in Shell\nDESCRIPTION: These shell commands compile the egui demo app to WebAssembly format and start a local server to serve the WASM app on a browser. The first command launches a background server process using a script, while the second builds the demo web app and opens it automatically. These require the related shell scripts and dependencies like wasm-bindgen and a web server environment.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_demo_app/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/start_server.sh &\n```\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/build_demo_web.sh --open\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Linux\nDESCRIPTION: This command installs necessary dependencies for running egui_glow on Linux systems.  It uses apt-get to install development libraries for XCB, XKBCommon, and OpenSSL. These libraries are essential for windowing and graphics rendering.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_glow/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt-get install libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libxkbcommon-dev libssl-dev\n```\n\n----------------------------------------\n\nTITLE: Running Image Display App with Cargo - Shell\nDESCRIPTION: This command uses the `cargo run` command to execute the eframe/egui project named \"images\".  It instructs the Rust build system (Cargo) to build and then run the specified project, which is presumed to contain the image display functionality. It's the prerequisite step for executing the application.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/images/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p images\n```\n\n----------------------------------------\n\nTITLE: Running Custom Window Frame Example in egui\nDESCRIPTION: Command to execute the custom window frame example application. This demonstrates how to render a custom window frame instead of using the default OS window chrome decorations.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_window_frame/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p custom_window_frame\n```\n\n----------------------------------------\n\nTITLE: Running the `custom_3d_glow` Example with Cargo (Shell)\nDESCRIPTION: This command uses Cargo, the Rust build tool, to compile and execute the `custom_3d_glow` example project. This project showcases embedding 3D rendering using the `glow` library within an `eframe` GUI application. Ensure Rust and Cargo are installed and the project dependencies are available.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_3d_glow/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p custom_3d_glow\n```\n\n----------------------------------------\n\nTITLE: Running egui Popups Example in Shell\nDESCRIPTION: Shows the shell command to run the egui example project demonstrating menus, popups, context menus, and tooltips. The snippet requires Cargo and Rust environment set up, and it runs the package named \"popups\". This command triggers execution of the example application showing GUI popups to the user.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/popups/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p popups\n```\n\n----------------------------------------\n\nTITLE: Running Egui Example Project with Cargo in Shell\nDESCRIPTION: Runs the 'hello_world_par' egui example using the shell command 'cargo run -p hello_world_par'. Requires Rust and cargo installed, as well as the egui codebase set up with the 'hello_world_par' example project. The command builds and executes the example, demonstrating concurrent usage of egui from multiple threads. Input is the shell command, and output is the compiled example running in parallel mode.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/hello_world_par/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p hello_world_par\n```\n\n----------------------------------------\n\nTITLE: Running the egui Custom Style Example using Cargo (Shell)\nDESCRIPTION: This shell command uses `cargo run` to compile and execute the `custom_style` example package within the current Rust project (presumably the `egui` repository). The `-p` flag specifies the package name (`custom_style`) to run. It requires Rust and Cargo to be installed.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_style/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run -p custom_style\n```\n\n----------------------------------------\n\nTITLE: Running the pure_glow Example\nDESCRIPTION: This command runs the pure_glow example included with the egui_glow crate. It uses cargo run to execute the example, specifying the egui_glow package and enabling the winit and egui/default_fonts features. This allows the example to create a window and render egui with default fonts.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_glow/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p egui_glow --example pure_glow --features=winit,egui/default_fonts\n```\n\n----------------------------------------\n\nTITLE: Running Keyboard Events Example via Cargo - Shell\nDESCRIPTION: This snippet demonstrates how to launch the 'keyboard_events' example within the egui Rust project using the Cargo package manager. The command requires Cargo and Rust installed and expects the egui project with the specified example to be available. There are no parameters except for the '-p' flag, which specifies the package or example to run; the command outputs the result of compiling and running the example, potentially opening a GUI window or providing terminal feedback.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/keyboard_events/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -p keyboard_events\n```\n\n----------------------------------------\n\nTITLE: Running egui Custom Font Style Example (sh)\nDESCRIPTION: This shell command uses `cargo run` to build and execute the `custom_font_style` example program within the `egui` project.\nIt serves as the entry point to run the demonstration of custom text styles.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_font_style/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p custom_font_style\n```\n\n----------------------------------------\n\nTITLE: Running Custom Keypad Example with Cargo\nDESCRIPTION: This command executes the custom keypad example using cargo. It navigates to the 'custom_keypad' package within the larger 'egui' project and runs the main function. This assumes that the cargo project is set up correctly with a 'custom_keypad' package.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/custom_keypad/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run -p custom_keypad\n```\n\n----------------------------------------\n\nTITLE: Running User Attention Module with Cargo in Rust\nDESCRIPTION: This shell snippet runs the 'user_attention' package of the project using Cargo, Rust's build system and package manager. It initiates the process to request user attention, useful for prompting interaction or signaling events.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/user_attention/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run -p user_attention\n```\n\n----------------------------------------\n\nTITLE: Using egui_kittest for Widget Testing in Rust\nDESCRIPTION: Example of using egui_kittest to perform automated UI testing with a checkbox widget. The code demonstrates how to create a test harness, interact with a checkbox widget, and verify its state before and after clicking.\nSOURCE: https://github.com/emilk/egui/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse egui::accesskit::Toggled;\nuse egui_kittest::{Harness, kittest::Queryable};\n\nfn main() {\n    let mut checked = false;\n    let app = |ui: &mut egui::Ui| {\n        ui.checkbox(&mut checked, \"Check me!\");\n    };\n\n    let mut harness = egui_kittest::Harness::new_ui(app);\n\n    let checkbox = harness.get_by_label(\"Check me!\");\n    assert_eq!(checkbox.toggled(), Some(Toggled::False));\n    checkbox.click();\n\n    harness.run();\n\n    let checkbox = harness.get_by_label(\"Check me!\");\n    assert_eq!(checkbox.toggled(), Some(Toggled::True));\n\n    // You can even render the ui and do image snapshot tests\n    #[cfg(all(feature = \"wgpu\", feature = \"snapshot\"))]\n    harness.wgpu_snapshot(\"readme_example\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example usage of egui_kittest with harness, querying, clicking, and snapshot features\nDESCRIPTION: This Rust code snippet demonstrates how to set up a UI test using egui_kittest's Harness, perform a checkbox toggle, and verify its state before and after clicking. It includes rendering the UI, making assertions, and capturing a snapshot if features are enabled. The snippet showcases dependencies on egui, egui_kittest, and optional features for wgpu and snapshot testing.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/egui_kittest/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse egui::accesskit::Toggled;\nuse egui_kittest::{Harness, kittest::Queryable};\n\nfn main() {\n    let mut checked = false;\n    let app = |ui: &mut egui::Ui| {\n        ui.checkbox(&mut checked, \"Check me!\");\n    };\n\n    let mut harness = Harness::new_ui(app);\n\n    let checkbox = harness.get_by_label(\"Check me!\");\n    assert_eq!(checkbox.toggled(), Some(Toggled::False));\n    checkbox.click();\n\n    harness.run();\n\n    let checkbox = harness.get_by_label(\"Check me!\");\n    assert_eq!(checkbox.toggled(), Some(Toggled::True));\n\n    // Shrink the window size to the smallest size possible\n    harness.fit_contents();\n\n    // You can even render the ui and do image snapshot tests\n    #[cfg(all(feature = \"wgpu\", feature = \"snapshot\"))]\n    harness.snapshot(\"readme_example\");\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Patched cargo-apk for Rust Projects (Shell)\nDESCRIPTION: Installs a custom revision of the cargo-apk tool directly from the specified GitHub repository using the cargo install command. This version is necessary due to an upstream bug impacting standard cargo-apk functionality for Android builds. No input parameters are required, but the Rust toolchain and Git must be installed beforehand. The snippet should be executed once per development environment.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/hello_android/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo install \\\n    --git https://github.com/parasyte/cargo-apk.git \\\n    --rev 282639508eeed7d73f2e1eaeea042da2716436d5 \\\n    cargo-apk\n```\n\n----------------------------------------\n\nTITLE: Running Puffin Profiler and Viewer with eframe App in Shell\nDESCRIPTION: This snippet includes shell commands to run the eframe application with the Puffin profiler enabled in the background, install the Puffin viewer tool, and launch the viewer pointed at the local profiling server. Dependencies include having Rust and Cargo installed for building and running the app, and network access to connect to the profiling server at 127.0.0.1:8585. The commands facilitate profiling data collection and real-time visualization, intended for development and performance analysis.\nSOURCE: https://github.com/emilk/egui/blob/master/examples/puffin_profiler/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run -p puffin_profiler &\n\ncargo install puffin_viewer\npuffin_viewer --url 127.0.0.1:8585\n```\n\n----------------------------------------\n\nTITLE: Migrating eframe run_native call\nDESCRIPTION: This diff shows how to update the `eframe::run_native` call to handle potential errors during application creation. The previous code directly passed a boxed `App` implementation, while the updated code wraps it in a `Result` to allow for error handling.\nSOURCE: https://github.com/emilk/egui/blob/master/crates/eframe/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Diff\nCODE:\n```\n- eframe::run_native(\"My App\", options, Box::new(|cc| Box::new(MyApp::new(cc))));\n+ eframe::run_native(\"My App\", options, Box::new(|cc| Ok(Box::new(MyApp::new(cc)))));\n```\n\n----------------------------------------\n\nTITLE: Publishing crates using Cargo\nDESCRIPTION: This bash script publishes multiple crates using cargo publish command within their respective directories. It changes the directory to each crate's location, runs cargo publish in quiet mode and then prints a success message.\nSOURCE: https://github.com/emilk/egui/blob/master/RELEASES.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n(cd crates/emath                && cargo publish --quiet)  &&  echo \"✅ emath\"\n(cd crates/ecolor               && cargo publish --quiet)  &&  echo \"✅ ecolor\"\n(cd crates/epaint_default_fonts && cargo publish --quiet)  &&  echo \"✅ epaint_default_fonts\"\n(cd crates/epaint               && cargo publish --quiet)  &&  echo \"✅ epaint\"\n(cd crates/egui                 && cargo publish --quiet)  &&  echo \"✅ egui\"\n(cd crates/egui-winit           && cargo publish --quiet)  &&  echo \"✅ egui-winit\"\n(cd crates/egui-wgpu            && cargo publish --quiet)  &&  echo \"✅ egui-wgpu\"\n(cd crates/eframe               && cargo publish --quiet)  &&  echo \"✅ eframe\"\n(cd crates/egui_kittest         && cargo publish --quiet)  &&  echo \"✅ egui_kittest\"\n(cd crates/egui_extras          && cargo publish --quiet)  &&  echo \"✅ egui_extras\"\n(cd crates/egui_demo_lib        && cargo publish --quiet)  &&  echo \"✅ egui_demo_lib\"\n(cd crates/egui_glow            && cargo publish --quiet)  &&  echo \"✅ egui_glow\"\n```\n\n----------------------------------------\n\nTITLE: Managing Git LFS for egui (Bash)\nDESCRIPTION: Lists common git-lfs commands used within the egui repository. It covers initializing git-lfs, tracking/untracking files (or patterns), renormalizing the repository to apply lfs rules to existing files, and pushing changes (including LFS objects) to contributor remotes, potentially bypassing verification hooks.\nSOURCE: https://github.com/emilk/egui/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install git-lfs in the repo (installs git hooks)\ngit lfs install\n\n# Move a file to git lfs\ngit lfs track \"path/to/file/or/pattern\" # OR manually edit .gitattributes\ngit add --renormalize . # Moves already added files to lfs (according to .gitattributes)\n\n# Move a file from lfs to regular git\ngit lfs untrack \"path/to/file/or/pattern\" # OR manually edit .gitattributes\ngit add --renormalize . # Moves already added files to regular git (according to .gitattributes)\n\n# Push to a contributor remote (see https://github.com/cli/cli/discussions/8794#discussioncomment-8695076)\ngit push --no-verify\n```"
  }
]