[
  {
    "owner": "taskflow",
    "repo": "taskflow",
    "content": "TITLE: Creating and Resizing a Tensor in C++\nDESCRIPTION: This snippet demonstrates how to create a 3-dimensional tensor of floats with initial dimensions 2x3x4, and then resize it by assigning a new tensor with different dimensions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Create a tensor of rank 3 of sizes 2, 3, 4.  This tensor owns\n// memory to hold 24 floating point values (24 = 2 x 3 x 4).\nTensor<float, 3> t_3d(2, 3, 4);\n\n// Resize t_3d by assigning a tensor of different sizes, but same rank.\nt_3d = Tensor<float, 3>(3, 4, 3);\n```\n\n----------------------------------------\n\nTITLE: Executing Taskflows with Different Methods in C++\nDESCRIPTION: Demonstrates various methods to execute a taskflow using the Executor. It shows how to run a taskflow once, multiple times, or until a condition is met, as well as waiting for completion.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// runs the taskflow once\ntf::Future<void> run_once = executor.run(taskflow); \n\n// wait on this run to finish\nrun_once.get();\n\n// run the taskflow four times\nexecutor.run_n(taskflow, 4);\n\n// runs the taskflow five times\nexecutor.run_until(taskflow, [counter=5](){ return --counter == 0; });\n\n// block the executor until all submitted taskflows complete\nexecutor.wait_for_all();\n```\n\n----------------------------------------\n\nTITLE: Composing Task Graphs with Taskflow in C++\nDESCRIPTION: Demonstrates how to create and compose task graphs using Taskflow. It shows creating two taskflows, adding tasks to each, and composing them together with dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\ntf::Taskflow f1, f2;\n\n// create taskflow f1 of two tasks\ntf::Task f1A = f1.emplace([]() { std::cout << \"Task f1A\\n\"; })\n                 .name(\"f1A\");\ntf::Task f1B = f1.emplace([]() { std::cout << \"Task f1B\\n\"; })\n                 .name(\"f1B\");\n\n// create taskflow f2 with one module task composed of f1\ntf::Task f2A = f2.emplace([]() { std::cout << \"Task f2A\\n\"; })\n                 .name(\"f2A\");\ntf::Task f2B = f2.emplace([]() { std::cout << \"Task f2B\\n\"; })\n                 .name(\"f2B\");\ntf::Task f2C = f2.emplace([]() { std::cout << \"Task f2C\\n\"; })\n                 .name(\"f2C\");\n\ntf::Task f1_module_task = f2.composed_of(f1)\n                            .name(\"module\");\n\nf1_module_task.succeed(f2A, f2B)\n              .precede(f2C);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Task Dependencies in C++ with Taskflow\nDESCRIPTION: A simple example demonstrating how to create four tasks with dependencies using Taskflow. The code creates tasks A, B, C, and D where A runs before B and C, and D runs after B and C.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <taskflow/taskflow.hpp>  // Taskflow is header-only\n\nint main(){\n  \n  tf::Executor executor;\n  tf::Taskflow taskflow;\n\n  auto [A, B, C, D] = taskflow.emplace(  // create four tasks\n    [] () { std::cout << \"TaskA\\n\"; },\n    [] () { std::cout << \"TaskB\\n\"; },\n    [] () { std::cout << \"TaskC\\n\"; },\n    [] () { std::cout << \"TaskD\\n\"; } \n  );                                  \n                                      \n  A.precede(B, C);  // A runs before B and C\n  D.succeed(B, C);  // D runs after  B and C\n                                      \n  executor.run(taskflow).wait(); \n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-Size Tensor in C++\nDESCRIPTION: This example demonstrates how to create a fixed-size tensor of dimensions 4x3 using the TensorFixedSize class, which is optimized for tensors whose dimensions are known at compile time.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// Create a 4 x 3 tensor of floats.\nTensorFixedSize<float, Sizes<4, 3>> t_4x3;\n```\n\n----------------------------------------\n\nTITLE: Offloading Tasks to GPU with CUDA in Taskflow\nDESCRIPTION: Example showing how to accelerate computations by offloading to GPU using Taskflow's CUDA integration. The code sets up data transfers between host and device, and launches a SAXPY kernel with dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n__global__ void saxpy(size_t N, float alpha, float* dx, float* dy) {\n  int i = blockIdx.x*blockDim.x + threadIdx.x;\n  if (i < n) {\n    y[i] = a*x[i] + y[i];\n  }\n}\ntf::Task cudaflow = taskflow.emplace([&](tf::cudaFlow& cf) {\n\n  // data copy tasks\n  tf::cudaTask h2d_x = cf.copy(dx, hx.data(), N).name(\"h2d_x\");\n  tf::cudaTask h2d_y = cf.copy(dy, hy.data(), N).name(\"h2d_y\");\n  tf::cudaTask d2h_x = cf.copy(hx.data(), dx, N).name(\"d2h_x\");\n  tf::cudaTask d2h_y = cf.copy(hy.data(), dy, N).name(\"d2h_y\");\n  \n  // kernel task with parameters to launch the saxpy kernel\n  tf::cudaTask saxpy = cf.kernel(\n    (N+255)/256, 256, 0, saxpy, N, 2.0f, dx, dy\n  ).name(\"saxpy\");\n\n  saxpy.succeed(h2d_x, h2d_y)\n       .precede(d2h_x, d2h_y);\n}).name(\"cudaFlow\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Pipeline with Taskflow in C++\nDESCRIPTION: Demonstrates how to create a parallel pipeline using Taskflow's composable graph building blocks. It shows a pipeline with three serial stages processing five tokens.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n// create a pipeline to propagate five tokens through three serial stages\ntf::Pipeline pl(num_parallel_lines,\n  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow& pf) {\n    if(pf.token() == 5) {\n      pf.stop();\n    }\n  }},\n  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow& pf) {\n    printf(\"stage 2: input buffer[%zu] = %d\\n\", pf.line(), buffer[pf.line()]);\n  }},\n  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow& pf) {\n    printf(\"stage 3: input buffer[%zu] = %d\\n\", pf.line(), buffer[pf.line()]);\n  }}\n);\ntaskflow.composed_of(pl)\nexecutor.run(taskflow).wait();\n```\n\n----------------------------------------\n\nTITLE: Using Standard Parallel Algorithms with Taskflow in C++\nDESCRIPTION: Shows how to use Taskflow's standard parallel algorithms for common operations like parallel for_each, reduce, and sort. It includes examples for both CPU and GPU (CUDA) parallel algorithms.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n// standard parallel CPU algorithms\ntf::Task task1 = taskflow.for_each( // assign each element to 100 in parallel\n  first, last, [] (auto& i) { i = 100; }    \n);\ntf::Task task2 = taskflow.reduce(   // reduce a range of items in parallel\n  first, last, init, [] (auto a, auto b) { return a + b; }\n);\ntf::Task task3 = taskflow.sort(     // sort a range of items in parallel\n  first, last, [] (auto a, auto b) { return a < b; }\n);\n\n// standard parallel GPU algorithms\ntf::cudaTask cuda1 = cudaflow.for_each( // assign each element to 100 on GPU\n  dfirst, dlast, [] __device__ (auto i) { i = 100; }\n);\ntf::cudaTask cuda2 = cudaflow.reduce(   // reduce a range of items on GPU\n  dfirst, dlast, init, [] __device__ (auto a, auto b) { return a + b; }\n);\ntf::cudaTask cuda3 = cudaflow.sort(     // sort a range of items on GPU\n  dfirst, dlast, [] __device__ (auto a, auto b) { return a < b; }\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Tensor with Array Constructor in C++\nDESCRIPTION: This snippet shows how to create a 2-dimensional tensor of strings using an array-based constructor with initialization list to specify dimensions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Create a tensor of strings of rank 2 with sizes 5, 7.\nTensor<string, 2> t_2d({5, 7});\n```\n\n----------------------------------------\n\nTITLE: Creating a Subflow Graph for Dynamic Tasking in Taskflow\nDESCRIPTION: Example of how to create dynamic task graphs using subflows in Taskflow. This code demonstrates spawning a subgraph parented at task B with three subtasks having their own dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ntf::Task A = taskflow.emplace([](){}).name(\"A\");  \ntf::Task C = taskflow.emplace([](){}).name(\"C\");  \ntf::Task D = taskflow.emplace([](){}).name(\"D\");  \n\ntf::Task B = taskflow.emplace([] (tf::Subflow& subflow) { \n  tf::Task B1 = subflow.emplace([](){}).name(\"B1\");  \n  tf::Task B2 = subflow.emplace([](){}).name(\"B2\");  \n  tf::Task B3 = subflow.emplace([](){}).name(\"B3\");  \n  B3.succeed(B1, B2);  // B3 runs after B1 and B2\n}).name(\"B\");\n\nA.precede(B, C);  // A runs before B and C\nD.succeed(B, C);  // D runs after  B and C\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Task Flow Control in Taskflow\nDESCRIPTION: Code demonstrating how to create conditional tasking patterns in Taskflow. This example sets up a feedback loop where a condition task returns a random binary value to determine execution flow.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\ntf::Task init = taskflow.emplace([](){}).name(\"init\");\ntf::Task stop = taskflow.emplace([](){}).name(\"stop\");\n\n// creates a condition task that returns a random binary\ntf::Task cond = taskflow.emplace(\n  [](){ return std::rand() % 2; }\n).name(\"cond\");\n\ninit.precede(cond);\n\n// creates a feedback loop {0: cond, 1: stop}\ncond.precede(cond, stop);\n```\n\n----------------------------------------\n\nTITLE: Working with Tensor Layouts in C++\nDESCRIPTION: This example shows how to specify tensor layouts (ColMajor/RowMajor), swap layouts, and handle dimension ordering when changing layouts. It demonstrates the constraints of mixing layouts in expressions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 2, ColMajor> col_major(2, 4);\nTensor<float, 2, RowMajor> row_major(2, 4);\n\nTensor<float, 2> col_major_result = col_major;  // ok, layouts match\nTensor<float, 2> col_major_result = row_major;  // will not compile\n\n// Simple layout swap\ncol_major_result = row_major.swap_layout();\neigen_assert(col_major_result.dimension(0) == 4);\neigen_assert(col_major_result.dimension(1) == 2);\n\n// Swap the layout and preserve the order of the dimensions\narray<int, 2> shuffle(1, 0);\ncol_major_result = row_major.swap_layout().shuffle(shuffle);\neigen_assert(col_major_result.dimension(0) == 2);\neigen_assert(col_major_result.dimension(1) == 4);\n```\n\n----------------------------------------\n\nTITLE: Launching Asynchronous Tasks with Taskflow in C++\nDESCRIPTION: Shows how to launch asynchronous tasks using Taskflow's Executor. It includes examples of creating tasks that return values, silent tasks, and tasks with dynamic dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\ntf::Executor executor;\n\n// create asynchronous tasks directly from an executor\nstd::future<int> future = executor.async([](){ \n  std::cout << \"async task returns 1\\n\";\n  return 1;\n}); \nexecutor.silent_async([](){ std::cout << \"async task does not return\\n\"; });\n\n// create asynchronous tasks with dynamic dependencies\ntf::AsyncTask A = executor.silent_dependent_async([](){ printf(\"A\\n\"); });\ntf::AsyncTask B = executor.silent_dependent_async([](){ printf(\"B\\n\"); }, A);\ntf::AsyncTask C = executor.silent_dependent_async([](){ printf(\"C\\n\"); }, A);\ntf::AsyncTask D = executor.silent_dependent_async([](){ printf(\"D\\n\"); }, B, C);\n\nexecutor.wait_for_all();\n```\n\n----------------------------------------\n\nTITLE: Accessing Tensor Dimensions\nDESCRIPTION: Examples showing how to access tensor dimensions using dimension() and size() methods.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(3, 4);\nint dim1 = a.dimension(1);\ncout << \"Dim 1: \" << dim1;\n```\n\n----------------------------------------\n\nTITLE: Basic Tensor Construction\nDESCRIPTION: Creating tensors with specified dimensions and accessing their properties.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(3, 4);\ncout << \"NumRows: \" << a.dimension(0) << \" NumCols: \" << a.dimension(1) << endl;\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Tensor Elements in C++\nDESCRIPTION: This snippet demonstrates how to access and modify individual elements of a tensor using the parentheses operator, including setting values, iterating through elements, and printing values.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// Set the value of the element at position (0, 1, 0);\nTensor<float, 3> t_3d(2, 3, 4);\nt_3d(0, 1, 0) = 12.0f;\n\n// Initialize all elements to random values.\nfor (int i = 0; i < 2; ++i) {\n  for (int j = 0; j < 3; ++j) {\n    for (int k = 0; k < 4; ++k) {\n      t_3d(i, j, k) = ...some random value...;\n    }\n  }\n}\n\n// Print elements of a tensor.\nfor (int i = 0; i < 2; ++i) {\n  LOG(INFO) << t_3d(i, 0, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Convolution Operation - Eigen Tensor\nDESCRIPTION: Shows how to perform convolution on a 4D tensor with a 2D kernel along specified dimensions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 4, DataLayout> input(3, 3, 7, 11);\nTensor<float, 2, DataLayout> kernel(2, 2);\nTensor<float, 4, DataLayout> output(3, 2, 6, 11);\ninput.setRandom();\nkernel.setRandom();\n\nEigen::array<ptrdiff_t, 2> dims({1, 2});  // Specify second and third dimension for convolution.\noutput = input.convolve(kernel, dims);\n```\n\n----------------------------------------\n\nTITLE: Resizing and Initializing Matrices in Eigen C++\nDESCRIPTION: Demonstrates matrix resizing operations (with potential runtime errors) and various initialization methods including comma-initialization and filling with values.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nA.resize(4, 4);   // Runtime error if assertions are on.\nB.resize(4, 9);   // Runtime error if assertions are on.\nA.resize(3, 3);   // Ok; size didn't change.\nB.resize(3, 9);   // Ok; only dynamic cols changed.\n                  \nA << 1, 2, 3,     // Initialize A. The elements can also be\n     4, 5, 6,     // matrices, which are stacked along cols\n     7, 8, 9;     // and then the rows are stacked.\nB << A, A, A;     // B is three horizontally stacked A's.\nA.fill(10);       // Fill A with all 10's.\n```\n\n----------------------------------------\n\nTITLE: Reshaping Tensors in Eigen C++\nDESCRIPTION: Demonstrates reshaping tensors with different dimensions and data layouts (ColMajor and RowMajor). Shows how to increase or decrease tensor rank and handle different data layouts.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\n// Increase rank example\nTensor<float, 2> input(7, 11);\narray<int, 3> three_dims{{7, 11, 1}};\nTensor<float, 3> result = input.reshape(three_dims);\n\n// Decrease rank example\narray<int, 1> one_dim{{7 * 11}};\nTensor<float, 1> result = input.reshape(one_dim);\n```\n\n----------------------------------------\n\nTITLE: Initializing Different Matrix Types in Eigen C++\nDESCRIPTION: Demonstrates various matrix type declarations in Eigen, including fixed-size, dynamic, and mixed matrices with different storage orders and data types.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <Eigen/Dense>\n\nMatrix<double, 3, 3> A;               // Fixed rows and cols. Same as Matrix3d.\nMatrix<double, 3, Dynamic> B;         // Fixed rows, dynamic cols.\nMatrix<double, Dynamic, Dynamic> C;   // Full dynamic. Same as MatrixXd.\nMatrix<double, 3, 3, RowMajor> E;     // Row major; default is column-major.\nMatrix3f P, Q, R;                     // 3x3 float matrix.\nVector3f x, y, z;                     // 3x1 float matrix.\nRowVector3f a, b, c;                  // 1x3 float matrix.\nVectorXd v;                           // Dynamic column vector of doubles\ndouble s;                            \n```\n\n----------------------------------------\n\nTITLE: Computing Tensor Power with Type Casting in C++\nDESCRIPTION: Demonstrates how to compute the power of tensor values, including type casting to handle non-integer exponents. The example computes cubic roots of an integer tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<int, 2> a(2, 3);\na.setValues({{0, 1, 8}, {27, 64, 125}});\nEigen::Tensor<double, 2> b = a.cast<double>().pow(1.0 / 3.0);\ncout << \"a\" << endl << a << endl << endl;\ncout << \"b\" << endl << b << endl << endl;\n```\n\n----------------------------------------\n\nTITLE: Generating Random Tensor Values in C++\nDESCRIPTION: Demonstrates how to add random values to an existing tensor using the random() method. The example shows creating a constant tensor and adding random values to it.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(2, 3);\na.setConstant(1.0f);\nEigen::Tensor<float, 2> b = a + a.random();\ncout << \"a\" << endl << a << endl << endl;\ncout << \"b\" << endl << b << endl << endl;\n```\n\n----------------------------------------\n\nTITLE: TaskFlow Library Interface Configuration\nDESCRIPTION: Configures the TaskFlow library as an interface library with C++17 requirement and threading dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${PROJECT_NAME} INTERFACE)\nadd_library(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})\ntarget_compile_features(${PROJECT_NAME} INTERFACE cxx_std_17)\ntarget_link_libraries(${PROJECT_NAME} INTERFACE ${ATOMIC_LIBRARY} Threads::Threads)\ntarget_include_directories(${PROJECT_NAME} INTERFACE\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n  $<INSTALL_INTERFACE:include/> \n)\n```\n\n----------------------------------------\n\nTITLE: Linear System Solving in Eigen C++\nDESCRIPTION: Shows different decomposition methods for solving linear systems (Ax = b), with comments about the required includes and stability/performance characteristics of each approach.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n// Solve Ax = b. Result stored in x. Matlab: x = A \\ b.\nx = A.ldlt().solve(b));  // A sym. p.s.d.    #include <Eigen/Cholesky>\nx = A.llt() .solve(b));  // A sym. p.d.      #include <Eigen/Cholesky>\nx = A.lu()  .solve(b));  // Stable and fast. #include <Eigen/LU>\nx = A.qr()  .solve(b));  // No pivoting.     #include <Eigen/QR>\nx = A.svd() .solve(b));  // Stable, slowest. #include <Eigen/SVD>\n// .ldlt() -> .matrixL() and .matrixD()\n// .llt()  -> .matrixL()\n// .lu()   -> .matrixL() and .matrixU()\n// .qr()   -> .matrixQ() and .matrixR()\n// .svd()  -> .matrixU(), .singularValues(), and .matrixV()\n```\n\n----------------------------------------\n\nTITLE: Basic Eigen Usage and Matrix Properties\nDESCRIPTION: Shows common operations for accessing matrix properties like size, rows, columns, and element access. Includes comparisons between Eigen and MATLAB indexing (zero-based vs one-based).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Basic usage\n// Eigen          // Matlab           // comments\nx.size()          // length(x)        // vector size\nC.rows()          // size(C,1)        // number of rows\nC.cols()          // size(C,2)        // number of columns\nx(i)              // x(i+1)           // Matlab is 1-based\nC(i,j)            // C(i+1,j+1)       //\n```\n\n----------------------------------------\n\nTITLE: Striding Through Tensor Elements in Eigen\nDESCRIPTION: Demonstrates how to skip elements in a tensor using stride operation. Shows striding in 2D tensors and using stride as an lvalue.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<int, 2> a(4, 3);\na.setValues({{0, 100, 200}, {300, 400, 500}, {600, 700, 800}, {900, 1000, 1100}});\nEigen::array<Eigen::DenseIndex, 2> strides({3, 2});\nEigen::Tensor<int, 2> b = a.stride(strides);\n```\n\n----------------------------------------\n\nTITLE: Computing Eigenvalues and Eigenvectors with Eigen in C++\nDESCRIPTION: This snippet demonstrates how to calculate eigenvalues and eigenvectors of a matrix using the Eigen library in C++. It shows the use of the EigenSolver class for a 3x3 matrix and mentions the SelfAdjointEigenSolver for self-adjoint matrices.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nA.eigenvalues();\nEigenSolver<Matrix3d> eig(A);\neig.eigenvalues();\neig.eigenvectors();\n// For self-adjoint matrices use SelfAdjointEigenSolver<>\n```\n\n----------------------------------------\n\nTITLE: Performing Tensor Contraction in C++\nDESCRIPTION: Illustrates how to perform tensor contractions, which are generalizations of matrix products. The example shows matrix multiplication, transposed product, and double contraction.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<int, 2> a(2, 3);\na.setValues({{1, 2, 3}, {6, 5, 4}});\nEigen::Tensor<int, 2> b(3, 2);\nb.setValues({{1, 2}, {4, 5}, {5, 6}});\n\nEigen::array<Eigen::IndexPair<int>, 1> product_dims = { Eigen::IndexPair<int>(1, 0) };\nEigen::Tensor<int, 2> AB = a.contract(b, product_dims);\n\nEigen::array<Eigen::IndexPair<int>, 1> transposed_product_dims = { Eigen::IndexPair<int>(0, 1) };\nEigen::Tensor<int, 2> AtBt = a.contract(b, transposed_product_dims);\n\nEigen::array<Eigen::IndexPair<int>, 2> double_contraction_product_dims = { Eigen::IndexPair<int>(0, 0), Eigen::IndexPair<int>(1, 1) };\nEigen::Tensor<int, 0> AdoubleContractedA = a.contract(a, double_contraction_product_dims);\n\nint value = AdoubleContractedA(0);\n```\n\n----------------------------------------\n\nTITLE: Composing Tensor Expressions in C++\nDESCRIPTION: This example shows how to build complex tensor expressions by chaining operations, demonstrating the equivalence of step-by-step expression building versus a single compound expression.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// One way to compute exp((t1 + t2) * 0.2f);\nauto t3 = t1 + t2;\nauto t4 = t3 * 0.2f;\nauto t5 = t4.exp();\nTensor<float, 3> result = t5;\n\n// Another way, exactly as efficient as the previous one:\nTensor<float, 3> result = ((t1 + t2) * 0.2f).exp();\n```\n\n----------------------------------------\n\nTITLE: Vector Operations and Type Conversions in Eigen C++\nDESCRIPTION: Covers vector-specific operations like norm, dot product, cross product and type conversion methods between different numeric types with MATLAB equivalents.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// Dot products, norms, etc.\n// Eigen                  // Matlab\nx.norm()                  // norm(x).    Note that norm(R) doesn't work in Eigen.\nx.squaredNorm()           // dot(x, x)   Note the equivalence is not true for complex\nx.dot(y)                  // dot(x, y)\nx.cross(y)                // cross(x, y) Requires #include <Eigen/Geometry>\n\n//// Type conversion\n// Eigen                  // Matlab\nA.cast<double>();         // double(A)\nA.cast<float>();          // single(A)\nA.cast<int>();            // int32(A)\nA.real();                 // real(A)\nA.imag();                 // imag(A)\n// if the original type equals destination type, no work is done\n\n// Note that for most operations Eigen requires all operands to have the same type:\nMatrixXf F = MatrixXf::Zero(3,3);\nA += F;                // illegal in Eigen. In Matlab A = A+F is allowed\nA += F.cast<double>(); // F converted to double and then added (generally, conversion happens on-the-fly)\n```\n\n----------------------------------------\n\nTITLE: Slicing Tensors in Eigen\nDESCRIPTION: Shows how to extract subtensors using the slice operation by specifying offsets and extents for each dimension.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<int, 2> a(4, 3);\na.setValues({{0, 100, 200}, {300, 400, 500}, {600, 700, 800}, {900, 1000, 1100}});\nEigen::array<int, 2> offsets = {1, 0};\nEigen::array<int, 2> extents = {2, 2};\nEigen::Tensor<int, 1> slice = a.slice(offsets, extents);\n```\n\n----------------------------------------\n\nTITLE: Matrix and Vector Operations in Eigen C++\nDESCRIPTION: Basic matrix operations including matrix-vector, matrix-matrix, and matrix-scalar operations with assignment variants. Includes equivalent MATLAB operations for reference.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// All the same as Matlab, but matlab doesn't have *= style operators.\n// Matrix-vector.  Matrix-matrix.   Matrix-scalar.\ny  = M*x;          R  = P*Q;        R  = P*s;\na  = b*M;          R  = P - Q;      R  = s*P;\na *= M;            R  = P + Q;      R  = P/s;\n                   R *= Q;          R  = s*P;\n                   R += Q;          R *= s;\n                   R -= Q;          R /= s;\n```\n\n----------------------------------------\n\nTITLE: Evaluating Tensor Expressions in C++\nDESCRIPTION: This snippet demonstrates different ways to evaluate tensor expressions, including assigning to different tensor types and using the expression tree for further operations before final evaluation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nauto t4 = t1 + t2;\n\nTensor<float, 3> result = t4;  // Could also be: result(t4);\ncout << result(0, 0, 0);\n\nTensorMap<float, 4> result(<a float* with enough space>, <size0>, ...) = t4;\ncout << result(0, 0, 0);\n\nTensorFixedSize<float, Sizes<size0, ...>> result = t4;\ncout << result(0, 0, 0);\n```\n\n----------------------------------------\n\nTITLE: Special Matrix Initialization Functions in Eigen vs. MATLAB\nDESCRIPTION: Provides a comparison between Eigen and MATLAB functions for creating special matrices like identity, zeros, ones, random matrices, and linearly spaced vectors.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// Eigen                                    // Matlab\nMatrixXd::Identity(rows,cols)               // eye(rows,cols)\nC.setIdentity(rows,cols)                    // C = eye(rows,cols)\nMatrixXd::Zero(rows,cols)                   // zeros(rows,cols)\nC.setZero(rows,cols)                        // C = zeros(rows,cols)\nMatrixXd::Ones(rows,cols)                   // ones(rows,cols)\nC.setOnes(rows,cols)                        // C = ones(rows,cols)\nMatrixXd::Random(rows,cols)                 // rand(rows,cols)*2-1            // MatrixXd::Random returns uniform random numbers in (-1, 1).\nC.setRandom(rows,cols)                      // C = rand(rows,cols)*2-1\nVectorXd::LinSpaced(size,low,high)          // linspace(low,high,size)'\nv.setLinSpaced(size,low,high)               // v = linspace(low,high,size)'\nVectorXi::LinSpaced(((hi-low)/step)+1,      // low:step:hi\n                    low,low+step*(size-1))  //\n```\n\n----------------------------------------\n\nTITLE: Tensor Mapping\nDESCRIPTION: Shows how to map existing data arrays to tensors using TensorMap.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nfloat data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\nEigen::TensorMap<Tensor<float, 2>> a(data, 3, 4);\ncout << \"NumRows: \" << a.dimension(0) << \" NumCols: \" << a.dimension(1) << endl;\ncout << \"a(1, 2): \" << a(1, 2) << endl;\n```\n\n----------------------------------------\n\nTITLE: Reduction Along Multiple Dimensions - Eigen Tensor\nDESCRIPTION: Shows reduction of a 3D tensor along two dimensions using the maximum operator. Creates a 2x3x4 tensor and reduces it to a 1D tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_25\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<float, 3, Eigen::ColMajor> a(2, 3, 4);\na.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},\n                  {7.0f, 6.0f, 5.0f, 4.0f},\n                  {8.0f, 9.0f, 10.0f, 11.0f}},\n                 {{12.0f, 13.0f, 14.0f, 15.0f},\n                  {19.0f, 18.0f, 17.0f, 16.0f},\n                  {20.0f, 21.0f, 22.0f, 23.0f}}});\nEigen::Tensor<float, 1, Eigen::ColMajor> b =\n    a.maximum(Eigen::array<int, 2>({0, 1}));\n```\n\n----------------------------------------\n\nTITLE: Profiling Taskflow Programs with TFProf\nDESCRIPTION: Commands demonstrating how to enable the built-in Taskflow profiler by setting an environment variable to generate JSON profiling data that can be visualized in a web-based interface.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# run the program with the environment variable TF_ENABLE_PROFILER enabled\n~$ TF_ENABLE_PROFILER=simple.json ./simple\n~$ cat simple.json\n[\n{\"executor\":\"0\",\"data\":[{\"worker\":0,\"level\":0,\"data\":[{\"span\":[172,186],\"name\":\"0_0\",\"type\":\"static\"},{\"span\":[187,189],\"name\":\"0_1\",\"type\":\"static\"}]},{\"worker\":2,\"level\":0,\"data\":[{\"span\":[93,164],\"name\":\"2_0\",\"type\":\"static\"},{\"span\":[170,179],\"name\":\"2_1\",\"type\":\"static\"}]}]}\n]\n# paste the profiling json data to https://taskflow.github.io/tfprof/\n```\n\n----------------------------------------\n\nTITLE: Element-wise Operations in Eigen C++\nDESCRIPTION: Demonstrates element-wise (vectorized) operations on matrices and vectors, covering arithmetic, comparisons, mathematical functions with both .array() and .cwiseX() syntaxes.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// Vectorized operations on each element independently\n// Eigen                       // Matlab\nR = P.cwiseProduct(Q);         // R = P .* Q\nR = P.array() * s.array();     // R = P .* s\nR = P.cwiseQuotient(Q);        // R = P ./ Q\nR = P.array() / Q.array();     // R = P ./ Q\nR = P.array() + s.array();     // R = P + s\nR = P.array() - s.array();     // R = P - s\nR.array() += s;                // R = R + s\nR.array() -= s;                // R = R - s\nR.array() < Q.array();         // R < Q\nR.array() <= Q.array();        // R <= Q\nR.cwiseInverse();              // 1 ./ P\nR.array().inverse();           // 1 ./ P\nR.array().sin()                // sin(P)\nR.array().cos()                // cos(P)\nR.array().pow(s)               // P .^ s\nR.array().square()             // P .^ 2\nR.array().cube()               // P .^ 3\nR.cwiseSqrt()                  // sqrt(P)\nR.array().sqrt()               // sqrt(P)\nR.array().exp()                // exp(P)\nR.array().log()                // log(P)\nR.cwiseMax(P)                  // max(R, P)\nR.array().max(P.array())       // max(R, P)\nR.cwiseMin(P)                  // min(R, P)\nR.array().min(P.array())       // min(R, P)\nR.cwiseAbs()                   // abs(P)\nR.array().abs()                // abs(P)\nR.cwiseAbs2()                  // abs(P.^2)\nR.array().abs2()               // abs(P.^2)\n(R.array() < s).select(P,Q );  // (R < s ? P : Q)\nR = (Q.array()==0).select(P,R) // R(Q==0) = P(Q==0)\nR = P.unaryExpr(ptr_fun(func)) // R = arrayfun(func, P)   // with: scalar func(const scalar &x);\n```\n\n----------------------------------------\n\nTITLE: Reduction Along Single Dimension - Eigen Tensor\nDESCRIPTION: Demonstrates reducing a 2D tensor along its second dimension using the maximum operator. Creates a 2x3 tensor and reduces it to a 1D tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_24\n\nLANGUAGE: C++\nCODE:\n```\n// Create a tensor of 2 dimensions\nEigen::Tensor<int, 2> a(2, 3);\na.setValues({{1, 2, 3}, {6, 5, 4}});\n// Reduce it along the second dimension (1)...\nEigen::array<int, 1> dims({1 /* dimension to reduce */});\n// ...using the \"maximum\" operator.\n// The result is a tensor with one dimension.  The size of\n// that dimension is the same as the first (non-reduced) dimension of a.\nEigen::Tensor<int, 1> b = a.maximum(dims);\n```\n\n----------------------------------------\n\nTITLE: Performing Tensor Addition in C++\nDESCRIPTION: This snippet shows how to perform element-wise addition of two tensors using operator overloading, demonstrating Eigen's lazy evaluation mechanism where operations are represented as expression trees.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 3> t1(2, 3, 4);\n...set some values in t1...\nTensor<float, 3> t2(2, 3, 4);\n...set some values in t2...\n// Set t3 to the element wise sum of t1 and t2\nTensor<float, 3> t3 = t1 + t2;\n```\n\n----------------------------------------\n\nTITLE: Matrix and Vector Reductions in Eigen C++\nDESCRIPTION: Shows reduction operations on matrices and vectors including min/max, sum, product, trace, and logical operations with column-wise and row-wise variants.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n// Reductions.\nint r, c;\n// Eigen                  // Matlab\nR.minCoeff()              // min(R(:))\nR.maxCoeff()              // max(R(:))\ns = R.minCoeff(&r, &c)    // [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);\ns = R.maxCoeff(&r, &c)    // [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);\nR.sum()                   // sum(R(:))\nR.colwise().sum()         // sum(R)\nR.rowwise().sum()         // sum(R, 2) or sum(R')'\nR.prod()                  // prod(R(:))\nR.colwise().prod()        // prod(R)\nR.rowwise().prod()        // prod(R, 2) or prod(R')'\nR.trace()                 // trace(R)\nR.all()                   // all(R(:))\nR.colwise().all()         // all(R)\nR.rowwise().all()         // all(R, 2)\nR.any()                   // any(R(:))\nR.colwise().any()         // any(R)\nR.rowwise().any()         // any(R, 2)\n```\n\n----------------------------------------\n\nTITLE: Tensor Dimensions Access in C++\nDESCRIPTION: Shows how to access tensor metadata including dimensions and size information.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(3, 4);\nconst Eigen::Tensor<float, 2>::Dimensions& d = a.dimensions();\ncout << \"Dim size: \" << d.size << \", dim 0: \" << d[0]\n     << \", dim 1: \" << d[1];\n```\n\n----------------------------------------\n\nTITLE: Matrix Slicing and Block Operations in Eigen C++\nDESCRIPTION: Comprehensive guide to accessing matrix subsets through block operations, showing both dynamic and template-based fixed-size methods with their MATLAB equivalents.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// Matrix slicing and blocks. All expressions listed here are read/write.\n// Templated size versions are faster. Note that Matlab is 1-based (a size N\n// vector is x(1)...x(N)).\n// Eigen                           // Matlab\nx.head(n)                          // x(1:n)\nx.head<n>()                        // x(1:n)\nx.tail(n)                          // x(end - n + 1: end)\nx.tail<n>()                        // x(end - n + 1: end)\nx.segment(i, n)                    // x(i+1 : i+n)\nx.segment<n>(i)                    // x(i+1 : i+n)\nP.block(i, j, rows, cols)          // P(i+1 : i+rows, j+1 : j+cols)\nP.block<rows, cols>(i, j)          // P(i+1 : i+rows, j+1 : j+cols)\nP.row(i)                           // P(i+1, :)\nP.col(j)                           // P(:, j+1)\nP.leftCols<cols>()                 // P(:, 1:cols)\nP.leftCols(cols)                   // P(:, 1:cols)\nP.middleCols<cols>(j)              // P(:, j+1:j+cols)\nP.middleCols(j, cols)              // P(:, j+1:j+cols)\nP.rightCols<cols>()                // P(:, end-cols+1:end)\nP.rightCols(cols)                  // P(:, end-cols+1:end)\nP.topRows<rows>()                  // P(1:rows, :)\nP.topRows(rows)                    // P(1:rows, :)\nP.middleRows<rows>(i)              // P(i+1:i+rows, :)\nP.middleRows(i, rows)              // P(i+1:i+rows, :)\nP.bottomRows<rows>()               // P(end-rows+1:end, :)\nP.bottomRows(rows)                 // P(end-rows+1:end, :)\nP.topLeftCorner(rows, cols)        // P(1:rows, 1:cols)\nP.topRightCorner(rows, cols)       // P(1:rows, end-cols+1:end)\nP.bottomLeftCorner(rows, cols)     // P(end-rows+1:end, 1:cols)\nP.bottomRightCorner(rows, cols)    // P(end-rows+1:end, end-cols+1:end)\nP.topLeftCorner<rows,cols>()       // P(1:rows, 1:cols)\nP.topRightCorner<rows,cols>()      // P(1:rows, end-cols+1:end)\nP.bottomLeftCorner<rows,cols>()    // P(end-rows+1:end, 1:cols)\nP.bottomRightCorner<rows,cols>()   // P(end-rows+1:end, end-cols+1:end)\n```\n\n----------------------------------------\n\nTITLE: Scan Operation (Cumulative Sum) - Eigen Tensor\nDESCRIPTION: Demonstrates the cumulative sum operation along a specified axis of a 2D tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_27\n\nLANGUAGE: C++\nCODE:\n```\n// Create a tensor of 2 dimensions\nEigen::Tensor<int, 2> a(2, 3);\na.setValues({{1, 2, 3}, {4, 5, 6}});\n// Scan it along the second dimension (1) using summation\nEigen::Tensor<int, 2> b = a.cumsum(1);\n```\n\n----------------------------------------\n\nTITLE: Memory Mapping in Eigen C++\nDESCRIPTION: Demonstrates how to map existing memory into Eigen matrices without copying data, useful for interfacing with other libraries or working with pre-allocated buffers.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n// Eigen can map existing memory into Eigen matrices.\nfloat array[3];\nVector3f::Map(array).fill(10);            // create a temporary Map over array and sets entries to 10\nint data[4] = {1, 2, 3, 4};\nMatrix2i mat2x2(data);                    // copies data into mat2x2\nMatrix2i::Map(data) = 2*mat2x2;           // overwrite elements of data with 2*mat2x2\nMatrixXi::Map(data, 2, 2) += mat2x2;      // adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)\n```\n\n----------------------------------------\n\nTITLE: Device-Specific Tensor Evaluation in C++\nDESCRIPTION: Shows how to evaluate tensor expressions using different device implementations including default CPU and thread pool.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nDefaultDevice my_device;\nc.device(my_device) = a + b;\n\n// Create the Eigen ThreadPoolDevice.\nEigen::ThreadPoolDevice my_device(4 /* number of threads to use */);\n\n// Now just use the device when evaluating expressions.\nEigen::Tensor<float, 2> c(30, 50);\nc.device(my_device) = a.contract(b, dot_product_dims);\n```\n\n----------------------------------------\n\nTITLE: Chipping Tensors in Eigen\nDESCRIPTION: Demonstrates extracting specific rows or columns from tensors using the chip operation. Shows both reading and writing with chips.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<int, 2> a(4, 3);\na.setValues({{0, 100, 200}, {300, 400, 500}, {600, 700, 800}, {900, 1000, 1100}});\nEigen::Tensor<int, 1> row_3 = a.chip(2, 0);\nEigen::Tensor<int, 1> col_2 = a.chip(1, 1);\n```\n\n----------------------------------------\n\nTITLE: Extracting Image Patches from Tensors in C++\nDESCRIPTION: Shows how to extract 2x2 image patches from a 4D tensor with extract_image_patches. Demonstrates the differences in dimension ordering between ColMajor and RowMajor layouts when working with image data.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_35\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 4> tensor(2,3,5,7);\nTensor<float, 4, RowMajor> tensor_row_major = tensor.swap_layout();\n```\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 5> twod_patch;\ntwod_patch = tensor.extract_image_patches<2, 2>();\n// twod_patch.dimension(0) == 2\n// twod_patch.dimension(1) == 2\n// twod_patch.dimension(2) == 2\n// twod_patch.dimension(3) == 3*5\n// twod_patch.dimension(4) == 7\n```\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 5, RowMajor> twod_patch_row_major;\ntwod_patch_row_major = tensor_row_major.extract_image_patches<2, 2>();\n// twod_patch_row_major.dimension(0) == 7\n// twod_patch_row_major.dimension(1) == 3*5\n// twod_patch_row_major.dimension(2) == 2\n// twod_patch_row_major.dimension(3) == 2\n// twod_patch_row_major.dimension(4) == 2\n```\n\n----------------------------------------\n\nTITLE: Running a Complete Benchmark Comparison\nDESCRIPTION: Example command that benchmarks Taskflow, OpenMP, and TBB on multiple applications across different thread counts, averaging results over multiple runs and generating a visualization.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/benchmarks.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n~$ ./benchmarks.py -m tf omp tbb \\\n                   -b graph_traversal wavefront linear_chain \\\n                   -t 1 4 8 16 \\\n                   -r 10 \\\n                   -p true \\\n                   -o result.png\n```\n\n----------------------------------------\n\nTITLE: Initializing Core CMake Configuration\nDESCRIPTION: Sets up basic CMake configuration including minimum version, project name, and build options for Taskflow project.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.18)\nMESSAGE(STATUS \"CMAKE_ROOT: \" ${CMAKE_ROOT})\n\nproject(Taskflow VERSION 3.10.0 LANGUAGES CXX)\n\noption(TF_BUILD_BENCHMARKS \"Enables builds of benchmarks\" OFF)\noption(TF_BUILD_PROFILER \"Enables builds of profiler\" OFF)\noption(TF_BUILD_CUDA \"Enables builds of cuda code\" OFF)\noption(TF_BUILD_SYCL \"Enables builds of sycl code\" OFF)\noption(TF_BUILD_TESTS \"Enables builds of tests\" ON)\noption(TF_BUILD_EXAMPLES \"Enables builds of examples\" ON)\n```\n\n----------------------------------------\n\nTITLE: Tensor Evaluation with eval() Method\nDESCRIPTION: Demonstrates explicit evaluation of intermediate results using eval() method in complex expressions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n// The previous example could have been written:\nTensor<float, 3> result = ((t1 + t2) * 0.2f).exp();\n\n// If you want to compute (t1 + t2) once ahead of time you can write:\nTensor<float, 3> result = ((t1 + t2).eval() * 0.2f).exp();\n```\n\n----------------------------------------\n\nTITLE: Configuring Unit Tests in TaskFlow using CMake\nDESCRIPTION: Sets up unit testing with doctest, defines test targets, and handles conditional compilation. The configuration includes optional exception tests based on sanitizer settings, and conditionally adds CUDA and SYCL tests if those features are enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/unittests/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nenable_testing()\n\ninclude(${TF_3RD_PARTY_DIR}/doctest/doctest.cmake)\n\nlist(APPEND TF_UNITTESTS \n  test_utility \n  test_queue\n  test_work_stealing \n  #test_serializer \n  test_basics \n  test_asyncs\n  test_dependent_asyncs\n  test_subflows\n  test_control_flow\n  test_semaphores\n  test_movable\n  test_cancellation\n  test_for_each\n  test_reduce\n  test_transform\n  test_sort\n  test_scan\n  test_find\n  test_modules\n  test_traversals\n  test_pipelines\n  test_scalable_pipelines\n  test_deferred_pipelines\n  test_deferred_scalable_pipelines\n  test_data_pipelines\n  test_runtimes\n  test_workers\n  #test_exceptions\n)\n\n# we only do exception tests if sanitizer is not enabled\nstring(FIND '${CMAKE_CXX_FLAGS}' \"-fsanitize\" sanitize)\n#message(\"sanitize='${sanitize}'\")\n\nif(${sanitize} EQUAL -1)\n  message(STATUS \"Add test_exception to unit tests\")\n  list(APPEND TF_UNITTESTS test_exceptions)\nendif()\n\n\nforeach(unittest IN LISTS TF_UNITTESTS)\n  add_executable(${unittest} ${unittest}.cpp)\n  target_link_libraries(${unittest} ${PROJECT_NAME} ${ATOMIC_LIBRARY} tf::default_settings)\n  target_include_directories(${unittest} PRIVATE ${TF_3RD_PARTY_DIR}/doctest)\n  doctest_discover_tests(${unittest})\nendforeach()\n\n# include CUDA tests\nif(TF_BUILD_CUDA)\n  add_subdirectory(${TF_UTEST_DIR}/cuda)\nendif()\n\n# include SYCL tests\nif(TF_BUILD_SYCL)\n  add_subdirectory(${TF_UTEST_DIR}/sycl)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Basic Tensor Operations Assignment in C++\nDESCRIPTION: Demonstrates the evaluation of tensor operations through assignment to a Tensor object. Operations are not evaluated until assigned to a concrete Tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nauto t3 = t1 + t2;             // t3 is an Operation.\nauto t4 = t3 * 0.2f;           // t4 is an Operation.\nauto t5 = t4.exp();            // t5 is an Operation.\nTensor<float, 3> result = t5;  // The operations are evaluated.\n```\n\n----------------------------------------\n\nTITLE: Type Casting in Eigen Tensor Library\nDESCRIPTION: Demonstrates how to use the cast<T> operation to convert tensor values from one type to another. The example shows casting between float and int types, particularly useful for operations not natively supported for certain types.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_36\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<float, 2> a(2, 3);\nEigen::Tensor<int, 2> b = a.cast<int>();\n```\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<int, 2> a(2, 3);\na.setValues({{0, 1, 2}, {3, 4, 5}});\nEigen::Tensor<int, 2> b =\n    (a.cast<float>() / a.constant(2).cast<float>()).cast<int>();\ncout << \"a\" << endl << a << endl << endl;\ncout << \"b\" << endl << b << endl << endl;\n```\n\n----------------------------------------\n\nTITLE: Package Configuration and Installation\nDESCRIPTION: Sets up package configuration files and installation rules for CMake find_package support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/taskflow DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\nset_target_properties(${PROJECT_NAME} PROPERTIES EXPORT_NAME ${PROJECT_NAME})\n\nexport(\n  TARGETS ${PROJECT_NAME} \n  NAMESPACE ${PROJECT_NAME}:: \n  FILE ${PROJECT_NAME}Targets.cmake\n)\nexport(PACKAGE ${PROJECT_NAME})\n\ninstall(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}Targets)\ninstall(\n  EXPORT ${PROJECT_NAME}Targets \n  NAMESPACE ${PROJECT_NAME}:: \n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring SYCL Examples in TaskFlow with CMake\nDESCRIPTION: This CMake script defines and configures multiple SYCL example applications in the TaskFlow project. It first creates a list of SYCL examples, then iterates through each to create executable targets with appropriate compiler options and dependencies including the TaskFlow library, atomic libraries, and threading support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/sycl/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND TF_SYCL_EXAMPLES \n  sycl_device\n  sycl_ndrange\n  sycl_saxpy\n  sycl_vector_add\n  sycl_atomic\n  sycl_matmul\n  sycl_reduce\n)\n\nforeach(sycl_example IN LISTS TF_SYCL_EXAMPLES)\n  add_executable(${sycl_example} ${sycl_example}.cpp)\n\n  #add_sycl_to_target(TARGET ${sycl_example} SOURCES ${sycl_example}.cpp)\n\n  target_compile_options(${sycl_example} PRIVATE ${TF_SYCL_OPTIONS})\n  target_link_options(${sycl_example} PRIVATE ${TF_SYCL_OPTIONS})\n  target_link_libraries(${sycl_example}\n    ${PROJECT_NAME} ${ATOMIC_LIBRARY} Threads::Threads tf::default_settings\n  )\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Row, Column Swapping and Matrix Transformations in Eigen C++\nDESCRIPTION: Shows row/column assignment operations and Eigen's optimized swap function, plus matrix transformations like transpose, adjoint, diagonal extraction, and matrix flipping operations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// Of particular note is Eigen's swap function which is highly optimized.\n// Eigen                           // Matlab\nR.row(i) = P.col(j);               // R(i, :) = P(:, j)\nR.col(j1).swap(mat1.col(j2));      // R(:, [j1 j2]) = R(:, [j2, j1])\n\n// Views, transpose, etc;\n// Eigen                           // Matlab\nR.adjoint()                        // R'\nR.transpose()                      // R.' or conj(R')       // Read-write\nR.diagonal()                       // diag(R)               // Read-write\nx.asDiagonal()                     // diag(x)\nR.transpose().colwise().reverse()  // rot90(R)              // Read-write\nR.rowwise().reverse()              // fliplr(R)\nR.colwise().reverse()              // flipud(R)\nR.replicate(i,j)                   // repmat(P,i,j)\n```\n\n----------------------------------------\n\nTITLE: Tensor Initialization Methods\nDESCRIPTION: Various methods to initialize tensor contents including setConstant, setZero, and setValues.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(2, 3);\na.setValues({{0.0f, 1.0f, 2.0f}, {3.0f, 4.0f, 5.0f}});\ncout << \"a\" << endl << a << endl << endl;\n```\n\n----------------------------------------\n\nTITLE: Configuring TBB (Threading Building Blocks) in CMake\nDESCRIPTION: Sets up Intel's Threading Building Blocks library by defining its root directory, building TBB, and finding the package. Uses CMake policies to handle newer CMake behavior with package root variables.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# -----------------------------------------------------------------------------\n# tbb package\n# -----------------------------------------------------------------------------\ncmake_policy(PUSH)\ncmake_policy(SET CMP0074 NEW)\nif(NOT DEFINED TBB_ROOT_DIR)\n  set(TBB_ROOT_DIR ${TF_3RD_PARTY_DIR}/tbb)\nendif()\n\ninclude(${TBB_ROOT_DIR}/cmake/TBBBuild.cmake)\n#tbb_build(TBB_ROOT ${TBB_ROOT_DIR} CONFIG_DIR TBB_DIR MAKE_ARGS tbb_cpf=1)\ntbb_build(TBB_ROOT ${TBB_ROOT_DIR} CONFIG_DIR TBB_DIR)\nunset(TBB_ROOT)  # unset is needed to pop CMP0074 without warning\ncmake_policy(POP)\n#find_package(TBB REQUIRED tbb_preview)\nfind_package(TBB REQUIRED)\n#cmake_policy(POP)\n```\n\n----------------------------------------\n\nTITLE: Configuring Async Task Benchmark in CMake\nDESCRIPTION: Configures the async_task benchmark executable with implementations in OpenMP, TBB, STD, and TaskFlow, including required dependencies and compiler flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(\n  bench_async_task\n  ${TF_BENCHMARK_DIR}/async_task/main.cpp\n  ${TF_BENCHMARK_DIR}/async_task/omp.cpp\n  ${TF_BENCHMARK_DIR}/async_task/tbb.cpp\n  ${TF_BENCHMARK_DIR}/async_task/std.cpp\n  ${TF_BENCHMARK_DIR}/async_task/taskflow.cpp\n)\ntarget_include_directories(bench_async_task PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_async_task\n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_async_task PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Taskflow Program in Bash\nDESCRIPTION: Command line instructions for cloning the Taskflow repository, compiling a C++ program with Taskflow headers, and executing the resulting binary.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n~$ git clone https://github.com/taskflow/taskflow.git  # clone it only once\n~$ g++ -std=c++20 examples/simple.cpp -I. -O2 -pthread -o simple\n~$ ./simple\nTaskA\nTaskC \nTaskB \nTaskD\n```\n\n----------------------------------------\n\nTITLE: Creating TensorMap Instances in C++\nDESCRIPTION: This snippet demonstrates how to create TensorMap objects that view existing memory as tensors without owning the data, including mapping to stack-allocated storage and viewing the same data with different dimensions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// Map a tensor of ints on top of stack-allocated storage.\nint storage[128];  // 2 x 4 x 2 x 8 = 128\nTensorMap<Tensor<int, 4>> t_4d(storage, 2, 4, 2, 8);\n\n// The same storage can be viewed as a different tensor.\n// You can also pass the sizes as an array.\nTensorMap<Tensor<int, 2>> t_2d(storage, 16, 8);\n\n// You can also map fixed-size tensors.  Here we get a 1d view of\n// the 2d fixed-size tensor.\nTensorFixedSize<float, Sizes<4, 5>> t_4x3;\nTensorMap<Tensor<float, 1>> t_12(t_4x3.data(), 12);\n```\n\n----------------------------------------\n\nTITLE: Setting Eigen Build Options\nDESCRIPTION: Configures various build options for Eigen, including package configuration, row-major default, test sizes, and platform-specific settings.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\noption(EIGEN_BUILD_BTL \"Build benchmark suite\" OFF)\n\n# Disable pkgconfig only for native Windows builds\nif(NOT WIN32 OR NOT CMAKE_HOST_SYSTEM_NAME MATCHES Windows)\n  option(EIGEN_BUILD_PKGCONFIG \"Build pkg-config .pc file for Eigen\" ON)\nendif()\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\noption(EIGEN_SPLIT_LARGE_TESTS \"Split large tests into smaller executables\" ON)\n\noption(EIGEN_DEFAULT_TO_ROW_MAJOR \"Use row-major as default matrix storage order\" OFF)\nif(EIGEN_DEFAULT_TO_ROW_MAJOR)\n  add_definitions(\"-DEIGEN_DEFAULT_TO_ROW_MAJOR\")\nendif()\n\nset(EIGEN_TEST_MAX_SIZE \"320\" CACHE STRING \"Maximal matrix/vector size, default is 320\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Reduce Sum Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for parallel reduction (sum) that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 9: reduce_sum\nadd_executable(\n  bench_reduce_sum\n  ${TF_BENCHMARK_DIR}/reduce_sum/main.cpp\n  ${TF_BENCHMARK_DIR}/reduce_sum/omp.cpp\n  ${TF_BENCHMARK_DIR}/reduce_sum/tbb.cpp\n  ${TF_BENCHMARK_DIR}/reduce_sum/taskflow.cpp\n)\ntarget_include_directories(bench_reduce_sum PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_reduce_sum \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_reduce_sum PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Heterogeneous Traversal Benchmark in CMake\nDESCRIPTION: Sets up the CUDA-based heterogeneous traversal benchmark with multiple implementations and specific CUDA compiler settings. Only built when CUDA support is enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_21\n\nLANGUAGE: cmake\nCODE:\n```\nif(TF_BUILD_CUDA)\n\n  add_executable(\n    bench_hetero_traversal \n    ${TF_BENCHMARK_DIR}/hetero_traversal/main.cu\n    ${TF_BENCHMARK_DIR}/hetero_traversal/taskflow.cu\n    ${TF_BENCHMARK_DIR}/hetero_traversal/tbb.cu\n    ${TF_BENCHMARK_DIR}/hetero_traversal/omp.cu\n  )\n  \n  target_include_directories(\n    bench_hetero_traversal PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11\n  )\n  \n  target_link_libraries(\n    bench_hetero_traversal \n    ${PROJECT_NAME} \n    Threads::Threads \n    ${TBB_IMPORTED_TARGETS} \n    ${OpenMP_CXX_LIBRARIES} \n    tf::default_settings\n  )\n  \n  set_target_properties(\n    bench_hetero_traversal PROPERTIES COMPILE_FLAGS \"-Xcompiler ${OpenMP_CXX_FLAGS}\"\n  )\n  \n  if(NOT CUDA_ARCHITECTURES)\n    set_property(TARGET bench_hetero_traversal PROPERTY CUDA_ARCHITECTURES OFF)\n  endif()\n\nendif(TF_BUILD_CUDA)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags for GCC/Clang in CMake\nDESCRIPTION: Configures compiler flags for GCC and Clang compilers, including warnings, optimizations, and language standards. It also handles specific flags for Android NDK builds.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_COMPILER_IS_GNUCXX)\n  ei_add_cxx_compiler_flag(\"-Wshadow\")\nendif()\n\nei_add_cxx_compiler_flag(\"-Wno-psabi\")\nei_add_cxx_compiler_flag(\"-Wno-variadic-macros\")\nei_add_cxx_compiler_flag(\"-Wno-long-long\")\n\nei_add_cxx_compiler_flag(\"-fno-check-new\")\nei_add_cxx_compiler_flag(\"-fno-common\")\nei_add_cxx_compiler_flag(\"-fstrict-aliasing\")\nei_add_cxx_compiler_flag(\"-wd981\")\nei_add_cxx_compiler_flag(\"-wd2304\")\n\ncheck_cxx_compiler_flag(\"-strict-ansi\" COMPILER_SUPPORT_STRICTANSI)\nei_add_cxx_compiler_flag(\"-Qunused-arguments\")\n\nif(COMPILER_SUPPORT_STRICTANSI)\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -strict-ansi\")\nelse()\n  ei_add_cxx_compiler_flag(\"-ansi\")\nendif()\n\nif(ANDROID_NDK)\n  ei_add_cxx_compiler_flag(\"-pie\")\n  ei_add_cxx_compiler_flag(\"-fPIE\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Extracting Tensor Patches with ColMajor and RowMajor Layout in C++\nDESCRIPTION: Demonstrates how to extract 2x2 patches from a 2D tensor using extract_patches method. The example shows the difference in indexing between ColMajor and RowMajor data layouts, extracting six 2x2 patches from a 3x4 tensor.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<float, 2, DataLayout> tensor(3,4);\ntensor.setValues({{0.0f, 1.0f, 2.0f, 3.0f},\n                  {4.0f, 5.0f, 6.0f, 7.0f},\n                  {8.0f, 9.0f, 10.0f, 11.0f}});\n\ncout << \"tensor: \" << endl << tensor << endl;\n```\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<float, 3, DataLayout> patch;\nEigen::array<ptrdiff_t, 2> patch_dims;\npatch_dims[0] = 2;\npatch_dims[1] = 2;\npatch = tensor.extract_patches(patch_dims);\nfor (int k = 0; k < 6; ++k) {\n  cout << \"patch index: \" << k << endl;\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      if (DataLayout == ColMajor) {\n        cout << patch(i, j, k) << \" \";\n      } else {\n        cout << patch(k, i, j) << \" \";\n      }\n    }\n    cout << endl;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Pipeline Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for data pipeline processing that compares implementations using TaskFlow and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 14: data_pipeline\nadd_executable(\n  bench_data_pipeline\n  ${TF_BENCHMARK_DIR}/data_pipeline/main.cpp\n  ${TF_BENCHMARK_DIR}/data_pipeline/tbb.cpp\n  ${TF_BENCHMARK_DIR}/data_pipeline/taskflow.cpp\n)\ntarget_include_directories(bench_data_pipeline PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_data_pipeline \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_data_pipeline PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Setting Up GCC/Clang Compiler Warning Flags\nDESCRIPTION: Configures compiler warning flags for GCC and Clang compilers to ensure high-quality code by enabling various warnings for potential issues.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT MSVC)\n  # We assume that other compilers are partly compatible with GNUCC\n\n  # clang outputs some warnings for unknown flags that are not caught by check_cxx_compiler_flag\n  # adding -Werror turns such warnings into errors\n  check_cxx_compiler_flag(\"-Werror\" COMPILER_SUPPORT_WERROR)\n  if(COMPILER_SUPPORT_WERROR)\n    set(CMAKE_REQUIRED_FLAGS \"-Werror\")\n  endif()\n  ei_add_cxx_compiler_flag(\"-pedantic\")\n  ei_add_cxx_compiler_flag(\"-Wall\")\n  ei_add_cxx_compiler_flag(\"-Wextra\")\n  #ei_add_cxx_compiler_flag(\"-Weverything\")              # clang\n  \n  ei_add_cxx_compiler_flag(\"-Wundef\")\n  ei_add_cxx_compiler_flag(\"-Wcast-align\")\n  ei_add_cxx_compiler_flag(\"-Wchar-subscripts\")\n  ei_add_cxx_compiler_flag(\"-Wnon-virtual-dtor\")\n  ei_add_cxx_compiler_flag(\"-Wunused-local-typedefs\")\n  ei_add_cxx_compiler_flag(\"-Wpointer-arith\")\n  ei_add_cxx_compiler_flag(\"-Wwrite-strings\")\n  ei_add_cxx_compiler_flag(\"-Wformat-security\")\n  ei_add_cxx_compiler_flag(\"-Wshorten-64-to-32\")\n  ei_add_cxx_compiler_flag(\"-Wlogical-op\")\n  ei_add_cxx_compiler_flag(\"-Wenum-conversion\")\n  ei_add_cxx_compiler_flag(\"-Wc++11-extensions\")\n  ei_add_cxx_compiler_flag(\"-Wdouble-promotion\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Deferred Pipeline Benchmark in CMake\nDESCRIPTION: Sets up the deferred_pipeline benchmark executable with required source files, include directories and library dependencies including OpenMP and TaskFlow.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(\n  bench_deferred_pipeline\n  ${TF_BENCHMARK_DIR}/deferred_pipeline/main.cpp\n  ${TF_BENCHMARK_DIR}/deferred_pipeline/pthread.cpp\n  ${TF_BENCHMARK_DIR}/deferred_pipeline/taskflow.cpp\n)\ntarget_include_directories(bench_deferred_pipeline PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_deferred_pipeline\n  ${PROJECT_NAME}\n  ${OpenMP_CXX_LIBRARIES}\n  tf::default_settings\n)\nset_target_properties(bench_deferred_pipeline PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Optional Components Configuration\nDESCRIPTION: Conditional inclusion of optional components like examples, tests, profiler and benchmarks based on build flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif(TF_BUILD_EXAMPLES)\n  add_subdirectory(examples)\nendif(TF_BUILD_EXAMPLES)\n\nif(TF_BUILD_TESTS)\n  include(CTest)\n  add_subdirectory(unittests)\nendif(TF_BUILD_TESTS)\n\nif(TF_BUILD_PROFILER)\n  add_subdirectory(tfprof/server)\nendif(TF_BUILD_PROFILER)\n\nif(TF_BUILD_BENCHMARKS)\n  add_subdirectory(benchmarks)\nendif(TF_BUILD_BENCHMARKS)\n```\n\n----------------------------------------\n\nTITLE: Reduction Along All Dimensions - Eigen Tensor\nDESCRIPTION: Demonstrates reducing a 3D tensor along all dimensions using the sum operator, resulting in a scalar value (0D tensor).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_26\n\nLANGUAGE: C++\nCODE:\n```\nEigen::Tensor<float, 3> a(2, 3, 4);\na.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},\n                  {7.0f, 6.0f, 5.0f, 4.0f},\n                  {8.0f, 9.0f, 10.0f, 11.0f}},\n                 {{12.0f, 13.0f, 14.0f, 15.0f},\n                  {19.0f, 18.0f, 17.0f, 16.0f},\n                  {20.0f, 21.0f, 22.0f, 23.0f}}});\n// Reduce along all dimensions using the sum() operator.\nEigen::Tensor<float, 0> b = a.sum();\n```\n\n----------------------------------------\n\nTITLE: Parsing Eigen Version Information from Source Headers\nDESCRIPTION: Extracts version information from the Eigen Macros.h header file using regex pattern matching to determine major, minor, and patch versions.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfile(READ \"${PROJECT_SOURCE_DIR}/Eigen/src/Core/util/Macros.h\" _eigen_version_header)\nstring(REGEX MATCH \"define[ \\t]+EIGEN_WORLD_VERSION[ \\t]+([0-9]+)\" _eigen_world_version_match \"${_eigen_version_header}\")\nset(EIGEN_WORLD_VERSION \"${CMAKE_MATCH_1}\")\nstring(REGEX MATCH \"define[ \\t]+EIGEN_MAJOR_VERSION[ \\t]+([0-9]+)\" _eigen_major_version_match \"${_eigen_version_header}\")\nset(EIGEN_MAJOR_VERSION \"${CMAKE_MATCH_1}\")\nstring(REGEX MATCH \"define[ \\t]+EIGEN_MINOR_VERSION[ \\t]+([0-9]+)\" _eigen_minor_version_match \"${_eigen_version_header}\")\nset(EIGEN_MINOR_VERSION \"${CMAKE_MATCH_1}\")\nset(EIGEN_VERSION_NUMBER ${EIGEN_WORLD_VERSION}.${EIGEN_MAJOR_VERSION}.${EIGEN_MINOR_VERSION})\n```\n\n----------------------------------------\n\nTITLE: Using the Benchmarks Python Wrapper\nDESCRIPTION: Commands to prepare and execute the benchmarks.py script, which helps configure benchmark parameters including thread count, iterations, tasking methods, and visualization options.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/benchmarks.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n~$ chmod 755 benchmarks.py    # change the permission to execute\n~$ ./benchmarks.py -h         # show the help message\n```\n\n----------------------------------------\n\nTITLE: Finding and Configuring OpenMP in CMake\nDESCRIPTION: Detects OpenMP on the system using FindOpenMP module and verifies that it's available. It outputs OpenMP configuration details and will fail the build process if OpenMP is not found.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# -----------------------------------------------------------------------------\n# find OpenMP package\n# -----------------------------------------------------------------------------\ninclude(FindOpenMP)\n\nif(NOT OpenMP_CXX_FOUND)\n  message(FATAL_ERROR \"OpenMP not found\")\nendif()\n  \nmessage(STATUS \"OpenMP_VERSION: ${OpenMP_VERSION}\")\nmessage(STATUS \"OpenMP_CXX_FLAGS: ${OpenMP_CXX_FLAGS}\")\nmessage(STATUS \"OpenMP_CXX_LIBRARIES: ${OpenMP_CXX_LIBRARIES}\")\n```\n\n----------------------------------------\n\nTITLE: Shuffling Tensor Dimensions in Eigen\nDESCRIPTION: Shows how to reorder tensor dimensions using the shuffle operation. Includes examples of shuffling 3D tensors and using shuffle as an lvalue.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 3> input(20, 30, 50);\n// ... set some values in input.\nTensor<float, 3> output = input.shuffle({1, 2, 0});\n\n// Using shuffle as lvalue\nTensor<float, 3> output(30, 50, 20);\noutput.shuffle({2, 0, 1}) = input;\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen CMake Configuration Files\nDESCRIPTION: This snippet installs the generated CMake configuration files for Eigen. These files allow other projects to easily find and use Eigen as a dependency.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_22\n\nLANGUAGE: cmake\nCODE:\n```\ninstall ( FILES ${CMAKE_CURRENT_SOURCE_DIR}/cmake/UseEigen3.cmake\n                ${CMAKE_CURRENT_BINARY_DIR}/Eigen3Config.cmake\n                ${CMAKE_CURRENT_BINARY_DIR}/Eigen3ConfigVersion.cmake\n          DESTINATION ${CMAKEPACKAGE_INSTALL_DIR} )\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Examples List and Build Settings in CMake\nDESCRIPTION: Defines a list of CUDA examples to be built and configures their build settings. The code sets up executable targets for each CUDA example, links necessary libraries, and handles CUDA architecture settings. Includes proper linking with TaskFlow libraries and thread support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/cuda/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND TF_CUDA_EXAMPLES \n  cuda_device_property \n  cuda_saxpy \n  cuda_matmul \n  cuda_knn\n  #cuda_capturer\n  #cuda_reduce\n  #cuda_scan\n  #cuda_merge\n  #cuda_sort\n  #cuda_transform\n  cuda_saxpy_update\n  #cuda_find\n)\n\nforeach(cuda_example IN LISTS TF_CUDA_EXAMPLES)\n  add_executable(${cuda_example} ${cuda_example}.cu)\n  target_link_libraries(${cuda_example}\n    ${PROJECT_NAME} ${ATOMIC_LIBRARY} Threads::Threads tf::default_settings\n  )\n\n  # avoid cmake 3.18+ warning\n  # we let nvcc to decide the flag if the architecture is not given\n  if(NOT CUDA_ARCHITECTURES)\n    set_property(TARGET ${cuda_example} PROPERTY CUDA_ARCHITECTURES OFF)\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting Up CUDA Configuration\nDESCRIPTION: Configures CUDA compiler settings and version requirements when CUDA build is enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(TF_BUILD_CUDA)\n  message(STATUS \"Configuring CUDA ...\")\n  check_language(CUDA)\n  if(NOT CMAKE_CUDA_COMPILER)\n    message(FATAL_ERROR \"\\nNo CUDA compiler found\")\n  endif()\n  enable_language(CUDA)\n  if(CMAKE_CUDA_COMPILER_VERSION VERSION_LESS \"11\")\n    message(STATUS \"CMAKE_CUDA_COMPILER_VERSION: ${CMAKE_CUDA_COMPILER_VERSION}\")\n    message(FATAL_ERROR \"\\nTaskflow requires CUDA at least v11\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA BLAS Example Executables in CMake\nDESCRIPTION: Iterates through the list of CUDA BLAS examples, creating an executable target for each. It links necessary libraries, sets include directories, and handles CUDA architecture settings.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/sandbox/cublas_examples/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(cublas_example IN LISTS TF_CUDA_BLAS_EXAMPLES)\n  add_executable(${cublas_example} ${cublas_example}.cu)\n  target_link_libraries(${cublas_example}\n    ${PROJECT_NAME} Threads::Threads tf::default_settings ${CUBLAS_LIBRARIES}\n  )\n  target_include_directories(${cublas_example} PRIVATE ${CUBLAS_INCLUDE_DIRS})\n  # avoid cmake 3.18+ warning\n  # we let nvcc to decide the flag if the architecture is not given\n  if(NOT CUDA_ARCHITECTURES)\n    set_property(TARGET ${cublas_example} PROPERTY CUDA_ARCHITECTURES OFF)\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Information in CMake for Eigen Tests\nDESCRIPTION: This snippet sets up compiler-related information for Eigen tests. It detects if the compiler is QCC, adds properties for CXX compiler, version, and flags, and includes information about sparse library flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nstring(TOLOWER \"${CMAKE_CXX_COMPILER}\" cmake_cxx_compiler_tolower)\nif(cmake_cxx_compiler_tolower MATCHES \"qcc\")\n  set(CXX_IS_QCC \"ON\")\nendif()\n\nei_add_property(EIGEN_TESTING_SUMMARY \"CXX:               ${CMAKE_CXX_COMPILER}\\n\")\nif(CMAKE_COMPILER_IS_GNUCXX AND NOT CXX_IS_QCC)\n  execute_process(COMMAND ${CMAKE_CXX_COMPILER} --version COMMAND head -n 1 OUTPUT_VARIABLE EIGEN_CXX_VERSION_STRING OUTPUT_STRIP_TRAILING_WHITESPACE)\n  ei_add_property(EIGEN_TESTING_SUMMARY \"CXX_VERSION:       ${EIGEN_CXX_VERSION_STRING}\\n\")\nendif()\nei_add_property(EIGEN_TESTING_SUMMARY \"CXX_FLAGS:         ${CMAKE_CXX_FLAGS}\\n\")\nei_add_property(EIGEN_TESTING_SUMMARY \"Sparse lib flags:  ${SPARSE_LIBS}\\n\")\n```\n\n----------------------------------------\n\nTITLE: TensorFixedSize Assignment in C++\nDESCRIPTION: Shows assignment to a TensorFixedSize for more efficient evaluation when dimensions are known at compile time.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n// We know that the result is a 4x4x2 tensor!\nTensorFixedSize<float, Sizes<4, 4, 2>> result = t5;\n```\n\n----------------------------------------\n\nTITLE: Commented TaskflowDSL Project Configuration\nDESCRIPTION: Commented-out CMake code for building TaskflowDSL examples. The section shows how to configure and link three different DSL examples (condition, simple, and visualization) against the TaskflowDSL library.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n#### TaskflowDSL project\n#### TODO: enable only when C++17 is available\n##set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${TF_EXAMPLE_DIR}/dsl)\n#add_executable(condition_dsl ${TF_EXAMPLE_DIR}/dsl/condition_dsl.cpp)\n#target_link_libraries(\n#  condition_dsl TaskflowDSL tf::default_settings\n#)\n#\n#add_executable(simple_dsl ${TF_EXAMPLE_DIR}/dsl/simple_dsl.cpp)\n#target_link_libraries(\n#  simple_dsl TaskflowDSL tf::default_settings\n#)\n#\n#add_executable(visualization_dsl ${TF_EXAMPLE_DIR}/dsl/visualization_dsl.cpp)\n#target_link_libraries(\n#  visualization_dsl TaskflowDSL tf::default_settings\n#)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Eigen Unsupported Examples in CMake\nDESCRIPTION: This CMake script collects all C++ source files in the current directory, creates an executable for each example, links necessary libraries, sets up post-build commands to run each example and capture its output, and adds them all to a custom target called 'unsupported_examples'.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/doc/examples/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nFILE(GLOB examples_SRCS \"*.cpp\")\n\nADD_CUSTOM_TARGET(unsupported_examples)\n\nINCLUDE_DIRECTORIES(../../../unsupported ../../../unsupported/test)\n\nFOREACH(example_src ${examples_SRCS})\n  GET_FILENAME_COMPONENT(example ${example_src} NAME_WE)\n  ADD_EXECUTABLE(example_${example} ${example_src})\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    target_link_libraries(example_${example} ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  endif()\n  ADD_CUSTOM_COMMAND(\n    TARGET example_${example}\n    POST_BUILD\n    COMMAND example_${example}\n    ARGS >${CMAKE_CURRENT_BINARY_DIR}/${example}.out\n  )\n  ADD_DEPENDENCIES(unsupported_examples example_${example})\nENDFOREACH(example_src)\n```\n\n----------------------------------------\n\nTITLE: Defining Taskflow Examples in CMake\nDESCRIPTION: Creates a list of Taskflow example programs to be built. These examples demonstrate various features of the Taskflow library, including simple tasks, async operations, control flow structures, and parallel algorithms.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND TF_EXAMPLES\n  simple \n  attach_data\n  async\n  async_module\n  runtime_async\n  dependent_async\n  observer \n  subflow \n  fibonacci \n  condition\n  multi_condition\n  switch_case\n  do_while_loop\n  while_loop\n  if_else\n  nested_if_else\n  visualization \n  parallel_for \n  parallel_sort\n  parallel_reduce \n  inclusive_scan\n  exclusive_scan\n  pipeline\n  scalable_pipeline\n  scalable_pipeline_with_deferred_tokens\n  text_pipeline\n  taskflow_pipeline\n  parallel_graph_pipeline\n  parallel_data_pipeline\n  pipeline_with_deferred_tokens\n  run \n  corun\n  runtime\n  composition\n  limited_concurrency\n  cancel\n  exception\n  subflow_exception\n  worker_interface\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Boost Multiprecision Test in CMake for Eigen\nDESCRIPTION: This snippet sets up a test for Boost Multiprecision in Eigen. It finds the Boost package, includes directories, adds a test, and updates properties based on whether Boost was found or not.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Boost)\nif(Boost_FOUND)\n  include_directories(${Boost_INCLUDE_DIRS})\n  ei_add_test(boostmultiprec \"\" \"${Boost_LIBRARIES}\")\n  ei_add_property(EIGEN_TESTED_BACKENDS \"Boost.Multiprecision, \")\nelse()\n  ei_add_property(EIGEN_MISSING_BACKENDS \"Boost.Multiprecision, \")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Building of CUDA and SYCL Examples\nDESCRIPTION: Conditionally adds CUDA and SYCL subdirectories to the build if their respective flags are enabled. This allows for optional compilation of GPU-accelerated Taskflow examples.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# -----------------------------------------------------------------------------\n# cuda examples\n# -----------------------------------------------------------------------------\nif(TF_BUILD_CUDA)\n  add_subdirectory(cuda)\nendif()\n\n# -----------------------------------------------------------------------------\n# sycl examples\n# -----------------------------------------------------------------------------\nif(TF_BUILD_SYCL)\n  add_subdirectory(sycl)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Error Settings\nDESCRIPTION: Sets up compiler-specific error and warning flags for different compiler vendors.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(error_settings INTERFACE)\nadd_library(tf::error_settings ALIAS error_settings)\n\ntarget_compile_options(\n  error_settings\n  INTERFACE\n  $<$<CXX_COMPILER_ID:AppleClang>:-Wall -Wextra -Wfatal-errors -Wshadow>\n  $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:Clang>>:-Wall -Wextra -Wfatal-errors -Wshadow>\n  $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:GNU>>:-Wall -Wextra -Wfatal-errors -Wshadow>\n  $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/W3 /permissive->\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Wavefront Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for wavefront computing pattern that compares implementations using TaskFlow, OpenMP, TBB, and sequential execution. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 1: wavefront computing\nadd_executable(\n  bench_wavefront \n  ${TF_BENCHMARK_DIR}/wavefront/main.cpp\n  ${TF_BENCHMARK_DIR}/wavefront/omp.cpp\n  ${TF_BENCHMARK_DIR}/wavefront/tbb.cpp\n  ${TF_BENCHMARK_DIR}/wavefront/seq.cpp\n  ${TF_BENCHMARK_DIR}/wavefront/taskflow.cpp\n)\ntarget_include_directories(bench_wavefront PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_wavefront \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_wavefront PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Building Taskflow Examples with CMake\nDESCRIPTION: Iterates through the list of examples, configuring build rules for each one. It links against the Taskflow library and adds special compiler flags for Emscripten builds to support threading and atomic operations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(example IN LISTS TF_EXAMPLES)\n  add_executable(${example} ${example}.cpp)\n  target_link_libraries(\n    ${example} ${PROJECT_NAME} ${ATOMIC_LIBRARY} tf::default_settings\n    )\n  # set emcc options\n  if (CMAKE_SYSTEM_NAME STREQUAL Emscripten)\n    target_link_options(${example} PUBLIC -sASSERTIONS=1 -sPROXY_TO_PTHREAD -sTOTAL_MEMORY=1536MB -sEXIT_RUNTIME=1 -sUSE_PTHREADS=1)\n    target_compile_options(${example} PUBLIC -matomics)\n  endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring Fortran Compiler Support in CMake\nDESCRIPTION: Checks for Fortran compiler availability and enables the language if supported. Falls back to searching for a LAPACK library if Fortran is not available.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cmake/language_support.cmake\")\n\nworkaround_9220(Fortran EIGEN_Fortran_COMPILER_WORKS)\n\nif(EIGEN_Fortran_COMPILER_WORKS)\n  enable_language(Fortran OPTIONAL)\n  if(NOT CMAKE_Fortran_COMPILER)\n    set(EIGEN_Fortran_COMPILER_WORKS OFF)\n  endif()\nendif()\n\nif(NOT EIGEN_Fortran_COMPILER_WORKS)\n  # search for a default Lapack library to complete Eigen's one\n  find_package(LAPACK QUIET)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running TaskFlow Examples with CMake\nDESCRIPTION: This CMake script glob-collects all C++ files in the current directory, creates an executable for each, and sets up a post-build command to run the example and output results. It also handles C++11 compiler flag checks and linking of Eigen standard libraries if required.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/examples/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB examples_SRCS \"*.cpp\")\n\nforeach(example_src ${examples_SRCS})\n  get_filename_component(example ${example_src} NAME_WE)\n  add_executable(${example} ${example_src})\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    target_link_libraries(${example} ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  endif()\n  add_custom_command(\n    TARGET ${example}\n    POST_BUILD\n    COMMAND ${example}\n    ARGS >${CMAKE_CURRENT_BINARY_DIR}/${example}.out\n  )\n  add_dependencies(all_examples ${example})\nendforeach(example_src)\n\ncheck_cxx_compiler_flag(\"-std=c++11\" EIGEN_COMPILER_SUPPORT_CPP11)\nif(EIGEN_COMPILER_SUPPORT_CPP11)\nei_add_target_property(nullary_indexing COMPILE_FLAGS \"-std=c++11\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining CUDA Unit Tests List in CMake\nDESCRIPTION: Creates a list of CUDA unit test names, including both active and commented-out tests. This list is used to generate test executables later in the script.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/unittests/cuda/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND TF_CUDA_UNITTESTS \n  test_cuda_objects\n  test_cuda_basics \n  test_cuda_updates\n  test_cuda_matrix \n  test_cuda_kmeans \n  test_cuda_for_each\n  test_cuda_transform\n  #test_cuda_reduce\n  #test_cuda_scan\n  #test_cuda_find\n  #test_cuda_min_max_element\n  #test_cuda_merge\n\n  #test_cuda_capturer_optimizer\n  #test_cuda_capture\n  \n  #cuda_algorithms\n  #cuda_algorithm_updates\n)\n```\n\n----------------------------------------\n\nTITLE: Fixed Size Tensor Creation\nDESCRIPTION: Demonstrates creation of fixed-size tensors using TensorFixedSize template.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::TensorFixedSize<float, Sizes<3, 4>> a;\ncout << \"Rank: \" << a.rank() << endl;\ncout << \"NumRows: \" << a.dimension(0) << \" NumCols: \" << a.dimension(1) << endl;\n```\n\n----------------------------------------\n\nTITLE: Generating Split Test Helper Header in CMake\nDESCRIPTION: Creates a header file with preprocessor macros for split testing. The file is generated only if it doesn't exist to prevent unnecessary rebuilds.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h)  \n  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h \"\")\n  foreach(i RANGE 1 999)\n    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h\n      \"#ifdef EIGEN_TEST_PART_${i}\\n\"\n      \"#define CALL_SUBTEST_${i}(FUNC) CALL_SUBTEST(FUNC)\\n\"\n      \"#else\\n\"\n      \"#define CALL_SUBTEST_${i}(FUNC)\\n\"\n      \"#endif\\n\\n\"\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling Taskflow Benchmarks with CMake\nDESCRIPTION: Commands to create a build directory, configure CMake with the TF_BUILD_BENCHMARKS option enabled, and compile the benchmark sources.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/benchmarks.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n~$ mkdir build        # create a build folder under taskflow/\n~$ cd build\n~$ cmake ../ -DTF_BUILD_BENCHMARKS=ON\n~$ make\n```\n\n----------------------------------------\n\nTITLE: Configuring Sort Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for parallel sorting algorithms that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 10: sort\nadd_executable(\n  bench_sort\n  ${TF_BENCHMARK_DIR}/sort/main.cpp\n  ${TF_BENCHMARK_DIR}/sort/omp.cpp\n  ${TF_BENCHMARK_DIR}/sort/tbb.cpp\n  ${TF_BENCHMARK_DIR}/sort/taskflow.cpp\n)\ntarget_include_directories(bench_sort PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_sort \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_sort PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Creating Main Documentation Build Target\nDESCRIPTION: Defines the main documentation target that runs Doxygen, processes output files, and creates a compressed archive of the documentation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(doc ALL\n  COMMAND doxygen\n  COMMAND doxygen Doxyfile-unsupported\n  COMMAND ${CMAKE_COMMAND} -E copy ${Eigen_BINARY_DIR}/doc/html/group__TopicUnalignedArrayAssert.html ${Eigen_BINARY_DIR}/doc/html/TopicUnalignedArrayAssert.html\n  COMMAND ${CMAKE_COMMAND} -E rename html eigen-doc\n  COMMAND ${CMAKE_COMMAND} -E remove eigen-doc/eigen-doc.tgz\n  COMMAND ${CMAKE_COMMAND} -E tar cfz eigen-doc.tgz eigen-doc\n  COMMAND ${CMAKE_COMMAND} -E rename eigen-doc.tgz eigen-doc/eigen-doc.tgz\n  COMMAND ${CMAKE_COMMAND} -E rename eigen-doc html\n  WORKING_DIRECTORY ${Eigen_BINARY_DIR}/doc)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Test Executables in CMake\nDESCRIPTION: Iterates through the list of CUDA tests, creating an executable for each test, linking required libraries, setting include directories, and configuring CUDA architecture settings. It also sets up test discovery using doctest.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/unittests/cuda/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(cudatest IN LISTS TF_CUDA_UNITTESTS)\n  add_executable(${cudatest} ${cudatest}.cu)\n  target_link_libraries(${cudatest} ${PROJECT_NAME} ${ATOMIC_LIBRARY} tf::default_settings)\n  target_include_directories(${cudatest} PRIVATE ${TF_3RD_PARTY_DIR}/doctest)\n  \n  # avoid cmake 3.18+ warning\n  # we let nvcc to decide the flag if the architecture is not given\n  if(NOT CUDA_ARCHITECTURES)\n    set_property(TARGET ${cudatest} PROPERTY CUDA_ARCHITECTURES OFF)\n  endif()\n  \n  doctest_discover_tests(${cudatest})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting Eigen Version Variables in CMake\nDESCRIPTION: This code sets various CMake variables related to Eigen's version number, definitions, and installation paths. These variables are used in other parts of the build system and in generated configuration files.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nset ( EIGEN_VERSION_STRING ${EIGEN_VERSION_NUMBER} )\nset ( EIGEN_VERSION_MAJOR  ${EIGEN_WORLD_VERSION} )\nset ( EIGEN_VERSION_MINOR  ${EIGEN_MAJOR_VERSION} )\nset ( EIGEN_VERSION_PATCH  ${EIGEN_MINOR_VERSION} )\nset ( EIGEN_DEFINITIONS \"\")\nset ( EIGEN_INCLUDE_DIR \"${CMAKE_INSTALL_PREFIX}/${INCLUDE_INSTALL_DIR}\" )\nset ( EIGEN_ROOT_DIR ${CMAKE_INSTALL_PREFIX} )\n```\n\n----------------------------------------\n\nTITLE: Configuring Graph Pipeline Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for graph-based pipeline processing that compares implementations using TaskFlow, OpenMP, TBB, and a gold standard. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 12: graph_pipeline\nadd_executable(\n  bench_graph_pipeline\n  ${TF_BENCHMARK_DIR}/graph_pipeline/main.cpp\n  ${TF_BENCHMARK_DIR}/graph_pipeline/omp.cpp\n  ${TF_BENCHMARK_DIR}/graph_pipeline/tbb.cpp\n  ${TF_BENCHMARK_DIR}/graph_pipeline/taskflow.cpp\n  ${TF_BENCHMARK_DIR}/graph_pipeline/gold.cpp\n  #${TF_BENCHMARK_DIR}/graph_pipeline/fastflow.cpp\n)\ntarget_include_directories(bench_graph_pipeline PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_include_directories(bench_graph_pipeline PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/)\ntarget_link_libraries(\n  bench_graph_pipeline \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_graph_pipeline PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring SYCL Tests for TaskFlow in CMake\nDESCRIPTION: This snippet defines a list of SYCL tests, creates executables for each test, and configures compilation and linking options. It also sets up include directories and discovers tests using doctest.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/unittests/sycl/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND TF_SYCL_TESTS \n  sycl_basics\n  #sycl_algorithms\n  #sycl_rebinds\n)\n\nforeach(sycl_test IN LISTS TF_SYCL_TESTS)\n  add_executable(${sycl_test} ${sycl_test}.cpp)\n\n  #add_sycl_to_target(TARGET ${sycl_test} SOURCES ${sycl_test}.cpp)\n\n  target_compile_options(${sycl_test} PRIVATE ${TF_SYCL_OPTIONS})\n  target_link_options(${sycl_test} PRIVATE ${TF_SYCL_OPTIONS})\n  target_link_libraries(${sycl_test}\n    ${PROJECT_NAME} ${ATOMIC_LIBRARY} Threads::Threads tf::default_settings\n  )\n  target_include_directories(${sycl_test} PRIVATE ${TF_3RD_PARTY_DIR}/doctest)\n  \n  doctest_discover_tests(${sycl_test})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxyfile for Eigen Unsupported Documentation\nDESCRIPTION: Generates the Doxyfile for Eigen unsupported modules by configuring it from a template.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in\n  ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile-unsupported\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional Eigen Build Options in CMake\nDESCRIPTION: Sets up various build options for Eigen, including disabling explicit vectorization, forcing X87 instructions, generating 32-bit code, and disabling exceptions. It also configures CUDA compute architecture and include directories.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\noption(EIGEN_TEST_NO_EXPLICIT_VECTORIZATION \"Disable explicit vectorization in tests/examples\" OFF)\noption(EIGEN_TEST_X87 \"Force using X87 instructions. Implies no vectorization.\" OFF)\noption(EIGEN_TEST_32BIT \"Force generating 32bit code.\" OFF)\n\nif(EIGEN_TEST_X87)\n  set(EIGEN_TEST_NO_EXPLICIT_VECTORIZATION ON)\n  if(CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -mfpmath=387\")\n    message(STATUS \"Forcing use of x87 instructions in tests/examples\")\n  else()\n    message(STATUS \"EIGEN_TEST_X87 ignored on your compiler\")\n  endif()\nendif()\n\n# Similar blocks for EIGEN_TEST_32BIT, EIGEN_TEST_NO_EXPLICIT_VECTORIZATION, EIGEN_TEST_NO_EXPLICIT_ALIGNMENT, EIGEN_TEST_NO_EXCEPTIONS\n\nset(EIGEN_CUDA_COMPUTE_ARCH 30 CACHE STRING \"The CUDA compute architecture level to target when compiling CUDA code\")\n\ninclude_directories(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Configuring Mandelbrot Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for Mandelbrot set computation that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 7: mandelbrot\nadd_executable(\n  bench_mandelbrot \n  ${TF_BENCHMARK_DIR}/mandelbrot/main.cpp\n  ${TF_BENCHMARK_DIR}/mandelbrot/omp.cpp\n  ${TF_BENCHMARK_DIR}/mandelbrot/tbb.cpp\n  ${TF_BENCHMARK_DIR}/mandelbrot/taskflow.cpp\n)\ntarget_include_directories(bench_mandelbrot PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_mandelbrot \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_mandelbrot PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Setting Doxygen Parameters for Eigen Unsupported Modules\nDESCRIPTION: Configures Doxygen parameters specifically for the unsupported Eigen modules, with different output directory and styling.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(EIGEN_DOXY_PROJECT_NAME             \"Eigen-unsupported\")\nset(EIGEN_DOXY_OUTPUT_DIRECTORY_SUFFIX  \"/unsupported\")\nset(EIGEN_DOXY_INPUT                    \"\\\"${Eigen_SOURCE_DIR}/unsupported/Eigen\\\" \\\"${Eigen_SOURCE_DIR}/unsupported/doc\\\"\")\nset(EIGEN_DOXY_HTML_COLORSTYLE_HUE      \"0\")\nset(EIGEN_DOXY_TAGFILES                 \"\\\"${Eigen_BINARY_DIR}/doc/Eigen.doxytags=..\\\"\")\n#set(EIGEN_DOXY_TAGFILES                 \"\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Pool Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable that compares TaskFlow with simple thread pool implementations. Links against the TaskFlow library, TBB, and OpenMP for comprehensive comparison.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 13: comparison with simple thread pool\nadd_executable(\n  bench_thread_pool\n  ${TF_BENCHMARK_DIR}/thread_pool/thread_pool.cpp\n)\ntarget_include_directories(bench_thread_pool PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_thread_pool\n  ${PROJECT_NAME}\n  ${TBB_IMPORTED_TARGETS}\n  ${OpenMP_CXX_LIBRARIES}\n  tf::default_settings\n)\nset_target_properties(bench_thread_pool PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Validating CMake Build Type\nDESCRIPTION: Sets a default build type to 'Release' if none is specified and validates that the build type is one of the allowed values (Debug, Release, or RelWithDebInfo).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\nstring(TOLOWER \"${CMAKE_BUILD_TYPE}\" cmake_build_type_tolower)\nif(    NOT cmake_build_type_tolower STREQUAL \"debug\"\n   AND NOT cmake_build_type_tolower STREQUAL \"release\"\n   AND NOT cmake_build_type_tolower STREQUAL \"relwithdebinfo\")\n  message(FATAL_ERROR \"Unknown build type \\\"${CMAKE_BUILD_TYPE}\\\". Allowed values are Debug, Release, RelWithDebInfo (case-insensitive).\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Matrix Multiplication Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for matrix multiplication that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 6: matrix multiplication\nadd_executable(\n  bench_matrix_multiplication \n  ${TF_BENCHMARK_DIR}/matrix_multiplication/main.cpp\n  ${TF_BENCHMARK_DIR}/matrix_multiplication/omp.cpp\n  ${TF_BENCHMARK_DIR}/matrix_multiplication/tbb.cpp\n  ${TF_BENCHMARK_DIR}/matrix_multiplication/taskflow.cpp\n)\ntarget_include_directories(bench_matrix_multiplication PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_matrix_multiplication \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_matrix_multiplication PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for Fibonacci with TBB in C++\nDESCRIPTION: This CMake configuration sets up a Fibonacci project using C++11, creates an executable, and links it with the Intel Threading Building Blocks (TBB) library. It also includes conditional linking for the 'rt' library on Linux platforms.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/examples/test_all/fibonacci/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\nproject(fibonacci CXX)\n\nif (NOT CMAKE_CXX_STANDARD)\n    set(CMAKE_CXX_STANDARD 11)\n    set(CXX_STANDARD_REQUIRED ON)\nendif()\n\nadd_executable(fibonacci Fibonacci.cpp)\n\n# find_package will search for available TBBConfig using variables CMAKE_PREFIX_PATH and TBB_DIR.\nfind_package(TBB REQUIRED tbb)\n\ntarget_link_libraries(fibonacci\n                      ${TBB_IMPORTED_TARGETS}      # Link TBB imported targets to the executable; \"TBB::tbb\" can be used instead of \"${TBB_IMPORTED_TARGETS}\".\n                      $<$<PLATFORM_ID:Linux>:rt>)  # Link \"rt\" library on Linux\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Pipeline Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for linear pipeline processing that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 11: linear_pipeline\nadd_executable(\n  bench_linear_pipeline\n  ${TF_BENCHMARK_DIR}/linear_pipeline/main.cpp\n  ${TF_BENCHMARK_DIR}/linear_pipeline/omp.cpp\n  ${TF_BENCHMARK_DIR}/linear_pipeline/tbb.cpp\n  ${TF_BENCHMARK_DIR}/linear_pipeline/taskflow.cpp\n)\ntarget_include_directories(bench_linear_pipeline PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_linear_pipeline \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_linear_pipeline PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring Black-Scholes Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for Black-Scholes option pricing that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 8: black_scholes\nadd_executable(\n  bench_black_scholes\n  ${TF_BENCHMARK_DIR}/black_scholes/main.cpp\n  ${TF_BENCHMARK_DIR}/black_scholes/omp.cpp\n  ${TF_BENCHMARK_DIR}/black_scholes/tbb.cpp\n  ${TF_BENCHMARK_DIR}/black_scholes/taskflow.cpp\n)\ntarget_include_directories(bench_black_scholes PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_black_scholes \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_black_scholes PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Adding LAPACK Single Precision Tests in CMake\nDESCRIPTION: This section adds various single precision LAPACK tests using the previously defined add_lapack_test macro. It includes tests for linear equations, eigenvalue problems, and other operations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (BUILD_SINGLE)\nadd_lapack_test(stest.out stest.in xlintsts)\nadd_lapack_test(stest_rfp.out stest_rfp.in xlintstrfs)\nadd_lapack_test(snep.out nep.in xeigtsts)\nadd_lapack_test(ssep.out sep.in xeigtsts)\nadd_lapack_test(ssvd.out svd.in xeigtsts)\nadd_lapack_test(sec.out sec.in xeigtsts)\nadd_lapack_test(sed.out sed.in xeigtsts)\nadd_lapack_test(sgg.out sgg.in xeigtsts)\nadd_lapack_test(sgd.out sgd.in xeigtsts)\nadd_lapack_test(ssb.out ssb.in xeigtsts)\nadd_lapack_test(ssg.out ssg.in xeigtsts)\nadd_lapack_test(sbal.out sbal.in xeigtsts)\nadd_lapack_test(sbak.out sbak.in xeigtsts)\nadd_lapack_test(sgbal.out sgbal.in xeigtsts)\nadd_lapack_test(sgbak.out sgbak.in xeigtsts)\nadd_lapack_test(sbb.out sbb.in xeigtsts)\nadd_lapack_test(sglm.out glm.in xeigtsts)\nadd_lapack_test(sgqr.out gqr.in xeigtsts)\nadd_lapack_test(sgsv.out gsv.in xeigtsts)\nadd_lapack_test(scsd.out csd.in xeigtsts)\nadd_lapack_test(slse.out lse.in xeigtsts)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring MSVC Compiler Flags for Eigen in CMake\nDESCRIPTION: Sets up compiler flags specifically for Microsoft Visual C++ compiler when building Eigen. It includes warning suppressions, optimization flags, and options for enabling SSE2 and OpenMP.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT MSVC)\n  # GCC/Clang flags\nelse(NOT MSVC)\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /EHsc /wd4127 /wd4505 /wd4714\")\n  string(REGEX REPLACE \"/W[0-9]\" \"/W4\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n\n  check_cxx_compiler_flag(\"/openmp\" COMPILER_SUPPORT_OPENMP)\n  if(COMPILER_SUPPORT_OPENMP)\n    option(EIGEN_TEST_OPENMP \"Enable/Disable OpenMP in tests/examples\" OFF)\n    if(EIGEN_TEST_OPENMP)\n      set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /openmp\")\n      message(STATUS \"Enabling OpenMP in tests/examples\")\n    endif()\n  endif()\n\n  option(EIGEN_TEST_SSE2 \"Enable/Disable SSE2 in tests/examples\" OFF)\n  if(EIGEN_TEST_SSE2)\n    if(NOT CMAKE_CL_64)\n      set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /arch:SSE2\")\n    endif(NOT CMAKE_CL_64)\n    message(STATUS \"Enabling SSE2 in tests/examples\")\n  endif(EIGEN_TEST_SSE2)\nendif(NOT MSVC)\n```\n\n----------------------------------------\n\nTITLE: Configuring Graph Traversal Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for graph traversal algorithms that compares implementations using TaskFlow, OpenMP, TBB, and sequential execution. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 2: graph traversal\nadd_executable(\n  bench_graph_traversal \n  ${TF_BENCHMARK_DIR}/graph_traversal/main.cpp\n  ${TF_BENCHMARK_DIR}/graph_traversal/omp.cpp\n  ${TF_BENCHMARK_DIR}/graph_traversal/tbb.cpp\n  ${TF_BENCHMARK_DIR}/graph_traversal/seq.cpp\n  ${TF_BENCHMARK_DIR}/graph_traversal/taskflow.cpp\n)\ntarget_include_directories(bench_graph_traversal PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_graph_traversal \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_graph_traversal PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Library Target Configuration\nDESCRIPTION: Sets up static and shared library targets for EigenLapack with proper linking and installation rules\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(eigen_lapack_static ${EigenLapack_SRCS} ${ReferenceLapack_SRCS})\nadd_library(eigen_lapack SHARED ${EigenLapack_SRCS})\n\ntarget_link_libraries(eigen_lapack eigen_blas)\n\nif(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n  target_link_libraries(eigen_lapack_static ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  target_link_libraries(eigen_lapack ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\nendif()\n\ninstall(TARGETS eigen_lapack eigen_lapack_static\n        RUNTIME DESTINATION bin\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n```\n\n----------------------------------------\n\nTITLE: Configuring Linear Chain Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for linear chain operations that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 4: linear_chain\nadd_executable(\n  bench_linear_chain\n  ${TF_BENCHMARK_DIR}/linear_chain/main.cpp\n  ${TF_BENCHMARK_DIR}/linear_chain/tbb.cpp\n  ${TF_BENCHMARK_DIR}/linear_chain/omp.cpp\n  ${TF_BENCHMARK_DIR}/linear_chain/taskflow.cpp\n)\ntarget_include_directories(bench_linear_chain PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_linear_chain \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_linear_chain PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Extracting Mercurial Changeset Information\nDESCRIPTION: Checks if the source is a Mercurial repository, and if so, extracts the changeset information to include with the version number for development builds.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(IS_DIRECTORY ${CMAKE_SOURCE_DIR}/.hg)\n  # if the mercurial program is absent or this will leave the EIGEN_HG_CHANGESET string empty,\n  # but won't stop CMake.\n  execute_process(COMMAND hg tip -R ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE EIGEN_HGTIP_OUTPUT)\n  execute_process(COMMAND hg branch -R ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE EIGEN_BRANCH_OUTPUT)\nendif()\n\n# if this is the default (aka development) branch, extract the mercurial changeset number from the hg tip output...\nif(EIGEN_BRANCH_OUTPUT MATCHES \"default\")\nstring(REGEX MATCH \"^changeset: *[0-9]*:([0-9;a-f]+).*\" EIGEN_HG_CHANGESET_MATCH \"${EIGEN_HGTIP_OUTPUT}\")\nset(EIGEN_HG_CHANGESET \"${CMAKE_MATCH_1}\")\nendif(EIGEN_BRANCH_OUTPUT MATCHES \"default\")\n#...and show it next to the version number\nif(EIGEN_HG_CHANGESET)\n  set(EIGEN_VERSION \"${EIGEN_VERSION_NUMBER} (mercurial changeset ${EIGEN_HG_CHANGESET})\")\nelse(EIGEN_HG_CHANGESET)\n  set(EIGEN_VERSION \"${EIGEN_VERSION_NUMBER}\")\nendif(EIGEN_HG_CHANGESET)\n```\n\n----------------------------------------\n\nTITLE: Configuring Binary Tree Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for binary tree operations that compares implementations using TaskFlow, OpenMP, and TBB. Links against the necessary libraries and includes CLI11 for command-line argument parsing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 3: binary_tree\nadd_executable(\n  bench_binary_tree \n  ${TF_BENCHMARK_DIR}/binary_tree/main.cpp\n  ${TF_BENCHMARK_DIR}/binary_tree/tbb.cpp\n  ${TF_BENCHMARK_DIR}/binary_tree/omp.cpp\n  ${TF_BENCHMARK_DIR}/binary_tree/taskflow.cpp\n)\ntarget_include_directories(bench_binary_tree PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_binary_tree \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_binary_tree PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Requirements\nDESCRIPTION: Checks for supported compiler versions including GNU, Clang, AppleClang, MSVC, and Intel compilers.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS \"8.4\")\n    message(STATUS \"CMAKE_CXX_COMPILER_VERSION: ${CMAKE_CXX_COMPILER_VERSION}\")\n    message(FATAL_ERROR \"\\nTaskflow requires g++ at least v8.4\")\n  endif()\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS \"6.0\")\n    message(STATUS \"CMAKE_CXX_COMPILER_VERSION: ${CMAKE_CXX_COMPILER_VERSION}\")\n    message(FATAL_ERROR \"\\nTaskflow requires clang++ at least v6.0\")\n  endif()\n```\n\n----------------------------------------\n\nTITLE: Computing Eigenvalues and Eigenvectors in Matlab\nDESCRIPTION: This snippet shows how to compute eigenvalues and eigenvectors of a matrix in Matlab. It demonstrates the use of the 'eig' function to obtain both eigenvalues and eigenvectors, as well as how to extract diagonal elements for eigenvalues.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/AsciiQuickReference.txt#2025-04-22_snippet_13\n\nLANGUAGE: Matlab\nCODE:\n```\neig(A);\n[vec val] = eig(A)\ndiag(val)\nvec\n```\n\n----------------------------------------\n\nTITLE: LAPACK Testing Configuration\nDESCRIPTION: Configures LAPACK testing functionality including downloading reference implementations and setting up test environment\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption(EIGEN_ENABLE_LAPACK_TESTS OFF \"Enbale the Lapack unit tests\")\n\nif(EIGEN_ENABLE_LAPACK_TESTS)\n  get_filename_component(eigen_full_path_to_reference_lapack \"./reference/\" ABSOLUTE)\n  if(NOT EXISTS ${eigen_full_path_to_reference_lapack})\n    file(DOWNLOAD \"http://downloads.tuxfamily.org/eigen/lapack_addons_3.4.1.tgz\"\n                  \"${CMAKE_CURRENT_SOURCE_DIR}/lapack_addons_3.4.1.tgz\"\n                  INACTIVITY_TIMEOUT 15\n                  TIMEOUT 240\n                  STATUS download_status\n                  EXPECTED_MD5 ab5742640617e3221a873aba44bbdc93\n                  SHOW_PROGRESS)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen CMake Package for Legacy CMake\nDESCRIPTION: This section creates the CMake configuration files for Eigen when using older CMake versions (below 3.0). It provides a fallback mechanism for systems without modern CMake support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_21\n\nLANGUAGE: cmake\nCODE:\n```\nelse (NOT CMAKE_VERSION VERSION_LESS 3.0)\n  # Fallback to legacy Eigen3Config.cmake without the imported target\n  \n  # If CMakePackageConfigHelpers module is available (CMake >= 2.8.8)\n  # create a relocatable Config file, otherwise leave the hardcoded paths       \n  include(CMakePackageConfigHelpers OPTIONAL RESULT_VARIABLE CPCH_PATH)\n  \n  if(CPCH_PATH)\n    configure_package_config_file (\n      ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Eigen3ConfigLegacy.cmake.in\n      ${CMAKE_CURRENT_BINARY_DIR}/Eigen3Config.cmake\n      PATH_VARS EIGEN_INCLUDE_DIR EIGEN_ROOT_DIR\n      INSTALL_DESTINATION ${CMAKEPACKAGE_INSTALL_DIR}\n      NO_CHECK_REQUIRED_COMPONENTS_MACRO # Eigen does not provide components\n    )\n  else() \n    # The PACKAGE_* variables are defined by the configure_package_config_file\n    # but without it we define them manually to the hardcoded paths\n    set(PACKAGE_INIT \"\")\n    set(PACKAGE_EIGEN_INCLUDE_DIR ${EIGEN_INCLUDE_DIR})\n    set(PACKAGE_EIGEN_ROOT_DIR ${EIGEN_ROOT_DIR})\n    configure_file ( ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Eigen3ConfigLegacy.cmake.in\n                     ${CMAKE_CURRENT_BINARY_DIR}/Eigen3Config.cmake\n                     @ONLY ESCAPE_QUOTES )\n  endif()\n\n  write_basic_package_version_file( Eigen3ConfigVersion.cmake\n                                    VERSION ${EIGEN_VERSION_NUMBER}\n                                    COMPATIBILITY SameMajorVersion )\n\nendif (NOT CMAKE_VERSION VERSION_LESS 3.0)\n```\n\n----------------------------------------\n\nTITLE: Configuring MNIST Benchmark in CMake\nDESCRIPTION: Sets up a benchmark executable for MNIST image processing that compares implementations using TaskFlow, OpenMP, TBB, and sequential execution. Links against necessary libraries including the filesystem library (stdc++fs).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n## benchmark 5: MNIST\nadd_executable(\n  bench_mnist \n  ${TF_BENCHMARK_DIR}/mnist/main.cpp\n  ${TF_BENCHMARK_DIR}/mnist/omp.cpp\n  ${TF_BENCHMARK_DIR}/mnist/tbb.cpp\n  ${TF_BENCHMARK_DIR}/mnist/seq.cpp\n  ${TF_BENCHMARK_DIR}/mnist/taskflow.cpp\n)\ntarget_include_directories(bench_mnist PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_mnist \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS}\n  ${OpenMP_CXX_LIBRARIES} \n  stdc++fs \n  tf::default_settings\n)\nset_target_properties(bench_mnist PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Configuring Stack Size for LAPACK Tests in CMake\nDESCRIPTION: This snippet adjusts the executable linker flags to set a large stack size for LAPACK tests. It uses string manipulation to replace the existing stack size with a very large value.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nstring(REGEX REPLACE \"(.*)/STACK:(.*) (.*)\" \"\\1/STACK:900000000000000000 \\3\"\n  CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS}\")\n```\n\n----------------------------------------\n\nTITLE: CUDA Configuration Setup\nDESCRIPTION: Configures CUDA compilation flags and settings for tensor operations when CUDA support is enabled. Includes specific compiler flags and architecture-dependent features.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/test/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(CUDA 7.0)\nif(CUDA_FOUND AND EIGEN_TEST_CUDA)\n  string(REPLACE \"-pedantic\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n  string(REPLACE \"-Wundef\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n  string(REPLACE \"-Wnon-virtual-dtor\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n  string(REPLACE \"-fno-check-new\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n  string(REPLACE \"-ansi\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n\n  if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\")\n    set(CUDA_NVCC_FLAGS \"-ccbin ${CMAKE_C_COMPILER}\" CACHE STRING \"nvcc flags\" FORCE)\n  endif()\n\n  set(CUDA_NVCC_FLAGS  \"${EIGEN_CUDA_CXX11_FLAG} ${EIGEN_CUDA_RELAXED_CONSTEXPR} -arch compute_${EIGEN_CUDA_COMPUTE_ARCH} -Xcudafe \\\"--display_error_number\\\" ${CUDA_NVCC_FLAGS}\")\n```\n\n----------------------------------------\n\nTITLE: Appending Target Property in CMake\nDESCRIPTION: This macro appends a value to an existing target property instead of overwriting it. It's useful for incrementally building up properties on CMake targets.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nmacro(ei_add_target_property target prop value)\n\n  get_target_property(previous ${target} ${prop})\n  # if the property wasn't previously set, ${previous} is now \"previous-NOTFOUND\" which cmake allows catching with plain if()\n  if(NOT previous)\n    set(previous \"\")\n  endif(NOT previous)\n  set_target_properties(${target} PROPERTIES ${prop} \"${previous} ${value}\")\nendmacro(ei_add_target_property)\n```\n\n----------------------------------------\n\nTITLE: Configuring For_Each Benchmark in CMake\nDESCRIPTION: Configures the for_each benchmark executable with OpenMP, TBB, and TaskFlow implementations, including necessary dependencies and compiler flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(\n  bench_for_each\n  ${TF_BENCHMARK_DIR}/for_each/main.cpp\n  ${TF_BENCHMARK_DIR}/for_each/omp.cpp\n  ${TF_BENCHMARK_DIR}/for_each/tbb.cpp\n  ${TF_BENCHMARK_DIR}/for_each/taskflow.cpp\n)\ntarget_include_directories(bench_for_each PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_for_each \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_for_each PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Binary TBB Integration Example\nDESCRIPTION: Complete CMake example for integrating binary TBB package into a sub_string_finder sample project.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\nproject(sub_string_finder CXX)\nadd_executable(sub_string_finder sub_string_finder.cpp)\n\nfind_package(TBB REQUIRED tbb)\n\ntarget_link_libraries(sub_string_finder ${TBB_IMPORTED_TARGETS})\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Macro for BLAS Test Configuration\nDESCRIPTION: A CMake macro that creates a test executable from a Fortran file, links it against the eigen_blas library and necessary external dependencies, and adds it as a test. The macro handles creating the executable, linking libraries, and setting up the test to run with a shell script.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/testing/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nmacro(ei_add_blas_test testname)\n\n  set(targetname ${testname})\n\n  set(filename ${testname}.f)\n  add_executable(${targetname} ${filename})\n\n  target_link_libraries(${targetname} eigen_blas)\n\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    target_link_libraries(${targetname} ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  endif()\n\n  target_link_libraries(${targetname} ${EXTERNAL_LIBS})\n\n  add_test(${testname} \"${Eigen_SOURCE_DIR}/blas/testing/runblastest.sh\" \"${testname}\" \"${Eigen_SOURCE_DIR}/blas/testing/${testname}.dat\")\n  add_dependencies(buildtests ${targetname})\n  \nendmacro(ei_add_blas_test)\n```\n\n----------------------------------------\n\nTITLE: Setting Up LAPACK Test Summary in CMake\nDESCRIPTION: This snippet sets up a final test that runs a Python script to summarize the LAPACK test results. It copies the necessary Python script to the build directory and adds a test command to execute it.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(COMMAND ${CMAKE_COMMAND} -E copy ${LAPACK_SOURCE_DIR}/testing/lapack_testing.py ${LAPACK_BINARY_DIR})\nadd_test(\n  NAME LAPACK_Test_Summary\n  WORKING_DIRECTORY ${LAPACK_BINARY_DIR}\n  COMMAND ${PYTHON_EXECUTABLE} \"lapack_testing.py\"\n)\n```\n\n----------------------------------------\n\nTITLE: Preventing In-source Builds in CMake\nDESCRIPTION: Checks if the source directory is the same as the build directory and aborts if an in-source build is detected, as these can cause issues with the build process.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR})\n  message(FATAL_ERROR \"In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there. You may need to remove CMakeCache.txt. \")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Tests in CMake for Eigen\nDESCRIPTION: This snippet sets up CUDA testing for Eigen. It includes options for enabling CUDA support and using Clang for CUDA compilation. If CUDA is found, it configures compiler flags, includes directories, and adds a basic CUDA test.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\noption(EIGEN_TEST_CUDA \"Enable CUDA support in unit tests\" OFF)\noption(EIGEN_TEST_CUDA_CLANG \"Use clang instead of nvcc to compile the CUDA tests\" OFF)\n\nif(EIGEN_TEST_CUDA_CLANG AND NOT CMAKE_CXX_COMPILER MATCHES \"clang\")\n  message(WARNING \"EIGEN_TEST_CUDA_CLANG is set, but CMAKE_CXX_COMPILER does not appear to be clang.\")\nendif()\n\nif(EIGEN_TEST_CUDA)\n\nfind_package(CUDA 5.0)\nif(CUDA_FOUND)\n  \n  set(CUDA_PROPAGATE_HOST_FLAGS OFF)\n  if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\") \n    set(CUDA_NVCC_FLAGS \"-ccbin ${CMAKE_C_COMPILER}\" CACHE STRING \"nvcc flags\" FORCE)\n  endif()\n  if(EIGEN_TEST_CUDA_CLANG)\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11 --cuda-gpu-arch=sm_30\")\n  endif()\n  cuda_include_directories(${CMAKE_CURRENT_BINARY_DIR})\n  set(EIGEN_ADD_TEST_FILENAME_EXTENSION  \"cu\")\n  \n  ei_add_test(cuda_basic)\n  \n  unset(EIGEN_ADD_TEST_FILENAME_EXTENSION)\n\nendif(CUDA_FOUND)\n\nendif(EIGEN_TEST_CUDA)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scan Benchmark in CMake\nDESCRIPTION: Sets up the scan benchmark executable with implementations in OpenMP, TBB, and TaskFlow, including necessary library dependencies and compiler settings.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(\n  bench_scan\n  ${TF_BENCHMARK_DIR}/scan/main.cpp\n  ${TF_BENCHMARK_DIR}/scan/omp.cpp\n  ${TF_BENCHMARK_DIR}/scan/tbb.cpp\n  ${TF_BENCHMARK_DIR}/scan/taskflow.cpp\n)\ntarget_include_directories(bench_scan PRIVATE ${PROJECT_SOURCE_DIR}/3rd-party/CLI11)\ntarget_link_libraries(\n  bench_scan \n  ${PROJECT_NAME} \n  ${TBB_IMPORTED_TARGETS} \n  ${OpenMP_CXX_LIBRARIES} \n  tf::default_settings\n)\nset_target_properties(bench_scan PROPERTIES COMPILE_FLAGS ${OpenMP_CXX_FLAGS})\n```\n\n----------------------------------------\n\nTITLE: Adding Eigen Subdirectories in CMake\nDESCRIPTION: This section adds various subdirectories to the CMake build, including the main Eigen directory, documentation, tests, BLAS, LAPACK, and others. It also sets up options for building tests and SYCL support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(Eigen)\n\nadd_subdirectory(doc EXCLUDE_FROM_ALL)\n\noption(BUILD_TESTING \"Enable creation of Eigen tests.\" ON)\nif(BUILD_TESTING)\n  include(EigenConfigureTesting)\n\n  if(EIGEN_LEAVE_TEST_IN_ALL_TARGET)\n    add_subdirectory(test) # can't do EXCLUDE_FROM_ALL here, breaks CTest\n  else()\n    add_subdirectory(test EXCLUDE_FROM_ALL)\n  endif()\nendif()\n\nif(EIGEN_LEAVE_TEST_IN_ALL_TARGET)\n  add_subdirectory(blas)\n  add_subdirectory(lapack)\nelse()\n  add_subdirectory(blas EXCLUDE_FROM_ALL)\n  add_subdirectory(lapack EXCLUDE_FROM_ALL)\nendif()\n\n# add SYCL\noption(EIGEN_TEST_SYCL \"Add Sycl support.\" OFF)\nif(EIGEN_TEST_SYCL)\n  set (CMAKE_MODULE_PATH \"${CMAKE_ROOT}/Modules\" \"cmake/Modules/\" \"${CMAKE_MODULE_PATH}\")\n  include(FindComputeCpp)\nendif()\n\nadd_subdirectory(unsupported)\n\nadd_subdirectory(demos EXCLUDE_FROM_ALL)\n\n# must be after test and unsupported, for configuring buildtests.in\nadd_subdirectory(scripts EXCLUDE_FROM_ALL)\n\n# TODO: consider also replacing EIGEN_BUILD_BTL by a custom target \"make btl\"?\nif(EIGEN_BUILD_BTL)\n  add_subdirectory(bench/btl EXCLUDE_FROM_ALL)\nendif(EIGEN_BUILD_BTL)\n\nif(NOT WIN32)\n  add_subdirectory(bench/spbench EXCLUDE_FROM_ALL)\nendif(NOT WIN32)\n\nconfigure_file(scripts/cdashtesting.cmake.in cdashtesting.cmake @ONLY)\n\nif(BUILD_TESTING)\n  ei_testing_print_summary()\nendif()\n\nmessage(STATUS \"\")\nmessage(STATUS \"Configured Eigen ${EIGEN_VERSION_NUMBER}\")\nmessage(STATUS \"\")\n\noption(EIGEN_FAILTEST \"Enable failtests.\" OFF)\nif(EIGEN_FAILTEST)\n  add_subdirectory(failtest)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenBLAS Library for BTL Benchmarks in CMake\nDESCRIPTION: Finds the OpenBLAS package and configures the btl_openblas benchmark target if available. Links against OpenBLAS libraries and sets compile flags to specify OpenBLAS as the CBLAS implementation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/BLAS/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(OPENBLAS)\nif (OPENBLAS_FOUND)\n  btl_add_bench(btl_openblas main.cpp)\n  if(BUILD_btl_openblas)\n    target_link_libraries(btl_openblas ${OPENBLAS_LIBRARIES} )\n    set_target_properties(btl_openblas PROPERTIES COMPILE_FLAGS \"-DCBLASNAME=OPENBLAS\")\n  endif(BUILD_btl_openblas)\nendif (OPENBLAS_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen CMake Package for Modern CMake\nDESCRIPTION: This section creates an interface library for Eigen and sets up the necessary CMake configuration files for modern CMake usage (version 3.0 and above). It includes creating imported targets and version files.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\n# Interface libraries require at least CMake 3.0\nif (NOT CMAKE_VERSION VERSION_LESS 3.0)\n  include (CMakePackageConfigHelpers)\n\n  # Imported target support\n  add_library (eigen INTERFACE)\n\n  target_compile_definitions (eigen INTERFACE ${EIGEN_DEFINITIONS})\n  target_include_directories (eigen INTERFACE\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n    $<INSTALL_INTERFACE:${INCLUDE_INSTALL_DIR}>\n  )\n\n  # Export as title case Eigen\n  set_target_properties (eigen PROPERTIES EXPORT_NAME Eigen)\n\n  install (TARGETS eigen EXPORT Eigen3Targets)\n\n  configure_package_config_file (\n    ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Eigen3Config.cmake.in\n    ${CMAKE_CURRENT_BINARY_DIR}/Eigen3Config.cmake\n    PATH_VARS EIGEN_INCLUDE_DIR EIGEN_ROOT_DIR\n    INSTALL_DESTINATION ${CMAKEPACKAGE_INSTALL_DIR}\n    NO_CHECK_REQUIRED_COMPONENTS_MACRO # Eigen does not provide components\n  )\n  # Remove CMAKE_SIZEOF_VOID_P from Eigen3ConfigVersion.cmake since Eigen does\n  # not depend on architecture specific settings or libraries. More\n  # specifically, an Eigen3Config.cmake generated from a 64 bit target can be\n  # used for 32 bit targets as well (and vice versa).\n  set (_Eigen3_CMAKE_SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P})\n  unset (CMAKE_SIZEOF_VOID_P)\n  write_basic_package_version_file (Eigen3ConfigVersion.cmake\n                                    VERSION ${EIGEN_VERSION_NUMBER}\n                                    COMPATIBILITY SameMajorVersion)\n  set (CMAKE_SIZEOF_VOID_P ${_Eigen3_CMAKE_SIZEOF_VOID_P})\n\n  # The Eigen target will be located in the Eigen3 namespace. Other CMake\n  # targets can refer to it using Eigen3::Eigen.\n  export (TARGETS eigen NAMESPACE Eigen3:: FILE Eigen3Targets.cmake)\n  # Export Eigen3 package to CMake registry such that it can be easily found by\n  # CMake even if it has not been installed to a standard directory.\n  export (PACKAGE Eigen3)\n\n  install (EXPORT Eigen3Targets NAMESPACE Eigen3:: DESTINATION ${CMAKEPACKAGE_INSTALL_DIR})\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing Eigen3 pkg-config File\nDESCRIPTION: This code block configures the eigen3.pc file for pkg-config and installs it if the EIGEN_BUILD_PKGCONFIG option is enabled. It's used for system-wide configuration of Eigen.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nif(EIGEN_BUILD_PKGCONFIG)\n    configure_file(eigen3.pc.in eigen3.pc @ONLY)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/eigen3.pc\n        DESTINATION ${PKGCONFIG_INSTALL_DIR}\n        )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring cuBLAS Unittest Executables in CMake\nDESCRIPTION: Iterates through the list of cuBLAS unittests to configure each test executable. Sets up dependencies, include directories, CUDA architecture settings, and registers the tests with doctest.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/sandbox/cublas_unittests/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test IN LISTS TF_CUBLAS_UNITTESTS)\n  add_executable(${test} ${test}.cu)\n  target_link_libraries(${test}\n    ${PROJECT_NAME} Threads::Threads tf::default_settings ${CUBLAS_LIBRARIES}\n  )\n  target_include_directories(${test} PRIVATE ${CUBLAS_INCLUDE_DIRS})\n  target_include_directories(${test} PRIVATE ${TF_3RD_PARTY_DIR}/doctest)\n\n  # avoid cmake 3.18+ warning\n  # we let nvcc to decide the flag if the architecture is not given\n  if(NOT CUDA_ARCHITECTURES)\n    set_property(TARGET ${test} PROPERTY CUDA_ARCHITECTURES OFF)\n  endif()\n  \n  doctest_discover_tests(${test})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen Demos Build with CMake\nDESCRIPTION: This CMake script configures the build process for Eigen demos. It creates a custom target for demos and conditionally includes Qt-based demos if Qt4 is available. The script checks for Qt4 and adds subdirectories for mandelbrot and opengl demos if found.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/demos/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(EigenDemos)\n\nadd_custom_target(demos)\n\nif(NOT EIGEN_TEST_NOQT)\n  find_package(Qt4)\n  if(QT4_FOUND)\n    add_subdirectory(mandelbrot)\n    add_subdirectory(opengl)\n  else(QT4_FOUND)\n    message(STATUS \"Qt4 not found, so disabling the mandelbrot and opengl demos\")\n  endif(QT4_FOUND)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen BLAS/LAPACK for BTL Benchmarks in CMake\nDESCRIPTION: Configures the btl_eigenblas benchmark target when running within Eigen source directory and when a Fortran compiler is available. Links against Eigen's BLAS and LAPACK implementations and sets compile flags to specify EigenBLAS as the CBLAS implementation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/BLAS/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(Eigen_SOURCE_DIR AND CMAKE_Fortran_COMPILER_WORKS)\n  # we are inside Eigen and blas/lapack interface is compilable\n  include_directories(${Eigen_SOURCE_DIR})\n  btl_add_bench(btl_eigenblas main.cpp)\n  if(BUILD_btl_eigenblas)\n    target_link_libraries(btl_eigenblas eigen_blas eigen_lapack )\n    set_target_properties(btl_eigenblas PROPERTIES COMPILE_FLAGS \"-DCBLASNAME=EigenBLAS\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Source TBB Integration Example with CPF\nDESCRIPTION: Complete CMake example for building TBB from source with Community Preview Features and linking it to a sub_string_finder sample.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\nproject(sub_string_finder CXX)\nadd_executable(sub_string_finder sub_string_finder.cpp)\n\ninclude(${TBB_ROOT}/cmake/TBBBuild.cmake)\n\ntbb_build(TBB_ROOT ${TBB_ROOT} CONFIG_DIR TBB_DIR MAKE_ARGS tbb_cpf=1)\n\nfind_package(TBB REQUIRED tbb_preview)\n\ntarget_link_libraries(sub_string_finder ${TBB_IMPORTED_TARGETS})\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Qt4/OpenGL Quaternion Demo\nDESCRIPTION: CMake configuration script that checks for Qt4 and OpenGL dependencies, sets up include directories, configures source files with Qt4 automoc, and builds an executable. The script includes proper linking of Qt and OpenGL libraries and handles cases where dependencies are not found.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/demos/opengl/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Qt4)\nfind_package(OpenGL)\n\nif(QT4_FOUND AND OPENGL_FOUND)\n\n  set(QT_USE_QTOPENGL TRUE)\n  include(${QT_USE_FILE})\n\n  set(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n  include_directories( ${QT_INCLUDE_DIR} )\n\n  set(quaternion_demo_SRCS  gpuhelper.cpp icosphere.cpp camera.cpp trackball.cpp quaternion_demo.cpp)\n\n  qt4_automoc(${quaternion_demo_SRCS})\n\n  add_executable(quaternion_demo ${quaternion_demo_SRCS})\n  add_dependencies(demos quaternion_demo)\n\n  target_link_libraries(quaternion_demo\n    ${QT_QTCORE_LIBRARY}    ${QT_QTGUI_LIBRARY}\n    ${QT_QTOPENGL_LIBRARY}  ${OPENGL_LIBRARIES} )\n\nelse()\n\n  message(STATUS \"OpenGL demo disabled because Qt4 and/or OpenGL have not been found.\")\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen Signature File in CMake\nDESCRIPTION: This snippet installs the Eigen signature file to the specified include directory. It's part of the Eigen library installation process.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(FILES\n  signature_of_eigen3_matrix_library\n  DESTINATION ${INCLUDE_INSTALL_DIR} COMPONENT Devel\n  )\n```\n\n----------------------------------------\n\nTITLE: Configuring Intel MKL Library for BTL Benchmarks in CMake\nDESCRIPTION: Finds the Intel MKL package and configures the btl_mkl benchmark target if available. Links against MKL libraries and sets compile flags to specify MKL as the CBLAS implementation with LAPACK support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/BLAS/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(MKL)\nif (MKL_FOUND)\n  btl_add_bench(btl_mkl main.cpp)\n  if(BUILD_btl_mkl)\n    target_link_libraries(btl_mkl ${MKL_LIBRARIES})\n    set_target_properties(btl_mkl PROPERTIES COMPILE_FLAGS \"-DCBLASNAME=INTEL_MKL -DHAS_LAPACK=1\")\n  endif(BUILD_btl_mkl)\nendif (MKL_FOUND)\n```\n\n----------------------------------------\n\nTITLE: TBB Source Integration with TBBBuild\nDESCRIPTION: CMake code to build and integrate TBB from source files using TBBBuild module. Requires TBB source code and CMake modules.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(<path-to-tbb-cmake-modules>/TBBBuild.cmake)\ntbb_build(TBB_ROOT <tbb_root> CONFIG_DIR TBB_DIR)\nfind_package(TBB <options>)\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen Installation Paths in CMake\nDESCRIPTION: Sets up installation directories for Eigen headers, CMake package files, and pkg-config files. It includes backward compatibility support for EIGEN_INCLUDE_INSTALL_DIR.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nif(EIGEN_INCLUDE_INSTALL_DIR)\n  message(WARNING \"EIGEN_INCLUDE_INSTALL_DIR is deprecated. Use INCLUDE_INSTALL_DIR instead.\")\nendif()\n\nif(EIGEN_INCLUDE_INSTALL_DIR AND NOT INCLUDE_INSTALL_DIR)\n  set(INCLUDE_INSTALL_DIR ${EIGEN_INCLUDE_INSTALL_DIR}\n      CACHE PATH \"The directory relative to CMAKE_PREFIX_PATH where Eigen header files are installed\")\nelse()\n  set(INCLUDE_INSTALL_DIR\n      \"${CMAKE_INSTALL_INCLUDEDIR}/eigen3\"\n      CACHE PATH \"The directory relative to CMAKE_PREFIX_PATH where Eigen header files are installed\"\n      )\nendif()\nset(CMAKEPACKAGE_INSTALL_DIR\n    \"${CMAKE_INSTALL_DATADIR}/eigen3/cmake\"\n    CACHE PATH \"The directory relative to CMAKE_PREFIX_PATH where Eigen3Config.cmake is installed\"\n    )\nset(PKGCONFIG_INSTALL_DIR\n    \"${CMAKE_INSTALL_DATADIR}/pkgconfig\"\n    CACHE PATH \"The directory relative to CMAKE_PREFIX_PATH where eigen3.pc is installed\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt4 Mandelbrot Demo Build in CMake\nDESCRIPTION: Complete CMake configuration for building a Qt4-based Mandelbrot visualization program. Sets up compiler optimization flags, includes Qt dependencies, configures source files, and links required Qt libraries. Includes automatic MOC (Meta-Object Compiler) processing for Qt classes.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/demos/mandelbrot/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Qt4 REQUIRED)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\nif (CMAKE_COMPILER_IS_GNUCXX)\n   set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O2\")\n   add_definitions ( \"-DNDEBUG\" )\nendif (CMAKE_COMPILER_IS_GNUCXX)\n\ninclude_directories( ${QT_INCLUDE_DIR} )\n\nset(mandelbrot_SRCS\n    mandelbrot.cpp\n)\n\nqt4_automoc(${mandelbrot_SRCS})\n\nadd_executable(mandelbrot ${mandelbrot_SRCS})\nadd_dependencies(demos mandelbrot)\n\ntarget_link_libraries(mandelbrot ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY})\n```\n\n----------------------------------------\n\nTITLE: Building C++11 Random Number Example\nDESCRIPTION: Configures a C++11-specific example that demonstrates random number functionality. Only builds if the compiler supports C++11, sets the appropriate compiler flag, and adds a post-build command to capture the output to a file.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/special_examples/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(EIGEN_COMPILER_SUPPORT_CPP11)\n  add_executable(random_cpp11 random_cpp11.cpp)\n  target_link_libraries(random_cpp11 ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  add_dependencies(all_examples random_cpp11)\n  ei_add_target_property(random_cpp11 COMPILE_FLAGS \"-std=c++11\")\n\n  add_custom_command(\n    TARGET random_cpp11\n    POST_BUILD\n    COMMAND random_cpp11\n    ARGS >${CMAKE_CURRENT_BINARY_DIR}/random_cpp11.out\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding LAPACK Complex16 Tests in CMake\nDESCRIPTION: This section adds various complex16 precision LAPACK tests using the add_lapack_test macro. It includes tests for linear equations, eigenvalue problems, and other operations for complex numbers with double precision.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif (BUILD_COMPLEX16)\nadd_lapack_test(ztest.out ztest.in xlintstz)\nadd_lapack_test(ztest_rfp.out ztest_rfp.in xlintstrfz)\nadd_lapack_test(znep.out nep.in xeigtstz)\nadd_lapack_test(zsep.out sep.in xeigtstz)\nadd_lapack_test(zsvd.out svd.in xeigtstz)\nadd_lapack_test(zec.out zec.in xeigtstz)\nadd_lapack_test(zed.out zed.in xeigtstz)\nadd_lapack_test(zgg.out zgg.in xeigtstz)\nadd_lapack_test(zgd.out zgd.in xeigtstz)\nadd_lapack_test(zsb.out zsb.in xeigtstz)\nadd_lapack_test(zsg.out zsg.in xeigtstz)\nadd_lapack_test(zbal.out zbal.in xeigtstz)\nadd_lapack_test(zbak.out zbak.in xeigtstz)\nadd_lapack_test(zgbal.out zgbal.in xeigtstz)\nadd_lapack_test(zgbak.out zgbak.in xeigtstz)\nadd_lapack_test(zbb.out zbb.in xeigtstz)\nadd_lapack_test(zglm.out glm.in xeigtstz)\nadd_lapack_test(zgqr.out gqr.in xeigtstz)\nadd_lapack_test(zgsv.out gsv.in xeigtstz)\nadd_lapack_test(zcsd.out csd.in xeigtstz)\nadd_lapack_test(zlse.out lse.in xeigtstz)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing TBB Config with tbb_install_config Function\nDESCRIPTION: Function for generating and installing TBB CMake configuration files. Takes parameters for install directory, system name, version details, and path configurations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntbb_install_config(INSTALL_DIR <install_dir> SYSTEM_NAME Linux|Darwin|Windows\n                     [TBB_VERSION <major>.<minor>|TBB_VERSION_FILE <version_file>]\n                     [LIB_REL_PATH <lib_rel_path> INC_REL_PATH <inc_rel_path>]\n                     [LIB_PATH <lib_path> INC_PATH <inc_path>])\n```\n\n----------------------------------------\n\nTITLE: Project Status Display in CMake\nDESCRIPTION: Displays various CMake configuration variables and project settings using message commands for debugging and verification purposes.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(STATUS \"PROJECT_NAME: \" ${PROJECT_NAME})\nmessage(STATUS \"CMAKE_HOST_SYSTEM: ${CMAKE_HOST_SYSTEM}\")\nmessage(STATUS \"CMAKE_BUILD_TYPE: \" ${CMAKE_BUILD_TYPE})\n# ... additional status messages\n```\n\n----------------------------------------\n\nTITLE: Building Sparse Matrix Tutorial Example with Qt4\nDESCRIPTION: Creates and configures the Tutorial_sparse_example executable if Qt4 is available. Links against required Qt libraries and adds a post-build command to generate JPEG output in the HTML documentation directory.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/special_examples/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(QT4_FOUND)\n  add_executable(Tutorial_sparse_example Tutorial_sparse_example.cpp Tutorial_sparse_example_details.cpp)\n  target_link_libraries(Tutorial_sparse_example ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO} ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY})\n\n  add_custom_command(\n    TARGET Tutorial_sparse_example\n    POST_BUILD\n    COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/../html/\n    COMMAND Tutorial_sparse_example ARGS ${CMAKE_CURRENT_BINARY_DIR}/../html/Tutorial_sparse_example.jpeg\n  )\n\n  add_dependencies(all_examples Tutorial_sparse_example)\nendif(QT4_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Configuring Blitz Library and Benchmarks in CMake\nDESCRIPTION: This CMake script finds the Blitz package, sets up include directories, and creates benchmark targets. It conditionally compiles the benchmarks based on the presence of Blitz and specific build flags. The script also links the Blitz libraries to the benchmark targets.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/blitz/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Blitz)\n\nif (BLITZ_FOUND)\n  include_directories(${BLITZ_INCLUDES})\n\n  btl_add_bench(btl_blitz btl_blitz.cpp)\n  if (BUILD_btl_blitz)\n    target_link_libraries(btl_blitz ${BLITZ_LIBRARIES})\n  endif (BUILD_btl_blitz)\n\n  btl_add_bench(btl_tiny_blitz btl_tiny_blitz.cpp OFF)\n  if (BUILD_btl_tiny_blitz)\n    target_link_libraries(btl_tiny_blitz ${BLITZ_LIBRARIES})\n  endif (BUILD_btl_tiny_blitz)\n\nendif (BLITZ_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Adding Final Documentation Dependencies\nDESCRIPTION: Establishes the final dependencies for the main documentation target, ensuring prerequisites are built first.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(doc doc-eigen-prerequisites doc-unsupported-prerequisites)\n```\n\n----------------------------------------\n\nTITLE: Defining EigenBlas Source Files\nDESCRIPTION: Specifies the source files for the EigenBlas library, including C++ implementations and F2C converted Fortran routines. Conditionally includes either Fortran or C implementation of complex dot products based on compiler availability.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(EigenBlas_SRCS  single.cpp double.cpp complex_single.cpp complex_double.cpp xerbla.cpp\n                    f2c/srotm.c   f2c/srotmg.c  f2c/drotm.c f2c/drotmg.c\n                    f2c/lsame.c   f2c/dspmv.c   f2c/ssbmv.c f2c/chbmv.c\n                    f2c/sspmv.c   f2c/zhbmv.c   f2c/chpmv.c f2c/dsbmv.c\n                    f2c/zhpmv.c   f2c/dtbmv.c   f2c/stbmv.c f2c/ctbmv.c\n                    f2c/ztbmv.c   f2c/d_cnjg.c  f2c/r_cnjg.c\n   )\n\nif (EIGEN_Fortran_COMPILER_WORKS)\n  set(EigenBlas_SRCS ${EigenBlas_SRCS} fortran/complexdots.f)\nelse()\n  set(EigenBlas_SRCS ${EigenBlas_SRCS} f2c/complexdots.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CPU Instruction Set Options in CMake for Eigen\nDESCRIPTION: Sets up CMake options to enable or disable various CPU instruction sets (SSE, AVX, NEON, etc.) for Eigen library tests and examples. It modifies the CXX_FLAGS based on the selected options.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\noption(EIGEN_TEST_SSE2 \"Enable/Disable SSE2 in tests/examples\" OFF)\nif(EIGEN_TEST_SSE2)\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -msse2\")\n  message(STATUS \"Enabling SSE2 in tests/examples\")\nendif()\n\n# Similar blocks for SSE3, SSSE3, SSE4.1, SSE4.2, AVX, FMA, AVX512, F16C, AltiVec, VSX, NEON, NEON64, ZVECTOR\n\noption(EIGEN_TEST_OPENMP \"Enable/Disable OpenMP in tests/examples\" OFF)\nif(EIGEN_TEST_OPENMP)\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fopenmp\")\n  message(STATUS \"Enabling OpenMP in tests/examples\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Automated Compilation of TaskFlow Snippets in CMake\nDESCRIPTION: This CMake script collects all C++ files in the current directory and sets up compilation targets for each one. It creates a custom target 'all_snippets' that depends on all individual snippet compilation targets, allowing for batch compilation and testing of code examples.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/snippets/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB snippets_SRCS \"*.cpp\")\n\nadd_custom_target(all_snippets)\n\nforeach(snippet_src ${snippets_SRCS})\n  get_filename_component(snippet ${snippet_src} NAME_WE)\n  set(compile_snippet_target compile_${snippet})\n  set(compile_snippet_src ${compile_snippet_target}.cpp)\n  file(READ ${snippet_src} snippet_source_code)\n  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/compile_snippet.cpp.in\n                 ${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src})\n  add_executable(${compile_snippet_target}\n                 ${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src})\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    target_link_libraries(${compile_snippet_target} ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  endif()\n  add_custom_command(\n    TARGET ${compile_snippet_target}\n    POST_BUILD\n    COMMAND ${compile_snippet_target}\n    ARGS >${CMAKE_CURRENT_BINARY_DIR}/${snippet}.out\n  )\n  add_dependencies(all_snippets ${compile_snippet_target})\n  set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src}\n                              PROPERTIES OBJECT_DEPENDS ${snippet_src})\nendforeach(snippet_src)\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen2 Benchmarks in CMake\nDESCRIPTION: This snippet sets up benchmarks for Eigen2 library operations. It includes the Eigen2 directory, adds benchmark targets for various operations, and sets compile flags for each target. The benchmarks are only added if Eigen2 is found on the system.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/eigen2/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Eigen2)\n\nif(EIGEN2_FOUND)\n\n  include_directories(BEFORE ${EIGEN2_INCLUDE_DIR})\n  btl_add_bench(btl_eigen2_linear main_linear.cpp)\n  btl_add_bench(btl_eigen2_vecmat main_vecmat.cpp)\n  btl_add_bench(btl_eigen2_matmat main_matmat.cpp)\n  btl_add_bench(btl_eigen2_adv main_adv.cpp      )\n\n  btl_add_target_property(btl_eigen2_linear COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen2\")\n  btl_add_target_property(btl_eigen2_vecmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen2\")\n  btl_add_target_property(btl_eigen2_matmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen2\")\n  btl_add_target_property(btl_eigen2_adv    COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen2\")\n\n  btl_add_bench(btl_tiny_eigen2 btl_tiny_eigen2.cpp OFF)\n\nendif() # EIGEN2_FOUND\n```\n\n----------------------------------------\n\nTITLE: Creating Prerequisites Target for Unsupported Documentation\nDESCRIPTION: Defines a custom target that prepares the directory structure and copies necessary files for the unsupported modules documentation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  doc-unsupported-prerequisites\n  ALL\n  COMMAND ${CMAKE_COMMAND} -E make_directory ${Eigen_BINARY_DIR}/doc/html/unsupported\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/eigen_navtree_hacks.js           ${CMAKE_CURRENT_BINARY_DIR}/html/unsupported/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/Eigen_Silly_Professor_64x64.png  ${CMAKE_CURRENT_BINARY_DIR}/html/unsupported/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ftv2pnode.png                    ${CMAKE_CURRENT_BINARY_DIR}/html/unsupported/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ftv2node.png                     ${CMAKE_CURRENT_BINARY_DIR}/html/unsupported/\n  WORKING_DIRECTORY ${Eigen_BINARY_DIR}/doc\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Installing EigenBlas Libraries\nDESCRIPTION: Creates static and shared library targets for EigenBlas, configures linking with standard libraries, and sets up installation paths for binaries and libraries.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(eigen_blas_static ${EigenBlas_SRCS})\nadd_library(eigen_blas SHARED ${EigenBlas_SRCS})\n\nif(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n  target_link_libraries(eigen_blas_static ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  target_link_libraries(eigen_blas        ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\nendif()\n\nadd_dependencies(blas eigen_blas eigen_blas_static)\n\ninstall(TARGETS eigen_blas eigen_blas_static\n        RUNTIME DESTINATION bin\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n```\n\n----------------------------------------\n\nTITLE: Configuring ATLAS Library for BTL Benchmarks in CMake\nDESCRIPTION: Finds the ATLAS library package and configures the btl_atlas benchmark target if the library is available. Links against ATLAS libraries and sets compile flags to specify ATLAS as the CBLAS implementation with LAPACK support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/BLAS/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(ATLAS)\nif (ATLAS_FOUND)\n  btl_add_bench(btl_atlas main.cpp)\n  if(BUILD_btl_atlas)\n    target_link_libraries(btl_atlas ${ATLAS_LIBRARIES})\n    set_target_properties(btl_atlas PROPERTIES COMPILE_FLAGS \"-DCBLASNAME=ATLAS -DHAS_LAPACK=1\")\n  endif(BUILD_btl_atlas)\nendif (ATLAS_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Configuring TaskFlow Profiler CMake Build\nDESCRIPTION: Creates and configures the tfprof executable by setting up the build target, linking required libraries including TaskFlow, atomic library and default settings, and configuring include directories for third-party dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/tfprof/server/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(tfprof tfprof.cpp)\n\ntarget_link_libraries(\n  tfprof ${PROJECT_NAME} ${ATOMIC_LIBRARY} tf::default_settings\n)\n\ntarget_include_directories(tfprof PRIVATE ${TF_3RD_PARTY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Examples and Snippets Targets\nDESCRIPTION: Initializes variables for tracking examples and snippets targets, defines the EIGEN_MAKING_DOCS flag, and creates a custom target for all examples.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(examples_targets \"\")\nset(snippets_targets \"\")\n\nadd_definitions(\"-DEIGEN_MAKING_DOCS\")\nadd_custom_target(all_examples)\n\nadd_subdirectory(examples)\nadd_subdirectory(special_examples)\nadd_subdirectory(snippets)\n```\n\n----------------------------------------\n\nTITLE: Configuring EigenBlas Tests\nDESCRIPTION: Sets up test configuration when Fortran compiler is available and testing is enabled. Allows control over whether tests are included in the main build target.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(EIGEN_Fortran_COMPILER_WORKS)\n\nif(BUILD_TESTING)\n  if(EIGEN_LEAVE_TEST_IN_ALL_TARGET)\n    add_subdirectory(testing) # can't do EXCLUDE_FROM_ALL here, breaks CTest\n  else()\n    add_subdirectory(testing EXCLUDE_FROM_ALL)\n  endif()\nendif()\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Fast Math Flags in CMake\nDESCRIPTION: Detects and configures fast math compiler flags for use in Eigen tests.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ncheck_cxx_compiler_flag(\"-ffast-math\" COMPILER_SUPPORT_FASTMATH)\nif(COMPILER_SUPPORT_FASTMATH)\n  set(EIGEN_FASTMATH_FLAGS \"-ffast-math\")\nelse()\n  check_cxx_compiler_flag(\"/fp:fast\" COMPILER_SUPPORT_FPFAST)\n  if(COMPILER_SUPPORT_FPFAST)\n    set(EIGEN_FASTMATH_FLAGS \"/fp:fast\")\n  endif()\nendif()\n\nei_add_test(fastmath \" ${EIGEN_FASTMATH_FLAGS} \")\n```\n\n----------------------------------------\n\nTITLE: Adding LAPACK Double Precision Tests in CMake\nDESCRIPTION: This section adds various double precision LAPACK tests using the add_lapack_test macro. It includes tests for linear equations, eigenvalue problems, and other operations, similar to the single precision tests.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif (BUILD_DOUBLE)\nadd_lapack_test(dtest.out dtest.in xlintstd)\nadd_lapack_test(dtest_rfp.out dtest_rfp.in xlintstrfd)\nadd_lapack_test(dnep.out nep.in xeigtstd)\nadd_lapack_test(dsep.out sep.in xeigtstd)\nadd_lapack_test(dsvd.out svd.in xeigtstd)\nadd_lapack_test(dec.out dec.in xeigtstd)\nadd_lapack_test(ded.out ded.in xeigtstd)\nadd_lapack_test(dgg.out dgg.in xeigtstd)\nadd_lapack_test(dgd.out dgd.in xeigtstd)\nadd_lapack_test(dsb.out dsb.in xeigtstd)\nadd_lapack_test(dsg.out dsg.in xeigtstd)\nadd_lapack_test(dbal.out dbal.in xeigtstd)\nadd_lapack_test(dbak.out dbak.in xeigtstd)\nadd_lapack_test(dgbal.out dgbal.in xeigtstd)\nadd_lapack_test(dgbak.out dgbak.in xeigtstd)\nadd_lapack_test(dbb.out dbb.in xeigtstd)\nadd_lapack_test(dglm.out glm.in xeigtstd)\nadd_lapack_test(dgqr.out gqr.in xeigtstd)\nadd_lapack_test(dgsv.out gsv.in xeigtstd)\nadd_lapack_test(dcsd.out csd.in xeigtstd)\nadd_lapack_test(dlse.out lse.in xeigtstd)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring ACML Library for BTL Benchmarks in CMake\nDESCRIPTION: Finds the AMD Core Math Library (ACML) package and configures the btl_acml benchmark target if available. Links against ACML libraries and sets compile flags to specify ACML as the CBLAS implementation with LAPACK support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/BLAS/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(ACML)\nif (ACML_FOUND)\n  btl_add_bench(btl_acml main.cpp)\n  if(BUILD_btl_acml)\n    target_link_libraries(btl_acml ${ACML_LIBRARIES} )\n    set_target_properties(btl_acml PROPERTIES COMPILE_FLAGS \"-DCBLASNAME=ACML -DHAS_LAPACK=1\")\n  endif(BUILD_btl_acml)\nendif (ACML_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional Tests and Documentation in CMake for Eigen\nDESCRIPTION: This snippet sets up additional tests including a fail test and an option for testing documentation building. It creates a directory for fail tests and adds a test command. It also provides an option to test building the doxygen documentation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nfile(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/failtests)    \nadd_test(NAME failtests WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/failtests COMMAND ${CMAKE_COMMAND} ${Eigen_SOURCE_DIR} -G \"${CMAKE_GENERATOR}\" -DEIGEN_FAILTEST=ON)\n\noption(EIGEN_TEST_BUILD_DOCUMENTATION \"Test building the doxygen documentation\" OFF)\nIF(EIGEN_TEST_BUILD_DOCUMENTATION)\n  add_dependencies(buildtests doc)\nENDIF()\n```\n\n----------------------------------------\n\nTITLE: Configuring BLAS and LAPACK Libraries in CMake\nDESCRIPTION: Sets up BLAS and LAPACK library configurations for Eigen, using Eigen's own implementations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(EIGEN_BLAS_LIBRARIES eigen_blas)\nset(EIGEN_LAPACK_LIBRARIES eigen_lapack)\n```\n\n----------------------------------------\n\nTITLE: BTL Benchmark Addition Macro\nDESCRIPTION: Defines a macro for adding benchmark targets with configurable build options and test execution\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nMACRO(BTL_ADD_BENCH targetname)\n\n  foreach(_current_var ${ARGN})\n    set(_last_var ${_current_var})\n  endforeach(_current_var)\n\n  set(_sources ${ARGN})\n  list(LENGTH _sources _argn_length)\n\n  list(REMOVE_ITEM _sources ON OFF TRUE FALSE)\n\n  list(LENGTH _sources _src_length)\n\n  if (${_argn_length} EQUAL ${_src_length})\n    set(_last_var ON)\n  endif (${_argn_length} EQUAL ${_src_length})\n\n  OPTION(BUILD_${targetname} \"Build benchmark ${targetname}\" ${_last_var})\n\n  IF(BUILD_${targetname})\n    ADD_EXECUTABLE(${targetname} ${_sources})\n    ADD_TEST(${targetname} \"${targetname}\")\n    target_link_libraries(${targetname} ${DEFAULT_LIBRARIES} ${EIGEN_BTL_RT_LIBRARY})\n  ENDIF(BUILD_${targetname})\n\nENDMACRO(BTL_ADD_BENCH)\n```\n\n----------------------------------------\n\nTITLE: Executable Targets Configuration\nDESCRIPTION: Defines and links executable targets for sparse matrix operations using configured libraries.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/spbench/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(spbenchsolver spbenchsolver.cpp)\ntarget_link_libraries (spbenchsolver ${SPARSE_LIBS})\n\nadd_executable(spsolver sp_solver.cpp)\ntarget_link_libraries (spsolver ${SPARSE_LIBS})\n\nadd_executable(test_sparseLU test_sparseLU.cpp)\ntarget_link_libraries (test_sparseLU ${SPARSE_LIBS})\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt Support for Eigen Tests in CMake\nDESCRIPTION: Detects and configures Qt4 support for Eigen tests if not explicitly disabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\noption(EIGEN_TEST_NOQT \"Disable Qt support in unit tests\" OFF)\nif(NOT EIGEN_TEST_NOQT)\n  find_package(Qt4)\n  if(QT4_FOUND)\n    include(${QT_USE_FILE})\n    ei_add_property(EIGEN_TESTED_BACKENDS  \"Qt4 support, \")\n  else()\n    ei_add_property(EIGEN_MISSING_BACKENDS  \"Qt4 support, \")\n  endif()\nendif(NOT EIGEN_TEST_NOQT)\n```\n\n----------------------------------------\n\nTITLE: Adding Eigen Test Targets in CMake\nDESCRIPTION: Defines numerous test targets for various Eigen components and features using the ei_add_test macro.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nei_add_test(rand)\nei_add_test(meta)\nei_add_test(numext)\nei_add_test(sizeof)\nei_add_test(dynalloc)\nei_add_test(nomalloc)\nei_add_test(first_aligned)\nei_add_test(nullary)\nei_add_test(mixingtypes)\nei_add_test(packetmath \"-DEIGEN_FAST_MATH=1\")\n# ... many more test targets\n```\n\n----------------------------------------\n\nTITLE: Configuring Sparse Matrix Testing in CMake\nDESCRIPTION: Sets up testing for real-world sparse matrices if a directory is specified. Adds necessary definitions and includes for Windows compatibility.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(EIGEN_TEST_MATRIX_DIR \"\" CACHE STRING \"Enable testing of realword sparse matrices contained in the specified path\")\nif(EIGEN_TEST_MATRIX_DIR)\n  if(NOT WIN32)\n    message(STATUS \"Test realworld sparse matrices: ${EIGEN_TEST_MATRIX_DIR}\")\n    add_definitions( -DTEST_REAL_CASES=\"${EIGEN_TEST_MATRIX_DIR}\" )\n  else(NOT WIN32)\n    message(STATUS \"REAL CASES CAN NOT BE CURRENTLY TESTED ON WIN32\")\n  endif(NOT WIN32)\nendif(EIGEN_TEST_MATRIX_DIR)\n```\n\n----------------------------------------\n\nTITLE: Configuring Tiny Eigen3 Benchmarks\nDESCRIPTION: Creates benchmarks for tiny Eigen3 operations, including a non-vectorized version when BTL_NOVEC is not set.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/eigen3/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nbtl_add_bench(btl_tiny_eigen3 btl_tiny_eigen3.cpp OFF)\n\nif(NOT BTL_NOVEC)\n  btl_add_bench(btl_tiny_eigen3_novec btl_tiny_eigen3.cpp OFF)\n  btl_add_target_property(btl_tiny_eigen3_novec    COMPILE_FLAGS \"-DBTL_PREFIX=eigen3_tiny\")\n\n  if(BUILD_btl_tiny_eigen3_novec)\n    btl_add_target_property(btl_tiny_eigen3_novec    COMPILE_FLAGS \"-DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=eigen3_tiny_novec\")\n  endif(BUILD_btl_tiny_eigen3_novec)\nendif(NOT BTL_NOVEC)\n```\n\n----------------------------------------\n\nTITLE: Generating Split Test Helper Header\nDESCRIPTION: Creates a helper header file that defines test macros for different test parts. The file is only generated if it doesn't exist to prevent unnecessary rebuilds.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/test/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h)\n  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h \"\")\n  foreach(i RANGE 1 999)\n    file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/split_test_helper.h\n      \"#ifdef EIGEN_TEST_PART_${i}\\n\"\n      \"#define CALL_SUBTEST_${i}(FUNC) CALL_SUBTEST(FUNC)\\n\"\n      \"#else\\n\"\n      \"#define CALL_SUBTEST_${i}(FUNC)\\n\"\n      \"#endif\\n\\n\"\n    )\n  endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding BLAS Tests for Different Precision Types\nDESCRIPTION: Using the custom ei_add_blas_test macro to add various BLAS test cases. The tests cover single precision (s), double precision (d), complex (c), and double complex (z) data types, with three test levels for each type.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/testing/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nei_add_blas_test(sblat1)\nei_add_blas_test(sblat2)\nei_add_blas_test(sblat3)\n\nei_add_blas_test(dblat1)\nei_add_blas_test(dblat2)\nei_add_blas_test(dblat3)\n\nei_add_blas_test(cblat1)\nei_add_blas_test(cblat2)\nei_add_blas_test(cblat3)\n\nei_add_blas_test(zblat1)\nei_add_blas_test(zblat2)\nei_add_blas_test(zblat3)\n\n# add_custom_target(level1)\n# add_dependencies(level1 sblat1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Library-Dependent Tests in CMake for Eigen\nDESCRIPTION: This snippet sets up conditional tests for Eigen based on the presence of various libraries such as Qt, UMFPACK, SuperLU, CHOLMOD, PARDISO, PaStiX, SPQR, and METIS. Each test is added only if the corresponding library is found.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(QT4_FOUND)\n  ei_add_test(qtvector \"\" \"${QT_QTCORE_LIBRARY}\")\nendif(QT4_FOUND)\n\nif(UMFPACK_FOUND)\n  ei_add_test(umfpack_support \"\" \"${UMFPACK_ALL_LIBS}\")\nendif()\n\nif(SUPERLU_FOUND)\n  ei_add_test(superlu_support \"\" \"${SUPERLU_ALL_LIBS}\")\nendif()\n\nif(CHOLMOD_FOUND)\n  ei_add_test(cholmod_support \"\" \"${CHOLMOD_ALL_LIBS}\")\nendif()\n\nif(PARDISO_FOUND)\n  ei_add_test(pardiso_support \"\" \"${PARDISO_ALL_LIBS}\")\nendif()\n\nif(PASTIX_FOUND AND (SCOTCH_FOUND OR METIS_FOUND))\n  ei_add_test(pastix_support \"\" \"${PASTIX_ALL_LIBS}\")\nendif()\n\nif(SPQR_FOUND AND CHOLMOD_FOUND)\n  ei_add_test(spqr_support \"\" \"${SPQR_ALL_LIBS}\")\nendif()\n\nif(METIS_FOUND)\nei_add_test(metis_support \"\" \"${METIS_LIBRARIES}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Sparse Library Dependencies in CMake\nDESCRIPTION: Detects and configures various sparse matrix libraries (Cholmod, Umfpack, SuperLU, PASTIX, METIS, SPQR) for use with Eigen tests.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/test/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(SPARSE_LIBS \" \")\n\nfind_package(Cholmod)\nif(CHOLMOD_FOUND)\n  add_definitions(\"-DEIGEN_CHOLMOD_SUPPORT\")\n  include_directories(${CHOLMOD_INCLUDES})\n  set(SPARSE_LIBS ${SPARSE_LIBS} ${CHOLMOD_LIBRARIES} ${EIGEN_BLAS_LIBRARIES} ${EIGEN_LAPACK_LIBRARIES})\n  set(CHOLMOD_ALL_LIBS  ${CHOLMOD_LIBRARIES} ${EIGEN_BLAS_LIBRARIES} ${EIGEN_LAPACK_LIBRARIES})\n  ei_add_property(EIGEN_TESTED_BACKENDS \"Cholmod, \")\nelse()\n  ei_add_property(EIGEN_MISSING_BACKENDS \"Cholmod, \")\nendif()\n\n# Similar blocks for Umfpack, SuperLU, PASTIX, METIS, and SPQR\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Flags for GCC/ICPC\nDESCRIPTION: Sets optimization flags for GCC and Intel C++ compilers, including options for vectorization control\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nIF(CMAKE_COMPILER_IS_GNUCXX OR IS_ICPC)\n  SET(CMAKE_CXX_FLAGS \"-g0 -O3 -DNDEBUG ${CMAKE_CXX_FLAGS}\")\n  SET(CMAKE_Fortran_FLAGS \"-g0 -O3 -DNDEBUG ${CMAKE_Fortran_FLAGS}\")\n  IF(BTL_NOVEC)\n    SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DEIGEN_DONT_VECTORIZE\")\n  ENDIF(BTL_NOVEC)\nENDIF(CMAKE_COMPILER_IS_GNUCXX OR IS_ICPC)\n```\n\n----------------------------------------\n\nTITLE: Configuring Boost Dependencies for BTL Benchmark in CMake\nDESCRIPTION: This CMake script searches for the Boost library and sets up the build environment for a BTL benchmark when Boost is available. It adds the Boost include directories to the include path and creates a benchmark target using btl_add_bench.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/ublas/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Boost)\nif (Boost_FOUND)\n  include_directories(${Boost_INCLUDE_DIRS})\n  include_directories(${Boost_INCLUDES})\n  btl_add_bench(btl_ublas main.cpp)\nendif (Boost_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Setting Eigen C++11 Headers in CMake\nDESCRIPTION: Defines a variable containing the list of C++11 header files for Eigen that need to be installed.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(Eigen_CXX11_HEADERS Tensor TensorSymmetry ThreadPool)\n```\n\n----------------------------------------\n\nTITLE: Configuring Matrix Operation Failtests in CMake\nDESCRIPTION: Sets up a comprehensive suite of compilation failure tests using CMake to verify compile-time constraints. The tests cover matrix operations, transformations, and numerical solvers with checks for const-correctness and type safety. Includes a final status check that reports test results and provides debugging instructions if failures occur.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/failtest/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(STATUS \"Running the failtests\")\n\nei_add_failtest(\"failtest_sanity_check\")\n\nei_add_failtest(\"block_nonconst_ctor_on_const_xpr_0\")\nei_add_failtest(\"block_nonconst_ctor_on_const_xpr_1\")\nei_add_failtest(\"block_nonconst_ctor_on_const_xpr_2\")\nei_add_failtest(\"transpose_nonconst_ctor_on_const_xpr\")\nei_add_failtest(\"diagonal_nonconst_ctor_on_const_xpr\")\nei_add_failtest(\"cwiseunaryview_nonconst_ctor_on_const_xpr\")\nei_add_failtest(\"triangularview_nonconst_ctor_on_const_xpr\")\nei_add_failtest(\"selfadjointview_nonconst_ctor_on_const_xpr\")\n\nei_add_failtest(\"const_qualified_block_method_retval_0\")\nei_add_failtest(\"const_qualified_block_method_retval_1\")\nei_add_failtest(\"const_qualified_transpose_method_retval\")\nei_add_failtest(\"const_qualified_diagonal_method_retval\")\n\nei_add_failtest(\"map_nonconst_ctor_on_const_ptr_0\")\nei_add_failtest(\"map_nonconst_ctor_on_const_ptr_1\")\nei_add_failtest(\"map_nonconst_ctor_on_const_ptr_2\")\nei_add_failtest(\"map_nonconst_ctor_on_const_ptr_3\")\nei_add_failtest(\"map_nonconst_ctor_on_const_ptr_4\")\n\nei_add_failtest(\"map_on_const_type_actually_const_0\")\nei_add_failtest(\"map_on_const_type_actually_const_1\")\nei_add_failtest(\"block_on_const_type_actually_const_0\")\nei_add_failtest(\"block_on_const_type_actually_const_1\")\nei_add_failtest(\"transpose_on_const_type_actually_const\")\nei_add_failtest(\"diagonal_on_const_type_actually_const\")\nei_add_failtest(\"cwiseunaryview_on_const_type_actually_const\")\nei_add_failtest(\"triangularview_on_const_type_actually_const\")\nei_add_failtest(\"selfadjointview_on_const_type_actually_const\")\n\nei_add_failtest(\"ref_1\")\nei_add_failtest(\"ref_2\")\nei_add_failtest(\"ref_3\")\nei_add_failtest(\"ref_4\")\nei_add_failtest(\"ref_5\")\n\nei_add_failtest(\"swap_1\")\nei_add_failtest(\"swap_2\")\n\nei_add_failtest(\"ternary_1\")\nei_add_failtest(\"ternary_2\")\n\nei_add_failtest(\"sparse_ref_1\")\nei_add_failtest(\"sparse_ref_2\")\nei_add_failtest(\"sparse_ref_3\")\nei_add_failtest(\"sparse_ref_4\")\nei_add_failtest(\"sparse_ref_5\")\n\nei_add_failtest(\"sparse_storage_mismatch\")\n\nei_add_failtest(\"partialpivlu_int\")\nei_add_failtest(\"fullpivlu_int\")\nei_add_failtest(\"llt_int\")\nei_add_failtest(\"ldlt_int\")\nei_add_failtest(\"qr_int\")\nei_add_failtest(\"colpivqr_int\")\nei_add_failtest(\"fullpivqr_int\")\nei_add_failtest(\"jacobisvd_int\")\nei_add_failtest(\"bdcsvd_int\")\nei_add_failtest(\"eigensolver_int\")\nei_add_failtest(\"eigensolver_cplx\")\n\nif (EIGEN_FAILTEST_FAILURE_COUNT)\n  message(FATAL_ERROR\n          \"${EIGEN_FAILTEST_FAILURE_COUNT} out of ${EIGEN_FAILTEST_COUNT} failtests FAILED. \"\n          \"To debug these failures, manually compile these programs in ${CMAKE_CURRENT_SOURCE_DIR}, \"\n          \"with and without #define EIGEN_SHOULD_FAIL_TO_BUILD.\")\nelse()\n  message(STATUS \"Failtest SUCCESS: all ${EIGEN_FAILTEST_COUNT} failtests passed.\")\n  message(STATUS \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding LAPACK Complex Tests in CMake\nDESCRIPTION: This section adds various complex precision LAPACK tests using the add_lapack_test macro. It includes tests for linear equations, eigenvalue problems, and other operations for complex numbers.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (BUILD_COMPLEX)\nadd_lapack_test(ctest.out ctest.in xlintstc)\nadd_lapack_test(ctest_rfp.out ctest_rfp.in xlintstrfc)\nadd_lapack_test(cnep.out nep.in xeigtstc)\nadd_lapack_test(csep.out sep.in xeigtstc)\nadd_lapack_test(csvd.out svd.in xeigtstc)\nadd_lapack_test(cec.out cec.in xeigtstc)\nadd_lapack_test(ced.out ced.in xeigtstc)\nadd_lapack_test(cgg.out cgg.in xeigtstc)\nadd_lapack_test(cgd.out cgd.in xeigtstc)\nadd_lapack_test(csb.out csb.in xeigtstc)\nadd_lapack_test(csg.out csg.in xeigtstc)\nadd_lapack_test(cbal.out cbal.in xeigtstc)\nadd_lapack_test(cbak.out cbak.in xeigtstc)\nadd_lapack_test(cgbal.out cgbal.in xeigtstc)\nadd_lapack_test(cgbak.out cgbak.in xeigtstc)\nadd_lapack_test(cbb.out cbb.in xeigtstc)\nadd_lapack_test(cglm.out glm.in xeigtstc)\nadd_lapack_test(cgqr.out gqr.in xeigtstc)\nadd_lapack_test(cgsv.out gsv.in xeigtstc)\nadd_lapack_test(ccsd.out csd.in xeigtstc)\nadd_lapack_test(clse.out lse.in xeigtstc)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring GCC-specific Vector Benchmarks\nDESCRIPTION: Creates additional benchmark targets specifically for GCC without auto-vectorization. Only executed when using GCC compiler and BTL_BENCH_NOGCCVEC option is enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/eigen3/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\noption(BTL_BENCH_NOGCCVEC \"also bench Eigen explicit vec without GCC's auto vec\" OFF)\nif(CMAKE_COMPILER_IS_GNUCXX AND BTL_BENCH_NOGCCVEC)\n  btl_add_bench(btl_eigen3_nogccvec_linear main_linear.cpp)\n  btl_add_bench(btl_eigen3_nogccvec_vecmat main_vecmat.cpp)\n  btl_add_bench(btl_eigen3_nogccvec_matmat main_matmat.cpp)\n  btl_add_bench(btl_eigen3_nogccvec_adv    main_adv.cpp   )\n\n  btl_add_target_property(btl_eigen3_nogccvec_linear COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=eigen3_nogccvec\")\n  btl_add_target_property(btl_eigen3_nogccvec_vecmat COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=eigen3_nogccvec\")\n  btl_add_target_property(btl_eigen3_nogccvec_matmat COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=eigen3_nogccvec\")\n  btl_add_target_property(btl_eigen3_nogccvec_adv    COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=eigen3_nogccvec\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen C++11 Source Directory with CMake\nDESCRIPTION: Installs the 'src' directory containing implementation files to the appropriate location. Only files with .h extension are included in the installation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(DIRECTORY src DESTINATION ${INCLUDE_INSTALL_DIR}/unsupported/Eigen/CXX11 COMPONENT Devel FILES_MATCHING PATTERN \"*.h\")\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen Unsupported Source Files in CMake\nDESCRIPTION: Installs the content of the 'src' directory to the include installation directory under the unsupported/Eigen path. It specifically targets header files (*.h) using the FILE_MATCHING PATTERN option.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(DIRECTORY src DESTINATION ${INCLUDE_INSTALL_DIR}/unsupported/Eigen COMPONENT Devel FILES_MATCHING PATTERN \"*.h\")\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Snippet Compilation Pipeline\nDESCRIPTION: Creates a build system configuration that compiles code snippets by iterating through source files, generating compilation targets, and setting up build dependencies. Each snippet is compiled into an executable with custom post-build commands to generate output files.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/doc/snippets/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nFILE(GLOB snippets_SRCS \"*.cpp\")\n\nADD_CUSTOM_TARGET(unsupported_snippets)\n\nFOREACH(snippet_src ${snippets_SRCS})\n  GET_FILENAME_COMPONENT(snippet ${snippet_src} NAME_WE)\n  SET(compile_snippet_target compile_${snippet})\n  SET(compile_snippet_src ${compile_snippet_target}.cpp)\n  FILE(READ ${snippet_src} snippet_source_code)\n  CONFIGURE_FILE(${PROJECT_SOURCE_DIR}/doc/snippets/compile_snippet.cpp.in\n                 ${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src})\n  ADD_EXECUTABLE(${compile_snippet_target}\n                 ${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src})\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    target_link_libraries(${compile_snippet_target} ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO})\n  endif()\n  ADD_CUSTOM_COMMAND(\n    TARGET ${compile_snippet_target}\n    POST_BUILD\n    COMMAND ${compile_snippet_target}\n    ARGS >${CMAKE_CURRENT_BINARY_DIR}/${snippet}.out\n  )\n  ADD_DEPENDENCIES(unsupported_snippets ${compile_snippet_target})\n  set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/${compile_snippet_src}\n                              PROPERTIES OBJECT_DEPENDS ${snippet_src})\nENDFOREACH(snippet_src)\n```\n\n----------------------------------------\n\nTITLE: Adding LAPACK Mixed Precision Tests in CMake\nDESCRIPTION: This section adds mixed precision LAPACK tests (single-double and complex-complex16) when the corresponding build options are enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif (BUILD_SIMPLE)\n    if (BUILD_DOUBLE)\n        add_lapack_test(dstest.out dstest.in xlintstds)\n    endif()\nendif()\n\nif (BUILD_COMPLEX)\n    if (BUILD_COMPLEX16)\n        add_lapack_test(zctest.out zctest.in xlintstzc)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Non-Vectorized Benchmarks\nDESCRIPTION: Sets up benchmark targets with vectorization explicitly disabled using EIGEN_DONT_VECTORIZE flag. These targets are created when BTL_NOVEC is not set.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/eigen3/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BTL_NOVEC)\n  btl_add_bench(btl_eigen3_novec_linear main_linear.cpp OFF)\n  btl_add_bench(btl_eigen3_novec_vecmat main_vecmat.cpp OFF)\n  btl_add_bench(btl_eigen3_novec_matmat main_matmat.cpp OFF)\n  btl_add_bench(btl_eigen3_novec_adv main_adv.cpp       OFF)\n  btl_add_target_property(btl_eigen3_novec_linear COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=eigen3_novec\")\n  btl_add_target_property(btl_eigen3_novec_vecmat COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=eigen3_novec\")\n  btl_add_target_property(btl_eigen3_novec_matmat COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=eigen3_novec\")\n  btl_add_target_property(btl_eigen3_novec_adv    COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=eigen3_novec\")\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen C++11 Header Files with CMake\nDESCRIPTION: Configures the installation of the main C++11 header files to the designated include directory. Files are installed as part of the Devel component.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(FILES\n  ${Eigen_CXX11_HEADERS}\n  DESTINATION ${INCLUDE_INSTALL_DIR}/unsupported/Eigen/CXX11 COMPONENT Devel\n  )\n```\n\n----------------------------------------\n\nTITLE: Adding CXX11 Subdirectory in CMake\nDESCRIPTION: Adds the CXX11 subdirectory to the build process, enabling CMake to process the CMakeLists.txt file in that directory. This allows for building and installing C++11 specific features of Eigen.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(CXX11)\n```\n\n----------------------------------------\n\nTITLE: Configuring Subdirectories for Eigen Project in CMake\nDESCRIPTION: This CMake script manages the inclusion of subdirectories for the Eigen project. It adds the Eigen core directory, documentation (excluded from default build), and conditionally includes test directories based on build settings and configuration flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(Eigen)\nadd_subdirectory(doc EXCLUDE_FROM_ALL)\nif(BUILD_TESTING)\n  if(EIGEN_LEAVE_TEST_IN_ALL_TARGET)\n    add_subdirectory(test) # can't do EXCLUDE_FROM_ALL here, breaks CTest\n  else()\n    add_subdirectory(test EXCLUDE_FROM_ALL)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining LAPACK Test Addition Macro in CMake\nDESCRIPTION: This macro, named 'add_lapack_test', sets up a LAPACK test by specifying input and output files, the target executable, and adding it to the test suite using CMake's add_test command.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nmacro(add_lapack_test output input target)\n  set(TEST_INPUT \"${LAPACK_SOURCE_DIR}/testing/${input}\")\n  set(TEST_OUTPUT \"${LAPACK_BINARY_DIR}/testing/${output}\")\n  get_target_property(TEST_LOC ${target} LOCATION)\n  string(REPLACE \".\" \"_\" input_name ${input})\n  set(testName \"${target}_${input_name}\")\n  if(EXISTS \"${TEST_INPUT}\")\n    add_test(LAPACK-${testName} \"${CMAKE_COMMAND}\"\n      -DTEST=${TEST_LOC}\n      -DINPUT=${TEST_INPUT} \n      -DOUTPUT=${TEST_OUTPUT} \n      -DINTDIR=${CMAKE_CFG_INTDIR}\n      -P \"${LAPACK_SOURCE_DIR}/testing/runtest.cmake\")\n  endif()\nendmacro(add_lapack_test)\n```\n\n----------------------------------------\n\nTITLE: Displaying Eigen Build Information in CMake\nDESCRIPTION: This snippet displays information about available build commands and installation paths for Eigen. It provides helpful information to users after the configuration process.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\nstring(TOLOWER \"${CMAKE_GENERATOR}\" cmake_generator_tolower)\nif(cmake_generator_tolower MATCHES \"makefile\")\n  message(STATUS \"Some things you can do now:\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"Command       |   Description\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\n  message(STATUS \"make install  | Install Eigen. Headers will be installed to:\")\n  message(STATUS \"              |     <CMAKE_INSTALL_PREFIX>/<INCLUDE_INSTALL_DIR>\")\n  message(STATUS \"              |   Using the following values:\")\n  message(STATUS \"              |     CMAKE_INSTALL_PREFIX: ${CMAKE_INSTALL_PREFIX}\")\n  message(STATUS \"              |     INCLUDE_INSTALL_DIR:  ${INCLUDE_INSTALL_DIR}\")\n  message(STATUS \"              |   Change the install location of Eigen headers using:\")\n  message(STATUS \"              |     cmake . -DCMAKE_INSTALL_PREFIX=yourprefix\")\n  message(STATUS \"              |   Or:\")\n  message(STATUS \"              |     cmake . -DINCLUDE_INSTALL_DIR=yourdir\")\n  message(STATUS \"make doc      | Generate the API documentation, requires Doxygen & LaTeX\")\n  message(STATUS \"make check    | Build and run the unit-tests. Read this page:\")\n  message(STATUS \"              |   http://eigen.tuxfamily.org/index.php?title=Tests\")\n  message(STATUS \"make blas     | Build BLAS library (not the same thing as Eigen)\")\n  message(STATUS \"make uninstall| Removes files installed by make install\")\n  message(STATUS \"--------------+--------------------------------------------------------------\")\nelse()\n  message(STATUS \"To build/run the unit tests, read this page:\")\n  message(STATUS \"  http://eigen.tuxfamily.org/index.php?title=Tests\")\nendif()\n\nmessage(STATUS \"\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard Tensor Benchmarks\nDESCRIPTION: Sets up basic tensor benchmarking targets for linear, vector-matrix, and matrix-matrix operations with standard compilation flags.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/tensors/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (TENSOR_FOUND)\n\n  include_directories(${TENSOR_INCLUDE_DIR})\n  btl_add_bench(btl_tensor_linear main_linear.cpp)\n  btl_add_bench(btl_tensor_vecmat main_vecmat.cpp)\n  btl_add_bench(btl_tensor_matmat main_matmat.cpp)\n\n  btl_add_target_property(btl_tensor_linear COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=tensor\")\n  btl_add_target_property(btl_tensor_vecmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=tensor\")\n  btl_add_target_property(btl_tensor_matmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=tensor\")\n```\n\n----------------------------------------\n\nTITLE: Defining CUDA BLAS Examples List in CMake\nDESCRIPTION: Creates a list of CUDA BLAS example programs to be built. The list includes 'nrm2', 'trsv', and 'gemm' examples.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/sandbox/cublas_examples/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND TF_CUDA_BLAS_EXAMPLES\n  nrm2\n  trsv\n  gemm\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen EulerAngles Headers with CMake\nDESCRIPTION: CMake configuration that collects all header files in the current directory and installs them to the specified destination path. Uses FILE(GLOB) to gather header files and INSTALL command to define installation parameters.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/src/EulerAngles/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nFILE(GLOB Eigen_EulerAngles_SRCS \"*.h\")\n\nINSTALL(FILES\n  ${Eigen_EulerAngles_SRCS}\n  DESTINATION ${INCLUDE_INSTALL_DIR}/unsupported/Eigen/src/EulerAngles COMPONENT Devel\n  )\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen3 Include Directory and Basic Benchmarks\nDESCRIPTION: Sets up Eigen3 include directory and creates basic benchmark targets for linear algebra operations. Configures compilation flags for basic benchmarks with exception handling disabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/eigen3/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif((NOT EIGEN3_INCLUDE_DIR) AND Eigen_SOURCE_DIR)\n  # unless EIGEN3_INCLUDE_DIR is defined, let's use current Eigen version\n  set(EIGEN3_INCLUDE_DIR ${Eigen_SOURCE_DIR})\n  set(EIGEN3_FOUND TRUE)\nelse()\n  find_package(Eigen3)\nendif()\n\nif (EIGEN3_FOUND)\n  include_directories(${EIGEN3_INCLUDE_DIR})\n  btl_add_bench(btl_eigen3_linear main_linear.cpp)\n  btl_add_bench(btl_eigen3_vecmat main_vecmat.cpp)\n  btl_add_bench(btl_eigen3_matmat main_matmat.cpp)\n  btl_add_bench(btl_eigen3_adv main_adv.cpp      )\n\n  btl_add_target_property(btl_eigen3_linear COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen3\")\n  btl_add_target_property(btl_eigen3_vecmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen3\")\n  btl_add_target_property(btl_eigen3_matmat COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen3\")\n  btl_add_target_property(btl_eigen3_adv    COMPILE_FLAGS \"-fno-exceptions -DBTL_PREFIX=eigen3\")\n```\n\n----------------------------------------\n\nTITLE: Source Files Configuration\nDESCRIPTION: Defines the source files for the EigenLapack library including C++ and Fortran sources\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(lapack)\ninclude_directories(../blas)\n\nset(EigenLapack_SRCS\nsingle.cpp double.cpp complex_single.cpp complex_double.cpp ../blas/xerbla.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Doxygen Parameters for Eigen Core Documentation\nDESCRIPTION: Configures various Doxygen parameters for the core Eigen library documentation, including project name, input directories, and styling options.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Set some Doxygen flags\nset(EIGEN_DOXY_PROJECT_NAME             \"Eigen\")\nset(EIGEN_DOXY_OUTPUT_DIRECTORY_SUFFIX  \"\")\nset(EIGEN_DOXY_INPUT                    \"\\\"${Eigen_SOURCE_DIR}/Eigen\\\" \\\"${Eigen_SOURCE_DIR}/doc\\\"\")\nset(EIGEN_DOXY_HTML_COLORSTYLE_HUE      \"220\")\nset(EIGEN_DOXY_TAGFILES                 \"\")\nif(EIGEN_INTERNAL_DOCUMENTATION)\n  set(EIGEN_DOXY_INTERNAL                 \"YES\")\nelse(EIGEN_INTERNAL_DOCUMENTATION)\n  set(EIGEN_DOXY_INTERNAL                 \"NO\")\nendif(EIGEN_INTERNAL_DOCUMENTATION)\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Shell Scripts with CMake\nDESCRIPTION: Copies check.in, debug.in, and release.in template files to their respective shell scripts in the build directory without variable substitution.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/scripts/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(check.in ${CMAKE_BINARY_DIR}/check.sh COPYONLY)\nconfigure_file(debug.in ${CMAKE_BINARY_DIR}/debug.sh COPYONLY)\nconfigure_file(release.in ${CMAKE_BINARY_DIR}/release.sh COPYONLY)\n```\n\n----------------------------------------\n\nTITLE: Creating Prerequisites Target for Eigen Core Documentation\nDESCRIPTION: Defines a custom target that prepares the directory structure and copies necessary files for the Eigen core documentation.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(\n  doc-eigen-prerequisites\n  ALL\n  COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/html/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/eigen_navtree_hacks.js           ${CMAKE_CURRENT_BINARY_DIR}/html/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/Eigen_Silly_Professor_64x64.png  ${CMAKE_CURRENT_BINARY_DIR}/html/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ftv2pnode.png                    ${CMAKE_CURRENT_BINARY_DIR}/html/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ftv2node.png                     ${CMAKE_CURRENT_BINARY_DIR}/html/\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/AsciiQuickReference.txt          ${CMAKE_CURRENT_BINARY_DIR}/html/\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n)\n```\n\n----------------------------------------\n\nTITLE: Capturing Compiler Version in CMake\nDESCRIPTION: Adds a custom command to write the compiler version information to a text file in the build directory. This is executed after the copy_scripts target is built.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nADD_CUSTOM_COMMAND(\n  TARGET copy_scripts\n  POST_BUILD\n  COMMAND ${CMAKE_CXX_COMPILER} --version | head -n 1 > ${CMAKE_CURRENT_BINARY_DIR}/compiler_version.txt\n  ARGS\n)\n```\n\n----------------------------------------\n\nTITLE: Initial Project and Language Setup\nDESCRIPTION: Sets up the CMake project for EigenLapack and configures Fortran compiler support\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/lapack/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nproject(EigenLapack CXX)\n\ninclude(\"../cmake/language_support.cmake\")\n\nworkaround_9220(Fortran EIGEN_Fortran_COMPILER_WORKS)\n\nif(EIGEN_Fortran_COMPILER_WORKS)\n  enable_language(Fortran OPTIONAL)\n  if(NOT CMAKE_Fortran_COMPILER)\n    set(EIGEN_Fortran_COMPILER_WORKS OFF)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding C++ Compiler Flags in CMake\nDESCRIPTION: Defines a macro to safely add compiler flags by first checking if the compiler supports the flag, then adding it only if supported.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nmacro(ei_add_cxx_compiler_flag FLAG)\n  string(REGEX REPLACE \"-\" \"\" SFLAG1 ${FLAG})\n  string(REGEX REPLACE \"\\\\+\" \"p\" SFLAG ${SFLAG1})\n  check_cxx_compiler_flag(${FLAG} COMPILER_SUPPORT_${SFLAG})\n  if(COMPILER_SUPPORT_${SFLAG})\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${FLAG}\")\n  endif()\nendmacro(ei_add_cxx_compiler_flag)\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxygen Template Files\nDESCRIPTION: Configures various Doxygen template files for both core and unsupported documentation, including headers, footers, and layout configurations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/eigendoxy_header.html.in\n  ${CMAKE_CURRENT_BINARY_DIR}/eigendoxy_header.html\n)\n\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/eigendoxy_footer.html.in\n  ${CMAKE_CURRENT_BINARY_DIR}/eigendoxy_footer.html\n)\n\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/eigendoxy_layout.xml.in\n  ${CMAKE_CURRENT_BINARY_DIR}/eigendoxy_layout.xml\n)\n\nconfigure_file(\n  ${Eigen_SOURCE_DIR}/unsupported/doc/eigendoxy_layout.xml.in\n  ${Eigen_BINARY_DIR}/doc/unsupported/eigendoxy_layout.xml\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Eigen Tests List Property in CMake\nDESCRIPTION: Gets the list of Eigen tests from a global property named EIGEN_TESTS_LIST for use in test configuration.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/scripts/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nget_property(EIGEN_TESTS_LIST GLOBAL PROPERTY EIGEN_TESTS_LIST)\n```\n\n----------------------------------------\n\nTITLE: Defining Linear Algebra Benchmark Operations with Size Ranges\nDESCRIPTION: This configuration file lists linear algebra operations for benchmarking with their descriptions and test size ranges. Each line has four fields: operation name, description, size parameter name, and size range for testing.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/action_settings.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\naat ; \"{/*1.5 A x A^T}\" ; \"matrix size\" ; 4:5000\nata ; \"{/*1.5 A^T x A}\" ; \"matrix size\" ; 4:5000\natv ; \"{/*1.5 matrix^T x vector}\" ; \"matrix size\" ; 4:5000\naxpby ; \"{/*1.5 Y = alpha X + beta Y}\" ; \"vector size\" ; 5:1000000\naxpy ; \"{/*1.5 Y += alpha X}\" ; \"vector size\" ; 5:1000000\nmatrix_matrix ; \"{/*1.5 matrix matrix product}\" ; \"matrix size\" ; 4:5000\nmatrix_vector ; \"{/*1.5 matrix vector product}\" ; \"matrix size\" ; 4:5000\ntrmm ; \"{/*1.5 triangular matrix matrix product}\" ; \"matrix size\" ; 4:5000\ntrisolve_vector ; \"{/*1.5 triangular solver - vector (X = inv(L) X)}\" ; \"size\" ; 4:5000\ntrisolve_matrix ; \"{/*1.5 triangular solver - matrix (M = inv(L) M)}\" ; \"size\" ; 4:5000\ncholesky ; \"{/*1.5 Cholesky decomposition}\" ; \"matrix size\" ; 4:5000\ncomplete_lu_decomp ; \"{/*1.5 Complete LU decomposition}\" ; \"matrix size\" ; 4:5000\npartial_lu_decomp ; \"{/*1.5 Partial LU decomposition}\" ; \"matrix size\" ; 4:5000\ntridiagonalization ; \"{/*1.5 Tridiagonalization}\" ; \"matrix size\" ; 4:5000\nhessenberg ; \"{/*1.5 Hessenberg decomposition}\" ; \"matrix size\" ; 4:5000\nsymv ; \"{/*1.5 symmetric matrix vector product}\" ; \"matrix size\" ; 4:5000\nsyr2 ; \"{/*1.5 symmretric rank-2 update (A += u^T v + u v^T)}\" ; \"matrix size\" ; 4:5000\nger ; \"{/*1.5 general rank-1 update (A += u v^T)}\" ; \"matrix size\" ; 4:5000\nrot ; \"{/*1.5 apply rotation in the plane}\" ; \"vector size\" ; 4:1000000\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen Library in CMake\nDESCRIPTION: Sets up the Eigen linear algebra library by defining its root directory and including it in the project. If EIGEN_ROOT is not already defined, it defaults to a local path in the project's 3rd-party directory.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/benchmarks/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# -----------------------------------------------------------------------------\n# eigen package \n# -----------------------------------------------------------------------------\nif(NOT DEFINED EIGEN_ROOT)\n  set(EIGEN_ROOT ${PROJECT_SOURCE_DIR}/3rd-party/eigen-3.3.7)\nendif()\ninclude_directories(${EIGEN_ROOT})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Standard Math Library Linking\nDESCRIPTION: Finds and configures how to link to the standard math library, which is required for Eigen's numerical operations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(StandardMathLibrary)\n\n\nset(EIGEN_TEST_CUSTOM_LINKER_FLAGS  \"\" CACHE STRING \"Additional linker flags when linking unit tests.\")\nset(EIGEN_TEST_CUSTOM_CXX_FLAGS     \"\" CACHE STRING \"Additional compiler flags when compiling unit tests.\")\n\nset(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO \"\")\n\nif(NOT STANDARD_MATH_LIBRARY_FOUND)\n\n  message(FATAL_ERROR\n    \"Can't link to the standard math library. Please report to the Eigen developers, telling them about your platform.\")\n\nelse()\n\n  if(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n    set(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO \"${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO} ${STANDARD_MATH_LIBRARY}\")\n  else()\n    set(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO \"${STANDARD_MATH_LIBRARY}\")\n  endif()\n\nendif()\n\nif(EIGEN_STANDARD_LIBRARIES_TO_LINK_TO)\n  message(STATUS \"Standard libraries to link to explicitly: ${EIGEN_STANDARD_LIBRARIES_TO_LINK_TO}\")\nelse()\n  message(STATUS \"Standard libraries to link to explicitly: none\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Documentation Option in CMake\nDESCRIPTION: Creates a CMake option to toggle building of internal documentation, defaulting to OFF.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\noption(EIGEN_INTERNAL_DOCUMENTATION \"Build internal documentation\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Configuring Logo Color Scheme in JSON\nDESCRIPTION: JSON configuration specifying the color scheme for the TaskFlow logo. Includes transparent background, icon gradient colors, font color, and slogan color.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/image/taskflow_logo/info.txt#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"bg\":\"transparent\",\"icon-gradient-0\":\"#20484F\",\"icon-gradient-1\":\"#4E9BAB\",\"font\":\"#000000\",\"slogan\":\"#141414\"}\n```\n\n----------------------------------------\n\nTITLE: Running OpenMP Benchmark in Bash\nDESCRIPTION: This snippet shows how to use the bench_multi_compilers.sh script to run OpenMP benchmarks. It uses a specific compiler list file for OpenMP and a corresponding C++ benchmark file.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/README.txt#2025-04-22_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ ./bench_multi_compilers.sh ompbench.cxxlist ompbenchmark.cpp\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Target for Copying Scripts in CMake\nDESCRIPTION: Creates a custom target that copies required script files to the build directory. The script files include plotting scripts, settings files, and other utility scripts used by the TaskFlow project.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nADD_CUSTOM_TARGET(copy_scripts)\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Flags for Documentation Build\nDESCRIPTION: Sets specific compiler flags for GCC under Linux to optimize documentation build with minimal debugging information.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_COMPILER_IS_GNUCXX)\n  if(CMAKE_SYSTEM_NAME MATCHES Linux)\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O1 -g1\")\n  endif(CMAKE_SYSTEM_NAME MATCHES Linux)\nendif(CMAKE_COMPILER_IS_GNUCXX)\n```\n\n----------------------------------------\n\nTITLE: Running Multi-Compiler Benchmark in Bash\nDESCRIPTION: This snippet demonstrates how to use the bench_multi_compilers.sh script to run benchmarks with different compilers and options. It takes two arguments: a file listing compilers with their options, and the C++ benchmark file.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/README.txt#2025-04-22_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ ./bench_multi_compilers.sh basicbench.cxxlist basicbenchmark.cpp\n```\n\n----------------------------------------\n\nTITLE: Configuring Blaze Benchmark Target with CMake\nDESCRIPTION: Sets up a Blaze benchmark target that requires both Blaze and Boost libraries. The configuration includes finding required packages, setting include directories, creating the benchmark target, setting C++14 standard requirement, and linking with Boost libraries.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/blaze/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(BLAZE)\nfind_package(Boost COMPONENTS system)\nif (BLAZE_FOUND AND Boost_FOUND)\n  include_directories(${BLAZE_INCLUDE_DIR} ${Boost_INCLUDE_DIRS})\n  btl_add_bench(btl_blaze main.cpp)\n  # Note: The newest blaze version requires C++14.\n  # Ideally, we should set this depending on the version of Blaze we found\n  set_property(TARGET btl_blaze PROPERTY CXX_STANDARD 14)\n  if(BUILD_btl_blaze)\n    target_link_libraries(btl_blaze ${Boost_LIBRARIES})\n  endif()\nendif ()\n```\n\n----------------------------------------\n\nTITLE: Setting Project Name for EigenDoc in CMake\nDESCRIPTION: Sets the project name for the Eigen documentation build and excludes it from the default build target.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(EigenDoc)\n\nset_directory_properties(PROPERTIES EXCLUDE_FROM_ALL TRUE)\n\nproject(EigenDoc)\n```\n\n----------------------------------------\n\nTITLE: Configuring C++11 Support in Eigen\nDESCRIPTION: Checks for compiler support for C++11 standard and configures the build accordingly based on whether C++11 testing is enabled.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ncheck_cxx_compiler_flag(\"-std=c++11\" EIGEN_COMPILER_SUPPORT_CPP11)\n\nif(EIGEN_TEST_CXX11)\n  set(CMAKE_CXX_STANDARD 11)\n  set(CMAKE_CXX_EXTENSIONS OFF)\n  if(EIGEN_COMPILER_SUPPORT_CPP11)\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n  endif()\nelse()\n  #set(CMAKE_CXX_STANDARD 03)\n  #set(CMAKE_CXX_EXTENSIONS OFF)\n  ei_add_cxx_compiler_flag(\"-std=c++03\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting up GMM Benchmark in CMake\nDESCRIPTION: This CMake script checks for the presence of the GMM library, sets up include paths, and conditionally adds a benchmark target. The script uses find_package to locate GMM and only proceeds with building the benchmark if GMM is found.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/gmm/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(GMM)\nif (GMM_FOUND)\n  include_directories(${GMM_INCLUDES})\n  btl_add_bench(btl_gmm main.cpp)\nendif (GMM_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Targets in CMake\nDESCRIPTION: Adds three executable targets (smooth, regularize, and main) that will be built from their respective source files. The main target depends on the copy_scripts target to ensure scripts are copied before it runs.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(smooth smooth.cxx)\nadd_executable(regularize regularize.cxx)\nadd_executable(main mean.cxx)\nadd_dependencies(main copy_scripts)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Documentation Dependencies\nDESCRIPTION: Establishes dependencies between documentation targets and their required prerequisites, including examples and snippets.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(doc-eigen-prerequisites all_snippets all_examples)\nadd_dependencies(doc-unsupported-prerequisites unsupported_snippets unsupported_examples)\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen Library Installation in CMake\nDESCRIPTION: Script to configure installation of Eigen library files. It includes regex utilities, glob-collects files, filters out unwanted files (txt files and hidden files), and sets up installation rules for both individual files and header directories.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/Eigen/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(RegexUtils)\ntest_escape_string_as_regex()\n\nfile(GLOB Eigen_directory_files \"*\")\n\nescape_string_as_regex(ESCAPED_CMAKE_CURRENT_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nforeach(f ${Eigen_directory_files})\n  if(NOT f MATCHES \"\\.txt\" AND NOT f MATCHES \"${ESCAPED_CMAKE_CURRENT_SOURCE_DIR}/[.].+\" AND NOT f MATCHES \"${ESCAPED_CMAKE_CURRENT_SOURCE_DIR}/src\")\n    list(APPEND Eigen_directory_files_to_install ${f})\n  endif()\nendforeach(f ${Eigen_directory_files})\n\ninstall(FILES\n  ${Eigen_directory_files_to_install}\n  DESTINATION ${INCLUDE_INSTALL_DIR}/Eigen COMPONENT Devel\n  )\n\ninstall(DIRECTORY src DESTINATION ${INCLUDE_INSTALL_DIR}/Eigen COMPONENT Devel FILES_MATCHING PATTERN \"*.h\")\n```\n\n----------------------------------------\n\nTITLE: Defining Script Files List in CMake\nDESCRIPTION: Sets a list of script files that need to be copied to the build directory. These include various shell scripts, gnuplot settings, and other configuration files used for data processing or visualization.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nSET(script_files go_mean mk_mean_script.sh mk_new_gnuplot.sh\n    perlib_plot_settings.txt action_settings.txt gnuplot_common_settings.hh )\n```\n\n----------------------------------------\n\nTITLE: Configuring Doxyfile for Eigen Core Documentation\nDESCRIPTION: Generates the Doxyfile for core Eigen documentation by configuring it from a template.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in\n  ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Fortran Support for EigenBlas\nDESCRIPTION: Checks for Fortran compiler availability and sets up language support. Uses a workaround for CMake issue 9220 and enables optional Fortran language support.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/blas/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nproject(EigenBlas CXX)\n\ninclude(\"../cmake/language_support.cmake\")\n\nworkaround_9220(Fortran EIGEN_Fortran_COMPILER_WORKS)\n\nif(EIGEN_Fortran_COMPILER_WORKS)\n  enable_language(Fortran OPTIONAL)\n  if(NOT CMAKE_Fortran_COMPILER)\n    set(EIGEN_Fortran_COMPILER_WORKS OFF)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: TBB Package Integration with TBBGet\nDESCRIPTION: CMake code to download and integrate TBB package using TBBGet module. Requires TBB CMake modules to be available.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(<path-to-tbb-cmake-modules>/TBBGet.cmake)\ntbb_get(TBB_ROOT tbb_root CONFIG_DIR TBB_DIR)\nfind_package(TBB <options>)\n```\n\n----------------------------------------\n\nTITLE: Defining cuBLAS Unittest List in CMake\nDESCRIPTION: Creates a list of cuBLAS unittests to be built. The list includes helper utilities and the three levels of BLAS operations (level1, level2, level3).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/sandbox/cublas_unittests/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND TF_CUBLAS_UNITTESTS\n  helper\n  level1\n  level2\n  level3\n)\n```\n\n----------------------------------------\n\nTITLE: Initial BLAS/LAPACK Configuration\nDESCRIPTION: Sets up basic BLAS and LAPACK library configurations using Eigen implementations.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/spbench/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(BLAS_FOUND TRUE)\nset(LAPACK_FOUND TRUE)\nset(BLAS_LIBRARIES eigen_blas_static)\nset(LAPACK_LIBRARIES eigen_lapack_static)\n\nset(SPARSE_LIBS \"\")\n```\n\n----------------------------------------\n\nTITLE: Target Property Addition Macro\nDESCRIPTION: Defines a macro for adding properties to build targets conditionally\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nmacro(btl_add_target_property target prop value)\n\n  if(BUILD_${target})\n    get_target_property(previous ${target} ${prop})\n    if(NOT previous)\n      set(previous \"\")\n    endif()\n    set_target_properties(${target} PROPERTIES ${prop} \"${previous} ${value}\")\n  endif()\n\nendmacro(btl_add_target_property)\n```\n\n----------------------------------------\n\nTITLE: PASTIX Configuration with METIS/SCOTCH\nDESCRIPTION: Sets up PASTIX sparse solver with optional METIS or SCOTCH ordering libraries, checking for non-MPI version compatibility.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/spbench/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(PASTIX QUIET COMPONENTS METIS SCOTCH)\nfind_path(PASTIX_pastix_nompi.h_INCLUDE_DIRS\n  NAMES pastix_nompi.h\n  HINTS ${PASTIX_INCLUDE_DIRS}\n)\nif (NOT PASTIX_pastix_nompi.h_INCLUDE_DIRS)\n  message(STATUS \"A version of Pastix has been found but pastix_nompi.h does not exist in the include directory.\"\n                 \" Because Eigen tests require a version without MPI, we disable the Pastix backend.\")\nendif()\nif(PASTIX_FOUND AND PASTIX_pastix_nompi.h_INCLUDE_DIRS AND BLAS_FOUND)\n  add_definitions(\"-DEIGEN_PASTIX_SUPPORT\")\n  include_directories(${PASTIX_INCLUDE_DIRS_DEP})\n  if(SCOTCH_FOUND)\n    include_directories(${SCOTCH_INCLUDE_DIRS})\n    set(PASTIX_LIBRARIES ${PASTIX_LIBRARIES} ${SCOTCH_LIBRARIES})\n  elseif(METIS_FOUND)\n    include_directories(${METIS_INCLUDE_DIRS})\n    set(PASTIX_LIBRARIES ${PASTIX_LIBRARIES} ${METIS_LIBRARIES})  \n  endif(SCOTCH_FOUND)\n  set(SPARSE_LIBS ${SPARSE_LIBS} ${PASTIX_LIBRARIES_DEP} ${ORDERING_LIBRARIES})\n  set(PASTIX_ALL_LIBS ${PASTIX_LIBRARIES_DEP})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Cholmod Library Configuration\nDESCRIPTION: Configures Cholmod sparse matrix library with BLAS and LAPACK dependencies.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/spbench/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Cholmod)\nif(CHOLMOD_FOUND AND BLAS_FOUND AND LAPACK_FOUND)\n  add_definitions(\"-DEIGEN_CHOLMOD_SUPPORT\")\n  include_directories(${CHOLMOD_INCLUDES})\n  set(SPARSE_LIBS ${SPARSE_LIBS} ${CHOLMOD_LIBRARIES} ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES})\n  set(CHOLMOD_ALL_LIBS  ${CHOLMOD_LIBRARIES} ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring GCC-specific No-Vectorization Benchmarks\nDESCRIPTION: Conditionally adds benchmarking targets that disable GCC's auto-vectorization for comparison purposes.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/tensors/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n  option(BTL_BENCH_NOGCCVEC \"also bench Eigen explicit vec without GCC's auto vec\" OFF)\n  if(CMAKE_COMPILER_IS_GNUCXX AND BTL_BENCH_NOGCCVEC)\n    btl_add_bench(btl_tensor_nogccvec_linear main_linear.cpp)\n    btl_add_bench(btl_tensor_nogccvec_vecmat main_vecmat.cpp)\n    btl_add_bench(btl_tensor_nogccvec_matmat main_matmat.cpp)\n\n    btl_add_target_property(btl_tensor_nogccvec_linear COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=tensor_nogccvec\")\n    btl_add_target_property(btl_tensor_nogccvec_vecmat COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=tensor_nogccvec\")\n    btl_add_target_property(btl_tensor_nogccvec_matmat COMPILE_FLAGS \"-fno-exceptions -fno-tree-vectorize -DBTL_PREFIX=tensor_nogccvec\")\n  endif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt4 Dependency for Eigen Tests\nDESCRIPTION: Checks if Qt4 testing should be enabled, finds the Qt4 package, and includes Qt use file if found. The EIGEN_TEST_NOQT flag can be used to disable Qt4 dependency checking.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/doc/special_examples/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT EIGEN_TEST_NOQT)\n  find_package(Qt4)\n  if(QT4_FOUND)\n    include(${QT_USE_FILE})\n  endif()\nendif(NOT EIGEN_TEST_NOQT)\n```\n\n----------------------------------------\n\nTITLE: Basic TBB Package Integration in CMake\nDESCRIPTION: Simple CMake code to find and integrate a TBB package using find_package command. Requires TBBConfig.cmake location to be available via TBB_DIR or CMAKE_PREFIX_PATH.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(TBB <options>)\n```\n\n----------------------------------------\n\nTITLE: Negating Tensor Values in C++\nDESCRIPTION: Shows how to negate all values in a tensor using the unary minus operator. The example creates a constant tensor and negates its values.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\nEigen::Tensor<float, 2> a(2, 3);\na.setConstant(1.0f);\nEigen::Tensor<float, 2> b = -a;\ncout << \"a\" << endl << a << endl << endl;\ncout << \"b\" << endl << b << endl << endl;\n```\n\n----------------------------------------\n\nTITLE: Configuring MTL4 Library for BTL Benchmarking in CMake\nDESCRIPTION: Searches for the MTL4 package using find_package, and if found, adds its include directory to the include path and creates a benchmark target named 'btl_mtl4' using the main.cpp source file.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/mtl4/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(MTL4)\nif (MTL4_FOUND)\n  include_directories(${MTL4_INCLUDE_DIR})\n  btl_add_bench(btl_mtl4 main.cpp)\nendif (MTL4_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Configuring TVMET Library Dependencies in CMake\nDESCRIPTION: Searches for TVMET package installation, includes its directory, and adds a benchmark target if found. Uses CMake's find_package mechanism for dependency management.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/tvmet/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Tvmet)\nif (TVMET_FOUND)\n  include_directories(${TVMET_INCLUDE_DIR})\n  btl_add_bench(btl_tvmet main.cpp OFF)\nendif (TVMET_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Using Auto with Tensor Expressions in C++\nDESCRIPTION: This example demonstrates the implications of using C++'s auto keyword with tensor expressions, showing the difference between storing results in a Tensor versus keeping a non-evaluated expression tree.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CXX11/src/Tensor/README.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nTensor<float, 3> t3 = t1 + t2;\ncout << t3(0, 0, 0);  // OK prints the value of t1(0, 0, 0) + t2(0, 0, 0)\n\nauto t4 = t1 + t2;\ncout << t4(0, 0, 0);  // Compilation error!\n```\n\n----------------------------------------\n\nTITLE: Configuring MSVC Compiler Flags\nDESCRIPTION: Sets optimization flags specifically for Microsoft Visual C++ compiler\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nIF(MSVC)\n  SET(CMAKE_CXX_FLAGS \" /O2 /Ot /GL /fp:fast -DNDEBUG\")\n  IF(BTL_NOVEC)\n    SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DEIGEN_DONT_VECTORIZE\")\n  ENDIF(BTL_NOVEC)\nENDIF(MSVC)\n```\n\n----------------------------------------\n\nTITLE: Installing Eigen Unsupported Headers in CMake\nDESCRIPTION: Configures the installation of the listed Eigen unsupported headers to the specified include installation directory. This makes these headers available for development with the 'Devel' component.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(FILES\n  ${Eigen_HEADERS}\n  DESTINATION ${INCLUDE_INSTALL_DIR}/unsupported/Eigen COMPONENT Devel\n  )\n```\n\n----------------------------------------\n\nTITLE: Configuring Eigen Unsupported Headers List in CMake\nDESCRIPTION: Defines a list of Eigen's unsupported module headers to be installed. These include specialized mathematical operations like AutoDiff, FFT, and optimization algorithms like LevenbergMarquardt.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/Eigen/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(Eigen_HEADERS \n  AdolcForward\n  AlignedVector3\n  ArpackSupport\n  AutoDiff\n  BVH\n  EulerAngles\n  FFT\n  IterativeSolvers \n  KroneckerProduct\n  LevenbergMarquardt\n  MatrixFunctions \n  MoreVectorization\n  MPRealSupport\n  NonLinearOptimization\n  NumericalDiff\n  OpenGLSupport\n  Polynomials\n  Skyline \n  SparseExtra\n  SpecialFunctions\n  Splines\n  )\n```\n\n----------------------------------------\n\nTITLE: Adding Uninstall Target for Eigen\nDESCRIPTION: This code adds a custom 'uninstall' target to the CMake project. It allows users to easily remove installed Eigen files using the uninstall command.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/CMakeLists.txt#2025-04-22_snippet_23\n\nLANGUAGE: cmake\nCODE:\n```\n# Add uninstall target\nadd_custom_target ( uninstall\n    COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/EigenUninstall.cmake)\n```\n\n----------------------------------------\n\nTITLE: Configuring buildtests Shell Script with CMake\nDESCRIPTION: Configures a buildtests.sh script from a template file using the @ONLY option to replace only variables marked with @VAR@.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/scripts/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(buildtests.in ${CMAKE_BINARY_DIR}/buildtests.sh @ONLY)\n```\n\n----------------------------------------\n\nTITLE: Configuring STL Benchmark Target in CMake\nDESCRIPTION: CMake function call that adds a benchmark target for testing STL functionality. The function btl_add_bench takes three parameters: the target name (btl_STL), the source file (main.cpp), and a toggle flag (OFF).\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/STL/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nbtl_add_bench(btl_STL main.cpp OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting up Tensor Include Directory\nDESCRIPTION: Configures the tensor include directory using either the existing Eigen source directory or by finding the Tensor package.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/tensors/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif((NOT TENSOR_INCLUDE_DIR) AND Eigen_SOURCE_DIR)\n  # unless TENSOR_INCLUDE_DIR is defined, let's use current Eigen version\n  set(TENSOR_INCLUDE_DIR ${Eigen_SOURCE_DIR})\n  set(TENSOR_FOUND TRUE)\nelse()\n  find_package(Tensor)\nendif()\n```\n\n----------------------------------------\n\nTITLE: TBB Install Example Command\nDESCRIPTION: Example command for installing TBB CMake configuration files using the tbb_config_installer script with specific paths and system parameters.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ncmake -DINSTALL_DIR=/my/package/content/lib/cmake/TBB -DSYSTEM_NAME=Linux -DTBB_VERSION_FILE=/my/package/content/include/tbb/tbb_stddef.h -P tbb_config_installer.cmake\n```\n\n----------------------------------------\n\nTITLE: Setting Directory Properties and Adding Subdirectories in CMake\nDESCRIPTION: Sets the EXCLUDE_FROM_ALL property to TRUE for the current directory and adds 'examples' and 'snippets' subdirectories to the build system. The EXCLUDE_FROM_ALL property prevents targets in this directory from being built by default.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/unsupported/doc/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset_directory_properties(PROPERTIES EXCLUDE_FROM_ALL TRUE)\n\nadd_subdirectory(examples)\nadd_subdirectory(snippets)\n```\n\n----------------------------------------\n\nTITLE: Default Make Arguments for TBB Build\nDESCRIPTION: Standard make arguments that are automatically passed during TBB compilation process. These include compiler specification, build directory paths, and parallel job settings.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_8\n\nLANGUAGE: makefile\nCODE:\n```\ncompiler=<compiler>\ntbb_build_dir=<tbb_build_dir>\ntbb_build_prefix=<tbb_build_prefix>\n-j<n>\n```\n\n----------------------------------------\n\nTITLE: Commented TensorFrame Project Configuration\nDESCRIPTION: Commented-out CMake code for building the TensorFrame project example. This section is disabled but shows how to link against the TensorFrame library and Threads library.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/examples/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n#### TensorFrame Project\n##set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${TF_EXAMPLE_DIR}/tensorframe)\n#add_executable(add ${TF_EXAMPLE_DIR}/tensorframe/add.cpp)\n#target_link_libraries(\n#  add TensorFrame Threads::Threads tf::default_settings\n#)\n```\n\n----------------------------------------\n\nTITLE: Configuring No-Vectorization Tensor Benchmarks\nDESCRIPTION: Sets up additional benchmarking targets with Eigen vectorization explicitly disabled when BTL_NOVEC is not set.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/libs/tensors/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n  if(NOT BTL_NOVEC)\n    btl_add_bench(btl_tensor_novec_linear main_linear.cpp OFF)\n    btl_add_bench(btl_tensor_novec_vecmat main_vecmat.cpp OFF)\n    btl_add_bench(btl_tensor_novec_matmat main_matmat.cpp OFF)\n    btl_add_target_property(btl_tensor_novec_linear COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=tensor_novec\")\n    btl_add_target_property(btl_tensor_novec_vecmat COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=tensor_novec\")\n    btl_add_target_property(btl_tensor_novec_matmat COMPILE_FLAGS \"-fno-exceptions -DEIGEN_DONT_VECTORIZE -DBTL_PREFIX=tensor_novec\")\n\n  endif(NOT BTL_NOVEC)\n\nendif (TENSOR_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Copying Each Script File using CMake Loop\nDESCRIPTION: Iterates through each script file and adds a custom command to copy it from the source directory to the build directory as part of the copy_scripts target.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nFOREACH(script_file ${script_files})\nADD_CUSTOM_COMMAND(\n  TARGET copy_scripts\n  POST_BUILD\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/${script_file} ${CMAKE_CURRENT_BINARY_DIR}/\n  ARGS\n)\nENDFOREACH(script_file)\n```\n\n----------------------------------------\n\nTITLE: TaskFlow Repository Configuration in Plaintext\nDESCRIPTION: Configuration metadata for the TaskFlow project repository, including the repository commit hash, node hash, branch name, and version tag information.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/.hg_archival.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nrepo: 8a21fd850624c931e448cbcfb38168cb2717c790\nnode: 323c052e17310984a40dda9426e0435bed7178fa\nbranch: 3.3\ntag: 3.3.7\n```\n\n----------------------------------------\n\nTITLE: Saving Eigen Source Directory in CMake\nDESCRIPTION: Adds a custom command to write the Eigen source directory path to a text file in the build directory. This allows the scripts to locate Eigen headers when needed.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nADD_CUSTOM_COMMAND(\n  TARGET copy_scripts\n  POST_BUILD\n  COMMAND echo \"${Eigen_SOURCE_DIR}\" > ${CMAKE_CURRENT_BINARY_DIR}/eigen_root_dir.txt\n  ARGS\n)\n```\n\n----------------------------------------\n\nTITLE: Complete TBB Source Integration Flow\nDESCRIPTION: Complete CMake code to download TBB source, build it, and integrate using both TBBGet and TBBBuild modules.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/tbb/cmake/README.rst#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(<path-to-tbb-cmake-modules>/TBBGet.cmake)\ninclude(<path-to-tbb-cmake-modules>/TBBBuild.cmake)\ntbb_get(TBB_ROOT tbb_root SOURCE_CODE)\ntbb_build(TBB_ROOT ${tbb_root} CONFIG_DIR TBB_DIR)\nfind_package(TBB <options>)\n```\n\n----------------------------------------\n\nTITLE: Configuring Line Styles for Libraries in Gnuplot\nDESCRIPTION: This snippet defines line styles for various libraries and frameworks in Gnuplot. It specifies the line width, line type, and color for each library, allowing for easy visual differentiation in plots.\nSOURCE: https://github.com/taskflow/taskflow/blob/master/3rd-party/eigen-3.3.7/bench/btl/data/perlib_plot_settings.txt#2025-04-22_snippet_0\n\nLANGUAGE: gnuplot\nCODE:\n```\neigen3 ;          with lines lw 4 lt 1 lc rgbcolor \"black\"\neigen2 ;          with lines lw 3 lt 1 lc rgbcolor \"#999999\"\nEigenBLAS ;       with lines lw 3 lt 3 lc rgbcolor \"#999999\"\neigen3_novec ;    with lines lw 2 lt 1 lc rgbcolor \"#999999\"\neigen3_nogccvec ; with lines lw 2 lt 2 lc rgbcolor \"#991010\"\nINTEL_MKL ;       with lines lw 3 lt 1 lc rgbcolor \"#ff0000\"\nATLAS ;           with lines lw 3 lt 1 lc rgbcolor \"#008000\"\ngmm ;             with lines lw 3 lt 1 lc rgbcolor \"#0000ff\"\nublas ;           with lines lw 3 lt 1 lc rgbcolor \"#00b7ff\"\nmtl4 ;            with lines lw 3 lt 1 lc rgbcolor \"#d18847\"\nblitz ;           with lines lw 3 lt 1 lc rgbcolor \"#ff00ff\"\nF77 ;             with lines lw 3 lt 3 lc rgbcolor \"#e6e64c\"\nOPENBLAS ;        with lines lw 3 lt 1 lc rgbcolor \"#C05600\"\nC ;               with lines lw 3 lt 3 lc rgbcolor \"#e6bd96\"\nACML ;            with lines lw 2 lt 3 lc rgbcolor \"#e6e64c\"\nblaze ;           with lines lw 3 lt 1 lc rgbcolor \"#ff00ff\"\n```"
  }
]