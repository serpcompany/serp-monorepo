[
  {
    "owner": "rdflib",
    "repo": "rdflib",
    "content": "TITLE: Importing Common RDF Namespaces in rdflib\nDESCRIPTION: This snippet imports common RDF namespaces from rdflib.namespace, allowing you to easily use standard RDF properties and classes.  It showcases examples using RDF.type, FOAF.knows, PROF.isProfileOf and SOSA.Sensor.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib.namespace import CSVW, DC, DCAT, DCTERMS, DOAP, FOAF, ODRL2, ORG, OWL, \\\n                               PROF, PROV, RDF, RDFS, SDO, SH, SKOS, SOSA, SSN, TIME, \\\n                               VOID, XMLNS, XSD\n\n    RDF.type\n    # == rdflib.term.URIRef(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\")\n\n    FOAF.knows\n    # == rdflib.term.URIRef(\"http://xmlns.com/foaf/0.1/knows\")\n\n    PROF.isProfileOf\n    # == rdflib.term.URIRef(\"http://www.w3.org/ns/dx/prof/isProfileOf\")\n\n    SOSA.Sensor\n    # == rdflib.term.URIRef(\"http://www.w3.org/ns/sosa/Sensor\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Parsing RDF Graph\nDESCRIPTION: This example demonstrates creating an RDFLib Graph object, parsing an RDF file from a URL, iterating through the triples, checking for triple existence and printing the number of triples in the graph. Finally, it serializes the graph into the Turtle format and prints it to the console.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/gettingstarted.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# Create a Graph\ng = Graph()\n\n# Parse in an RDF file hosted on the Internet\ng.parse(\"http://www.w3.org/People/Berners-Lee/card\")\n\n# Loop through each triple in the graph (subj, pred, obj)\nfor subj, pred, obj in g:\n    # Check if there is at least one triple in the Graph\n    if (subj, pred, obj) not in g:\n       raise Exception(\"It better be!\")\n\n# Print the number of \"triples\" in the Graph\nprint(f\"Graph g has {len(g)} statements.\")\n# Prints: Graph g has 86 statements.\n\n# Print out the entire Graph in the RDF Turtle format\nprint(g.serialize(format=\"turtle\"))\n```\n\n----------------------------------------\n\nTITLE: Adding Triples to an RDF Graph with rdflib\nDESCRIPTION: This snippet demonstrates how to add triples to an RDF graph using the `add` method in rdflib.  It creates a graph, binds a namespace, creates nodes, and then adds triples to the graph, representing relationships between the nodes.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal, BNode\nfrom rdflib.namespace import FOAF, RDF\n\ng = Graph()\ng.bind(\"foaf\", FOAF)\n\nbob = URIRef(\"http://example.org/people/Bob\")\nlinda = BNode()  # a GUID is generated\n\nname = Literal(\"Bob\")\nage = Literal(24)\n\ng.add((bob, RDF.type, FOAF.Person))\ng.add((bob, FOAF.name, name))\ng.add((bob, FOAF.age, age))\ng.add((bob, FOAF.knows, linda))\ng.add((linda, RDF.type, FOAF.Person))\ng.add((linda, FOAF.name, Literal(\"Linda\")))\n\nprint(g.serialize())\n```\n\n----------------------------------------\n\nTITLE: Loading RDF data and printing triples with RDFLib\nDESCRIPTION: This snippet demonstrates how to create an RDF graph using RDFLib, load RDF data from a URL, and iterate through the triples in the graph, printing each subject, predicate, and object.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib import Graph\ng = Graph()\ng.parse('http://dbpedia.org/resource/Semantic_Web')\n\nfor s, p, o in g:\n    print(s, p, o)\n```\n\n----------------------------------------\n\nTITLE: Preparing SPARQL Queries in RDFLib\nDESCRIPTION: This code demonstrates how to prepare a SPARQL query in RDFLib for more efficient execution. It uses the `prepareQuery` function to parse and translate the query once, and then reuses the prepared query object for multiple executions with different initial bindings. This avoids re-parsing the query each time it's executed.  Requires the rdflib library, FOAF namespace, and a pre-existing graph (foaf.rdf).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_sparql.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nq = prepareQuery(\n    \"SELECT ?s WHERE { ?person foaf:knows ?s .}\",\n    initNs = { \"foaf\": FOAF }\n)\n\ng = rdflib.Graph()\ng.parse(\"foaf.rdf\")\n\ntim = rdflib.URIRef(\"http://www.w3.org/People/Berners-Lee/card#i\")\n\nfor row in g.query(q, initBindings={'person': tim}):\n    print(row)\n```\n\n----------------------------------------\n\nTITLE: Creating Literals in rdflib\nDESCRIPTION: Examples of creating Literal objects in rdflib, including specifying datatypes and language tags.  It shows how to create a simple string literal and how to create literals with specific datatypes using the XSD namespace, and language tags.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/rdf_terms.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nname = Literal(\"Nicholas\")  # the name 'Nicholas', as a string\n    \nage = Literal(39, datatype=XSD.integer)  # the number 39, as an integer\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating RDF Data\nDESCRIPTION: This example demonstrates how to create an RDF Graph, create URIRef and Literal nodes, add triples to the graph, iterate over triples, and print them. It shows how to use namespaces, bind a namespace to a prefix, and serialize the graph in N3 format.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/gettingstarted.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, Literal, RDF, URIRef\n# rdflib knows about quite a few popular namespaces, like W3C ontologies, schema.org etc.\nfrom rdflib.namespace import FOAF , XSD\n\n# Create a Graph\ng = Graph()\n\n# Create an RDF URI node to use as the subject for multiple triples\ndonna = URIRef(\"http://example.org/donna\")\n\n# Add triples using store's add() method.\ng.add((donna, RDF.type, FOAF.Person))\ng.add((donna, FOAF.nick, Literal(\"donna\", lang=\"en\")))\ng.add((donna, FOAF.name, Literal(\"Donna Fales\")))\ng.add((donna, FOAF.mbox, URIRef(\"mailto:donna@example.org\")))\n\n# Add another person\ned = URIRef(\"http://example.org/edward\")\n\n# Add triples using store's add() method.\ng.add((ed, RDF.type, FOAF.Person))\ng.add((ed, FOAF.nick, Literal(\"ed\", datatype=XSD.string)))\ng.add((ed, FOAF.name, Literal(\"Edward Scissorhands\")))\ng.add((ed, FOAF.mbox, Literal(\"e.scissorhands@example.org\", datatype=XSD.anyURI)))\n\n# Iterate over triples in store and print them out.\nprint(\"--- printing raw triples ---\")\nfor s, p, o in g:\n    print((s, p, o))\n\n# For each foaf:Person in the store, print out their mbox property's value.\nprint(\"--- printing mboxes ---\")\nfor person in g.subjects(RDF.type, FOAF.Person):\n    for mbox in g.objects(person, FOAF.mbox):\n        print(mbox)\n\n# Bind the FOAF namespace to a prefix for more readable output\ng.bind(\"foaf\", FOAF)\n\n# print all the data in the Notation3 format\nprint(\"--- printing mboxes ---\")\nprint(g.serialize(format='n3'))\n```\n\n----------------------------------------\n\nTITLE: Namespace Creation in RDFLib (Python)\nDESCRIPTION: Demonstrates how to create URIs within a namespace using the `rdflib.namespace.Namespace` class. It shows both object attribute and dictionary notation for accessing elements within the namespace.  Highlights the ability to create elements that are not valid Python identifiers, such as those with spaces or reserved words, through dictionary notation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Namespace\n\nEX = Namespace(\"http://example.org/\")\nEX.Person  # a Python attribute for EX. This example is equivalent to rdflib.term.URIRef(\"http://example.org/Person\")\n\n# use dict notation for things that are not valid Python identifiers, e.g.:\nn['first%20name']  # as rdflib.term.URIRef(\"http://example.org/first%20name\")\n```\n\n----------------------------------------\n\nTITLE: Binding Namespaces to Prefixes (Python)\nDESCRIPTION: Illustrates how to bind namespaces to prefixes using the `rdflib.graph.Graph.bind` method.  This example shows how to bind both RDFLib-provided namespaces (like FOAF) and user-declared namespaces to prefixes within an RDF graph.  The resulting prefixes can be used when serializing RDF or parsing SPARQL queries.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, Namespace\nfrom rdflib.namespace import FOAF\n\nEX = Namespace(\"http://example.org/\")\n\ng = Graph()\ng.bind(\"foaf\", FOAF)  # bind an RDFLib-provided namespace to a prefix\ng.bind(\"ex\", EX)      # bind a user-declared namespace to a prefix\n```\n\n----------------------------------------\n\nTITLE: Adding triples to a graph with namespaces\nDESCRIPTION: This snippet demonstrates how to add a triple to an RDF graph using URIRef and Literal objects, incorporating namespace prefixes for properties and datatypes.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal\nfrom rdflib.namespace import FOAF, XSD\n\ng = Graph()\ng.add((\n    URIRef(\"http://example.com/person/nick\"),\n    FOAF.givenName,\n    Literal(\"Nick\", datatype=XSD.string)\n))\n```\n\n----------------------------------------\n\nTITLE: Querying RDF Multi-Graph\nDESCRIPTION: This code demonstrates how to parse and query a multi-graph using rdflib's Dataset class. It parses a Trig file and then iterates through the quads, printing the subject and graph for each quad where the predicate is rdf:type. It requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Dataset\nfrom rdflib.namespace import RDF\n\ng = Dataset()\ng.parse(\"demo.trig\")\n\nfor s, p, o, g in g.quads((None, RDF.type, None, None)):\n    print(s, g)\n```\n\n----------------------------------------\n\nTITLE: Using RDFLib namespaces\nDESCRIPTION: This snippet shows how to import and use common RDF namespaces in RDFLib to create URIRef objects. It demonstrates querying a graph for a specific value using a namespace-qualified property.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib.namespace import DC, DCTERMS, DOAP, FOAF, SKOS, OWL, RDF, RDFS, VOID, XMLNS, XSD\n```\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal\nfrom rdflib.namespace import RDFS, XSD\n\ng = Graph()\nsemweb = URIRef('http://dbpedia.org/resource/Semantic_Web')\ntype = g.value(semweb, RDFS.label)\n```\n\n----------------------------------------\n\nTITLE: Merging Graphs by Parsing into a Single Graph (rdflib)\nDESCRIPTION: This code snippet demonstrates the simplest way to merge RDF graphs in rdflib by parsing multiple input sources into a single graph instance. This method automatically assigns unique IDs to blank nodes during parsing, preventing collisions. The `input1` and `input2` variables are assumed to hold the paths or URLs to the RDF data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/merging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ngraph = Graph()\n\ngraph.parse(input1)\ngraph.parse(input2)\n```\n\n----------------------------------------\n\nTITLE: Creating RDF Nodes with rdflib\nDESCRIPTION: This snippet demonstrates how to create RDF nodes, including URIRefs, BNodes, and Literals, using the rdflib library. It covers creating literals from different Python data types and the use of Namespaces for convenient URIRef creation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import URIRef, BNode, Literal\n\nbob = URIRef(\"http://example.org/people/Bob\")\nlinda = BNode()  # a GUID is generated\n\nname = Literal(\"Bob\")  # passing a string\nage = Literal(24)  # passing a python int\nheight = Literal(76.5)  # passing a python float\n```\n\n----------------------------------------\n\nTITLE: Initializing Graph with BerkeleyDB Store in RDFlib (Python)\nDESCRIPTION: This code snippet demonstrates how to create an RDF graph using the BerkeleyDB store in RDFlib. The `Graph()` constructor is called with the `store` parameter set to \"BerkeleyDB\".\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_stores.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# use the BerkeleyDB Store\ngraph = Graph(store=\"BerkeleyDB\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Single Value with RDFLib\nDESCRIPTION: This code illustrates how to use the `value` method to retrieve a single value associated with a subject and predicate in an RDFLib graph. It retrieves Bob's name and retrieves the person who knows Bob, ensuring only one person is found or raising an exception.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_graphs.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# get any name of bob\nname = g.value(bob, FOAF.name)\n# get the one person that knows bob and raise an exception if more are found\nperson = g.value(predicate=FOAF.knows, object=bob, any=False)\n```\n\n----------------------------------------\n\nTITLE: Querying RDF Data with SPARQL\nDESCRIPTION: This example demonstrates how to query an RDF graph using SPARQL. It parses an RDF file from a URL, defines a SPARQL query to retrieve the 'name' of all foaf:Person instances, and then applies the query to the graph. It iterates through the results and prints the names.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/gettingstarted.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# Create a Graph, parse in Internet data\ng = Graph().parse(\"http://www.w3.org/People/Berners-Lee/card\")\n\n# Query the data in g using SPARQL\n# This query returns the 'name' of all ``foaf:Person`` instances\nq = \"\"\"\n        PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\n        SELECT ?name\n        WHERE {\n            ?p rdf:type foaf:Person .\n\n            ?p foaf:name ?name .\n        }\n    \"\"\"\n\n# Apply the query to the graph and iterate through results\nfor r in g.query(q):\n    print(r[\"name\"])\n\n# prints: Timothy Berners-Lee\n```\n\n----------------------------------------\n\nTITLE: Checking Triple Containment in RDFLib Graph\nDESCRIPTION: This code snippet demonstrates how to use the `in` operator to check if a specific triple exists within an RDFLib graph.  It imports necessary modules from RDFLib and then uses a URIRef and RDF.type to check for the existence of a specific triple, as well as an unbound triple, within the graph.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_graphs.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import URIRef\nfrom rdflib.namespace import RDF\n\nbob = URIRef(\"http://example.org/people/bob\")\nif (bob, RDF.type, FOAF.Person) in graph:\n    print(\"This graph knows that Bob is a person!\")\n\nif (bob, None, None) in graph:\n    print(\"This graph contains triples about Bob!\")\n```\n\n----------------------------------------\n\nTITLE: Using Namespaces in SPARQL Queries (Python)\nDESCRIPTION: Explains how to use namespaces in SPARQL queries executed with `rdflib.graph.Graph.query`. The `initNs` argument allows passing a dictionary of namespaces to be expanded in the query string.  If `initNs` is not provided, the namespaces registered with the graph's namespace manager are used.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib.namespace import FOAF\ngraph.query('SELECT * WHERE { ?p a foaf:Person }', initNs={'foaf': FOAF})\n```\n\n----------------------------------------\n\nTITLE: Querying RDF Graph with SPARQL in RDFLib\nDESCRIPTION: This code snippet demonstrates how to query an RDF graph using SPARQL with RDFLib. It imports the rdflib library, creates a Graph object, parses an RDF file, defines a SPARQL query to find names of people who know each other, executes the query, and iterates through the results to print the names.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_sparql.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport rdflib\ng = rdflib.Graph()\ng.parse(\"http://danbri.org/foaf.rdf#\")\n\nknows_query = \"\"\"\nSELECT DISTINCT ?aname ?bname\nWHERE {\n    ?a foaf:knows ?b .\n    ?a foaf:name ?aname .\n    ?b foaf:name ?bname .\n}\"\"\"\n    \nqres = g.query(knows_query)\nfor row in qres:\n    print(f\"{row.aname} knows {row.bname}\")\n```\n\n----------------------------------------\n\nTITLE: SPARQL String Manipulation\nDESCRIPTION: This SPARQL query demonstrates various string manipulation functions such as strlen, substr, ucase, lcase, strStarts, strEnds, contains, strbefore, strafter, encode_for_uri, concat, replace, and regex.  It selects the results of these string operations and binds them to variables.  It also uses `langMatches` to filter based on language tags.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functions_on_strings.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nselect\n(strlen(\"chat\") as ?strlen)\n(substr(\"foobar\", 4) as ?substr)\n(ucase(\"foo\") as ?ucase)\n(lcase(\"FOO\") as ?lcase)\n(strStarts(\"foobar\", \"foo\") as ?strstarts)\n(strEnds(\"foobar\", \"bar\") as ?strends)\n(contains(\"foobar\", \"bar\") as ?contains)\n(strbefore(\"abc\",\"b\") as ?strbefore)\n(strafter(\"abc\",\"b\") as ?strafter)\n(encode_for_uri(\"Los Angeles\") as ?encode_for_uri)\n(concat(\"foo\"@en, \"bar\"@en) as ?concat)\n(replace(\"abcd\", \"b\", \"Z\") as ?replace)\n(regex(substr(\"foobar\", 4), \"bar\", \"bar\") as ?regex)\n(regex(substr(\"foobar\", 4, 1), \"b\", \"b\") as ?regex2)\nwhere {\n\t?s ?p ?o .\n    FILTER langMatches(lang(?o), \"EN\" )\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Initializing a URIRef in rdflib\nDESCRIPTION: Demonstrates how to create URIRef objects using the rdflib library. It shows how to initialize URIRef with different values including an empty string and a URL. Also, it shows the N3 representation of URIRef.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/rdf_terms.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from rdflib import URIRef\n>>> uri = URIRef()  # doctest: +SKIP\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: __new__() missing 1 required positional argument: 'value'\n>>> uri = URIRef('')\n>>> uri\nrdflib.term.URIRef('')\n>>> uri = URIRef('http://example.com')\n>>> uri\nrdflib.term.URIRef('http://example.com')\n>>> uri.n3()\n'<http://example.com>'\n```\n\n----------------------------------------\n\nTITLE: Query Political Mentions with SPARQL\nDESCRIPTION: This SPARQL query retrieves information about political mentions, including person labels, party labels, document names, and mention details. It filters results based on person labels and orders them by mention. The query assumes the existence of ontologies such as 'pub' and 'publishing'.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__filter.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX pub: <http://ontology.ontotext.com/taxonomy/>\nPREFIX publishing: <http://ontology.ontotext.com/publishing#>\n\nselect ?personLabel ?party_label ?document ?mention where {\n    ?mention publishing:hasInstance ?person .\n    ?document publishing:containsMention ?mention .\n    ?person pub:memberOfPoliticalParty ?party .\n    ?person pub:preferredLabel ?personLabel .\n    ?party pub:hasValue ?value .\n    ?value pub:preferredLabel ?party_label .\n\n    filter((?personLabel = \"Barack Obama\"@en || ?personLabel = \"Judy Chu\"@en) && ?personLabel = \"Michelle Obama\"@en )\n} order by ?mention\n```\n\n----------------------------------------\n\nTITLE: SPARQL Update Queries with RDFLib\nDESCRIPTION: This code snippet shows how to perform SPARQL update queries with RDFLib. It demonstrates inserting and deleting triples within an RDF graph using the `update` method. The example includes adding a new triple, changing the type of a resource, and querying the graph before and after each update.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_sparql.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# Create a Graph, add in some test data\ng = Graph()\ng.parse(\n    data='''\n        <x:> a <c:> .\n        <y:> a <c:> .\n    ''',\n    format=\"turtle\"\n)\n\n# Select all the things (s) that are of type (rdf:type) c:\nqres = g.query(\"\"\"SELECT ?s WHERE { ?s a <c:> }\"\"\")\n\nfor row in qres:\n    print(f\"{row.s}\")\n# prints:\n# x:\n# y:\n\n# Add in a new triple using SPARQL UPDATE\ng.update(\"\"\"INSERT DATA { <z:> a <c:> }\"\"\")\n\n# Select all the things (s) that are of type (rdf:type) c:\nqres = g.query(\"\"\"SELECT ?s WHERE { ?s a <c:> }\"\"\")\n\nprint(\"After update:\")\nfor row in qres:\n    print(f\"{row.s}\")\n# prints:\n# x:\n# y:\n# z:\n\n# Change type of <y:> from <c:> to <d:>\ng.update(\"\"\"\n         DELETE { <y:> a <c:> }\n         INSERT { <y:> a <d:> }\n         WHERE { <y:> a <c:> }\n         \"\"\")\nprint(\"After second update:\")\nqres = g.query(\"\"\"SELECT ?s ?o WHERE { ?s a ?o }\"\"\")\nfor row in qres:\n    print(f\"{row.s} a {row.o}\")\n# prints:\n# x: a c:\n# z: a c:\n# y: a d:\n```\n\n----------------------------------------\n\nTITLE: Parsing RDF Data from URL\nDESCRIPTION: This code shows how to parse RDF data directly from a URL using rdflib. It creates a Graph object, parses the data from the specified URL, and then prints the number of triples in the graph. It requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"http://www.w3.org/People/Berners-Lee/card\")\nprint(len(g))\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query to Extract Person, Party, and Document Relations\nDESCRIPTION: This SPARQL query retrieves information about people, their political parties, and documents containing mentions of them. It uses prefixes to shorten URIs and binds the party label to the `party_name` variable for easier access. The results are ordered by mention.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__extend.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX pub: <http://ontology.ontotext.com/taxonomy/>\nPREFIX publishing: <http://ontology.ontotext.com/publishing#>\n\nselect ?personLabel ?party_name ?document (?mention as ?men) where {\n    ?mention publishing:hasInstance ?person .\n    ?document publishing:containsMention ?mention .\n    ?person pub:memberOfPoliticalParty ?party .\n    ?person pub:preferredLabel ?personLabel .\n    ?party pub:hasValue ?value .\n    ?value pub:preferredLabel ?party_label .\n    Bind(?party_label as ?party_name)\n} order by ?mention\n```\n\n----------------------------------------\n\nTITLE: Parsing RDF Data from File\nDESCRIPTION: This code demonstrates how to parse an RDF file (demo.nt) using rdflib. It creates a Graph object, parses the file, and then prints the number of triples in the graph and each statement in the graph. It requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"demo.nt\")\n\nprint(len(g))\n# prints: 2\n\nimport pprint\nfor stmt in g:\n    pprint.pprint(stmt)\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Document Mentions of People and Parties\nDESCRIPTION: This SPARQL query retrieves documents, mentions, person labels, and party labels based on relationships defined by prefixes such as `pub`, `publishing`, and `xsd`. It identifies documents containing mentions of specific individuals and extracts information about their political party affiliations. The query targets two specific people: Judy Chu and Barack Obama.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_integration__complex_query1.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\n# Prefixes\nPREFIX pub: <http://ontology.ontotext.com/taxonomy/>\nPREFIX publishing: <http://ontology.ontotext.com/publishing#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n\nselect ?document ?mention ?personLabel ?party_label {\n    {\n        select *  {\n            ?document publishing:containsMention ?mention .\n            ?person pub:memberOfPoliticalParty ?party .\n            ?person pub:preferredLabel ?personLabel .\n            ?party pub:hasValue ?value .\n            ?value pub:preferredLabel ?party_label .\n            filter(?personLabel = \"Judy Chu\"@en)\n\n            {\n                Select * where {\n                    ?mention publishing:hasInstance ?person .\n\n                }\n            }\n        }\n    }\n    union\n    {\n        select * where {\n            ?mention publishing:hasInstance ?person .\n            ?document publishing:containsMention ?mention .\n            ?person pub:memberOfPoliticalParty / pub:hasValue / pub:preferredLabel ?party_label .\n            ?person pub:preferredLabel ?personLabel .\n            filter(?personLabel = \"Barack Obama\"@en)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Triple Pattern Matching in RDFLib\nDESCRIPTION: This code shows how to perform basic triple pattern matching using the `triples` method of an RDFLib graph. It demonstrates how to find all subjects of a specific type and all subjects of any type, and how to create a new graph containing triples related to a specific subject. It requires `g` to be populated RDF Graph, `bob` a URIRef\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_graphs.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ng.parse(\"some_foaf.ttl\")\n# find all subjects (s) of type (rdf:type) person (foaf:Person)\nfor s, p, o in g.triples((None, RDF.type, FOAF.Person)):\n    print(f\"{s} is a person\")\n\n# find all subjects of any type\nfor s, p, o in g.triples((None,  RDF.type, None)):\n    print(f\"{s} is a {o}\")\n\n# create a graph\nbobgraph = Graph()\n# add all triples with subject 'bob'\nbobgraph += g.triples((bob, None, None))\n```\n\n----------------------------------------\n\nTITLE: Parsing RDF data with MIME type in RDFLib\nDESCRIPTION: This code snippet illustrates how to parse RDF data from a URL by specifying the format using a MIME type. In this example, the MIME type 'application/rdf+xml' is used to indicate that the data is in RDF/XML format. The `graph.parse` method automatically uses the appropriate parser based on the provided MIME type.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_parsers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngraph.parse(my_url, format='application/rdf+xml')\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for RDF Types and Counts\nDESCRIPTION: This SPARQL query retrieves RDF types, counts their occurrences, groups the results by the type, orders the results by type, and limits the output to the first 50. It uses the `rdf:type` property to determine the types and counts the distinct values of `?y` for each type `?x`.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_solution_modifiers__slice.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect reduced ?x (count(distinct ?y) as ?cnt)  where\n{\n    ?x (rdf:type|^rdf:type) ?y\n}\ngroup by ?x\norder by ?x\nlimit 50\n```\n\n----------------------------------------\n\nTITLE: Working with Functional Properties in RDFLib (Python)\nDESCRIPTION: Demonstrates how to use `rdflib.graph.Graph.value` and `rdflib.graph.Graph.set` to work with functional properties in RDF graphs. It shows how to retrieve and update single values for properties that should only occur once for a given resource. Requires rdflib and its dependencies.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/utilities.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal, BNode\nfrom rdflib.namespace import FOAF, RDF\n\ng = Graph()\ng.bind(\"foaf\", FOAF)\n\n# Add demo data\nbob = URIRef(\"http://example.org/people/Bob\")\ng.add((bob, RDF.type, FOAF.Person))\ng.add((bob, FOAF.name, Literal(\"Bob\")))\ng.add((bob, FOAF.age, Literal(38)))\n\n# To get a single value, use 'value'\nprint(g.value(bob, FOAF.age))\n# prints: 38\n\n# To change a single of value, use 'set'\ng.set((bob, FOAF.age, Literal(39)))\nprint(g.value(bob, FOAF.age))\n# prints: 39\n```\n\n----------------------------------------\n\nTITLE: Aggregate RDF Triples with SPARQL\nDESCRIPTION: This SPARQL query retrieves RDF triples, filters them based on the subject being equal to rdf:type, and then performs several aggregation functions: sum, count, min, max, avg, sample, and group_concat. It returns a single result due to the 'LIMIT 1' clause.  It requires an RDF triplestore as the data source.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__aggregate_join.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect\n(sum(?s) as ?sum)\n(count(distinct ?s) as ?count)\n(min(?s) as ?min)\n(max(?s) as ?max)\n(avg(?s) as ?avg)\n(sample(?s) as ?sample)\n(GROUP_CONCAT(?s;SEPARATOR=\"|\") AS ?group_concat)\nwhere {\n\t?s ?p ?o .\n    filter(?s = rdf:type)\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Setting Functional Properties with rdflib\nDESCRIPTION: This snippet demonstrates how to use the `set` method in rdflib to set a single value for a property, ensuring that only one value is associated with a resource for that property.  It also uses the `value` method to query the graph for the value of a specific property.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal\nfrom rdflib.namespace import FOAF\n\ng = Graph()\nbob = URIRef(\"http://example.org/people/Bob\")\n\ng.add((bob, FOAF.age, Literal(42)))\nprint(f\"Bob is {g.value(bob, FOAF.age)}\")\n# prints: Bob is 42\n\ng.set((bob, FOAF.age, Literal(43)))  # replaces 42 set above\nprint(f\"Bob is now {g.value(bob, FOAF.age)}\")\n# prints: Bob is now 43\n```\n\n----------------------------------------\n\nTITLE: Creating URIRefs with rdflib Namespaces\nDESCRIPTION: This snippet demonstrates the use of rdflib's Namespace class for creating multiple URIRefs with a common prefix. It shows how to define a namespace and then access URIRefs within that namespace.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Namespace\n\nn = Namespace(\"http://example.org/people/\")\n\nn.bob  # == rdflib.term.URIRef(\"http://example.org/people/bob\")\nn.eve  # == rdflib.term.URIRef(\"http://example.org/people/eve\")\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Title/Label\nDESCRIPTION: This SPARQL query retrieves either the dc:title or rdfs:label property of a resource identified as :book1.  It selects the value and binds it to the variable ?displayString, and limits the number of results to 100. It depends on the prefixes dc, rdfs and a custom prefix :.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__alternative_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX : <http://example.org/book/>\n\nselect * where {\n\t{ :book1 dc:title|rdfs:label ?displayString }\n} limit 100\n```\n\n----------------------------------------\n\nTITLE: Querying Subjects with RDFLib\nDESCRIPTION: This snippet demonstrates how to retrieve all subjects in an RDFLib graph that have a specific predicate and object using the `subjects` method. In this example, it retrieves all subjects that are of type `FOAF.Person`.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_graphs.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor person in g.subjects(RDF.type, FOAF.Person):\n    print(\"{} is a person\".format(person))\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Subquery for Minimum Name\nDESCRIPTION: This SPARQL query selects entities related to 'ex:alice' via the 'ex:knows' property and finds the minimum name associated with each selected entity using a subquery and aggregation. The query uses the `MIN` function to find the minimum name and `GROUP BY` to group the results by the selected entity.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__join.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX ex: <http://people.example/>\nSELECT ?select ?minName\nWHERE {\n    ex:alice ex:knows ?select .\n    {\n        SELECT (MIN(?name) AS ?minName) ?select\n        WHERE {\n            ?select ex:name ?name .\n        } GROUP BY ?select\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding namespaces to prefixes for serialization\nDESCRIPTION: This snippet demonstrates how to bind namespaces to prefixes in an RDF graph for more compact serialization formats like Turtle. This allows for shorter URIs in the output.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib.namespace import FOAF, XSD\n\ng.bind(\"foaf\", FOAF)\ng.bind(\"xsd\", XSD)\n```\n\nLANGUAGE: Python\nCODE:\n```\nprint(g.serialize(format=\"turtle\"))\n```\n\n----------------------------------------\n\nTITLE: Serializing a graph to RDF/XML with a mime-type in RDFLib\nDESCRIPTION: This code snippet shows how to serialize an RDFLib graph to RDF/XML format by specifying the mime-type for the 'format' parameter. The graph is serialized and sent to the provided URL.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_serializers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngraph.serialize(my_url, format='application/rdf+xml')\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Hashing and Data Retrieval\nDESCRIPTION: This SPARQL query calculates the MD5, SHA1, SHA256, SHA384, and SHA512 hash values of the string \"abc\" and retrieves one triple from the RDF graph. It uses the built-in SPARQL hashing functions and limits the result set to a single triple. No external dependencies are required as it utilizes standard SPARQL functions.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__hash_functions.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nselect\n(md5(\"abc\") as ?md5)\n(sha1(\"abc\") as ?sha1)\n(SHA256(\"abc\") as ?SHA256)\n(SHA384(\"abc\") as ?SHA384)\n(SHA512(\"abc\") as ?SHA512)\nwhere {\n\t?s ?p ?o .\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Parsing RDF data with format specifier in RDFLib\nDESCRIPTION: This code snippet demonstrates how to parse RDF data from a URL using a specific format (N3 in this case) with RDFLib's `graph.parse` method. It shows a basic usage pattern for utilizing the built-in parsers to load RDF data into a graph object.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_parsers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ngraph.parse(my_url, format='n3')\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with FROM NAMED\nDESCRIPTION: This SPARQL query retrieves mailbox, nickname, and personal profile document information from named graphs. It uses FROM NAMED clauses to specify the graphs to query and GRAPH patterns to access data within those graphs. Prefixes are used to simplify URI references, specifically data, foaf, and rdfs namespaces.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__graph.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX  data:  <http://example.org/foaf/>\nPREFIX  foaf:  <http://xmlns.com/foaf/0.1/>\nPREFIX  rdfs:  <http://www.w3.org/2000/01/rdf-schema#>\n\nSELECT ?mbox ?nick ?ppd\nFROM NAMED <http://example.org/foaf/aliceFoaf>\nFROM NAMED <http://example.org/foaf/bobFoaf>\nWHERE\n{\n    GRAPH data:aliceFoaf\n    {\n        ?alice foaf:mbox <mailto:alice@work.example> ;\n               foaf:knows ?whom .\n        ?whom  foaf:mbox ?mbox ;\n               rdfs:seeAlso ?ppd .\n        ?ppd  a foaf:PersonalProfileDocument .\n    } .\n    GRAPH ?ppd\n    {\n        ?w foaf:mbox ?mbox ;\n           foaf:nick ?nick\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Graph with Default Memory Store in RDFlib (Python)\nDESCRIPTION: This code snippet demonstrates how to create an RDF graph using the default memory store in RDFlib. The `Graph()` constructor is called without specifying a store, which defaults to the `Memory` store.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_stores.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# use the default memory Store\ngraph = Graph()\n```\n\n----------------------------------------\n\nTITLE: Parsing RDF Data from a String (Python)\nDESCRIPTION: Demonstrates how to parse RDF data directly from a string using the `data` parameter of the `parse` method in RDFLib.  This allows you to create RDF graphs from string literals. Requires rdflib and its dependencies.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/utilities.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng = Graph().parse(data=\"<a:> <p:> <p:>.\")\nfor r in g.triples((None, None, None)):\n    print(r)\n# prints: (rdflib.term.URIRef('a:'), rdflib.term.URIRef('p:'), rdflib.term.URIRef('p:'))\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Blank Node\nDESCRIPTION: This SPARQL query uses a blank node to find entities connected through the properties :p1 and :p2. It selects the values of variables ?x and ?y, where a blank node is connected to ?x via the :p1 predicate, and that same blank node is connected to ?y via the :p2 predicate. The prefixes must be defined or available in the SPARQL engine's configuration.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__bnode_subject.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX : <http://example.org/>\nSELECT ?x ?y WHERE {\n[ :p1 ?x ] :p2 ?y .\n}\n```\n\n----------------------------------------\n\nTITLE: Re-binding Namespaces (Python)\nDESCRIPTION: Illustrates how to override default namespace bindings with user-preferred prefixes.  Even when a namespace binding strategy is employed, users can re-bind namespaces to different prefixes using the `bind` method with the `override=True` parameter. This is useful for using custom prefixes for well-known namespaces.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\nfrom rdflib.namespace import GEO  # imports GeoSPARQL's namespace\n\ng = Graph(bind_namespaces=\"rdflib\")  # binds GeoSPARQL's namespace to prefix 'geo'\n\ng.bind('geosp', GEO, override=True)\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Arithmetic and Filter\nDESCRIPTION: This SPARQL query calculates an arithmetic expression and filters results based on boolean conditions. The query selects the result of the expression `2*4 -5 + 3` as `?test_arithmetics` and applies a filter `2=2 && 1=1` before limiting the output to 1 result.  It depends on the existence of RDF data with subject, predicate, and object (?s ?p ?o).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_operators__conditional_and.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect (2*4 -5 + 3 as ?test_arithmetics) where {\n\t?s ?p ?o .\n    filter(2=2 && 1=1)\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Opening and Using BerkeleyDB Store with Identifier in RDFLib (Python)\nDESCRIPTION: This example showcases how to open a BerkeleyDB store using a specific identifier. It creates a Graph instance with the 'BerkeleyDB' store and an identifier 'mygraph'. The store is then opened, some data is parsed into the graph using the Turtle format, and finally, the store is closed to release resources.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persistence.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngraph = Graph('BerkeleyDB', identifier='mygraph')\n\n# first time create the store:\ngraph.open('/home/user/data/myRDFLibStore', create=True)\n   \n# work with the graph: \ndata = \"\"\"\n          PREFIX : <https://example.org/>\n\n          :a :b :c .\n          :d :e :f .\n          :d :g :h .\n          \"\"\"\ngraph.parse(data=data, format=\"ttl\")\n\n# when done!\ngraph.close()\n```\n\n----------------------------------------\n\nTITLE: SPARQL String Concatenation Query\nDESCRIPTION: This SPARQL query demonstrates string concatenation using the `concat` function. It concatenates the string representation of the variable '?a' with the concatenated string literals 'foo'@en and 'bar'@en. The result is aliased as '?nested_concat'. The query selects this concatenated value where '?a' has an rdf:value and groups by '?a'.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__group_and_nested_concat.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nSELECT\n(concat(str(?a), concat(\"foo\"@en, \"bar\"@en)) as ?nested_concat)\nWHERE {\n  ?a rdf:value ?val .\n} GROUP BY ?a\n```\n\n----------------------------------------\n\nTITLE: Serializing a graph to N3 format in RDFLib\nDESCRIPTION: This code snippet demonstrates how to serialize an RDFLib graph to N3 format using the `serialize` method. The 'n3' format specifier is passed as an argument.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_serializers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint graph.serialize(format='n3')\n```\n\n----------------------------------------\n\nTITLE: Setting Namespace Binding Strategies (Python)\nDESCRIPTION: Demonstrates how to set namespace binding strategies using the `bind_namespaces` parameter in `rdflib.graph.Graph` and `rdflib.namespace.NamespaceManager`. This parameter controls which namespaces are automatically bound to prefixes when a graph or namespace manager is created.  Valid strategies include 'core', 'rdflib', and 'none'.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\nfrom rdflib.namespace import NamespaceManager\n\ng = Graph(bind_namespaces=\"rdflib\")  # bind via Graph\n\ng2 = Graph()\nnm = NamespaceManager(g2, bind_namespaces=\"rdflib\")  # bind via NamespaceManager\n```\n\n----------------------------------------\n\nTITLE: Aggregate RDF data with SPARQL\nDESCRIPTION: This SPARQL query calculates the sum of ?val and counts the occurrences of ?a, then extracts a substring of ?a, grouping the results by ?a.  It assumes that ?a is an RDF subject with a predicate rdf:value and a corresponding ?val.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__group_and_substr.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nSELECT\n(SUM(?val) AS ?sum)\n(COUNT(?a) AS ?count)\n(SUBSTR(?a, 4, 1) as ?a_substr)\nWHERE {\n  ?a rdf:value ?val .\n} GROUP BY ?a\n```\n\n----------------------------------------\n\nTITLE: Using an Empty Prefix in SPARQL (SPARQL)\nDESCRIPTION: Illustrates how to use an empty prefix in SPARQL queries to set a default namespace. This is achieved by using a `PREFIX` directive with no prefix specified, followed by the namespace URI enclosed in angle brackets.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_6\n\nLANGUAGE: sparql\nCODE:\n```\nPREFIX : <http://xmlns.com/foaf/0.1/>\n```\n\n----------------------------------------\n\nTITLE: DELETE Request for Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP DELETE request to remove an existing graph at the specified URL (/person/2.ttl). The expected response is 200 OK, indicating successful deletion.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_9\n\nLANGUAGE: HTTP\nCODE:\n```\nDELETE /person/2.ttl HTTP/1.1\nHost: $HOST$\n```\n\n----------------------------------------\n\nTITLE: Initializing Graph with BerkeleyDB Store in RDFLib (Python)\nDESCRIPTION: This snippet demonstrates how to initialize an RDFLib Graph with the BerkeleyDB store. It imports the Graph class from rdflib and creates a Graph instance using the 'BerkeleyDB' store identifier. This sets up the graph to use BerkeleyDB for storing RDF data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persistence.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ngraph = Graph(store='BerkeleyDB')\n```\n\n----------------------------------------\n\nTITLE: HEAD Request on an Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP HEAD request to retrieve metadata about an existing graph at the specified URL (/person/1.ttl). The expected response is 200 OK, with the Content-Type header indicating the graph's format.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_20\n\nLANGUAGE: HTTP\nCODE:\n```\nHEAD /person/1.ttl HTTP/1.1\nHost: $HOST$\n```\n\n----------------------------------------\n\nTITLE: Querying FOAF data using SPARQL\nDESCRIPTION: This SPARQL query retrieves the names of people known (directly or indirectly through the knows relationship) by someone with the email address alice@example. It uses the FOAF vocabulary and limits the results to a maximum of 100.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__one_or_more_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nselect * where\n{\n    ?x foaf:mbox <mailto:alice@example> .\n    ?x foaf:knows+/foaf:name ?name .\n}\nlimit 100\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Friends of Friends\nDESCRIPTION: This SPARQL query retrieves information about individuals who are two degrees of separation away from someone with the email address 'alice@example'. It selects all variables, finds individuals with the specified email, traverses the 'knows' relationship twice, and extracts the name of the person at the end of the path. The query limits the results to 100 entries.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__sequence_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nselect * where\n  {\n    ?x foaf:mbox <mailto:alice@example> .\n    ?x foaf:knows/foaf:knows/foaf:name ?name .\n  }\nlimit 100\n```\n\n----------------------------------------\n\nTITLE: PUT Request for Updating Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP PUT request to update an existing graph at /person/1.ttl. The request includes a modified Turtle representation of the graph. The expected response is 200 OK, indicating successful update of the resource.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_2\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT /person/1.ttl HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n<http://$HOST$/person/1> a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:fn \"Jane Doe\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Creating LangString Literals in rdflib\nDESCRIPTION: Demonstrates creating langString literals in rdflib, which are strings with language tags.  It provides examples in English and Polish.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/rdf_terms.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nname = Literal(\"Nicholas\", lang=\"en\")  # the name 'Nicholas', as an English string\nimie = Literal(\"Mikołaj\", lang=\"pl\")  # the Polish version of the name 'Nicholas'\n```\n\n----------------------------------------\n\nTITLE: GET Request of Newly Created Graph via POST\nDESCRIPTION: This snippet demonstrates an HTTP GET request to retrieve the graph created in the previous POST request to the $GRAPHSTORE$ URL, using the $NEWPATH$ URL (Location header from previous POST). The expected response is 200 OK, with the Turtle representation of the graph in the response body.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_17\n\nLANGUAGE: HTTP\nCODE:\n```\nGET $NEWPATH$ HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n[]  a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:given-name \"Alice\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Querying Dublin Core Metadata with SPARQL\nDESCRIPTION: This SPARQL query retrieves the title and author of books from an RDF graph. It uses the `dc10` and `dc11` prefixes for Dublin Core versions 1.0 and 1.1, respectively. The `UNION` clause ensures that results are returned regardless of which version of Dublin Core is used in the data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__union.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX dc10:  <http://purl.org/dc/elements/1.0/>\nPREFIX dc11:  <http://purl.org/dc/elements/1.1/>\nSELECT ?title ?author\nWHERE  {\n    {\n        ?book dc10:title ?title .\n        ?book dc10:creator ?author\n    }\n    UNION\n    {\n        ?book dc11:title ?title .\n        ?book dc11:creator ?author\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Remote SPARQL Endpoint with RDFLib\nDESCRIPTION: This snippet demonstrates how to query a remote SPARQL endpoint using the SERVICE keyword in RDFLib. It creates a graph, defines a SPARQL query that uses the SERVICE keyword to query DBPedia, executes the query, and prints the results.  It requires the `rdflib` library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_sparql.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport rdflib\n\ng = rdflib.Graph()\nqres = g.query(\n    \"\"\"\n    SELECT ?s\n    WHERE {\n      SERVICE <https://dbpedia.org/sparql> {\n        ?s a ?o .\n      }\n    }\n    LIMIT 3\n    \"\"\"\n)\n\nfor row in qres:\n    print(row.s)\n```\n\n----------------------------------------\n\nTITLE: GET Request for Empty Graph\nDESCRIPTION: This snippet retrieves the content of a graph previously created as empty via a PUT operation. The response should be 200 OK with an empty body.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_8\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/2.ttl HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query to Select Given Names\nDESCRIPTION: This SPARQL query retrieves given names (?givenName) from an RDF graph, utilizing the FOAF and Dublin Core vocabularies.  It includes optional clauses to retrieve date and datetime values and a filter to ensure a date value exists for the retrieved entities. The query expects an RDF graph as input and outputs a list of given names.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__left_join.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX dc:   <http://purl.org/dc/elements/1.1/>\nPREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>\nSELECT ?givenName\nWHERE {\n    ?x foaf:givenName  ?givenName .\n    OPTIONAL {\n        ?x dc:date ?date\n    } .\n    OPTIONAL {\n        ?x dc:datetime ?datetime\n    } .\n    FILTER ( bound(?date) )\n}\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Negated Path\nDESCRIPTION: This SPARQL query retrieves subjects (?x) and objects (?y) where ?x is *not* related to ?y through rdf:type or its inverse. It utilizes the negated path feature (!(rdf:type|^rdf:type)). The query limits the result set to 100 entries.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__negated_property_set.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect * where\n{\n    ?x !(rdf:type|^rdf:type) ?y\n}\nlimit 100\n```\n\n----------------------------------------\n\nTITLE: Incorrect Graph Merging using Set Operations (rdflib)\nDESCRIPTION: This code demonstrates an incorrect way to merge RDF graphs using the `+` operator. This method can lead to collisions of blank nodes because it assumes shared blank node IDs, which is generally not the case when merging data from different sources. `input1` and `input2` are assumed to be paths or URLs to RDF data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/merging.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng1 = Graph()\ng1.parse(input1)\n\ng2 = Graph()\ng2.parse(input2)\n\ngraph = g1 + g2\n```\n\n----------------------------------------\n\nTITLE: Querying RDF Data without a Property (SPARQL)\nDESCRIPTION: This SPARQL query retrieves all triples (?s ?p ?o) where the subject (?s) does *not* have a 'citing:valid_from' property. It uses a `FILTER NOT EXISTS` clause to exclude triples based on the existence of this property. The `citing` prefix needs to be defined for this query to function correctly.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functional_forms_not_exists.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX citing: <https://github.com/GreenfishK/DataCitation/citing/>\n\nselect ?s ?p ?o {\n\t?s ?p ?o .\n    filter not exists {?s citing:valid_from ?valid_from} .\n}\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Book Details\nDESCRIPTION: This SPARQL query retrieves book details (title and price) using defined prefixes. It selects the book, title, and price, filtering by conditions such as title and price specified in the VALUES clause. The query uses prefixes 'dc', ':', and 'ns' to define the namespaces for Dublin Core, a custom namespace, and a general namespace, respectively.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_other__values.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX dc:   <http://purl.org/dc/elements/1.1/>\nPREFIX :     <http://example.org/book/>\nPREFIX ns:   <http://example.org/ns#>\n\nSELECT ?book ?title ?price\n{\n    ?book dc:title ?title ;\n          ns:price ?price .\n    VALUES (?book ?title)\n    {\n        (UNDEF \"SPARQL Tutorial\")\n        (:book2 UNDEF)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Literals with Custom Datatypes in rdflib\nDESCRIPTION: Demonstrates creating literals with custom datatypes using a custom IRI for the datatype.  It uses the GeoSPARQL example with a geoJSONLiteral.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/rdf_terms.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nGEO = Namespace(\"http://www.opengis.net/ont/geosparql#\")\n    \ngeojson_geometry = Literal(\n        '''{\"type\": \"Point\", \"coordinates\": [-83.38,33.95]}''',\n        datatype=GEO.geoJSONLiteral\n```\n\n----------------------------------------\n\nTITLE: Defining new namespaces and querying objects\nDESCRIPTION: This snippet demonstrates how to define a new namespace using the Namespace class and use it to query a graph for specific objects based on a subject and predicate. It filters the results based on language.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib import Graph, Namespace, URIRef\n\ndbpedia = Namespace('http://dbpedia.org/ontology/')\n\nabstracts = list(x for x in g.objects(semweb, dbpedia['abstract']) if x.language=='en')\n```\n\n----------------------------------------\n\nTITLE: Serializing RDF Data to String\nDESCRIPTION: This code demonstrates how to parse RDF data from a URL and serialize it to a string in RDF/XML format.  It creates a Graph object, parses data from the specified URL, and then serializes the graph to a string which is assigned to the variable `v`. It requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"http://www.w3.org/People/Berners-Lee/card\")\nv = g.serialize(format=\"xml\")\n```\n\n----------------------------------------\n\nTITLE: Removing Triples from an RDF Graph with rdflib\nDESCRIPTION: This snippet demonstrates how to remove triples from an RDF graph using the `remove` method in rdflib. It shows how to remove all triples about a specific subject by leaving the predicate and object unspecified.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ng.remove((bob, None, None))  # remove all triples about bob\n```\n\n----------------------------------------\n\nTITLE: Serializing RDF Data to File\nDESCRIPTION: This code demonstrates how to parse RDF data from a URL and serialize it to a file using the turtle format. It creates a Graph object, parses data from the specified URL, and then serializes the graph to a file named tbl.ttl. It requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\ng = Graph()\ng.parse(\"http://www.w3.org/People/Berners-Lee/card\")\ng.serialize(destination=\"tbl.ttl\")\n```\n\n----------------------------------------\n\nTITLE: Serializing RDF Terms to N3 Format (Python)\nDESCRIPTION: Demonstrates how to serialize RDF terms (URIRef, Literal) to N3 format using the `n3()` method. This provides a readable representation of terms, especially when used with namespace bindings.  Requires rdflib and its dependencies.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/utilities.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal\nfrom rdflib.namespace import FOAF\n\n# A URIRef\nperson = URIRef(\"http://xmlns.com/foaf/0.1/Person\")\nprint(person.n3())\n# prints: <http://xmlns.com/foaf/0.1/Person>\n\n# Simplifying the output with a namespace prefix:\ng = Graph()\ng.bind(\"foaf\", FOAF)\n\nprint(person.n3(g.namespace_manager))\n# prints foaf:Person\n\n# A typed literal\nl = Literal(2)\nprint(l.n3())\n# prints \"2\"^^<http://www.w3.org/2001/XMLSchema#integer>\n\n# Simplifying the output with a namespace prefix\n# XSD is built in, so no need to bind() it!\nl.n3(g.namespace_manager)\n# prints: \"2\"^^xsd:integer\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with IF, COALESCE and Filters\nDESCRIPTION: This SPARQL query retrieves data based on foaf:givenName and dc:date properties. It uses the IF function to conditionally assign a value to ?givenName2 based on the value of ?givenName. The COALESCE function handles potential division-by-zero errors. The query also employs OPTIONAL clauses, EXISTS, NOT EXISTS, FILTER, and sameTerm to refine the results.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functional_forms.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX dc:   <http://purl.org/dc/elements/1.1/>\nPREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>\nSELECT (IF(?givenName = \"Obama\", if(?givenName = \"Obama\", \"yes\", \"no\"), \"no\") as ?givenName2) (COALESCE(1/0 *3 *4 +5 + 6, ?x) as ?col)\nWHERE {\n    ?x foaf:givenName  ?givenName .\n    OPTIONAL {\n        ?x dc:date ?date\n    } .\n    FILTER ( bound(?date) )\n    FILTER NOT EXISTS {\n        ?givenName foaf:name ?name.\n        filter(?givenName = \"Clark\")\n    }\n    FILTER EXISTS {\n        ?givenName foaf:name ?name.\n        filter((?givenName = \"Obama\" || ?givenName = \"Obama2\") && ?givenName = \"Stern\")\n        FILTER (sameTerm(?givenName, ?givenName) && !sameTerm(?givenName, ?givenName2))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Arithmetic and Filter\nDESCRIPTION: This SPARQL query selects a calculated value and filters the results. It calculates \"2*4 - 5 + 3\" and binds it to the variable \"?test_arithmetics\". A filter condition \"?o || ?o\" (which is always true) and a limit of 1 are also applied.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_operators__unary.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect (2*4 -5 + 3 as ?test_arithmetics) where {\n\t?s ?p ?o .\n    filter(?o || ?o)\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Persisting URI References using N3 syntax\nDESCRIPTION: This snippet shows how to persist URI References using Notation 3 syntax. The URI is enclosed in angle brackets.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<..URI..>\n```\n\n----------------------------------------\n\nTITLE: Function with Type Hints (Python)\nDESCRIPTION: This example demonstrates a Python function `foo` with type hints. The input variable `a` is specified as an integer (`int`), and the function is indicated to return an integer as well.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/type_hints.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef foo(a: int) -> int:\n    return a + 1\n```\n\n----------------------------------------\n\nTITLE: Slicing RDF Graphs in RDFLib (Python)\nDESCRIPTION: Demonstrates the use of slicing syntax as a shortcut for querying RDF graphs using RDFLib. It overloads the `__getitem__` method, allowing slice notation to represent RDF triples for querying. It requires rdflib and its dependencies. Note that using variables that evaluate to None or False in the slices may lead to unexpected results.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/utilities.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph, URIRef, Literal, BNode\nfrom rdflib.namespace import FOAF, RDF\n\ng = Graph()\ng.bind(\"foaf\", FOAF)\n\n# Add demo data\nbob = URIRef(\"http://example.org/people/Bob\")\nbill = URIRef(\"http://example.org/people/Bill\")\ng.add((bob, RDF.type, FOAF.Person))\ng.add((bob, FOAF.name, Literal(\"Bob\")))\ng.add((bob, FOAF.age, Literal(38)))\ng.add((bob, FOAF.knows, bill))\n\nprint(g[:])\n# same as\nprint(iter(g))\n\nprint(g[bob])\n# same as\nprint(g.predicate_objects(bob))\n\nprint(g[bob: FOAF.knows])\n# same as\nprint(g.objects(bob, FOAF.knows))\n\nprint(g[bob: FOAF.knows: bill])\n# same as\nprint((bob, FOAF.knows, bill) in g)\n\nprint(g[:FOAF.knows])\n# same as\nprint(g.subject_objects(FOAF.knows])\n```\n\n----------------------------------------\n\nTITLE: URIRef String Operation - Python\nDESCRIPTION: This demonstrates how string operations on URIRefs in RDFLib return new URIRefs. It shows how to concatenate a string with a URIRef to create a new URIRef. Requires the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> URIRef('http://example.org/')+'test'\nrdflib.term.URIRef('http://example.org/test')\n```\n\n----------------------------------------\n\nTITLE: N3 Formula Example\nDESCRIPTION: This snippet shows an example of N3 formula. It shows the relation between a N3Programmer and Migrane.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n{?x a :N3Programmer} => {?x :has :Migrane}\n```\n\n----------------------------------------\n\nTITLE: Extracting Date and Time Components with SPARQL\nDESCRIPTION: This SPARQL query retrieves the current date and time using the `now()` function and extracts its components, such as year, month, day, hours, minutes, seconds, timezone, and timezone abbreviation. It uses functions like `year()`, `month()`, `day()`, `hours()`, `minutes()`, `seconds()`, `timezone()`, and `tz()` to achieve this.  The `WHERE` clause includes a basic triple pattern `?s ?p ?o .` and the `LIMIT` clause restricts the output to a single result.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functions_on_dates_and_time.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nselect (now() as ?now) (year(now()) as ?year) (month(now()) as ?month) (day(now()) as ?day)\n(hours(now()) as ?hours) (minutes(now()) as ?minutes) (seconds(now()) as ?seconds)\n(timezone(now()) as ?timezone) (tz(now()) as ?tz) where {\n\t?s ?p ?o .\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Normalizing a URI (Python)\nDESCRIPTION: Shows how to normalize a URI using the `normalizeUri` method of the `rdflib.namespace.NamespaceManager`. The intended function of this call isn't explicitly stated in the provided context.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/namespaces_and_bindings.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib.namespace import NamespaceManager\n\nnm = NamespaceManager(Graph())\nnm.normalizeUri(t)\n```\n\n----------------------------------------\n\nTITLE: Running pre-commit checks with tox on changed files\nDESCRIPTION: This command uses tox to run pre-commit hooks on changed files. Tox provides a consistent environment for running tests and other tasks, ensuring that they produce the same results regardless of the host system.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntox -e precommit\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib with optional dependencies\nDESCRIPTION: This shell command installs RDFLib along with several optional dependencies, providing extra features such as support for Berkeley DB, NetworkX, HTML parsing, lxml, and orjson.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\npip install rdflib[berkeleydb,networkx,html,lxml,orjson]\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Summing Book Prices\nDESCRIPTION: This SPARQL query calculates the total price of books associated with an organization's affiliates. It filters books priced under 5, groups results by organization, and only returns groups with a total price exceeding 10.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__having.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX : <http://books.example/>\nSELECT (SUM(?lprice) AS ?totalPrice)\nWHERE {\n  ?org :affiliates ?auth .\n  ?auth :writesBook ?book .\n  ?book :price ?lprice .\n  filter(?lprice < 5)\n}\nGROUP BY ?org\nHAVING (SUM(?lprice) > 10)\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Distinct Count of RDF Types\nDESCRIPTION: This SPARQL query retrieves distinct counts of resources related to a given subject through either the `rdf:type` property or its inverse. It groups the results by subject and orders them alphabetically. The `select reduced` keyword is used to eliminate duplicate result sets based on the bound variables.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_solution_modifiers__reduced.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect reduced ?x (count(distinct ?y) as ?cnt)  where\n{\n    ?x (rdf:type|^rdf:type) ?y\n}\ngroup by ?x\norder by ?x\n```\n\n----------------------------------------\n\nTITLE: Persisting Literals using N3 syntax\nDESCRIPTION: This snippet shows how to persist Literals using Notation 3 syntax. The value is enclosed in double quotes, optionally followed by a language tag or a datatype URI.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n\"...value..\"@lang or \"..value..\"^^dtype_uri\n```\n\n----------------------------------------\n\nTITLE: Querying FOAF Data with SPARQL\nDESCRIPTION: This SPARQL query retrieves information about individuals known by someone with the email address alice@example. It searches for individuals (?x) who have a foaf:mbox value of mailto:alice@example and then finds the names of people they know (directly or indirectly). The query limits the results to 100.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__zero_or_one_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nselect * where\n{\n    ?x foaf:mbox <mailto:alice@example> .\n    ?x foaf:knows?/foaf:name ?name .\n}\nlimit 100\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Functions and Filters\nDESCRIPTION: This SPARQL query selects names and mailboxes, uses STRDT and STRLANG functions to create typed and language-tagged literals, generates UUIDs, and applies various filters to the mailbox variable based on its type (IRI, blank node, literal, numeric) and string representation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functions_on_rdf_terms.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nSELECT ?name ?mbox (STRDT(\"iiii\", <http://example/romanNumeral>) as ?strdt) (STRLANG(\"chat\", \"en\") as ?strlang) (uuid() as ?uuid) (STRUUID() as ?struuid)\nWHERE {\n    ?x foaf:name  ?name ;\n       foaf:mbox  ?mbox .\n    FILTER isIRI(?mbox)\n    FILTER isBlank(?mbox)\n    FILTER isLiteral(?mbox)\n    FILTER isNumeric(?mbox)\n    FILTER STR(?mbox)\n    FILTER LANG(?mbox)\n    FILTER DATATYPE(?mbox)\n    FILTER IRI(?mobox)\n    FILTER BNODE(\"string\")\n}\n```\n\n----------------------------------------\n\nTITLE: Moving triples to a named graph with RDFlib\nDESCRIPTION: This code snippet demonstrates how to move triples from the default graph to a named graph within a ConjunctiveGraph using RDFlib. It involves parsing the data, iterating over the triples in the default graph, adding them to the destination graph, and then removing them from the default graph.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/upgrade6to7.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import ConjunctiveGraph\n\ncg = ConjunctiveGraph()\ncg.parse(\"http://example.com/source.trig\", format=\"trig\")\ndestination_graph = cg.get_context(\"example:graph_name\")\nfor triple in cg.default_context.triples((None, None, None)):\n    destination_graph.add(triple)\n    cg.default_context.remove(triple)\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for RDF Types and Counts\nDESCRIPTION: This SPARQL query retrieves distinct values for the variable '?x' based on the RDF type relationship with '?y', and calculates the count of distinct '?y' values for each '?x'. It uses the `select reduced` modifier for efficiency, groups the results by '?x', orders them by '?x', and limits the output to 50 results.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_solution_modifiers__to_multiset.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect reduced ?x (count(distinct ?y) as ?cnt)  where\n{\n    ?x (rdf:type|^rdf:type) ?y\n    {\n        ?y ?a ?z\n    }\n}\ngroup by ?x\norder by ?x\nlimit 50\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Prefixes\nDESCRIPTION: This SPARQL query retrieves information about individuals in a social network. It uses prefixes for Dublin Core, RDF Schema, an example namespace, and FOAF (Friend of a Friend). The query finds individuals with a specific email address and retrieves the names of their friends, limiting the results to 100.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__inverse_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX : <http://example.org/book/>\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\nselect * where {\n  {\n    ?x foaf:mbox <mailto:alice@example> .\n    ?x ^foaf:knows/foaf:name ?name .\n  }\n} limit 100\n```\n\n----------------------------------------\n\nTITLE: Python Interface for Variable Aggregation\nDESCRIPTION: This snippet defines a python interface for aggregating variables in a given scope identified by a formula identifier. It takes a formula identifier as input.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef variables(formula_identifier)\n```\n\n----------------------------------------\n\nTITLE: Iterating through RDF Graph Triples in RDFLib\nDESCRIPTION: This code demonstrates how to iterate through all triples (subject, predicate, object) within an RDFLib graph. It checks if each triple obtained during iteration is indeed present in the graph, raising an exception if there's a mismatch between the iterator and the container protocols.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_graphs.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfor s, p, o in someGraph:\n    if not (s, p, o) in someGraph:\n        raise Exception(\"Iterator / Container Protocols are Broken!!\")\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with MINUS\nDESCRIPTION: This SPARQL query selects all triples where '?x' has a property ':p' with value '?n', excluding those where '?x' also has a property ':q' with value '?m', and '?n' is equal to '?m'. The query utilizes the MINUS operator to achieve this exclusion.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__minus.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX : <http://example/>\nSELECT * WHERE {\n    ?x :p ?n\n    MINUS {\n        ?x :q ?m .\n        FILTER(?n = ?m)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Code Style and Conventions with Ruff\nDESCRIPTION: This snippet demonstrates how to check code style and conventions using Ruff. Ruff is used to lint the code and ensure that it follows the project's coding guidelines.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry run ruff check\n```\n\n----------------------------------------\n\nTITLE: N-Triples RDF Data Example\nDESCRIPTION: This N-Triples example defines two RDF triples: one stating that drewp is a FOAF Person, and another stating that drewp says \"Hello World\". The .nt file extension indicates that the file contains RDF data in N-Triples format.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_0\n\nLANGUAGE: Turtle\nCODE:\n```\n<http://example.com/drewp> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Person> .\n<http://example.com/drewp> <http://example.com/says> \"Hello World\" .\n```\n\n----------------------------------------\n\nTITLE: SPARQL Arithmetic Query\nDESCRIPTION: This SPARQL query calculates an arithmetic expression and assigns the result to the variable `?test_arithmetics`. It selects the result of `2*4 -5 + 3` and limits the result set to 1.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_operators__arithmetics.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nselect (2*4 -5 + 3 as ?test_arithmetics) where {\n\t?s ?p ?o .\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Fixing Code Style Issues with Ruff\nDESCRIPTION: This snippet shows how to automatically fix code style issues detected by Ruff. The --fix flag tells Ruff to attempt to automatically correct any identified style violations.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npoetry run ruff check --fix\n```\n\n----------------------------------------\n\nTITLE: Opening and Closing a BerkeleyDB Store in RDFlib (Python)\nDESCRIPTION: This code snippet demonstrates how to open and close a BerkeleyDB store in RDFlib. The `graph.open()` method is used to open the store at a specified location, and the `graph.close()` method is used to close it. This is important for persistent stores like BerkeleyDB.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_stores.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\n\n# use the BerkeleyDB Store\ngraph = Graph(store=\"BerkeleyDB\")\ngraph.open(\"/some/folder/location\")\n# do things ...\ngraph.close()\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with RDFlib\nDESCRIPTION: This SPARQL query retrieves all individuals (?x) with an email address of 'alice@example' and finds their names (?name) through the 'foaf:knows' property, including transitive relationships. The 'LIMIT 100' clause restricts the number of results returned.  The query requires a loaded RDF graph with FOAF data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_property_path__zero_or_more_path.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nselect * where\n{\n    ?x foaf:mbox <mailto:alice@example> .\n    ?x foaf:knows*/foaf:name ?name .\n}\nlimit 100\n```\n\n----------------------------------------\n\nTITLE: Checking Types with Mypy\nDESCRIPTION: This snippet demonstrates how to check types using Mypy. Mypy is used to perform static type checking and identify potential type errors in the code.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npoetry run mypy --show-error-context --show-error-codes\n```\n\n----------------------------------------\n\nTITLE: Manipulating FOAF Data with rdflib\nDESCRIPTION: This snippet demonstrates how to manipulate FOAF data using rdflib. It retrieves data from a LiveJournal FOAF feed, adds foaf:name triples based on foaf:member_name triples, and then removes the original foaf:member_name triples to align the data with standard FOAF usage.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_creating_rdf.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import Graph\nfrom rdflib.namespace import FOAF\n\ng = Graph()\n# get the data\ng.parse(\"http://danbri.livejournal.com/data/foaf\")\n\n# for every foaf:member_name, add foaf:name and remove foaf:member_name\nfor s, p, o in g.triples((None, FOAF['member_name'], None)):\n    g.add((s, FOAF['name'], o))\n    g.remove((s, FOAF['member_name'], o))\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Sum and Count\nDESCRIPTION: This SPARQL query calculates the sum of all `rdf:value` properties (?val) and counts the number of subjects (?a) that have the `rdf:value` property. It groups the results, so the count will be per distinct subject, but since the group by is on ?a, the SUM is over all ?val for the entire data set, as there is no distinct group.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__group.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nSELECT (SUM(?val) AS ?sum) (COUNT(?a) AS ?count)\nWHERE {\n  ?a rdf:value ?val .\n} GROUP BY ?a\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests with Pytest\nDESCRIPTION: This snippet shows how to run a specific test file using pytest. This is useful for focusing on specific areas of the codebase during development or debugging.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ poetry run pytest test/test_graph/test_graph.py\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks\nDESCRIPTION: This snippet demonstrates how to install pre-commit hooks. These hooks run automatically every time a git commit is made, ensuring that code formatting and style checks are performed before the commit is finalized.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: SPARQL Federated Query\nDESCRIPTION: This SPARQL query demonstrates federated querying, retrieving data from two different SPARQL endpoints: http://people.example.org/sparql and http://people2.example.org/sparql. It selects the person, their interest, and who they know, using the foaf ontology for properties like name, interest, and knows.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_other__service1.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\n# https://www.w3.org/TR/sparql11-federated-query/\nPREFIX foaf:   <http://xmlns.com/foaf/0.1/>\nSELECT ?person ?interest ?known\nWHERE\n{\n    SERVICE <http://people.example.org/sparql> {\n        ?person foaf:name ?name .\n        OPTIONAL {\n            ?person foaf:interest ?interest .\n            SERVICE <http://people2.example.org/sparql> {\n                ?person foaf:knows ?known .\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Arithmetic and Filter\nDESCRIPTION: This SPARQL query demonstrates basic arithmetic operations and filtering within a WHERE clause. It calculates an expression (2*4 - 5 + 3) and aliases it as ?test_arithmetics. It also includes a filter that evaluates a boolean OR expression based on equality.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_operators__conditional_or.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect (2*4 -5 + 3 as ?test_arithmetics) where {\n\t?s ?p ?o .\n    filter(2=2 || 1=1)\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Running pre-commit checks on changed files\nDESCRIPTION: This command runs the pre-commit hooks on only the files that have been changed since the last commit. It helps maintain code quality and consistency by automatically formatting and linting code before each commit.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run\n```\n\n----------------------------------------\n\nTITLE: Checking Code Formatting with Black\nDESCRIPTION: This snippet shows how to check code formatting using Black, ensuring that the code adheres to the project's coding style. It uses the project's black.toml configuration file.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run black .\n```\n\n----------------------------------------\n\nTITLE: Querying RDF Types and Counts with SPARQL\nDESCRIPTION: This SPARQL query selects distinct subjects (?x) and counts the number of distinct related objects (?y) through rdf:type or its inverse. The results are grouped by the subject and ordered alphabetically.  It requires an RDF graph to execute against.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_solution_modifiers__order_by.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect distinct ?x (count(distinct ?y) as ?cnt)  where\n{\n    ?x (rdf:type|^rdf:type) ?y\n}\ngroup by ?x\norder by ?x\n```\n\n----------------------------------------\n\nTITLE: SPARQL: Select Distinct and Count\nDESCRIPTION: This SPARQL query selects distinct values for the variable `?x` and counts the distinct values of the variable `?y` that are related to `?x` through either the `rdf:type` property or its inverse. The results are grouped by `?x` and the count is aliased as `?cnt`.  A required dependency is an RDF graph.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_solution_modifiers__distinct.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect distinct ?x (count(distinct ?y) as ?cnt)  where\n{\n    ?x (rdf:type|^rdf:type) ?y\n}\ngroup by ?x\n```\n\n----------------------------------------\n\nTITLE: Loading triples into named graph with RDFlib\nDESCRIPTION: This code snippet shows how to load triples from a format that does not support named graphs into a specific named graph using RDFlib. It utilizes the `ConjunctiveGraph` and the `get_context` method to access the target graph and then parses the data into it.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/upgrade6to7.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom rdflib import ConjunctiveGraph\n\ncg = ConjunctiveGraph()\ncg.get_context(\"example:graph_name\").parse(\"http://example.com/source.ttl\", format=\"turtle\")\n```\n\n----------------------------------------\n\nTITLE: Installing tox\nDESCRIPTION: This command installs tox, a generic virtual environment management and test command line tool. It is used to automate testing in different Python environments.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npip install tox\n```\n\n----------------------------------------\n\nTITLE: Checking wheel and sdist (Release Process)\nDESCRIPTION: These commands verify the built wheel and source distribution by installing them with `pipx` and running `rdfpipe` to check the version and process a test file. `pipx` is used to avoid conflicts with the RDFLib development environment.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\npipx run --no-cache --spec \"$(readlink -f dist/rdflib*.whl)\" rdfpipe --version\npipx run --no-cache --spec \"$(readlink -f dist/rdflib*.whl)\" rdfpipe https://github.com/RDFLib/rdflib/raw/main/test/data/defined_namespaces/rdfs.ttl\npipx run --no-cache --spec \"$(readlink -f dist/rdflib*.tar.gz)\" rdfpipe --version\npipx run --no-cache --spec \"$(readlink -f dist/rdflib*.tar.gz)\" rdfpipe https://github.com/RDFLib/rdflib/raw/main/test/data/defined_namespaces/rdfs.ttl\n```\n\n----------------------------------------\n\nTITLE: SPARQL Federated Query\nDESCRIPTION: This SPARQL query demonstrates federated query capabilities by accessing data from a remote SPARQL endpoint. It selects the name of a person known by a specific individual from a local RDF graph, and then queries the remote endpoint for the person's name.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_other__service2.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX foaf:   <http://xmlns.com/foaf/0.1/>\n\nSELECT ?name\nFROM <http://example.org/myfoaf.rdf>\nWHERE\n{\n  <http://example.org/myfoaf/I> foaf:knows ?person .\n  SERVICE <http://people.example.org/sparql> {\n    ?person foaf:name ?name . }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing multi-graph data into a Dataset in RDFLib\nDESCRIPTION: This code snippet demonstrates how to parse multi-graph data (e.g., Trig, HexT) into an RDFLib `Dataset`.  It sets the `publicID` of the `Dataset` to the identifier of the `default_context` (default graph) to ensure correct parsing. The snippet also includes example trig data.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/plugin_parsers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nd = Dataset()\nd.parse(\n    data=\"\"\" ... \"\"\", \n    format=\"trig\", \n    publicID=d.default_context.identifier\n)\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib with pip\nDESCRIPTION: This command installs RDFLib using pip, the Python package installer. It retrieves the latest version of RDFLib from PyPI and installs it along with its dependencies. 'sudo' may be required based on system configuration.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/gettingstarted.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install rdflib\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Arithmetic and Filters\nDESCRIPTION: This SPARQL query demonstrates arithmetic operations and filter conditions. It selects the result of the expression (2*4 -5 + 3) as ?test_arithmetics and includes a filter condition with logical OR and comparison operators. The query is limited to returning a single result using `LIMIT 1`.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_operators__relational.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nselect (2*4 -5 + 3 as ?test_arithmetics) where {\n\t?s ?p ?o .\n    filter(3>2 || 1<2 || 2>=2 || 2<=2 || 1!=2)\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Query Result Iteration Example - Python\nDESCRIPTION: This code shows how to iterate over QueryResults in RDFLib and access variable bindings as attributes or as a dictionary.  It assumes that a SPARQL query has been executed on a graph (g).  Dependencies include the rdflib library.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfor row in g.query('select ... ') :\n   print row.age, row[\"name\"]\n```\n\n----------------------------------------\n\nTITLE: Running a specific tox environment\nDESCRIPTION: This command runs a specific tox environment. For example, `tox -e py39` runs the default environment with Python 3.9, and `tox -e py311-extra` runs extra tests with Python 3.11.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ntox -e py39 # default environment with py39\ntox -e py311-extra # extra tests with py311\n```\n\n----------------------------------------\n\nTITLE: Running test coverage with pytest-cov\nDESCRIPTION: This command runs the tests and generates a coverage report to assess the percentage of code covered by the test suite.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\npoetry run pytest --cov\n```\n\n----------------------------------------\n\nTITLE: Graph Slicing Example - Python\nDESCRIPTION: This code snippet demonstrates the slicing feature of Graphs and Resources in RDFLib. It shows how to use slicing to generate an iterator over the names of Bob's friends. Requires the rdflib library and the instantiation of a graph object.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ngraph[bob : FOAF.knows/FOAF.name]\n          -> generator over the names of Bobs friends\n```\n\n----------------------------------------\n\nTITLE: SPARQL Path Operators Example - Python\nDESCRIPTION: This code demonstrates how SPARQL paths are exposed as operators on URIRefs in RDFLib. It shows how to use these operators with graph.triples to query relationships within an RDF graph. It requires the rdflib library and the FOAF and RDFS namespaces.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom rdflib import Graph, URIRef\nfrom rdflib.namespace import FOAF, RDFS\n\ng = Graph()\nbob = URIRef(\"...\")\ncls = URIRef(\"...\")\n\n# List names of friends of Bob:\ng.triples((bob, FOAF.knows/FOAF.name , None))\n\n# All super-classes:\ng.triples((cls, RDFS.subClassOf * '+', None))\n```\n\n----------------------------------------\n\nTITLE: Graph Variant Identification\nDESCRIPTION: This snippet illustrates the naming convention used to identify different variants of the same RDF graph. Files with the same basename and differing extensions, as well as those with a `-variant-[^/]*` suffix are considered variants.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/variants/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ntest/variants/literal_with_lang-variant-control.ttl\ntest/variants/literal_with_lang.nt\ntest/variants/literal_with_lang.rdf\ntest/variants/literal_with_lang.ttl\n```\n\n----------------------------------------\n\nTITLE: POST Request to Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP POST request to add data to an existing graph, resulting in a merge. The expected response is 200 OK.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_12\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST /person/1.ttl HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n\n<http://$HOST$/person/1> foaf:name \"Jane Doe\" \n```\n\n----------------------------------------\n\nTITLE: Executing pytest with EARL reporter plugin options\nDESCRIPTION: This code snippet shows how to run pytest with specific options for the EARL reporter plugin. The options add a datetime stamp to the output file name and specify a suffix for the output file.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npytest \\\n  --earl-add-datetime \\\n  --earl-output-suffix=-timestamped \\\n  test/test_w3c_spec/\n```\n\n----------------------------------------\n\nTITLE: Running tests with pytest\nDESCRIPTION: This shell command shows how to run the RDFLib test suite using pytest.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\npoetry install\npoetry run pytest\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query for Political Mentions\nDESCRIPTION: This SPARQL query retrieves information about political mentions, including the person mentioned, their political party, the document containing the mention, and the mention itself.  It relies on the `pub` and `publishing` ontologies and orders the results by mention.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_graph_patterns__bgp.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nPREFIX pub: <http://ontology.ontotext.com/taxonomy/>\nPREFIX publishing: <http://ontology.ontotext.com/publishing#>\n\nselect ?personLabel ?party_label ?document ?mention where {\n    ?mention publishing:hasInstance ?person .\n    ?document publishing:containsMention ?mention .\n    ?person pub:memberOfPoliticalParty ?party .\n    ?person pub:preferredLabel ?personLabel .\n    ?party pub:hasValue ?value .\n    ?value pub:preferredLabel ?party_label .\n} order by ?mention\n```\n\n----------------------------------------\n\nTITLE: Running go-task validation\nDESCRIPTION: This command runs basic validation checks as defined in the Taskfile.yml.  This helps ensure the codebase adheres to standards and basic checks pass.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ntask validate\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib from GitHub\nDESCRIPTION: This command installs RDFLib directly from the main branch of the GitHub repository. It allows users to access the latest development code. The #egg=rdflib part tells pip how to name the installed package.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/gettingstarted.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install git+https://github.com/RDFLib/rdflib.git@main#egg=rdflib\n```\n\n----------------------------------------\n\nTITLE: Running pre-commit checks on all files\nDESCRIPTION: This command runs the pre-commit hooks on all files in the repository, regardless of whether they have been changed. This is useful for initial setup or for ensuring that all files conform to the project's coding standards.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Pytest\nDESCRIPTION: This snippet demonstrates how to run the RDFLib test suite using pytest. It first installs the dependencies using poetry, and then executes pytest to run the tests.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ poetry install\n$ poetry run pytest\n```\n\n----------------------------------------\n\nTITLE: Publishing to TestPyPI (Release Process)\nDESCRIPTION: This command publishes the RDFlib package to the TestPyPI repository using Poetry.  It requires authentication with an API token.  This allows testing the release process before publishing to the main PyPI repository.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\npoetry publish --repository=testpypi\n```\n\n----------------------------------------\n\nTITLE: GET Request After Initial Graph Creation\nDESCRIPTION: This snippet demonstrates an HTTP GET request to retrieve the graph created in the previous PUT request. The request specifies the Accept header to receive the graph in text/turtle format. The expected response is 200 OK with the Turtle representation of the graph in the response body.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_1\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/1.ttl HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n<http://$HOST$/person/1> a foaf:Person;\n   foaf:businessCard [ \n        a v:VCard;\n        v:fn \"John Doe\" \n   ]\n```\n\n----------------------------------------\n\nTITLE: Fetching Test Data using fetcher.py (Bash)\nDESCRIPTION: This bash script demonstrates how to use the `fetcher.py` script to download test data for the rdflib project. It provides examples for fetching all files, a single file, and files below a specific path. It assumes that a virtual environment `.venv` has been created.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# run in repo root\n\n# fetch everything\n.venv/bin/python3 test/data/fetcher.py\n\n# only fetch single file\n.venv/bin/python3 test/data/fetcher.py test/data/rdfs.ttl\n\n# only fetch files below path:\n.venv/bin/python3 test/data/fetcher.py test/data/suites\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib with pip\nDESCRIPTION: This shell command shows how to install the RDFLib package using pip, Python's package installer.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\npip install rdflib\n```\n\n----------------------------------------\n\nTITLE: Running a specific tox environment with go-task\nDESCRIPTION: This command runs a specific tox environment using go-task.  The `-- -e py310` part passes the `-e py310` argument to tox, which specifies the environment to run.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ntask tox -- -e py310\n```\n\n----------------------------------------\n\nTITLE: Running extensive tests inside devcontainer\nDESCRIPTION: This command runs extensive tests inside the devtools container by setting the EXTENSIVE environment variable to true. This ensures that all tests are executed within the container environment.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose run --rm run task EXTENSIVE=true test\n```\n\n----------------------------------------\n\nTITLE: Overriding the tox test command\nDESCRIPTION: This command overrides the default test command for specified tox environments. In this example, it runs `pytest test/test_translate_algebra.py` instead of the default pytest command for py39 and py311 environments.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ntox -e py39,py311 -- pytest test/test_translate_algebra.py\n```\n\n----------------------------------------\n\nTITLE: Building documentation with go-task\nDESCRIPTION: This command builds the documentation as defined in the Taskfile.yml. It generates the HTML documentation from the source files.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ntask docs\n```\n\n----------------------------------------\n\nTITLE: Listing tox environments\nDESCRIPTION: This command lists the tox environments that are run by default. Tox environments are configured in the `tox.ini` file and define different Python versions and dependencies to test against.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntox -e\n```\n\n----------------------------------------\n\nTITLE: Build Sphinx Documentation\nDESCRIPTION: This snippet builds the Sphinx documentation using poetry. It specifies the builder (html), the doctrees directory, the source directory, and the output directory.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/docs.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run sphinx-build -b html -d docs/_build/doctrees docs docs/_build/html\n```\n\n----------------------------------------\n\nTITLE: Configuring the system for development inside devcontainer\nDESCRIPTION: This command configures the system for development inside the devcontainer by running the `task configure` command within the container. It ensures that the environment is properly set up for development tasks.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose run --rm run task configure\n```\n\n----------------------------------------\n\nTITLE: Running pre-commit checks with tox on all files\nDESCRIPTION: This command uses tox to run pre-commit hooks on all files in the repository.  This ensures that pre-commit checks are run in an isolated and reproducible environment.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntox -e precommitall\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib from Git\nDESCRIPTION: This snippet shows how to install RDFLib directly from the git repository. This is useful for developers who want to use the latest, potentially unstable, version.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\npip install git+https://github.com/rdflib/rdflib@main\n```\n\nLANGUAGE: Shell\nCODE:\n```\npip install -e git+https://github.com/rdflib/rdflib@main#egg=rdflib\n```\n\n----------------------------------------\n\nTITLE: Copy JSON-LD files to test suite\nDESCRIPTION: This command copies all .jsonld files from the directory specified by the `$JSONLD_TESTSUITE` environment variable to the `test/test-suite/` directory.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/jsonld/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncp $JSONLD_TESTSUITE/*.jsonld test/test-suite/\n```\n\n----------------------------------------\n\nTITLE: Running the validate task inside devcontainer\nDESCRIPTION: This command runs the validate task inside the devtools container. This ensures that the validation checks are performed within the isolated environment of the container.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose run --rm run task validate\n```\n\n----------------------------------------\n\nTITLE: Listing all tox environments\nDESCRIPTION: This command lists all tox environments, including the ones that don't run by default. It allows you to see all available testing configurations.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntox -a\n```\n\n----------------------------------------\n\nTITLE: Type Alias Example (Python)\nDESCRIPTION: This example shows the creation of a type alias `Bar` using the `typing` module. `Bar` is defined as a tuple containing an integer and a string.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/type_hints.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Tuple\n\nBar = tuple[int, str]\n```\n\n----------------------------------------\n\nTITLE: Persisting Blank Nodes using N3 syntax\nDESCRIPTION: This snippet shows how to persist Blank Nodes using Notation 3 syntax. They are represented as '_:Id', where Id is an identifier determined by skolemization.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n_:Id\n```\n\n----------------------------------------\n\nTITLE: PUT Request with Empty Graph\nDESCRIPTION: This snippet demonstrates a PUT request that creates an empty graph, which should result in a 200 OK\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_7\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT /person/2.ttl HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n```\n\n----------------------------------------\n\nTITLE: Build Docs Using Tox\nDESCRIPTION: This command builds the documentation using the tox environment, which provides a consistent and isolated environment for building the documentation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/docs.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntox -e docs\n```\n\n----------------------------------------\n\nTITLE: Generate API Docs with sphinx-apidoc\nDESCRIPTION: This command generates API documentation from docstrings using sphinx-apidoc. It includes options to force overwriting existing files (-f), set the maximum depth for the table of contents (-d 10), specify the output directory (-o docs/apidocs/), and the source directory (rdflib examples).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/docs.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run sphinx-apidoc -f -d 10 -o docs/apidocs/ rdflib examples\n```\n\n----------------------------------------\n\nTITLE: Building artifacts (Release Process)\nDESCRIPTION: This command builds the distribution artifacts for RDFlib using Poetry.  It creates both a wheel (.whl) and a source distribution (.tar.gz).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\npoetry build\n```\n\n----------------------------------------\n\nTITLE: Install Poetry Venv\nDESCRIPTION: This code snippet demonstrates how to install the poetry virtual environment.  It is a prerequisite step before building the Sphinx documentation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/docs.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Building the development container (devcontainer CLI)\nDESCRIPTION: This command builds the development container using the devcontainer CLI.  It uses the configuration files in the current directory (`.`).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\ncd ./rdflib/\n\ndevcontainer build .\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Extra Requirements\nDESCRIPTION: This snippet demonstrates how to run tests with extra requirements, such as those needed for the berkeleydb backend. It installs the extra requirements using the --all-extras flag with poetry, and then executes pytest.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ poetry install --all-extras\n$ poetry run pytest\n```\n\n----------------------------------------\n\nTITLE: GET Request After Updating Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP GET request to retrieve the updated graph at /person/1.ttl. The request specifies the Accept header to receive the graph in text/turtle format. The expected response is 200 OK, returning the updated Turtle representation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_3\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/1.ttl HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n<http://$HOST$/person/1> a foaf:Person;\n   foaf:businessCard [ \n        a v:VCard;\n        v:fn \"Jane Doe\" \n   ]\n```\n\n----------------------------------------\n\nTITLE: Building the devcontainer docker image\nDESCRIPTION: This command builds the Docker image for the development container using the `docker-compose.yml` file. This creates a consistent environment for development.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose build\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit\nDESCRIPTION: This snippet demonstrates how to install pre-commit, a tool used to run checks on code before committing it to the repository.  This helps ensure code quality and consistency.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install --user --upgrade pre-commit\n```\n\n----------------------------------------\n\nTITLE: Getting a shell into the devcontainer\nDESCRIPTION: This command provides a shell into the devcontainer docker image, allowing direct interaction with the container's file system and environment. This is useful for debugging and manual configuration.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose run --rm run bash\n```\n\n----------------------------------------\n\nTITLE: Opening code inside the development container (devcontainer CLI)\nDESCRIPTION: This command opens the code inside the development container using the devcontainer CLI. It uses the configuration files in the current directory (`.`).\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ncd ./rdflib/\n\ndevcontainer open .\n```\n\n----------------------------------------\n\nTITLE: Installing RDFLib locally\nDESCRIPTION: This snippet provides options for installing RDFLib from a locally cloned repository, useful for development and contributing to the project. Uses poetry or pip.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\npoetry install  # installs into a poetry-managed venv\n```\n\nLANGUAGE: Shell\nCODE:\n```\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: GET Request After POST to Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP GET request after an HTTP POST request that added data to the graph. The response should include the merged data from the initial PUT and the subsequent POST.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_13\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/1.ttl HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n<http://$HOST$/person/1> a foaf:Person;\n    foaf:name \"Jane Doe\";\n    foaf:businessCard [ \n        a v:VCard;\n        v:fn \"Jane Doe\" \n    ]\n\n```\n\n----------------------------------------\n\nTITLE: Copy RDF conversion tests to test suite\nDESCRIPTION: This command copies all files related to RDF conversion tests (both `toRdf` and `fromRdf`) from the `$JSONLD_TESTSUITE/tests/` directory to the `test/test-suite/tests/` directory.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/jsonld/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp $JSONLD_TESTSUITE/tests/{toRdf,fromRdf}-*.* test/test-suite/tests/\n```\n\n----------------------------------------\n\nTITLE: Running default tox environments\nDESCRIPTION: This command runs the default tox environments as configured in the `tox.ini` file. These environments typically include different Python versions and dependencies to ensure compatibility.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntox\n```\n\n----------------------------------------\n\nTITLE: Cleaning up previous builds (Release Process)\nDESCRIPTION: This command removes the `dist` directory contents before building the RDFlib package, ensuring a clean build process for the release.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n\\rm -vf dist/*\n```\n\n----------------------------------------\n\nTITLE: Configuring the go-task environment\nDESCRIPTION: This command configures the environment for development as defined in the Taskfile.yml. This often involves setting up environment variables and installing dependencies.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ntask configure\n```\n\n----------------------------------------\n\nTITLE: Running live-preview of documentation with go-task\nDESCRIPTION: This command runs a live preview server for the documentation as defined in the Taskfile.yml.  This allows you to see changes to the documentation in real-time as you make them.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ntask docs:live-server\n```\n\n----------------------------------------\n\nTITLE: Publishing to PyPI (Release Process)\nDESCRIPTION: This command publishes the RDFlib package to the main PyPI repository using Poetry.  This makes the package available for installation by users. It may require specifying credentials.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\npoetry publish\n```\n\n----------------------------------------\n\nTITLE: Listing available go-task tasks\nDESCRIPTION: This command lists all the available tasks defined in the Taskfile.yml file. go-task simplifies development by providing a way to define and run common development tasks.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ntask -l\n```\n\n----------------------------------------\n\nTITLE: Verifying package metadata (Release Process)\nDESCRIPTION: This command extracts and views package metadata from both the wheel and source distribution archives using `bsdtar` and `view`. This allows checking the contents of `METADATA` and `PKG-INFO` files before publishing.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\nbsdtar -xvf dist/rdflib-*.whl -O '*/METADATA' | view -\nbsdtar -xvf dist/rdflib-*.tar.gz -O '*/PKG-INFO' | view -\n```\n\n----------------------------------------\n\nTITLE: SPARQL Query with Math Functions\nDESCRIPTION: This SPARQL query demonstrates the use of mathematical functions abs, round, ceil, floor, and rand. It selects the absolute value of 1.6, the rounded value of 5.5, the ceiling and floor values of 5.5, and a random number. The query limits the result to a single row.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/translate_algebra/test_functions__functions_on_numerics.txt#_snippet_0\n\nLANGUAGE: SPARQL\nCODE:\n```\nselect (abs(1.6) as ?abs) (round(5.5) as ?round) (ceil(5.5) as ?ceil) (floor(5.5) as ?floor) (rand() as ?rand)  where {\n\t?s ?p ?o .\n} limit 1\n```\n\n----------------------------------------\n\nTITLE: Function with No Explicit Type Hints (Python)\nDESCRIPTION: This demonstrates a Python function `foo` without explicit type hints.  This is used as the 'before' state for a type declaration change.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/type_hints.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(val):\n    return val + 1\n```\n\n----------------------------------------\n\nTITLE: Dry run publishing to TestPyPI (Release Process)\nDESCRIPTION: These commands perform a dry run of publishing the package to TestPyPI and PyPI using Poetry.  The `--dry-run` option simulates the publishing process without actually uploading the package.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/developers.rst#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\npoetry publish --repository=testpypi --dry-run\npoetry publish --dry-run\n```\n\n----------------------------------------\n\nTITLE: Persisting Formula Identifiers using N3 syntax\nDESCRIPTION: This snippet shows how to persist Formula Identifiers using N3 syntax. It uses the following notation: `{_:bnode}` or `{<.. URI ..>}`\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n{_:bnode} or {<.. URI ..>}\n```\n\n----------------------------------------\n\nTITLE: POST Request to Create New Graph\nDESCRIPTION: This snippet demonstrates an HTTP POST request to create a new graph at the $GRAPHSTORE$ URL. The request includes a Turtle representation of the graph in the body. The expected response is 201 Created, and the Location header should contain the URL of the newly created graph.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_16\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST $GRAPHSTORE$ HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n[]  a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:given-name \"Alice\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Python Interface for Formula Iteration\nDESCRIPTION: This snippet defines a Python interface for iterating over all formulae in the store. It optionally takes a triple pattern to filter the results.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef formulae(triple=None)\n```\n\n----------------------------------------\n\nTITLE: Turtle Rule Definition\nDESCRIPTION: This Turtle code snippet defines a rule using `log:implies`. It states that if the antecedent (left side of `log:implies`) is true, then the consequent (right side) must also be true. The antecedent is a blank node with a triple pattern `www3:is :x`, and the consequent is the triple `{www3 :is :x}`.  The code corrects a syntax issue by adding a colon to the local name www3 in the consequent.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/n3/N3Tests/cwm_includes/concat_correction.txt#_snippet_0\n\nLANGUAGE: Turtle\nCODE:\n```\n\t} log:implies {:www3 :is :x}.\n```\n\n----------------------------------------\n\nTITLE: PUT Request for Initial Graph Creation\nDESCRIPTION: This snippet demonstrates an HTTP PUT request to create a new graph at the specified URL (/person/1.ttl). The request includes a Turtle representation of the graph in the body with content type set to text/turtle. The expected response is 201 Created, indicating successful creation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_0\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT /person/1.ttl HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n<http://$HOST$/person/1> a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:fn \"John Doe\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Function with Type Hints (Python, Example 2)\nDESCRIPTION: This is a second example of the `foo` function, but now with explicit type hints.  This is used as the 'after' state for a type declaration change, illustrating how type hints are being added to the project.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/type_hints.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo(val: int) -> int:\n    return val + 1\n```\n\n----------------------------------------\n\nTITLE: Creating a BNode in rdflib\nDESCRIPTION: Demonstrates how to create BNode (Blank Node) objects using the rdflib library. It showcases the creation of a BNode instance and its N3 representation.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/rdf_terms.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from rdflib import BNode\n>>> bn = BNode()\n>>> bn  # doctest: +SKIP\nrdflib.term.BNode('AFwALAKU0')\n>>> bn.n3()  # doctest: +SKIP\n'_:AFwALAKU0'\n```\n\n----------------------------------------\n\nTITLE: GET Request to Default Graph\nDESCRIPTION: This snippet retrieves the contents of the default graph after a PUT operation, specifying the desired format as text/turtle. The expected response is 200 OK with the Turtle representation of the graph in the body.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_5\n\nLANGUAGE: HTTP\nCODE:\n```\nGET $GRAPHSTORE$?default HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n[]  a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:given-name \"Alice\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Example Results from DBPedia SPARQL Endpoint Query\nDESCRIPTION: This text snippet shows example results from querying the DBPedia SPARQL endpoint using the SERVICE keyword, as demonstrated in the previous code example.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_sparql.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n<http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.openlinksw.com/schemas/virtcxml#FacetCategoryPattern>\n<http://www.w3.org/2001/XMLSchema#anyURI> <http://www.w3.org/2000/01/rdf-schema#Datatype>\n<http://www.w3.org/2001/XMLSchema#anyURI> <http://www.w3.org/2000/01/rdf-schema#Datatype>\n```\n\n----------------------------------------\n\nTITLE: GET Request After Deleting Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP GET request to retrieve a graph that has been previously deleted. The expected response is 404 Not Found, indicating the resource no longer exists.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_10\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/2.ttl HTTP/1.1\nHost: $HOST$\n```\n\n----------------------------------------\n\nTITLE: PUT Request with Mismatched Content Type\nDESCRIPTION: This snippet demonstrates a PUT request with a content-type of application/rdf+xml while the body actually contains Turtle syntax. This should result in a 400 Bad Request error.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_6\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT /person/1.ttl HTTP/1.1\nHost: $HOST$\nContent-Type: application/rdf+xml\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n<http://$HOST$/person/1> a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:fn \"Jane Doe\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: Inferred Statement Example\nDESCRIPTION: This snippet shows an inferred statement based on the N3 Formula Example above. _a implies _b\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n_:a log:implies _:b\n```\n\n----------------------------------------\n\nTITLE: HEAD Request on a Non-Existing Graph\nDESCRIPTION: This snippet demonstrates an HTTP HEAD request to retrieve metadata about a non-existent graph at the specified URL (/person/2.ttl). The expected response is 404 Not Found.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_21\n\nLANGUAGE: HTTP\nCODE:\n```\nHEAD /person/2.ttl HTTP/1.1\nHost: $HOST$\n```\n\n----------------------------------------\n\nTITLE: POST Request with multipart/form-data\nDESCRIPTION: This snippet demonstrates a POST request with content type multipart/form-data. Two Turtle files are sent to create a graph. The response should be 200 OK.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_14\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST /person/1.ttl HTTP/1.1\nHost: $HOST$\nContent-type: multipart/form-data, boundary=AaB03x\n\n--AaB03x\ncontent-disposition: form-data; name=\"graphs\"\nContent-type: multipart/mixed, boundary=BbC04y\n\n--BbC04y\nContent-disposition: attachment; filename=\"lastName.ttl\"\nContent-type: text/turtle\n\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n<http://$HOST$/person/1> foaf:familyName \"Doe\" \n--BbC04y\nContent-disposition: attachment; filename=\"firstName.ttl\"\nContent-type: text/turtle\n\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n<http://$HOST$/person/1> foaf:givenName  \"Jane\"\n--BbC04y\n--AaB03x\n```\n\n----------------------------------------\n\nTITLE: Trig RDF Multi-Graph Example\nDESCRIPTION: This Turtle example defines an RDF multi-graph in the Trig format, specifying two graphs (eg:graph-1 and eg:graph-2), each containing triples describing different people (drewp and nick). The prefixes 'eg' and 'foaf' are used to shorten the URIs.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/intro_to_parsing.rst#_snippet_5\n\nLANGUAGE: Turtle\nCODE:\n```\nPREFIX eg: <http://example.com/person/>\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\neg:graph-1 {\n    eg:drewp a foaf:Person .\n    eg:drewp eg:says \"Hello World\" .\n}\n\neg:graph-2 {\n    eg:nick a foaf:Person .\n    eg:nick eg:says \"Hi World\" .\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing test coverage\nDESCRIPTION: These shell commands generate an HTML coverage report and then serve it using Python's built-in http server so that it can be viewed in a browser.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/README.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\npoetry run pytest --cov --cov-report term --cov-report html\npython -m http.server --directory=htmlcov\n```\n\n----------------------------------------\n\nTITLE: GET Request After POST multipart/form-data\nDESCRIPTION: This snippet demonstrates a GET request after a POST with multipart/form-data content type. The expected response is 200 OK with the merged graph from the attachments.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_15\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /person/1.ttl HTTP/1.1\nHost: $HOST$\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n<http://$HOST$/person/1> a foaf:Person;\n    foaf:name           \"Jane Doe\";\n    foaf:givenName      \"Jane\";\n    foaf:familyName     \"Doe\";\n    foaf:businessCard [ \n        a               v:VCard;\n        v:fn            \"Jane Doe\" \n    ]\n\n```\n\n----------------------------------------\n\nTITLE: PUT Request to Default Graph\nDESCRIPTION: This snippet demonstrates an HTTP PUT request to update the default graph using the $GRAPHSTORE$?default URL. The request includes a Turtle representation of the graph. The expected response is 201 Created, if the default graph was initially empty or didn't exist, or 200 if the default graph already existed.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_4\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT $GRAPHSTORE$?default HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n[]  a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:given-name \"Alice\" \n    ]\n```\n\n----------------------------------------\n\nTITLE: RDF Type Log Formula\nDESCRIPTION: This snippet describes the pattern of Blank Node identifiers associated with formulae.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/docs/persisting_n3_terms.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n?formula rdf:type log:Formula\n```\n\n----------------------------------------\n\nTITLE: DELETE Request for Non-Existent Graph\nDESCRIPTION: This snippet demonstrates an HTTP DELETE request for a non-existent graph. The expected response is 404 Not Found.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_11\n\nLANGUAGE: HTTP\nCODE:\n```\nDELETE /person/2.ttl HTTP/1.1\nHost: $HOST$\n```\n\n----------------------------------------\n\nTITLE: POST Request with Empty Graph to Existing Graph\nDESCRIPTION: This snippet tests what happens when posting an empty graph to an existing graph. A 204 No Content is expected.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_18\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST $NEWPATH$ HTTP/1.1\nHost: $HOST$\nContent-Type: text/turtle\n```\n\n----------------------------------------\n\nTITLE: GET Request after Empty POST\nDESCRIPTION: This snippet tests if an empty post has changed the graph's content. It shouldn't have and the graph should be identical to before.\nSOURCE: https://github.com/rdflib/rdflib/blob/main/test/data/suites/w3c/sparql11/http-rdf-update/tests.txt#_snippet_19\n\nLANGUAGE: HTTP\nCODE:\n```\nGET $NEWPATH$ HTTP/1.1\nHost: $HOST$\nAccept: text/turtle; charset=utf-8\n```\n\nLANGUAGE: Turtle\nCODE:\n```\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix v: <http://www.w3.org/2006/vcard/ns#> .\n\n[]  a foaf:Person;\n    foaf:businessCard [ \n        a v:VCard;\n        v:given-name \"Alice\" \n    ]\n```"
  }
]