[
  {
    "owner": "nlohmann",
    "repo": "json",
    "content": "TITLE: Using JSON as a first-class data type in C++\nDESCRIPTION: This snippet illustrates how JSON can be used as a first-class data type in C++. It shows various operations like creating JSON objects, accessing nested elements, and modifying values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// create an empty structure (null)\njson j;\n\n// add a number that is stored as double (note the implicit conversion of j to an object)\nj[\"pi\"] = 3.141;\n\n// add a Boolean that is stored as bool\nj[\"happy\"] = true;\n\n// add a string that is stored as std::string\nj[\"name\"] = \"Niels\";\n\n// add another null object by passing nullptr\nj[\"nothing\"] = nullptr;\n\n// add an object inside the object\nj[\"answer\"][\"everything\"] = 42;\n\n// add an array that is stored as std::vector (using an initializer list)\nj[\"list\"] = { 1, 0, 2 };\n\n// add another object (using an initializer list of pairs)\nj[\"object\"] = { {\"currency\", \"USD\"}, {\"value\", 42.99} };\n\n// instead, you could also write (which looks very similar to the JSON above)\njson j2 = {\n  {\"pi\", 3.141},\n  {\"happy\", true},\n  {\"name\", \"Niels\"},\n  {\"nothing\", nullptr},\n  {\"answer\", {\n    {\"everything\", 42}\n  }},\n  {\"list\", {1, 0, 2}},\n  {\"object\", {\n    {\"currency\", \"USD\"},\n    {\"value\", 42.99}\n  }}\n};\n\n```\n\n----------------------------------------\n\nTITLE: Implementing basic_json Constructors in C++\nDESCRIPTION: Declares nine different constructors for the basic_json class, providing various ways to create JSON values from different data types and sources. These constructors handle empty values, null values, compatible types, existing JSON objects, initializer lists, arrays, ranges, and copy/move semantics.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nbasic_json(const value_t v);\n\n// (2)\nbasic_json(std::nullptr_t = nullptr) noexcept;\n\n// (3)\ntemplate<typename CompatibleType>\nbasic_json(CompatibleType&& val) noexcept(noexcept(\n           JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),\n                                      std::forward<CompatibleType>(val))));\n\n// (4)\ntemplate<typename BasicJsonType>\nbasic_json(const BasicJsonType& val);\n\n// (5)\nbasic_json(initializer_list_t init,\n           bool type_deduction = true,\n           value_t manual_type = value_t::array);\n\n// (6)\nbasic_json(size_type cnt, const basic_json& val);\n\n// (7)\nbasic_json(iterator first, iterator last);\nbasic_json(const_iterator first, const_iterator last);\n\n// (8)\nbasic_json(const basic_json& other);\n\n// (9)\nbasic_json(basic_json&& other) noexcept;\n```\n\n----------------------------------------\n\nTITLE: Working with JSON as First-Class Data Type in C++\nDESCRIPTION: Illustrates how to create and manipulate complex JSON structures using the nlohmann/json library, demonstrating various ways to build JSON objects and arrays.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// create an empty structure (null)\njson j;\n\n// add a number that is stored as double (note the implicit conversion of j to an object)\nj[\"pi\"] = 3.141;\n\n// add a Boolean that is stored as bool\nj[\"happy\"] = true;\n\n// add a string that is stored as std::string\nj[\"name\"] = \"Niels\";\n\n// add another null object by passing nullptr\nj[\"nothing\"] = nullptr;\n\n// add an object inside the object\nj[\"answer\"][\"everything\"] = 42;\n\n// add an array that is stored as std::vector (using an initializer list)\nj[\"list\"] = { 1, 0, 2 };\n\n// add another object (using an initializer list of pairs)\nj[\"object\"] = { {\"currency\", \"USD\"}, {\"value\", 42.99} };\n\n// instead, you could also write (which looks very similar to the JSON above)\njson j2 = {\n  {\"pi\", 3.141},\n  {\"happy\", true},\n  {\"name\", \"Niels\"},\n  {\"nothing\", nullptr},\n  {\"answer\", {\n    {\"everything\", 42}\n  }},\n  {\"list\", {1, 0, 2}},\n  {\"object\", {\n    {\"currency\", \"USD\"},\n    {\"value\", 42.99}\n  }}\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Explicit JSON Arrays and Objects in C++\nDESCRIPTION: Shows how to create empty JSON arrays and objects explicitly, as well as how to create an array of key/value pairs using the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// a way to express the empty array []\njson empty_array_explicit = json::array();\n\n// ways to express the empty object {}\njson empty_object_implicit = json({});\njson empty_object_explicit = json::object();\n\n// a way to express an _array_ of key/value pairs [[\"currency\", \"USD\"], [\"value\", 42.99]]\njson array_not_object = json::array({ {\"currency\", \"USD\"}, {\"value\", 42.99} });\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Serializer with Size Constraint in C++\nDESCRIPTION: This snippet demonstrates how to create a custom serializer that only accepts types with a size <= 32 bytes. It uses SFINAE for compile-time checks and leverages ADL for calling the correct to_json and from_json overloads.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// You should use void as a second template argument\n// if you don't need compile-time checks on T\ntemplate<typename T, typename SFINAE = typename std::enable_if<sizeof(T) <= 32>::type>\nstruct less_than_32_serializer {\n    template <typename BasicJsonType>\n    static void to_json(BasicJsonType& j, T value) {\n        // we want to use ADL, and call the correct to_json overload\n        using nlohmann::to_json; // this method is called by adl_serializer,\n                                 // this is where the magic happens\n        to_json(j, value);\n    }\n\n    template <typename BasicJsonType>\n    static void from_json(const BasicJsonType& j, T& value) {\n        // same thing here\n        using nlohmann::from_json;\n        from_json(j, value);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using nlohmann/json Library in C++\nDESCRIPTION: This example demonstrates how to use the nlohmann/json library to create, manipulate, and serialize JSON data in C++.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/index.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"examples/README.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Simplified JSON Conversion for Custom Types in C++\nDESCRIPTION: Shows a more concise way to convert between custom types and JSON using nlohmann/json's automatic type conversion. This method requires implementing to_json and from_json functions for the custom type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// create a person\nns::person p {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// conversion: person -> json\njson j = p;\n\nstd::cout << j << std::endl;\n// {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n\n// conversion: json -> person\nauto p2 = j.template get<ns::person>();\n\n// that's it\nassert(p == p2);\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Objects from Literals in C++\nDESCRIPTION: Shows multiple ways to create json objects from JSON literals, including using string literals, user-defined literals, and initializer lists.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// Using (raw) string literals and json::parse\njson ex1 = json::parse(R\"(\n  {\n    \"pi\": 3.141,\n    \"happy\": true\n  }\n)\");\n\n// Using user-defined (raw) string literals\nusing namespace nlohmann::literals;\njson ex2 = R\"(\n  {\n    \"pi\": 3.141,\n    \"happy\": true\n  }\n)\"_json;\n\n// Using initializer lists\njson ex3 = {\n  {\"happy\", true},\n  {\"pi\", 3.141},\n};\n```\n\n----------------------------------------\n\nTITLE: Creating JSON arrays and objects with initializer lists in C++\nDESCRIPTION: Shows how to use initializer lists to create JSON arrays and objects, which is the recommended way to use brace initialization with the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/faq.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\njson array = {1, 2, 3, 4};\n```\n\nLANGUAGE: cpp\nCODE:\n```\njson object = {{\"one\", 1}, {\"two\", 2}};\n```\n\n----------------------------------------\n\nTITLE: Reading JSON Values Using at() Method in C++\nDESCRIPTION: Demonstrates how to access values in a JSON object using the `at()` method for checked access, which returns references to values if they exist and throws exceptions otherwise.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/checked_access.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Mary Smith\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Hybrid CMake Integration Setup\nDESCRIPTION: Shows a flexible setup that supports both external and embedded nlohmann_json library integration\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cmake.md#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nproject(ExampleProject LANGUAGES CXX)\n\noption(EXAMPLE_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF)\n\nadd_subdirectory(thirdparty)\n\nadd_executable(example example.cpp)\n\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nif(EXAMPLE_USE_EXTERNAL_JSON)\n    find_package(nlohmann_json 3.12.0 REQUIRED)\nelse()\n    set(JSON_BuildTests OFF CACHE INTERNAL \"\")\n    add_subdirectory(nlohmann_json)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing ADL Serializer for nlohmann::json in C++\nDESCRIPTION: This snippet shows the simplified implementation of the default ADL (Argument-Dependent Lookup) serializer used by nlohmann::json to convert types to JSON. It defines methods for both serialization (to_json) and deserialization (from_json).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T>\nstruct adl_serializer {\n    static void to_json(json& j, const T& value) {\n        // calls the \"to_json\" method in T's namespace\n    }\n\n    static void from_json(const json& j, T& value) {\n        // same thing, but with the \"from_json\" method\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Specializing ADL Serializer for boost::optional in C++\nDESCRIPTION: This code demonstrates how to add a specialization of adl_serializer to the nlohmann namespace for handling boost::optional types. It provides custom to_json and from_json implementations to properly serialize and deserialize optional values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// partial specialization (full specialization works too)\nNLOHMANN_JSON_NAMESPACE_BEGIN\ntemplate <typename T>\nstruct adl_serializer<boost::optional<T>> {\n    static void to_json(json& j, const boost::optional<T>& opt) {\n        if (opt == boost::none) {\n            j = nullptr;\n        } else {\n            j = *opt; // this will call adl_serializer<T>::to_json which will\n                      // find the free function to_json in T's namespace!\n        }\n    }\n\n    static void from_json(const json& j, boost::optional<T>& opt) {\n        if (j.is_null()) {\n            opt = boost::none;\n        } else {\n            opt = j.template get<T>(); // same as above, but with\n                              // adl_serializer<T>::from_json\n        }\n    }\n};\nNLOHMANN_JSON_NAMESPACE_END\n```\n\n----------------------------------------\n\nTITLE: External CMake Integration\nDESCRIPTION: Shows how to integrate nlohmann_json library as an external dependency using find_package()\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cmake.md#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\nproject(ExampleProject LANGUAGES CXX)\n\nfind_package(nlohmann_json 3.12.0 REQUIRED)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Implementing ADL Serializer for Non-Copyable Types in C++\nDESCRIPTION: This example shows how to specialize the adl_serializer for non-default constructible and non-copyable types that are MoveConstructible. It implements a custom from_json method that returns the constructed object and a to_json method for serialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstruct move_only_type {\n    move_only_type() = delete;\n    move_only_type(int ii): i(ii) {}\n    move_only_type(const move_only_type&) = delete;\n    move_only_type(move_only_type&&) = default;\n\n    int i;\n};\n\nnamespace nlohmann {\n    template <>\n    struct adl_serializer<move_only_type> {\n        // note: the return type is no longer 'void', and the method only takes\n        // one argument\n        static move_only_type from_json(const json& j) {\n            return {j.template get<int>()};\n        }\n\n        // Here's the catch! You must provide a to_json method! Otherwise, you\n        // will not be able to convert move_only_type to json, since you fully\n        // specialized adl_serializer on that type\n        static void to_json(json& j, move_only_type t) {\n            j = t.i;\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Custom Type Conversion in C++\nDESCRIPTION: Demonstrates a more efficient approach to custom type serialization using automatic conversion methods.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n// create a person\nns::person p {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// conversion: person -> json\njson j = p;\n\nstd::cout << j << std::endl;\n// {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n\n// conversion: json -> person\nauto p2 = j.template get<ns::person>();\n\n// that's it\nassert(p == p2);\n```\n\n----------------------------------------\n\nTITLE: Reading JSON from a file in C++\nDESCRIPTION: This snippet demonstrates how to read JSON data from a file using the nlohmann/json library. It opens a file, creates a json object, and uses the stream extraction operator to parse the file contents.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstd::ifstream f(\"example.json\");\njson data = json::parse(f);\n```\n\n----------------------------------------\n\nTITLE: Using Range-based For Loops with JSON in C++\nDESCRIPTION: Shows how to use C++11 range-based for loops with JSON objects. This example demonstrates direct iteration over JSON values without accessing keys.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto it : j_object)\n{\n    // \"it\" is of type json::reference and has no key() member\n    std::cout << \"value: \" << it << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JSON from Strings - C++\nDESCRIPTION: Demonstrates how to create JSON objects from string literals using the _json suffix and raw string literals. Shows both direct creation and explicit parsing approaches.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// create object from string literal\njson j = \"{ \\\"happy\\\": true, \\\"pi\\\": 3.141 }\"_json;\n\n// or even nicer with a raw string literal\nauto j2 = R\"(\n  {\n    \"happy\": true,\n    \"pi\": 3.141\n  }\n)\"_json;\n```\n\n----------------------------------------\n\nTITLE: Creating JSON objects from literals in C++\nDESCRIPTION: This example shows how to create JSON objects using JSON literals in C++. It demonstrates the creation of various JSON data types including objects, arrays, and primitive values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// create object from string literal\njson j = \"{\\\"happy\\\": true, \\\"pi\\\": 3.141}\";\n\n// or even nicer with a raw string literal\nauto j2 = R\"(\n  {\n    \"happy\": true,\n    \"pi\": 3.141\n  }\n)\"_json;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Conversion Functions for nlohmann/json in C++\nDESCRIPTION: Defines the necessary to_json and from_json functions to enable automatic conversion between a custom 'person' type and JSON. These functions must be in the same namespace as the custom type and available wherever conversions are used.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nusing json = nlohmann::json;\n\nnamespace ns {\n    void to_json(json& j, const person& p) {\n        j = json{ {\"name\", p.name}, {\"address\", p.address}, {\"age\", p.age} };\n    }\n\n    void from_json(const json& j, person& p) {\n        j.at(\"name\").get_to(p.name);\n        j.at(\"address\").get_to(p.address);\n        j.at(\"age\").get_to(p.age);\n    }\n} // namespace ns\n```\n\n----------------------------------------\n\nTITLE: Retrieving Objects Elements with Default Values in C++\nDESCRIPTION: Three overloads of the value method that allow accessing object elements by key or JSON pointer with default values. This provides safe access without throwing exceptions when elements don't exist.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<class ValueType>\nValueType value(const typename object_t::key_type& key,\n                ValueType&& default_value) const;\n\n// (2)\ntemplate<class ValueType, class KeyType>\nValueType value(KeyType&& key,\n                ValueType&& default_value) const;\n\n// (3)\ntemplate<class ValueType>\nValueType value(const json_pointer& ptr,\n                const ValueType& default_value) const;\n```\n\n----------------------------------------\n\nTITLE: JSON Merge Patch Operations in C++\nDESCRIPTION: Shows how to use JSON Merge Patch (RFC 7386) to modify JSON documents using a syntax that mirrors the document structure.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\n// a JSON value\njson j_document = R\"({\n  \"a\": \"b\",\n  \"c\": {\n    \"d\": \"e\",\n    \"f\": \"g\"\n  }\n})\"_json;\n\n// a patch\njson j_patch = R\"({\n  \"a\":\"z\",\n  \"c\": {\n    \"f\": null\n  }\n})\"_json;\n\n// apply the patch\nj_document.merge_patch(j_patch);\n// {\n//  \"a\": \"z\",\n//  \"c\": {\n//    \"d\": \"e\"\n//  }\n// }\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Serialization for Non-Intrusive Struct in C++\nDESCRIPTION: This snippet demonstrates how to use the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE macro to create to_json and from_json functions for a 'person' struct. This macro is used outside the struct definition and can't access private members.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nnamespace ns {\n    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(person, name, address, age)\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to MessagePack in C++\nDESCRIPTION: Function overloads for serializing JSON to MessagePack format. The first overload returns a byte vector, while the second and third write to output adapters for uint8_t and char respectively.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_msgpack.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nstatic std::vector<std::uint8_t> to_msgpack(const basic_json& j);\n\n// (2)\nstatic void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o);\nstatic void to_msgpack(const basic_json& j, detail::output_adapter<char> o);\n```\n\n----------------------------------------\n\nTITLE: JSON Container Creation from Initializer Lists (C++)\nDESCRIPTION: Demonstrates how to create JSON arrays and objects using initializer lists.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__list_init_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Custom Type Conversion Implementation in C++\nDESCRIPTION: Shows how to implement the necessary to_json and from_json functions for custom type conversion support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\nusing json = nlohmann::json;\n\nnamespace ns {\n    void to_json(json& j, const person& p) {\n        j = json{{\"name\", p.name}, {\"address\", p.address}, {\"age\", p.age}};\n    }\n\n    void from_json(const json& j, person& p) {\n        j.at(\"name\").get_to(p.name);\n        j.at(\"address\").get_to(p.address);\n        j.at(\"age\").get_to(p.age);\n    }\n} // namespace ns\n```\n\n----------------------------------------\n\nTITLE: Including nlohmann/json Library in C++\nDESCRIPTION: This snippet shows how to include the nlohmann/json library in a C++ file and create an alias for convenience. It requires the json.hpp file to be in the include path and C++11 support to be enabled in the compiler.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\n// for convenience\nusing json = nlohmann::json;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of nlohmann::json in C++\nDESCRIPTION: Example demonstrating how to use the nlohmann::json type, included from an external file 'examples/README.cpp'.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/README.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Manual JSON Conversion for Custom Types in C++\nDESCRIPTION: Demonstrates manual conversion between a custom 'person' struct and JSON object. This approach requires explicitly copying each field, which can be verbose for complex types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace ns {\n    // a simple struct to model a person\n    struct person {\n        std::string name;\n        std::string address;\n        int age;\n    };\n} // namespace ns\n\nns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// convert to JSON: copy each value into the JSON object\njson j;\nj[\"name\"] = p.name;\nj[\"address\"] = p.address;\nj[\"age\"] = p.age;\n\n// ...\n\n// convert from JSON: copy each value from the JSON object\nns::person p {\n    j[\"name\"].template get<std::string>(),\n    j[\"address\"].template get<std::string>(),\n    j[\"age\"].template get<int>()\n};\n```\n\n----------------------------------------\n\nTITLE: Applying JSON Patch to a Document (C++)\nDESCRIPTION: Demonstrates how to apply a JSON Patch to a JSON value by executing operations defined in the patch. This implementation follows RFC 6902 which defines a structure for expressing a sequence of operations to apply to a JSON document.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_patch.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/patch.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Serialization for Intrusive Class with Private Members in C++\nDESCRIPTION: This example shows how to use the NLOHMANN_DEFINE_TYPE_INTRUSIVE macro inside a class definition to create to_json and from_json functions. This macro can access private members and is used for the 'address' class.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nnamespace ns {\n    class address {\n      private:\n        std::string street;\n        int housenumber;\n        int postcode;\n\n      public:\n        NLOHMANN_DEFINE_TYPE_INTRUSIVE(address, street, housenumber, postcode)\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Applying JSON Merge Patch in C++\nDESCRIPTION: This code snippet demonstrates how to apply a JSON Merge Patch to a JSON document using the nlohmann/json library. It shows the creation of an original JSON object, a patch object, and the application of the patch using the merge_patch function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/merge_patch.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/merge_patch.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Binary Arrays with nlohmann::basic_json in C++\nDESCRIPTION: Static method to create JSON binary array values from binary containers, optionally with a specified subtype. These binary values are used for serialization to binary formats like CBOR, MessagePack, and BSON. This method exists to avoid ambiguity with standard JSON array initialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/binary.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nstatic basic_json binary(const typename binary_t::container_type& init);\nstatic basic_json binary(typename binary_t::container_type&& init);\n\n// (2)\nstatic basic_json binary(const typename binary_t::container_type& init,\n                         std::uint8_t subtype);\nstatic basic_json binary(typename binary_t::container_type&& init,\n                         std::uint8_t subtype);\n```\n\n----------------------------------------\n\nTITLE: STL-like Container Operations - C++\nDESCRIPTION: Demonstrates STL-like container operations including iteration, element access, modification, and common container operations like size and type checking.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n// create an array using push_back\njson j;\nj.push_back(\"foo\");\nj.push_back(1);\nj.push_back(true);\n\n// also use emplace_back\nj.emplace_back(1.78);\n\n// iterate the array\nfor (json::iterator it = j.begin(); it != j.end(); ++it) {\n  std::cout << *it << '\\n';\n}\n\n// range-based for\nfor (auto& element : j) {\n  std::cout << element << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Check Using String View in C++17\nDESCRIPTION: Shows how to use the contains() method with string_view in C++17 to check for key existence. This leverages the template overload of the contains method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/contains.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/contains__keytype.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: FetchContent CMake Integration\nDESCRIPTION: Demonstrates how to use FetchContent to automatically download and integrate nlohmann_json library at configure time\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cmake.md#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.11)\nproject(ExampleProject LANGUAGES CXX)\n\ninclude(FetchContent)\n\nFetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.12.0/json.tar.xz)\nFetchContent_MakeAvailable(json)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n```\n\nLANGUAGE: cmake\nCODE:\n```\nFetchContent_Declare(json\n    GIT_REPOSITORY https://github.com/nlohmann/json\n    GIT_TAG v3.12.0\n)\n```\n\n----------------------------------------\n\nTITLE: Deserializing CBOR to JSON - Input Adapter Overload\nDESCRIPTION: Template function that deserializes CBOR data from a compatible input source like std::istream, FILE pointer, or character array into a JSON value. Supports strict mode, exception handling, and CBOR tag handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_cbor.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename InputType>\nstatic basic_json from_cbor(InputType&& i,\n                            const bool strict = true,\n                            const bool allow_exceptions = true,\n                            const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error);\n```\n\n----------------------------------------\n\nTITLE: CBOR Deserialization Example in C++\nDESCRIPTION: Example demonstrating how to deserialize CBOR data into JSON objects using the nlohmann/json library. Shows handling of various CBOR data types and their corresponding JSON representations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/cbor.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_cbor.cpp\"\n```\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_cbor.output\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SAX Interface for JSON Parsing in C++\nDESCRIPTION: This example shows how to implement a custom SAX interface to handle parse errors. It defines a sax_no_exception class that overrides the parse_error method to provide custom error handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parse_exceptions.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass sax_no_exception : public nlohmann::detail::json_sax_dom_parser<json>\n{\n  public:\n    sax_no_exception(json& j)\n      : nlohmann::detail::json_sax_dom_parser<json>(j, false)\n    {}\n    \n    bool parse_error(std::size_t position,\n                     const std::string& last_token,\n                     const json::exception& ex)\n    {\n        std::cerr << \"parse error at input byte \" << position << \"\\n\"\n                  << ex.what() << \"\\n\"\n                  << \"last read: \\\"\" << last_token << \"\\\"\"\n                  << std::endl;\n        return false;\n    }\n};\n\nint main()\n{\n    std::string myinput = \"[1,2,3,]\";\n\n    json result;\n    sax_no_exception sax(result);\n    \n    bool parse_result = json::sax_parse(myinput, &sax);\n    if (!parse_result)\n    {\n        std::cerr << \"parsing unsuccessful!\" << std::endl;\n    }\n    \n    std::cout << \"parsed value: \" << result << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Intrusive Type Serialization with Private Members in C++\nDESCRIPTION: Example of using NLOHMANN_DEFINE_TYPE_INTRUSIVE macro for a class with private members.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace ns {\n    class address {\n      private:\n        std::string street;\n        int housenumber;\n        int postcode;\n  \n      public:\n        NLOHMANN_DEFINE_TYPE_INTRUSIVE(address, street, housenumber, postcode)\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Type Serialization in C++\nDESCRIPTION: Shows how to implement manual serialization for custom types using explicit property mapping between JSON and C++ structs.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace ns {\n    // a simple struct to model a person\n    struct person {\n        std::string name;\n        std::string address;\n        int age;\n    };\n}\n\nns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// convert to JSON: copy each value into the JSON object\njson j;\nj[\"name\"] = p.name;\nj[\"address\"] = p.address;\nj[\"age\"] = p.age;\n\n// ...\n\n// convert from JSON: copy each value from the JSON object\nns::person p {\n    j[\"name\"].template get<std::string>(),\n    j[\"address\"].template get<std::string>(),\n    j[\"age\"].template get<int>()\n};\n```\n\n----------------------------------------\n\nTITLE: Example: Check Key Existence in JSON Object\nDESCRIPTION: Demonstrates how to use the contains() method to check if a specific key exists in a JSON object. Returns true if the key exists, false otherwise.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/contains.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/contains__object_t_key_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Binary Values to JSON Format in C++\nDESCRIPTION: Demonstrates how binary values are serialized to standard JSON format as objects with bytes and subtype fields.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// serialize to standard output\nstd::cout << j.dump(2) << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON from Various Input Types in C++\nDESCRIPTION: Two overloads of the parse function for deserializing JSON from different input types. The first overload handles compatible input types like streams and strings, while the second overload works with pairs of character iterators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/parse.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic basic_json parse(InputType&& i,\n                        const parser_callback_t cb = nullptr,\n                        const bool allow_exceptions = true,\n                        const bool ignore_comments = false);\n\n// (2)\ntemplate<typename IteratorType>\nstatic basic_json parse(IteratorType first, IteratorType last,\n                        const parser_callback_t cb = nullptr,\n                        const bool allow_exceptions = true,\n                        const bool ignore_comments = false);\n```\n\n----------------------------------------\n\nTITLE: JSON Iterator Range Parsing - C++\nDESCRIPTION: Shows how to parse JSON from iterator ranges, supporting UTF-8, UTF-16 and UTF-32 encoded data from containers like vectors and lists.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<std::uint8_t> v = {'t', 'r', 'u', 'e'};\njson j = json::parse(v.begin(), v.end());\n```\n\n----------------------------------------\n\nTITLE: JSON String Serialization - C++\nDESCRIPTION: Shows how to convert JSON objects to strings, including pretty printing with indentation. Demonstrates the difference between serialization and direct string assignment.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// explicit conversion to string\nstd::string s = j.dump();    // {\"happy\":true,\"pi\":3.141}\n\n// serialization with pretty printing\n// pass in the amount of spaces to indent\nstd::cout << j.dump(4) << std::endl;\n// {\n//     \"happy\": true,\n//     \"pi\": 3.141\n// }\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE in C++\nDESCRIPTION: A complete example showing how to use the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE macro for serializing and deserializing a custom type. The macro is used outside the class definition but inside its namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implicit Type Conversions with JSON in C++\nDESCRIPTION: Examples of implicit conversions between basic C++ types and JSON values, including strings, booleans, and numbers. Includes recommendations against using implicit conversions from JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\n// strings\nstd::string s1 = \"Hello, world!\";\njson js = s1;\nauto s2 = js.template get<std::string>();\n// NOT RECOMMENDED\nstd::string s3 = js;\nstd::string s4;\ns4 = js;\n\n// Booleans\nbool b1 = true;\njson jb = b1;\nauto b2 = jb.template get<bool>();\n// NOT RECOMMENDED\nbool b3 = jb;\nbool b4;\nb4 = jb;\n\n// numbers\nint i = 42;\njson jn = i;\nauto f = jn.template get<double>();\n// NOT RECOMMENDED\ndouble f2 = jb;\ndouble f3;\nf3 = jb;\n```\n\n----------------------------------------\n\nTITLE: Implementation Example of adl_serializer in C++\nDESCRIPTION: Example implementation of the adl_serializer template. It defines two static methods: to_json for converting a value to JSON and from_json for converting JSON back to a value. Both methods use ADL to find appropriate conversion functions in the value type's namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/adl_serializer/index.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ValueType>\nstruct adl_serializer {\n    template<typename BasicJsonType>\n    static void to_json(BasicJsonType& j, const T& value) {\n        // calls the \"to_json\" method in T's namespace\n    }\n\n    template<typename BasicJsonType>\n    static void from_json(const BasicJsonType& j, T& value) {\n        // same thing, but with the \"from_json\" method\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON SAX Parsing in C++\nDESCRIPTION: This example demonstrates how to use the SAX interface for parsing JSON. It includes the implementation of the SAX event handlers and shows how to parse a JSON string using the SAX parser.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/string.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Value Type Enumeration and Union Structure\nDESCRIPTION: Definition of supported JSON value types through an enum class and corresponding union structure for storing different value types. Includes support for null, object, array, string, boolean, various number types, and binary data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/architecture.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nenum class value_t : std::uint8_t\n{\n    null,             ///< null value\n    object,           ///< object (unordered set of name/value pairs)\n    array,            ///< array (ordered collection of values)\n    string,           ///< string value\n    boolean,          ///< boolean value\n    number_integer,   ///< number value (signed integer)\n    number_unsigned,  ///< number value (unsigned integer)\n    number_float,     ///< number value (floating-point)\n    binary,           ///< binary array (ordered collection of bytes)\n    discarded         ///< discarded by the parser callback function\n};\n\nunion json_value {\n  /// object (stored with pointer to save storage)\n  object_t *object;\n  /// array (stored with pointer to save storage)\n  array_t *array;\n  /// string (stored with pointer to save storage)\n  string_t *string;\n  /// binary (stored with pointer to save storage)\n  binary_t *binary;\n  /// boolean\n  boolean_t boolean;\n  /// number (integer)\n  number_integer_t number_integer;\n  /// number (unsigned integer)\n  number_unsigned_t number_unsigned;\n  /// number (floating-point)\n  number_float_t number_float;\n};\n```\n\n----------------------------------------\n\nTITLE: Reading JSON from a File in C++\nDESCRIPTION: Demonstrates how to read a JSON file and parse it into a json object using the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <fstream>\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\n\n// ...\n\nstd::ifstream f(\"example.json\");\njson data = json::parse(f);\n```\n\n----------------------------------------\n\nTITLE: Converting STL Associative Containers to JSON Objects in C++\nDESCRIPTION: Examples of converting STL associative containers (map, unordered_map, multimap, unordered_multimap) to JSON objects. Demonstrates key-value pair handling and special cases for multi-containers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nstd::map<std::string, int> c_map { {\"one\", 1}, {\"two\", 2}, {\"three\", 3} };\njson j_map(c_map);\n// {\"one\": 1, \"three\": 3, \"two\": 2 }\n\nstd::unordered_map<const char*, double> c_umap { {\"one\", 1.2}, {\"two\", 2.3}, {\"three\", 3.4} };\njson j_umap(c_umap);\n// {\"one\": 1.2, \"two\": 2.3, \"three\": 3.4}\n\nstd::multimap<std::string, bool> c_mmap { {\"one\", true}, {\"two\", true}, {\"three\", false}, {\"three\", true} };\njson j_mmap(c_mmap); // only one entry for key \"three\" is used\n// maybe {\"one\": true, \"two\": true, \"three\": true}\n\nstd::unordered_multimap<std::string, bool> c_ummap { {\"one\", true}, {\"two\", true}, {\"three\", false}, {\"three\", true} };\njson j_ummap(c_ummap); // only one entry for key \"three\" is used\n// maybe {\"one\": true, \"two\": true, \"three\": true}\n```\n\n----------------------------------------\n\nTITLE: Example: Check Using JSON Pointer\nDESCRIPTION: Demonstrates how to use the contains() method with a JSON pointer to check if a specific path exists within the JSON structure.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/contains.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/contains__json_pointer.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Deserializing BSON to JSON in C++\nDESCRIPTION: This example illustrates how to deserialize a BSON object back into JSON format using the nlohmann/json library. It reads BSON data and converts it to a JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bson.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_bson.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Basic Usage Example of NLOHMANN_JSON_SERIALIZE_ENUM in C++\nDESCRIPTION: Example demonstrating how to use the macro to serialize/deserialize both traditional enums and C++11 enum classes with custom string representations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_serialize_enum.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_json_serialize_enum.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Pointer and Patch Operations in C++\nDESCRIPTION: Demonstrates using JSON Pointer (RFC 6901) for accessing nested values and JSON Patch (RFC 6902) for describing and applying differences between JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\n// a JSON value\njson j_original = R\"({\n  \"baz\": [\"one\", \"two\", \"three\"],\n  \"foo\": \"bar\"\n})\"_json;\n\n// access members with a JSON pointer (RFC 6901)\nj_original[\"/baz/1\"_json_pointer];\n// \"two\"\n\n// a JSON patch (RFC 6902)\njson j_patch = R\"([\n  { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },\n  { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },\n  { \"op\": \"remove\", \"path\": \"/foo\"}\n])\"_json;\n\n// apply the patch\njson j_result = j_original.patch(j_patch);\n// {\n//    \"baz\": \"boo\",\n//    \"hello\": [\"world\"]\n// }\n\n// calculate a JSON patch from two JSON values\njson::diff(j_result, j_original);\n// [\n//   { \"op\":\" replace\", \"path\": \"/baz\", \"value\": [\"one\", \"two\", \"three\"] },\n//   { \"op\": \"remove\",\"path\": \"/hello\" },\n//   { \"op\": \"add\", \"path\": \"/foo\", \"value\": \"bar\" }\n// ]\n```\n\n----------------------------------------\n\nTITLE: Calculating JSON Diff Between Documents (C++)\nDESCRIPTION: Shows how to calculate a JSON patch (diff) between two JSON values, which generates a series of operations that transform one JSON document into another.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_patch.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diff.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Values to MessagePack in C++\nDESCRIPTION: Shows how to convert JSON with binary values to MessagePack format, which supports both binary values and subtypes through different encoding families.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to MessagePack\nauto v = json::to_msgpack(j);\n```\n\n----------------------------------------\n\nTITLE: Converting BJData to JSON using nlohmann/json library in C++\nDESCRIPTION: This code snippet demonstrates how to use the nlohmann/json library to convert BJData to JSON. It includes various BJData types and their corresponding JSON representations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bjdata.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_bjdata.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Embedded CMake Integration\nDESCRIPTION: Demonstrates how to embed the nlohmann_json library directly into a CMake project using add_subdirectory()\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cmake.md#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\nproject(ExampleProject LANGUAGES CXX)\n\nset(JSON_Install OFF CACHE INTERNAL \"\")\n\nadd_subdirectory(nlohmann_json)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Comments using nlohmann/json in C++\nDESCRIPTION: This example demonstrates how to parse a JSON string containing comments using the nlohmann/json library. It shows both the default behavior (which throws an exception when comments are encountered) and how to parse the same JSON string with the 'ignore_comments' parameter set to true.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/comments.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string s = R\"(\n    {\n        // update in 2006: removed Pluto\n        \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                    \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */]\n    }\n    )\";\n    \n    try\n    {\n        json j = json::parse(s);\n    }\n    catch (json::exception &e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n    \n    json j = json::parse(s,\n                         /* callback */ nullptr,\n                         /* allow exceptions */ true,\n                         /* ignore_comments */ true);\n    std::cout << j.dump(2) << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: CBOR Serialization Example in C++\nDESCRIPTION: This code snippet demonstrates how to serialize JSON data to CBOR format using the nlohmann/json library. It creates a JSON object with various data types and converts it to CBOR, then prints the hexadecimal representation of the CBOR output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/cbor.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_cbor.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example: Updating JSON Object in C++\nDESCRIPTION: Demonstrates how to use the update() function to merge JSON objects, including the handling of user settings and default configurations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/update.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nauto user_settings = json::parse(\"config.json\");\nauto effective_settings = get_default_settings();\neffective_settings.update(user_settings);\n```\n\n----------------------------------------\n\nTITLE: JSON Stream Operations - C++\nDESCRIPTION: Demonstrates reading and writing JSON using standard streams, including file operations and pretty printing using stream manipulators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n// deserialize from standard input\njson j;\nstd::cin >> j;\n\n// serialize to standard output\nstd::cout << j;\n\n// the setw manipulator was overloaded to set the indentation for pretty printing\nstd::cout << std::setw(4) << j << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Defining NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE Macro Variants in C++\nDESCRIPTION: Three macro definitions for non-intrusive JSON serialization/deserialization. These macros enable using JSON objects for serialization with member variable names as object keys. They must be defined outside the class/struct but inside its namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(type, member...)              // (1)\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(type, member...) // (2)\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(type, member...) // (3)\n```\n\n----------------------------------------\n\nTITLE: Unflattening JSON Object in C++\nDESCRIPTION: Shows how to use the unflatten() function to recreate the original JSON structure from a flattened JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_pointer.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nauto j_original = j_flat.unflatten();\n```\n\n----------------------------------------\n\nTITLE: Using the array Function to Create JSON Arrays in C++\nDESCRIPTION: Example demonstrating how to use the array function to create JSON arrays, including an empty array and an array with various data types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/array.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"examples/array.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Enum Serialization in C++\nDESCRIPTION: Example of specialized enum serialization using NLOHMANN_JSON_SERIALIZE_ENUM macro to map enum values to JSON strings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\nenum TaskState {\n    TS_STOPPED,\n    TS_RUNNING,\n    TS_COMPLETED,\n    TS_INVALID=-1,\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM( TaskState, {\n    {TS_INVALID, nullptr},\n    {TS_STOPPED, \"stopped\"},\n    {TS_RUNNING, \"running\"},\n    {TS_COMPLETED, \"completed\"},\n})\n```\n\n----------------------------------------\n\nTITLE: Using items() Method for Range-based For Loops in C++\nDESCRIPTION: Demonstrates the items() method which allows accessing both keys and values in range-based for loops. This approach provides access to key() and value() methods during iteration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto& el : j_object.items())\n{\n    std::cout << \"key: \" << el.key() << \", value:\" << el.value() << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Structured Bindings Example with JSON Objects\nDESCRIPTION: Demonstrates the new structured bindings support for iterating over JSON objects using the items() member function, allowing destructuring of key-value pairs.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor (auto& [key, val] : j.items()) {\n    std::cout << key << ':' << val << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Basic UBJSON Binary Serialization in C++\nDESCRIPTION: Demonstrates basic serialization of binary data to UBJSON format. Creates a binary value with subtype 42 and converts it to UBJSON format, resulting in a vector of uint8 values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42 (will be ignored in UBJSON)\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to UBJSON\nauto v = json::to_ubjson(j);\n```\n\n----------------------------------------\n\nTITLE: Using Binary Values as std::vector in C++\nDESCRIPTION: Demonstrates how to use binary values with std::vector methods since json::binary_t inherits from std::vector<std::uint8_t>.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nbinary.size();  // returns 4\nbinary[1];      // returns 0xFE\n```\n\n----------------------------------------\n\nTITLE: Optimized UBJSON Binary Serialization in C++\nDESCRIPTION: Shows how to use type and size optimization when serializing to UBJSON format. This optimization can be more efficient for larger datasets but may not be beneficial for small amounts of data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\n// convert to UBJSON using the size and type optimization\nauto v = json::to_ubjson(j, true, true);\n```\n\n----------------------------------------\n\nTITLE: Converting STL Sequence Containers to JSON Arrays in C++\nDESCRIPTION: Examples of converting various STL sequence containers (vector, deque, list, forward_list, array) and associative containers (set types) to JSON arrays. Shows how different container types are handled and their resulting JSON representation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<int> c_vector {1, 2, 3, 4};\njson j_vec(c_vector);\n// [1, 2, 3, 4]\n\nstd::deque<double> c_deque {1.2, 2.3, 3.4, 5.6};\njson j_deque(c_deque);\n// [1.2, 2.3, 3.4, 5.6]\n\nstd::list<bool> c_list {true, true, false, true};\njson j_list(c_list);\n// [true, true, false, true]\n\nstd::forward_list<int64_t> c_flist {12345678909876, 23456789098765, 34567890987654, 45678909876543};\njson j_flist(c_flist);\n// [12345678909876, 23456789098765, 34567890987654, 45678909876543]\n\nstd::array<unsigned long, 4> c_array {{1, 2, 3, 4}};\njson j_array(c_array);\n// [1, 2, 3, 4]\n\nstd::set<std::string> c_set {\"one\", \"two\", \"three\", \"four\", \"one\"};\njson j_set(c_set); // only one entry for \"one\" is used\n// [\"four\", \"one\", \"three\", \"two\"]\n\nstd::unordered_set<std::string> c_uset {\"one\", \"two\", \"three\", \"four\", \"one\"};\njson j_uset(c_uset); // only one entry for \"one\" is used\n// maybe [\"two\", \"three\", \"four\", \"one\"]\n\nstd::multiset<std::string> c_mset {\"one\", \"two\", \"one\", \"four\"};\njson j_mset(c_mset); // both entries for \"one\" are used\n// maybe [\"one\", \"two\", \"one\", \"four\"]\n\nstd::unordered_multiset<std::string> c_umset {\"one\", \"two\", \"one\", \"four\"};\njson j_umset(c_umset); // both entries for \"one\" are used\n// maybe [\"one\", \"two\", \"one\", \"four\"]\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing JSON to Binary Formats in C++\nDESCRIPTION: Demonstrates how to serialize a JSON object to BSON, CBOR, MessagePack, and UBJSON binary formats, and then deserialize them back to JSON. It shows the compact binary representation for each format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_30\n\nLANGUAGE: cpp\nCODE:\n```\n// create a JSON value\njson j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n// serialize to BSON\nstd::vector<std::uint8_t> v_bson = json::to_bson(j);\n\n// 0x1B, 0x00, 0x00, 0x00, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0x00, 0x01, 0x10, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\n// roundtrip\njson j_from_bson = json::from_bson(v_bson);\n\n// serialize to CBOR\nstd::vector<std::uint8_t> v_cbor = json::to_cbor(j);\n\n// 0xA2, 0x67, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0xF5, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00\n\n// roundtrip\njson j_from_cbor = json::from_cbor(v_cbor);\n\n// serialize to MessagePack\nstd::vector<std::uint8_t> v_msgpack = json::to_msgpack(j);\n\n// 0x82, 0xA7, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0xC3, 0xA6, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00\n\n// roundtrip\njson j_from_msgpack = json::from_msgpack(v_msgpack);\n\n// serialize to UBJSON\nstd::vector<std::uint8_t> v_ubjson = json::to_ubjson(j);\n\n// 0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D\n\n// roundtrip\njson j_from_ubjson = json::from_ubjson(v_ubjson);\n```\n\n----------------------------------------\n\nTITLE: SAX Interface Callback Functions in C++\nDESCRIPTION: Detailed list of all SAX interface callback functions that must be implemented when creating a custom SAX handler for the nlohmann/json library. Each function returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/sax_interface.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// called when null is parsed\nbool null();\n\n// called when a boolean is parsed; value is passed\nbool boolean(bool val);\n\n// called when a signed or unsigned integer number is parsed; value is passed\nbool number_integer(number_integer_t val);\nbool number_unsigned(number_unsigned_t val);\n\n// called when a floating-point number is parsed; value and original string is passed\nbool number_float(number_float_t val, const string_t& s);\n\n// called when a string is parsed; value is passed and can be safely moved away\nbool string(string_t& val);\n// called when a binary value is parsed; value is passed and can be safely moved away\nbool binary(binary_t& val);\n\n// called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known)\nbool start_object(std::size_t elements);\nbool end_object();\nbool start_array(std::size_t elements);\nbool end_array();\n// called when an object key is parsed; value is passed and can be safely moved away\nbool key(string_t& val);\n\n// called when a parse error occurs; byte position, the last token, and an exception is passed\nbool parse_error(std::size_t position, const std::string& last_token, const json::exception& ex);\n```\n\n----------------------------------------\n\nTITLE: Converting MessagePack to JSON with nlohmann/json\nDESCRIPTION: Example demonstrating how to deserialize MessagePack binary data back to JSON using the from_msgpack function from the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/messagepack.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_msgpack.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to UBJSON Format in C++\nDESCRIPTION: Demonstrates how to convert a JSON object to UBJSON format using the to_ubjson function. This example shows both basic conversion and optimized container formats with use_size and use_type parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/ubjson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_ubjson.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using JSON SAX Interface in C++\nDESCRIPTION: Example demonstrating how to use the SAX interface for parsing JSON, including the start_array method. This snippet shows the implementation of a custom SAX event handler.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/start_array.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Including JSON Library in C++\nDESCRIPTION: Shows how to include the entire JSON library, which consists of a single header file. This demonstrates the trivial integration aspect of the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/design_goals.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <nlohmann/json.hpp>\n```\n\n----------------------------------------\n\nTITLE: Accessing Binary Values from JSON Objects in C++\nDESCRIPTION: Demonstrates how to access binary data through the get_binary() method from a JSON object containing binary values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nj.get_binary().has_subtype();  // returns true\nj.get_binary().size();         // returns 4\n```\n\n----------------------------------------\n\nTITLE: Implementing >= Operator Overloads for JSON Value Comparisons in C++\nDESCRIPTION: Overloaded implementations of the greater than or equal operator for nlohmann::basic_json. Includes comparing two JSON values and comparing JSON values with scalar types. The operators determine whether one value is greater than or equal to another following specific comparison rules.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_ge.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator>=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator>=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator>=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Values from Compatible Types (C++)\nDESCRIPTION: Illustrates creation of JSON values from various compatible C++ types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__CompatibleType.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Elements with string_view in C++17\nDESCRIPTION: Shows how to read object elements using the operator[] with string_view in C++17.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__keytype.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Intrusive Type Serialization Macros in C++\nDESCRIPTION: Defines three macros for simplifying JSON serialization/deserialization of types with different behaviors regarding missing keys and serialization-only support. These macros need to be defined inside the class/struct to create code for.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(type, member...)              // (1)\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(type, member...) // (2)\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(type, member...) // (3)\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON Values with nlohmann::basic_json::dump in C++\nDESCRIPTION: Method signature for the dump function that serializes JSON values to strings. The function supports customizable indentation levels, indentation characters, ASCII output enforcement, and error handling strategies.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/dump.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstring_t dump(const int indent = -1,\n              const char indent_char = ' ',\n              const bool ensure_ascii = false,\n              const error_handler_t error_handler = error_handler_t::strict) const;\n```\n\n----------------------------------------\n\nTITLE: Defining the array Function for JSON Array Creation in C++\nDESCRIPTION: Static function that creates a JSON array value from a given initializer list. It handles edge cases like creating an empty array or an array of string-value pairs.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/array.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstatic basic_json array(initializer_list_t init = {});\n```\n\n----------------------------------------\n\nTITLE: Range-Based Loop With items() Function\nDESCRIPTION: Example showing how to use the items() function with range-based for loops to access both keys and values efficiently.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/items.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto& el : j_object.items())\n{\n    std::cout << \"key: \" << el.key() << \", value:\" << el.value() << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Number Types in nlohmann/json using C++ Templates\nDESCRIPTION: Demonstrates how to create a custom basic_json type that uses long double as the floating-point type. This allows for greater precision in floating-point operations when needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nusing json_ld = nlohmann::basic_json<std::map, std::vector, std::string, bool,\n                                         std::int64_t, std::uint64_t, long double>;\n```\n\n----------------------------------------\n\nTITLE: Custom Floating-Point Comparison with Epsilon\nDESCRIPTION: Example of implementing a custom floating-point comparison function that respects an epsilon value, useful for more accurate floating-point comparisons than the default operator==.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>\ninline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept\n{\n    return std::abs(a - b) <= epsilon;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing JSON Values with JSON Pointers in C++\nDESCRIPTION: Shows how to use JSON Pointers to access values in a JSON object. This can be done using the at(), operator[], and value() functions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_pointer.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// the JSON value from above\nauto j = json::parse(R\"({\n    \"array\": [\"A\", \"B\", \"C\"],\n    \"nested\": {\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": [true, false]\n    }\n})\");\n\n// access values\nauto val = j[\"\"_json_pointer];                              // {\"array\":[\"A\",\"B\",\"C\"],...}\nauto val1 = j[\"/nested/one\"_json_pointer];                  // 1\nauto val2 = j.at(json::json_pointer(\"/nested/three/1\"));    // false\nauto val3 = j.value(json::json_pointer(\"/nested/four\"), 0); // 0\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Values with Various Types (C++)\nDESCRIPTION: Demonstrates constructor usage with different value_t types to create empty JSON values of specific types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__value_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT Macro in C++\nDESCRIPTION: Example of using NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT macro which uses the 'value' method for deserialization, falling back to default values when keys are missing in the JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_with_default_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Accessing JSON Elements with Bounds Checking using at() Method in C++\nDESCRIPTION: Signature definitions for the at() method in nlohmann::basic_json. The method provides four overloads: (1) for array elements by index, (2) for object elements by key, (3) for object elements with compatible key types, and (4) for elements via JSON pointer. All overloads perform bounds checking and throw appropriate exceptions for invalid access.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/at.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nreference at(size_type idx);\nconst_reference at(size_type idx) const;\n\n// (2)\nreference at(const typename object_t::key_type& key);\nconst_reference at(const typename object_t::key_type& key) const;\n\n// (3)\ntemplate<typename KeyType>\nreference at(KeyType&& key);\ntemplate<typename KeyType>\nconst_reference at(KeyType&& key) const;\n\n// (4)\nreference at(const json_pointer& ptr);\nconst_reference at(const json_pointer& ptr) const;\n```\n\n----------------------------------------\n\nTITLE: Catching invalid_iterator Exception in C++\nDESCRIPTION: Example code demonstrating how to catch an invalid_iterator exception when using the JSON library. This shows the proper error handling pattern for iterator-related errors.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/invalid_iterator.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring diff Function for JSON Patch Generation in C++\nDESCRIPTION: Function signature for the diff method in the nlohmann::basic_json class. It takes two basic_json objects as input and returns a JSON Patch to transform the source into the target.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/diff.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic basic_json diff(const basic_json& source,\n                       const basic_json& target);\n```\n\n----------------------------------------\n\nTITLE: Enum Serialization Usage Examples in C++\nDESCRIPTION: Demonstration of using serialized enums including conversion to/from JSON and handling undefined values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_29\n\nLANGUAGE: cpp\nCODE:\n```\njson j = TS_STOPPED;\nassert(j == \"stopped\");\n\njson j3 = \"running\";\nassert(j3.template get<TaskState>() == TS_RUNNING);\n\njson jPi = 3.14;\nassert(jPi.template get<TaskState>() == TS_INVALID);\n```\n\n----------------------------------------\n\nTITLE: Type Conversion Implementation Example for get Method\nDESCRIPTION: Example implementation showing how the get method converts JSON to a ValueType by using the from_json serializer method. This shows the internal implementation logic of the first overload.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nValueType ret;\nJSONSerializer<ValueType>::from_json(*this, ret);\nreturn ret;\n```\n\n----------------------------------------\n\nTITLE: Implementing to_json Template Function in ADL Serializer\nDESCRIPTION: Template function definition for converting custom types to JSON. This function is called by basic_json constructors to serialize values. It uses ADL (Argument Dependent Lookup) to find the appropriate to_json implementation for the target type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/adl_serializer/to_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType, typename TargetType = ValueType>\nstatic auto to_json(BasicJsonType& j, TargetType && val) noexcept(\n    noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))\n-> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())\n```\n\n----------------------------------------\n\nTITLE: Defining basic_json Template Class in C++\nDESCRIPTION: Template definition for the basic_json class, which is the core class of the nlohmann/json library. It includes various template parameters for customizing the JSON object's behavior and underlying data types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<\n    template<typename U, typename V, typename... Args> class ObjectType = std::map,\n    template<typename U, typename... Args> class ArrayType = std::vector,\n    class StringType = std::string,\n    class BooleanType = bool,\n    class NumberIntegerType = std::int64_t,\n    class NumberUnsignedType = std::uint64_t,\n    class NumberFloatType = double,\n    template<typename U> class AllocatorType = std::allocator,\n    template<typename T, typename SFINAE = void> class JSONSerializer = adl_serializer,\n    class BinaryType = std::vector<std::uint8_t>,\n    class CustomBaseClass = void\n>\nclass basic_json;\n```\n\n----------------------------------------\n\nTITLE: Using get_to Function for JSON Deserialization in C++\nDESCRIPTION: The get_to function writes a JSON value to a passed reference. It automatically deduces the destination type, allowing for more concise code compared to the get function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nget_to\n```\n\n----------------------------------------\n\nTITLE: NLOHMANN_JSON_SERIALIZE_ENUM Macro Definition in C++\nDESCRIPTION: The macro definition that enables custom enum serialization and deserialization in the nlohmann/json library. It takes an enum type and conversion pairs as parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_serialize_enum.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_SERIALIZE_ENUM(type, conversion...)\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Equality Operators in C++\nDESCRIPTION: Defines equality comparison operators for JSON values, supporting both pre-C++20 and C++20 implementations. Includes overloads for comparing JSON values with scalar types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_eq.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator==(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator==(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator==(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n\n// since C++20\nclass basic_json {\n    bool operator==(const_reference rhs) const noexcept;              // (1)\n\n    template<typename ScalarType>\n    bool operator==(ScalarType rhs) const noexcept;                   // (2)\n};\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Exception Handling in C++\nDESCRIPTION: This snippet demonstrates how to parse JSON input using a try/catch block to handle parse errors. It catches json::parse_error exceptions and outputs the error position.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parse_exceptions.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson j;\ntry\n{\n    j = json::parse(my_input);\n}\ncatch (json::parse_error& ex)\n{\n    std::cerr << \"parse error at byte \" << ex.byte << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Const Object Elements with string_view in C++17\nDESCRIPTION: Illustrates how to read object elements using the const version of operator[] with string_view in C++17.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__keytype_const.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using items() With C++17 Structured Bindings\nDESCRIPTION: Example demonstrating the usage of items() with C++17 structured bindings for even more concise key-value iteration syntax.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/items.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto& [key, val] : j_object.items())\n{\n    std::cout << \"key: \" << key << \", value:\" << val << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON Patch Application in C++\nDESCRIPTION: Code snippet showing that applying the generated patch to the source always results in the target. This demonstrates the correctness of the diff function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/diff.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nsource.patch(diff(source, target)) == target;\n```\n\n----------------------------------------\n\nTITLE: Flattening JSON Object with JSON Pointers in C++\nDESCRIPTION: Demonstrates how to use the flatten() function to convert a JSON document into a flat structure where keys are JSON Pointers and values are primitive JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_pointer.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// the JSON value from above\nauto j = json::parse(R\"({\n    \"array\": [\"A\", \"B\", \"C\"],\n    \"nested\": {\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": [true, false]\n    }\n})\");\n\n// create flattened value\nauto j_flat = j.flatten();\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements with operator[] in C++\nDESCRIPTION: Demonstrates how to read and write array elements using the operator[]. Shows the addition of null values when accessing out-of-range indices.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__size_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using emplace Method with nlohmann::json in C++\nDESCRIPTION: Example demonstrating how to use emplace() to add elements to a JSON object. Shows automatic conversion of null values to objects and handling of duplicate keys.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/emplace.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/emplace.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_JSON_SERIALIZE_ENUM Macro for Enum/JSON Mapping in C++\nDESCRIPTION: This macro simplifies the process of defining custom enum to JSON mappings. It allows specifying enum-value pairs for serialization and deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nNLOHMANN_JSON_SERIALIZE_ENUM\n```\n\n----------------------------------------\n\nTITLE: Converting JSON to MessagePack with nlohmann/json\nDESCRIPTION: Example demonstrating how to serialize JSON data to MessagePack binary format using the to_msgpack function from the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/messagepack.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_msgpack.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Applying JSON Patch In-Place in C++\nDESCRIPTION: Function signature for the patch_inplace method that applies a JSON Patch document to the current JSON value in place. Takes a JSON patch document as input and modifies the original document without returning a value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/patch_inplace.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid patch_inplace(const basic_json& json_patch) const;\n```\n\n----------------------------------------\n\nTITLE: Updating JSON Objects in C++\nDESCRIPTION: Function signatures for updating JSON objects with values from another JSON object or a range of iterators. The merge_objects parameter controls whether existing keys are overwritten or objects are recursively merged.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/update.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nvoid update(const_reference j, bool merge_objects = false);\n\n// (2)\nvoid update(const_iterator first, const_iterator last, bool merge_objects = false);\n```\n\n----------------------------------------\n\nTITLE: Defining Template Arguments for basic_json Class in C++\nDESCRIPTION: This code snippet shows the template arguments for the basic_json class, which allow customization of the underlying types used for storing JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<\n    template<typename U, typename V, typename... Args> class ObjectType = std::map,\n    template<typename U, typename... Args> class ArrayType = std::vector,\n    class StringType = std::string,\n    class BooleanType = bool,\n    class NumberIntegerType = std::int64_t,\n    class NumberUnsignedType = std::uint64_t,\n    class NumberFloatType = double,\n    template<typename U> class AllocatorType = std::allocator,\n    template<typename T, typename SFINAE = void> class JSONSerializer = adl_serializer,\n    class BinaryType = std::vector<std::uint8_t>\n>\nclass basic_json;\n```\n\n----------------------------------------\n\nTITLE: Custom Iterator Implementation - C++\nDESCRIPTION: Example of implementing a custom iterator that satisfies the LegacyInputIterator concept for use with JSON parsing.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nstruct MyContainer {\n  void advance();\n  const char& get_current();\n};\n\nstruct MyIterator {\n    using difference_type = std::ptrdiff_t;\n    using value_type = char;\n    using pointer = const char*;\n    using reference = const char&;\n    using iterator_category = std::input_iterator_tag;\n\n    MyIterator& operator++() {\n        target->advance();\n        return *this;\n    }\n\n    bool operator!=(const MyIterator& rhs) const {\n        return rhs.target != target;\n    }\n\n    reference operator*() const {\n        return target->get_current();\n    }\n\n    MyContainer* target = nullptr;\n};\n```\n\n----------------------------------------\n\nTITLE: Example: Removing Object Element Using Key\nDESCRIPTION: Example showing how to remove an element from a JSON object using a key, demonstrating the effect of erase() when called with an object key.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/erase__object_t_key_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON without Exceptions in C++\nDESCRIPTION: This example shows how to parse JSON input without throwing exceptions. It uses the allow_exceptions parameter set to false and checks if the result is discarded.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parse_exceptions.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\njson j = json::parse(my_input, nullptr, false);\nif (j.is_discarded())\n{\n    std::cerr << \"parse error\" << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for items() Method\nDESCRIPTION: The function declaration for items() which returns an iteration proxy for both normal and const iterators. This enables access to key-value pairs during iteration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/items.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\niteration_proxy<iterator> items() noexcept;\niteration_proxy<const_iterator> items() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Example of JSON to MessagePack Serialization in C++\nDESCRIPTION: This example demonstrates how to serialize a JSON value to a byte vector in MessagePack format using the to_msgpack function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_msgpack.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_msgpack.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Parser Callback Example\nDESCRIPTION: Implementation example showing parse() function usage with and without callback function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parser_callbacks.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/parse__string__parser_callback_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for nlohmann_json\nDESCRIPTION: Sets up the CMake project for nlohmann_json with version 3.12.0 and CXX language requirement. It also determines if the project is built as a standalone project or as a subproject.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5...4.0)\n\n##\n## PROJECT\n## name and version\n##\nproject(nlohmann_json VERSION 3.12.0 LANGUAGES CXX)\n\n##\n## MAIN_PROJECT CHECK\n## determine if nlohmann_json is built as a subproject (using add_subdirectory) or if it is the main project\n##\nset(MAIN_PROJECT OFF)\nif (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n    set(MAIN_PROJECT ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating JSON from Input Streams\nDESCRIPTION: Shows how to create JSON values by parsing from std::istream sources like stringstream or ifstream.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nstd::stringstream ss;\njson j = json::parse(ss);\n\nstd::ifstream file(\"data.json\");\njson j2 = json::parse(file);\n```\n\n----------------------------------------\n\nTITLE: Example: Updating JSON Object with Merging in C++\nDESCRIPTION: Shows how to use the update() function with merge_objects set to true, allowing for recursive merging of nested objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/update.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nauto user_settings = json::parse(\"config.json\");\nauto effective_settings = get_default_settings();\neffective_settings.update(user_settings, true);\n```\n\n----------------------------------------\n\nTITLE: Creating Binary Values in C++\nDESCRIPTION: Demonstrates how to create binary values with and without subtypes using the json::binary_t class in the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nauto binary = json::binary_t({0xCA, 0xFE, 0xBA, 0xBE});\nauto binary_with_subtype = json::binary_t({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of flatten Method in nlohmann::basic_json\nDESCRIPTION: Example code showing how a JSON object is flattened to an object with JSON pointers as keys. The example demonstrates practical usage of the flatten method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/flatten.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/flatten.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to BJData Format in C++\nDESCRIPTION: These methods convert JSON values to BJData format. The first overload returns a byte vector containing the serialization, while the second and third overloads write to an output adapter. Parameters control size annotations, type annotations, and BJData version.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_bjdata.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nstatic std::vector<std::uint8_t> to_bjdata(const basic_json& j,\n                                           const bool use_size = false,\n                                           const bool use_type = false,\n                                           const bjdata_version_t version = bjdata_version_t::draft2);\n\n// (2)\nstatic void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,\n                      const bool use_size = false, const bool use_type = false,\n                      const bjdata_version_t version = bjdata_version_t::draft2);\nstatic void to_bjdata(const basic_json& j, detail::output_adapter<char> o,\n                      const bool use_size = false, const bool use_type = false,\n                      const bjdata_version_t version = bjdata_version_t::draft2);\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from JSON Values with erase - Method Signatures\nDESCRIPTION: Method signatures for the five overloaded versions of the erase method in the nlohmann::basic_json class, which enable removal of elements by iterator, iterator range, object key, or array index.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\niterator erase(iterator pos);\nconst_iterator erase(const_iterator pos);\n\n// (2)\niterator erase(iterator first, iterator last);\nconst_iterator erase(const_iterator first, const_iterator last);\n\n// (3)\nsize_type erase(const typename object_t::key_type& key);\n\n// (4)\ntemplate<typename KeyType>\nsize_type erase(KeyType&& key);\n\n// (5)\nvoid erase(const size_type idx);\n```\n\n----------------------------------------\n\nTITLE: Input Adapter Interface for JSON Parsing\nDESCRIPTION: Interface definition for input adapters that abstract different input sources with a common interface for reading characters and elements during JSON parsing.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/architecture.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n/// read a single character\nstd::char_traits<char>::int_type get_character() noexcept;\n\n/// read multiple characters to a destination buffer and\n/// returns the number of characters successfully read\ntemplate<class T>\nstd::size_t get_elements(T* dest, std::size_t count = 1);\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Pointer from String in C++\nDESCRIPTION: Demonstrates how to create a JSON Pointer object from a string in C++. This can be done using the json::json_pointer constructor or a user-defined string literal.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson::json_pointer p = \"/nested/one\";\n```\n\nLANGUAGE: cpp\nCODE:\n```\nauto p = \"/nested/one\"_json_pointer;\n```\n\n----------------------------------------\n\nTITLE: Array Push Back Example\nDESCRIPTION: Example demonstrating how to add elements to a JSON array using push_back and += operators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/push_back.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example of JSON to CBOR Serialization in C++\nDESCRIPTION: This example demonstrates how to use the to_cbor function to serialize a JSON value to a byte vector in CBOR format. It includes the code and expected output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_cbor.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_cbor.cpp\"\n```\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/to_cbor.output\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Const Elements via JSON Pointer with operator[] in C++\nDESCRIPTION: Shows how to read values using JSON Pointers with the const version of operator[].\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__json_pointer_const.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Unflattening JSON Objects Method Declaration - C++\nDESCRIPTION: Method declaration for unflatten() which restores nested JSON structures from a flattened object. The function requires the value to be an object with JSON pointer keys and primitive values as constraints. It provides strong exception safety.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/unflatten.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbasic_json unflatten() const;\n```\n\n----------------------------------------\n\nTITLE: Example JSON Usage in C++\nDESCRIPTION: Basic example of how to use the nlohmann/json library to create and access JSON data in C++. This is used as a reference example throughout the page to demonstrate the library's integration with various package managers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/example.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring begin() Iterator Methods in C++\nDESCRIPTION: Declaration of begin() iterator methods in the nlohmann::basic_json class. Includes both non-const and const overloads that return iterators to the first element with no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/begin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\niterator begin() noexcept;\nconst_iterator begin() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Using Structured Bindings with JSON Objects in C++17\nDESCRIPTION: Shows how to use C++17 structured bindings with the items() method to directly access keys and values during iteration over JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto& [key, val] : j_object.items())\n{\n    std::cout << \"key: \" << key << \", value:\" << val << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of get_to Method\nDESCRIPTION: Demonstrates the equivalent implementation of the get_to method showing how the value conversion is performed using json_serializer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_to.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nValueType v;\nJSONSerializer<ValueType>::from_json(*this, v);\n```\n\n----------------------------------------\n\nTITLE: Checking JSON Null Value Method Declaration in C++\nDESCRIPTION: Method declaration for checking if a JSON value is null. Returns true if the value is null, false otherwise. Provides no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_null.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_null() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Deserializing BJData to JSON using nlohmann::basic_json in C++\nDESCRIPTION: Two overloads of the from_bjdata function for deserializing BJData format to JSON. The first accepts a compatible input type, while the second uses an iterator range. Both versions allow specifying strictness and exception behavior.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_bjdata.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic basic_json from_bjdata(InputType&& i,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n// (2)\ntemplate<typename IteratorType>\nstatic basic_json from_bjdata(IteratorType first, IteratorType last,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of emplace_back Method\nDESCRIPTION: Demonstration of using emplace_back to add elements to a JSON array, showing how null values are automatically converted to arrays when needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/emplace_back.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/emplace_back.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example of JSON Deserialization from Stream in C++\nDESCRIPTION: Example code showing how to deserialize JSON data from a stream into a JSON object using the operator>> function. This demonstrates the practical usage of the stream deserialization operator.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_gtgt.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_deserialize.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Serialization Mapping in C++\nDESCRIPTION: Demonstrates how to declare an enum type and configure its JSON serialization mapping using NLOHMANN_JSON_SERIALIZE_ENUM macro. Maps enum values to specific string representations in JSON.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/enum_conversion.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// example enum type declaration\nenum TaskState {\n    TS_STOPPED,\n    TS_RUNNING,\n    TS_COMPLETED,\n    TS_INVALID=-1,\n};\n\n// map TaskState values to JSON as strings\nNLOHMANN_JSON_SERIALIZE_ENUM( TaskState, {\n    {TS_INVALID, nullptr},\n    {TS_STOPPED, \"stopped\"},\n    {TS_RUNNING, \"running\"},\n    {TS_COMPLETED, \"completed\"},\n})\n```\n\n----------------------------------------\n\nTITLE: Catching JSON Parse Error Exceptions in C++\nDESCRIPTION: Example code demonstrating how to catch parse_error exceptions in the nlohmann/json library. This shows proper exception handling with try-catch blocks for JSON parsing operations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// Example of catching parse_error exceptions is referenced but the code is not directly shown in the document\n```\n\n----------------------------------------\n\nTITLE: Using basic_json::meta() to retrieve library information in C++\nDESCRIPTION: This static function returns a JSON object containing version, compiler, platform, and other metadata about the nlohmann/json library. It provides detailed information with no exceptions and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/meta.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic basic_json meta();\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Merge Patch Algorithm in Python\nDESCRIPTION: Pseudocode representation of the JSON Merge Patch algorithm as defined in RFC 7396. This algorithm recursively applies the patch to the target JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/merge_patch.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndefine MergePatch(Target, Patch):\n  if Patch is an Object:\n    if Target is not an Object:\n      Target = {} // Ignore the contents and set it to an empty Object\n    for each Name/Value pair in Patch:\n      if Value is null:\n        if Name exists in Target:\n          remove the Name/Value pair from Target\n      else:\n        Target[Name] = MergePatch(Target[Name], Value)\n    return Target\n  else:\n    return Patch\n```\n\n----------------------------------------\n\nTITLE: Managing Binary Value Subtypes in C++\nDESCRIPTION: Shows how to check for, set, and clear subtypes on binary values using the binary_t API methods.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nbinary.has_subtype();                   // returns false\nbinary_with_subtype.has_subtype();      // returns true\n\nbinary_with_subtype.clear_subtype();\nbinary_with_subtype.has_subtype();      // returns true\n\nbinary_with_subtype.set_subtype(42);\nbinary.set_subtype(23);\n\nbinary.subtype();                       // returns 23\n```\n\n----------------------------------------\n\nTITLE: Conan Package Manager Integration Example\nDESCRIPTION: Example showing how to use the nlohmann/json library with the Conan package manager, including setting up dependencies in Conanfile.txt and integrating with CMake.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n--8<-- \"integration/conan/Conanfile.txt\"\n```\n\nLANGUAGE: cmake\nCODE:\n```\n--8<-- \"integration/conan/CMakeLists.txt\"\n```\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/conan/example.cpp\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nconan install . --output-folder=build --build=missing\n```\n\nLANGUAGE: sh\nCODE:\n```\ncmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=\"conan_toolchain.cmake\" -DCMAKE_BUILD_TYPE=Release\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to BSON in C++\nDESCRIPTION: This example demonstrates how to serialize a JSON object to BSON format using the nlohmann/json library. It creates a JSON object with various data types and converts it to BSON.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_bson.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to BSON in C++\nDESCRIPTION: Two overloads of the to_bson function for serializing JSON to BSON format. The first returns a byte vector, while the second writes to an output adapter.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_bson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nstatic std::vector<std::uint8_t> to_bson(const basic_json& j);\n\n// (2)\nstatic void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o);\nstatic void to_bson(const basic_json& j, detail::output_adapter<char> o);\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Intrusive Type Serialization with Macros in C++\nDESCRIPTION: Example of using NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE macro to create to_json/from_json functions for a person struct.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace ns {\n    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(person, name, address, age)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Find Method Declarations\nDESCRIPTION: Core declarations of the find() method for both non-const and const iterators. These overloads work with the object's native key type for searching elements in JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/find.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\niterator find(const typename object_t::key_type& key);\nconst_iterator find(const typename object_t::key_type& key) const;\n```\n\n----------------------------------------\n\nTITLE: Conditional Number Conversion in C++ using nlohmann/json\nDESCRIPTION: Shows a safer approach to number conversion by explicitly checking the nature of the value using is_number_integer() before performing the conversion. This method allows for appropriate handling of different value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// check if jd is really integer-valued\nif (jd.is_number_integer())\n{\n    // if so, do the conversion and use i\n    std::int64_t i = jd.template get<std::int64_t>();\n    // ...\n}\nelse\n{\n    // otherwise, take appropriate action\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON objects with braces in C++\nDESCRIPTION: Demonstrates the difference between brace initialization and parentheses initialization for JSON objects, highlighting a known issue where brace initialization yields arrays instead of single values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/faq.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson j{true};\n```\n\nLANGUAGE: cpp\nCODE:\n```\njson j(true);\n```\n\n----------------------------------------\n\nTITLE: Example: Serializing JSON Value to Stream with Different Indentation in C++\nDESCRIPTION: Demonstrates how to serialize JSON values to an output stream with different indentation levels using the width parameter of the output stream.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_ltlt.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_ltlt__basic_json.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Function Signatures Generated by Non-Intrusive Macros in C++\nDESCRIPTION: The function signatures generated by the non-intrusive macros. These template functions handle the conversion between the custom type and JSON objects, with variant (3) only implementing the to_json function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType>\nvoid to_json(BasicJsonType&, const type&);\ntemplate<typename BasicJsonType>\nvoid from_json(const BasicJsonType&, type&); // except (3)\n```\n\n----------------------------------------\n\nTITLE: Initializer List Insertion Example\nDESCRIPTION: Example showing how to insert elements from an initializer list into a JSON array\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/insert__ilist.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Integrating nlohmann/json with CMake (External)\nDESCRIPTION: CMake configuration to find and link against an externally installed nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_33\n\nLANGUAGE: cmake\nCODE:\n```\n# CMakeLists.txt\nfind_package(nlohmann_json 3.12.0 REQUIRED)\n...\nadd_library(foo ...)\n...\ntarget_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Example: Serializing JSON to BSON in C++\nDESCRIPTION: An example demonstrating the serialization of a JSON value to a byte vector in BSON format using the to_bson function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_bson.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_bson.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Including Nlohmann JSON Header in C++ Applications\nDESCRIPTION: The recommended way to include the Nlohmann JSON library in your C++ code. This approach allows for selecting different installation directories like 'single_include' or 'include'.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <nlohmann/json.hpp>\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json\nDESCRIPTION: Shows how to configure a CMake project to use the nlohmann/json library as a dependency. Demonstrates setting up project options and linking against the JSON library target.\nSOURCE: https://github.com/nlohmann/json/blob/develop/ChangeLog.md#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nproject(FOO)\n\noption(FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF)\n\nadd_subdirectory(thirdparty)\n\nadd_library(foo ...)\n\n# Note that the namespaced target will always be available regardless of the\n# import method\ntarget_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Using items() for JSON Iteration in C++\nDESCRIPTION: Demonstrates the use of the items() member function for iterating over JSON objects, replacing the deprecated iterator_wrapper function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto &x : j.items())\n{\n    std::cout << x.key() << \":\" << x.value() << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default ADL Serializer Template in C++\nDESCRIPTION: Basic implementation of the default ADL (Argument-Dependent Lookup) serializer used by nlohmann::json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T>\nstruct adl_serializer {\n    static void to_json(json& j, const T& value) {\n        // calls the \"to_json\" method in T's namespace\n    }\n\n    static void from_json(const json& j, T& value) {\n        // same thing, but with the \"from_json\" method\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Reverse Iteration of JSON Arrays in C++\nDESCRIPTION: Demonstrates how to iterate over a JSON array in reverse order using rbegin() and rend() iterators. The example shows traversing an array from the last element to the first.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\njson j = {1, 2, 3, 4};\n\nfor (auto it = j.rbegin(); it != j.rend(); ++it)\n{\n    std::cout << *it << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Namespace Macros with Third-party Type Conversion in C++\nDESCRIPTION: Example showing how to use NLOHMANN_JSON_NAMESPACE_BEGIN and NLOHMANN_JSON_NAMESPACE_END when implementing JSON serialization for third-party types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_begin.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_json_namespace_begin.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: BJData Serialization Example in C++\nDESCRIPTION: Example demonstrating BJData serialization of different JSON data types using the nlohmann/json library, including basic types, arrays, and binary data handling\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bjdata.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/to_bjdata.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using Parse Function for JSON Stream Processing\nDESCRIPTION: Demonstrates the new recommended way to parse JSON from streams using the parse function with callback support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\njson j = json::parse(ss, cb);\n```\n\n----------------------------------------\n\nTITLE: Output Adapter Interface for JSON Serialization\nDESCRIPTION: Interface definition for output adapters used during JSON serialization, providing methods to write individual characters and character sequences.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/architecture.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T>\nvoid write_character(CharType c);\n\ntemplate<typename CharType>\nvoid write_characters(const CharType* s, std::size_t length);\n```\n\n----------------------------------------\n\nTITLE: Modifying JSON Objects Using operator[]\nDESCRIPTION: Shows how to modify existing values and add new key-value pairs to a JSON object. When a non-existing key is accessed, a null value is inserted which can be immediately overwritten.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/unchecked_access.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nj[\"name\"] = \"John Smith\";\nj[\"maidenName\"] = \"Jones\";\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"John Smith\",\n    \"maidenName\": \"Jones\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Method Signature for push_back in nlohmann::json_pointer\nDESCRIPTION: Function signatures for the push_back method, which appends an unescaped token at the end of a JSON Pointer. The method has two overloads: one accepting an lvalue reference and another accepting an rvalue reference.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/push_back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid push_back(const string_t& token);\n\nvoid push_back(string_t&& token);\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Elements with operator[] in C++\nDESCRIPTION: Illustrates how to read and write object elements using the operator[].\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__object_t_key_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Parser Callback Function Type in C++\nDESCRIPTION: Template definition for the parser callback function type that takes depth, event type, and parsed JSON value as parameters and returns a boolean.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parser_callbacks.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType>\nusing parser_callback_t =\n    std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;\n```\n\n----------------------------------------\n\nTITLE: Implementing get Method Overloads in nlohmann::basic_json\nDESCRIPTION: Declaration of three overloads of the get method for type conversion. The first converts JSON values to compatible value types, the second handles conversion between basic_json specializations, and the third provides pointer access to the internal JSON value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename ValueType>\nValueType get() const noexcept(\n    noexcept(JSONSerializer<ValueType>::from_json(\n        std::declval<const basic_json_t&>(), std::declval<ValueType&>())));\n\n// (2)\ntemplate<typename BasicJsonType>\nBasicJsonType get() const;\n\n// (3)\ntemplate<typename PointerType>\nPointerType get_ptr();\n\ntemplate<typename PointerType>\nconstexpr const PointerType get_ptr() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Adding Key/Value Pairs with Initializer Lists\nDESCRIPTION: Demonstrates using push_back and operator+= with initializer lists to add key/value pairs to JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nj_object += {\"key\", 1};\nj_object.push_back({\"key\", 1});\n```\n\n----------------------------------------\n\nTITLE: Using json::binary Convenience Function in C++\nDESCRIPTION: Shows how to use the json::binary convenience function to create binary JSON values with and without subtypes.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nauto j2 = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 23);\nauto j3 = json::binary({0xCA, 0xFE, 0xBA, 0xBE});\n\nj2 == j;                        // returns true\nj3.get_binary().has_subtype();  // returns false\nj3.get_binary().subtype();      // returns std::uint64_t(-1) as j3 has no subtype\n```\n\n----------------------------------------\n\nTITLE: Implementing from_json Function Templates in nlohmann::adl_serializer\nDESCRIPTION: Defines two template overloads of the from_json function: one for default-constructible types (1) and another for non-default-constructible types (2). These functions convert JSON values to C++ types and are typically called by the get() function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/adl_serializer/from_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename BasicJsonType, typename TargetType = ValueType>\nstatic auto from_json(BasicJsonType && j, TargetType& val) noexcept(\n    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))\n-> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())\n\n// (2)\ntemplate<typename BasicJsonType, typename TargetType = ValueType>\nstatic auto from_json(BasicJsonType && j) noexcept(\nnoexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))\n-> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))\n```\n\n----------------------------------------\n\nTITLE: Sample JSON with Comments\nDESCRIPTION: An example of a JSON document that contains line comments and block comments. This JSON document lists planets with comments explaining that Pluto was removed in 2006.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/comments.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    // update in 2006: removed Pluto\n    \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */]\n}\n```\n\n----------------------------------------\n\nTITLE: Deserializing MessagePack Data to JSON in C++\nDESCRIPTION: Static method overloads for deserializing MessagePack-formatted data to JSON values. The first overload accepts various input types (streams, files, arrays), while the second works with iterator ranges. Both support options for strict parsing and exception handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_msgpack.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic basic_json from_msgpack(InputType&& i,\n                               const bool strict = true,\n                               const bool allow_exceptions = true);\n// (2)\ntemplate<typename IteratorType>\nstatic basic_json from_msgpack(IteratorType first, IteratorType last,\n                               const bool strict = true,\n                               const bool allow_exceptions = true);\n```\n\n----------------------------------------\n\nTITLE: Traditional Loop Iteration for Key-Value Access\nDESCRIPTION: Example showing how to iterate a JSON object using traditional iterator approach with explicit begin/end to access both keys and values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/items.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto it = j_object.begin(); it != j_object.end(); ++it)\n{\n    std::cout << \"key: \" << it.key() << \", value:\" << it.value() << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Using End Iterator in C++\nDESCRIPTION: Demonstrates how to use the end() function in practice. This example likely shows iterating over a JSON object or array using begin() and end() iterators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/end.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example: Removing Array Element Using Index\nDESCRIPTION: Example showing how to remove an element from a JSON array by index, demonstrating the effect of the erase() method when used with an array index parameter.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/erase__size_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Optimized BJData Conversion with Type and Size Options in C++\nDESCRIPTION: Demonstrates converting binary values to BJData with size and type optimization flags enabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n// convert to UBJSON using the size and type optimization\nauto v = json::to_bjdata(j, true, true);\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Objects with Binary Values in C++\nDESCRIPTION: Shows how to construct JSON objects from binary values and how to check properties of binary JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\njson j = binary;\n\nj.is_binary();    // returns true\nj.is_primitive(); // returns true\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Serialization Example in C++\nDESCRIPTION: Example showing how to implement serialization for a non-default-constructible type through specialization of the adl_serializer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/json_serializer.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_json__non_default_constructible.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Array Element Addition Example in C++\nDESCRIPTION: Example showing how push_back() and += can be used to add elements to a JSON array, demonstrating automatic conversion of null values to arrays.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator+=.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining object_comparator_t type in nlohmann::basic_json (C++)\nDESCRIPTION: Definition of object_comparator_t, which is the comparator used by object_t. It is defined as either typename object_t::key_compare if available, or default_object_comparator_t otherwise.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object_comparator_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing object_comparator_t = typename object_t::key_compare;\n// or\nusing object_comparator_t = default_object_comparator_t;\n```\n\n----------------------------------------\n\nTITLE: Declaring accept Function Overloads in C++\nDESCRIPTION: Declares two overloads of the static accept function. The first accepts a generic InputType, while the second takes a pair of iterators. Both check if the input is valid JSON without throwing exceptions or creating diagnostic information.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/accept.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic bool accept(InputType&& i,\n                   const bool ignore_comments = false);\n\n// (2)\ntemplate<typename IteratorType>\nstatic bool accept(IteratorType first, IteratorType last,\n                   const bool ignore_comments = false);\n```\n\n----------------------------------------\n\nTITLE: Setting up CMake project with nlohmann/json library\nDESCRIPTION: Configures a CMake project that imports the nlohmann/json library and builds multiple executables with different linking configurations. The file demonstrates proper library integration with and without namespace specification, and shows how to disable exceptions when using the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_add_subdirectory/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5...3.14)\n\nproject(DummyImport CXX)\n\nset(JSON_BuildTests OFF CACHE INTERNAL \"\")\nadd_subdirectory(${nlohmann_json_source}\n   ${CMAKE_CURRENT_BINARY_DIR}/nlohmann_json)\n\nadd_executable(with_namespace_target main.cpp)\ntarget_link_libraries(with_namespace_target nlohmann_json::nlohmann_json)\n\nadd_executable(without_namespace_target main.cpp)\ntarget_link_libraries(without_namespace_target nlohmann_json)\n\nif(NOT MSVC)\n    add_executable(without_exceptions main.cpp)\n    target_link_libraries(without_exceptions nlohmann_json::nlohmann_json)\n    target_compile_definitions(without_exceptions PRIVATE JSON_NOEXCEPTION)\n    target_compile_options(without_exceptions PRIVATE -fno-exceptions)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Deserializing UBJSON to JSON Templates\nDESCRIPTION: Template function declarations for deserializing UBJSON format into JSON values. Includes two overloads: one for compatible input types (streams, files, arrays) and another for iterator ranges. Both functions support strict mode and exception handling options.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_ubjson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic basic_json from_ubjson(InputType&& i,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n// (2)\ntemplate<typename IteratorType>\nstatic basic_json from_ubjson(IteratorType first, IteratorType last,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n```\n\n----------------------------------------\n\nTITLE: Defining ordered_json Type in C++\nDESCRIPTION: Type alias for basic_json with ordered_map as the object type, which preserves insertion order of object keys. The implementation uses std::vector internally to store object elements.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/ordered_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing ordered_json = basic_json<ordered_map>;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of is_number_unsigned()\nDESCRIPTION: Code example demonstrating the usage of is_number_unsigned() for different JSON types. Shows how the function behaves with various input values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_unsigned.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_number_unsigned.cpp\"\n```\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_number_unsigned.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining CBOR Tag Handler Enumeration in C++\nDESCRIPTION: Enumeration class that defines how CBOR tags should be handled during JSON parsing. It provides three options: error (throws parse_error), ignore (skips tags), and store (stores tagged values as binary container with subtype for bytes 0xd8..0xdb).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cbor_tag_handler_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nenum class cbor_tag_handler_t\n{\n    error,\n    ignore,\n    store\n};\n```\n\n----------------------------------------\n\nTITLE: Object Push Back Example\nDESCRIPTION: Example showing how to add elements to a JSON object using push_back and += operators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/push_back.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back__object_t__value.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Specializing ADL Serializer for Boost Optional in C++\nDESCRIPTION: Example of specializing the ADL serializer for third-party types using boost::optional as an example.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace nlohmann {\n    template <typename T>\n    struct adl_serializer<boost::optional<T>> {\n        static void to_json(json& j, const boost::optional<T>& opt) {\n            if (opt == boost::none) {\n                j = nullptr;\n            } else {\n              j = *opt;\n            }\n        }\n\n        static void from_json(const json& j, boost::optional<T>& opt) {\n            if (j.is_null()) {\n                opt = boost::none;\n            } else {\n                opt = j.template get<T>();\n            }\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of std::hash with nlohmann::basic_json\nDESCRIPTION: Example code showing how to calculate hash values for different JSON values using the std::hash specialization. This demonstrates the hash implementation's behavior with various JSON data types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/std_hash.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/std_hash.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing is_number Function in C++\nDESCRIPTION: Possible implementation of the is_number() function. It checks if the value is either an integer or a floating-point number using other member functions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_number() const noexcept\n{\n    return is_number_integer() || is_number_float();\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Accessing Object Elements via JSON Pointer with Default Value in C++\nDESCRIPTION: Example showing how to use the third overload to access object elements through a JSON pointer with a default value fallback.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/value__json_ptr.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Custom Size-Constrained Serializer in C++\nDESCRIPTION: Example of a custom serializer that only accepts types with size <= 32 bytes, demonstrating advanced serialization techniques.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T, typename SFINAE = typename std::enable_if<sizeof(T) <= 32>::type>\nstruct less_than_32_serializer {\n    template <typename BasicJsonType>\n    static void to_json(BasicJsonType& j, T value) {\n        using nlohmann::to_json;\n        to_json(j, value);\n    }\n\n    template <typename BasicJsonType>\n    static void from_json(const BasicJsonType& j, T& value) {\n        using nlohmann::from_json;\n        from_json(j, value);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Using Custom Enum Serialization in C++\nDESCRIPTION: Shows practical usage examples of the custom enum serialization, including conversion from enum to JSON string, JSON string to enum, and handling undefined JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/enum_conversion.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// enum to JSON as string\njson j = TS_STOPPED;\nassert(j == \"stopped\");\n\n// json string to enum\njson j3 = \"running\";\nassert(j3.template get<TaskState>() == TS_RUNNING);\n\n// undefined json value to enum (where the first map entry above is the default)\njson jPi = 3.14;\nassert(jPi.template get<TaskState>() == TS_INVALID );\n```\n\n----------------------------------------\n\nTITLE: Using is_number_float Function in C++\nDESCRIPTION: Example usage of the is_number_float() function for different JSON types. This snippet demonstrates how the function behaves with various JSON value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_float.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_number_float.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Default Sorted Keys Example with nlohmann::json\nDESCRIPTION: Demonstrates the default behavior of nlohmann::json which uses std::map to store object keys in alphabetical order.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/object_order.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"one\"] = 1;\n    j[\"two\"] = 2;\n    j[\"three\"] = 3;\n    \n    std::cout << j.dump(2) << '\\n';\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"one\": 1,\n  \"three\": 3,\n  \"two\": 2\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the JSON SAX number_integer Virtual Method in C++\nDESCRIPTION: Virtual method in the json_sax interface that is called when an integer number is read during parsing. It receives the integer value as a parameter and returns a boolean indicating whether parsing should proceed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/number_integer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool number_integer(number_integer_t val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of sax_parse Function with Custom SAX Event Consumer\nDESCRIPTION: Demonstrates how to use the sax_parse function with a string input and a user-defined SAX event consumer. This example is referenced in the documentation but the actual implementation is included from an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/sax_parse.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring size() method in nlohmann::basic_json class in C++\nDESCRIPTION: Declaration of the size() method that returns the number of elements in a JSON value with no-throw guarantee and constant complexity for most types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/size.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nsize_type size() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project and Fetching nlohmann/json Library\nDESCRIPTION: Sets up a CMake project, declares the nlohmann/json library as a dependency using FetchContent, and makes it available for use in the project.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content2/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nproject(DummyImport CXX)\n\ninclude(FetchContent)\n\nget_filename_component(GIT_REPOSITORY_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../../.. ABSOLUTE)\nFetchContent_Declare(json GIT_REPOSITORY ${GIT_REPOSITORY_DIRECTORY} GIT_TAG HEAD)\nFetchContent_MakeAvailable(json)\n```\n\n----------------------------------------\n\nTITLE: Example: Comparing JSON Values Using Spaceship Operator in C++20\nDESCRIPTION: Demonstrates the usage of the spaceship operator to compare various JSON values. This example shows how different JSON types are compared and how the operator handles equality, ordering, and unordered cases.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_spaceship.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_spaceship__const_reference.c++20.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Deserializing UBJSON to JSON in C++\nDESCRIPTION: Demonstrates how to convert UBJSON data back to JSON format using the from_ubjson function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/ubjson.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/from_ubjson.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: This CMake script configures a project that uses the nlohmann/json library. It sets the minimum CMake version to 3.15, defines a project named 'json_example', finds the nlohmann_json package, and links it to an executable built from example.cpp.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/macports/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Using crbegin() function with nlohmann::json in C++\nDESCRIPTION: This example demonstrates how to use the crbegin() function with the nlohmann::json class. It creates a JSON object, iterates over it in reverse order using crbegin(), and prints the elements.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/crbegin.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/crbegin.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example: Removing Elements Using Iterator Range\nDESCRIPTION: Example showing how to remove a range of JSON elements using the erase method with a pair of iterators, demonstrating the effect across different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/erase__IteratorType_IteratorType.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Handling Binary Types in CBOR and MessagePack with C++\nDESCRIPTION: Shows how to work with binary types from BSON, CBOR, and MessagePack. It demonstrates creating a CBOR byte string, accessing its contents, setting a subtype, and serializing to MessagePack.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_31\n\nLANGUAGE: cpp\nCODE:\n```\n// CBOR byte string with payload 0xCAFE\nstd::vector<std::uint8_t> v = {0x42, 0xCA, 0xFE};\n\n// read value\njson j = json::from_cbor(v);\n\n// the JSON value has type binary\nj.is_binary(); // true\n\n// get reference to stored binary value\nauto& binary = j.get_binary();\n\n// the binary value has no subtype (CBOR has no binary subtypes)\nbinary.has_subtype(); // false\n\n// access std::vector<std::uint8_t> member functions\nbinary.size(); // 2\nbinary[0]; // 0xCA\nbinary[1]; // 0xFE\n\n// set subtype to 0x10\nbinary.set_subtype(0x10);\n\n// serialize to MessagePack\nauto cbor = json::to_msgpack(j); // 0xD5 (fixext2), 0x10, 0xCA, 0xFE\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Index Access with at() Method in C++\nDESCRIPTION: Demonstrates how accessing a non-existent array index using the `at()` method throws an out_of_range exception with diagnostic information.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/checked_access.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nj.at(\"hobbies\").at(3) = \"cooking\";\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NaN Handling in JSON\nDESCRIPTION: Shows how NaN (not-a-number) values are handled in the library. NaN values are stored internally but serialized as null in the JSON output, matching JavaScript's JSON.stringify behavior.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint main()\n{\n    double val = std::numeric_limits<double>::quiet_NaN();\n    std::cout << \"val=\" << val << std::endl;\n    json j = val;\n    std::cout << \"j=\" << j.dump() << std::endl;\n    val = j;\n    std::cout << \"val=\" << val << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Using JSON SAX Interface for Parsing in C++\nDESCRIPTION: This example demonstrates how to use the SAX interface for parsing JSON data. It includes the implementation of various SAX interface methods, including the boolean handler.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/boolean.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Output from array Function Usage in C++\nDESCRIPTION: The resulting JSON output from using the array function to create various JSON arrays.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/array.md#2025-04-21_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n--8<-- \"examples/array.output\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Move-Only Types in C++\nDESCRIPTION: Implementation of serialization for non-default constructible and non-copyable but move-constructible types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\nstruct move_only_type {\n    move_only_type() = delete;\n    move_only_type(int ii): i(ii) {}\n    move_only_type(const move_only_type&) = delete;\n    move_only_type(move_only_type&&) = default;\n\n    int i;\n};\n\nnamespace nlohmann {\n    template <>\n    struct adl_serializer<move_only_type> {\n        static move_only_type from_json(const json& j) {\n            return {j.template get<int>()};\n        }\n\n        static void to_json(json& j, move_only_type t) {\n            j = t.i;\n        }\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying JSON Arrays with Auto-Resizing Using operator[]\nDESCRIPTION: Demonstrates how accessing an invalid array index automatically resizes the array and fills intermediate positions with null values. This behavior differs from std::vector where operator[] never inserts new elements.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/unchecked_access.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nj[\"hobbies\"][0] = \"running\";\nj[\"hobbies\"][3] = \"cooking\";\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"John Smith\",\n    \"maidenName\": \"Jones\",\n    \"age\": 42,\n    \"hobbies\": [\"running\", \"reading\", null, \"cooking\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring emplace_back Template Method in C++\nDESCRIPTION: Template method declaration for emplace_back that accepts variable arguments to construct and append a new JSON value to an array. Returns a reference to the inserted element.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/emplace_back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<class... Args>\nreference emplace_back(Args&& ... args);\n```\n\n----------------------------------------\n\nTITLE: JSON Copy Constructor Usage (C++)\nDESCRIPTION: Demonstrates the copy constructor functionality for JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__basic_json.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Initializer List Push Back Example\nDESCRIPTION: Example demonstrating how initializer lists are handled when adding elements using push_back.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/push_back.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back__initializer_list.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Deriving JSON Value Types from Template Arguments in C++\nDESCRIPTION: This code snippet demonstrates how various JSON value types are derived from the template arguments of the basic_json class.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nusing object_comparator_t = std::less<>;\nusing object_t = ObjectType<StringType, basic_json, object_comparator_t,\n                   AllocatorType<std::pair<const StringType, basic_json>>>;\n\nusing array_t = ArrayType<basic_json, AllocatorType<basic_json>>;\n\nusing string_t = StringType;\n\nusing boolean_t = BooleanType;\n\nusing number_integer_t = NumberIntegerType;\nusing number_unsigned_t = NumberUnsignedType;\nusing number_float_t = NumberFloatType;\n\nusing binary_t = nlohmann::byte_container_with_subtype<BinaryType>;\n```\n\n----------------------------------------\n\nTITLE: Overloaded Stream Output Operators for JSON Values and Pointers in C++\nDESCRIPTION: Defines two overloaded stream output operators: one for serializing JSON values to output streams with customizable formatting, and another for writing JSON pointer string representations to output streams.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_ltlt.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstd::ostream& operator<<(std::ostream& o, const basic_json& j);      // (1)\n\nstd::ostream& operator<<(std::ostream& o, const json_pointer& ptr);  // (2)\n```\n\n----------------------------------------\n\nTITLE: Using to_string Method with JSON Pointer in C++\nDESCRIPTION: Example usage of the to_string method with JSON pointers, demonstrating how it converts JSON pointers to string representations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/to_string.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/json_pointer__to_string.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to CBOR in C++ using nlohmann::json\nDESCRIPTION: Two overloads of the to_cbor function: one returns a byte vector, and the other writes to an output adapter. These functions serialize a JSON value to CBOR format, which is more compact and efficient to parse than JSON.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_cbor.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nstatic std::vector<std::uint8_t> to_cbor(const basic_json& j);\n\n// (2)\nstatic void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o);\nstatic void to_cbor(const basic_json& j, detail::output_adapter<char> o);\n```\n\n----------------------------------------\n\nTITLE: Push Back Method Declarations\nDESCRIPTION: Method declarations for push_back operations including overloads for rvalue/lvalue JSON values, object value types, and initializer lists.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/push_back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nvoid push_back(basic_json&& val);\nvoid push_back(const basic_json& val);\n\n// (2)\nvoid push_back(const typename object_t::value_type& val);\n\n// (3)\nvoid push_back(initializer_list_t init);\n```\n\n----------------------------------------\n\nTITLE: Declaring operator[] Overloads for nlohmann::basic_json in C++\nDESCRIPTION: Defines multiple overloads of operator[] for accessing array elements, object elements, and elements via JSON pointers. Includes const and non-const versions for each type of access.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nreference operator[](size_type idx);\nconst_reference operator[](size_type idx) const;\n\n// (2)\nreference operator[](typename object_t::key_type key);\nconst_reference operator[](const typename object_t::key_type& key) const;\n\n// (3)\ntemplate<typename KeyType>\nreference operator[](KeyType&& key);\ntemplate<typename KeyType>\nconst_reference operator[](KeyType&& key) const;\n\n// (4)\nreference operator[](const json_pointer& ptr);\nconst_reference operator[](const json_pointer& ptr) const;\n```\n\n----------------------------------------\n\nTITLE: Example: Removing Element Using Iterator\nDESCRIPTION: Example demonstrating how to remove a JSON element using the erase method with an iterator. This shows the effect of erase() for different JSON types using a single iterator position.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/erase__IteratorType.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Alternative Type Conversion for Non-DefaultConstructible Types\nDESCRIPTION: Example implementation showing how the get method handles types that are not CopyConstructible and DefaultConstructible by using a different form of the from_json serializer method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nreturn JSONSerializer<ValueTypeCV>::from_json(*this);\n```\n\n----------------------------------------\n\nTITLE: Explicit Implementation Equivalent to NLOHMANN_DEFINE_TYPE_INTRUSIVE\nDESCRIPTION: Shows the equivalent code that the NLOHMANN_DEFINE_TYPE_INTRUSIVE macro generates, including both to_json and from_json friend functions that handle serialization and deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Explicit Implementation Equivalent to NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE\nDESCRIPTION: Shows the equivalent code that the NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE macro generates, containing only the to_json friend function for serialization without deserialization support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_only_serialize_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Triggering an Assertion with Missing Object Key in C++\nDESCRIPTION: Demonstrates how accessing a non-existent key in a const JSON object triggers a runtime assertion. This example shows why checked access methods like at() or contains() should be used when key existence is uncertain.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/assertions.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Array Creation with Count and Value (C++)\nDESCRIPTION: Shows how to create JSON arrays with multiple copies of a given value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__size_type_basic_json.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_DEFINE_TYPE_INTRUSIVE Macro in C++\nDESCRIPTION: Example of using NLOHMANN_DEFINE_TYPE_INTRUSIVE macro inside a class with private members. This version uses the 'at' method during deserialization and will throw an exception if a key is missing in the JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Range Insertion Example\nDESCRIPTION: Example demonstrating how to insert a range of elements into a JSON array\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/insert__range.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Stream Input Using Left Shift Operator\nDESCRIPTION: Shows how to parse JSON from a stream using the left shift operator when no callback function is needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\njson j;\nj << ss;\n```\n\n----------------------------------------\n\nTITLE: JSON Patch Invariant Principle (C++)\nDESCRIPTION: Demonstrates the invariant principle of JSON patches - applying a patch calculated as a diff between source and target should transform the source into the target exactly.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_patch.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nsource.patch(diff(source, target)) == target;\n```\n\n----------------------------------------\n\nTITLE: JSON Container Creation from Iterator Range (C++)\nDESCRIPTION: Examples of creating JSON containers using iterator ranges.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__InputIt_InputIt.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing the contains Method Overloads in nlohmann::basic_json\nDESCRIPTION: Three overloaded versions of the contains method for checking key existence in a JSON object. The method supports basic key types, comparable key types, and JSON pointers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/contains.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nbool contains(const typename object_t::key_type& key) const;\n\n// (2)\ntemplate<typename KeyType>\nbool contains(KeyType&& key) const;\n\n// (3)\nbool contains(const json_pointer& ptr) const;\n```\n\n----------------------------------------\n\nTITLE: Defining Parser Event Types in nlohmann::basic_json C++ Library\nDESCRIPTION: Defines an enumeration class that represents different parser events during JSON parsing. The enum uses std::uint8_t as its underlying type and identifies six distinct parsing events: object_start, object_end, array_start, array_end, key, and value. This is used in parser callbacks to indicate which JSON structural element is being processed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/parse_event_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nenum class parse_event_t : std::uint8_t {\n    object_start,\n    object_end,\n    array_start,\n    array_end,\n    key,\n    value\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing sax_parse Function Overloads in nlohmann::basic_json\nDESCRIPTION: Defines two overloads of the sax_parse function for the nlohmann::basic_json class. The first overload accepts a compatible input type, while the second takes a pair of character iterators. Both functions parse input and generate SAX events according to the specified format and parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/sax_parse.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate <typename InputType, typename SAX>\nstatic bool sax_parse(InputType&& i,\n                      SAX* sax,\n                      input_format_t format = input_format_t::json,\n                      const bool strict = true,\n                      const bool ignore_comments = false);\n\n// (2)\ntemplate<class IteratorType, class SAX>\nstatic bool sax_parse(IteratorType first, IteratorType last,\n                      SAX* sax,\n                      input_format_t format = input_format_t::json,\n                      const bool strict = true,\n                      const bool ignore_comments = false);\n```\n\n----------------------------------------\n\nTITLE: Appending JSON Pointer Components in C++\nDESCRIPTION: Three overloads of operator/= for appending to a JSON pointer. The first appends another JSON pointer, the second appends an unescaped reference token, and the third appends an array index. Returns the modified JSON pointer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_slasheq.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\njson_pointer& operator/=(const json_pointer& ptr);\n\n// (2)\njson_pointer& operator/=(string_t token);\n\n// (3)\njson_pointer& operator/=(std::size_t array_idx)\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to UBJSON Output Adapter\nDESCRIPTION: Static methods that write JSON value as UBJSON to an output adapter. Provides overloads for both uint8_t and char output adapters. Supports optional size and type annotations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_ubjson.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstatic void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,\n                      const bool use_size = false, const bool use_type = false);\nstatic void to_ubjson(const basic_json& j, detail::output_adapter<char> o,\n                      const bool use_size = false, const bool use_type = false);\n```\n\n----------------------------------------\n\nTITLE: Declaring parent_pointer Function in C++\nDESCRIPTION: Function signature for the parent_pointer method in the json_pointer class. It returns the parent of the current JSON pointer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/parent_pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson_pointer parent_pointer() const;\n```\n\n----------------------------------------\n\nTITLE: Type Error Exception Class Definition in C++\nDESCRIPTION: Definition of the type_error exception class that inherits from the base exception class. Used for handling type mismatch errors in JSON operations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type_error.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass type_error : public exception;\n```\n\n----------------------------------------\n\nTITLE: Deserializing BSON to JSON in C++\nDESCRIPTION: Method signatures for the from_bson function that deserializes BSON (Binary JSON) format data into JSON values. Two overloads are provided: one accepting compatible input types and another working with iterator ranges.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_bson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\ntemplate<typename InputType>\nstatic basic_json from_bson(InputType&& i,\n                            const bool strict = true,\n                            const bool allow_exceptions = true);\n// (2)\ntemplate<typename IteratorType>\nstatic basic_json from_bson(IteratorType first, IteratorType last,\n                            const bool strict = true,\n                            const bool allow_exceptions = true);\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration Example with Default Values\nDESCRIPTION: Example JSON configuration object containing logOutput and append properties. Used to demonstrate the value() method behavior.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/default_value.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"logOutput\": \"result.log\",\n    \"append\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Custom JSON Equality Operator Implementation\nDESCRIPTION: Example of a custom equality operator implementation that handles floating-point comparisons with epsilon tolerance while maintaining original behavior for other types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_eq.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nbool my_equal(const_reference lhs, const_reference rhs)\n{\n    const auto lhs_type lhs.type();\n    const auto rhs_type rhs.type();\n    if (lhs_type == rhs_type)\n    {\n        switch(lhs_type)\n            // self_defined case\n            case value_t::number_float:\n                return std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();\n            // other cases remain the same with the original\n            ...\n    }\n...\n```\n\n----------------------------------------\n\nTITLE: Declaring to_string Method for JSON Pointer in C++\nDESCRIPTION: Declaration of the to_string method for the json_pointer class. It returns a string representation of the JSON pointer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/to_string.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstring_t to_string() const;\n```\n\n----------------------------------------\n\nTITLE: Single Element Insertion Example\nDESCRIPTION: Example demonstrating how to insert a single element into a JSON array using insert()\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/insert.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Diff Output Result (JSON)\nDESCRIPTION: Displays the output of a diff operation between two JSON documents, showing the generated patch operations that transform the source document into the target document.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_patch.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/diff.output\"\n```\n\n----------------------------------------\n\nTITLE: Writing JSON Values Using at() Method in C++\nDESCRIPTION: Shows how to modify JSON values by using the reference returned by the `at()` method to update the original JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/checked_access.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nj.at(\"name\") = \"John Smith\";\n```\n\n----------------------------------------\n\nTITLE: Accessing Elements via JSON Pointer with operator[] in C++\nDESCRIPTION: Demonstrates how to read and write values using JSON Pointers with the operator[].\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__json_pointer.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Catching type_error Exception in C++\nDESCRIPTION: Example code demonstrating how to catch a type_error exception when using the JSON library. This shows the proper error handling pattern for type-related errors.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/type_error.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Exception Throwing with JSON_THROW_USER Macro in C++\nDESCRIPTION: This macro allows customization of how exceptions are thrown within the library, overriding the default throw behavior.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nJSON_THROW_USER(exception)\n```\n\n----------------------------------------\n\nTITLE: Example: Accessing Object Elements with Default Value in C++\nDESCRIPTION: Example showing how to query object elements with default values using the first overload that takes an object_t::key_type parameter.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/value__object_t_key_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Validating JSON Input using accept() Function in C++\nDESCRIPTION: This snippet demonstrates the use of the accept() function to validate JSON input without parsing it. It returns a boolean indicating whether the input is valid JSON.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parse_exceptions.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nif (!json::accept(my_input))\n{\n    std::cerr << \"parse error\" << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the value_t Enumeration in C++\nDESCRIPTION: Defines the value_t enumeration that represents all possible JSON types in the nlohmann::json library. The enumeration includes null, object, array, string, boolean, various number types, binary data, and a special discarded state.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nenum class value_t : std::uint8_t {\n    null,\n    object,\n    array,\n    string,\n    boolean,\n    number_integer,\n    number_unsigned,\n    number_float,\n    binary,\n    discarded\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON Comparison Operations in C++\nDESCRIPTION: Example code snippet demonstrating the usage of the less than operator for comparing various JSON types. It shows comparisons between different JSON values and outputs the results.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_lt.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator__less.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using input_format_t in sax_parse Function (C++)\nDESCRIPTION: Demonstrates how to use the input_format_t enum value with the sax_parse function to set the input format to CBOR. This example shows the practical application of the enumeration in parsing binary data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/input_format_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse__binary.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using the Served Header in C++ with Compiler Explorer\nDESCRIPTION: Example C++ code demonstrating how to include the dynamically served json.hpp header from Compiler Explorer and access the injected build macros.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <https://localhost:8443/json.hpp>\nusing namespace nlohmann;\n\n#include <iostream>\n\nint main() {\n    // these macros are dynamically injected into the header file\n    std::cout << JSON_BUILD_TIME << \" (\" << JSON_BUILD_COUNT << \")\\n\";\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting JSON Value Type in C++\nDESCRIPTION: A method that returns the type of a JSON value as a value_t enumeration. This is a const noexcept member function that provides constant time complexity and no-throw guarantee. Supports all JSON types including null, boolean, string, numbers, object, array, binary and discarded.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr value_t type() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of value Method in C++\nDESCRIPTION: Sample implementation showing the equivalent try-catch logic for the first overload of the value method. It attempts to use the at method and returns the default value if an out_of_range exception occurs.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n   return at(key);\n} catch(out_of_range) {\n   return default_value;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Null Pointer Exception When Reading JSON in C++\nDESCRIPTION: Shows how the library handles reading from a null FILE pointer by throwing a parse_error.101 exception instead of triggering undefined behavior. This example demonstrates the safety mechanism added in version 3.12.0.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/assertions.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::FILE* f = std::fopen(\"nonexistent_file.json\", \"r\");\n    try {\n        json j = json::parse(f);\n    } catch (std::exception& e) {\n        std::cerr << e.what() << std::endl;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Const Object Elements with operator[] in C++\nDESCRIPTION: Demonstrates how to read object elements using the const version of operator[].\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__object_t_key_type_const.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of crend() Method in nlohmann::json C++\nDESCRIPTION: Example code demonstrating how to use the crend() method in the nlohmann::basic_json class. This is a reference to an example file included in the documentation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/crend.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/crend.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Object Range Insertion Example\nDESCRIPTION: Example demonstrating how to insert a range of elements into a JSON object\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/insert__range_object.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Bazel Build Integration Example\nDESCRIPTION: Example demonstrating how to integrate the nlohmann/json library in a Bazel build system using MODULE.bazel and BUILD files to reference the repository.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n--8<-- \"integration/bazel/BUILD\"\n```\n\nLANGUAGE: ini\nCODE:\n```\n--8<-- \"integration/bazel/MODULE.bazel\"\n```\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/bazel/example.cpp\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nbazel build //:main\nbazel run //:main\n```\n\n----------------------------------------\n\nTITLE: Class Diagram for JSON Exception Hierarchy in Mermaid\nDESCRIPTION: A mermaid class diagram showing the hierarchy of exception classes in the nlohmann/json library. The diagram illustrates that parse_error, invalid_iterator, type_error, out_of_range, and other_error all inherit from basic_json::exception, which in turn inherits from std::exception.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/parse_error.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n  \n    class std_exception [\"std::exception\"] {\n        <<interface>>\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n    \n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception <|-- json_exception\n    json_exception <|-- json_parse_error\n    json_exception <|-- json_invalid_iterator\n    json_exception <|-- json_type_error\n    json_exception <|-- json_out_of_range\n    json_exception <|-- json_other_error\n\n    style json_parse_error fill:#CCCCFF\n```\n\n----------------------------------------\n\nTITLE: Using is_number_integer Function in C++\nDESCRIPTION: Example usage of is_number_integer() function for different JSON types. This code demonstrates how the function behaves with various JSON value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_integer.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_number_integer.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Namespace Structure in C++\nDESCRIPTION: This snippet shows an example of the complete default namespace name for version 3.11.2 with JSON_DIAGNOSTICS defined to 1.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/namespace.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json_abi_diag_v3_11_2\n```\n\n----------------------------------------\n\nTITLE: Template-based Find Method Declarations\nDESCRIPTION: Template overloads of the find() method that support custom key types. These overloads allow for flexible key type comparison, including support for string_view in C++17.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/find.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename KeyType>\niterator find(KeyType&& key);\ntemplate<typename KeyType>\nconst_iterator find(KeyType&& key) const;\n```\n\n----------------------------------------\n\nTITLE: Simplifying Enum Serialization with NLOHMANN_JSON_SERIALIZE_ENUM Macro in C++\nDESCRIPTION: This macro provides a simple way to define serialization and deserialization for enum types, reducing boilerplate code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nNLOHMANN_JSON_SERIALIZE_ENUM(type, ...)\n```\n\n----------------------------------------\n\nTITLE: Example: Retrieving Positions from JSON in C++\nDESCRIPTION: Demonstrates how to retrieve the start and end positions of JSON elements using the start_pos() and end_pos() methods enabled by the JSON_DIAGNOSTIC_POSITIONS macro.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostic_positions.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostic_positions.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using cbegin() Function with nlohmann::json in C++\nDESCRIPTION: This example demonstrates how to use the cbegin() function with the nlohmann::json library. It creates a JSON object, iterates through its elements using cbegin(), and prints the results.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cbegin.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/cbegin.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Swap Operations for nlohmann::basic_json in C++\nDESCRIPTION: Declares multiple overloads of the swap function for different types within the nlohmann::basic_json library. These functions exchange the contents of JSON values, arrays, objects, strings, and binary data without invoking move, copy, or swap operations on individual elements.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/swap.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nvoid swap(reference other) noexcept;\n\n// (2)\nvoid swap(reference left, reference right) noexcept;\n\n// (3)\nvoid swap(array_t& other);\n\n// (4)\nvoid swap(object_t& other);\n\n// (5)\nvoid swap(string_t& other);\n\n// (6)\nvoid swap(binary_t& other);\n\n// (7)\nvoid swap(typename binary_t::container_type& other);\n```\n\n----------------------------------------\n\nTITLE: Unflattening JSON Objects Example Include - C++\nDESCRIPTION: Reference to an example implementation file showing how to unflatten a JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/unflatten.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/unflatten.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of begin() Iterator\nDESCRIPTION: Example code showing practical usage of the begin() iterator method. The example demonstrates how to access the first element of a JSON container.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/begin.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/begin.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining json Type Alias in C++\nDESCRIPTION: Declaration of the default json type alias which is a specialization of the basic_json template class with default template parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing json = basic_json<>;\n```\n\n----------------------------------------\n\nTITLE: Using type_name function for all JSON types in C++\nDESCRIPTION: Example code demonstrating the usage of type_name() for various JSON types. This snippet shows how to call type_name() on different JSON value types and print the results.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type_name.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/type_name.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Custom JSON Equality Operator with Special Floating-Point Handling\nDESCRIPTION: Implementation of a custom equality comparison function for JSON values that handles floating-point numbers with epsilon-based comparison while maintaining default behavior for other types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nbool my_equal(const_reference lhs, const_reference rhs)\n{\n    const auto lhs_type lhs.type();\n    const auto rhs_type rhs.type();\n    if (lhs_type == rhs_type)\n    {\n        switch(lhs_type)\n        {\n            // self_defined case\n            case value_t::number_float:\n                return std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();\n    \n            // other cases remain the same with the original\n            ...\n        }\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Const Array Elements with operator[] in C++\nDESCRIPTION: Shows how to read array elements using the const version of operator[].\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator[].md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_array__size_type_const.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating default_object_comparator_t usage in C++\nDESCRIPTION: Example code demonstrating the usage of default_object_comparator_t in the nlohmann::json library. The actual code is not provided in the snippet, but it's referenced as an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/default_object_comparator_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/default_object_comparator_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Less Than Operator for JSON Values in C++\nDESCRIPTION: Defines the less than operator for comparing JSON values. It includes overloads for comparing two JSON values and for comparing a JSON value with a scalar type. The comparison follows specific rules based on value types and provides automatic conversion for numeric types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_lt.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator<(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator<(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator<(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n```\n\n----------------------------------------\n\nTITLE: Checking for Unsigned Numbers in C++\nDESCRIPTION: Function declaration for checking if a JSON value is an unsigned integer number. Returns true if and only if the value is an unsigned integer, excluding floating-point and signed integer values. Provides no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_unsigned.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_number_unsigned() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_ASSERT Macro for Runtime Assertions in C++\nDESCRIPTION: This macro controls the code executed for runtime assertions in the library. It can be customized to use different assertion mechanisms.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nJSON_ASSERT(x)\n```\n\n----------------------------------------\n\nTITLE: Example: Accessing Object Elements Using string_view with Default Value in C++17\nDESCRIPTION: Example demonstrating the second overload that supports string_view for accessing object elements with default values in C++17.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/value__keytype.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Iterating over JSON Objects with Basic Iterators in C++\nDESCRIPTION: Creates a JSON object with three key-value pairs and iterates through it using begin() and end() iterators. The output demonstrates that object keys are ordered lexicographically by default.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// create JSON object {\"one\": 1, \"two\": 2, \"three\": 3}\njson j;\nj[\"one\"] = 1;\nj[\"two\"] = 2;\nj[\"three\"] = 3;\n\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout << *it << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Output from SAX Parsing Example\nDESCRIPTION: This snippet shows the JSON output produced by the SAX parsing example. It represents the result of processing the JSON input using the custom SAX event handlers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/string.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Value Storage Implementation in basic_json Class\nDESCRIPTION: Core value storage implementation showing how JSON values are stored using a tagged union of value_t enum and json_value union. The m_type member tracks the current value type while m_value stores the actual data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/architecture.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n/// the type of the current element\nvalue_t m_type = value_t::null;\n\n/// the value of the current element\njson_value m_value = {};\n```\n\n----------------------------------------\n\nTITLE: Declaring the patch Method in nlohmann::basic_json Class\nDESCRIPTION: The method declaration for applying a JSON Patch to a JSON document. It takes a JSON patch document as input and returns the patched document without modifying the original.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/patch.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbasic_json patch(const basic_json& json_patch) const;\n```\n\n----------------------------------------\n\nTITLE: Replacing Deprecated Parsing with Operator>> in C++\nDESCRIPTION: Demonstrates how to replace the deprecated operator<< for parsing JSON with the recommended operator>> approach.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json j;\nstd::stringstream ss(\"[1,2,3]\");\nss >> j;\n```\n\n----------------------------------------\n\nTITLE: Removing Last Reference Token with json_pointer::pop_back in C++\nDESCRIPTION: Function signature for the pop_back method which removes the last reference token from a JSON pointer. Throws out_of_range.405 exception if the JSON pointer has no parent. Has constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/pop_back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid pop_back();\n```\n\n----------------------------------------\n\nTITLE: Output of End Iterator Example in JSON\nDESCRIPTION: Shows the expected JSON output from the end() function usage example. This helps illustrate the practical effects of using the end() iterator.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/end.output\"\n```\n\n----------------------------------------\n\nTITLE: Example: Extended Diagnostics with Positions in C++\nDESCRIPTION: Demonstrates using extended diagnostics with position information enabled in exceptions for more comprehensive error reporting.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostic_positions.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostics_extended_positions.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining NLOHMANN_JSON_NAMESPACE Macro in C++\nDESCRIPTION: This macro evaluates to the full name of the nlohmann namespace. It includes the root namespace (nlohmann) and an inline ABI namespace. The default value is used when the macro is not explicitly defined.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_NAMESPACE /* value */\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Keys During Iteration in C++\nDESCRIPTION: Demonstrates how to access both the key and value during object iteration using the key() and value() methods of JSON iterators. This example shows how to print each key-value pair in the object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// create JSON object {\"one\": 1, \"two\": 2, \"three\": 3}\njson j;\nj[\"one\"] = 1;\nj[\"two\"] = 2;\nj[\"three\"] = 3;\n\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout << it.key() << \" : \" << it.value() << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE in C++\nDESCRIPTION: A complete example showing how to use the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE macro, which only implements serialization and is useful for non-default-constructible types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_only_serialize_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Object from Initializer List in C++\nDESCRIPTION: Static function declaration for creating a JSON object from an initializer list. The initializer list must contain pairs where the first elements are strings. Returns a JSON object value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic basic_json object(initializer_list_t init = {});\n```\n\n----------------------------------------\n\nTITLE: Output of type_error Example\nDESCRIPTION: Expected output from running the type_error example code, showing the error message format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n--8<-- \"examples/type_error.output\"\n```\n\n----------------------------------------\n\nTITLE: Custom Floating-Point Comparison Implementation\nDESCRIPTION: Example implementation of a custom floating-point comparison function that respects an epsilon value for more precise floating-point equality checks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_eq.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>\ninline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept\n{\n    return std::abs(a - b) <= epsilon;\n}\n```\n\n----------------------------------------\n\nTITLE: Unconditional Number Conversion in C++ using nlohmann/json\nDESCRIPTION: Demonstrates how the library allows unconditional conversion between different number types, which may lead to unexpected results. The example shows conversion from a double to an integer without warnings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/number_handling.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\ndouble d = 42.3;                                   // non-integer double value 42.3\njson jd = d;                                       // stores double value 42.3\nstd::int64_t i = jd.template get<std::int64_t>();  // now i==42; no warning or error is produced\n```\n\n----------------------------------------\n\nTITLE: Implementing get_to Template Method for JSON Value Conversion\nDESCRIPTION: Template method that performs explicit type conversion from JSON value to a compatible value type using json_serializer. The method fills the input parameter by calling the json_serializer<ValueType> from_json() method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_to.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ValueType>\nValueType& get_to(ValueType& v) const noexcept(\n    noexcept(JSONSerializer<ValueType>::from_json(\n        std::declval<const basic_json_t&>(), v)));\n```\n\n----------------------------------------\n\nTITLE: JSON Move Constructor Usage (C++)\nDESCRIPTION: Shows how to use the move constructor with std::move for JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__moveconstructor.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring is_number Function in C++\nDESCRIPTION: Function signature for the is_number() method in the nlohmann::basic_json class. It is a const member function that returns a boolean and doesn't throw exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_number() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Defining input_format_t Enumeration in C++\nDESCRIPTION: Defines an enumeration class input_format_t with values for different input formats used in parsing. This enum is used in the sax_parse function to specify the format of the input data to be parsed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/input_format_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nenum class input_format_t {\n    json,\n    cbor,\n    msgpack,\n    ubjson,\n    bson,\n    bjdata\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring const_iterator cbegin() Member Function in C++\nDESCRIPTION: This snippet declares the cbegin() member function for the nlohmann::basic_json class. It returns a const_iterator to the first element and is marked as noexcept, indicating it won't throw exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cbegin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst_iterator cbegin() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Output of type_name function for all JSON types\nDESCRIPTION: JSON output showing the results of calling type_name() on various JSON value types. This demonstrates the string representations returned for each type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type_name.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/type_name.output\"\n```\n\n----------------------------------------\n\nTITLE: Using parent_pointer Function in C++\nDESCRIPTION: Example usage of the parent_pointer function for different JSON Pointers, demonstrating how to obtain parent pointers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/parent_pointer.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/json_pointer__parent_pointer.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Conversion for JSON Values in C++\nDESCRIPTION: Demonstrates how to use explicit type conversion with get<>() instead of implicit conversion for JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json j = \"Hello, world!\";\nauto s = j.template get<std::string>();\n```\n\n----------------------------------------\n\nTITLE: JSON Null Check Example Usage Reference\nDESCRIPTION: Reference to an example file demonstrating is_null() usage across different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_null.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_null.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementation of basic_json Specialization Conversion\nDESCRIPTION: Example implementation showing how the second overload of get handles conversion between different basic_json specializations by simply returning the current instance.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nreturn *this;\n```\n\n----------------------------------------\n\nTITLE: Output of is_number_integer Example in JSON\nDESCRIPTION: JSON output showing the results of calling is_number_integer() on different JSON value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_integer.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_number_integer.output\"\n```\n\n----------------------------------------\n\nTITLE: Adding Unit Tests for Different Source Files\nDESCRIPTION: Configures the collection of unit tests, handling the 32-bit test separately based on JSON_32bitTest option. Creates tests for each source file across all specified C++ standards.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# *DO* use json_test_set_test_options() above this line\n\njson_test_should_build_32bit_test(json_32bit_test json_32bit_test_only \"${JSON_32bitTest}\")\nfile(GLOB files src/unit-*.cpp)\nif(json_32bit_test_only)\n    set(files src/unit-32bit.cpp)    \nelseif(NOT json_32bit_test)\n    list(FILTER files EXCLUDE REGEX src/unit-32bit.cpp)\nendif()\n\nforeach(file ${files})\n    json_test_add_test_for(${file} MAIN test_main CXX_STANDARDS ${test_cxx_standards} ${test_force})\nendforeach()\n\nif(json_32bit_test_only)\n    # Skip all other tests in this file\n    return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Basic JSON Insert Method Declarations\nDESCRIPTION: Function declarations for five different insert() method overloads that handle single element insertion, multiple copy insertion, range insertion, initializer list insertion, and object range insertion.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\niterator insert(const_iterator pos, const basic_json& val);\niterator insert(const_iterator pos, basic_json&& val);\n\n// (2)\niterator insert(const_iterator pos, size_type cnt, const basic_json& val);\n\n// (3)\niterator insert(const_iterator pos, const_iterator first, const_iterator last);\n\n// (4)\niterator insert(const_iterator pos, initializer_list_t ilist);\n\n// (5)\nvoid insert(const_iterator first, const_iterator last);\n```\n\n----------------------------------------\n\nTITLE: Declaring the json_sax Template Class in C++\nDESCRIPTION: Template declaration for the json_sax class that implements the SAX interface for JSON parsing. The template parameter BasicJsonType specifies a specialization of basic_json to use with this interface.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType>\nstruct json_sax;\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Exception Inheritance Hierarchy with Mermaid\nDESCRIPTION: This diagram shows the inheritance hierarchy for the json library's exception classes. All exceptions inherit from json::exception which in turn inherits from std::exception.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n    class `std::exception` {\n        <<interface>>\n    }\n\n    class `json::exception` {\n        +const int id\n        +const char* what() const\n    }\n\n    class `json::parse_error` {\n        +const std::size_t byte\n    }\n\n    class `json::invalid_iterator`\n    class `json::type_error`\n    class `json::out_of_range`\n    class `json::other_error`\n\n    `std::exception` <|-- `json::exception`\n    `json::exception` <|-- `json::parse_error`\n    `json::exception` <|-- `json::invalid_iterator`\n    `json::exception` <|-- `json::type_error`\n    `json::exception` <|-- `json::out_of_range`\n    `json::exception` <|-- `json::other_error`\n```\n\n----------------------------------------\n\nTITLE: Incorrect Way to Check for Discarded Values in C++\nDESCRIPTION: Example showing an incorrect way to check for discarded values, which will always return false due to the internal implementation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_discarded.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nj == json::value_t::discarded\n```\n\n----------------------------------------\n\nTITLE: Iterating JSON String Values in C++\nDESCRIPTION: Shows how to iterate over a JSON string value. When iterating strings or binary values, the entire value is returned by dereferencing the iterator rather than individual characters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/iterators.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\njson j = \"Hello, world\";\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout << *it << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring is_number_integer Function in C++\nDESCRIPTION: Function signature for is_number_integer(). It's a const member function that returns a boolean and doesn't throw exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_integer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_number_integer() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Implementing Greater Than Operators for JSON Values in C++\nDESCRIPTION: Operator overloads for comparing JSON values and scalar types using the greater than operator. Includes two variants: comparing two JSON values directly, and comparing a JSON value with a scalar type. Special handling is implemented for NaN values and discarded values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_gt.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator>(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator>(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator>(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Pointer Constructor in C++\nDESCRIPTION: Constructor for creating a JSON pointer according to RFC6901 Section 3 syntax. Takes an optional string parameter that represents the JSON pointer path, defaulting to an empty string which references the whole JSON value. Throws parse errors for invalid pointer syntax.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/json_pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nexplicit json_pointer(const string_t& s = \"\");\n```\n\n----------------------------------------\n\nTITLE: Declaring to_string Template Function for JSON Serialization in C++\nDESCRIPTION: Function declaration for the to_string template which converts JSON objects to string representation. It takes a BasicJsonType parameter and returns a standard string containing the serialization of the JSON value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_string.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename BasicJsonType>\nstd::string to_string(const BasicJsonType& j);\n```\n\n----------------------------------------\n\nTITLE: Using accept Function with String Input in C++\nDESCRIPTION: Demonstrates how to use the accept function to validate JSON input from a string. The example shows checking various JSON strings for validity and printing the results.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/accept.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/accept__string.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring the json_pointer Class Template in C++\nDESCRIPTION: Template declaration for the json_pointer class, which accepts a RefStringType parameter defining the string type used for reference tokens in the JSON pointer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename RefStringType>\nclass json_pointer;\n```\n\n----------------------------------------\n\nTITLE: Implementing rend() Iterator Methods in C++\nDESCRIPTION: Function declarations for reverse end iterators in nlohmann::json. Provides both mutable and const versions of the rend() method with no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rend.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nreverse_iterator rend() noexcept;\nconst_reverse_iterator rend() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: SAX Interface Class Diagram\nDESCRIPTION: Mermaid class diagram showing the structure of the json::sax_t interface with all required callback methods for parsing JSON data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/sax_interface.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass sax_t [\"json::sax_t\"] {\n    <<interface>>\n    +bool null()*\n    \n    +bool boolean(bool val)*\n    \n    +bool number_integer(number_integer_t val)*\n    +bool number_unsigned(number_unsigned_t val)*\n    \n    +bool number_float(number_float_t val, const string_t& s)*\n    \n    +bool string(string_t& val)*\n    +bool binary(binary_t& val)*\n    \n    +bool start_object(std::size_t elements)*\n    +bool end_object()*\n    +bool start_array(std::size_t elements)*\n    +bool end_array()*\n    +bool key(string_t& val)*\n    \n    +bool parse_error(std::size_t position, const std::string& last_token, const json::exception& ex)*\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Method Declaration\nDESCRIPTION: Method declaration for checking if a JSON value has no elements\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/empty.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbool empty() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Concatenating JSON Pointers in C++\nDESCRIPTION: Overloaded operator/ functions for concatenating JSON pointers, appending tokens, and adding array indices. These operations create new JSON pointers based on the input parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_slash.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\njson_pointer operator/(const json_pointer& lhs, const json_pointer& rhs);\n\n// (2)\njson_pointer operator/(const json_pointer& lhs, string_t token);\n\n// (3)\njson_pointer operator/(const json_pointer& lhs, std::size_t array_idx);\n```\n\n----------------------------------------\n\nTITLE: Defining String Value Handler in C++ JSON SAX Interface\nDESCRIPTION: This snippet defines the virtual method 'string' in the nlohmann::json_sax interface. It is called when a string value is read during SAX parsing. The method takes a string_t reference as a parameter and returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/string.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool string(string_t& val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Retrieving Binary Values from JSON in C++\nDESCRIPTION: Function signatures for the get_binary method that returns a reference to stored binary data in a JSON object. The method provides both const and non-const overloads for accessing binary values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_binary.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbinary_t& get_binary();\n\nconst binary_t& get_binary() const;\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE Macro in C++\nDESCRIPTION: Example of using NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE macro for non-default-constructible types that only need serialization. This variant only generates the to_json function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_only_serialize_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Object Element Addition Example in C++\nDESCRIPTION: Example demonstrating how push_back() and += can be used to add elements to a JSON object, showing automatic conversion of null values to objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator+=.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back__object_t__value.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Disabling Namespace Version Component in C++\nDESCRIPTION: This snippet demonstrates how to disable the version component of the inline namespace, allowing different versions to be used at the user's own risk.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/namespace.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_NAMESPACE_BEGIN  namespace nlohmann {\n#define NLOHMANN_JSON_NAMESPACE_END    }\n```\n\n----------------------------------------\n\nTITLE: Declaring get_ptr Function Templates in C++\nDESCRIPTION: These function templates provide implicit pointer access to the internally stored JSON value. They are overloaded for non-const and const versions, returning a pointer to the requested type if it matches the JSON value, or nullptr otherwise.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_ptr.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename PointerType>\nPointerType get_ptr() noexcept;\n\ntemplate<typename PointerType>\nconstexpr const PointerType get_ptr() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Default Array Type Implementation in C++\nDESCRIPTION: Shows the default implementation of array_t using std::vector as the container type and std::allocator as the allocator type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/array_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<\n  basic_json, // value_type\n  std::allocator<basic_json> // allocator_type\n>\n```\n\n----------------------------------------\n\nTITLE: Implementing std::swap for basic_json\nDESCRIPTION: Implementation of the std::swap specialization that uses the internal swap method of basic_json to exchange values between two JSON objects efficiently.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/std_swap.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid swap(nlohmann::basic_json& j1, nlohmann::basic_json& j2)\n{\n    j1.swap(j2);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ordered_map Template in C++\nDESCRIPTION: Declaration of the ordered_map class template that inherits from std::vector to preserve insertion order. It's designed as a minimal map-like container specifically for use within nlohmann::ordered_json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/ordered_map.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<class Key, class T, class IgnoredLess = std::less<Key>,\n         class Allocator = std::allocator<std::pair<const Key, T>>>\nstruct ordered_map : std::vector<std::pair<const Key, T>, Allocator>;\n```\n\n----------------------------------------\n\nTITLE: Default object_t Type Definition for C++14 and Earlier\nDESCRIPTION: Shows the default type definition for object_t using std::map with std::string keys and basic_json values, applicable to C++14 and earlier versions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++14\nstd::map<\n  std::string, // key_type\n  basic_json, // value_type\n  std::less<std::string>, // key_compare\n  std::allocator<std::pair<const std::string, basic_json>> // allocator_type\n>\n```\n\n----------------------------------------\n\nTITLE: Implementing is_primitive Function in C++\nDESCRIPTION: A possible implementation of the is_primitive() function. It checks if the JSON value is null, string, boolean, number, or binary using other member functions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_primitive.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_primitive() const noexcept\n{\n    return is_null() || is_string() || is_boolean() || is_number() || is_binary();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Inequality Operator Overloads for JSON Pointers in C++\nDESCRIPTION: Function signatures for the inequality operator (!= operator) for JSON pointers, comparing pointers with each other or with strings. The first overload provides no-throw guarantee, while the string conversion overloads may throw parse errors on invalid JSON pointer strings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_ne.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\ntemplate<typename RefStringTypeLhs, typename RefStringTypeRhs>\nbool operator!=(\n    const json_pointer<RefStringTypeLhs>& lhs,\n    const json_pointer<RefStringTypeRhs>& rhs) noexcept;  // (1)\n\ntemplate<typename RefStringTypeLhs, typename StringType>\nbool operator!=(\n    const json_pointer<RefStringTypeLhs>& lhs,\n    const StringType& rhs);                               // (2)\n\ntemplate<typename RefStringTypeRhs, typename StringType>\nbool operator!=(\n    const StringType& lhs,\n    const json_pointer<RefStringTypeRhs>& rhs);           // (2)\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Array Type in C++\nDESCRIPTION: Type definition for JSON arrays using template parameters ArrayType and AllocatorType. This defines how JSON arrays are stored in the C++ implementation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/array_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing array_t = ArrayType<basic_json, AllocatorType<basic_json>>;\n```\n\n----------------------------------------\n\nTITLE: CMakeLists.txt Configuration for Spack\nDESCRIPTION: A CMake configuration file for a project using nlohmann-json installed via Spack.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\n--8<-- \"integration/spack/CMakeLists.txt\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Less Than or Equal Operators for JSON Values in C++\nDESCRIPTION: Operator overloads for comparing JSON values using <= operator. Includes three overloads: comparing two JSON values, comparing JSON value with scalar type, and comparing scalar type with JSON value. Features no-throw guarantee and special NaN handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_le.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator<=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator<=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator<=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n```\n\n----------------------------------------\n\nTITLE: Empty Method Implementation\nDESCRIPTION: Example implementation showing how the empty() method checks for zero size\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/empty.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nbool empty() const noexcept\n{\n    return size() == 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Inequality Operator for JSON Values in C++\nDESCRIPTION: Defines the inequality operator (!=) for comparing JSON values. It includes overloads for comparing two JSON values, a JSON value with a scalar, and a scalar with a JSON value. The implementation covers both pre-C++20 and C++20 versions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_ne.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\nbool operator!=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate<typename ScalarType>\nbool operator!=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate<typename ScalarType>\nbool operator!=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n\n// since C++20\nclass basic_json {\n    bool operator!=(const_reference rhs) const noexcept;              // (1)\n\n    template<typename ScalarType>\n    bool operator!=(ScalarType rhs) const noexcept;                   // (2)\n};\n```\n\n----------------------------------------\n\nTITLE: Output of parent_pointer Function Example in JSON\nDESCRIPTION: JSON output showing the results of using the parent_pointer function on various JSON pointers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/parent_pointer.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/json_pointer__parent_pointer.output\"\n```\n\n----------------------------------------\n\nTITLE: Catching invalid_iterator Exception in C++\nDESCRIPTION: Example code demonstrating how to catch and handle an invalid_iterator exception in the nlohmann::json library. The actual code is not provided in the snippet.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/invalid_iterator.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/invalid_iterator.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Default Function Templates Generated by the Macro in C++\nDESCRIPTION: The macro adds two function templates to the namespace which handle the serialization (to_json) and deserialization (from_json) of the specified enum type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_serialize_enum.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType>\ninline void to_json(BasicJsonType& j, const type& e);\ntemplate<typename BasicJsonType>\ninline void from_json(const BasicJsonType& j, type& e);\n```\n\n----------------------------------------\n\nTITLE: Integrating nlohmann/json with CMake (Embedded)\nDESCRIPTION: CMake configuration to embed nlohmann/json library directly into an existing project.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_34\n\nLANGUAGE: cmake\nCODE:\n```\n# Typically you don't care so much for a third party library's tests to be\n# run from your own project's code.\nset(JSON_BuildTests OFF CACHE INTERNAL \"\")\n\n# If you only include this third party in PRIVATE source files, you do not\n# need to install it when your main project gets installed.\n# set(JSON_Install OFF CACHE INTERNAL \"\")\n\n# Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it\n# unintended consequences that will break the build.  It's generally\n# discouraged (although not necessarily well documented as such) to use\n# include(...) for pulling in other CMake projects anyways.\nadd_subdirectory(nlohmann_json)\n...\nadd_library(foo ...)\n...\ntarget_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Explicit Equivalent of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT in C++\nDESCRIPTION: The explicit implementation equivalent to what the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT macro generates, showing how default values are handled during deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_with_default_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring merge_patch Function in C++\nDESCRIPTION: Function signature for the merge_patch method in the nlohmann::basic_json class. It takes a const reference to a basic_json object as a parameter and returns void.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/merge_patch.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid merge_patch(const basic_json& apply_patch);\n```\n\n----------------------------------------\n\nTITLE: Output of BSON to JSON Deserialization in JSON\nDESCRIPTION: This snippet displays the JSON output resulting from the BSON deserialization process. It shows the reconstructed JSON object from the BSON data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bson.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_bson.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining get_ref Method Templates in C++\nDESCRIPTION: Template method declarations for get_ref in nlohmann::basic_json class. The method provides a way to get a reference to the internally stored JSON value without making copies, supporting both non-const and const contexts.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_ref.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ReferenceType>\nReferenceType get_ref();\n\ntemplate<typename ReferenceType>\nconst ReferenceType get_ref() const;\n```\n\n----------------------------------------\n\nTITLE: Method Signature for basic_json::clear\nDESCRIPTION: Function signature of the clear() method in the nlohmann::basic_json class, which resets a JSON value to its default state.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/clear.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid clear() noexcept;\n```\n\n----------------------------------------\n\nTITLE: Setting Path Configuration for nlohmann_json\nDESCRIPTION: Configures installation paths, build directories, and cmake configuration file locations. Determines whether to use multi-header or single-header version of the library based on user configuration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## CONFIGURATION\n##\ninclude(GNUInstallDirs)\n\nif (NOT DEFINED NLOHMANN_JSON_TARGET_NAME)\n    # Allow overriding the target name when using FetchContent / add_subdirectory.\n    set(NLOHMANN_JSON_TARGET_NAME ${PROJECT_NAME})\nendif()\n\nset(NLOHMANN_JSON_CONFIG_INSTALL_DIR        \"${CMAKE_INSTALL_DATADIR}/cmake/${PROJECT_NAME}\" CACHE INTERNAL \"\")\nset(NLOHMANN_JSON_INCLUDE_INSTALL_DIR       \"${CMAKE_INSTALL_INCLUDEDIR}\")\nset(NLOHMANN_JSON_TARGETS_EXPORT_NAME       \"${PROJECT_NAME}Targets\")\nset(NLOHMANN_JSON_CMAKE_CONFIG_TEMPLATE     \"cmake/config.cmake.in\")\nset(NLOHMANN_JSON_CMAKE_CONFIG_DIR          \"${CMAKE_CURRENT_BINARY_DIR}\")\nset(NLOHMANN_JSON_CMAKE_VERSION_CONFIG_FILE \"${NLOHMANN_JSON_CMAKE_CONFIG_DIR}/${PROJECT_NAME}ConfigVersion.cmake\")\nset(NLOHMANN_JSON_CMAKE_PROJECT_CONFIG_FILE \"${NLOHMANN_JSON_CMAKE_CONFIG_DIR}/${PROJECT_NAME}Config.cmake\")\nset(NLOHMANN_JSON_CMAKE_PROJECT_TARGETS_FILE \"${NLOHMANN_JSON_CMAKE_CONFIG_DIR}/${PROJECT_NAME}Targets.cmake\")\nset(NLOHMANN_JSON_PKGCONFIG_INSTALL_DIR     \"${CMAKE_INSTALL_DATADIR}/pkgconfig\")\n```\n\n----------------------------------------\n\nTITLE: Example Output of begin() Usage\nDESCRIPTION: JSON output demonstrating the result of using the begin() iterator method from the example above.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/begin.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/begin.output\"\n```\n\n----------------------------------------\n\nTITLE: Implementing is_structured Method in C++\nDESCRIPTION: Possible implementation of the is_structured() method. It checks if the JSON value is either an array or an object using the is_array() and is_object() methods.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_structured.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_structured() const noexcept\n{\n    return is_array() || is_object();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON SAX Array End Handler in C++\nDESCRIPTION: Virtual method declaration for handling the end of array events in JSON SAX parsing. Returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/end_array.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool end_array() = 0;\n```\n\n----------------------------------------\n\nTITLE: Default object_t Type Definition for C++14 and Later\nDESCRIPTION: Demonstrates the default type definition for object_t using std::map with std::string keys and basic_json values, applicable to C++14 and later versions, using std::less<> as the comparison function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object_t.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// since C++14\nstd::map<\n  std::string, // key_type\n  basic_json, // value_type\n  std::less<>, // key_compare\n  std::allocator<std::pair<const std::string, basic_json>> // allocator_type\n>\n```\n\n----------------------------------------\n\nTITLE: Defining string_t Type Alias in C++\nDESCRIPTION: Defines the string_t type as an alias for the StringType template parameter, typically std::string, used to store JSON strings in UTF-8 encoding. This type is used for both string values and object keys in the JSON implementation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/string_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing string_t = StringType;\n```\n\n----------------------------------------\n\nTITLE: Declaring End Iterator Functions in C++\nDESCRIPTION: Defines two overloads of the end() function for both mutable and const iterators. These functions return an iterator to one past the last element in the JSON container.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\niterator end() noexcept;\nconst_iterator end() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Front Method Usage Example - C++\nDESCRIPTION: Example code demonstrating the usage of front() method with file inclusion reference.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/front.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/front.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Object Example Output\nDESCRIPTION: Example output showing the result of creating JSON objects.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/object.output\"\n```\n\n----------------------------------------\n\nTITLE: UBJSON Serialization Output Example\nDESCRIPTION: Shows the output of the to_ubjson serialization example, displaying the binary UBJSON format as C-style output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/ubjson.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n--8<-- \"examples/to_ubjson.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Package Config File for nlohmann_json\nDESCRIPTION: Creates a pkg-config file to help external tools find and use the library. This enables integration with build systems that support pkg-config.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Install a pkg-config file, so other tools can find this.\nCONFIGURE_FILE(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/pkg-config.pc.in\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc\"\n    @ONLY\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Undefined Behavior with get_ptr in C++\nDESCRIPTION: This example demonstrates the potential for undefined behavior when using get_ptr. It shows how the pointer becomes invalid after the underlying JSON object changes due to array resizing.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_ptr.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j = {1, 2, 3, 4};\n    auto* ptr = j[0].get_ptr<std::int64_t*>();\n    std::cout << \"value at \" << ptr << \" is \" << *ptr << std::endl;\n\n    j.push_back(5);\n\n    ptr = j[0].get_ptr<std::int64_t*>();\n    std::cout << \"value at \" << ptr << \" is \" << *ptr << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the emplace Method in nlohmann::basic_json C++\nDESCRIPTION: Template method declaration for inserting a new element into a JSON object using in-place construction. Returns a pair containing an iterator to the inserted element and a boolean indicating if insertion occurred.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/emplace.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<class... Args>\nstd::pair<iterator, bool> emplace(Args&& ... args);\n```\n\n----------------------------------------\n\nTITLE: Defining object_t Type Alias for JSON Objects in C++\nDESCRIPTION: Defines the object_t type alias using template parameters for the container type, string type, and allocator type. This type is used to store JSON objects in the nlohmann::basic_json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing object_t = ObjectType<StringType,\n                            basic_json,\n                            default_object_comparator_t,\n                            AllocatorType<std::pair<const StringType, basic_json>>>;\n```\n\n----------------------------------------\n\nTITLE: Default Undefined State of JSON_NO_IO in C++\nDESCRIPTION: Shows the default state of the JSON_NO_IO macro in the library, which is undefined.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_no_io.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#undef JSON_NO_IO\n```\n\n----------------------------------------\n\nTITLE: JSON Output of flatten Method Example\nDESCRIPTION: Sample JSON output demonstrating the result of using the flatten method, showing how nested structures are converted to a flat representation with JSON pointers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/flatten.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/flatten.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining the cend() Method Signature in C++\nDESCRIPTION: Declaration of the cend() const method which returns a const_iterator to one past the last element of a JSON object. The method is marked as noexcept, indicating it won't throw exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cend.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst_iterator cend() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration with nlohmann/json Dependencies\nDESCRIPTION: Sets up a CMake project that uses Hunter package manager to fetch the nlohmann/json library. Configures minimum CMake version, includes Hunter gate, sets up project dependencies, and creates an executable target linked with nlohmann_json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/hunter/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\n\ninclude(\"cmake/HunterGate.cmake\")\nHunterGate(\n    URL \"https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz\"\n    SHA1 \"3319fe6a3b08090df7df98dee75134d68e2ef5a3\"\n)\n\nproject(json_example)\n\nhunter_add_package(nlohmann_json)\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Implementing back() Method Declaration in C++\nDESCRIPTION: Method declarations for accessing the last element in a JSON container, providing both mutable and const access variants.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nreference back();\n\nconst_reference back() const;\n```\n\n----------------------------------------\n\nTITLE: Checking JSON Object Type - C++ Method Declaration\nDESCRIPTION: Method declaration for checking if a JSON value is an object type. Returns true if the value is an object, false otherwise. Provides no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_object.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_object() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of JSON Patch Generation in C++\nDESCRIPTION: This example demonstrates how to create a JSON patch as a diff between two JSON values using the nlohmann::json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/diff.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diff.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Derived Type Serialization Macros in C++\nDESCRIPTION: Definition of six different macros for serializing and deserializing derived types. They differ in whether they are intrusive (defined inside the class) or non-intrusive (defined outside), how they handle missing values, and whether they support only serialization or both serialization and deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_derived_type.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE(type, base_type, member...)\n// (2)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT(type, base_type, member...)\n// (3)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE(type, base_type, member...)\n\n// (4)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE(type, base_type, member...)\n// (5)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT(type, base_type, member...)\n// (6)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(type, base_type, member...)\n```\n\n----------------------------------------\n\nTITLE: Defining binary_t Type in nlohmann::basic_json (C++)\nDESCRIPTION: Definition of the binary_t type which is a typedef to byte_container_with_subtype with BinaryType template parameter. The default value for BinaryType is std::vector<std::uint8_t>.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/binary_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing binary_t = byte_container_with_subtype<BinaryType>;\n```\n\n----------------------------------------\n\nTITLE: Initializer List Addition Example in C++\nDESCRIPTION: Example showing how initializer lists are treated as objects when possible in the context of operator+=.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator+=.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/push_back__initializer_list.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring const_reverse_iterator crbegin() function in C++\nDESCRIPTION: This snippet declares the crbegin() member function for the nlohmann::basic_json class. It returns a const_reverse_iterator to the reverse-beginning of the JSON object, which is the last element.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/crbegin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst_reverse_iterator crbegin() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Implementing std::hash Specialization for nlohmann::basic_json\nDESCRIPTION: Declares a specialization of std::hash for nlohmann::basic_json that provides hash functionality for JSON objects. This implementation ensures different hash values for distinct JSON types like null, numbers, and booleans, relying on std::hash where possible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/std_hash.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace std {\n    struct hash<nlohmann::basic_json>;\n}\n```\n\n----------------------------------------\n\nTITLE: Default Undefined State of JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\nDESCRIPTION: Shows the default state of the macro, which is undefined. By default, the library will perform compiler compatibility checks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_skip_unsupported_compiler_check.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#undef JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON to UBJSON Vector\nDESCRIPTION: Static method that converts a JSON value to a UBJSON byte vector. Supports optional size and type annotations. Returns vector of uint8_t containing the serialized data.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_ubjson.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic std::vector<std::uint8_t> to_ubjson(const basic_json& j,\n                                           const bool use_size = false,\n                                           const bool use_type = false);\n```\n\n----------------------------------------\n\nTITLE: Example: Removing Object Element Using String View Key\nDESCRIPTION: Example demonstrating how to remove an element from a JSON object using string_view as a key (C++17 feature), showing the effect across different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/erase.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/erase__keytype.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Reference Token in JSON Pointer - C++\nDESCRIPTION: Method declaration for retrieving the last reference token from a JSON pointer. Returns a const reference to string_t containing the last token. Throws out_of_range exception if pointer has no parent. Constant time complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/back.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst string_t& back() const;\n```\n\n----------------------------------------\n\nTITLE: Example usage of rbegin() in nlohmann::json\nDESCRIPTION: Example code demonstrating how to use the rbegin() method in the nlohmann::json library. The example is referenced but not fully shown in the documentation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rbegin.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/rbegin.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion Example in nlohmann/json C++\nDESCRIPTION: Demonstrates an implicit conversion from a JSON string to a std::string when JSON_USE_IMPLICIT_CONVERSIONS is enabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_implicit_conversions.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\njson j = \"Hello, world!\";\nstd::string s = j;\n```\n\n----------------------------------------\n\nTITLE: Count Method Signatures in C++\nDESCRIPTION: Method overloads for counting elements with specific keys in a JSON object. Includes both direct key_type counting and template version for compatible key types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/count.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nsize_type count(const typename object_t::key_type& key) const;\n\n// (2)\ntemplate<typename KeyType>\nsize_type count(KeyType&& key) const;\n```\n\n----------------------------------------\n\nTITLE: Front Method Declaration - C++\nDESCRIPTION: Function declarations for accessing the first element in a JSON container. Provides both const and non-const overloads that return references to the first element.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/front.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nreference front();\nconst_reference front() const;\n```\n\n----------------------------------------\n\nTITLE: Disabling Enum Serialization in C++\nDESCRIPTION: Demonstrates how disabling enum serialization prevents default to_json and from_json functions from being created, causing compilation errors when attempting to serialize or deserialize enums.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_disable_enum_serialization.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nint main()\n{\n    // normally invokes to_json serialization function but with JSON_DISABLE_ENUM_SERIALIZATION defined, it does not\n    const json j = Choice::first; \n\n    // normally invokes from_json parse function but with JSON_DISABLE_ENUM_SERIALIZATION defined, it does not\n    Choice ch = j.template get<Choice>();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Pointer Equality Operators in C++\nDESCRIPTION: Defines equality operator overloads for comparing JSON pointers with other JSON pointers and strings. Includes both pre-C++20 and C++20 implementations with template parameters for flexible string type support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_eq.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// until C++20\ntemplate<typename RefStringTypeLhs, typename RefStringTypeRhs>\nbool operator==(\n    const json_pointer<RefStringTypeLhs>& lhs,\n    const json_pointer<RefStringTypeRhs>& rhs) noexcept;            // (1)\n\ntemplate<typename RefStringTypeLhs, typename StringType>\nbool operator==(\n    const json_pointer<RefStringTypeLhs>& lhs,\n    const StringType& rhs);                                         // (2)\n\ntemplate<typename RefStringTypeRhs, typename StringType>\nbool operator==(\n    const StringType& lhs,\n    const json_pointer<RefStringTypeRhs>& rhs);                     // (2)\n\n// since C++20\nclass json_pointer {\n    template<typename RefStringTypeRhs>\n    bool operator==(\n        const json_pointer<RefStringTypeRhs>& rhs) const noexcept;  // (1)\n\n    bool operator==(const string_t& rhs) const;                     // (2)\n};\n```\n\n----------------------------------------\n\nTITLE: Using Iterator Pairs for Parsing in C++\nDESCRIPTION: Shows how to use iterator pairs instead of initializer lists for parsing functions like from_cbor, from_msgpack, etc.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconst char* s = \"[1,2,3]\";\nbool ok = nlohmann::json::accept(s, s + std::strlen(s));\n```\n\n----------------------------------------\n\nTITLE: Setting Binary Subtype in C++\nDESCRIPTION: Method declaration for setting the binary subtype of a JSON value. This method provides a no-throw guarantee and operates with constant complexity. It flags a binary JSON value as having a subtype which affects serialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/set_subtype.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid set_subtype(subtype_type subtype) noexcept;\n```\n\n----------------------------------------\n\nTITLE: Deserializing CBOR to JSON - Iterator Range Overload\nDESCRIPTION: Template function that deserializes CBOR data from an iterator range into a JSON value. Takes begin and end iterators along with configuration options for strict mode, exception handling, and CBOR tag handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/from_cbor.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename IteratorType>\nstatic basic_json from_cbor(IteratorType first, IteratorType last,\n                            const bool strict = true,\n                            const bool allow_exceptions = true,\n                            const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error);\n```\n\n----------------------------------------\n\nTITLE: Visualizing JSON Value Storage Structure with Mermaid\nDESCRIPTION: This diagram illustrates the class structure for storing JSON values, showing the relationship between basic_json, json_value, and value_t.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n\nclass value_t {\n    <<enumeration>>\n    null\n    object\n    array\n    string\n    boolean\n    number_integer\n    number_unsigned\n    number_float\n    binary\n    discarded\n}\n\nclass json_value {\n    <<union>>\n    object_t* object\n    array_t* array\n    string_t* string\n    binary_t* binary\n    boolean_t boolean\n    number_integer_t number_integer\n    number_unsigned_t number_unsigned\n    number_float_t number_float\n}\n\nclass basic_json {\n    -value_t m_type\n    -json_value m_value\n    +typedef object_t\n    +typedef array_t\n    +typedef binary_t\n    +typedef boolean_t\n    +typedef number_integer_t\n    +typedef number_unsigned_t\n    +typedef number_float_t\n}\n\nbasic_json .. json_value\nbasic_json .. value_t\n```\n\n----------------------------------------\n\nTITLE: JSON Output Example after Deserialization\nDESCRIPTION: Example JSON output produced after deserializing JSON data using the operator>> function, showing the expected result format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_gtgt.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/operator_deserialize.output\"\n```\n\n----------------------------------------\n\nTITLE: Using Namespaced UDLs Example\nDESCRIPTION: Example showing how to use UDLs when JSON_USE_GLOBAL_UDLS is set to 0, requiring explicit namespace usage.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_global_udls.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_GLOBAL_UDLS 0\n#include <nlohmann/json.hpp>\n\n#include <iostream>\n\nint main()\n{\n    // auto j = \"42\"_json; // This line would fail to compile,\n                           // because the UDLs are not in the global namespace\n\n    // Bring the UDLs into scope\n    using namespace nlohmann::json_literals;\n\n    auto j = \"42\"_json;\n\n    std::cout << j << std::endl;\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n42\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Values to BJData in C++\nDESCRIPTION: Shows how to convert JSON with binary values to BJData format, where binary values are serialized as arrays of uint8 values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42 (will be ignored in BJData)\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to BJData\nauto v = json::to_bjdata(j);\n```\n\n----------------------------------------\n\nTITLE: Conda Example C++ Code for Using nlohmann_json\nDESCRIPTION: Example C++ code for using the nlohmann_json library. This is referenced in the Conda installation instructions as example.cpp.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nexample.cpp\n```\n\n----------------------------------------\n\nTITLE: Using is_primitive Function in C++\nDESCRIPTION: Example usage of the is_primitive() function for different JSON types. The code demonstrates how the function behaves for various JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_primitive.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_primitive.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Range-Based Loop Without items() Function\nDESCRIPTION: Example demonstrating the limitation of range-based for loops without items() - inability to access key information since the loop provides only references to values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/items.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nfor (auto it : j_object)\n{\n    // \"it\" is of type json::reference and has no key() member\n    std::cout << \"value: \" << it << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Defining error_handler_t Enumeration in C++\nDESCRIPTION: Definition of the error_handler_t enumeration that specifies how to treat decoding errors when serializing JSON values. It includes three options: strict (throws exceptions), replace (substitutes invalid sequences), and ignore (copies bytes unchanged).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/error_handler_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nenum class error_handler_t {\n    strict,\n    replace,\n    ignore\n};\n```\n\n----------------------------------------\n\nTITLE: JSON Object Example Code\nDESCRIPTION: Example code reference for creating JSON objects using the object() function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/object.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/object.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Starting the Header Server\nDESCRIPTION: Command to start serving the json.hpp header file using the make command, which invokes serve_header.py with default configuration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ make serve_header\n```\n\n----------------------------------------\n\nTITLE: Example: Type Issues with value Method Return Type in C++\nDESCRIPTION: Example demonstrating potential issues with the return type of the value method. The return type is determined by the default value, which can cause unexpected behavior with numeric types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/value__return_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing max_size Method in nlohmann::basic_json C++ Library\nDESCRIPTION: Method declaration for max_size() which returns the maximum number of elements a JSON value can hold. It has no-throw guarantee and constant complexity for container types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/max_size.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nsize_type max_size() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Defining end_object Virtual Method\nDESCRIPTION: Pure virtual method declaration for handling the end of a JSON object during SAX parsing. Returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/end_object.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool end_object() = 0;\n```\n\n----------------------------------------\n\nTITLE: Declaring operator value_t() for nlohmann::basic_json in C++\nDESCRIPTION: This function is a constant member function that returns the type of the JSON value as a value from the value_t enumeration. It has no-throw guarantee and constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_value_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr operator value_t() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Checking if a JSON Pointer Points to Root Document in C++\nDESCRIPTION: Method signature for the empty() function in the json_pointer class that checks if the pointer refers to the root document. Returns true if the pointer points to the root document and provides a no-throw guarantee with constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/empty.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbool empty() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Example: Using Diagnostic Positions in Exceptions in C++\nDESCRIPTION: Shows how to use diagnostic positions in exceptions when parsing JSON, providing position information for error reporting.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostic_positions.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostic_positions_exception.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Lines Data Format Example\nDESCRIPTION: Example showing the structure of valid JSON Lines format where each line contains a complete JSON object with player name and card game wins.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/json_lines.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\"], [\"one pair\", \"10\"]]}\n{\"name\": \"Alexa\", \"wins\": [[\"two pair\", \"4\"], [\"two pair\", \"9\"]]}\n{\"name\": \"May\", \"wins\": []}\n{\"name\": \"Deloise\", \"wins\": [[\"three of a kind\", \"5\"]]}\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Dependency\nDESCRIPTION: Sets up a CMake project named 'json_example' that uses the nlohmann/json library. The configuration requires CMake 3.15 or higher, finds the nlohmann_json package, and creates an executable that links against the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/spack/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Accessing the crend() Method in nlohmann::json C++\nDESCRIPTION: Method signature for the crend() method that returns a const_reverse_iterator to the reverse-end of a JSON object. This element is a placeholder and accessing it results in undefined behavior.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/crend.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst_reverse_iterator crend() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Example Output in JSON Format\nDESCRIPTION: JSON output showing the result of using emplace_back to construct and append elements to an array.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/emplace_back.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/emplace_back.output\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of C++14 Standard Override\nDESCRIPTION: Example showing how to force the library to use C++14 standard by defining the JSON_HAS_CPP_14 macro before including the library header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_cpp_11.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_CPP_14 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Values to BSON in C++\nDESCRIPTION: Shows how to convert JSON with binary values to BSON format, which natively supports binary values and subtypes.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to BSON\nauto v = json::to_bson(j);\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Directory for Multiple Working Trees\nDESCRIPTION: YAML configuration example for serve_header.yml that shifts the web server root up one level to serve the header from multiple project directories or git working trees.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nroot: ..\n```\n\n----------------------------------------\n\nTITLE: Declaring start_array Method in C++ JSON SAX Interface\nDESCRIPTION: Virtual method declaration for handling the start of an array in JSON parsing. It takes the number of elements as a parameter and returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/start_array.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool start_array(std::size_t elements) = 0;\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT in C++\nDESCRIPTION: A complete example showing how to use the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT macro, which allows falling back to default values for missing JSON keys during deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_with_default_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Checking if a JSON Value is Boolean in C++\nDESCRIPTION: Method declaration for is_boolean() that determines if a JSON value is of boolean type (true or false). The method guarantees no-throw exception safety and constant time complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_boolean.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_boolean() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Copy Assignment Operator Declaration - C++\nDESCRIPTION: Declares the copy assignment operator for basic_json class using the copy-and-swap idiom. The operator is conditionally noexcept based on the move operations of its member types value_t and json_value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator=.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbasic_json& operator=(basic_json other) noexcept (\n    std::is_nothrow_move_constructible<value_t>::value &&\n    std::is_nothrow_move_assignable<value_t>::value &&\n    std::is_nothrow_move_constructible<json_value>::value &&\n    std::is_nothrow_move_assignable<json_value>::value\n);\n```\n\n----------------------------------------\n\nTITLE: Supported Versions of nlohmann/json\nDESCRIPTION: Lists the currently supported versions of the nlohmann/json project, indicating which versions receive security updates.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/community/security_policy.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 3.11.x   | :white_check_mark: |\n| < 3.11   | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Declaring Input Stream Operator for JSON Deserialization in C++\nDESCRIPTION: Function declaration for the std::istream operator>> which deserializes JSON data from an input stream into a basic_json object. This function reads serialized JSON from the stream and populates the provided JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_gtgt.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstd::istream& operator>>(std::istream& i, basic_json& j);\n```\n\n----------------------------------------\n\nTITLE: Declaring is_number_float Function in C++\nDESCRIPTION: Function signature for the is_number_float() method in the nlohmann::basic_json class. It is a const member function that returns a boolean value and does not throw exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_float.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_number_float() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Default Object Type Definition in C++\nDESCRIPTION: This code snippet shows the default type definition for JSON objects using std::map with default template arguments.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstd::map<\n  std::string, // key_type\n  basic_json, // value_type\n  std::less<>, // key_compare\n  std::allocator<std::pair<const std::string, basic_json>> // allocator_type\n>\n```\n\n----------------------------------------\n\nTITLE: Intrusive Derived Type Serialization Example in C++\nDESCRIPTION: A complete example demonstrating how to use NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE macro with a base class A and derived class B. The example shows how the macro handles the inheritance relationship during serialization and deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_derived_type.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_derived_type_intrusive_macro.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Lines Incorrect Implementation Example\nDESCRIPTION: Example showing an incorrect way to parse JSON Lines using operator>> which fails because the parser attempts to parse beyond the last valid value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/json_lines.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\njson j;\nwhile (input >> j)\n{\n    std::cout << j << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation for nlohmann_json\nDESCRIPTION: Sets up installation targets and configuration for the nlohmann_json library, including headers, CMake config files, and pkg-config file. Uses a custom version config file to ensure architecture independence.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## INSTALL\n## install header files, generate and install cmake config files for find_package()\n##\ninclude(CMakePackageConfigHelpers)\n# use a custom package version config file instead of\n# write_basic_package_version_file to ensure that it's architecture-independent\n# https://github.com/nlohmann/json/issues/1697\nconfigure_file(\n    \"cmake/nlohmann_jsonConfigVersion.cmake.in\"\n    ${NLOHMANN_JSON_CMAKE_VERSION_CONFIG_FILE}\n    @ONLY\n)\nconfigure_file(\n    ${NLOHMANN_JSON_CMAKE_CONFIG_TEMPLATE}\n    ${NLOHMANN_JSON_CMAKE_PROJECT_CONFIG_FILE}\n    @ONLY\n)\n\nif(JSON_Install)\n    install(\n        DIRECTORY ${NLOHMANN_JSON_INCLUDE_BUILD_DIR}\n        DESTINATION ${NLOHMANN_JSON_INCLUDE_INSTALL_DIR}\n    )\n    install(\n        FILES ${NLOHMANN_JSON_CMAKE_PROJECT_CONFIG_FILE} ${NLOHMANN_JSON_CMAKE_VERSION_CONFIG_FILE}\n        DESTINATION ${NLOHMANN_JSON_CONFIG_INSTALL_DIR}\n    )\n    if (NLOHMANN_ADD_NATVIS)\n        install(\n            FILES ${NLOHMANN_NATVIS_FILE}\n            DESTINATION .\n    )\n    endif()\n    export(\n        TARGETS ${NLOHMANN_JSON_TARGET_NAME}\n        NAMESPACE ${PROJECT_NAME}::\n        FILE ${NLOHMANN_JSON_CMAKE_PROJECT_TARGETS_FILE}\n    )\n    install(\n        TARGETS ${NLOHMANN_JSON_TARGET_NAME}\n        EXPORT ${NLOHMANN_JSON_TARGETS_EXPORT_NAME}\n        INCLUDES DESTINATION ${NLOHMANN_JSON_INCLUDE_INSTALL_DIR}\n    )\n    install(\n        EXPORT ${NLOHMANN_JSON_TARGETS_EXPORT_NAME}\n        NAMESPACE ${PROJECT_NAME}::\n        DESTINATION ${NLOHMANN_JSON_CONFIG_INSTALL_DIR}\n    )\n    install(\n        FILES \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc\"\n        DESTINATION ${NLOHMANN_JSON_PKGCONFIG_INSTALL_DIR}\n    )\n    include(CPack)\nendif()\n```\n\n----------------------------------------\n\nTITLE: JSON NaN Serialization\nDESCRIPTION: Shows that NaN (Not-a-Number) values in C++ are serialized to null in JSON output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\nnull\n```\n\n----------------------------------------\n\nTITLE: Defining the json_serializer Template Alias in C++\nDESCRIPTION: A template alias that maps to JSONSerializer with the same template parameters. Used for type conversion in to_json/from_json functions with SFINAE type checks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/json_serializer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T, typename SFINAE>\nusing json_serializer = JSONSerializer<T, SFINAE>;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\nDESCRIPTION: Demonstrates how to use the macro to disable compiler compatibility checks before including the nlohmann/json library header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_skip_unsupported_compiler_check.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_SKIP_UNSUPPORTED_COMPILER_CHECK 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Converting Binary Values to CBOR in C++\nDESCRIPTION: Demonstrates converting JSON with binary values to CBOR format, which supports binary values and uses tags to represent subtypes.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to CBOR\nauto v = json::to_cbor(j);\n```\n\n----------------------------------------\n\nTITLE: Exception Control Macros Definition in nlohmann/json\nDESCRIPTION: The three macros used to override C++ exception handling within the library. These allow customizing how exceptions are caught, thrown, and how try blocks are handled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_throw_user.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\n#define JSON_CATCH_USER(exception) /* value */\n// (2)\n#define JSON_THROW_USER(exception) /* value */\n// (3)\n#define JSON_TRY_USER /* value */\n```\n\n----------------------------------------\n\nTITLE: Enabling Extended Diagnostics with JSON_DIAGNOSTICS Macro in C++\nDESCRIPTION: This macro enables extended diagnostic messages for exceptions. When set to 1, it includes JSON Pointers in exception messages to pinpoint the source of errors.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nJSON_DIAGNOSTICS\n```\n\n----------------------------------------\n\nTITLE: Checking if JSON Value is String in C++ using nlohmann::basic_json\nDESCRIPTION: Method signature for the is_string() function that checks if a JSON value is a string type. The method is constexpr, returns a boolean, and has no-throw exception guarantee with constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_string.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_string() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Defining other_error Exception Class in C++\nDESCRIPTION: Declaration of the other_error class, which inherits from the exception class. This exception is used for errors that don't fit into other specific categories.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/other_error.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass other_error : public exception;\n```\n\n----------------------------------------\n\nTITLE: Using amalgamate.py from command line\nDESCRIPTION: Command line usage for amalgamate.py showing required and optional parameters. The tool requires a config JSON file, source directory path, and can optionally use a prologue file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/amalgamate/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\namalgamate.py [-v] -c path/to/config.json -s path/to/source/dir \\\n        [-p path/to/prologue.(c|h)]\n```\n\n----------------------------------------\n\nTITLE: Incorrect Ordered JSON Parsing\nDESCRIPTION: Demonstrates incorrect usage where parsing with nlohmann::json loses the insertion order even when assigning to ordered_json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/object_order.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nstd::ifstream i(\"input.json\");\nnlohmann::ordered_json j = nlohmann::json::parse(i);\nstd::cout << j.dump(2) << std::endl;\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"one\": 1,\n  \"three\": 3\n  \"two\": 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Literal Operator into Scope in C++\nDESCRIPTION: Different ways to bring the \"_json\" operator into scope. These using declarations help with migration to future library versions and make the operator available in the current scope.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_literal_json.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nusing nlohmann::literals::operator \"\"_json;\nusing namespace nlohmann::literals;\nusing namespace nlohmann::json_literals;\nusing namespace nlohmann::literals::json_literals;\nusing namespace nlohmann;\n```\n\n----------------------------------------\n\nTITLE: Custom Assertion Implementation\nDESCRIPTION: Example showing how to customize the assertion behavior with custom error reporting and abort handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_assert.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <cstdlib>\n#define JSON_ASSERT(x) if(!(x)){fprintf(stderr, \"assertion error in %s\\n\", __FUNCTION__); std::abort();}\n\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Output\nDESCRIPTION: The JSON output produced by the C++ example above, included from an external file 'examples/README.output'.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/README.output\"\n```\n\n----------------------------------------\n\nTITLE: JSON Output of Patch Generation Example\nDESCRIPTION: The JSON output produced by the diff function, showing the generated JSON Patch.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/diff.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/diff.output\"\n```\n\n----------------------------------------\n\nTITLE: Encoding wide strings to UTF-8 for JSON storage in C++\nDESCRIPTION: Demonstrates how to convert wide strings (std::wstring) to UTF-8 encoding for proper storage and serialization in JSON objects. This is necessary because the library assumes UTF-8 encoding for strings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/faq.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <codecvt> // codecvt_utf8\n#include <locale>  // wstring_convert\n\n// encoding function\nstd::string to_utf8(std::wstring& wide_string)\n{\n    static std::wstring_convert<std::codecvt_utf8<wchar_t>> utf8_conv;\n    return utf8_conv.to_bytes(wide_string);\n}\n\njson j;\nstd::wstring ws = L\"B1234 \";\n\nj[\"original\"] = ws;\nj[\"encoded\"] = to_utf8(ws);\n\nstd::cout << j << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Setting Up CMake Project with nlohmann/json Library\nDESCRIPTION: Configures a CMake project called 'DummyImport' that imports the nlohmann/json library and creates two executables linking against it in different ways. The file demonstrates both namespaced and non-namespaced target linking approaches.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5...3.14)\n\nproject(DummyImport CXX)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(with_namespace_target main.cpp)\ntarget_link_libraries(with_namespace_target nlohmann_json::nlohmann_json)\n\nadd_executable(without_namespace_target main.cpp)\ntarget_link_libraries(without_namespace_target nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_DISABLE_ENUM_SERIALIZATION Macro in C++\nDESCRIPTION: Defines the JSON_DISABLE_ENUM_SERIALIZATION macro to disable default enum serialization and deserialization functions. When set to 1, users must provide their own serialization functions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_disable_enum_serialization.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DISABLE_ENUM_SERIALIZATION /* value */\n```\n\n----------------------------------------\n\nTITLE: Example C++ Code for nlohmann_json with Hunter\nDESCRIPTION: Sample C++ code demonstrating how to use the nlohmann_json library with Hunter integration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/hunter/example.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaring the clear_subtype Method in C++\nDESCRIPTION: Function declaration for the clear_subtype method which clears the binary subtype and marks the value as not having a subtype. This affects serialization behavior, such as MessagePack preferring the bin family over ext family.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/clear_subtype.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid clear_subtype() noexcept;\n```\n\n----------------------------------------\n\nTITLE: Basic Count Example in C++\nDESCRIPTION: Example code referenced as 'count__object_t_key_type.cpp' demonstrating the basic usage of the count() method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/count.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/count__object_t_key_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_SKIP_LIBRARY_VERSION_CHECK macro in C++\nDESCRIPTION: This snippet shows how to define the JSON_SKIP_LIBRARY_VERSION_CHECK macro to skip the library version compatibility check. When defined, the library will not issue warnings about different versions being included.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_skip_library_version_check.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_SKIP_LIBRARY_VERSION_CHECK\n```\n\n----------------------------------------\n\nTITLE: Checking JSON Array Type in C++\nDESCRIPTION: Member function that checks if the current JSON value is an array type. Returns a boolean value and provides no-throw exception guarantee with constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_array.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_array() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Implementing the number_unsigned Method in JSON SAX Interface\nDESCRIPTION: Declaration of the pure virtual method for handling unsigned integer values in the JSON SAX parser. This method is called when an unsigned integer is encountered during parsing and returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/number_unsigned.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool number_unsigned(number_unsigned_t val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Defining number_unsigned_t Type for Unsigned JSON Numbers in C++\nDESCRIPTION: This snippet defines the number_unsigned_t type as an alias for NumberUnsignedType, which is used to store unsigned integer JSON numbers in the nlohmann::basic_json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/number_unsigned_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing number_unsigned_t = NumberUnsignedType;\n```\n\n----------------------------------------\n\nTITLE: Specifying reuse Package Version\nDESCRIPTION: Specifies the exact version (5.0.2) requirement for the reuse package\nSOURCE: https://github.com/nlohmann/json/blob/develop/cmake/requirements/requirements-reuse.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nreuse==5.0.2\n```\n\n----------------------------------------\n\nTITLE: Method Declaration for Binary Array Check\nDESCRIPTION: Declares a constexpr member function that checks if the JSON value is a binary array. Returns true if the value is binary, false otherwise. Provides no-throw guarantee and constant time complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_binary.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_binary() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Triggering an Assertion with Uninitialized Iterator Range in C++\nDESCRIPTION: Shows how constructing a JSON value from an uninitialized iterator range leads to undefined behavior that triggers a runtime assertion. This illustrates the importance of properly initializing iterators before use.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/assertions.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json::iterator it1, it2;\n    json j(it1, it2);\n}\n```\n\n----------------------------------------\n\nTITLE: Building Fuzzers with afl++\nDESCRIPTION: Command to build fuzz testing binaries using afl++ instead of libFuzzer. This sets the afl-clang-fast++ compiler and appropriate flags to reuse the same code written for libFuzzer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nCXX=afl-clang-fast++ make fuzzers FUZZER_ENGINE=\"-fsanitize=fuzzer\" \n```\n\n----------------------------------------\n\nTITLE: Controlling Implicit Conversions with JSON_USE_IMPLICIT_CONVERSIONS Macro in C++\nDESCRIPTION: This macro controls whether implicit conversions are allowed. When set to 0, implicit conversions are disabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nJSON_USE_IMPLICIT_CONVERSIONS\n```\n\n----------------------------------------\n\nTITLE: Checking if a JSON Value is Discarded in C++\nDESCRIPTION: Example showing how to properly check if a JSON value has been discarded. This is the recommended approach rather than comparing with json::value_t::discarded.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_discarded.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nj.is_discarded()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json\nDESCRIPTION: Sets up a CMake project that uses the nlohmann/json library. Configures minimum CMake version, creates a project, finds the nlohmann_json package, and links it to an executable target.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/vcpkg/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Character Type Conversions in JSON C++\nDESCRIPTION: Demonstrates how character types are handled differently from strings, requiring explicit conversion to string type when needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nchar ch = 'A';                       // ASCII value 65\njson j_default = ch;                 // stores integer number 65\njson j_string = std::string(1, ch);  // stores string \"A\"\n```\n\n----------------------------------------\n\nTITLE: Enabling 3-Way Comparison in nlohmann/json\nDESCRIPTION: Example of how to force the library to use 3-way comparison by defining the JSON_HAS_THREE_WAY_COMPARISON macro to 1 before including the nlohmann/json header file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_three_way_comparison.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_THREE_WAY_COMPARISON 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Homebrew Example with Direct Compilation\nDESCRIPTION: Example showing how to use the nlohmann/json library installed via Homebrew by directly compiling a C++ file with the appropriate include path.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/homebrew/example.cpp\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nc++ example.cpp -I$(brew --prefix nlohmann-json)/include -std=c++11 -o example\n```\n\n----------------------------------------\n\nTITLE: Defining Parser Callback Type in C++\nDESCRIPTION: Defines the parser_callback_t template type as a function that takes depth, event, and parsed JSON reference as parameters and returns a boolean indicating whether to keep the parsed element.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/parser_callback_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BasicJsonType>\nusing parser_callback_t =\n    std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;\n```\n\n----------------------------------------\n\nTITLE: Using is_number Function in C++\nDESCRIPTION: Example usage of the is_number() function for different JSON types. The actual code is not provided in the snippet, but it's referenced from an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_number.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Define LibFuzzer Test Function\nDESCRIPTION: Defines a CMake function add_libfuzzer_test that creates test executables with proper linking and output directory configuration. Takes test name and source files as parameters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(add_libfuzzer_test name)\n  set(multi_arg_options \"SOURCES\")\n  cmake_parse_arguments(\n    \"add_libfuzzer_test\" \"\" \"\" \"${multi_arg_options}\" ${ARGN})\n  if (\"${add_libfuzzer_test_SOURCES}\" STREQUAL \"\")\n    message(FATAL_ERROR \"Source files must be specified\")\n  endif()\n  add_executable(LLVMFuzzer-${name}\n    ${add_libfuzzer_test_SOURCES}\n    )\n  target_link_libraries(LLVMFuzzer-${name} LLVMFuzzer)\n  set_target_properties(LLVMFuzzer-${name}\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY\n    \"${CMAKE_BINARY_DIR}/lib/Fuzzer/test\"\n    )\n  set(TestBinaries ${TestBinaries} LLVMFuzzer-${name} PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Return Value Examples\nDESCRIPTION: Example code showcasing the usage of is_binary() method across different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_binary.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_binary.cpp\"\n```\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_binary.output\"\n```\n\n----------------------------------------\n\nTITLE: Declaring out_of_range Exception Class in C++\nDESCRIPTION: The declaration of the out_of_range exception class that inherits from the base exception class. This exception is thrown when input parameters exceed expected ranges.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/out_of_range.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass out_of_range : public exception;\n```\n\n----------------------------------------\n\nTITLE: Function Signature for flatten Method in nlohmann::basic_json\nDESCRIPTION: Defines the flatten method that creates a flat JSON object with JSON pointers as keys and primitive values as values. This method provides strong exception safety and has linear complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/flatten.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbasic_json flatten() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for Documentation Build\nDESCRIPTION: Lists required Python packages and their versions for building documentation. Includes MkDocs core, Material theme, various plugins for Git integration, minification, redirects, and HTML proofing, along with dependencies like wheel and PyYAML.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nwheel==0.45.1\n\nmkdocs==1.6.1                                       # documentation framework\nmkdocs-git-revision-date-localized-plugin==1.4.5    # plugin \"git-revision-date-localized\"\nmkdocs-material==9.6.11                             # theme for mkdocs\nmkdocs-material-extensions==1.3.1                   # extensions\nmkdocs-minify-plugin==0.8.0                         # plugin \"minify\"\nmkdocs-redirects==1.2.2                             # plugin \"redirects\"\nmkdocs-htmlproofer-plugin==1.3.0                    # plugin \"htmlproofer\"\n\nPyYAML==6.0.2                                       # linter\n```\n\n----------------------------------------\n\nTITLE: Declaration of adl_serializer Template Structure in C++\nDESCRIPTION: Template declaration of the adl_serializer structure which takes two type parameters. This structure handles JSON serialization and deserialization using Argument-Dependent Lookup.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/adl_serializer/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename, typename>\nstruct adl_serializer;\n```\n\n----------------------------------------\n\nTITLE: Correct Ordered JSON Parsing\nDESCRIPTION: Shows the proper way to parse JSON while preserving insertion order using nlohmann::ordered_json's parse function.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/object_order.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::ifstream i(\"input.json\");\nauto j = nlohmann::ordered_json::parse(i);\nstd::cout << j.dump(2) << std::endl;\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"one\": 1,\n  \"two\": 2,\n  \"three\": 3\n}\n```\n\n----------------------------------------\n\nTITLE: Building Fuzzers with libFuzzer on macOS\nDESCRIPTION: Command to build fuzz testing binaries using libFuzzer on macOS with Homebrew-installed Clang. This handles the case where the default Apple compiler doesn't include libFuzzer support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake fuzzers FUZZER_ENGINE=\"-fsanitize=fuzzer\" CXX=$(brew --prefix llvm)/bin/clang\n```\n\n----------------------------------------\n\nTITLE: Declaring is_primitive Function in C++\nDESCRIPTION: Function signature for the is_primitive() member function of the nlohmann::basic_json class. It is a const member function that returns a boolean and never throws exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_primitive.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_primitive() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: CMakeLists.txt Configuration for vcpkg\nDESCRIPTION: A CMake configuration file for a project using nlohmann-json installed via vcpkg.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\n--8<-- \"integration/vcpkg/CMakeLists.txt\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Diagnostic Positions with JSON_DIAGNOSTIC_POSITIONS Macro in C++\nDESCRIPTION: This macro adds start_pos() and end_pos() member functions to basic_json values, allowing querying of byte positions for parsed JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nJSON_DIAGNOSTIC_POSITIONS\n```\n\n----------------------------------------\n\nTITLE: Creating nlohmann_json dependency in Meson build system\nDESCRIPTION: Meson build system code to locate and include the nlohmann_json library using pkg-config. The 'required: true' flag indicates that the build should fail if the dependency cannot be found.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/pkg-config.md#2025-04-21_snippet_1\n\nLANGUAGE: meson\nCODE:\n```\njson = dependency('nlohmann_json', required: true)\n```\n\n----------------------------------------\n\nTITLE: Default Definition of NLOHMANN_JSON_NAMESPACE_BEGIN in C++\nDESCRIPTION: The default definition of NLOHMANN_JSON_NAMESPACE_BEGIN opens the main nlohmann namespace and an inline versioned namespace for ABI compatibility.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_begin.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace nlohmann\n{\ninline namespace json_abi_v3_11_2\n{\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_DIAGNOSTICS Macro\nDESCRIPTION: Basic macro definition to enable or disable extended diagnostics for exception messages. Value can be 1 (enable) or 0 (disable).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostics.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DIAGNOSTICS /* value */\n```\n\n----------------------------------------\n\nTITLE: JSON Output from nlohmann/json Library Example\nDESCRIPTION: This snippet shows the JSON output generated by the example code using the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/index.md#2025-04-21_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n--8<-- \"examples/README.output\"\n```\n\n----------------------------------------\n\nTITLE: Virtual Method Declaration for JSON Object Start in C++\nDESCRIPTION: Declaration of the virtual method start_object in the nlohmann::json_sax interface that gets called when the beginning of a JSON object is read. The method accepts a size parameter indicating the number of elements or -1 if unknown.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/start_object.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool start_object(std::size_t elements) = 0;\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of basic_json::clear\nDESCRIPTION: Shows the equivalent implementation of the clear() method, which reassigns the JSON value to a new instance of the same type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/clear.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n*this = basic_json(type());\n```\n\n----------------------------------------\n\nTITLE: JSON Merge Patch Output\nDESCRIPTION: This JSON snippet shows the output of applying the JSON Merge Patch to the original JSON document. It demonstrates the resulting changes after the merge operation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/merge_patch.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/merge_patch.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining Base Exception Class - C++\nDESCRIPTION: Declaration of the base exception class that extends std::exception. Used as the foundation for all JSON library exceptions with added functionality for exception identification.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/exception.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass exception : public std::exception;\n```\n\n----------------------------------------\n\nTITLE: JSON Value Conversion Interface\nDESCRIPTION: Template function declarations for converting between JSON values and C++ types in both directions using to_json and from_json functions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/architecture.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<class T>\nvoid to_json(basic_json& j, const T& t);\n\ntemplate<class T>\nvoid from_json(const basic_json& j, T& t);\n```\n\n----------------------------------------\n\nTITLE: Example output from rbegin() usage\nDESCRIPTION: JSON output demonstrating the result of using the rbegin() method in the example code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rbegin.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/rbegin.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Main Library with Shared Code and Common Settings\nDESCRIPTION: Creates a library containing shared test code to speed up builds, with compiler-specific flags and definitions used across tests. Sets up doctest for testing and configures include directories.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n#############################################################################\n# test_main library with shared code to speed up build and common settings\n#############################################################################\n\nadd_library(test_main OBJECT src/unit.cpp)\ntarget_compile_definitions(test_main PUBLIC\n    DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n    JSON_TEST_KEEP_MACROS\n    JSON_TEST_USING_MULTIPLE_HEADERS=$<BOOL:${JSON_MultipleHeaders}>)\ntarget_compile_features(test_main PRIVATE cxx_std_11)\ntarget_compile_options(test_main PUBLIC\n    $<$<CXX_COMPILER_ID:MSVC>:/EHsc;$<$<CONFIG:Release>:/Od>>\n    # MSVC: Force to always compile with W4\n    #       Disable warning C4566: character represented by universal-character-name '\\uFF01'\n    #                              cannot be represented in the current code page (1252)\n    #       Disable warning C4996: 'nlohmann::basic_json<...>::operator <<': was declared deprecated\n    $<$<CXX_COMPILER_ID:MSVC>:/W4 /wd4566 /wd4996>\n    # https://github.com/nlohmann/json/issues/1114\n    $<$<CXX_COMPILER_ID:MSVC>:/bigobj> $<$<BOOL:${MINGW}>:-Wa,-mbig-obj>\n\n    # https://github.com/nlohmann/json/pull/3229\n    $<$<CXX_COMPILER_ID:Intel>:-diag-disable=2196>\n\n    $<$<NOT:$<CXX_COMPILER_ID:MSVC>>:-Wno-deprecated;-Wno-float-equal>\n    $<$<CXX_COMPILER_ID:GNU>:-Wno-deprecated-declarations>\n    $<$<CXX_COMPILER_ID:Intel>:-diag-disable=1786>)\ntarget_include_directories(test_main PUBLIC\n    thirdparty/doctest\n    thirdparty/fifo_map\n    ${PROJECT_BINARY_DIR}/include)\ntarget_link_libraries(test_main PUBLIC ${NLOHMANN_JSON_TARGET_NAME})\n```\n\n----------------------------------------\n\nTITLE: Declaring JSON String Literal Operator in C++\nDESCRIPTION: Declaration of the user-defined string literal operator \"_json\" which converts a string literal to a json object. It takes a character pointer and size parameter and returns a json object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_literal_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson operator \"\"_json(const char* s, std::size_t n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Filesystem Support with JSON_HAS_FILESYSTEM Macros in C++\nDESCRIPTION: These macros control the use of std::filesystem or std::experimental::filesystem for C++17 filesystem support. They can be set to 1 to override built-in checks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nJSON_HAS_FILESYSTEM\nJSON_HAS_EXPERIMENTAL_FILESYSTEM\n```\n\n----------------------------------------\n\nTITLE: Bringing JSON Pointer Literal Operator into Scope in C++\nDESCRIPTION: Different ways to bring the _json_pointer string literal operator into scope. Using these directives allows the operator to be used in code without full qualification.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_literal_json_pointer.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nusing nlohmann::literals::operator \"\"_json_pointer;\nusing namespace nlohmann::literals;\nusing namespace nlohmann::json_literals;\nusing namespace nlohmann::literals::json_literals;\nusing namespace nlohmann;\n```\n\n----------------------------------------\n\nTITLE: JSON Array Type Check Usage Example\nDESCRIPTION: Example placeholder referencing external file that demonstrates is_array() usage across different JSON types\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_array.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/is_array.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing key_compare Type in ordered_map\nDESCRIPTION: Definition of the key_compare member type for the ordered_map class. It uses std::equal_to with different syntax depending on the C++ standard version.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/ordered_map.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::equal_to<Key>  // until C++14\n\nstd::equal_to<>     // since C++14\n```\n\n----------------------------------------\n\nTITLE: NuGet MSBuild Target Configuration for nlohmann.json\nDESCRIPTION: MSBuild XML configuration that adds the nlohmann.json library's include directory to the project's include paths. This file is automatically imported into the project when the NuGet package is installed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_25\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    <ItemDefinitionGroup>\n        <ClCompile>\n            <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n        </ClCompile>\n    </ItemDefinitionGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Default Definition of NLOHMANN_JSON_NAMESPACE_NO_VERSION in C++\nDESCRIPTION: This snippet shows the default definition of the NLOHMANN_JSON_NAMESPACE_NO_VERSION macro, which is set to 0. When not explicitly defined, the library will define it to this default value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_no_version.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0\n```\n\n----------------------------------------\n\nTITLE: Using Proper Namespace for JSON Types in C++\nDESCRIPTION: Demonstrates the correct way to reference JSON types using the nlohmann namespace or the NLOHMANN_JSON_NAMESPACE macro.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nvoid to_json(nlohmann::json& j, const person& p)\n{\n    j[\"age\"] = p.age;\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nvoid to_json(NLOHMANN_JSON_NAMESPACE::json& j, const person& p)\n{\n    j[\"age\"] = p.age;\n}\n```\n\n----------------------------------------\n\nTITLE: Front Method Example Output - JSON\nDESCRIPTION: Example output showing the result of using the front() method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/front.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/front.output\"\n```\n\n----------------------------------------\n\nTITLE: Declaration of nlohmann::basic_json::parse_error Class in C++\nDESCRIPTION: The class declaration for parse_error, which inherits from the exception class. This exception is thrown when parse errors occur during JSON deserialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/parse_error.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass parse_error : public exception;\n```\n\n----------------------------------------\n\nTITLE: Example Usage of cend() Method\nDESCRIPTION: Example code demonstrating how to use the cend() method in practice. The example references an external file 'examples/cend.cpp'.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cend.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/cend.cpp\"\n```\n\n----------------------------------------\n\nTITLE: MessagePack Deserialization Output Example\nDESCRIPTION: Sample output from the MessagePack deserialization process, showing the resulting JSON data after converting from MessagePack format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/messagepack.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_msgpack.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining invalid_iterator Exception Class in C++\nDESCRIPTION: Declaration of the invalid_iterator class, which inherits from the exception base class. This exception is thrown for iterator-related errors with ids in the 2xx range.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/invalid_iterator.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nclass invalid_iterator : public exception;\n```\n\n----------------------------------------\n\nTITLE: Using JSON_NOEXCEPTION Macro in C++ Project\nDESCRIPTION: This example shows how to use the JSON_NOEXCEPTION macro in a C++ project to disable exceptions for the nlohmann/json library. The macro is defined before including the library header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_noexception.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_NOEXCEPTION 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Output of is_primitive Example in JSON\nDESCRIPTION: The expected output of the is_primitive() example, showing the result of the function for different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_primitive.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_primitive.output\"\n```\n\n----------------------------------------\n\nTITLE: Creating Test Executable for Diagnostics Compatibility\nDESCRIPTION: Builds a test executable that links against both diagnostic-enabled and diagnostic-disabled libraries to verify ABI compatibility.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/diag/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(abi_compat_diag diag.cpp)\ntarget_link_libraries(abi_compat_diag PRIVATE\n    abi_compat_main abi_compat_diag_on abi_compat_diag_off)\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Pointer String Literal Operator in C++\nDESCRIPTION: The operator declaration for the user-defined string literal that converts string literals to json_pointer objects. It takes a character array and its length as parameters, returning a json_pointer object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_literal_json_pointer.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\njson_pointer operator \"\"_json_pointer(const char* s, std::size_t n);\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Standard Version Macros\nDESCRIPTION: Core preprocessor definitions that specify which C++ standard versions are supported. These macros override the library's automatic C++ standard detection.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_cpp_11.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_CPP_11\n#define JSON_HAS_CPP_14\n#define JSON_HAS_CPP_17\n#define JSON_HAS_CPP_20\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Pointer to String - Implementation\nDESCRIPTION: Implementation of the string_t operator that converts a JSON pointer to its string representation by calling to_string(). This implementation is deprecated in favor of the to_string() method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_string_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\noperator string_t() const\n{\n    return to_string();\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of rend() Iterator\nDESCRIPTION: Code snippet placeholder referenced in documentation showing example usage of the rend() method.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rend.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/rend.cpp\"\n```\n\n----------------------------------------\n\nTITLE: JSON Array Check Example Output\nDESCRIPTION: Example output placeholder showing the results of is_array() checks\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_array.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_array.output\"\n```\n\n----------------------------------------\n\nTITLE: Implementing 3-way Comparison Operator for JSON in C++20\nDESCRIPTION: Defines the spaceship operator (<=>) for the basic_json class, enabling 3-way comparisons between JSON values and between JSON values and scalar types. It returns a std::partial_ordering based on specific comparison rules.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_spaceship.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// since C++20\nclass basic_json {\n    std::partial_ordering operator<=>(const_reference rhs) const noexcept;  // (1)\n\n    template<typename ScalarType>\n    std::partial_ordering operator<=>(const ScalarType rhs) const noexcept; // (2)\n};\n```\n\n----------------------------------------\n\nTITLE: NuGet packages.config XML Configuration\nDESCRIPTION: Example of a packages.config file used by NuGet to track package dependencies for a project. This file lists the nlohmann.json package with version 3.5.0 targeted for native frameworks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_24\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<packages>\n  <package id=\"nlohmann.json\" version=\"3.5.0\" targetFramework=\"native\" />\n</packages>\n```\n\n----------------------------------------\n\nTITLE: Disabling Exceptions with JSON_NOEXCEPTION Macro in C++\nDESCRIPTION: This macro disables the use of exceptions in the library. When defined, alternative error handling mechanisms are used instead of throwing exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nJSON_NOEXCEPTION\n```\n\n----------------------------------------\n\nTITLE: Overriding Try Blocks with JSON_TRY_USER Macro in C++\nDESCRIPTION: This macro overrides the default try behavior in the library, allowing for custom implementation of try blocks.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nJSON_TRY_USER\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization Output Example\nDESCRIPTION: The JSON output produced by the custom serialization example, showing the serialized format of the non-default-constructible type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/json_serializer.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_json__non_default_constructible.output\"\n```\n\n----------------------------------------\n\nTITLE: MessagePack Serialization Output Example\nDESCRIPTION: Sample output from the MessagePack serialization process, showing the result of converting JSON data to MessagePack format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/messagepack.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n--8<-- \"examples/to_msgpack.output\"\n```\n\n----------------------------------------\n\nTITLE: Example: Writing JSON Pointer to Stream in C++\nDESCRIPTION: Shows how to write a JSON pointer to an output stream, converting the pointer to its string representation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/operator_ltlt.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_ltlt__json_pointer.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining UBSan Test List in CMake\nDESCRIPTION: Creates a list of UBSan tests to be compiled and run. Currently includes only the SignedIntOverflowTest.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/ubsan/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(UbsanTests\n  SignedIntOverflowTest\n  )\n```\n\n----------------------------------------\n\nTITLE: UBJSON Deserialization Output Example\nDESCRIPTION: Shows the JSON output resulting from deserializing UBJSON data in the from_ubjson example.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/ubjson.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_ubjson.output\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of max_size Method with Different JSON Types\nDESCRIPTION: Example code demonstrating how to call max_size() on different JSON value types. The output is platform-dependent and shows the maximum size limit for each type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/max_size.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/max_size.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON Pointer Equality with to_string in C++\nDESCRIPTION: Example showing that a JSON pointer is equal to a new JSON pointer created from its string representation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/to_string.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nptr == json_pointer(ptr.to_string());\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Enum Serialization with JSON_DISABLE_ENUM_SERIALIZATION Macro in C++\nDESCRIPTION: When defined, this macro excludes default parse and serialize functions for enums, requiring the user to provide custom implementations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nJSON_DISABLE_ENUM_SERIALIZATION\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_JSON_NAMESPACE in C++\nDESCRIPTION: This example demonstrates how to use NLOHMANN_JSON_NAMESPACE instead of just nlohmann, and how to output its value. It shows practical usage of the macro in code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_json_namespace.cpp\"\n```\n\n----------------------------------------\n\nTITLE: SVG Close Icon\nDESCRIPTION: SVG path definition for a close (X) icon used in the menu header\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_1\n\nLANGUAGE: SVG\nCODE:\n```\n<svg aria-label=\"Close\" class=\"octicon octicon-x js-menu-close\" height=\"16\" role=\"img\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\"><path d=\"M7.48 8l3.75 3.75-1.48 1.48L6 9.48l-3.75 3.75-1.48-1.48L4.52 8 .77 4.25l1.48-1.48L6 6.52l3.75-3.75 1.48 1.48z\"></path></svg>\n```\n\n----------------------------------------\n\nTITLE: Stream Input Using Right Shift Operator\nDESCRIPTION: Alternative method to parse JSON from a stream using the right shift operator when no callback function is needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\njson j;\nss >> j;\n```\n\n----------------------------------------\n\nTITLE: Declaring Binary Value Handler Method in JSON SAX Interface\nDESCRIPTION: Virtual method declaration for handling binary values in the SAX parsing interface. The method takes a binary_t reference parameter and returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/binary.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool binary(binary_t& val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Pointer to String - Function Declaration\nDESCRIPTION: Declaration of the operator string_t() conversion function that returns a string representation of a JSON pointer.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/operator_string_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\noperator string_t() const\n```\n\n----------------------------------------\n\nTITLE: JSON Output for boolean_t Example\nDESCRIPTION: Expected JSON output from the boolean_t usage example. This snippet is referenced in the documentation but not directly provided in the input.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/boolean_t.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/boolean_t.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining rbegin() function signatures in nlohmann::basic_json\nDESCRIPTION: Declares two overloaded rbegin() member functions that return reverse iterators to the first element in reverse order (last element). Both versions are marked noexcept for exception safety.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rbegin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nreverse_iterator rbegin() noexcept;\nconst_reverse_iterator rbegin() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann.json using dotnet CLI\nDESCRIPTION: Command to install the nlohmann.json package using the dotnet CLI package manager. This is used to add the JSON library to a .NET project.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package nlohmann.json\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_ASSERT Macro\nDESCRIPTION: Basic definition of the JSON_ASSERT macro used for runtime assertions. The macro takes a scalar expression as input and is used throughout the library for verification of invariants.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_assert.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_ASSERT(x) /* value */\n```\n\n----------------------------------------\n\nTITLE: Custom Exception Handling with Logging Example\nDESCRIPTION: An example showing how to customize the exception handling macros to disable exceptions while creating detailed log entries for errors before aborting.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_throw_user.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\n#define JSON_TRY_USER if(true)\n#define JSON_CATCH_USER(exception) if(false)\n#define JSON_THROW_USER(exception)                           \\\n    {std::clog << \"Error in \" << __FILE__ << \":\" << __LINE__ \\\n               << \" (function \" << __FUNCTION__ << \") - \"    \\\n               << (exception).what() << std::endl;           \\\n     std::abort();}\n\n#include <nlohmann/json.hpp>\n```\n\n----------------------------------------\n\nTITLE: Example: Comparing JSON Values and Scalars Using Spaceship Operator in C++20\nDESCRIPTION: Illustrates how the spaceship operator can be used to compare JSON values with scalar types. This example showcases the conversion of scalars to JSON values for comparison and the resulting ordering.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_spaceship.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/operator_spaceship__scalartype.c++20.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Disabling JSON Exceptions with Custom Error Handling in C++\nDESCRIPTION: This code demonstrates how to disable exceptions in the nlohmann/json library by defining JSON_TRY_USER, JSON_CATCH_USER, and JSON_THROW_USER macros. It redirects errors to a log file with detailed error information before calling abort().\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\n#define JSON_TRY_USER if(true)\n#define JSON_CATCH_USER(exception) if(false)\n#define JSON_THROW_USER(exception)                           \\\n    {std::clog << \"Error in \" << __FILE__ << \":\" << __LINE__ \\\n               << \" (function \" << __FUNCTION__ << \") - \"    \\\n               << (exception).what() << std::endl;           \\\n     std::abort();}\n\n#include <nlohmann/json.hpp>\n```\n\n----------------------------------------\n\nTITLE: Return Type Issue with Default Values in C++\nDESCRIPTION: Example demonstrating a potential issue with the value() method's return type being determined by the default value type. Shows how integer overflow can occur when using the wrong default value type.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/default_value.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/value__return_type.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Execution\nDESCRIPTION: Adds a test configuration that runs the compatibility test executable with specified doctest filters.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/diag/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(\n    NAME test-abi_compat_diag\n    COMMAND abi_compat_diag ${DOCTEST_TEST_FILTER})\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default number_unsigned_t Type in C++\nDESCRIPTION: This example shows that number_unsigned_t is by default a typedef to std::uint64_t in the nlohmann::json library. It demonstrates creating and outputting unsigned integer JSON values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/number_unsigned_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/number_unsigned_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Positions Usage Example - C++\nDESCRIPTION: Example code demonstrating the usage of diagnostic positions functionality, referenced from examples/diagnostic_positions.cpp. Shows how to track and display start/end positions of JSON elements.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end_pos.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostic_positions.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Declaration of is_discarded Method in C++\nDESCRIPTION: Function declaration for the is_discarded method that checks if a JSON value has been discarded during parsing.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_discarded.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_discarded() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Output of NLOHMANN_JSON_NAMESPACE Example in JSON\nDESCRIPTION: This snippet shows the expected output of the NLOHMANN_JSON_NAMESPACE example. It demonstrates the result of using the macro in the code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/nlohmann_json_namespace.output\"\n```\n\n----------------------------------------\n\nTITLE: Creating Null JSON Values (C++)\nDESCRIPTION: Shows how to create null JSON values using nullptr constructor overload.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/basic_json.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/basic_json__nullptr_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Default Exception Macro Definitions\nDESCRIPTION: The default implementations of the exception control macros that map to standard C++ exception keywords when exceptions are enabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_throw_user.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_CATCH_USER(exception) catch(exception)\n#define JSON_THROW_USER(exception) throw exception\n#define JSON_TRY_USER              try\n```\n\n----------------------------------------\n\nTITLE: Defining string_t Type Alias in json_pointer Class in C++\nDESCRIPTION: Defines string_t as an alias for RefStringType in the json_pointer class. This type is used for the reference tokens that make up the JSON pointer, similar to basic_json::string_t.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/string_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing string_t = RefStringType;\n```\n\n----------------------------------------\n\nTITLE: Using pkg-config with nlohmann_json in shell\nDESCRIPTION: This command uses pkg-config to generate the proper include flags for the nlohmann_json library when using Makefiles. The flags will point to the installation location of the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/pkg-config.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npkg-config nlohmann_json --cflags\n```\n\n----------------------------------------\n\nTITLE: Multiple Copy Insertion Example\nDESCRIPTION: Example showing how to insert multiple copies of an element into a JSON array\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/insert.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/insert__count.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: Complete CMake configuration for a JSON example project. It sets the minimum CMake version, defines the project, includes the CPM package manager, adds the nlohmann/json library as a dependency, and creates an executable target linked with the JSON library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cpm/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\ninclude(${CMAKE_SOURCE_DIR}/cmake/CPM.cmake)\n\nCPMAddPackage(\"gh:nlohmann/json@3.12.0\")\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Downloading Hunter Gate dependencies\nDESCRIPTION: Commands to create the necessary directory structure and download HunterGate.cmake for Hunter integration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nmkdir cmake\nwget https://raw.githubusercontent.com/cpp-pm/gate/master/cmake/HunterGate.cmake -O cmake/HunterGate.cmake\n```\n\n----------------------------------------\n\nTITLE: Undefining JSON_NOEXCEPTION Macro in C++\nDESCRIPTION: This snippet demonstrates the default state of the JSON_NOEXCEPTION macro, which is undefined. This allows exceptions to be used normally in the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_noexception.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#undef JSON_NOEXCEPTION\n```\n\n----------------------------------------\n\nTITLE: Demonstrating boolean_t Usage in C++\nDESCRIPTION: Example code showing that boolean_t is by default a typedef to bool. This snippet is referenced in the documentation but not directly provided in the input.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/boolean_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/boolean_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Pointers to Strings in C++\nDESCRIPTION: Demonstrates the use of to_string() method instead of implicit conversion for JSON pointers to strings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json::json_pointer ptr(\"/foo/bar/1\");\nstd::string s = ptr.to_string();\n```\n\n----------------------------------------\n\nTITLE: Flexible nlohmann/json Integration with CMake\nDESCRIPTION: CMake configuration to support both external and embedded nlohmann/json library integration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_36\n\nLANGUAGE: cmake\nCODE:\n```\n# Top level CMakeLists.txt\nproject(FOO)\n...\noption(FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF)\n...\nadd_subdirectory(thirdparty)\n...\nadd_library(foo ...)\n...\n# Note that the namespaced target will always be available regardless of the\n# import method\ntarget_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)\n```\n\nLANGUAGE: cmake\nCODE:\n```\n# thirdparty/CMakeLists.txt\n...\nif(FOO_USE_EXTERNAL_JSON)\n  find_package(nlohmann_json 3.12.0 REQUIRED)\nelse()\n  set(JSON_BuildTests OFF CACHE INTERNAL \"\")\n  add_subdirectory(nlohmann_json)\nendif()\n...\n```\n\n----------------------------------------\n\nTITLE: Defining SAX Event Handler Method for Floating-Point Numbers in C++\nDESCRIPTION: The signature for the SAX interface method that handles floating-point number values encountered during JSON parsing. It receives the parsed floating-point value and its original string representation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/number_float.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool number_float(number_float_t val, const string_t& s) = 0;\n```\n\n----------------------------------------\n\nTITLE: Defining Uninstrumented Test List in CMake\nDESCRIPTION: Creates a list of uninstrumented test targets to be built. Currently, it only includes one test named 'UninstrumentedTest'.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/uninstrumented/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(UninstrumentedTests\n  UninstrumentedTest\n  )\n```\n\n----------------------------------------\n\nTITLE: Operator+= Overload Declarations in C++\nDESCRIPTION: Declares three overloads of operator+= for handling array append operations, object insertions, and initializer list handling. The first overload handles basic_json values, the second handles object value types, and the third handles initializer lists.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator+=.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nreference operator+=(basic_json&& val);\nreference operator+=(const basic_json& val);\n\n// (2)\nreference operator+=(const typename object_t::value_type& val);\n\n// (3)\nreference operator+=(initializer_list_t init);\n```\n\n----------------------------------------\n\nTITLE: Example Usage of JSON SAX Interface\nDESCRIPTION: Example code showing how to use the SAX interface, including the number_unsigned method. This example demonstrates the practical implementation of SAX event handlers for JSON parsing.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/number_unsigned.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of JSON_HAS_RANGES in C++\nDESCRIPTION: This example demonstrates how to force the library to enable support for ranges by defining the JSON_HAS_RANGES macro before including the nlohmann/json header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_ranges.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_RANGES 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_NO_IO Macro in C++\nDESCRIPTION: Example of how to define the JSON_NO_IO macro to disable I/O functionality in the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_no_io.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_NO_IO\n```\n\n----------------------------------------\n\nTITLE: Comparing JSON Pointers in C++\nDESCRIPTION: Illustrates the correct way to compare JSON pointers with strings by converting strings to json_pointer objects first.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json::json_pointer lhs(\"/foo/bar/1\");\nassert(lhs == nlohmann::json::json_pointer(\"/foo/bar/1\"));\n```\n\n----------------------------------------\n\nTITLE: Exception Macro Definitions When Exceptions Are Disabled\nDESCRIPTION: Alternative implementations of the exception control macros used when exceptions are switched off. Try blocks execute unconditionally, throws abort the process, and catch blocks are skipped.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_throw_user.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_THROW_USER(exception) std::abort()\n#define JSON_TRY_USER              if (true)\n#define JSON_CATCH_USER(exception) if (false)\n```\n\n----------------------------------------\n\nTITLE: Binary Format Support Comparison Table\nDESCRIPTION: Markdown table showing serialization and deserialization completeness for different binary formats supported by the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/index.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Format      | Serialization                                 | Deserialization                              |\n|-------------|-----------------------------------------------|----------------------------------------------|\n| BJData      | complete                                      | complete                                     |\n| BSON        | incomplete: top-level value must be an object | incomplete, but all JSON types are supported |\n| CBOR        | complete                                      | incomplete, but all JSON types are supported |\n| MessagePack | complete                                      | complete                                     |\n| UBJSON      | complete                                      | complete                                     |\n```\n\n----------------------------------------\n\nTITLE: Default Definition of JSON_DIAGNOSTIC_POSITIONS in C++\nDESCRIPTION: Shows the default definition of the JSON_DIAGNOSTIC_POSITIONS macro, which is set to 0 (disabled) when not explicitly defined by the user.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostic_positions.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DIAGNOSTIC_POSITIONS 0\n```\n\n----------------------------------------\n\nTITLE: Building with CMake using Hunter-integrated nlohmann_json\nDESCRIPTION: Commands to build a project with CMake using the nlohmann_json package integrated via Hunter.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S . -B build\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Building and running project with xmake\nDESCRIPTION: Commands to build and run a project using xmake build system.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_36\n\nLANGUAGE: shell\nCODE:\n```\nxmake\nxmake run\n```\n\n----------------------------------------\n\nTITLE: Example Output of Hash Calculations with JSON Values\nDESCRIPTION: Sample output showing the hash values generated for different JSON values. The output is platform-dependent and demonstrates the unique hash values generated for different JSON types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/std_hash.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/std_hash.output\"\n```\n\n----------------------------------------\n\nTITLE: Integer Range Minimum Value\nDESCRIPTION: The minimum integer value that can be stored in the default integer type (INT64_MIN).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n-9223372036854775808\n```\n\n----------------------------------------\n\nTITLE: Exception Class Hierarchy Diagram\nDESCRIPTION: Mermaid class diagram showing the inheritance hierarchy of JSON library exceptions, including type_error and its relationship to other exception classes.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type_error.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n  \n    class std_exception [\"std::exception\"] {\n        <<interface>>\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n    \n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception <|-- json_exception\n    json_exception <|-- json_parse_error\n    json_exception <|-- json_invalid_iterator\n    json_exception <|-- json_type_error\n    json_exception <|-- json_out_of_range\n    json_exception <|-- json_other_error\n\n    style json_type_error fill:#CCCCFF\n```\n\n----------------------------------------\n\nTITLE: Default JSON_ASSERT Implementation\nDESCRIPTION: Default implementation of JSON_ASSERT that maps to the standard assert macro. Can be disabled by defining NDEBUG.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_assert.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_ASSERT(x) assert(x)\n```\n\n----------------------------------------\n\nTITLE: Reporting a Vulnerability for nlohmann/json Project\nDESCRIPTION: Instructions for reporting a security vulnerability in the nlohmann/json project. It specifies the email address to use and the expected response time.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/community/security_policy.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Reporting a Vulnerability\n\nTo report a security vulnerability, please use the [GitHub Security Advisory](https://github.com/nlohmann/json/security/advisories/new) feature.\n\nAlternatively, you can send an email to `mail@nlohmann.me`. You can expect an initial response within 48 hours.\n```\n\n----------------------------------------\n\nTITLE: Example Usage of JSON_NO_IO in C++\nDESCRIPTION: Complete example showing how to define JSON_NO_IO before including the nlohmann/json library to prevent the use of I/O-related headers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_no_io.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_NO_IO 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_USE_IMPLICIT_CONVERSIONS Macro in C++\nDESCRIPTION: Defines the JSON_USE_IMPLICIT_CONVERSIONS macro which controls whether implicit conversions are enabled or disabled in the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_implicit_conversions.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_IMPLICIT_CONVERSIONS /* value */\n```\n\n----------------------------------------\n\nTITLE: Default Definition of NLOHMANN_JSON_NAMESPACE_END in C++\nDESCRIPTION: The default definition of NLOHMANN_JSON_NAMESPACE_END closes both the inline versioned namespace and the main nlohmann namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_begin.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n}  // namespace json_abi_v3_11_2\n}  // namespace nlohmann\n```\n\n----------------------------------------\n\nTITLE: Disabling I/O Dependencies with JSON_NO_IO Macro in C++\nDESCRIPTION: This macro excludes certain I/O-related headers and functions, useful for environments where these operations are restricted for security reasons.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nJSON_NO_IO\n```\n\n----------------------------------------\n\nTITLE: Accessing Library Version with NLOHMANN_JSON_VERSION Macros in C++\nDESCRIPTION: These macros provide access to the major, minor, and patch version numbers of the library, following Semantic Versioning 2.0.0.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nNLOHMANN_JSON_VERSION_MAJOR\nNLOHMANN_JSON_VERSION_MINOR\nNLOHMANN_JSON_VERSION_PATCH\n```\n\n----------------------------------------\n\nTITLE: Visualizing Exception Hierarchy with Mermaid\nDESCRIPTION: A class diagram showing the hierarchy of exception classes in the nlohmann::json library, including the invalid_iterator class highlighted in light blue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/invalid_iterator.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n  \n    class std_exception [\"std::exception\"] {\n        <<interface>>\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n    \n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception <|-- json_exception\n    json_exception <|-- json_parse_error\n    json_exception <|-- json_invalid_iterator\n    json_exception <|-- json_type_error\n    json_exception <|-- json_out_of_range\n    json_exception <|-- json_other_error\n\n    style json_invalid_iterator fill:#CCCCFF\n```\n\n----------------------------------------\n\nTITLE: Rendering GitHub Footer Links in HTML\nDESCRIPTION: This snippet contains HTML markup for rendering footer links on GitHub pages, including terms, privacy, security, status, and help pages.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_9\n\nLANGUAGE: HTML\nCODE:\n```\n<li><a href=\"https://github.com/site/terms\" data-ga-click=\"Footer, go to terms, text:terms\">Terms</a></li>\n<li><a href=\"https://github.com/site/privacy\" data-ga-click=\"Footer, go to privacy, text:privacy\">Privacy</a></li>\n<li><a href=\"https://github.com/security\" data-ga-click=\"Footer, go to security, text:security\">Security</a></li>\n<li><a href=\"https://status.github.com/\" data-ga-click=\"Footer, go to status, text:status\">Status</a></li>\n<li><a href=\"https://help.github.com\" data-ga-click=\"Footer, go to help, text:help\">Help</a></li>\n```\n\n----------------------------------------\n\nTITLE: Constructors for byte_container_with_subtype in nlohmann::json C++ library\nDESCRIPTION: These constructors create binary containers with optional subtypes in the nlohmann::json library. They provide three variants: an empty constructor, constructors that accept a container without a subtype, and constructors that accept both a container and a subtype. The container parameter represents the binary data, while the subtype parameter specifies the binary format or protocol.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/byte_container_with_subtype.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// (1)\nbyte_container_with_subtype();\n\n// (2)\nbyte_container_with_subtype(const container_type& container);\nbyte_container_with_subtype(container_type&& container);\n\n// (3)\nbyte_container_with_subtype(const container_type& container, subtype_type subtype);\nbyte_container_with_subtype(container_type&& container, subtype_type subtype);\n```\n\n----------------------------------------\n\nTITLE: Using Namespace for JSON Literals in C++\nDESCRIPTION: Shows how to properly use the nlohmann::literals namespace for JSON user-defined literals.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nusing namespace nlohmann::literals;\nnlohmann::json j = \"[1,2,3]\"_json;\n```\n\n----------------------------------------\n\nTITLE: Output of cbegin() Usage Example in JSON\nDESCRIPTION: This snippet shows the expected JSON output from the cbegin() usage example. It demonstrates the structure and content of the JSON object after iteration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cbegin.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/cbegin.output\"\n```\n\n----------------------------------------\n\nTITLE: JSON Output from SAX Parsing Example\nDESCRIPTION: This snippet shows the expected JSON output from the SAX parsing example. It represents the parsed data structure.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/boolean.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_NOEXCEPTION Macro in C++\nDESCRIPTION: This snippet shows how to define the JSON_NOEXCEPTION macro to disable exceptions in the nlohmann/json library. When defined, try/catch blocks are replaced with if statements, and throw is replaced with std::abort().\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_noexception.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_NOEXCEPTION\n```\n\n----------------------------------------\n\nTITLE: CMakeLists.txt Configuration for Hunter\nDESCRIPTION: A CMake configuration file for a project using nlohmann_json installed via Hunter.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\n--8<-- \"integration/hunter/CMakeLists.txt\"\n```\n\n----------------------------------------\n\nTITLE: Implementing end_pos Method - C++\nDESCRIPTION: Method declaration for end_pos() which returns the position after the last character of a JSON value in the parsed string. Only available when JSON_DIAGNOSTIC_POSITIONS is defined.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end_pos.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#if JSON_DIAGNOSTIC_POSITIONS\nconstexpr std::size_t end_pos() const noexcept;\n#endif\n```\n\n----------------------------------------\n\nTITLE: Parsing Large Floating-Point Number in JavaScript\nDESCRIPTION: This snippet shows a JavaScript array containing a large floating-point number (1.7976931348623157e308) that the Nlohmann JSON library fails to roundtrip correctly.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n[1.7976931348623157e308]\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_HAS_THREE_WAY_COMPARISON Macro in C++\nDESCRIPTION: The macro definition for JSON_HAS_THREE_WAY_COMPARISON which can be set to 1 or 0 to indicate whether 3-way comparison is supported. When not defined, the library automatically detects support based on __cpp_impl_three_way_comparison and __cpp_lib_three_way_comparison preprocessor macros.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_three_way_comparison.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_THREE_WAY_COMPARISON /* value */\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Stream Constructor to Parse Function\nDESCRIPTION: Shows how to update deprecated stream constructor code to use the new parse function with callback support.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\njson j(ss, cb);\n```\n\n----------------------------------------\n\nTITLE: Enabling Legacy Discarded Value Comparison Example\nDESCRIPTION: Example code showing how to enable the legacy discarded value comparison behavior by defining the macro with value 1 before including the nlohmann/json header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_legacy_discarded_value_comparison.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Example Output from error_handler_t Usage\nDESCRIPTION: JSON output demonstrating the results of using different error_handler_t options when handling invalid UTF-8 sequences during serialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/error_handler_t.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/error_handler_t.output\"\n```\n\n----------------------------------------\n\nTITLE: Default Definition of JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON\nDESCRIPTION: Shows the default definition of the JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON macro, which is set to 0 (disabled) by default. When the macro is not defined, the library will define it to this value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_legacy_discarded_value_comparison.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0\n```\n\n----------------------------------------\n\nTITLE: Skipping Unsupported Compiler Check with JSON_SKIP_UNSUPPORTED_COMPILER_CHECK Macro in C++\nDESCRIPTION: This macro allows using the library with compilers that don't fully support C++11, bypassing the usual compile error for unsupported compilers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nJSON_SKIP_UNSUPPORTED_COMPILER_CHECK\n```\n\n----------------------------------------\n\nTITLE: Output of JSON to BSON Serialization in C\nDESCRIPTION: This snippet shows the hexadecimal output of the BSON serialization process. It represents the binary format of the serialized JSON object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bson.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n--8<-- \"examples/to_bson.output\"\n```\n\n----------------------------------------\n\nTITLE: Virtual Key Method Declaration in json_sax Interface\nDESCRIPTION: Virtual method declaration for handling object key parsing in the SAX interface. Takes a string_t reference parameter for the key value and returns a boolean indicating whether parsing should continue. The key value can be safely moved.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/key.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool key(string_t& val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Pointer with String Type in C++\nDESCRIPTION: Shows how to directly provide the string type when defining a json_pointer, replacing the deprecated method of passing a basic_json specialization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nnlohmann::json_pointer<my_string_type> ptr(\"/foo/bar/1\");\n```\n\n----------------------------------------\n\nTITLE: JSON SAX Parser Output Example\nDESCRIPTION: Example output from the SAX parser implementation, showing the results of processing JSON through the SAX interface.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/number_unsigned.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Example JSON Structure\nDESCRIPTION: Sample JSON structure used to demonstrate parser callback events.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parser_callbacks.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Berlin\",\n    \"location\": [\n        52.519444,\n        13.406667\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying C++ Version Compatibility with JSON_HAS_CPP_XX Macros in C++\nDESCRIPTION: These macros override the internal C++ version checks, allowing users to specify C++ standard compatibility for compilers with partial standard implementations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nJSON_HAS_CPP_11\nJSON_HAS_CPP_14\nJSON_HAS_CPP_17\nJSON_HAS_CPP_20\n```\n\n----------------------------------------\n\nTITLE: Adding nlohmann_json dependency with Hunter in CMake\nDESCRIPTION: CMake command to add the nlohmann_json package as a dependency using Hunter package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nhunter_add_package(nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Positions Example Output\nDESCRIPTION: Example output showing the start and end positions of JSON elements in the parsed string\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/end_pos.md#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n--8<-- \"examples/diagnostic_positions.output\"\n```\n\n----------------------------------------\n\nTITLE: Maximum Floating-Point Value\nDESCRIPTION: The maximum floating-point value that can be stored before being converted to NaN.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n1.79769313486232e+308\n```\n\n----------------------------------------\n\nTITLE: Declaring is_structured Method in C++\nDESCRIPTION: Method signature for the is_structured() function in the nlohmann::basic_json class. It is a const member function that returns a boolean and never throws exceptions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_structured.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool is_structured() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Explicit Equivalent of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE in C++\nDESCRIPTION: The explicit implementation equivalent to what the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE macro generates, showing that only the to_json function is implemented.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_only_serialize_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Explicit Equivalent of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE in C++\nDESCRIPTION: The explicit implementation equivalent to what the NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE macro generates. This shows the actual to_json and from_json function implementations created when using the macro.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_non_intrusive.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_non_intrusive_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: This CMake script sets up a C++ project that uses the nlohmann/json library. It specifies the minimum CMake version of 3.15, creates a project named 'json_example', finds the nlohmann_json package, creates an executable from example.cpp, and links the JSON library to the executable.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/cget/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Default Definition of JSON_USE_IMPLICIT_CONVERSIONS in C++\nDESCRIPTION: Shows the default value of the JSON_USE_IMPLICIT_CONVERSIONS macro in the nlohmann/json library, which enables implicit conversions by default.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_implicit_conversions.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_IMPLICIT_CONVERSIONS 1\n```\n\n----------------------------------------\n\nTITLE: Optimized UBJSON Binary Output Format\nDESCRIPTION: Displays the hexadecimal representation of the optimized UBJSON-encoded binary data, showing type and size markers for optimization.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\n0x7B                                // '{'\n    0x24                            // '$' type of the object elements\n    0x5B                            // '[' array\n    0x23 0x69 0x01                  // '#' i 1 number of object elements\n    0x69 0x06                       // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79   // \"binary\"\n        0x24 0x55                   // '$' 'U' type of the array elements: unsigned integers\n        0x23 0x69 0x04              // '#' i 4 number of array elements\n        0xCA 0xFE 0xBA 0xBE         // content\n```\n\n----------------------------------------\n\nTITLE: Running the Natvis Generation Script for nlohmann/json library\nDESCRIPTION: Command line usage example for the generate_natvis.py script. It takes a version parameter (X.Y.Z format) and an output directory path where the generated Natvis files will be saved.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/generate_natvis/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./generate_natvis.py --version X.Y.Z output_directory/\n```\n\n----------------------------------------\n\nTITLE: Triggering an Assertion with Operations on Uninitialized Iterator in C++\nDESCRIPTION: Demonstrates how performing operations on an uninitialized JSON iterator causes undefined behavior and triggers a runtime assertion. This example shows why iterators must be properly initialized before use.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/assertions.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n  json::iterator it;\n  ++it;\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Output from SAX Parsing\nDESCRIPTION: Example JSON output produced by the SAX parsing process, showing the result of using the custom SAX event handler.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/start_array.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Class Diagram for JSON Exception Hierarchy\nDESCRIPTION: Mermaid diagram showing the inheritance hierarchy of exception classes in the nlohmann JSON library, with out_of_range highlighted as one of the specialized exception types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/out_of_range.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n  \n    class std_exception [\"std::exception\"] {\n        <<interface>>\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n    \n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception <|-- json_exception\n    json_exception <|-- json_parse_error\n    json_exception <|-- json_invalid_iterator\n    json_exception <|-- json_type_error\n    json_exception <|-- json_out_of_range\n    json_exception <|-- json_other_error\n\n    style json_out_of_range fill:#CCCCFF\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_HAS_RANGES Macro in C++\nDESCRIPTION: The JSON_HAS_RANGES macro indicates whether the standard library has support for ranges. It can be set to 1 (supported) or 0 (unsupported) and implies support for concepts.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_ranges.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_RANGES /* value */\n```\n\n----------------------------------------\n\nTITLE: Configuring Conan Requirements and Generators for nlohmann/json\nDESCRIPTION: Defines the required version of nlohmann_json package and specifies CMake-related generators for build system integration. Uses version 3.12.0 of the library and configures CMakeToolchain and CMakeDeps generators.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/conan/Conanfile.txt#2025-04-21_snippet_0\n\nLANGUAGE: conan\nCODE:\n```\n[requires]\nnlohmann_json/3.12.0\n\n[generators]\nCMakeToolchain\nCMakeDeps\n```\n\n----------------------------------------\n\nTITLE: Defining NLOHMANN_JSON_NAMESPACE_NO_VERSION Macro in C++\nDESCRIPTION: This snippet shows how to define the NLOHMANN_JSON_NAMESPACE_NO_VERSION macro, which when set to 1, omits the version component from the inline namespace in the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_no_version.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_NAMESPACE_NO_VERSION /* value */\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Allocator in nlohmann::basic_json (C++)\nDESCRIPTION: Static method that returns the allocator associated with the JSON container. This function can be used to retrieve the allocator for creating new JSON values with the same allocation strategy.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/get_allocator.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic allocator_type get_allocator();\n```\n\n----------------------------------------\n\nTITLE: JSON Patch Output Result (JSON)\nDESCRIPTION: Shows the output of applying a JSON Patch operation to a JSON document, displaying the resulting transformed document.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/json_patch.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/patch.output\"\n```\n\n----------------------------------------\n\nTITLE: Multiple Conversions Example for NLOHMANN_JSON_SERIALIZE_ENUM in C++\nDESCRIPTION: Example showing how to define multiple conversion options for a single enum value, allowing different strings to deserialize to the same enum value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_serialize_enum.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_json_serialize_enum_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using NLOHMANN_JSON_SERIALIZE_ENUM Macro with Disabled Enum Serialization in C++\nDESCRIPTION: Shows how to use the NLOHMANN_JSON_SERIALIZE_ENUM macro to provide custom serialization and deserialization for enums when default serialization is disabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_disable_enum_serialization.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM(Choice,\n{\n    { Choice::first, \"first\" },\n    { Choice::second, \"second\" },\n})\n\nint main()\n{\n    // uses user-defined to_json function defined by macro\n    const json j = Choice::first; \n\n    // uses user-defined from_json function defined by macro\n    Choice ch = j.template get<Choice>();\n}\n```\n\n----------------------------------------\n\nTITLE: BJData Serialization Output Example\nDESCRIPTION: Output generated from the BJData serialization example showing the binary format representation\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bjdata.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n--8<-- \"examples/to_bjdata.output\"\n```\n\n----------------------------------------\n\nTITLE: Default Definition of JSON_DISABLE_ENUM_SERIALIZATION in C++\nDESCRIPTION: Shows the default value of the JSON_DISABLE_ENUM_SERIALIZATION macro, which is 0. This means enum serialization is enabled by default.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_disable_enum_serialization.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DISABLE_ENUM_SERIALIZATION 0\n```\n\n----------------------------------------\n\nTITLE: Setting Up JSON Benchmarks Project with CMake\nDESCRIPTION: This CMake script configures a benchmarking environment for the nlohmann/json library. It sets compiler optimization flags, fetches Google Benchmark from GitHub, downloads test data, and configures the benchmark executable with appropriate dependencies and include paths.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/benchmarks/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.11...3.14)\nproject(JSON_Benchmarks LANGUAGES CXX)\n\n# set compiler flags\nif((CMAKE_CXX_COMPILER_ID MATCHES GNU) OR (CMAKE_CXX_COMPILER_ID MATCHES Clang))\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -flto -DNDEBUG -O3\")\nendif()\n\n# configure Google Benchmarks\ninclude(FetchContent)\nFetchContent_Declare(\n    benchmark\n    GIT_REPOSITORY https://github.com/google/benchmark.git\n    GIT_TAG origin/main\n    GIT_SHALLOW TRUE\n)\n\nFetchContent_GetProperties(benchmark)\nif(NOT benchmark_POPULATED)\n    FetchContent_Populate(benchmark)\n    set(BENCHMARK_ENABLE_TESTING OFF CACHE INTERNAL \"\" FORCE)\n    add_subdirectory(${benchmark_SOURCE_DIR} ${benchmark_BINARY_DIR})\nendif()\n\n# download test data\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../../cmake ${CMAKE_MODULE_PATH})\ninclude(download_test_data)\n\n# benchmark binary\nadd_executable(json_benchmarks src/benchmarks.cpp)\ntarget_compile_features(json_benchmarks PRIVATE cxx_std_11)\ntarget_link_libraries(json_benchmarks benchmark ${CMAKE_THREAD_LIBS_INIT})\nadd_dependencies(json_benchmarks download_test_data)\ntarget_include_directories(json_benchmarks PRIVATE ${CMAKE_SOURCE_DIR}/../../single_include ${CMAKE_BINARY_DIR}/include)\n```\n\n----------------------------------------\n\nTITLE: Catching other_error Exception in C++\nDESCRIPTION: Example of how to catch an other_error exception in C++. The actual code is not provided in the snippet, but referenced to an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/other_error.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/other_error.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Example Usage of error_handler_t in C++\nDESCRIPTION: Referenced example code showing how different error_handler_t values affect the dump function's behavior when serializing invalid UTF-8 sequences. The example is included by reference to an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/error_handler_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/error_handler_t.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Exception Class Hierarchy Diagram - Mermaid\nDESCRIPTION: Class diagram showing the inheritance hierarchy of JSON library exceptions, starting from std::exception through basic_json::exception to specific exception types like parse_error, invalid_iterator, etc.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/exception.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n  direction LR\n  \n    class std_exception [\"std::exception\"] {\n        <<interface>>\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n    \n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception <|-- json_exception\n    json_exception <|-- json_parse_error\n    json_exception <|-- json_invalid_iterator\n    json_exception <|-- json_type_error\n    json_exception <|-- json_out_of_range\n    json_exception <|-- json_other_error\n\n    style json_exception fill:#CCCCFF\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Standards for Testing\nDESCRIPTION: Sets up the C++ standards to test against (11, 14, 17, 20, 23 by default), allowing override through JSON_TestStandards variable. Formats and displays available standards for the current compiler.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n#############################################################################\n# add unit tests\n#############################################################################\n\nif(\"${JSON_TestStandards}\" STREQUAL \"\")\n    set(test_cxx_standards 11 14 17 20 23)\n    unset(test_force)\nelse()\n    set(test_cxx_standards ${JSON_TestStandards})\n    set(test_force FORCE)\nendif()\n\n# Print selected standards marking unavailable ones with brackets\nset(msg_standards \"\")\nforeach(cxx_standard ${test_cxx_standards})\n    if(compiler_supports_cpp_${cxx_standard})\n        list(APPEND msg_standards ${cxx_standard})\n    else()\n        list(APPEND msg_standards [${cxx_standard}])\n    endif()\nendforeach()\nstring(JOIN \" \" msg_standards ${msg_standards})\nset(msg \"Testing standards: ${msg_standards}\")\nif(test_force)\n    string(APPEND msg \" (forced)\")\nendif()\nmessage(STATUS \"${msg}\")\n```\n\n----------------------------------------\n\nTITLE: Executing Unit Tests with CMake\nDESCRIPTION: Commands to build and run the test suite using CMake. Requires CMake and a C++ compiler. Downloads test data from external repository unless specified otherwise via JSON_TestDataDirectory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_38\n\nLANGUAGE: shell\nCODE:\n```\nmkdir build\ncd build\ncmake .. -DJSON_BuildTests=On\ncmake --build .\nctest --output-on-failure\n```\n\n----------------------------------------\n\nTITLE: Setting up nlohmann/json with CMake\nDESCRIPTION: Configures a CMake project that uses nlohmann_json library version 3.2.0 or higher. Creates an executable 'with_namespace_target' from main.cpp and links it with the nlohmann_json library using modern CMake target-based approach.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import_minver/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5...3.14)\n\nproject(DummyImportMinVer CXX)\n\nfind_package(nlohmann_json 3.2.0 REQUIRED)\n\nadd_executable(with_namespace_target main.cpp)\ntarget_link_libraries(with_namespace_target nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Forcing Experimental Filesystem Usage Example\nDESCRIPTION: Example showing how to force the library to use experimental filesystem header by defining JSON_HAS_EXPERIMENTAL_FILESYSTEM before including the library header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_filesystem.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Header Selection and Feature Settings for nlohmann_json\nDESCRIPTION: Sets build configurations based on user preferences, including multi-header vs single-header mode, implicit conversions, diagnostics, and other library features. Outputs status messages for enabled/disabled features.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif (JSON_MultipleHeaders)\n    set(NLOHMANN_JSON_INCLUDE_BUILD_DIR \"${PROJECT_SOURCE_DIR}/include/\")\n    message(STATUS \"Using the multi-header code from ${NLOHMANN_JSON_INCLUDE_BUILD_DIR}\")\nelse()\n    set(NLOHMANN_JSON_INCLUDE_BUILD_DIR \"${PROJECT_SOURCE_DIR}/single_include/\")\n    message(STATUS \"Using the single-header code from ${NLOHMANN_JSON_INCLUDE_BUILD_DIR}\")\nendif()\n\nif (NOT JSON_ImplicitConversions)\n    message(STATUS \"Implicit conversions are disabled (JSON_USE_IMPLICIT_CONVERSIONS=0)\")\nendif()\n\nif (JSON_DisableEnumSerialization)\n    message(STATUS \"Enum integer serialization is disabled (JSON_DISABLE_ENUM_SERIALIZATION=0)\")\nendif()\n\nif (JSON_LegacyDiscardedValueComparison)\n    message(STATUS \"Legacy discarded value comparison enabled (JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1)\")\nendif()\n\nif (JSON_Diagnostics)\n    message(STATUS \"Diagnostics enabled (JSON_DIAGNOSTICS=1)\")\nendif()\n\nif (JSON_Diagnostic_Positions)\n    message(STATUS \"Diagnostic positions enabled (JSON_DIAGNOSTIC_POSITIONS=1)\")\nendif()\n\nif (NOT JSON_GlobalUDLs)\n    message(STATUS \"User-defined string literals are not put in the global namespace (JSON_USE_GLOBAL_UDLS=0)\")\nendif()\n\nif (JSON_SystemInclude)\n    set(NLOHMANN_JSON_SYSTEM_INCLUDE \"SYSTEM\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Library Version Macros in C++\nDESCRIPTION: These macros define the major, minor, and patch version numbers of the nlohmann/json library according to Semantic Versioning 2.0.0 specifications. They can be used to check compatibility or display version information.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_version_major.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_VERSION_MAJOR /* value */\n#define NLOHMANN_JSON_VERSION_MINOR /* value */\n#define NLOHMANN_JSON_VERSION_PATCH /* value */\n```\n\n----------------------------------------\n\nTITLE: Explicit Implementation Equivalent to NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT\nDESCRIPTION: Shows the equivalent code that the NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT macro generates, including the creation of a default object to provide fallback values for missing JSON keys.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_define_type_intrusive.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/nlohmann_define_type_intrusive_with_default_explicit.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Generating Local Documentation for nlohmann/json Library in Shell\nDESCRIPTION: This shell script demonstrates how to clone the nlohmann/json repository, checkout a specific version (v3.10.2 in this example), and build the documentation using mkdocs. After running these commands, the documentation will be accessible at http://127.0.0.1:8000.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/nlohmann/json.git\ncd json\ngit checkout v3.10.2\nmake install_venv serve -C docs/mkdocs\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_USE_GLOBAL_UDLS Macro\nDESCRIPTION: Basic macro definition that controls whether UDLs are placed in global namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_global_udls.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_GLOBAL_UDLS /* value */\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: Sets up a CMake project that uses the nlohmann/json library. Configures minimum CMake version, creates a project, finds the required package, and sets up an executable with proper library linking.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/homebrew/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Example of Incorrectly Implemented Serializer in C++\nDESCRIPTION: This code snippet shows an example of a badly implemented serializer that can cause stack overflow. It demonstrates the potential pitfalls when reimplementing serializers without proper care.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/arbitrary_types.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename T, void>\nstruct bad_serializer\n{\n    template <typename BasicJsonType>\n    static void to_json(BasicJsonType& j, const T& value) {\n      // this calls BasicJsonType::json_serializer<T>::to_json(j, value);\n      // if BasicJsonType::json_serializer == bad_serializer ... oops!\n      j = value;\n    }\n\n    template <typename BasicJsonType>\n    static void from_json(const BasicJsonType& j, T& value) {\n      // this calls BasicJsonType::json_serializer<T>::from_json(j, value);\n      // if BasicJsonType::json_serializer == bad_serializer ... oops!\n      value = j.template template get<T>(); // oops!\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Output from cend() Example\nDESCRIPTION: The resulting JSON output from executing the cend() example code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/cend.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/cend.output\"\n```\n\n----------------------------------------\n\nTITLE: Output of invalid_iterator Example\nDESCRIPTION: Expected output from running the invalid_iterator example code, showing the error message format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n--8<-- \"examples/invalid_iterator.output\"\n```\n\n----------------------------------------\n\nTITLE: Overriding C++ Standard Support Detection Based on Compiler Versions\nDESCRIPTION: Unsets compiler support flags for various C++ standards based on compiler version checks, as some compilers claim support for standards they don't fully implement.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n#############################################################################\n# override standard support\n#############################################################################\n\n# Clang only supports C++14 starting from Clang 3.5 (lesser versions miss std::enable_if_t)\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 3.5)\n    unset(compiler_supports_cpp_14)\nendif()\n\n# Clang only supports C++17 starting from Clang 5.0\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0)\n    unset(compiler_supports_cpp_17)\nendif()\n# MSVC 2015 (14.0) does not support C++17\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.10)\n    unset(compiler_supports_cpp_17)\nendif()\n# GCC 5 and 6 do claim experimental support for C++17, but do not implement <optional>\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0)\n    unset(compiler_supports_cpp_17)\nendif()\n\n# Clang C++20 support appears insufficient prior to Clang 9.0 (based on CI build failure)\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)\n    unset(compiler_supports_cpp_20)\nendif()\n# MSVC 2017 (15.x) does not support C++20\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 19.20)\n    unset(compiler_supports_cpp_20)\nendif()\n# GCC started supporting C++20 features in 8.0 but a test for #3070 segfaults prior to 9.0\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)\n    unset(compiler_supports_cpp_20)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking if a Binary Value Has a Subtype in nlohmann::json (C++)\nDESCRIPTION: The has_subtype() method returns a boolean indicating whether a binary value has an associated subtype. It provides a no-throw guarantee and has constant complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/has_subtype.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr bool has_subtype() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann_json in Conda Environment\nDESCRIPTION: Command to install the nlohmann_json package from the conda-forge channel in the active Conda environment.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\nconda install -c conda-forge nlohmann_json\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Standard JSON Error Diagnostics with Parse Error Example\nDESCRIPTION: This code snippet is referenced but not directly shown in the content. It demonstrates standard JSON diagnostic messages when parsing errors occur, which typically show limited context information.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// Examples of standard diagnostics messages are referenced but the code is not directly shown in the document\n```\n\n----------------------------------------\n\nTITLE: Enabling RTTI Support in nlohmann/json Library in C++\nDESCRIPTION: This example demonstrates how to force the library to enable support for RTTI-dependent libraries. It sets JSON_HAS_STATIC_RTTI to 1 before including the nlohmann/json header.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_static_rtti.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_STATIC_RTTI 1\n#include <nlohmann/json.hpp>\n\n...\n```\n\n----------------------------------------\n\nTITLE: Return Type Issue Output Example\nDESCRIPTION: Output showing the results of the return type issue example, demonstrating the differences between direct access and using value() with different default value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/default_value.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/value__return_type.output\"\n```\n\n----------------------------------------\n\nTITLE: Default ValueType Operator Signature without JSON_EXPLICIT\nDESCRIPTION: The default signature when JSON_EXPLICIT is empty, allowing implicit conversions between JSON values and other types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_ValueType.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ValueType>\noperator ValueType() const;\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_DIAGNOSTIC_POSITIONS Macro in C++\nDESCRIPTION: Defines the JSON_DIAGNOSTIC_POSITIONS macro which enables position diagnostics for JSON objects. When enabled, it adds start_pos() and end_pos() member functions to basic_json values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostic_positions.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DIAGNOSTIC_POSITIONS /* value */\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version and Test Options for Nlohmann JSON\nDESCRIPTION: Defines the minimum required CMake version and configures options for the test suite including Valgrind execution, fast tests, 32-bit testing, and standard selection.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13...3.14)\n\noption(JSON_Valgrind    \"Execute test suite with Valgrind.\" OFF)\noption(JSON_FastTests   \"Skip expensive/slow tests.\" OFF)\n\nset(JSON_32bitTest     AUTO CACHE STRING \"Enable the 32bit unit test (ON/OFF/AUTO/ONLY).\")\nset(JSON_TestStandards \"\" CACHE STRING \"The list of standards to test explicitly.\")\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON Macro\nDESCRIPTION: Defines the JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON macro, which enables the legacy comparison behavior of discarded JSON values when set to 1, or disables it when set to 0 (default).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_legacy_discarded_value_comparison.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON /* value */\n```\n\n----------------------------------------\n\nTITLE: Creating Test Corpus for Fuzz Testing JSON Parsers\nDESCRIPTION: Shell script to download and prepare corpus files for fuzz testing the JSON, BJData, BSON, CBOR, MessagePack, and UBJSON parsers. The script downloads test data, extracts it, and organizes it into format-specific corpus directories.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nTEST_DATA_VERSION=3.1.0\nwget https://github.com/nlohmann/json_test_data/archive/refs/tags/v$TEST_DATA_VERSION.zip\nunzip v$TEST_DATA_VERSION.zip\nrm v$TEST_DATA_VERSION.zip\nfor FORMAT in json bjdata bson cbor msgpack ubjson\ndo\n  rm -fr corpus_$FORMAT\n  mkdir corpus_$FORMAT\n  find json_test_data-$TEST_DATA_VERSION -size -5k -name \"*.$FORMAT\" -exec cp \"{}\" \"corpus_$FORMAT\" \\;\ndone\nrm -fr json_test_data-$TEST_DATA_VERSION\n```\n\n----------------------------------------\n\nTITLE: Output of crend() Example in nlohmann::json\nDESCRIPTION: The JSON output from running the example code for the crend() method. This shows the expected result when using the method correctly.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/crend.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/crend.output\"\n```\n\n----------------------------------------\n\nTITLE: Output of default_object_comparator_t example in JSON\nDESCRIPTION: The JSON output of the default_object_comparator_t example. The actual output is not provided in the snippet, but it's referenced as an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/default_object_comparator_t.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/default_object_comparator_t.output\"\n```\n\n----------------------------------------\n\nTITLE: Unsigned Integer Maximum Value\nDESCRIPTION: The maximum unsigned integer value that can be stored (UINT64_MAX).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n18446744073709551615\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Import Test with Minimum Version\nDESCRIPTION: Sets up a CMake test to verify library import functionality with minimum version requirements. Configures the test environment with specified generator, platform, and compiler settings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import_minver/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_import_minver_configure\n  COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -A \"${CMAKE_GENERATOR_PLATFORM}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_DIR=${PROJECT_BINARY_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of string_t Type\nDESCRIPTION: References an example file 'string_t.cpp' demonstrating that string_t is typically a typedef to std::string, with corresponding JSON output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/string_t.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/string_t.cpp\"\n```\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/string_t.output\"\n```\n\n----------------------------------------\n\nTITLE: Compiling C++ code with nlohmann-json on MacPorts\nDESCRIPTION: Command to compile a C++ file using the nlohmann-json library installed via MacPorts, specifying the include path.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_32\n\nLANGUAGE: shell\nCODE:\n```\nc++ example.cpp -I/opt/local/include -std=c++11 -o example\n```\n\n----------------------------------------\n\nTITLE: JSON SAX Parser Usage Example in C++\nDESCRIPTION: Example showing SAX interface usage with array handling, referenced from examples/sax_parse.cpp\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/end_array.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_HAS_STATIC_RTTI Macro in C++\nDESCRIPTION: This macro defines whether the standard library supports RTTI. It can be set to 1 for support or 0 for no support. By default, it's based on the _HAS_STATIC_RTTI preprocessor macro.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_static_rtti.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_STATIC_RTTI /* value */\n```\n\n----------------------------------------\n\nTITLE: String View Count Example in C++\nDESCRIPTION: Example code referenced as 'count__keytype.c++17.cpp' demonstrating the count() method usage with string_view in C++17.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/count.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/count__keytype.c++17.cpp\"\n```\n\n----------------------------------------\n\nTITLE: CBOR Serialization Output in C\nDESCRIPTION: This code snippet shows the hexadecimal output of the CBOR serialization process. It represents the binary CBOR data generated from the JSON object in the previous example.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/cbor.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n--8<-- \"examples/to_cbor.output\"\n```\n\n----------------------------------------\n\nTITLE: Example 1: Default Behavior\nDESCRIPTION: Example demonstrating default behavior without extended diagnostics using --8<-- directive for code inclusion.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostics.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostics_standard.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Building Static Library with JSON_DIAGNOSTICS Enabled\nDESCRIPTION: Creates a static library compiled with JSON_DIAGNOSTICS=1 and links it with common dependencies.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/diag/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(abi_compat_diag_on STATIC diag_on.cpp)\ntarget_link_libraries(abi_compat_diag_on PUBLIC abi_compat_common)\n```\n\n----------------------------------------\n\nTITLE: Size Comparison Table\nDESCRIPTION: Markdown table showing size efficiency comparison of different formats against various JSON files.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/index.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Format             | canada.json | twitter.json | citm_catalog.json | jeopardy.json |\n|--------------------|-------------|--------------|-------------------|---------------|\n| BJData             | 53.2 %      | 91.1 %       | 78.1 %            | 96.6 %        |\n| BJData (size)      | 58.6 %      | 92.1 %       | 86.7 %            | 97.4 %        |\n| BJData (size+tyoe) | 58.6 %      | 92.1 %       | 86.5 %            | 97.4 %        |\n| BSON               | 85.8 %      | 95.2 %       | 95.8 %            | 106.7 %       |\n| CBOR               | 50.5 %      | 86.3 %       | 68.4 %            | 88.0 %        |\n| MessagePack        | 50.5 %      | 86.0 %       | 68.5 %            | 87.9 %        |\n| UBJSON             | 53.2 %      | 91.3 %       | 78.2 %            | 96.6 %        |\n| UBJSON (size)      | 58.6 %      | 92.3 %       | 86.8 %            | 97.4 %        |\n| UBJSON (size+type) | 55.9 %      | 92.3 %       | 85.0 %            | 95.0 %        |\n```\n\n----------------------------------------\n\nTITLE: Using the GDB Pretty Printer with JSON Values\nDESCRIPTION: Command to use in GDB to pretty-print a JSON variable. The 'pretty' and 'array' options control the formatting of the output.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/gdb_pretty_printer/README.md#2025-04-21_snippet_1\n\nLANGUAGE: GDB\nCODE:\n```\np -pretty on -array on -- var\n```\n\n----------------------------------------\n\nTITLE: Adding Non-Instrumented LibFuzzer Tests in CMake\nDESCRIPTION: Iterates through the NoCoverageTests list and adds each as a LibFuzzer test with the -NoCoverage suffix, sourcing from the parent directory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(Test ${NoCoverageTests})\n  add_libfuzzer_test(${Test}-NoCoverage SOURCES ../${Test}.cpp)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Defining JSON SAX Parse Error Method in C++\nDESCRIPTION: Virtual method declaration for handling JSON parsing errors. The method takes the error position, last token read, and an exception object as parameters and must return false to indicate parsing should not proceed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/parse_error.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool parse_error(std::size_t position,\n                         const std::string& last_token,\n                         const detail::exception& ex) = 0;\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Test Properties for Build\nDESCRIPTION: Configures test properties for the build step, requiring the configuration fixture and marking as not reproducible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import_minver/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset_tests_properties(cmake_import_minver_build PROPERTIES\n  FIXTURES_REQUIRED cmake_import_minver\n  LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Defining number_float_t Type for JSON Floating-Point Numbers in C++\nDESCRIPTION: The code defines the number_float_t type as an alias for NumberFloatType, which by default is double. This type is used to store JSON floating-point numbers within the nlohmann::basic_json class.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/number_float_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing number_float_t = NumberFloatType;\n```\n\n----------------------------------------\n\nTITLE: Building project with CPM.cmake\nDESCRIPTION: Commands to build a CMake project that uses CPM.cmake for dependency management.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_35\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S . -B build\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Example Output Placeholder\nDESCRIPTION: JSON output placeholder from example usage, referenced from external file 'examples/sax_parse.output'\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/key.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Declaring type_name function in C++\nDESCRIPTION: Function signature for the type_name() method in the nlohmann::basic_json class. It returns a const char* representing the type name and is marked as noexcept.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/type_name.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst char* type_name() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Integrating nlohmann/json with CMake (FetchContent)\nDESCRIPTION: CMake configuration to automatically download and integrate nlohmann/json library using FetchContent.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_35\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(FetchContent)\n\nFetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.12.0/json.tar.xz)\nFetchContent_MakeAvailable(json)\n\ntarget_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Overriding Exception Catching with JSON_CATCH_USER Macro in C++\nDESCRIPTION: This macro allows overriding the default catch behavior for exceptions within the library. It can be used to implement custom exception handling.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nJSON_CATCH_USER(exception)\n```\n\n----------------------------------------\n\nTITLE: Loading Spack Environment for nlohmann-json\nDESCRIPTION: Command to load the Spack environment for the installed nlohmann-json package.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nspack load nlohmann-json\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Namespace Test in CMake\nDESCRIPTION: Sets up a test executable for the default namespace configuration in the JSON library. It creates an executable, links it with the compatibility test main library, and adds a test command.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/config/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(abi_config_default default.cpp)\ntarget_link_libraries(abi_config_default PRIVATE abi_compat_main)\nadd_test(\n    NAME test-abi_config_default\n    COMMAND abi_config_default ${DOCTEST_TEST_FILTER})\n```\n\n----------------------------------------\n\nTITLE: Building Static Library with JSON_DIAGNOSTICS Disabled\nDESCRIPTION: Creates a static library compiled with JSON_DIAGNOSTICS=0 and links it with common dependencies.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/diag/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(abi_compat_diag_off STATIC diag_off.cpp)\ntarget_link_libraries(abi_compat_diag_off PUBLIC abi_compat_common)\n```\n\n----------------------------------------\n\nTITLE: Example C++ Code for nlohmann-json with vcpkg\nDESCRIPTION: Sample C++ code demonstrating how to use the nlohmann-json library with vcpkg integration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/vcpkg/example.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Setting Coverage Flags for Fuzzing Tests in CMake\nDESCRIPTION: Configures CMake flags to disable specific coverage instrumentation features for fuzzer tests while maintaining the base LibFuzzer flags.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS\n  \"${LIBFUZZER_FLAGS_BASE} -fno-sanitize-coverage=edge,trace-cmp,indirect-calls,8bit-counters,trace-pc-guard\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Compile and Link Options from Environment Variables\nDESCRIPTION: Uses environment variables to set global compilation and linking options that will affect all targets in the project, including those executing CMake.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# using an env var, since this will also affect targets executing cmake (such as \"ci_test_compiler_default\")\nset(JSON_FORCED_GLOBAL_COMPILE_OPTIONS $ENV{JSON_FORCED_GLOBAL_COMPILE_OPTIONS})\nif (NOT \"\" STREQUAL \"$ENV{JSON_FORCED_GLOBAL_COMPILE_OPTIONS}\")\n    add_compile_options($ENV{JSON_FORCED_GLOBAL_COMPILE_OPTIONS})\nendif()\nif (NOT \"\" STREQUAL \"$ENV{JSON_FORCED_GLOBAL_LINK_OPTIONS}\")\n    add_link_options($ENV{JSON_FORCED_GLOBAL_LINK_OPTIONS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Include Directories Test\nDESCRIPTION: Defines a CMake test that configures the build environment for testing include directory setup. Sets the compiler and source directory paths for the nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_target_include_directories/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_target_include_directories_configure\n  COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_source=${PROJECT_SOURCE_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n)\n```\n\n----------------------------------------\n\nTITLE: Defining default_object_comparator_t in C++\nDESCRIPTION: Defines the default_object_comparator_t type for comparing object keys in nlohmann::json. It uses std::less<StringType> until C++14 and std::less<> since C++14 for transparent comparison.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/default_object_comparator_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing default_object_comparator_t = std::less<StringType>;  // until C++14\n\nusing default_object_comparator_t = std::less<>;            // since C++14\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: Sets up a CMake project that imports the nlohmann/json library using FetchContent. Creates two executable targets demonstrating different ways to link against the library - with and without namespace qualification.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.11...3.14)\n\nproject(DummyImport CXX)\n\ninclude(FetchContent)\n\nget_filename_component(GIT_REPOSITORY_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/../../.. ABSOLUTE)\nFetchContent_Declare(json GIT_REPOSITORY ${GIT_REPOSITORY_DIRECTORY} GIT_TAG HEAD)\n\nFetchContent_GetProperties(json)\nif(NOT json_POPULATED)\n  FetchContent_Populate(json)\n  add_subdirectory(${json_SOURCE_DIR} ${json_BINARY_DIR} EXCLUDE_FROM_ALL)\nendif()\n\nadd_executable(with_namespace_target main.cpp)\ntarget_link_libraries(with_namespace_target nlohmann_json::nlohmann_json)\n\nadd_executable(without_namespace_target main.cpp)\ntarget_link_libraries(without_namespace_target nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Using Global UDLs Example\nDESCRIPTION: Example demonstrating default behavior with _json UDL in global namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_global_udls.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\n#include <iostream>\n\nint main()\n{\n    auto j = \"42\"_json;\n\n    std::cout << j << std::endl;\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n42\n```\n\n----------------------------------------\n\nTITLE: Minimum Floating-Point Value\nDESCRIPTION: The minimum floating-point value that can be stored before being converted to NaN.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n-1.79769313486232e+308\n```\n\n----------------------------------------\n\nTITLE: Homebrew Example with CMake Integration\nDESCRIPTION: Example demonstrating how to integrate nlohmann/json installed via Homebrew using CMake's find_package functionality.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/homebrew/example.cpp\"\n```\n\nLANGUAGE: cmake\nCODE:\n```\n--8<-- \"integration/homebrew/CMakeLists.txt\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nCMAKE_PREFIX_PATH=$(brew --prefix) cmake -S . -B build\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Initializing cget for nlohmann/json\nDESCRIPTION: Command to initialize the cget environment before installing nlohmann/json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\ncget init\n```\n\n----------------------------------------\n\nTITLE: Adding AFL Driver Test Executable in CMake\nDESCRIPTION: Creates an executable for AFL Driver testing, including both the test file and the AFL driver implementation file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(AFLDriverTest\n  ../AFLDriverTest.cpp ../../afl/afl_driver.cpp)\n```\n\n----------------------------------------\n\nTITLE: Integer Range Maximum Value\nDESCRIPTION: The maximum integer value that can be stored in the default integer type (INT64_MAX).\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n9223372036854775807\n```\n\n----------------------------------------\n\nTITLE: SAX Interface Usage Example Placeholder\nDESCRIPTION: Placeholder for an example showing SAX interface usage, referenced from external file 'examples/sax_parse.cpp'\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/key.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/sax_parse.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Propagating TestBinaries to Parent Scope\nDESCRIPTION: Sets the TestBinaries variable in the parent scope, allowing the parent CMakeLists.txt to access the list of generated test binaries.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/ubsan/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(TestBinaries ${TestBinaries} PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Adding Legacy Comparison Test with Special Flags\nDESCRIPTION: Adds a specific test for legacy comparison of discarded values with a compile definition to enable this behavior, which was changed in newer versions of the library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# test legacy comparison of discarded values\njson_test_set_test_options(test-comparison_legacy\n    COMPILE_DEFINITIONS JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1\n)\njson_test_add_test_for(src/unit-comparison.cpp\n    NAME test-comparison_legacy\n    MAIN test_main CXX_STANDARDS ${test_cxx_standards} ${test_force}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring No Version Namespace Test in CMake\nDESCRIPTION: Sets up a test executable for a configuration without version namespace in the JSON library. It creates an executable, links it with the compatibility test main library, and adds a test command.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/config/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(abi_config_noversion noversion.cpp)\ntarget_link_libraries(abi_config_noversion PRIVATE abi_compat_main)\nadd_test(\n    NAME test-abi_config_noversion\n    COMMAND abi_config_noversion ${DOCTEST_TEST_FILTER})\n```\n\n----------------------------------------\n\nTITLE: Default JSON_DIAGNOSTICS Definition\nDESCRIPTION: Default definition of the JSON_DIAGNOSTICS macro, which is set to 0 to disable extended diagnostics by default.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostics.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DIAGNOSTICS 0\n```\n\n----------------------------------------\n\nTITLE: Adding Visual Studio Debug Visualization Support\nDESCRIPTION: Adds natvis debug visualization support for Microsoft Visual Studio. The natvis file helps with debugging by providing custom visualizations for JSON data structures in the Visual Studio debugger.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n## add debug view definition file for msvc (natvis)\nif (MSVC)\n    set(NLOHMANN_ADD_NATVIS TRUE)\n    set(NLOHMANN_NATVIS_FILE \"nlohmann_json.natvis\")\n    target_sources(\n        ${NLOHMANN_JSON_TARGET_NAME}\n        INTERFACE\n            $<INSTALL_INTERFACE:${NLOHMANN_NATVIS_FILE}>\n            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/${NLOHMANN_NATVIS_FILE}>\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Example C++ Code for nlohmann-json with Spack\nDESCRIPTION: Sample C++ code demonstrating how to use the nlohmann-json library with Spack integration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/spack/example.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing the null method in JSON SAX interface in C++\nDESCRIPTION: Pure virtual method that handles null values during SAX parsing. Returns a boolean indicating whether parsing should continue or be aborted.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/null.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool null() = 0;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extended JSON Error Diagnostics with JSON_DIAGNOSTICS\nDESCRIPTION: This code snippet is referenced but not directly shown in the content. It illustrates how enabling JSON_DIAGNOSTICS provides more detailed error messages including JSON Pointer paths to error locations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/exceptions.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// Examples of extended diagnostics messages are referenced but the code is not directly shown in the document\n```\n\n----------------------------------------\n\nTITLE: Building with CMake using cget-installed nlohmann/json\nDESCRIPTION: Commands to build a project with CMake using the nlohmann/json package installed via cget.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=cget/cget/cget.cmake\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Defining number_integer_t Type in nlohmann::basic_json C++ Library\nDESCRIPTION: This code snippet defines the number_integer_t type used for storing JSON integer values. It's a typedef to the template parameter NumberIntegerType, which determines the underlying storage type for integers in the JSON library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/number_integer_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing number_integer_t = NumberIntegerType;\n```\n\n----------------------------------------\n\nTITLE: Unsigned Integer Minimum Value\nDESCRIPTION: The minimum unsigned integer value that can be stored.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n0\n```\n\n----------------------------------------\n\nTITLE: Propagating Test Binaries to Parent Scope in CMake\nDESCRIPTION: Sets the TestBinaries variable in the parent scope, allowing the parent CMakeLists.txt to access the list of generated test binaries.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/uninstrumented/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(TestBinaries ${TestBinaries} PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Meson Build Integration Example\nDESCRIPTION: Example showing how to use the nlohmann/json library with the Meson build system by using the Meson WrapDB to fetch the library as a dependency.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n--8<-- \"integration/meson/meson.build\"\n```\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"integration/meson/example.cpp\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nmkdir subprojects\nmeson wrap install nlohmann_json\n```\n\nLANGUAGE: sh\nCODE:\n```\nmeson setup build\nmeson compile -C build\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization Output for Binary Values\nDESCRIPTION: Shows the resulting JSON output when serializing a binary value with subtype, formatted as an object with bytes array and subtype.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"binary\": {\n    \"bytes\": [202, 254, 186, 190],\n    \"subtype\": 42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting LibFuzzer Base Flags\nDESCRIPTION: Sets base compiler flags and disables certain sanitizer coverage instrumentation options for the fuzzer build.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(LIBFUZZER_FLAGS_BASE \"${CMAKE_CXX_FLAGS}\")\nset(CMAKE_CXX_FLAGS \"${LIBFUZZER_FLAGS_BASE} -fno-sanitize-coverage=trace-pc-guard,edge,trace-cmp,indirect-calls,8bit-counters -Werror\")\n```\n\n----------------------------------------\n\nTITLE: Setting Build Test Properties\nDESCRIPTION: Sets test properties for the build step, requiring the configuration fixture and labeling it as not reproducible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_target_include_directories/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset_tests_properties(cmake_target_include_directories_build PROPERTIES\n    FIXTURES_REQUIRED cmake_target_include_directories\n    LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: This CMake script sets up a project that uses the nlohmann/json library. It specifies the minimum CMake version, creates a project, finds the required package, and configures an executable with the appropriate library linkage.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/conan/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Implementing basic_json Destructor in C++\nDESCRIPTION: The destructor for the basic_json class that cleans up allocated memory. It provides a no-throw guarantee and has linear complexity based on the size of the JSON value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/~basic_json.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n~basic_json() noexcept;\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Configuration for nlohmann_json\nDESCRIPTION: Configures testing for the nlohmann_json library when JSON_BuildTests is enabled. Includes CTest support and adds the tests subdirectory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## TESTS\n## create and configure the unit test target\n##\nif (JSON_BuildTests)\n    include(CTest)\n    enable_testing()\n    add_subdirectory(tests)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Conda Environment for JSON\nDESCRIPTION: Shell commands to create a new Conda environment named 'json' and activate it. This isolates the nlohmann_json package installation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_28\n\nLANGUAGE: shell\nCODE:\n```\nconda create -n json\nconda activate json\n```\n\n----------------------------------------\n\nTITLE: Defining JSON_SKIP_UNSUPPORTED_COMPILER_CHECK Macro\nDESCRIPTION: Defines the macro that disables compiler compatibility checking in the nlohmann/json library. When defined, allows usage with compilers that may not fully support C++11.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_skip_unsupported_compiler_check.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\n```\n\n----------------------------------------\n\nTITLE: Declaring Byte Container with Subtype Template Class in C++\nDESCRIPTION: Template class declaration that extends a binary container type with subtype support. The class inherits from BinaryType and adds functionality for handling BSON and MessagePack subtypes. Default container type is std::vector<std::uint8_t>.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/index.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename BinaryType>\nclass byte_container_with_subtype : public BinaryType;\n```\n\n----------------------------------------\n\nTITLE: Configuring FetchContent Tests for nlohmann/json in CMake\nDESCRIPTION: Sets up two tests for CMake's FetchContent module: one for configuration and one for building. These tests are only added for CMake versions greater than 3.11.0. The tests use the project's source directory and set specific properties for test fixtures and labels.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif (${CMAKE_VERSION} VERSION_GREATER \"3.11.0\")\n  add_test(NAME cmake_fetch_content_configure\n    COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_source=${PROJECT_SOURCE_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n  )\n  add_test(NAME cmake_fetch_content_build\n    COMMAND ${CMAKE_COMMAND} --build .\n  )\n  set_tests_properties(cmake_fetch_content_configure PROPERTIES\n    FIXTURES_SETUP cmake_fetch_content\n    LABELS \"git_required;not_reproducible\"\n  )\n  set_tests_properties(cmake_fetch_content_build PROPERTIES\n    FIXTURES_REQUIRED cmake_fetch_content\n    LABELS \"git_required;not_reproducible\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Illustrating Library Incompatibility with Mermaid\nDESCRIPTION: This Mermaid diagram illustrates the potential incompatibility between different versions of the JSON library with different JSON_DIAGNOSTICS settings.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/namespace.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph\n    json[\"<strong>nlohmann_json (v3.10.5)</strong><br>JSON_DIAGNOSTICS=0\"]\n    json_diag[\"<strong>nlohmann_json (v3.10.5)</strong><br>JSON_DIAGNOSTICS=1\"]\n    library[\"<strong>some library</strong>\"]\n    app[\"<strong>application</strong>\"]\n    \n    library --> json\n    app --> json_diag\n    app --> library\n```\n\n----------------------------------------\n\nTITLE: Configuring Android NDK for nlohmann/json in Makefile\nDESCRIPTION: Makefile configuration to use LLVM C++ library, Clang compiler, and enable C++11 features for Android NDK compatibility with nlohmann/json library.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_32\n\nLANGUAGE: makefile\nCODE:\n```\nAPP_STL := c++_shared\nNDK_TOOLCHAIN_VERSION := clang3.6\nAPP_CPPFLAGS += -frtti -fexceptions\n```\n\n----------------------------------------\n\nTITLE: Adding nlohmann-json dependency with CPM.cmake\nDESCRIPTION: CMake snippet to add nlohmann-json as a dependency using CPM.cmake package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_33\n\nLANGUAGE: cmake\nCODE:\n```\nCPMAddPackage(\"gh:nlohmann/json@3.12.0\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subtype from Byte Container in C++\nDESCRIPTION: Member function that returns the numerical subtype of a byte container value. Returns subtype_type(-1) if no subtype is set. Provides no-throw guarantee and constant time complexity.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/byte_container_with_subtype/subtype.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr subtype_type subtype() const noexcept;\n```\n\n----------------------------------------\n\nTITLE: Setting up CMake tests for add_subdirectory integration in nlohmann/json\nDESCRIPTION: Defines CMake tests to verify the project can be correctly integrated using add_subdirectory. The first test configures the build system with the nlohmann_json source directory, and the second test builds the configured project. Test properties establish a fixture relationship between the tests and label them as not reproducible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_add_subdirectory/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_add_subdirectory_configure\n  COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_source=${PROJECT_SOURCE_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n)\nadd_test(NAME cmake_add_subdirectory_build\n  COMMAND ${CMAKE_COMMAND} --build .\n)\nset_tests_properties(cmake_add_subdirectory_configure PROPERTIES\n  FIXTURES_SETUP cmake_add_subdirectory\n  LABELS not_reproducible\n)\nset_tests_properties(cmake_add_subdirectory_build PROPERTIES\n  FIXTURES_REQUIRED cmake_add_subdirectory\n  LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Configure Build Flags for LibFuzzer Tests\nDESCRIPTION: Sets compilation flags to -O0 optimization level for all build types to ensure proper basic block discovery during testing. Filters and replaces optimization flags in existing build variables.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(variables_to_filter\n  CMAKE_CXX_FLAGS_RELEASE\n  CMAKE_CXX_FLAGS_DEBUG\n  CMAKE_CXX_FLAGS_RELWITHDEBINFO\n  CMAKE_CXX_FLAGS_MINSIZEREL\n  LIBFUZZER_FLAGS_BASE\n  )\nforeach (VARNAME ${variables_to_filter})\n  string(REPLACE \" \" \";\" BUILD_FLAGS_AS_LIST \"${${VARNAME}}\")\n  set(new_flags \"\")\n  foreach (flag ${BUILD_FLAGS_AS_LIST})\n    if (NOT (\"XX${flag}\" MATCHES \"XX-O[0123s]\"))\n      set(new_flags \"${new_flags} ${flag}\")\n    else()\n      set(new_flags \"${new_flags} -O0\")\n    endif()\n  endforeach()\n  set(${VARNAME} \"${new_flags}\")\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Example 2: Extended Diagnostic Messages\nDESCRIPTION: Example showing enhanced error messages with JSON pointer information when extended diagnostics are enabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostics.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostics_extended.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Building CMake Include Directories Test\nDESCRIPTION: Defines a CMake test that executes the build process after configuration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_target_include_directories/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_target_include_directories_build\n    COMMAND ${CMAKE_COMMAND} --build .\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with nlohmann/json Library\nDESCRIPTION: This CMake script sets up a project with multiple targets that use the nlohmann/json library. It demonstrates different inclusion methods (PRIVATE, SYSTEM, PUBLIC) and configures executables and libraries with the C++11 standard.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_target_include_directories/project/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5...3.14)\n\nproject(DummyImport CXX)\n\nadd_executable(with_private_target main.cpp)\ntarget_include_directories(with_private_target PRIVATE ${nlohmann_json_source}/include)\nset_target_properties(with_private_target PROPERTIES CXX_STANDARD 11)\n\nadd_executable(with_private_system_target main.cpp)\ntarget_include_directories(with_private_system_target PRIVATE SYSTEM ${nlohmann_json_source}/include)\nset_target_properties(with_private_system_target PROPERTIES CXX_STANDARD 11)\n\n# regression from https://github.com/nlohmann/json/discussions/2281\nadd_library(Foo STATIC Foo.cpp Bar.cpp)\ntarget_include_directories(Foo PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${nlohmann_json_source}/include)\nset_target_properties(Foo PROPERTIES CXX_STANDARD 11)\n\nadd_library(Bar STATIC Bar.cpp)\ntarget_link_libraries(Bar PRIVATE Foo)\ntarget_include_directories(Bar PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ${nlohmann_json_source}/include)\nset_target_properties(Bar PROPERTIES CXX_STANDARD 11)\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Target without Namespace\nDESCRIPTION: Defines an executable target named 'without_namespace_target' that links against the nlohmann_json library using the non-namespaced target name.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content2/project/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(without_namespace_target main.cpp)\ntarget_link_libraries(without_namespace_target nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Declaring Boolean Handler Method in C++ JSON SAX Interface\nDESCRIPTION: This snippet shows the declaration of the boolean method in the JSON SAX interface. It takes a boolean value as input and returns a boolean indicating whether parsing should continue.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/boolean.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvirtual bool boolean(bool val) = 0;\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann_json using Conda\nDESCRIPTION: Command to install the nlohmann_json package from the conda-forge channel using the Conda package manager. This makes the JSON library available in a Conda environment.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\nconda install -c conda-forge nlohmann_json\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Target with Namespace\nDESCRIPTION: Defines an executable target named 'with_namespace_target' that links against the nlohmann_json library using the namespace-aware target name.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content2/project/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(with_namespace_target main.cpp)\ntarget_link_libraries(with_namespace_target nlohmann_json::nlohmann_json)\n```\n\n----------------------------------------\n\nTITLE: Defining boolean_t Type Alias in C++\nDESCRIPTION: Defines the boolean_t type as an alias for BooleanType, which is used to store JSON boolean values. By default, BooleanType is set to bool.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/boolean_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing boolean_t = BooleanType;\n```\n\n----------------------------------------\n\nTITLE: Setting Up Main Test Library and Test Directories in CMake\nDESCRIPTION: Creates a static library for the main test executable and sets up test subdirectories. Links the main library with common ABI compatibility settings and adds configuration, diagnostics, and inline namespace test directories.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(abi_compat_main STATIC main.cpp)\ntarget_link_libraries(abi_compat_main PUBLIC abi_compat_common)\n\n# add individual tests\nadd_subdirectory(config)\nadd_subdirectory(diag)\nadd_subdirectory(inline_ns)\n```\n\n----------------------------------------\n\nTITLE: JSON Output to Stream in C++\nDESCRIPTION: Shows the correct way to output JSON to a stream using the << operator instead of the deprecated >> operator.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/migration_guide.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nstd::cout << j;\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann-json with Spack\nDESCRIPTION: Command to install the nlohmann-json package using the Spack package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nspack install nlohmann-json\n```\n\n----------------------------------------\n\nTITLE: Configure Unit Tests Setup\nDESCRIPTION: Sets up unit test executables with Google Test framework integration and proper include directories. Configures standalone initialization test and unittest binaries.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(LLVMFuzzer-Unittest\n  FuzzerUnittest.cpp\n  )\n\nadd_executable(LLVMFuzzer-StandaloneInitializeTest\n  InitializeTest.cpp\n  ../standalone/StandaloneFuzzTargetMain.c\n  )\n\ntarget_link_libraries(LLVMFuzzer-Unittest\n  gtest\n  gtest_main\n  LLVMFuzzerNoMain\n  )\n\ntarget_include_directories(LLVMFuzzer-Unittest PRIVATE\n  \"${LLVM_MAIN_SRC_DIR}/utils/unittest/googletest/include\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Building Fuzzers with libFuzzer\nDESCRIPTION: Command to build fuzz testing binaries using libFuzzer. This creates a separate binary for each supported parser by setting the FUZZER_ENGINE variable with the appropriate sanitizer flag.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake fuzzers FUZZER_ENGINE=\"-fsanitize=fuzzer\"\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann-json with MacPorts\nDESCRIPTION: Command to install the nlohmann-json package using MacPorts package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_31\n\nLANGUAGE: shell\nCODE:\n```\nsudo port install nlohmann-json\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann/json with cget\nDESCRIPTION: Command to install the latest master version of nlohmann/json using the cget package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\ncget install nlohmann/json\n```\n\n----------------------------------------\n\nTITLE: Setting Configure Test Properties\nDESCRIPTION: Sets test properties for the configuration step, marking it as a fixture setup and labeling it as not reproducible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_target_include_directories/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_tests_properties(cmake_target_include_directories_configure PROPERTIES\n    FIXTURES_SETUP cmake_target_include_directories\n    LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA Project with CMake for nlohmann/json\nDESCRIPTION: This CMake script configures a CUDA project named json_cuda that integrates with the nlohmann/json library. It establishes minimum CMake version requirements, sets CUDA as the project language, configures include directories, and enforces CUDA C++ 11 standard compliance.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cuda_example/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.18)\nproject(json_cuda LANGUAGES CUDA)\n\nadd_executable(json_cuda json_cuda.cu)\ntarget_include_directories(json_cuda PRIVATE ../../include)\ntarget_compile_features(json_cuda PUBLIC cuda_std_11)\nset_target_properties(json_cuda PROPERTIES\n    CUDA_EXTENSIONS OFF\n    CUDA_STANDARD_REQUIRED ON\n)\n```\n\n----------------------------------------\n\nTITLE: Creating nlohmann/json Docset with Make\nDESCRIPTION: Command to generate a docset for the nlohmann/json library using the make utility. The resulting nlohmann_json.docset folder can be opened in documentation browsers like Dash, Velocity, or Zeal.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/docset/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake nlohmann_json.docset\n```\n\n----------------------------------------\n\nTITLE: Defining start_pos Method in nlohmann::basic_json\nDESCRIPTION: Declaration of the start_pos method that returns the position of the first character in the JSON string from which the value was parsed. This method is only available when JSON_DIAGNOSTIC_POSITIONS macro is defined.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/start_pos.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#if JSON_DIAGNOSTIC_POSITIONS\nconstexpr std::size_t start_pos() const noexcept;\n#endif\n```\n\n----------------------------------------\n\nTITLE: Output of is_number_float Example in JSON\nDESCRIPTION: The output produced by the is_number_float() example code, showing the results for different JSON value types.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_number_float.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_number_float.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Import Tests for nlohmann/json Library\nDESCRIPTION: Sets up two CMake tests to verify the importability of the nlohmann/json library. The first test configures a test project to use the library, and the second test builds that project. Both tests are marked as 'not_reproducible' and are linked via CMake test fixtures.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_import_configure\n  COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -A \"${CMAKE_GENERATOR_PLATFORM}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_DIR=${PROJECT_BINARY_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n)\nadd_test(NAME cmake_import_build\n  COMMAND ${CMAKE_COMMAND} --build .\n)\nset_tests_properties(cmake_import_configure PROPERTIES\n  FIXTURES_SETUP cmake_import\n  LABELS not_reproducible\n)\nset_tests_properties(cmake_import_build PROPERTIES\n  FIXTURES_REQUIRED cmake_import\n  LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Adding CMake Build Test\nDESCRIPTION: Adds a test command to build the project after configuration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import_minver/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME cmake_import_minver_build\n  COMMAND ${CMAKE_COMMAND} --build .\n)\n```\n\n----------------------------------------\n\nTITLE: Example 3: Diagnostic Positions in Exceptions\nDESCRIPTION: Example demonstrating the use of diagnostic positions in exception messages.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_diagnostics.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"examples/diagnostic_positions_exception.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Downloading CPM.cmake script\nDESCRIPTION: Shell commands to create a directory and download the CPM.cmake script for use in a project.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_34\n\nLANGUAGE: shell\nCODE:\n```\nmkdir -p cmake\nwget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake\n```\n\n----------------------------------------\n\nTITLE: Custom Enum Serialization Functions with Disabled Default Serialization in C++\nDESCRIPTION: Demonstrates how to provide custom to_json and from_json functions for enum serialization and deserialization when default serialization is disabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_disable_enum_serialization.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nvoid from_json(const json& j, Choice& ch)\n{\n    auto value = j.template get<std::string>();\n    if (value == \"first\")\n    {\n        ch = Choice::first;\n    }\n    else if (value == \"second\")\n    {\n        ch = Choice::second;\n    }\n}\n\nvoid to_json(json& j, const Choice& ch)\n{\n    auto value = j.template get<std::string>();\n    if (value == \"first\")\n    {\n        ch = Choice::first;\n    }\n    else if (value == \"second\")\n    {\n        ch = Choice::second;\n    }\n}\n\nint main()\n{\n    // uses user-defined to_json function\n    const json j = Choice::first; \n\n    // uses user-defined from_json function\n    Choice ch = j.template get<Choice>();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Local Certificate for HTTPS\nDESCRIPTION: Command to create a locally-trusted certificate for localhost using mkcert, which generates the required PEM files for HTTPS.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ mkcert localhost\n```\n\n----------------------------------------\n\nTITLE: Installing amalgamate.py with bash\nDESCRIPTION: Command to test and install the amalgamate.py script to /usr/local/bin/ directory. Requires Python 2.7.0 or higher.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/amalgamate/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./test.sh && sudo -k cp ./amalgamate.py /usr/local/bin/\n```\n\n----------------------------------------\n\nTITLE: Implementation Logic for back() Method in C++\nDESCRIPTION: Equivalent implementation logic showing how back() method works by decrementing the end iterator and dereferencing it.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/back.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nauto tmp = c.end();\n--tmp;\nreturn *tmp;\n```\n\n----------------------------------------\n\nTITLE: Adding Tests for ABI Compatibility and CMake Integration\nDESCRIPTION: Adds subdirectories for testing ABI compatibility and various CMake import methods, ensuring the library can be correctly integrated in different project structures.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n#############################################################################\n# test ABI compatibility\n#############################################################################\n\nadd_subdirectory(abi)\n\n#############################################################################\n# Test the generated build configs\n#############################################################################\n\n# these tests depend on the generated file nlohmann_jsonConfig.cmake\nif (JSON_Install)\n    add_subdirectory(cmake_import)\n    add_subdirectory(cmake_import_minver)\nendif()\n\nadd_subdirectory(cmake_add_subdirectory)\nadd_subdirectory(cmake_fetch_content)\nadd_subdirectory(cmake_fetch_content2)\nadd_subdirectory(cmake_target_include_directories)\n```\n\n----------------------------------------\n\nTITLE: ValueType Operator Declaration in nlohmann::basic_json\nDESCRIPTION: Template method declaration for converting JSON values to other types. The method calls get() internally and can be made explicit by setting JSON_USE_IMPLICIT_CONVERSIONS to 0.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_ValueType.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ValueType>\nJSON_EXPLICIT operator ValueType() const;\n```\n\n----------------------------------------\n\nTITLE: Default undefined state of JSON_SKIP_LIBRARY_VERSION_CHECK in C++\nDESCRIPTION: This snippet shows the default state of the JSON_SKIP_LIBRARY_VERSION_CHECK macro, which is undefined. By default, the library will check for version compatibility and issue warnings when different versions are detected.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_skip_library_version_check.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#undef JSON_SKIP_LIBRARY_VERSION_CHECK\n```\n\n----------------------------------------\n\nTITLE: JSON output from BJData conversion using nlohmann/json library\nDESCRIPTION: This JSON snippet shows the result of converting BJData to JSON using the nlohmann/json library. It includes various data types and structures as represented in JSON format.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/bjdata.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/from_bjdata.output\"\n```\n\n----------------------------------------\n\nTITLE: Defining Test-Specific and Standard-Specific Build Settings\nDESCRIPTION: Sets compiler-specific options for particular tests, including linking to filesystem library for GCC 8, configuring stack size for binary format tests in MSVC, and disabling exceptions for specific tests.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n#############################################################################\n# define test- and standard-specific build settings\n#############################################################################\n\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\"\n    AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 8.0\n    AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0 AND NOT MINGW)\n    # fix for https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90050\n    json_test_set_test_options(all CXX_STANDARDS 17 LINK_LIBRARIES stdc++fs)\nendif()\n\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n    # avoid stack overflow, see https://github.com/nlohmann/json/issues/2955\n    json_test_set_test_options(\"test-cbor;test-msgpack;test-ubjson;test-bjdata;test-binary_formats\" LINK_OPTIONS /STACK:4000000)\nendif()\n\n# disable exceptions for test-disabled_exceptions\njson_test_set_test_options(test-disabled_exceptions\n    COMPILE_DEFINITIONS\n        JSON_NOEXCEPTION\n        # disabled due to https://github.com/nlohmann/json/discussions/2824\n        #$<$<CXX_COMPILER_ID:MSVC>:_HAS_EXCEPTIONS=0>\n    COMPILE_OPTIONS\n        $<$<CXX_COMPILER_ID:AppleClang>:-fno-exceptions> $<$<CXX_COMPILER_ID:Clang>:-fno-exceptions>\n        $<$<CXX_COMPILER_ID:GNU>:-fno-exceptions>\n        $<$<CXX_COMPILER_ID:Intel>:-fno-exceptions> $<$<CXX_COMPILER_ID:IntelLLVM>:-fno-exceptions>\n        # disabled due to https://github.com/nlohmann/json/discussions/2824\n        #$<$<CXX_COMPILER_ID:MSVC>:/EH>\n)\n\n# raise timeout of expensive Unicode test\njson_test_set_test_options(test-unicode4 TEST_PROPERTIES TIMEOUT 3000)\n```\n\n----------------------------------------\n\nTITLE: Defining json_base_class_t type in C++\nDESCRIPTION: Definition of the json_base_class_t type that enables injecting custom functionality into basic_json instances. This type uses a template parameter CustomBaseClass that becomes the base class for basic_json.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/json_base_class_t.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nusing json_base_class_t = detail::json_base_class<CustomBaseClass>;\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Test Properties for Configuration\nDESCRIPTION: Configures test properties for the import configuration step, setting up fixtures and marking as not reproducible.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_import_minver/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset_tests_properties(cmake_import_minver_configure PROPERTIES\n  FIXTURES_SETUP cmake_import_minver\n  LABELS not_reproducible\n)\n```\n\n----------------------------------------\n\nTITLE: Example Output of rend() Usage\nDESCRIPTION: JSON output placeholder showing the result of executing the rend() example code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/rend.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/rend.output\"\n```\n\n----------------------------------------\n\nTITLE: Running an afl++ Fuzzer Test with Corpus\nDESCRIPTION: Example command to run the CBOR parser fuzzer using afl++ with the prepared corpus directory. The command specifies input and output directories for the fuzzer operation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nafl-fuzz -i corpus_cbor -o out  -- ./parse_cbor_fuzzer \n```\n\n----------------------------------------\n\nTITLE: GPL Terminal Notice Template for Interactive Programs\nDESCRIPTION: A template for the short notice that should be displayed when a GPL-licensed program starts in interactive mode. It includes placeholders for program name, year, and author name, along with instructions for displaying warranty and redistribution details.\nSOURCE: https://github.com/nlohmann/json/blob/develop/LICENSES/GPL-3.0-only.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n<program>  Copyright (C) <year>  <name of author>\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Installing mkcert Certificate Authority\nDESCRIPTION: Command to install the mkcert certificate authority into the local trust store, which is needed for serving content over HTTPS.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mkcert -install\n```\n\n----------------------------------------\n\nTITLE: Running a libFuzzer Test with Corpus\nDESCRIPTION: Example command to run the CBOR parser fuzzer using libFuzzer with the prepared corpus directory. The fuzzer will continuously test the parser with mutations based on the corpus files.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/fuzzing.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./parse_cbor_fuzzer corpus_cbor\n```\n\n----------------------------------------\n\nTITLE: Configuring Common Build Settings for ABI Tests in CMake\nDESCRIPTION: Sets up an interface library with common compiler definitions, features, and options for ABI compatibility testing. Includes compiler-specific flags, warning suppressions, and linking configuration for different compiler vendors (MSVC, GNU, Intel).\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(abi_compat_common INTERFACE)\ntarget_compile_definitions(abi_compat_common INTERFACE\n    DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n    JSON_TEST_KEEP_MACROS)\ntarget_compile_features(abi_compat_common INTERFACE cxx_std_11)\ntarget_compile_options(abi_compat_common INTERFACE\n    $<$<CXX_COMPILER_ID:MSVC>:/EHsc;$<$<CONFIG:Release>:/Od>>\n    # MSVC: Force to always compile with W4\n    $<$<CXX_COMPILER_ID:MSVC>:/W4>\n\n    # https://github.com/nlohmann/json/pull/3229\n    $<$<CXX_COMPILER_ID:Intel>:-diag-disable=2196>\n\n    $<$<NOT:$<CXX_COMPILER_ID:MSVC>>:-Wno-deprecated;-Wno-float-equal>\n    $<$<CXX_COMPILER_ID:GNU>:-Wno-deprecated-declarations>\n    $<$<CXX_COMPILER_ID:Intel>:-diag-disable=1786>)\ntarget_include_directories(abi_compat_common SYSTEM INTERFACE\n    ../thirdparty/doctest\n    include)\ntarget_link_libraries(abi_compat_common INTERFACE ${NLOHMANN_JSON_TARGET_NAME})\n```\n\n----------------------------------------\n\nTITLE: Building Uninstrumented LibFuzzer Tests with CMake\nDESCRIPTION: Iterates through the list of uninstrumented tests and adds each as a LibFuzzer test target. The source file for each test is assumed to be in the parent directory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/uninstrumented/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(Test ${UninstrumentedTests})\n  add_libfuzzer_test(${Test}-Uninstrumented SOURCES ../${Test}.cpp)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: JSON Output for other_error Exception Example\nDESCRIPTION: The JSON output produced by the other_error exception example. The actual output is not provided in the snippet, but referenced to an external file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/other_error.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/other_error.output\"\n```\n\n----------------------------------------\n\nTITLE: Binary Values Support Comparison Table\nDESCRIPTION: Markdown table comparing binary value and subtype support across different binary formats.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_formats/index.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Format      | Binary values | Binary subtypes |\n|-------------|---------------|------------------|\n| BJData      | not supported | not supported   |\n| BSON        | supported     | supported       |\n| CBOR        | supported     | supported       |\n| MessagePack | supported     | supported       |\n| UBJSON      | not supported | not supported   |\n```\n\n----------------------------------------\n\nTITLE: Configure DSO Test Setup\nDESCRIPTION: Sets up shared library tests by creating DSO test executables and libraries with appropriate linking and output directory configuration.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(LLVMFuzzer-DSO1 SHARED DSO1.cpp)\nadd_library(LLVMFuzzer-DSO2 SHARED DSO2.cpp)\n\nadd_executable(LLVMFuzzer-DSOTest\n  DSOTestMain.cpp\n  DSOTestExtra.cpp)\n\ntarget_link_libraries(LLVMFuzzer-DSOTest\n  LLVMFuzzer-DSO1\n  LLVMFuzzer-DSO2\n  LLVMFuzzer\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating LibFuzzer Test Targets for UBSan Tests\nDESCRIPTION: Iterates through the UBSan test list and creates LibFuzzer test targets for each test, appending '-Ubsan' to the target name.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/ubsan/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(Test ${UbsanTests})\n  add_libfuzzer_test(${Test}-Ubsan SOURCES ../${Test}.cpp)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Parsing Floating-Point Number in JavaScript\nDESCRIPTION: This snippet shows a JavaScript array containing a very small floating-point number (5e-324) that the Nlohmann JSON library fails to roundtrip correctly.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n[5e-324]\n```\n\n----------------------------------------\n\nTITLE: Building C++ Code with nlohmann_json from Conda\nDESCRIPTION: g++ command to compile a C++ program that uses the nlohmann_json library installed in a Conda environment. It includes the appropriate include path from the Conda environment.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\ng++ -std=c++11 -I$(conda info --base)/envs/json/include example.cpp -o example\n```\n\n----------------------------------------\n\nTITLE: Parsing Small Floating-Point Number in JavaScript\nDESCRIPTION: This snippet demonstrates the actual output from the Nlohmann JSON library when attempting to roundtrip the very small floating-point number 5e-324.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n[4.94065645841247e-324]\n```\n\n----------------------------------------\n\nTITLE: Installing Required Python Packages\nDESCRIPTION: These are the Python package dependencies needed for serve_header.py to function properly. They can be installed via pip and are listed in the requirements.txt file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nPyYAML\nwatchdog\n```\n\n----------------------------------------\n\nTITLE: Configuring ABI Compatibility Test for JSON Library in CMake\nDESCRIPTION: This CMake snippet creates an executable for testing ABI compatibility between different versions of a JSON library. It links both an old version without an inline namespace and the current version with an inline namespace. The test is then added to the project's test suite.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/inline_ns/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# test linking an old library version without an inline namespace\n# with the current library using an inline namespace into the same executable\n\n# build test executable and add test\nadd_executable(abi_compat_inline_ns\n    use_v3_10_5.cpp\n    use_current.cpp)\ntarget_link_libraries(abi_compat_inline_ns PRIVATE abi_compat_main)\n\nadd_test(\n    NAME test-abi_compat_inline_ns\n    COMMAND abi_compat_inline_ns ${DOCTEST_TEST_FILTER})\n```\n\n----------------------------------------\n\nTITLE: Specifying cppcheck Version Requirement\nDESCRIPTION: Defines the specific version of cppcheck (1.5.0) required for the project, likely used for static code analysis and bug detection in the C++ codebase.\nSOURCE: https://github.com/nlohmann/json/blob/develop/cmake/requirements/requirements-cppcheck.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncppcheck==1.5.0\n```\n\n----------------------------------------\n\nTITLE: Skipping Library Version Check with JSON_SKIP_LIBRARY_VERSION_CHECK Macro in C++\nDESCRIPTION: When defined, this macro prevents the library from issuing a warning when a different version of the library was already included.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/macros.md#2025-04-21_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nJSON_SKIP_LIBRARY_VERSION_CHECK\n```\n\n----------------------------------------\n\nTITLE: JSON Null Check Example Output Reference\nDESCRIPTION: Reference to output file showing results of null check operations.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/is_null.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/is_null.output\"\n```\n\n----------------------------------------\n\nTITLE: Setting Output Directory for AFL Driver Test in CMake\nDESCRIPTION: Configures the runtime output directory for the AFL Driver test executable to be in the lib/Fuzzer/test directory within the build directory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(AFLDriverTest\n    PROPERTIES RUNTIME_OUTPUT_DIRECTORY\n    \"${CMAKE_BINARY_DIR}/lib/Fuzzer/test\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Explicit ValueType Operator Signature with JSON_EXPLICIT\nDESCRIPTION: The signature when JSON_USE_IMPLICIT_CONVERSIONS is set to 0, making the operator explicit and requiring manual conversion.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/operator_ValueType.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename ValueType>\nexplicit operator ValueType() const;\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Instrumented Fuzzing Tests in CMake\nDESCRIPTION: Creates a list of fuzzing tests that should not include coverage instrumentation. Currently only includes the UninstrumentedTest.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(NoCoverageTests\n  UninstrumentedTest\n  )\n```\n\n----------------------------------------\n\nTITLE: Including JavaScript Resources for GitHub Functionality\nDESCRIPTION: This snippet shows the inclusion of various JavaScript files required for GitHub's compatibility, core frameworks, and main functionality.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_11\n\nLANGUAGE: HTML\nCODE:\n```\n<script crossorigin=\"anonymous\" src=\"https://assets-cdn.github.com/assets/compat-40e365359d1c4db1e36a55be458e60f2b7c24d58b5a00ae13398480e7ba768e0.js\"></script>\n<script crossorigin=\"anonymous\" src=\"https://assets-cdn.github.com/assets/frameworks-88471af1fec40ff9418efbe2ddd15b6896af8d772f8179004c254dffc25ea490.js\"></script>\n<script async=\"async\" crossorigin=\"anonymous\" src=\"https://assets-cdn.github.com/assets/github-e18e11a943ff2eb9394c72d4ec8b76592c454915b5839ae177d422777a046e29.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Configuring LibFuzzer Libraries\nDESCRIPTION: Creates the main LibFuzzer libraries including LLVMFuzzerNoMainObjects (object library), LLVMFuzzerNoMain (static library), and LLVMFuzzer (static library with main). Includes various source files and links against pthread.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(LLVMFuzzerNoMainObjects OBJECT\n  FuzzerCrossOver.cpp\n  FuzzerDriver.cpp\n  FuzzerExtFunctionsDlsym.cpp\n  FuzzerExtFunctionsWeak.cpp\n  FuzzerExtFunctionsWeakAlias.cpp\n  FuzzerIO.cpp\n  FuzzerIOPosix.cpp\n  FuzzerIOWindows.cpp\n  FuzzerLoop.cpp\n  FuzzerMerge.cpp\n  FuzzerMutate.cpp\n  FuzzerSHA1.cpp\n  FuzzerTracePC.cpp\n  FuzzerTraceState.cpp\n  FuzzerUtil.cpp\n  FuzzerUtilDarwin.cpp\n  FuzzerUtilLinux.cpp\n  FuzzerUtilPosix.cpp\n  FuzzerUtilWindows.cpp\n  )\nadd_library(LLVMFuzzerNoMain STATIC\n  $<TARGET_OBJECTS:LLVMFuzzerNoMainObjects>\n  )\ntarget_link_libraries(LLVMFuzzerNoMain ${PTHREAD_LIB})\nadd_library(LLVMFuzzer STATIC\n  FuzzerMain.cpp\n  $<TARGET_OBJECTS:LLVMFuzzerNoMainObjects>\n  )\ntarget_link_libraries(LLVMFuzzer ${PTHREAD_LIB})\n```\n\n----------------------------------------\n\nTITLE: SVG Check Icon\nDESCRIPTION: SVG path definition for a checkmark icon used in menu items\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_2\n\nLANGUAGE: SVG\nCODE:\n```\n<svg aria-hidden=\"true\" class=\"octicon octicon-check select-menu-item-icon\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\"><path d=\"M12 5l-8 8-4-4 1.5-1.5L4 10l6.5-6.5z\"></path></svg>\n```\n\n----------------------------------------\n\nTITLE: Default Assertion Behavior Example\nDESCRIPTION: Example demonstrating the default assertion behavior when accessing a missing key in a const json object.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_assert.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying cpplint Package Version for nlohmann/json Project\nDESCRIPTION: This snippet defines the required version of the cpplint package for the nlohmann/json project. It specifies that version 2.0.2 of cpplint is needed.\nSOURCE: https://github.com/nlohmann/json/blob/develop/cmake/requirements/requirements-cpplint.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ncpplint==2.0.2\n```\n\n----------------------------------------\n\nTITLE: Explicit Conversion Example in nlohmann/json C++\nDESCRIPTION: Shows how to explicitly convert from a JSON string to a std::string using the get() method when JSON_USE_IMPLICIT_CONVERSIONS is disabled.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_implicit_conversions.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\njson j = \"Hello, world!\";\nauto s = j.template get<std::string>();\n```\n\n----------------------------------------\n\nTITLE: Default JSON_USE_GLOBAL_UDLS Definition\nDESCRIPTION: Default macro definition with value 1, placing UDLs in global namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_use_global_udls.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_USE_GLOBAL_UDLS 1\n```\n\n----------------------------------------\n\nTITLE: Rounding Small Floating-Point Number in JavaScript\nDESCRIPTION: This snippet demonstrates the actual output from the Nlohmann JSON library when attempting to roundtrip the small floating-point number 2.225073858507201e-308.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n[2.2250738585072e-308]\n```\n\n----------------------------------------\n\nTITLE: Displaying AJAX Error Message in HTML\nDESCRIPTION: This snippet shows the HTML structure for displaying an AJAX error message, including an alert icon and a dismiss button.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_10\n\nLANGUAGE: HTML\nCODE:\n```\n<div id=\"ajax-error-message\" class=\"ajax-error-message flash flash-error\">\n  <svg aria-hidden=\"true\" class=\"octicon octicon-alert\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path d=\"M8.865 1.52c-.18-.31-.51-.5-.87-.5s-.69.19-.87.5L.275 13.5c-.18.31-.18.69 0 1 .19.31.52.5.87.5h13.7c.36 0 .69-.19.86-.5.17-.31.18-.69.01-1L8.865 1.52zM8.995 13h-2v-2h2v2zm0-3h-2V6h2v4z\"></path></svg>\n  <button type=\"button\" class=\"flash-close js-flash-close js-ajax-error-dismiss\" aria-label=\"Dismiss error\">\n    <svg aria-hidden=\"true\" class=\"octicon octicon-x\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\"><path d=\"M7.48 8l3.75 3.75-1.48 1.48L6 9.48l-3.75 3.75-1.48-1.48L4.52 8 .77 4.25l1.48-1.48L6 6.52l3.75-3.75 1.48 1.48z\"></path></svg>\n  </button>\n  You can't perform that action at this time.\n</div>\n```\n\n----------------------------------------\n\nTITLE: Propagating Test Binaries to Parent Scope in CMake\nDESCRIPTION: Adds the AFLDriverTest to the TestBinaries list and propagates it to the parent scope, making it available in the parent CMake file.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/no-coverage/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nset(TestBinaries ${TestBinaries} AFLDriverTest PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Output of invalid_iterator Exception Example\nDESCRIPTION: The expected JSON output from the invalid_iterator exception handling example. The actual output is not provided in the snippet.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/invalid_iterator.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/invalid_iterator.output\"\n```\n\n----------------------------------------\n\nTITLE: Including External Markdown Document in Markdown\nDESCRIPTION: This snippet demonstrates the use of the '--8<--' syntax which is used in some Markdown processors (like MkDocs with the material theme) to include content from another file. In this case, it's including the CODE_OF_CONDUCT.md file from the .github directory.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/community/code_of_conduct.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n--8<-- \"../../../.github/CODE_OF_CONDUCT.md\"\n```\n\n----------------------------------------\n\nTITLE: Example Output of max_size Method across JSON Types\nDESCRIPTION: Example output showing the results of calling max_size() on different JSON value types. The actual values are platform-dependent.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/max_size.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/max_size.output\"\n```\n\n----------------------------------------\n\nTITLE: Integer Values in C++ Leading Zero Handling\nDESCRIPTION: Demonstrates how C++ interprets leading zeros as octal numbers, where the literal 010 is interpreted as the decimal value 8.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/types/index.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n010\n```\n\n----------------------------------------\n\nTITLE: Displaying Stale Session Flash Message in HTML\nDESCRIPTION: This snippet contains the HTML structure for displaying a stale session flash message, including options for signed-in and signed-out states.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_12\n\nLANGUAGE: HTML\nCODE:\n```\n<div class=\"js-stale-session-flash stale-session-flash flash flash-warn flash-banner d-none\">\n  <svg aria-hidden=\"true\" class=\"octicon octicon-alert\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path d=\"M8.865 1.52c-.18-.31-.51-.5-.87-.5s-.69.19-.87.5L.275 13.5c-.18.31-.18.69 0 1 .19.31.52.5.87.5h13.7c.36 0 .69-.19.86-.5.17-.31.18-.69.01-1L8.865 1.52zM8.995 13h-2v-2h2v2zm0-3h-2V6h2v4z\"></path></svg>\n  <span class=\"signed-in-tab-flash\">You signed in with another tab or window. <a href=\"\">Reload</a> to refresh your session.</span>\n  <span class=\"signed-out-tab-flash\">You signed out in another tab or window. <a href=\"\">Reload</a> to refresh your session.</span>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for nlohmann/json\nDESCRIPTION: This requirements file specifies that Jinja2 version 3.1.6 is required for the project. Jinja2 is a templating engine for Python that is commonly used for generating HTML, documentation, or code.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/generate_natvis/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\njinja2==3.1.6\n```\n\n----------------------------------------\n\nTITLE: Unflattening JSON Objects Example Output - JSON\nDESCRIPTION: Reference to the output file showing the result of unflattening operation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/unflatten.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/unflatten.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring GDB Pretty Printer for nlohmann/json\nDESCRIPTION: Add this line to your ~/.gdbinit file to load the pretty printer. You need to specify the correct path to where the nlohmann-json.py file is located.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/gdb_pretty_printer/README.md#2025-04-21_snippet_0\n\nLANGUAGE: GDB\nCODE:\n```\nsource /path/to/nlohmann-json.py\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake FetchContent Tests for nlohmann/json Library\nDESCRIPTION: Creates CMake tests to verify the library can be properly fetched and built using CMake's FetchContent module. The tests check if configuration and build steps work correctly, and are marked with appropriate labels and fixture relationships.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/cmake_fetch_content2/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif (${CMAKE_VERSION} VERSION_GREATER \"3.14.0\")\n  add_test(NAME cmake_fetch_content2_configure\n    COMMAND ${CMAKE_COMMAND}\n    -G \"${CMAKE_GENERATOR}\"\n    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\n    -Dnlohmann_json_source=${PROJECT_SOURCE_DIR}\n    ${CMAKE_CURRENT_SOURCE_DIR}/project\n  )\n  add_test(NAME cmake_fetch_content2_build\n    COMMAND ${CMAKE_COMMAND} --build .\n  )\n  set_tests_properties(cmake_fetch_content2_configure PROPERTIES\n    FIXTURES_SETUP cmake_fetch_content2\n    LABELS \"git_required;not_reproducible\"\n  )\n  set_tests_properties(cmake_fetch_content2_build PROPERTIES\n    FIXTURES_REQUIRED cmake_fetch_content2\n    LABELS \"git_required;not_reproducible\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: JSON SAX Parser Example Output\nDESCRIPTION: Example output from the SAX parser implementation\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_sax/end_array.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: UBJSON Binary Output Format\nDESCRIPTION: Shows the hexadecimal representation of the UBJSON-encoded binary data, including structural markers and content bytes.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/binary_values.md#2025-04-21_snippet_14\n\nLANGUAGE: c\nCODE:\n```\n0x7B                                             // '{'\n    0x69 0x06                                    // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79                // \"binary\"\n    0x5B                                         // '['\n        0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE  // content (each byte prefixed with 'U')\n    0x5D                                         // ']'\n0x7D                                             // '}'\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Include Paths and External Project Support\nDESCRIPTION: Sets up the CMake module path to include the project's cmake directory and includes the ExternalProject module for dependency management.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## INCLUDE\n##\n##\nset(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\ninclude(ExternalProject)\n```\n\n----------------------------------------\n\nTITLE: Building Bazel Configuration using Make\nDESCRIPTION: Shell command to update the BUILD.bazel file using make\nSOURCE: https://github.com/nlohmann/json/blob/develop/FILES.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake BUILD.bazel\n```\n\n----------------------------------------\n\nTITLE: Building with CMake using vcpkg-installed nlohmann-json\nDESCRIPTION: Commands to build a project with CMake using the nlohmann-json package installed via vcpkg.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Implementing Facebox Modal in HTML\nDESCRIPTION: This snippet shows the HTML structure for a Facebox modal, including content area and close button with SVG icon.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_13\n\nLANGUAGE: HTML\nCODE:\n```\n<div class=\"facebox\" id=\"facebox\" style=\"display:none;\">\n  <div class=\"facebox-popup\">\n    <div class=\"facebox-content\" role=\"dialog\" aria-labelledby=\"facebox-header\" aria-describedby=\"facebox-description\">\n    </div>\n    <button type=\"button\" class=\"facebox-close js-facebox-close\" aria-label=\"Close modal\">\n      <svg aria-hidden=\"true\" class=\"octicon octicon-x\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\"><path d=\"M7.48 8l3.75 3.75-1.48 1.48L6 9.48l-3.75 3.75-1.48-1.48L4.52 8 .77 4.25l1.48-1.48L6 6.52l3.75-3.75 1.48 1.48z\"></path></svg>\n    </button>\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Installing nlohmann-json with vcpkg\nDESCRIPTION: Command to install the nlohmann-json package using the vcpkg package manager.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg install nlohmann-json\n```\n\n----------------------------------------\n\nTITLE: Building with CMake using Spack-installed nlohmann-json\nDESCRIPTION: Commands to build a project with CMake using the nlohmann-json package installed via Spack.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/integration/package_managers.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncmake -S . -B build -DCMAKE_PREFIX_PATH=$(spack location -i nlohmann-json)\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Defining NLOHMANN_JSON_NAMESPACE_BEGIN and NLOHMANN_JSON_NAMESPACE_END Macros in C++\nDESCRIPTION: These macros are used to open and close the nlohmann namespace in the JSON library. They control the namespace structure and versioning.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/nlohmann_json_namespace_begin.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define NLOHMANN_JSON_NAMESPACE_BEGIN /* value */  // (1)\n#define NLOHMANN_JSON_NAMESPACE_END   /* value */  // (2)\n```\n\n----------------------------------------\n\nTITLE: Generating Include Flags with Pkg-config for nlohmann_json\nDESCRIPTION: This command uses pkg-config to generate the include flags that point to where the nlohmann_json library is installed. It's useful for projects using bare Makefiles.\nSOURCE: https://github.com/nlohmann/json/blob/develop/README.md#2025-04-21_snippet_37\n\nLANGUAGE: sh\nCODE:\n```\npkg-config nlohmann_json --cflags\n```\n\n----------------------------------------\n\nTITLE: Creating CMake Target for nlohmann_json\nDESCRIPTION: Creates an interface library target for nlohmann_json, sets C++11 requirement, configures compiler definitions based on build options, and sets include directories for both build and install interfaces.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## TARGET\n## create target and add include path\n##\nadd_library(${NLOHMANN_JSON_TARGET_NAME} INTERFACE)\nadd_library(${PROJECT_NAME}::${NLOHMANN_JSON_TARGET_NAME} ALIAS ${NLOHMANN_JSON_TARGET_NAME})\nif (${CMAKE_VERSION} VERSION_LESS \"3.8.0\")\n    target_compile_features(${NLOHMANN_JSON_TARGET_NAME} INTERFACE cxx_range_for)\nelse()\n    target_compile_features(${NLOHMANN_JSON_TARGET_NAME} INTERFACE cxx_std_11)\nendif()\n\ntarget_compile_definitions(\n    ${NLOHMANN_JSON_TARGET_NAME}\n    INTERFACE\n    $<$<NOT:$<BOOL:${JSON_GlobalUDLs}>>:JSON_USE_GLOBAL_UDLS=0>\n    $<$<NOT:$<BOOL:${JSON_ImplicitConversions}>>:JSON_USE_IMPLICIT_CONVERSIONS=0>\n    $<$<BOOL:${JSON_DisableEnumSerialization}>:JSON_DISABLE_ENUM_SERIALIZATION=1>\n    $<$<BOOL:${JSON_Diagnostics}>:JSON_DIAGNOSTICS=1>\n    $<$<BOOL:${JSON_Diagnostic_Positions}>:JSON_DIAGNOSTIC_POSITIONS=1>\n    $<$<BOOL:${JSON_LegacyDiscardedValueComparison}>:JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON=1>\n)\n\ntarget_include_directories(\n    ${NLOHMANN_JSON_TARGET_NAME}\n    ${NLOHMANN_JSON_SYSTEM_INCLUDE} INTERFACE\n    $<BUILD_INTERFACE:${NLOHMANN_JSON_INCLUDE_BUILD_DIR}>\n    $<INSTALL_INTERFACE:${NLOHMANN_JSON_INCLUDE_INSTALL_DIR}>\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Build and Configuration Options for nlohmann_json\nDESCRIPTION: Defines all configurable options for the library build process, including testing, diagnostics, implicit conversions, and installation settings. Default values are determined based on whether this is the main project or a subproject.\nSOURCE: https://github.com/nlohmann/json/blob/develop/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n##\n## OPTIONS\n##\n\nif (POLICY CMP0077)\n    # Allow CMake 3.13+ to override options when using FetchContent / add_subdirectory.\n    cmake_policy(SET CMP0077 NEW)\nendif ()\n\n# VERSION_GREATER_EQUAL is not available in CMake 3.1\nif(${MAIN_PROJECT} AND (${CMAKE_VERSION} VERSION_EQUAL 3.13 OR ${CMAKE_VERSION} VERSION_GREATER 3.13))\n    set(JSON_BuildTests_INIT ON)\nelse()\n    set(JSON_BuildTests_INIT OFF)\nendif()\noption(JSON_BuildTests                     \"Build the unit tests when BUILD_TESTING is enabled.\" ${JSON_BuildTests_INIT})\noption(JSON_CI                             \"Enable CI build targets.\" OFF)\noption(JSON_Diagnostics                    \"Use extended diagnostic messages.\" OFF)\noption(JSON_Diagnostic_Positions           \"Enable diagnostic positions.\" OFF)\noption(JSON_GlobalUDLs                     \"Place user-defined string literals in the global namespace.\" ON)\noption(JSON_ImplicitConversions            \"Enable implicit conversions.\" ON)\noption(JSON_DisableEnumSerialization       \"Disable default integer enum serialization.\" OFF)\noption(JSON_LegacyDiscardedValueComparison \"Enable legacy discarded value comparison.\" OFF)\noption(JSON_Install                        \"Install CMake targets during install step.\" ${MAIN_PROJECT})\noption(JSON_MultipleHeaders                \"Use non-amalgamated version of the library.\" ON)\noption(JSON_SystemInclude                  \"Include as system headers (skip for clang-tidy).\" OFF)\n\nif (JSON_CI)\n    include(ci)\nendif ()\n```\n\n----------------------------------------\n\nTITLE: Reading JSON Values Using operator[] in C++\nDESCRIPTION: Demonstrates how to access different parts of a JSON structure using the operator[] syntax. Shows how to navigate through nested objects and arrays to retrieve specific values.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/element_access/unchecked_access.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Mary Smith\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nj\nj[\"name\"]\nj[\"age\"]\nj[\"hobbies\"]\nj[\"hobbies\"][0]\nj[\"hobbies\"][1]\n```\n\n----------------------------------------\n\nTITLE: Accessing Object Values with JSON Pointers\nDESCRIPTION: Example showing how to use JSON Pointers for accessing values with at() and operator[] functions, along with flatten() and unflatten() operations for key/value pair manipulation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/home/releases.md#2025-04-21_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nj.at(\"pointer\");\nj[\"pointer\"];\n\n// Flatten JSON to key/value pairs\nauto flattened = j.flatten();\n\n// Restore original structure\nauto unflattened = flattened.unflatten();\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of value Method with JSON Pointer in C++\nDESCRIPTION: Sample implementation showing the equivalent try-catch logic for the third overload of the value method that uses a JSON pointer. It returns the default value if the pointer doesn't find a value.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/value.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\ntry {\n   return at(ptr);\n} catch(out_of_range) {\n   return default_value;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing to_string Template Function for JSON Serialization in C++\nDESCRIPTION: Sample implementation of the to_string function that internally calls the dump method on the JSON object. This implementation demonstrates how the function converts a JSON value to its string representation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/to_string.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename BasicJsonType>\nstd::string to_string(const BasicJsonType& j)\n{\n    return j.dump();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Filesystem Support Macros in C++\nDESCRIPTION: Core macro definitions that enable filesystem support in the JSON library. These macros determine whether to use std::filesystem or std::experimental::filesystem for path conversions.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/macros/json_has_filesystem.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define JSON_HAS_FILESYSTEM /* value */\n#define JSON_HAS_EXPERIMENTAL_FILESYSTEM /* value */\n```\n\n----------------------------------------\n\nTITLE: Declaring std::swap Specialization for basic_json\nDESCRIPTION: Function declaration for std::swap specialization that allows exchanging values between two nlohmann::basic_json objects. Located in the std namespace.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/std_swap.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace std {\n    void swap(nlohmann::basic_json& j1, nlohmann::basic_json& j2);\n}\n```\n\n----------------------------------------\n\nTITLE: GPL Copyright Notice Template for Source Files\nDESCRIPTION: A template for the copyright and license notice that should be attached to the start of each source file in a GPL-licensed program. It includes placeholders for program name, year, and author name, along with standard GPL licensing text.\nSOURCE: https://github.com/nlohmann/json/blob/develop/LICENSES/GPL-3.0-only.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n```\n\n----------------------------------------\n\nTITLE: Example Output from sax_parse Function\nDESCRIPTION: Shows the expected JSON output from running the sax_parse example code. This output is included to demonstrate the results of the SAX parsing process.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/basic_json/sax_parse.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/sax_parse.output\"\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Flags for Uninstrumented Tests in C++\nDESCRIPTION: Configures CMake flags to disable sanitizers and coverage instrumentation for uninstrumented fuzzing tests. This ensures the tests are built without additional runtime overhead.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/uninstrumented/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS\n  \"${LIBFUZZER_FLAGS_BASE} -fno-sanitize=all -fno-sanitize-coverage=edge,trace-cmp,indirect-calls,8bit-counters,trace-pc-guard\")\n```\n\n----------------------------------------\n\nTITLE: Output of JSON Pointer to_string Example\nDESCRIPTION: The JSON output produced by the to_string method example, showing the string representations of various JSON pointers.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/api/json_pointer/to_string.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/json_pointer__to_string.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Namespace Test in CMake\nDESCRIPTION: Sets up a test executable for a custom namespace configuration in the JSON library. It creates an executable, links it with the compatibility test main library, and adds a test command.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/abi/config/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(abi_config_custom custom.cpp)\ntarget_link_libraries(abi_config_custom PRIVATE abi_compat_main)\nadd_test(\n    NAME test-abi_config_custom\n    COMMAND abi_config_custom ${DOCTEST_TEST_FILTER})\n```\n\n----------------------------------------\n\nTITLE: Parser Callback Output\nDESCRIPTION: Example output from the parser callback implementation.\nSOURCE: https://github.com/nlohmann/json/blob/develop/docs/mkdocs/docs/features/parsing/parser_callbacks.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n--8<-- \"examples/parse__string__parser_callback_t.output\"\n```\n\n----------------------------------------\n\nTITLE: Configuring UBSan Flags for CMake Tests\nDESCRIPTION: Sets CMake flags for UBSan tests with LibFuzzer integration. Enables undefined behavior sanitizer in non-recovery mode.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/ubsan/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS\n  \"${LIBFUZZER_FLAGS_BASE} -fsanitize=undefined -fno-sanitize-recover=all\")\n```\n\n----------------------------------------\n\nTITLE: Rounding Large Floating-Point Number in JavaScript\nDESCRIPTION: This snippet demonstrates the actual output from the Nlohmann JSON library when attempting to roundtrip the large floating-point number 1.7976931348623157e308.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n[1.79769313486232e+308]\n```\n\n----------------------------------------\n\nTITLE: Parsing Another Small Floating-Point Number in JavaScript\nDESCRIPTION: This snippet shows a JavaScript array containing another small floating-point number (2.225073858507201e-308) that the Nlohmann JSON library fails to roundtrip correctly.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n[2.225073858507201e-308]\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies\nDESCRIPTION: Specifies required Python packages with exact version constraints for the project. Includes PyYAML 6.0.2 and watchdog 6.0.0, which are likely used for YAML parsing and file system monitoring respectively.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/serve_header/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPyYAML==6.0.2\nwatchdog==6.0.0\n```\n\n----------------------------------------\n\nTITLE: Specifying astyle Version Requirement\nDESCRIPTION: Defines the specific version of astyle (3.4.13) to be used. This ensures that code formatting is consistent across different environments and among contributors to the nlohmann/json project.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tools/astyle/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nastyle==3.4.13\n```\n\n----------------------------------------\n\nTITLE: HTML Form for Repository Search\nDESCRIPTION: Search form HTML for scoped repository search functionality with CSRF token and search input field.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/reports/2016-09-09-nativejson_benchmark/conformance_Nlohmann (C++11).md#2025-04-21_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<form accept-charset=\\\"UTF-8\\\" action=\\\"/miloyip/nativejson-benchmark/search\\\" class=\\\"js-site-search-form\\\" data-scoped-search-url=\\\"/miloyip/nativejson-benchmark/search\\\" data-unscoped-search-url=\\\"/search\\\" method=\\\"get\\\"><div style=\\\"margin:0;padding:0;display:inline\\\"><input name=\\\"utf8\\\" type=\\\"hidden\\\" value=\\\"&#x2713;\\\" /></div>\n    <label class=\\\"form-control header-search-wrapper js-chromeless-input-container\\\">\n      <div class=\\\"header-search-scope\\\">This repository</div>\n      <input type=\\\"text\\\"\n        class=\\\"form-control header-search-input js-site-search-focus js-site-search-field is-clearable\\\"\n        data-hotkey=\\\"s\\\"\n        name=\\\"q\\\"\n        placeholder=\\\"Search\\\"\n        aria-label=\\\"Search this repository\\\"\n        data-unscoped-placeholder=\\\"Search GitHub\\\"\n        data-scoped-placeholder=\\\"Search\\\"\n        autocapitalize=\\\"off\\\">\n    </label>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Defining Dictionary Key-Value Pairs in Python\nDESCRIPTION: This snippet defines two variables with string values, likely to be used as key-value pairs in a dictionary. The variables 'a' and 'b' are assigned the values 'Elvis' and 'Presley' respectively.\nSOURCE: https://github.com/nlohmann/json/blob/develop/tests/thirdparty/Fuzzer/test/dict1.txt#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\na=\"Elvis\"\nb=\"Presley\"\n```"
  }
]