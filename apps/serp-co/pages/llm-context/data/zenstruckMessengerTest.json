[
  {
    "owner": "zenstruck",
    "repo": "messenger-test",
    "content": "TITLE: Queue Assertions with TestTransport\nDESCRIPTION: Demonstrates how to use the `InteractsWithMessenger` trait to interact with the test transport and assert on the queue. This includes checking if the queue is empty or not, counting messages, and checking for specific messages within the queue.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_3\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // ...some code that routes messages to your configured transport\n\n        // assert against the queue\n        $this->transport()->queue()->assertEmpty();\n        $this->transport()->queue()->assertNotEmpty();\n        $this->transport()->queue()->assertCount(3);\n        $this->transport()->queue()->assertContains(MyMessage::class); // queue contains this message\n        $this->transport()->queue()->assertContains(MyMessage::class, 3); // queue contains this message 3 times\n        $this->transport()->queue()->assertContains(MyMessage::class, 0); // queue contains this message 0 times\n        $this->transport()->queue()->assertNotContains(MyMessage::class); // queue not contains this message\n\n        // access the queue data\n        $this->transport()->queue(); // Envelope[]\n        $this->transport()->queue()->messages(); // object[] the messages unwrapped from envelope\n        $this->transport()->queue()->messages(MyMessage::class); // MyMessage[] just messages matching class\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Transport Assertions and Helpers\nDESCRIPTION: Demonstrates advanced usage of the test transport, including manually sending messages, accessing dispatched, acknowledged, and rejected messages, and using collection assertions and helpers for `EnvelopeCollection` objects.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_5\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Symfony\\Component\\Messenger\\Envelope;\nuse Symfony\\Component\\Messenger\\Stamp\\DelayStamp;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\nuse Zenstruck\\Messenger\\Test\\Transport\\TestTransport;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // manually send a message to your transport\n        $this->transport()->send(new MyMessage());\n\n        // send with stamps\n        $this->transport()->send(Envelope::wrap(new MyMessage(), [new SomeStamp()]));\n\n        // send \"pre-encoded\" message\n        $this->transport()->send(['body' => '...']);\n\n        $queue = $this->transport()->queue();\n        $dispatched = $this->transport()->dispatched();\n        $acknowledged = $this->transport()->acknowledged(); // messages successfully processed\n        $rejected = $this->transport()->rejected(); // messages not successfully processed\n\n        // The 4 above variables are all instances of Zenstruck\\Messenger\\Test\\EnvelopeCollection\n        // which is a countable iterator with the following api (using $queue for the example).\n        // Methods that return Envelope(s) actually return TestEnvelope(s) which is an Envelope\n        // decorator (all standard Envelope methods can be used) with some stamp-related assertions.\n\n        // collection assertions\n        $queue->assertEmpty();\n        $queue->assertNotEmpty();\n        $queue->assertCount(3);\n        $queue->assertContains(MyMessage::class); // contains this message\n        $queue->assertContains(MyMessage::class, 3); // contains this message 3 times\n        $queue->assertNotContains(MyMessage::class); // not contains this message\n\n        // helpers\n        $queue->count(); // number of envelopes\n        $queue->all(); // TestEnvelope[]\n        $queue->messages(); // object[] the messages unwrapped from their envelope\n        $queue->messages(MyMessage::class); // MyMessage[] just instances of the passed message class\n\n        // get specific envelope\n        $queue->first(); // TestEnvelope - first one on the collection\n        $queue->first(MyMessage::class); // TestEnvelope - first where message class is MyMessage\n        $queue->first(function(Envelope $e): bool {\n            return $e->getMessage() instanceof MyMessage && $e->getMessage()->isSomething();\n        }); // TestEnvelope - first that matches the filter callback\n\n        // Equivalent to above - use the message class as the filter function typehint to\n        // auto-filter to this message type.\n        $queue->first(fn(MyMessage $m): bool => $m->isSomething()); // TestEnvelope\n\n        // TestEnvelope stamp assertions\n        $queue->first()->assertHasStamp(DelayStamp::class);\n        $queue->first()->assertNotHasStamp(DelayStamp::class);\n\n        // reset collected messages on the transport\n        $this->transport()->reset();\n\n        // reset collected messages for all transports\n        TestTransport::resetAll();\n\n        // fluid assertions on different EnvelopeCollections\n        $this->transport()\n            ->queue()\n                ->assertNotEmpty()\n                ->assertContains(MyMessage::class)\n            ->back() // returns to the TestTransport\n            ->dispatched()\n                ->assertEmpty()\n            ->back()\n            ->acknowledged()\n                ->assertEmpty()\n            ->back()\n            ->rejected()\n                ->assertEmpty()\n            ->back()\n        ;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Messages from the Queue\nDESCRIPTION: Demonstrates how to process messages from the test transport queue. It showcases processing a specific number of messages or all messages, including the use of `processOrFail` which throws an exception if the queue is empty.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_4\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // ...some code that routes messages to your configured transport\n\n        // let's assume 3 messages are on this queue\n        $this->transport()->queue()->assertCount(3);\n\n        $this->transport()->process(1); // process one message\n        $this->transport()->processOrFail(1); // equivalent to above but fails if queue empty\n\n        $this->transport()->queue()->assertCount(2); // queue now only has 2 items\n\n        $this->transport()->process(); // process all messages on the queue\n        $this->transport()->processOrFail(); // equivalent to above but fails if queue empty\n\n        $this->transport()->queue()->assertEmpty(); // queue is now empty\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Messenger Transport for Testing\nDESCRIPTION: Overrides the messenger transport configuration for the test environment in `config/packages/messenger.yaml`.  This configures the `async` transport to use the `test://` transport provided by zenstruck/messenger-test, allowing for message interception and assertions in tests.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                async: test://\n```\n\n----------------------------------------\n\nTITLE: Testing Single Bus Dispatch - PHP\nDESCRIPTION: This PHP code demonstrates testing message dispatch on a single message bus using the `InteractsWithMessenger` trait. It asserts that a specific number of messages have been dispatched and checks if specific message classes are present in the dispatched messages.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_17\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // ... some code that uses the bus\n\n        // Let's assume two messages are processed\n        $this->bus()->dispatched()->assertCount(2);\n\n        $this->bus()->dispatched()->assertContains(MessageA::class, 1);\n        $this->bus()->dispatched()->assertContains(MessageB::class, 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Transports - PHP\nDESCRIPTION: This PHP code demonstrates how to use the `InteractsWithMessenger` trait in a Symfony test to interact with and assert against multiple configured Messenger transports. It queues messages on the 'high' transport and checks if messages are dispatched on the 'low' transport.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_11\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        $this->transport('high')->queue();\n        $this->transport('low')->dispatched();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Delayed Actions with Clock - PHP\nDESCRIPTION: This PHP code demonstrates testing delayed message handling using `DelayStamp` and a mocked clock. It dispatches messages with delay stamps, asserts that they are initially queued, advances the clock, and asserts that they are then handled. Requires mocking time for sleep functionality.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_15\n\nLANGUAGE: php\nCODE:\n```\n// Let's say somewhere in your app, you register some actions that should occur in the future:\n\n$bus->dispatch(new Enevelope(new TakeSomeAction1(), [DelayStamp::delayFor(new \\DateInterval('P1D'))])); // will be handled in 1 day\n$bus->dispatch(new Enevelope(new TakeSomeAction2(), [DelayStamp::delayFor(new \\DateInterval('P3D'))])); // will be handled in 3 days\n\n// In your test, you can check that the action is not yet performed:\n\nclass TestDelayedActions extends KernelTestCase\n{\n    use InteractsWithMessenger;\n    use ClockSensitiveTrait;\n\n    public function testDelayedActions(): void\n    {\n        // 1. mock the clock, in order to perform sleeps\n        $clock = self::mockTime();\n\n        // 2. trigger the action that will dispatch the two messages\n\n        // ...\n\n        // 3. assert nothing happens yet\n        $transport = $this->transport('async');\n\n        $transport->process();\n        $transport->queue()->assertCount(2);\n        $transport->acknowledged()->assertCount(0);\n\n        // 4. sleep, process queue, and assert some messages have been handled\n        $clock->sleep(60 * 60 * 24); // wait one day\n        $transport->process()->acknowledged()->assertContains(TakeSomeAction1::class);\n        $this->asssertTakeSomeAction1IsHandled();\n\n        // TakeSomeAction2 is still in the queue\n        $transport->queue()->assertCount(1);\n\n        $clock->sleep(60 * 60 * 24 * 2); // wait two other days\n        $transport->process()->acknowledged()->assertContains(TakeSomeAction2::class);\n        $this->asssertTakeSomeAction2IsHandled();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions during Processing\nDESCRIPTION: Demonstrates how to control exception handling during message processing in the test transport.  It shows how to disable exception catching, which causes exceptions to be thrown, and re-enable it to catch exceptions and add them to the rejected list.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_6\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // ...some code that routes messages to your configured transport\n\n        // disable exception catching\n        $this->transport()->throwExceptions();\n\n        // if processing fails, the exception will be thrown\n        $this->transport()->process(1);\n\n        // re-enable exception catching\n        $this->transport()->catchExceptions();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Bus Dispatches - PHP\nDESCRIPTION: This PHP code demonstrates testing message dispatches across multiple message buses.  It asserts that specific buses have handled a specific number of messages and checks if certain message classes are dispatched on the correct buses.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_19\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // ... some code that use bus\n\n        // Let's assume two messages are handled by two different buses\n        $this->bus('bus-a')->dispatched()->assertCount(1);\n        $this->bus('bus-b')->dispatched()->assertCount(1);\n        $this->bus('bus-c')->dispatched()->assertCount(0);\n\n        $this->bus('bus-a')->dispatched()->assertContains(MessageA::class, 1);\n        $this->bus('bus-b')->dispatched()->assertContains(MessageB::class, 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Test Transport without Serialization - YAML\nDESCRIPTION: This snippet configures the Symfony Messenger transport to use the `test://` transport in the `test` environment and disables message serialization testing using the `test_serialization=false` parameter in the transport DSN.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                async: test://?test_serialization=false\n```\n\n----------------------------------------\n\nTITLE: Configure Multiple Test Transports - YAML\nDESCRIPTION: This snippet configures multiple Symfony Messenger transports (`low` and `high`) to use the `test://` transport in the `test` environment. This allows for testing different transport configurations separately.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                low: test://\n                high: test://\n```\n\n----------------------------------------\n\nTITLE: Configure Multiple Buses - YAML\nDESCRIPTION: This snippet configures multiple message buses in `messenger.yaml`, defining `bus_a`, `bus_b`, and `bus_c` along with setting `bus_c` as the default bus.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nframework:\n    messenger:\n        default_bus: bus_c\n        buses:\n            bus_a: ~\n            bus_b: ~\n            bus_c: ~\n```\n\n----------------------------------------\n\nTITLE: Configuring Exception Handling in DSN\nDESCRIPTION: Configures the `catch_exceptions` option in the transport DSN to disable exception catching by default for the test transport. This will cause exceptions to be thrown during processing.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                async: test://?catch_exceptions=false\n```\n\n----------------------------------------\n\nTITLE: Enable DelayStamp Support - YAML\nDESCRIPTION: This snippet configures a Symfony Messenger transport to enable support for `DelayStamp` using the `support_delay_stamp=true` parameter in the transport DSN.  Requires version 1.8.0 or later of the testing library.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                async: test://?support_delay_stamp=true\n```\n\n----------------------------------------\n\nTITLE: Disable Retries in Test Transport - YAML\nDESCRIPTION: This snippet disables message retries in the Symfony Messenger test transport by setting `disable_retries=false` in the transport DSN.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\nwhen@test:\n    framework:\n        messenger:\n            transports:\n                async: test://?disable_retries=false\n```\n\n----------------------------------------\n\nTITLE: Disable DoctrineClearEntityManagerWorkerSubscriber - YAML\nDESCRIPTION: This snippet disables the `DoctrineClearEntityManagerWorkerSubscriber` service in the `test` environment, preventing Doctrine entities from becoming detached after message processing. This is achieved by replacing the service's class with `stdClass`.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n# config/packages/messenger.yaml\n\n# ...\n\nwhen@test:\n    # ...\n\n    services:\n        # DoctrineClearEntityManagerWorkerSubscriber service\n        doctrine.orm.messenger.event_subscriber.doctrine_clear_entity_manager:\n            class: stdClass # effectively disables this service in your test env\n```\n\n----------------------------------------\n\nTITLE: Configure Clock Service - YAML\nDESCRIPTION: This snippet configures a clock service in `services.yaml`, either using a custom clock implementation or leveraging Symfony's clock component, to provide the `Psr\\Clock\\ClockInterface` dependency required for `DelayStamp` support.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n# config/services.yaml\nservices:\n    app.clock:\n        class: Some\\Clock\\Implementation\n    Psr\\Clock\\ClockInterface: '@app.clock'\n```\n\n----------------------------------------\n\nTITLE: Unblocking and Intercepting Messages\nDESCRIPTION: Demonstrates how to switch between intercepting and immediately handling messages in the test transport. It shows how to unblock the transport to handle messages as they are sent and intercept to queue them for later processing.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_8\n\nLANGUAGE: php\nCODE:\n```\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Zenstruck\\Messenger\\Test\\InteractsWithMessenger;\n\nclass MyTest extends KernelTestCase // or WebTestCase\n{\n    use InteractsWithMessenger;\n\n    public function test_something(): void\n    {\n        // disable intercept\n        $this->transport()->unblock();\n\n        // ...some code that routes messages to your configured transport\n        // ...these messages are handled immediately\n\n        // enable intercept\n        $this->transport()->intercept();\n\n        // ...some code that routes messages to your configured transport\n\n        // if messages are on the queue when calling unblock(), they are processed\n        $this->transport()->unblock();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Install Symfony Clock Component - Bash\nDESCRIPTION: This bash command installs the Symfony Clock component, which provides a PSR-20 Clock implementation required for `DelayStamp` support in the test environment.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncomposer require symfony/clock\n```\n\n----------------------------------------\n\nTITLE: Registering ZenstruckMessengerTestBundle\nDESCRIPTION: Registers the ZenstruckMessengerTestBundle in the application's bundles configuration.  This enables the bundle's features in the test environment.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nZenstruck\\Messenger\\Test\\ZenstruckMessengerTestBundle::class => ['test' => true],\n```\n\n----------------------------------------\n\nTITLE: Installing zenstruck/messenger-test\nDESCRIPTION: Installs the zenstruck/messenger-test library as a development dependency using Composer. This command adds the library to your project, allowing you to use its testing features for Symfony Messenger.\nSOURCE: https://github.com/zenstruck/messenger-test/blob/1.x/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncomposer require --dev zenstruck/messenger-test\n```"
  }
]