[
  {
    "owner": "litestar-org",
    "repo": "litestar",
    "content": "TITLE: Hello World Litestar Application in Python\nDESCRIPTION: A basic Litestar application that returns 'Hello, world!' on the root path. Demonstrates route handler definition using decorators and application instantiation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/0-application-basics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get, Litestar\n\n@get(\"/\")\nasync def hello_world() -> str:\n    return \"Hello, world!\"\n\n\napp = Litestar([hello_world])\n```\n\n----------------------------------------\n\nTITLE: Defining DTOs on Litestar Controller Layer\nDESCRIPTION: Demonstrates how to define DTOs at the controller level in Litestar, applying them to all handlers within the controller except where explicitly overridden.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/0-basic-use.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, get, post, put, delete\nfrom litestar.dto import DTOData\n\nclass UserController(Controller):\n    path = \"/users\"\n    dto = UserDTO\n    return_dto = UserReturnDTO\n\n    @post()\n    def create(self, data: DTOData[User]) -> User:\n        return User(**data.create_instance())\n\n    @get(\"/{user_id:uuid}\")\n    def get(self, user_id: UUID) -> User:\n        return get_user(user_id)\n\n    @put(\"/{user_id:uuid}\")\n    def update(self, user_id: UUID, data: DTOData[User]) -> User:\n        return update_user(user_id, data.create_instance())\n\n    @delete(\"/{user_id:uuid}\", return_dto=None)\n    def delete(self, user_id: UUID) -> None:\n        delete_user(user_id)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Class-based Controller in Litestar\nDESCRIPTION: Shows how to create a class-based controller with multiple HTTP methods for handling user-related operations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/PYPI_README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List, Optional\nfrom datetime import datetime\n\nfrom litestar import Controller, get, post, put, patch, delete\nfrom litestar.dto import DTOData\nfrom pydantic import UUID4\n\nfrom my_app.models import User, PartialUserDTO\n\n\nclass UserController(Controller):\n    path = \"/users\"\n\n    @post()\n    async def create_user(self, data: User) -> User: ...\n\n    @get()\n    async def list_users(self) -> List[User]: ...\n\n    @get(path=\"/{date:int}\")\n    async def list_new_users(self, date: datetime) -> List[User]: ...\n\n    @patch(path=\"/{user_id:uuid}\", dto=PartialUserDTO)\n    async def partial_update_user(\n        self, user_id: UUID4, data: DTOData[PartialUserDTO]\n    ) -> User: ...\n\n    @put(path=\"/{user_id:uuid}\")\n    async def update_user(self, user_id: UUID4, data: User) -> User: ...\n\n    @get(path=\"/{user_name:str}\")\n    async def get_user_by_name(self, user_name: str) -> Optional[User]: ...\n\n    @get(path=\"/{user_id:uuid}\")\n    async def get_user(self, user_id: UUID4) -> User: ...\n\n    @delete(path=\"/{user_id:uuid}\")\n    async def delete_user(self, user_id: UUID4) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Basic Route Handler Registration in Python\nDESCRIPTION: Demonstrates how to register basic route handlers with the Litestar application instance using decorators.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n@get(\"/sub-path\")\ndef sub_path_handler() -> None: ...\n\n@get()\ndef root_handler() -> None: ...\n\napp = Litestar(route_handlers=[root_handler, sub_path_handler])\n```\n\n----------------------------------------\n\nTITLE: Implementing a CRUD Controller in Litestar\nDESCRIPTION: Example of a class-based controller implementation with CRUD operations (Create, Read, Update, Delete) for a User model, demonstrating route handlers with different HTTP methods.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List\n\nfrom litestar import Controller, get, post, put, patch, delete\nfrom litestar.dto import DTOData\nfrom pydantic import UUID4\n\nfrom my_app.models import User, PartialUserDTO\n\n\nclass UserController(Controller):\n    path = \"/users\"\n\n    @post()\n    async def create_user(self, data: User) -> User: ...\n\n    @get()\n    async def list_users(self) -> List[User]: ...\n\n    @patch(path=\"/{user_id:uuid}\", dto=PartialUserDTO)\n    async def partial_update_user(\n        self, user_id: UUID4, data: DTOData[User]\n    ) -> User: ...\n\n    @put(path=\"/{user_id:uuid}\")\n    async def update_user(self, user_id: UUID4, data: User) -> User: ...\n\n    @get(path=\"/{user_id:uuid}\")\n    async def get_user(self, user_id: UUID4) -> User: ...\n\n    @delete(path=\"/{user_id:uuid}\")\n    async def delete_user(self, user_id: UUID4) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging with Python Standard Library in Litestar (Python)\nDESCRIPTION: This example demonstrates how to use Python's standard logging library with Litestar's LoggingConfig. It configures a root logger and uses it both inside and outside request handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/logging.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom litestar import Litestar, Request, get\nfrom litestar.logging import LoggingConfig\n\nlogging_config = LoggingConfig(\n    root={\"level\": \"INFO\", \"handlers\": [\"queue_listener\"]},\n    formatters={\n        \"standard\": {\"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"}\n    },\n    log_exceptions=\"always\",\n)\n\nlogger = logging_config.configure()()\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -> None:\n    request.logger.info(\"inside a request\")\n    logger.info(\"here too\")\n\n\napp = Litestar(\n    route_handlers=[my_router_handler],\n    logging_config=logging_config,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Database Connection with Startup and Shutdown Hooks in Litestar\nDESCRIPTION: Example demonstrating how to establish and close a database connection using SQLAlchemy async engine with Litestar's startup and shutdown hooks.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = None\n\nasync def get_engine():\n    global engine\n    engine = create_async_engine(\"postgresql+asyncpg://user:pass@localhost/db\")\n\nasync def close_engine():\n    if engine is not None:\n        await engine.dispose()\n\napp = Litestar(on_startup=[get_engine], on_shutdown=[close_engine], route_handlers=[...])\n```\n\n----------------------------------------\n\nTITLE: Implementing SQLAlchemyInitPlugin in Litestar Application\nDESCRIPTION: This code snippet shows a full Litestar application using the SQLAlchemyInitPlugin. It demonstrates how to configure the plugin, create models, and use the automatically provided database session in route handlers and dependency providers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/3-init-plugin.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/contrib/sqlalchemy/plugins/tutorial/full_app_with_init_plugin.py\n    :language: python\n    :linenos:\n    :emphasize-lines: 12, 28, 76-78, 85\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Middleware in Litestar\nDESCRIPTION: This snippet demonstrates how to enable CORS (Cross-Origin Resource Sharing) in a Litestar application by passing a CORSConfig instance to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.config.cors import CORSConfig\n\ncors_config = CORSConfig(allow_origins=[\"https://www.example.com\"])\n\napp = Litestar(route_handlers=[...], cors_config=cors_config)\n```\n\n----------------------------------------\n\nTITLE: Handling POST Requests for Creating TODO Items in Python with Litestar\nDESCRIPTION: This snippet demonstrates how to create a route handler for adding new TODO items using the POST HTTP method. It uses type annotations for data validation and conversion of incoming JSON data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/2-interacting-with-the-list.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@post(\"/\")\nasync def add_item(data: Dict[str, Any]) -> Dict[str, Any]:\n    todo_list.append(data)\n    return {\"message\": \"Item added successfully\", \"data\": data}\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimal Litestar Application\nDESCRIPTION: A minimal example showing how to create a simple Litestar application with two route handlers: one returning a string and another returning a dictionary based on a path parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\nasync def index() -> str:\n    return \"Hello, world!\"\n\n\n@get(\"/books/{book_id:int}\")\nasync def get_book(book_id: int) -> dict[str, int]:\n    return {\"book_id\": book_id}\n\n\napp = Litestar([index, get_book])\n```\n\n----------------------------------------\n\nTITLE: Using DTOData with Person Model in Litestar\nDESCRIPTION: Demonstrates how to use DTOData to handle data parsing and instance creation in a Litestar handler function. The code shows how to work with DTOData to validate incoming data and create Person instances with generated IDs.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/08-dto-data.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.dto.data_structures import DTOData\n\nasync def create_person(data: DTOData[Person]) -> Person:\n    return data.create_instance(id=123)\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Litestar Application\nDESCRIPTION: Demonstrates how to create a basic Litestar application with a single route handler function returning a JSON response.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/PYPI_README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\nasync def hello_world() -> dict[str, str]:\n    \"\"\"Keeping the tradition alive with hello world.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Litestar(route_handlers=[hello_world])\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Query Parameter Validation in Python with Litestar\nDESCRIPTION: This snippet adds manual validation for the 'done' query parameter. It demonstrates how to handle invalid inputs and raise HTTP exceptions for error responses in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom litestar import Litestar, get\nfrom litestar.exceptions import HTTPException\n\n\n@dataclass\nclass TodoItem:\n    id: str\n    item: str\n    done: bool\n\n\n@get(\"/\")\ndef get_list(done: str) -> List[TodoItem]:\n    todos = [\n        TodoItem(id=\"1\", item=\"Make this list more useful\", done=False),\n        TodoItem(id=\"2\", item=\"Buy groceries\", done=False),\n        TodoItem(id=\"3\", item=\"Do laundry\", done=True),\n    ]\n    if done == \"1\":\n        return [todo for todo in todos if todo.done]\n    elif done == \"0\":\n        return [todo for todo in todos if not todo.done]\n    raise HTTPException(status_code=400, detail=\"Invalid value for 'done' parameter\")\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Implementing SQLAlchemy Serialization Plugin in Litestar Application\nDESCRIPTION: This code snippet demonstrates the integration of the SQLAlchemy Serialization Plugin into a Litestar application. It shows the import of the plugin, its addition to the app's plugin list, and the simplified handler implementations that can now directly use SQLAlchemy models.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/2-serialization-plugin.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/contrib/sqlalchemy/plugins/tutorial/full_app_with_serialization_plugin.py\n    :language: python\n    :linenos:\n    :emphasize-lines: 12, 75-77, 80-83, 86-91, 98\n```\n\n----------------------------------------\n\nTITLE: Using Application State in Litestar\nDESCRIPTION: Demonstrates how to use application state to share contextual data between different parts of a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.datastructures import State\n\nasync def startup(app: Litestar) -> None:\n    app.state.counter = 0\n\n@get(\"/\")\ndef handler(state: State) -> dict:\n    state.counter += 1\n    return {\"count\": state.counter}\n\napp = Litestar(route_handlers=[handler], on_startup=[startup])\n```\n\n----------------------------------------\n\nTITLE: Layered Exception Handlers\nDESCRIPTION: Example demonstrating the layered approach to exception handling with handlers at different levels of the application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/exceptions.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, post, Litestar, get\nfrom litestar.exceptions import ValidationException\n\n\napp_level_handler = ...\n\nclass MyController(Controller):\n    path = \"/users\"\n    exception_handlers = {ValidationException: controller_level_handler}\n\n    @post(exception_handlers={ValidationException: route_level_handler})\n    async def create_user(self) -> None: ...\n\n\napp = Litestar(\n    route_handlers=[MyController],\n    exception_handlers={ValidationException: app_level_handler},\n)\n```\n\n----------------------------------------\n\nTITLE: Using JWT Auth Backend in Python\nDESCRIPTION: Example of using the base JWT Auth backend in Litestar. This backend uses headers for JWT token transmission.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Using Session Auth Backend in Litestar\nDESCRIPTION: This code snippet demonstrates how to use the session auth backend in Litestar. It includes the necessary imports, configuration of the session auth backend, and creation of a Litestar application with the configured auth backend.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/security-backends.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.contrib.jwt import JWTAuth\nfrom litestar.security.session_auth import SessionAuth\nfrom litestar.store.memory import MemoryStore\n\nauth = SessionAuth(\n    auth_redirect=\"/login\",\n    exclude=[\"login\"],\n    jwt_auth=JWTAuth[User](\"secret\", token_expiration=3600),\n    session_backend=MemoryStore(),\n)\n\napp = Litestar(route_handlers=[...], middleware=[auth.middleware])\n```\n\n----------------------------------------\n\nTITLE: Nested Dependencies Implementation\nDESCRIPTION: Shows how to implement dependencies that depend on other dependencies, demonstrating dependency chaining.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.di import Provide\nfrom random import randint\n\n\ndef first_dependency() -> int:\n    return randint(1, 10)\n\n\ndef second_dependency(injected_integer: int) -> bool:\n    return injected_integer % 2 == 0\n\n\n@get(\"/true-or-false\")\ndef true_or_false_handler(injected_bool: bool) -> str:\n    return \"its true!\" if injected_bool else \"nope, its false...\"\n\n\napp = Litestar(\n    route_handlers=[true_or_false_handler],\n    dependencies={\n        \"injected_integer\": Provide(first_dependency),\n        \"injected_bool\": Provide(second_dependency),\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving TODO Items with GET Handler in Python\nDESCRIPTION: Implements a GET route handler that returns a list of TODO items with optional filtering by completion status. Uses an Optional[bool] query parameter for filtering.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/3-assembling-the-app.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\")\nasync def get_items(self, done: Optional[bool] = None) -> list[TodoItem]:\n    if done is None:\n        return self.todo_items\n    return [item for item in self.todo_items if item.done == done]\n```\n\n----------------------------------------\n\nTITLE: Implementing PUT Handler for Full Updates in Litestar\nDESCRIPTION: This snippet demonstrates how to create a PUT handler in Litestar for updating a Person instance. It uses DTOData.update_instance() to apply full updates to the existing data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/09-updating.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/data_transfer_objects/factory/tutorial/put_handlers.py\n   :language: python\n   :linenos:\n   :emphasize-lines: 25,28,29\n```\n\n----------------------------------------\n\nTITLE: Basic Dependency Injection Implementation in Litestar\nDESCRIPTION: Demonstrates the basic structure of declaring dependencies at different layers of a Litestar application including app, router, controller and handler levels.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, Router, Litestar, get\nfrom litestar.di import Provide\n\n\nasync def bool_fn() -> bool: ...\n\n\nasync def dict_fn() -> dict: ...\n\n\nasync def list_fn() -> list: ...\n\n\nasync def int_fn() -> int: ...\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    # on the controller\n    dependencies = {\"controller_dependency\": Provide(list_fn)}\n\n    # on the route handler\n    @get(path=\"/handler\", dependencies={\"local_dependency\": Provide(int_fn)})\n    def my_route_handler(\n        self,\n        app_dependency: bool,\n        router_dependency: dict,\n        controller_dependency: list,\n        local_dependency: int,\n    ) -> None: ...\n\n\n# on the router\nmy_router = Router(\n    path=\"/router\",\n    dependencies={\"router_dependency\": Provide(dict_fn)},\n    route_handlers=[MyController],\n)\n\n# on the app\napp = Litestar(\n    route_handlers=[my_router], dependencies={\"app_dependency\": Provide(bool_fn)}\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth2 Password Bearer Flow in Python\nDESCRIPTION: Example of using the OAuth2PasswordBearerAuth backend for OAuth 2.0 Bearer password flows in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Defining SQLAlchemy Models with UUIDBase in Python\nDESCRIPTION: This snippet demonstrates how to define SQLAlchemy models using the UUIDBase class provided by Litestar. It includes examples of different field types and relationships.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/models_and_repository.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import List\n\nfrom sqlalchemy import String, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom advanced_alchemy.base import UUIDBase\n\n\nclass User(UUIDBase):\n    name: Mapped[str] = mapped_column(String(100))\n    email: Mapped[str] = mapped_column(String(100), unique=True, index=True)\n    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)\n    articles: Mapped[List[\"Article\"]] = relationship(back_populates=\"author\")\n\n\nclass Article(UUIDBase):\n    title: Mapped[str] = mapped_column(String(100))\n    content: Mapped[str]\n    author_id: Mapped[str] = mapped_column(ForeignKey(\"user.id\"))\n    author: Mapped[User] = relationship(back_populates=\"articles\")\n```\n\n----------------------------------------\n\nTITLE: Complete Database Models for Author and Book in Python\nDESCRIPTION: This comprehensive code snippet includes the full implementation of both Author and Book models, showcasing the use of UUIDBase and UUIDAuditBase classes, relationships, and various field types.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/01-modelling-and-features.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom datetime import date\nfrom typing import TYPE_CHECKING\nfrom uuid import UUID\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom advanced_alchemy.base import UUIDAuditBase, UUIDBase\n\nif TYPE_CHECKING:\n    from sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass Author(UUIDBase):\n    name: Mapped[str]\n    dob: Mapped[date]\n    books: Mapped[list[Book]] = relationship(\n        \"Book\", back_populates=\"author\", cascade=\"all, delete-orphan\"\n    )\n\n\nclass Book(UUIDAuditBase):\n    title: Mapped[str]\n    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n    author: Mapped[Author] = relationship(Author, back_populates=\"books\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Async SQLAlchemy Repository in Litestar Controller\nDESCRIPTION: This code snippet shows how to use the SQLAlchemy async repository in a Litestar controller. It includes CRUD operations and pagination for a User model.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/models_and_repository.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, get, post, put, patch, delete\nfrom litestar.di import Provide\nfrom litestar.params import Parameter\nfrom litestar.repository.filters import LimitOffset\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom .models import User\n\n\nclass UserRepository(SQLAlchemyAsyncRepository[User]):\n    model_type = User\n\n\nasync def provide_user_repo(db_session: AsyncSession) -> UserRepository:\n    return UserRepository(session=db_session)\n\n\nclass UserController(Controller):\n    path = \"/users\"\n    dependencies = {\"repo\": Provide(provide_user_repo)}\n\n    @get()\n    async def list_users(self, repo: UserRepository, limit_offset: LimitOffset) -> list[User]:\n        return await repo.list(limit_offset)\n\n    @post()\n    async def create_user(self, repo: UserRepository, data: User) -> User:\n        return await repo.add(data)\n\n    @get(\"/{user_id:uuid}\")\n    async def get_user(self, repo: UserRepository, user_id: UUID) -> User:\n        return await repo.get(user_id)\n\n    @put(\"/{user_id:uuid}\")\n    async def update_user(self, repo: UserRepository, user_id: UUID, data: User) -> User:\n        return await repo.update(user_id, data)\n\n    @patch(\"/{user_id:uuid}\")\n    async def partial_update_user(self, repo: UserRepository, user_id: UUID, data: dict) -> User:\n        return await repo.update(user_id, data, partial=True)\n\n    @delete(\"/{user_id:uuid}\")\n    async def delete_user(self, repo: UserRepository, user_id: UUID) -> None:\n        await repo.delete(user_id)\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic TODO List Endpoint in Python with Litestar\nDESCRIPTION: This snippet creates a simple Litestar app with a single route handler that returns a list of TODO items as dictionaries. It demonstrates basic usage of Litestar for creating a JSON API endpoint.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Dict, List, Union\n\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\ndef get_list() -> List[Dict[str, Union[str, bool]]]:\n    return [\n        {\"id\": \"1\", \"item\": \"Make this list more useful\", \"done\": False},\n        {\"id\": \"2\", \"item\": \"Buy groceries\", \"done\": False},\n        {\"id\": \"3\", \"item\": \"Do laundry\", \"done\": True},\n    ]\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Implementing SQLAlchemy Async Serialization Plugin\nDESCRIPTION: Example showing how to implement the SQLAlchemy serialization plugin in an async context. The code demonstrates model definition, handler creation, and plugin usage in a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_serialization_plugin.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom litestar import Litestar, get\nfrom litestar.contrib.sqlalchemy.plugins import SQLAlchemySerializationPlugin\nfrom sqlalchemy import String, select\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import BigIntBase\n\n\nclass User(BigIntBase):\n    name: Mapped[str] = mapped_column(String(length=100))\n\n\n@get(\"/users/{user_id:int}\")\nasync def get_user(user_id: int) -> User:\n    return await User.select()\n\n\n@get(\"/users\")\nasync def list_users() -> list[User]:\n    return await User.select()\n\n\napp = Litestar([get_user, list_users], plugins=[SQLAlchemySerializationPlugin()])\n```\n\n----------------------------------------\n\nTITLE: Creating TODO Items with POST Handler in Python\nDESCRIPTION: Implements a POST route handler that creates new TODO items. Accepts TodoItem data in JSON format and adds it to the list of items.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/3-assembling-the-app.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@post(\"/\")\nasync def add_item(self, data: TodoItem) -> TodoItem:\n    self.todo_items.append(data)\n    return data\n```\n\n----------------------------------------\n\nTITLE: Implementing Sync SQLAlchemy Repository in Litestar Controller\nDESCRIPTION: This code snippet demonstrates how to use the SQLAlchemy sync repository in a Litestar controller. It includes CRUD operations and pagination for a User model.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/models_and_repository.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, get, post, put, patch, delete\nfrom litestar.di import Provide\nfrom litestar.params import Parameter\nfrom litestar.repository.filters import LimitOffset\nfrom advanced_alchemy.repository import SQLAlchemySyncRepository\nfrom sqlalchemy.orm import Session\n\nfrom .models import User\n\n\nclass UserRepository(SQLAlchemySyncRepository[User]):\n    model_type = User\n\n\ndef provide_user_repo(db_session: Session) -> UserRepository:\n    return UserRepository(session=db_session)\n\n\nclass UserController(Controller):\n    path = \"/users\"\n    dependencies = {\"repo\": Provide(provide_user_repo)}\n\n    @get()\n    def list_users(self, repo: UserRepository, limit_offset: LimitOffset) -> list[User]:\n        return repo.list(limit_offset)\n\n    @post()\n    def create_user(self, repo: UserRepository, data: User) -> User:\n        return repo.add(data)\n\n    @get(\"/{user_id:uuid}\")\n    def get_user(self, repo: UserRepository, user_id: UUID) -> User:\n        return repo.get(user_id)\n\n    @put(\"/{user_id:uuid}\")\n    def update_user(self, repo: UserRepository, user_id: UUID, data: User) -> User:\n        return repo.update(user_id, data)\n\n    @patch(\"/{user_id:uuid}\")\n    def partial_update_user(self, repo: UserRepository, user_id: UUID, data: dict) -> User:\n        return repo.update(user_id, data, partial=True)\n\n    @delete(\"/{user_id:uuid}\")\n    def delete_user(self, repo: UserRepository, user_id: UUID) -> None:\n        repo.delete(user_id)\n```\n\n----------------------------------------\n\nTITLE: Applying Guards at Different Levels in Litestar Application\nDESCRIPTION: Demonstrates how to apply guards at various levels of a Litestar application: on the Litestar instance, routers, controllers, and individual route handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/guards.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\napp = Litestar(guards=[some_guard])\n\nrouter = Router(\"/some-path\", guards=[some_guard])\n\n@controller(\"/some-path\", guards=[some_guard])\nclass SomeController:\n    @get(\"/\", guards=[some_guard])\n    def some_handler(self) -> None:\n        ...\n\n@get(\"/\", guards=[some_guard])\ndef some_handler() -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Adding Process Time Header Middleware in Python\nDESCRIPTION: Illustrates how to create a middleware that adds a process time header to all outgoing responses. This example uses the MiddlewareProtocol and demonstrates modifying the ASGI response message.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom litestar.datastructures import MutableScopeHeaders\nfrom litestar.types import Message, Receive, Scope, Send\nfrom litestar.middleware.base import MiddlewareProtocol\nfrom litestar.types import ASGIApp\n\n\nclass ProcessTimeHeader(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -> None:\n        super().__init__(app)\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] == \"http\":\n            start_time = time.monotonic()\n\n            async def send_wrapper(message: Message) -> None:\n                if message[\"type\"] == \"http.response.start\":\n                    process_time = time.monotonic() - start_time\n                    headers = MutableScopeHeaders.from_message(message=message)\n                    headers[\"X-Process-Time\"] = str(process_time)\n                await send(message)\n\n            await self.app(scope, receive, send_wrapper)\n        else:\n            await self.app(scope, receive, send)\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging with LoggingConfig in Litestar (Python)\nDESCRIPTION: This snippet demonstrates how to configure logging for a Litestar application using LoggingConfig. It sets up a root logger with INFO level and a queue listener handler, and includes a custom formatter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/logging.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom litestar import Litestar, Request, get\nfrom litestar.logging import LoggingConfig\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -> None:\n    request.logger.info(\"inside a request\")\n    return None\n\n\nlogging_config = LoggingConfig(\n    root={\"level\": \"INFO\", \"handlers\": [\"queue_listener\"]},\n    formatters={\n        \"standard\": {\"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"}\n    },\n    log_exceptions=\"always\",\n)\n\napp = Litestar(route_handlers=[my_router_handler], logging_config=logging_config)\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthorController with CRUD Operations in Python\nDESCRIPTION: This class defines an AuthorController with five routes for interacting with the Author model. It includes methods for creating, reading, updating, and deleting authors, as well as a paginated list endpoint.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/03-repository-controller.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass AuthorController(Controller):\n    path = \"/authors\"\n\n    @post()\n    async def create_author(\n        self, data: Author, repo: AuthorRepository[Author] = Depends(get_author_repo)\n    ) -> Author:\n        return await repo.add(data)\n\n    @get()\n    async def list_authors(\n        self,\n        repo: AuthorRepository[Author] = Depends(get_author_repo_with_books),\n        paginator: Paginator = Depends(Paginator),\n    ) -> Page[Author]:\n        statement = select(Author)\n        return await paginator.paginate(repo, statement)\n\n    @get(\"/{author_id:int}\")\n    async def get_author(\n        self,\n        author_id: int,\n        repo: AuthorRepository[Author] = Depends(get_author_repo_with_books),\n    ) -> Author:\n        author = await repo.get(author_id)\n        if not author:\n            raise NotFoundException(detail=\"Author not found\")\n        return author\n\n    @patch(\"/{author_id:int}\")\n    async def update_author(\n        self,\n        author_id: int,\n        data: Author,\n        repo: AuthorRepository[Author] = Depends(get_author_repo),\n    ) -> Author:\n        db_obj = await repo.get(author_id)\n        if not db_obj:\n            raise NotFoundException(detail=\"Author not found\")\n        return await repo.update(db_obj, data)\n\n    @delete(\"/{author_id:int}\")\n    async def delete_author(\n        self,\n        author_id: int,\n        repo: AuthorRepository[Author] = Depends(get_author_repo),\n    ) -> None:\n        db_obj = await repo.get(author_id)\n        if not db_obj:\n            raise NotFoundException(detail=\"Author not found\")\n        await repo.delete(db_obj)\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Revocation in Python\nDESCRIPTION: Example of implementing token revocation by maintaining a list of revoked tokens and checking against it during authentication.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: SQLAlchemy Handler Route Implementation\nDESCRIPTION: Example of a Litestar route handler using SQLAlchemy, demonstrating how to access the engine from application state and execute database operations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/0-introduction.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def get_items(state: State) -> TodoCollectionType:\n    async with AsyncSession(state.engine) as session:\n        result = await session.execute(select(TodoItem))\n        return [serialize_todo(item) for item in result.scalars().all()]\n```\n\n----------------------------------------\n\nTITLE: Configuring Middleware with DefineMiddleware in Python\nDESCRIPTION: Demonstrates how to use DefineMiddleware to pass positional and keyword arguments to middleware factory functions. The example shows creation of a custom middleware with parameters and its integration into a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.types import ASGIApp, Scope, Receive, Send\nfrom litestar import Litestar\nfrom litestar.middleware import DefineMiddleware\n\n\ndef middleware_factory(my_arg: int, *, app: ASGIApp, my_kwarg: str) -> ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> None:\n        # here we can use my_arg and my_kwarg for some purpose\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n\n\napp = Litestar(\n    route_handlers=[...],\n    middleware=[DefineMiddleware(middleware_factory, 1, my_kwarg=\"abc\")],\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Admin User Guard for Route Authorization in Python\nDESCRIPTION: Implements an 'admin_user_guard' function that checks if the user associated with the connection is an admin. If not, it raises a NotAuthorizedException.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/guards.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef admin_user_guard(connection: Request, _: BaseRouteHandler) -> None:\n    if connection.user.role is not UserRole.ADMIN:\n        raise NotAuthorizedException()\n\n@post(\"/users\", guards=[admin_user_guard])\ndef create_user(data: User) -> User:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Encoding and Decoding in Litestar\nDESCRIPTION: Demonstrates how to create custom type encoders and decoders for handling custom data types in Litestar. The example shows implementation of encoding/decoding functions and their registration with the Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/custom-types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n/examples/encoding_decoding/custom_type_encoding_decoding.py\n```\n\n----------------------------------------\n\nTITLE: Implementing CustomAuthenticationMiddleware in Python\nDESCRIPTION: This snippet shows the implementation of a CustomAuthenticationMiddleware class that extends AbstractAuthenticationMiddleware and performs token-based authentication.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass CustomAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n    async def authenticate_request(self, connection: ASGIConnection) -> AuthenticationResult:\n        if \"Authorization\" not in connection.headers:\n            return AuthenticationResult(user=None, auth=None)\n\n        token = connection.headers[\"Authorization\"]\n        user = await get_user_by_token(token)\n\n        if user is None:\n            return AuthenticationResult(user=None, auth=None)\n\n        return AuthenticationResult(user=user, auth=token)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Stream with Listener Pattern\nDESCRIPTION: Shows how to implement concurrent streaming and data receiving using a WebSocket listener pattern. Includes error handling and disconnect management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@websocket_listener(\"/ws\")\nasync def on_receive(data: dict, socket: WebSocket) -> None:\n    print(f\"received {data}\")\n\n@websocket(\"/ws\")\nasync def handler(socket: WebSocket) -> None:\n    async def counter() -> AsyncGenerator[int, None]:\n        for i in range(5):\n            yield i\n            await asyncio.sleep(1)\n\n    await send_websocket_stream(\n        socket,\n        counter(),\n        listen_for_disconnect=False,\n    )\n```\n\n----------------------------------------\n\nTITLE: Using the 'return_dto' Parameter in Litestar Route Handler\nDESCRIPTION: Shows how to use both 'dto' and 'return_dto' parameters in a Litestar route handler to handle decoding of client data and encoding of the response separately.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/0-basic-use.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import post\nfrom litestar.dto import DTOData\n\n@post(\"/users\", return_dto=UserReturnDTO)\ndef create_user(data: DTOData[User]) -> User:\n    return User(**data.create_instance())\n```\n\n----------------------------------------\n\nTITLE: Paginated Data Selection with SQLAlchemy Repository in Python\nDESCRIPTION: This snippet shows how to select multiple records with pagination using the LimitOffset filter type.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    state_repo = context.get_repository(StateRepository)\n    paginated_states = await state_repo.list(LimitOffset(limit=10, offset=0))\n```\n\n----------------------------------------\n\nTITLE: Basic Event Handling Implementation in Litestar\nDESCRIPTION: Demonstrates basic event listener pattern using a user creation example with email notification. Shows how to create a listener for user creation events and emit events from route handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom litestar import Request, post\nfrom litestar.events import listener\nfrom litestar import Litestar\n\nfrom db import user_repository\nfrom utils.email import send_welcome_mail\n\n\n@listener(\"user_created\")\nasync def send_welcome_email_handler(email: str) -> None:\n    # do something here to send an email\n    await send_welcome_mail(email)\n\n\n@dataclass\nclass CreateUserDTO:\n    first_name: str\n    last_name: str\n    email: str\n\n\n@post(\"/users\")\nasync def create_user_handler(data: UserDTO, request: Request) -> None:\n    # do something here to create a new user\n    # e.g. insert the user into a database\n    await user_repository.insert(data)\n\n    # assuming we have now inserted a user, we want to send a welcome email.\n    # To do this in a none-blocking fashion, we will emit an event to a listener, which will send the email,\n    # using a different async block than the one where we are returning a response.\n    request.app.emit(\"user_created\", email=data.email)\n\n\napp = Litestar(\n    route_handlers=[create_user_handler], listeners=[send_welcome_email_handler]\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Routing in Flask and Litestar\nDESCRIPTION: Demonstrates how to set up basic routing in Flask and Litestar. Shows the creation of an application instance and defining routes for the index and hello pages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    return \"Index Page\"\n\n\n@app.route(\"/hello\")\ndef hello():\n    return \"Hello, World\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\ndef index() -> str:\n    return \"Index Page\"\n\n\n@get(\"/hello\")\ndef hello() -> str:\n    return \"Hello, World\"\n\n\napp = Litestar([index, hello])\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Handlers for TODO Items in Python\nDESCRIPTION: This snippet defines route handlers for creating, retrieving, and updating TODO items. It uses the transaction dependency for database operations and the utility functions for data retrieval.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/4-final-touches-and-recap.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import post, get, patch\nfrom litestar.dto import DTOData\n\n@post(\"/todo\")\nasync def create_todo_item(data: DTOData[TodoItem], session: Session = Depends(transaction)) -> TodoItem:\n    todo_item = TodoItem(**data.as_builtins())\n    session.add(todo_item)\n    return todo_item\n\n@get(\"/todo\")\nasync def list_todo_items(session: Session = Depends(transaction)) -> list[TodoItem]:\n    return await get_all_todo_items(session)\n\n@get(\"/todo/{todo_id:int}\")\nasync def get_todo_item_by_id(todo_id: int, session: Session = Depends(transaction)) -> TodoItem:\n    return await get_todo_item(session, todo_id)\n\n@patch(\"/todo/{todo_id:int}\")\nasync def update_todo_item(todo_id: int, data: DTOData[TodoItem], session: Session = Depends(transaction)) -> TodoItem:\n    todo_item = await get_todo_item(session, todo_id)\n    for key, value in data.as_builtins().items():\n        setattr(todo_item, key, value)\n    return todo_item\n```\n\n----------------------------------------\n\nTITLE: Configuring Litestar Application with SQLAlchemy Plugin in Python\nDESCRIPTION: This snippet shows the final application configuration using the SQLAlchemyPlugin. It sets up the database connection, configures the plugin, and registers the transaction dependency.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/4-final-touches-and-recap.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.contrib.sqlalchemy.plugins import SQLAlchemyPlugin\n\napp = Litestar(\n    route_handlers=[create_todo_item, list_todo_items, get_todo_item_by_id, update_todo_item],\n    plugins=[SQLAlchemyPlugin(connection_string=\"sqlite+aiosqlite:///todo.db\")],\n    dependencies={\"transaction\": transaction},\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Data Models with Pydantic\nDESCRIPTION: Example of defining a data model using Pydantic's BaseModel for type validation and serialization in a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, UUID4\n\n\nclass User(BaseModel):\n    first_name: str\n    last_name: str\n    id: UUID4\n```\n\n----------------------------------------\n\nTITLE: Basic WebSocket Listener Implementation\nDESCRIPTION: Demonstrates a simple WebSocket listener setup that echoes received data back to the client.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.handlers.websocket_handlers import websocket_listener\n\n@websocket_listener(\"/\")\nasync def handler(data: str) -> str:\n    return data\n\napp = Litestar([handler])\n```\n\n----------------------------------------\n\nTITLE: Basic Static Files Router Configuration in Python\nDESCRIPTION: Example showing basic usage of create_static_files_router to serve files from assets directory under /static path.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(path=\"/static\", directories=[\"assets\"])\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Person Model with Nested Collection Exclusions in Python\nDESCRIPTION: This code snippet defines a Person model with a self-referencing children relationship and demonstrates how to exclude specific fields (email and address) from nested collections using the DataTransferObject decorator.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/03-nested-collection-exclude.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import List\n\nfrom litestar import Controller, get\nfrom litestar.dto import DataTransferObject\n\n\nclass Person:\n    def __init__(\n        self,\n        first_name: str,\n        last_name: str,\n        email: str,\n        address: str,\n        children: List[\"Person\"] | None = None,\n    ) -> None:\n        self.first_name = first_name\n        self.last_name = last_name\n        self.email = email\n        self.address = address\n        self.children = children or []\n\n\n@DataTransferObject(\n    exclude={\"children.0.email\", \"children.0.address\"}\n)\nclass PersonDTO(Person):\n    pass\n\n\nclass PersonController(Controller):\n    path = \"/person\"\n\n    @get()\n    def get_person(self) -> PersonDTO:\n        return Person(\n            first_name=\"John\",\n            last_name=\"Doe\",\n            email=\"john@doe.com\",\n            address=\"123 Main St\",\n            children=[\n                Person(\n                    first_name=\"Jane\",\n                    last_name=\"Doe\",\n                    email=\"jane@doe.com\",\n                    address=\"456 Oak Rd\",\n                )\n            ],\n        )\n```\n\n----------------------------------------\n\nTITLE: Explicitly Renaming Fields in Litestar DTO (Python)\nDESCRIPTION: This code snippet demonstrates how to explicitly rename fields in a Litestar DTO using the rename_fields attribute. It renames the 'address' field to 'location'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/05-renaming-fields.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get\nfrom litestar.dto import DataclassDTO, DTOConfig\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    address: str\n\n\nclass UserModelDTO(DataclassDTO[User]):\n    config = DTOConfig(\n        rename_fields={\"address\": \"location\"}\n    )\n\n\n@get(\"/\")\ndef index() -> User:\n    return User(name=\"John\", age=30, address=\"123 Main St\")\n\n\napp = Litestar(\n    route_handlers=[index],\n    dto=UserModelDTO,\n)\n```\n\n----------------------------------------\n\nTITLE: Dependencies Parameters Access\nDESCRIPTION: Shows how to access dependency parameters in FastAPI and Litestar, particularly focusing on state access.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import Request\n\nasync def get_arqredis(request: Request) -> ArqRedis:\n    return request.state.arqredis\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import State\n\nasync def get_arqredis(state: State) -> ArqRedis:\n    return state.arqredis\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Transaction Management in Python\nDESCRIPTION: This snippet defines a dependency for centralized database transaction management and error handling. It utilizes the db_session dependency provided by the SQLAlchemy plugin.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/4-final-touches-and-recap.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.exceptions import HTTPException\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm import Session\n\nasync def transaction(db_session: Session) -> AsyncGenerator[Session, None]:\n    try:\n        yield db_session\n        await db_session.commit()\n    except HTTPException:\n        await db_session.rollback()\n        raise\n    except SQLAlchemyError as e:\n        await db_session.rollback()\n        raise HTTPException(detail=str(e)) from e\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection with Database User Example\nDESCRIPTION: Shows how to implement dependency injection with a database user model, demonstrating parameter injection and UUID handling.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, patch\nfrom litestar.di import Provide\nfrom pydantic import BaseModel, UUID4\n\n\nclass User(BaseModel):\n    id: UUID4\n    name: str\n\n\nasync def retrieve_db_user(user_id: UUID4) -> User: ...\n\n\nclass UserController(Controller):\n    path = \"/user\"\n    dependencies = {\"user\": Provide(retrieve_db_user)}\n\n    @patch(path=\"/{user_id:uuid}\")\n    async def get_user(self, user: User) -> User: ...\n```\n\n----------------------------------------\n\nTITLE: Basic Response Caching in Litestar\nDESCRIPTION: Demonstrates the simplest form of response caching by setting the cache parameter to True in the route handler.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\")\n@cache()\ndef handler() -> dict[str, str]:\n    return {\"hello\": \"world\"}\n```\n\n----------------------------------------\n\nTITLE: Basic WebSocket Stream Implementation\nDESCRIPTION: Demonstrates a WebSocket stream that sends current time updates at regular intervals.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom litestar.handlers.websocket_handlers import websocket_stream\n\n@websocket_stream(\"/\")\nasync def handler() -> str:\n    while True:\n        await asyncio.sleep(0.5)\n        yield datetime.now().isoformat()\n```\n\n----------------------------------------\n\nTITLE: Defining Data Models with Dataclasses\nDESCRIPTION: Example of defining a data model using Python's standard dataclasses along with a Data Transfer Object (DTO) for partial updates.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import UUID\n\nfrom dataclasses import dataclass\nfrom litestar.dto import DTOConfig, DataclassDTO\n\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n    id: UUID\n\n\nclass PartialUserDTO(DataclassDTO[User]):\n    config = DTOConfig(exclude={\"id\"}, partial=True)\n```\n\n----------------------------------------\n\nTITLE: Converting Custom Exceptions to Problem Details Response in Litestar\nDESCRIPTION: Illustrates how to map custom exceptions to problem details responses using the ProblemDetailsPlugin. This can also be used to override the conversion of HTTPExceptions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/problem_details.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.exceptions import ProblemDetailsException\nfrom litestar.plugins.problem_details import ProblemDetailsPlugin, ProblemDetailsConfig\n\nclass CustomException(Exception):\n    pass\n\ndef custom_exception_handler(exc: CustomException) -> ProblemDetailsException:\n    return ProblemDetailsException(\n        status_code=400,\n        title=\"Custom Exception\",\n        detail=str(exc),\n        instance=\"/custom-exception\",\n        type_=\"https://example.com/errors/custom-exception\",\n    )\n\n@get(\"/\")\ndef handler() -> None:\n    raise CustomException(\"Something went wrong\")\n\napp = Litestar(\n    route_handlers=[handler],\n    plugins=[\n        ProblemDetailsPlugin(\n            config=ProblemDetailsConfig(\n                exception_mapping={CustomException: custom_exception_handler}\n            )\n        )\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Converting HTTPException to Problem Details Response in Litestar\nDESCRIPTION: Shows how to configure the ProblemDetailsPlugin to automatically convert all HTTPExceptions into problem details responses using ProblemDetailsConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/problem_details.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.exceptions import HTTPException\nfrom litestar.plugins.problem_details import ProblemDetailsPlugin, ProblemDetailsConfig\n\n@get(\"/\")\ndef handler() -> None:\n    raise HTTPException(status_code=400, detail=\"The request was invalid.\")\n\napp = Litestar(\n    route_handlers=[handler],\n    plugins=[ProblemDetailsPlugin(config=ProblemDetailsConfig(convert_http_exception=True))],\n)\n```\n\n----------------------------------------\n\nTITLE: Type Validation in Request Data\nDESCRIPTION: Shows different supported types for request data validation including dataclasses and TypedDict\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\nclass Item(TypedDict):\n    name: str\n\nasync def handler(data: Item) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLAlchemy Plugin and Litestar App in Python\nDESCRIPTION: This snippet shows how to set up the SQLAlchemy Plugin and configure the Litestar app. It includes the plugin configuration, route handler setup, and specifies the database initialization function for both async and sync implementations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsqlalchemy_plugin = SQLAlchemyPlugin(\n    config=SQLAlchemyAsyncConfig(\n        connection_string=\"sqlite+aiosqlite:///todo.sqlite\",\n        engine_instance_hook=init_db,\n    )\n)\napp = Litestar(route_handlers=[add_todo_item], plugins=[sqlalchemy_plugin])\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Cookie Auth in Python\nDESCRIPTION: Demonstration of using the JWT Cookie Auth backend, which uses cookies instead of headers for JWT token transmission.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Enabling CSRF Protection in Litestar\nDESCRIPTION: This code shows how to enable CSRF (Cross-Site Request Forgery) protection in a Litestar application by creating a CSRFConfig instance and passing it to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, post\nfrom litestar.config.csrf import CSRFConfig\n\n\n@get()\nasync def get_resource() -> str:\n    # GET is one of the safe methods\n    return \"some_resource\"\n\n@post(\"{id:int}\")\nasync def create_resource(id: int) -> bool:\n    # POST is one of the unsafe methods\n    return True\n\ncsrf_config = CSRFConfig(secret=\"my-secret\")\n\napp = Litestar([get_resource, create_resource], csrf_config=csrf_config)\n```\n\n----------------------------------------\n\nTITLE: Modifying Application Configuration with on_app_init Hook in Litestar (Python)\nDESCRIPTION: This example shows how to use the 'on_app_init' hook in Litestar to modify the application configuration before the application is instantiated. The hook receives an AppConfig instance and must return a modified AppConfig instance.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/application_hooks/on_app_init.py\n    :language: python\n    :caption: Example usage of the ``on_app_init`` hook to modify the application configuration.\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Injection in Litestar\nDESCRIPTION: Demonstrates how to use dependency injection in Litestar by defining a dependency and injecting it into a route handler.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/PYPI_README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.di import Provide\n\n\nasync def my_dependency() -> str: ...\n\n\n@get(\"/\")\nasync def index(injected: str) -> str:\n    return injected\n\n\napp = Litestar([index], dependencies={\"injected\": Provide(my_dependency)})\n```\n\n----------------------------------------\n\nTITLE: Advanced HTMX Response Handlers with DOM Manipulation\nDESCRIPTION: Collection of advanced HTMX response handlers that can modify the DOM, including location changes, URL updates, and event triggering.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/htmx.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/about\")\ndef handler() -> HXLocation:\n    ...\n    return HXLocation(\n        redirect_to=\"/contact-us\",\n        # Optional parameters\n        source,  # the source element of the request.\n        event,  # an event that \"triggered\" the request.\n        target=\"#target\",  # element id to target to.\n        swap=\"outerHTML\",  # swapping method to use.\n        hx_headers={\"attr\": \"val\"},  # headers to pass to HTMX.\n        values={\"val\": \"one\"},\n    )\n\n@get(\"/about\")\ndef handler() -> PushUrl:\n    ...\n    return PushUrl(content=\"Success!\", push_url=\"/about\")\n\n@get(\"/contact-us\")\ndef handler() -> ReplaceUrl:\n    ...\n    return ReplaceUrl(content=\"Success!\", replace_url=\"/contact-us\")\n\n@get(\"/contact-us\")\ndef handler() -> Reswap:\n    ...\n    return Reswap(content=\"Success!\", method=\"beforebegin\")\n\n@get(\"/contact-us\")\ndef handler() -> Retarget:\n    ...\n    return Retarget(content=\"Success!\", target=\"#new-target\")\n\n@get(\"/contact-us\")\ndef handler() -> TriggerEvent:\n    ...\n    return TriggerEvent(\n        content=\"Success!\",\n        name=\"showMessage\",\n        params={\"attr\": \"value\"},\n        after=\"receive\",  # possible values 'receive', 'settle', and 'swap'\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirect Middleware in Python\nDESCRIPTION: Demonstrates how to create a middleware that redirects requests based on a condition. This example uses the MiddlewareProtocol and shows how to respond directly from the middleware.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.types import ASGIApp, Receive, Scope, Send\n\nfrom litestar.response.redirect import ASGIRedirectResponse\nfrom litestar import Request\nfrom litestar.middleware.base import MiddlewareProtocol\n\n\nclass RedirectMiddleware(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -> None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if Request(scope).session is None:\n            response = ASGIRedirectResponse(path=\"/login\")\n            await response(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)\n```\n\n----------------------------------------\n\nTITLE: Using SecretString in Request Body with Litestar\nDESCRIPTION: This example shows how to use a data structure with a SecretString field to accept a secret within the HTTP body of a request. It defines a model for the request body and a route that handles POST requests with this model.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/secret-datastructures.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, post\nfrom litestar.datastructures import SecretString\nfrom pydantic import BaseModel\n\nclass SecretModel(BaseModel):\n    secret: SecretString\n\n@post(\"/\")\nasync def secret_body(data: SecretModel) -> str:\n    return f\"Secret received: {data.secret.get_secret_value()}\"\n\napp = Litestar([secret_body])\n```\n\n----------------------------------------\n\nTITLE: Including Specific Routes for Authentication in Litestar\nDESCRIPTION: Uses regex pattern to include only /secured routes for authentication while excluding all others. Demonstrates inverse exclusion pattern.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/excluding-and-including-endpoints.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsession_auth = SessionAuth[User, ServerSideSessionBackend](\nretrieve_user_handler=retrieve_user_handler,\n# we must pass a config for a session backend.\n# all session backends are supported\nsession_backend_config=ServerSideSessionConfig(),\n# exclude any URLs that should not have authentication.\n# We exclude the documentation URLs, signup and login.\nexclude=[r\"^(?!.*\\/secured$).*$\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Using HTMXRequest Handler with Template Response\nDESCRIPTION: Demonstrates handling HTMX requests with custom request class and template responses. Shows how to check for HTMX headers and return template responses with HTMX-specific features.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/htmx.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.plugins.htmx import HTMXRequest, HTMXTemplate\nfrom litestar import get, Litestar\nfrom litestar.response import Template\n\nfrom litestar.contrib.jinja import JinjaTemplateEngine\nfrom litestar.template.config import TemplateConfig\n\nfrom pathlib import Path\n\n\n@get(path=\"/form\")\ndef get_form(request: HTMXRequest) -> Template:\n    if request.htmx:  # if request has \"HX-Request\" header, then\n        print(request.htmx)  # HTMXDetails instance\n        print(request.htmx.current_url)\n    return HTMXTemplate(template_name=\"partial.html\", context=context, push_url=\"/form\")\n\n\napp = Litestar(\n    route_handlers=[get_form],\n    debug=True,\n    request_class=HTMXRequest,\n    template_config=TemplateConfig(\n        directory=Path(\"litestar_htmx/templates\"),\n        engine=JinjaTemplateEngine,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Request Hook in Litestar\nDESCRIPTION: Example showing how to implement a before_request hook that runs before the route handler function. The hook accepts a Request object and can either return None or a response value.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/lifecycle-hooks.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\\examples\\lifecycle_hooks\\before_request.py\n```\n\n----------------------------------------\n\nTITLE: HTMXTemplate Response with Advanced Configuration\nDESCRIPTION: Shows advanced usage of HTMXTemplate response class with optional parameters for URL pushing, DOM manipulation, and event triggering.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/htmx.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.plugins.htmx import HTMXTemplate\nfrom litestar.response import Template\n\n\n@get(path=\"/form\")\ndef get_form(\n    request: HTMXRequest,\n) -> Template:  # Return type is Template and not HTMXTemplate.\n    ...\n    return HTMXTemplate(\n        template_name=\"partial.html\",\n        context=context,\n        # Optional parameters\n        push_url=\"/form\",  # update browser history\n        re_swap=\"outerHTML\",  # change swapping method\n        re_target=\"#new-target\",  # change target element\n        trigger_event=\"showMessage\",  # trigger event name\n        params={\"alert\": \"Confirm your Choice.\"},  # parameter to pass to the event\n        after=\"receive\",  #  when to trigger event,\n        # possible values 'receive', 'settle', and 'swap'\n    )\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Problem Details Plugin in Litestar\nDESCRIPTION: Demonstrates how to register the ProblemDetailsPlugin and raise a ProblemDetailsException for automatic conversion into a problem details response.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/problem_details.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.exceptions import ProblemDetailsException\nfrom litestar.plugins.problem_details import ProblemDetailsPlugin\n\n@get(\"/\")\ndef handler() -> None:\n    raise ProblemDetailsException(\n        status_code=400,\n        title=\"Bad Request\",\n        detail=\"The request was invalid.\",\n        instance=\"/invalid-request\",\n        type_=\"https://example.com/errors/bad-request\",\n    )\n\napp = Litestar(\n    route_handlers=[handler],\n    plugins=[ProblemDetailsPlugin()],\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for Litestar Application with Database\nDESCRIPTION: This YAML file defines a Docker Compose configuration for running the Litestar application alongside a PostgreSQL database, including environment variables and volume management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.9\"\n\nservices:\n  exampleapp:\n    build:\n      context: ./\n      dockerfile: Dockerfile\n    container_name: \"exampleapp\"\n    depends_on:\n      - database\n    ports:\n      - \"80:80\"\n    environment:\n      - DB_HOST=database\n      - DB_PORT=5432\n      - DB_USER=litestar\n      - DB_PASS=r0cks\n      - DB_NAME=exampleapp\n\n  database:\n    image: postgres:latest\n    container_name: \"exampledb\"\n    environment:\n      POSTGRES_USER: exampleuser\n      POSTGRES_PASSWORD: examplepass\n      POSTGRES_DB: exampledb\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - db_data:/var/lib/postgresql/data\n\nvolumes:\n  db_data:\n```\n\n----------------------------------------\n\nTITLE: Implementing Repository Context Manager in Python\nDESCRIPTION: This code creates a context manager for the Author repository, handling session creation, rollback on exceptions, and automatic commit.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@contextlib.asynccontextmanager\nasync def repository_factory():\n    async with db_engine.begin() as connection:\n        async with SQLAlchemyAsyncRepositoryContext(\n            connection=connection,\n            repositories=[AuthorRepository],\n        ) as context:\n            yield context\n```\n\n----------------------------------------\n\nTITLE: Using SecretString for Header Parameter in Litestar\nDESCRIPTION: This example demonstrates how to use SecretString to accept a secret value as a parameter in a GET request. It defines a route that expects a secret header and returns a message based on the header's value.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/secret-datastructures.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.datastructures import SecretString\nfrom litestar.params import Header\n\n@get(\"/\")\nasync def secret_header(secret: SecretString = Header()) -> str:\n    return f\"Secret received: {secret.get_secret_value()}\"\n\napp = Litestar([secret_header])\n```\n\n----------------------------------------\n\nTITLE: Using FlashPlugin with Jinja2 in Litestar\nDESCRIPTION: This example demonstrates how to use the FlashPlugin with the Jinja2 templating engine to display flash messages. It includes setting up session middleware, configuring templates and flash messages, and defining a route handler that adds and displays flash messages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/flash_messages.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.contrib.jinja import JinjaTemplateEngine\nfrom litestar.template.config import TemplateConfig\nfrom litestar.response import Template\nfrom litestar.contrib.sessions.middleware import SessionMiddleware\nfrom litestar.contrib.sessions.servers import ServerSideSessionConfig\nfrom litestar.plugins.flash_messages import FlashConfig, FlashPlugin\n\nsession_config = ServerSideSessionConfig(secret=\"some-secret\")\nsession_middleware = SessionMiddleware(session_config)\n\nflash_config = FlashConfig(cookie_name=\"flash_messages\")\nflash_plugin = FlashPlugin(flash_config=flash_config)\n\ntemplate_config = TemplateConfig(\n    directory=\"templates\",\n    engine=JinjaTemplateEngine,\n)\n\n@get(\"/\")\nasync def index(flash: FlashPlugin) -> Template:\n    flash(\"Hello, World!\", category=\"info\")\n    return Template(\n        template_str=\"\"\"\n        <html>\n            <body>\n                {% for message in flash_messages %}\n                    <p>{{ message.message }} ({{ message.category }})</p>\n                {% endfor %}\n            </body>\n        </html>\n        \"\"\"\n    )\n\napp = Litestar(\n    route_handlers=[index],\n    middleware=[session_middleware],\n    template_config=template_config,\n    plugins=[flash_plugin],\n)\n```\n\n----------------------------------------\n\nTITLE: Using CustomAuthenticationMiddleware in a Dependency in Python\nDESCRIPTION: This code shows how to use CustomAuthenticationMiddleware in a dependency function to ensure authentication before accessing a resource.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.exceptions import NotAuthorizedException\n\ndef auth_required(request: Request) -> User:\n    if request.user is None:\n        raise NotAuthorizedException()\n    return request.user\n```\n\n----------------------------------------\n\nTITLE: Implementing InitPlugin in Python for Litestar\nDESCRIPTION: This example demonstrates a simple InitPlugin implementation that adds a route handler and a dependency to the Litestar application. The plugin modifies the AppConfig by updating the dependency mapping and route handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/plugins/init_plugin_protocol.py\n   :language: python\n   :caption: ``InitPlugin`` implementation example\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Litestar Middleware Factory\nDESCRIPTION: Demonstrates how to create a basic middleware factory function that receives an ASGI app and returns a middleware function. The middleware can process requests before passing them to the next ASGI app in the stack.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/using-middleware.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.types import ASGIApp, Scope, Receive, Send\n\n\ndef middleware_factory(app: ASGIApp) -> ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n```\n\n----------------------------------------\n\nTITLE: Implementing After Request Hook in Litestar\nDESCRIPTION: Demonstration of after_request hook implementation that runs after the route handler returns. Takes a Response instance as parameter and returns a modified or same Response instance.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/lifecycle-hooks.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\\examples\\lifecycle_hooks\\after_request.py\n```\n\n----------------------------------------\n\nTITLE: Configuring the Prometheus Exporter in Litestar\nDESCRIPTION: Advanced example demonstrating how to customize the configuration of the Prometheus exporter in a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/prometheus.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Content of this code block is not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Defining UserRole Enum for Role-Based Authorization in Python\nDESCRIPTION: Creates an Enum class 'UserRole' with two roles: 'consumer' and 'admin'. This is used as the foundation for a role-based authorization system in a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/guards.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass UserRole(str, Enum):\n    CONSUMER = \"consumer\"\n    ADMIN = \"admin\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for Litestar Application Deployment\nDESCRIPTION: This Dockerfile sets up a Python 3.12 environment, installs dependencies, and configures the container to run the Litestar application using the Litestar CLI.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_2\n\nLANGUAGE: docker\nCODE:\n```\n# Set the base image using Python 3.12 and Debian Bookworm\nFROM python:3.12-slim-bookworm\n\n# Set the working directory to /app\nWORKDIR /app\n\n# Copy only the necessary files to the working directory\nCOPY . /app\n\n# Install the requirements\nRUN pip install --no-cache-dir --upgrade -r /app/requirements.txt\n\n# Expose the port the app runs on\nEXPOSE 80\n\n# Run the app with the Litestar CLI\nCMD [\"litestar\", \"run\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\n```\n\n----------------------------------------\n\nTITLE: Using DIPlugin for Custom Type Injection in Python\nDESCRIPTION: This example demonstrates how to use DIPlugin to extend Litestar's dependency injection system. It shows how to generate signature information for a custom type dynamically.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/plugins/di_plugin.py\n   :language: python\n   :caption: Dynamically generating signature information for a custom type\n```\n\n----------------------------------------\n\nTITLE: Sync File Upload Handling\nDESCRIPTION: Demonstrates synchronous file upload handling\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.datastructures import UploadFile\n\ndef handler(data: UploadFile) -> None:\n    contents = data.file.read()\n\n```\n\n----------------------------------------\n\nTITLE: Per-Exception Type Handlers\nDESCRIPTION: Example showing how to define different handlers for specific exception types.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/exceptions.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.exceptions import ValidationException, NotAuthorizedException\n\napp = Litestar(\n    route_handlers=[...],\n    exception_handlers={\n        ValidationException: validation_exception_handler,\n        NotAuthorizedException: auth_exception_handler,\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Async File Upload Handling\nDESCRIPTION: Shows asynchronous file upload handling using UploadFile class\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.datastructures import UploadFile\n\nasync def handler(data: UploadFile) -> None:\n    contents = await data.read()\n\n```\n\n----------------------------------------\n\nTITLE: Subclassing AbstractAuthenticationMiddleware in Python\nDESCRIPTION: This snippet demonstrates how to create a custom authentication middleware by subclassing AbstractAuthenticationMiddleware and implementing the authenticate_request method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.middleware import (\n   AbstractAuthenticationMiddleware,\n   AuthenticationResult,\n)\nfrom litestar.connection import ASGIConnection\n\n\nclass MyAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n   async def authenticate_request(\n       self, connection: ASGIConnection\n   ) -> AuthenticationResult:\n       # do something here.\n       ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Brotli Compression in Litestar\nDESCRIPTION: This code demonstrates how to enable Brotli compression for responses in a Litestar application by passing a CompressionConfig instance with the 'brotli' backend to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.config.compression import CompressionConfig\n\napp = Litestar(\n    route_handlers=[...],\n    compression_config=CompressionConfig(backend=\"brotli\", brotli_gzip_fallback=True),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Transaction Provider in Python\nDESCRIPTION: Async generator function that creates and manages SQLAlchemy sessions with transaction handling and integrity error management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/1-provide-session-with-di.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def provide_transaction() -> AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        try:\n            async with session.begin():\n                yield session\n        except IntegrityError as exc:\n            # Handle any integrity errors that might occur during\n            # the transaction\n            raise ClientException(detail=str(exc.orig))\n            # the transaction will automatically be rolled back\n```\n\n----------------------------------------\n\nTITLE: Redis Store Configuration for Litestar Caching\nDESCRIPTION: Shows how to configure Redis as a cache store for Litestar applications using ResponseCacheConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.stores.redis import RedisStore\nfrom litestar.config.response_cache import ResponseCacheConfig\n\napp = Litestar(\n    response_cache_config=ResponseCacheConfig(store=RedisStore(url=\"redis://localhost\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing PATCH Handler for Partial Updates in Litestar\nDESCRIPTION: This snippet shows how to create a PATCH handler in Litestar for partially updating a Person instance. It uses a PatchDTO with partial=True to allow subset updates of the data model.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/09-updating.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/data_transfer_objects/factory/tutorial/patch_handlers.py\n   :language: python\n   :linenos:\n   :emphasize-lines: 21,22,25\n```\n\n----------------------------------------\n\nTITLE: Multiple File Upload with Pydantic\nDESCRIPTION: Shows handling multiple file uploads using Pydantic models\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom litestar.datastructures import UploadFile\n\nclass Files(BaseModel):\n    file1: UploadFile\n    file2: UploadFile\n\nasync def handler(data: Files) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Registering FlashPlugin with Jinja2 in Litestar\nDESCRIPTION: This snippet shows how to register the FlashPlugin using the Jinja2 templating engine in a Litestar application. It sets up the necessary configurations for templates and flash messages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/flash_messages.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.contrib.jinja import JinjaTemplateEngine\nfrom litestar.template.config import TemplateConfig\nfrom litestar.plugins.flash_messages import FlashConfig, FlashPlugin\n\nflash_config = FlashConfig(cookie_name=\"flash_messages\")\nflash_plugin = FlashPlugin(flash_config=flash_config)\n\napp = Litestar(\n    template_config=TemplateConfig(\n        directory=\"templates\",\n        engine=JinjaTemplateEngine,\n    ),\n    plugins=[flash_plugin],\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Middleware Using Factory Function in Python\nDESCRIPTION: Demonstrates how to create middleware using a factory function that returns an ASGI app. This approach allows for custom logic to be executed before passing control to the next middleware in the stack.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.types import ASGIApp, Scope, Receive, Send\n\n\ndef middleware_factory(app: ASGIApp) -> ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n```\n\n----------------------------------------\n\nTITLE: Implementing Layered Hooks in Litestar\nDESCRIPTION: Example showing how to implement hooks at different layers of the application, demonstrating Litestar's layered architecture where closer layers take precedence.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/lifecycle-hooks.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\\examples\\lifecycle_hooks\\layered_hooks.py\n```\n\n----------------------------------------\n\nTITLE: Updating TODO Items with PUT Handler in Python\nDESCRIPTION: Implements a PUT route handler that updates existing TODO items using path parameters. Matches items by title and updates with new data provided in the request body.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/3-assembling-the-app.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@put(\"/{item_title:str}\")\nasync def update_item(self, item_title: str, data: TodoItem) -> TodoItem:\n    for item in self.todo_items:\n        if item.title == item_title:\n            item.done = data.done\n    return data\n```\n\n----------------------------------------\n\nTITLE: Basic Request Data Handling in Litestar\nDESCRIPTION: Demonstrates basic request data handling using the data parameter in a handler function\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\n@dataclass\nclass Item:\n    name: str\n\nasync def handler(data: Item) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: MultiPart Form Data Processing\nDESCRIPTION: Demonstrates handling multipart form data with file uploads\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.params import Body\nfrom litestar.enums import RequestEncodingType\n\nasync def handler(data: dict = Body(media_type=RequestEncodingType.MULTI_PART)) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Route-Specific Cache Key Builder in Litestar\nDESCRIPTION: Shows how to implement a custom cache key builder for a specific route handler.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Request, get\n\ndef custom_key_builder(request: Request) -> str:\n    return f\"{request.method}:{request.url}\"\n\n@get(\"/\")\n@cache(cache_key_builder=custom_key_builder)\ndef handler() -> dict[str, str]:\n    return {\"hello\": \"world\"}\n```\n\n----------------------------------------\n\nTITLE: Database Connection Lifecycle Management with SQLAlchemy\nDESCRIPTION: Implements a context manager for database connection lifecycle, creating and disposing of the SQLAlchemy engine. Includes table creation logic using SQLAlchemy Base metadata.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/0-introduction.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def db_connection(app: Litestar) -> AsyncGenerator[None, None]:\n    async_engine = create_async_engine(\n        \"sqlite+aiosqlite:///db.sqlite3\",\n        echo=True,\n    )\n    app.state.engine = async_engine\n    async with async_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    try:\n        yield\n    finally:\n        await async_engine.dispose()\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Send Hook in Litestar (Python)\nDESCRIPTION: This code snippet demonstrates the implementation of a 'before_send' hook in a Litestar application. The hook intercepts and potentially modifies the response before it is sent to the client.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/application_hooks/before_send_hook.py\n    :language: python\n    :caption: Before Send Hook\n```\n\n----------------------------------------\n\nTITLE: Custom WebSocket Connection Acceptance Handler\nDESCRIPTION: Shows implementation of a custom connection acceptance handler for WebSockets that sets specific headers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.status_codes import WS_ACCEPT\nfrom litestar.types import WebSocketMode\n\nasync def custom_connection_handler(socket, subprotocols: list[str] | None = None) -> None:\n    headers = [(b\"X-Custom-Header\", b\"value\")]\n    await socket.accept(subprotocols=subprotocols, headers=headers)\n```\n\n----------------------------------------\n\nTITLE: JSON Post Request Handling\nDESCRIPTION: Compares how JSON POST requests are handled in FastAPI and Litestar, showing different parameter naming conventions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass ObjectType(BaseModel):\n    name: str\n\n@app.post(\"/items/\")\nasync def create_item(object_name: ObjectType) -> dict[str, str]:\n    return {\"name\": object_name.name}\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, post\nfrom pydantic import BaseModel\n\nclass ObjectType(BaseModel):\n    name: str\n\n@post(\"/items/\")\nasync def create_item(data: ObjectType) -> dict[str, str]:\n    return {\"name\": data.name}\n```\n\n----------------------------------------\n\nTITLE: Initial State Configuration Change\nDESCRIPTION: Shows the migration from initial_state dictionary to state parameter using State class in Litestar 2.x application configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\napp = Starlite(..., initial_state={\"some\": \"key\"})\n```\n\nLANGUAGE: python\nCODE:\n```\napp = Litestar(..., state=State({\"some\": \"key\"}))\n```\n\n----------------------------------------\n\nTITLE: Configuring HTMXPlugin with Litestar Application\nDESCRIPTION: Sets up Litestar application with HTMX plugin and Jinja template engine configuration. Enables HTMX functionality across all routes.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/htmx.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.plugins.htmx import HTMXPlugin\nfrom litestar import Litestar\n\nfrom litestar.contrib.jinja import JinjaTemplateEngine\nfrom litestar.template.config import TemplateConfig\n\nfrom pathlib import Path\n\napp = Litestar(\n    route_handlers=[get_form],\n    debug=True,\n    plugins=[HTMXPlugin()],\n    template_config=TemplateConfig(\n        directory=Path(\"litestar_htmx/templates\"),\n        engine=JinjaTemplateEngine,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Direct Access Stream Implementation\nDESCRIPTION: Demonstrates how to interact with WebSocket directly by injecting it into a generator function via the socket argument.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@websocket(\"/ws\")\nasync def stream_socket(socket: WebSocket) -> AsyncGenerator[str, None]:\n    await socket.send_json({\"status\": \"ready\"})\n    try:\n        for i in range(5):\n            yield str(i)\n            await asyncio.sleep(1)\n    except WebSocketDisconnect:\n        print(\"client disconnected\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Server-Side Session Store in Litestar\nDESCRIPTION: Demonstrates how to set up server-side sessions using a file store in Litestar. Server-side sessions store data on the server and use a cookie containing a session ID for client identification.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Content of file_store.py is not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Timed Response Caching in Litestar\nDESCRIPTION: Shows how to cache responses for a specific duration (120 seconds) using the cache parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\")\n@cache(expiration=120)\ndef handler() -> dict[str, str]:\n    return {\"hello\": \"world\"}\n```\n\n----------------------------------------\n\nTITLE: Overriding Implicit 'return_dto' in Litestar Route Handler\nDESCRIPTION: Illustrates how to disable the implicit 'return_dto' behavior by explicitly setting it to None, allowing manual management of response data encoding.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/0-basic-use.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import post\nfrom litestar.dto import DTOData\n\n@post(\"/users\", return_dto=None)\ndef create_user(data: DTOData[User]) -> dict[str, str]:\n    user = User(**data.create_instance())\n    return {\"id\": user.id, \"name\": user.name}\n```\n\n----------------------------------------\n\nTITLE: MessagePack Data Handling\nDESCRIPTION: Shows how to handle MessagePack encoded request data\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.enums import RequestEncodingType\nfrom litestar.params import Body\n\nasync def handler(data: dict = Body(media_type=RequestEncodingType.MESSAGEPACK)) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Litestar Application Configuration with DI\nDESCRIPTION: Configuration of a Litestar application with dependency injection setup for database transactions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/1-provide-session-with-di.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\napp = Litestar(\n    route_handlers=[HomeController],\n    dependencies={\"transaction\": provide_transaction},\n    debug=True,\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing User and Auth in WebSocket Route Handler with CustomAuthenticationMiddleware in Python\nDESCRIPTION: This code demonstrates how to access the authenticated user and auth token in a WebSocket route handler when using CustomAuthenticationMiddleware.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import websocket\n\n@websocket(\"/\")\nasync def websocket_handler(socket: WebSocket) -> None:\n    user: User = socket.user\n    auth: Token = socket.auth\n    await socket.accept()\n```\n\n----------------------------------------\n\nTITLE: Basic HTMX Response Handlers\nDESCRIPTION: Collection of basic HTMX response handlers for stopping polling, client redirects, and page refreshes without DOM modifications.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/htmx.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\")\ndef handler() -> HXStopPolling:\n    ...\n    return HXStopPolling()\n\n@get(\"/\")\ndef handler() -> ClientRedirect:\n    ...\n    return ClientRedirect(redirect_to=\"/contact-us\")\n\n@get(\"/\")\ndef handler() -> ClientRefresh:\n    ...\n    return ClientRefresh()\n```\n\n----------------------------------------\n\nTITLE: Managing Database Connections with Lifespan Context Manager\nDESCRIPTION: Example showing how to handle database connections using an asynchronous context manager for lifespan management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import asynccontextmanager\nfrom litestar import Litestar\n\n@asynccontextmanager\nasync def handle_db_connection():\n    try:\n        connection = await establish_connection()\n        yield connection\n    finally:\n        await connection.close()\n\napp = Litestar(route_handlers=[...], lifespan=[handle_db_connection])\n```\n\n----------------------------------------\n\nTITLE: Using the 'dto' Parameter in Litestar Route Handler\nDESCRIPTION: Demonstrates how to use the 'dto' parameter in a Litestar route handler to decode client data into a User type and encode the returned User instance.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/0-basic-use.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import post\nfrom litestar.dto import DTOData\n\n@post(\"/users\")\ndef create_user(data: DTOData[User]) -> User:\n    return User(**data.create_instance())\n```\n\n----------------------------------------\n\nTITLE: Configuring StructLog with Litestar (Python)\nDESCRIPTION: This example demonstrates how to use StructLog, a structured logging library, with Litestar. It uses the StructlogPlugin to integrate StructLog into the Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/logging.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Request, get\nfrom litestar.plugins.structlog import StructlogPlugin\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -> None:\n    request.logger.info(\"inside a request\")\n    return None\n\n\nstructlog_plugin = StructlogPlugin()\n\napp = Litestar(route_handlers=[my_router_handler], plugins=[StructlogPlugin()])\n```\n\n----------------------------------------\n\nTITLE: Implementing After Response Hook in Litestar\nDESCRIPTION: Example of after_response hook implementation that executes after the response is sent. Used for post-processing, metrics gathering, or third-party service integration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/lifecycle-hooks.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\\examples\\lifecycle_hooks\\after_response.py\n```\n\n----------------------------------------\n\nTITLE: Excluding Routes from Authentication in Litestar\nDESCRIPTION: Configures SessionAuth to exclude specific routes from authentication using regex patterns. This example excludes /login, /signup, and /schema routes from requiring authentication.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/excluding-and-including-endpoints.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nsession_auth = SessionAuth[User, ServerSideSessionBackend](\nretrieve_user_handler=retrieve_user_handler,\n# we must pass a config for a session backend.\n# all session backends are supported\nsession_backend_config=ServerSideSessionConfig(),\n# exclude any URLs that should not have authentication.\n# We exclude the documentation URLs, signup and login.\nexclude=[\"/login\", \"/signup\", \"/schema\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Request Class Implementation\nDESCRIPTION: Demonstrates implementing a custom request class at the application level\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Request\n\nclass MyRequest(Request):\n    pass\n\napp = Litestar(request_class=MyRequest)\n\n```\n\n----------------------------------------\n\nTITLE: Multiple Listeners for Same Event in Litestar\nDESCRIPTION: Demonstrates how to set up multiple listeners for the same event type, handling different aspects of the event data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import UUID\nfrom dataclasses import dataclass\n\nfrom litestar import Request, post\nfrom litestar.events import listener\n\nfrom db import user_repository\nfrom utils.client import client\nfrom utils.email import send_farewell_email\n\n\n@listener(\"user_deleted\")\nasync def send_farewell_email_handler(email: str, **kwargs) -> None:\n    # do something here to send an email\n    await send_farewell_email(email)\n\n\n@listener(\"user_deleted\")\nasync def notify_customer_support(reason: str, **kwargs) -> None:\n    # do something here to send an email\n    await client.post(\"some-url\", reason)\n\n\n@dataclass\nclass DeleteUserDTO:\n    email: str\n    reason: str\n\n\n@post(\"/users\")\nasync def delete_user_handler(data: UserDTO, request: Request) -> None:\n    await user_repository.delete({\"email\": email})\n    request.app.emit(\"user_deleted\", email=data.email, reason=\"deleted\")\n```\n\n----------------------------------------\n\nTITLE: Route Reverse for Static Files in Python\nDESCRIPTION: Demonstrates how to retrieve paths to static files using route_reverse method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.static_files import create_static_files_router\n\n@get(\"/\")\ndef handler(app: Litestar) -> str:\n    return app.route_reverse(\"static\", file_path=\"test.txt\")\n\napp = Litestar(\n    route_handlers=[\n        handler,\n        create_static_files_router(path=\"/static\", directories=[\"assets\"]),\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Request Body Validation with OpenAPI\nDESCRIPTION: Demonstrates request body validation and OpenAPI documentation customization using Body class\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.params import Body\n\nasync def handler(data: str = Body(media_type=\"text/plain\", min_length=1)) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining Author Model with UUIDBase in Python\nDESCRIPTION: This snippet demonstrates how to create an Author model using the UUIDBase class from advanced_alchemy.base. The model includes fields for id, name, and date of birth.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/01-modelling-and-features.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.base import UUIDBase\n\nclass Author(UUIDBase):\n    name: Mapped[str]\n    dob: Mapped[date]\n```\n\n----------------------------------------\n\nTITLE: Initializing Application State with Custom Configuration\nDESCRIPTION: Shows how to initialize application state by passing a State object to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.datastructures import State\n\napp = Litestar(\n    route_handlers=[...],\n    state=State({\"counter\": 0}, deep_copy=True)\n)\n```\n\n----------------------------------------\n\nTITLE: Channel Unsubscription Using Context Manager in Python\nDESCRIPTION: Example demonstrating how to unsubscribe from specific channels while using the async context manager pattern.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync with channels.start_subscription([\"foo\", \"bar\"]) as subscriber:\n    ...  # do some stuff here\n    await channels.unsubscribe(subscriber, [\"foo\"])\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Handlers with Slug Generation in Python\nDESCRIPTION: This snippet shows route handlers for creating and retrieving blog posts. It demonstrates how to generate and use unique slugs when creating new blog posts, and how to query posts by their slugs.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/04-repository-other.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@app.post(\"/blog\")\nasync def create_blog_post(data: BlogPostCreate) -> BlogPost:\n    async with db_session() as session:\n        slug = await BlogPost._create_unique_slug(session, data.title)\n        post_dict = data.model_dump()\n        post_dict[\"slug\"] = slug\n        return await repository.insert(post_dict)\n\n@app.get(\"/blog/{slug}\")\nasync def get_blog_post(slug: str) -> BlogPost:\n    return await repository.get(BlogPost.slug == slug)\n```\n\n----------------------------------------\n\nTITLE: WebSocket JSON to MessagePack Handler\nDESCRIPTION: Example showing how to create a WebSocket handler that receives JSON data and sends it back as MessagePack.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import websocket, WebSocket\n\n\n@websocket(\"/\")\nasync def handler(socket: WebSocket) -> None:\n    await socket.accept()\n    async for message in socket.iter_data(mode):\n        await socket.send_msgpack(message)\n```\n\n----------------------------------------\n\nTITLE: List-based File Upload Handling\nDESCRIPTION: Demonstrates handling multiple file uploads as a list\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.datastructures import UploadFile\n\nasync def handler(data: list[UploadFile]) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Automatic Query Parameter Validation in Python with Litestar\nDESCRIPTION: This snippet demonstrates how to use Litestar's automatic type conversion and validation for query parameters. It shows how to define a boolean query parameter that Litestar will automatically convert and validate.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom litestar import Litestar, get\n\n\n@dataclass\nclass TodoItem:\n    id: str\n    item: str\n    done: bool\n\n\n@get(\"/\")\ndef get_list(done: bool) -> List[TodoItem]:\n    todos = [\n        TodoItem(id=\"1\", item=\"Make this list more useful\", done=False),\n        TodoItem(id=\"2\", item=\"Buy groceries\", done=False),\n        TodoItem(id=\"3\", item=\"Do laundry\", done=True),\n    ]\n    return [todo for todo in todos if todo.done == done]\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Creating POST Handler with DTO in Litestar\nDESCRIPTION: Demonstrates how to create a POST endpoint that receives and returns Person data using DTOs. The handler accepts Person objects and uses ReadDTO to exclude email from response payloads. The example shows Litestar's native ability to decode request payloads into Python dataclasses.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/06-receiving-data.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass Person:\n    name: str\n    age: int\n    email: str\n\nclass ReadDTO(DTOFactory):\n    exclude = {\"email\"}\n\n@post(\"/person\", dto=ReadDTO)\nasync def create_person(data: Person) -> Person:\n    return data\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Routing in Litestar and FastAPI\nDESCRIPTION: This snippet demonstrates how to create a simple route that returns a string in both Litestar and FastAPI. It shows the syntax differences in route decoration and function definition.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@get(path=\"/blabla\", name=\"blabla\")\nasync def blabla() -> str:\n    return \"Blabla\"\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Route Handlers in Python\nDESCRIPTION: Demonstrates how to create automatic WebSocket route handlers for channels by enabling create_ws_route_handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.channels import ChannelsPlugin\nfrom litestar.channels.memory import MemoryChannelsBackend\n\nchannels = ChannelsPlugin(\n    backend=MemoryChannelsBackend(),\n    channels=[\"test\"],  # list of channels\n    create_ws_route_handlers=True,  # automatically create WebSocket route handlers for each channel\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication in Litestar\nDESCRIPTION: This snippet demonstrates how to implement authentication in Litestar using guards. It defines an authenticate function that takes connection and route_handler parameters, and uses it as a guard for a route.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, ASGIConnection, BaseRouteHandler\n\n\nasync def authenticate(\n    connection: ASGIConnection, route_handler: BaseRouteHandler\n) -> None: ...\n\n\n@get(\"/\", guards=[authenticate])\nasync def index() -> dict[str, str]: ...\n```\n\n----------------------------------------\n\nTITLE: Implementing SQLAlchemy Field Marking for Data Control\nDESCRIPTION: Example demonstrating how to control data serialization by marking fields as private in SQLAlchemy models. Shows implementation of field privacy and its effect on API responses.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_serialization_plugin.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom litestar import Litestar, get\nfrom litestar.contrib.sqlalchemy.plugins import SQLAlchemySerializationPlugin\nfrom litestar.dto import mark_field_private\nfrom sqlalchemy import String, select\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom advanced_alchemy.base import BigIntBase\n\n\nclass User(BigIntBase):\n    name: Mapped[str] = mapped_column(String(length=100))\n    super_secret_value: Mapped[str] = mark_field_private(\n        mapped_column(String(length=100))\n    )\n\n\n@get(\"/users/{user_id:int}\")\nasync def get_user(user_id: int) -> User:\n    user = await User.select()\n    user.super_secret_value = \"top secret!\"\n    return user\n\n\n@get(\"/users\")\nasync def list_users() -> list[User]:\n    users = await User.select()\n    for user in users:\n        user.super_secret_value = \"top secret!\"\n    return users\n\n\napp = Litestar([get_user, list_users], plugins=[SQLAlchemySerializationPlugin()])\n```\n\n----------------------------------------\n\nTITLE: Channel Subscription Using Context Manager in Python\nDESCRIPTION: Example showing how to manage channel subscriptions using the async context manager pattern.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync with channels.start_subscription([\"foo\", \"bar\"]) as subscriber:\n    ...  # do some stuff here\n```\n\n----------------------------------------\n\nTITLE: HTML Mode Configuration for Static Files in Python\nDESCRIPTION: Shows how to enable HTML mode for serving index.html and 404.html files automatically.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(\n            path=\"/static\",\n            directories=[\"assets\"],\n            html_mode=True,\n        )\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Validation in Python Litestar\nDESCRIPTION: Example showing how to toggle dependency validation using the Dependency function. This allows for validation to be skipped when needed for efficiency or compatibility reasons.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndependency_skip_validation.py\n```\n\n----------------------------------------\n\nTITLE: Accessing Litestar App Instance in Custom CLI Commands\nDESCRIPTION: Demonstrates how to access the Litestar app instance within a custom CLI command by adding an 'app' parameter of type Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport click\nfrom litestar import Litestar\n\n\n@click.command()\ndef my_command(app: Litestar) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Eviction Strategy in Python\nDESCRIPTION: Example showing how to configure a channels plugin with eviction strategy (dropleft) for managing backpressure with a 1000 message limit.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.channels import ChannelsPlugin\nfrom litestar.channels.memory import MemoryChannelsBackend\n\nchannels = ChannelsPlugin(\n    backend=MemoryChannelsBackend(),\n    max_backlog=1000,\n    backlog_strategy=\"dropleft\",\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Litestar Application in Python\nDESCRIPTION: Creates and configures the main Litestar application instance. Sets up the ASGI application that can be served using an ASGI server like uvicorn.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/3-assembling-the-app.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\napp = Litestar(route_handlers=[TodoController])\n```\n\n----------------------------------------\n\nTITLE: Configuring Channels with Arbitrary Channel Support in Python\nDESCRIPTION: Example demonstrating how to configure the ChannelsPlugin to allow arbitrary channel creation by setting arbitrary_channels_allowed to True.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.channels import ChannelsPlugin\n\nchannels_plugin = ChannelsPlugin(..., arbitrary_channels_allowed=True)\n```\n\n----------------------------------------\n\nTITLE: Implementing DTO with Field Exclusion in Litestar (Python)\nDESCRIPTION: This code creates a ReadDTO class that extends DataclassDTO[Person] and configures it to exclude the email field from the Person dataclass. The DTO is then applied to a route handler to filter the response data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/01-simple-dto-exclude.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom litestar import Litestar, get\nfrom litestar.contrib.sqlalchemy.base import UUIDBase\nfrom litestar.contrib.sqlalchemy.repository import SQLAlchemyAsyncRepository\nfrom litestar.di import Provide\nfrom litestar.dto import DTOConfig, DataclassDTO\n\n\n@dataclass\nclass Person(UUIDBase):\n    name: str\n    email: str\n\n\nclass ReadDTO(DataclassDTO[Person]):\n    config = DTOConfig(exclude={\"email\"})\n\n\n@get(\"/person/{name:str}\", return_dto=ReadDTO)\nasync def get_person(name: str, repo: SQLAlchemyAsyncRepository[Person]) -> Person:\n    return await repo.get_by_kwargs(name=name)\n\n\napp = Litestar(\n    route_handlers=[get_person],\n    dependencies={\"repo\": Provide(SQLAlchemyAsyncRepository[Person], sync_to_thread=True)},\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Token Class in Python\nDESCRIPTION: Demonstration of creating and using a custom token class by subclassing the Token class in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Defining Book Model with UUIDAuditBase in Python\nDESCRIPTION: This snippet shows how to create a Book model using the UUIDAuditBase class. This class automatically adds created and updated timestamp columns to the model.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/01-modelling-and-features.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.base import UUIDAuditBase\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nclass Book(UUIDAuditBase):\n    title: Mapped[str]\n    author_id: Mapped[UUID] = mapped_column(ForeignKey(\"author.id\"))\n    author: Mapped[Author] = relationship(Author, back_populates=\"books\")\n```\n\n----------------------------------------\n\nTITLE: Using HTTPX Client with CSRF Protection\nDESCRIPTION: This code demonstrates how to use the HTTPX client to make requests to a CSRF-protected Litestar application, including handling the CSRF token in headers and form data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\n\n\nwith httpx.Client() as client:\n    get_response = client.get(\"http://localhost:8000/\")\n\n    # \"csrftoken\" is the default cookie name\n    csrf = get_response.cookies[\"csrftoken\"]\n\n    # \"x-csrftoken\" is the default header name\n    post_response_using_header = client.post(\"http://localhost:8000/1\", headers={\"x-csrftoken\": csrf})\n    assert post_response_using_header.status_code == 201\n\n    # \"_csrf_token\" is the default *non* configurable form-data key\n    post_response_using_form_data = client.post(\"http://localhost:8000/1\", data={\"_csrf_token\": csrf})\n    assert post_response_using_form_data.status_code == 201\n\n    # despite the header being passed, this request will fail as it does not have a cookie in its session\n    # note the usage of ``httpx.post`` instead of ``client.post``\n    post_response_with_no_persisted_cookie = httpx.post(\"http://localhost:8000/1\", headers={\"x-csrftoken\": csrf})\n    assert post_response_with_no_persisted_cookie.status_code == 403\n    assert \"CSRF token verification failed\" in post_response_with_no_persisted_cookie.text\n```\n\n----------------------------------------\n\nTITLE: Handling Default Value Dependencies in Litestar OpenAPI\nDESCRIPTION: Demonstrates how dependencies with default values are handled in route handlers or Provide functions. Shows the default behavior where dependencies are treated as query parameters.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndependency_with_default.py\n```\n\n----------------------------------------\n\nTITLE: Dependency Override Example\nDESCRIPTION: Demonstrates how to override dependencies at different scopes using the same key name.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, get\nfrom litestar.di import Provide\n\n\ndef bool_fn() -> bool: ...\n\n\ndef dict_fn() -> dict: ...\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    # on the controller\n    dependencies = {\"some_dependency\": Provide(dict_fn)}\n\n    # on the route handler\n    @get(path=\"/handler\", dependencies={\"some_dependency\": Provide(bool_fn)})\n    def my_route_handler(\n        self,\n        some_dependency: bool,\n    ) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Implementing After Exception Hook in Litestar\nDESCRIPTION: Shows how to implement an after exception hook for logging or monitoring purposes.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.types import Scope\n\nasync def log_exception(exc: Exception, scope: Scope) -> None:\n    print(f\"Exception occurred: {exc}\")\n\napp = Litestar(\n    route_handlers=[...],\n    after_exception=[log_exception]\n)\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Flask and Litestar\nDESCRIPTION: Shows how to set up global error handlers in both frameworks. Flask uses decorators, while Litestar uses a dictionary of exception handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\nfrom werkzeug.exceptions import HTTPException\n\n\napp = Flask(__name__)\n\n\n@app.errorhandler(HTTPException)\ndef handle_exception(e): ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Request, Response\nfrom litestar.exceptions import HTTPException\n\n\ndef handle_exception(request: Request, exception: Exception) -> Response: ...\n\n\napp = Litestar([], exception_handlers={HTTPException: handle_exception})\n```\n\n----------------------------------------\n\nTITLE: Manual Channel Subscription Management in Python\nDESCRIPTION: Example demonstrating manual subscription management using subscribe and unsubscribe methods.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsubscriber = await channels.subscribe([\"foo\", \"bar\"])\ntry:\n    ...  # do some stuff here\nfinally:\n    await channels.unsubscribe(subscriber)\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Timing Middleware in Python\nDESCRIPTION: Shows how to create a middleware that adds a request timing header to all outgoing responses. This example extends the ASGIMiddleware class and demonstrates modifying the response.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# This code snippet is referenced but not directly provided in the text\n```\n\n----------------------------------------\n\nTITLE: Manual Channel Unsubscription in Python\nDESCRIPTION: Example showing how to manually unsubscribe from specific channels while maintaining other subscriptions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsubscriber = await channels.subscribe([\"foo\", \"bar\"])\ntry:\n    ...  # do some stuff here\nfinally:\n    await channels.unsubscribe(subscriber, [\"foo\"])\n```\n\n----------------------------------------\n\nTITLE: Enhancing Repository Function with Query Options in Python\nDESCRIPTION: This function enhances the repository by adding a selectinload option, optimizing query execution for the 'books' relationship. It demonstrates how to override the default query behavior.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/03-repository-controller.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef get_author_repo_with_books(\n    db_session: AsyncSession,\n) -> AuthorRepository[Author]:\n    return AuthorRepository[\n        Author\n    ](session=db_session, model=Author, statement=select(Author).options(selectinload(Author.books)))\n```\n\n----------------------------------------\n\nTITLE: Accessing User and Auth in HTTP Route Handler with CustomAuthenticationMiddleware in Python\nDESCRIPTION: This snippet shows how to access the authenticated user and auth token in an HTTP route handler when using CustomAuthenticationMiddleware.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get\n\n@get(\"/\")\ndef http_handler(request: Request) -> dict[str, Any]:\n    user: User = request.user\n    auth: Token = request.auth\n    return {\"user\": user, \"auth\": auth}\n```\n\n----------------------------------------\n\nTITLE: Implementing Token-Based Guard with Route Handler Opts in Python\nDESCRIPTION: Creates a 'token_guard' function that checks for a specific token in the request headers. The expected token is retrieved from the route handler's 'opts' dictionary.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/guards.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef token_guard(connection: Request, route_handler: BaseRouteHandler) -> None:\n    expected_token = route_handler.opt.get(\"token\")\n    if expected_token:\n        token = connection.headers.get(\"Authorization\")\n        if token != f\"Bearer {expected_token}\":\n            raise NotAuthorizedException()\n\n@get(\"/secret\", guards=[token_guard], opt={\"token\": \"my-secret-token\"})\ndef secret_route_handler() -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: JSON Response Format for HTTP Exceptions\nDESCRIPTION: Default JSON structure returned by HTTPException when an error occurs in the application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/exceptions.rst#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"status_code\": 500,\n  \"detail\": \"Internal Server Error\",\n  \"extra\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Litestar with pdb_on_exception in Python\nDESCRIPTION: This snippet shows how to configure the Litestar application to use the Python debugger when an exception occurs.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/debugging.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\napp = Litestar(pdb_on_exception=True)\n```\n\n----------------------------------------\n\nTITLE: Implementing generate_field_definitions Method for Custom DTO in Python\nDESCRIPTION: This method generates DTOFieldDefinition instances for the model fields. It receives the model type and should return a generator yielding DTOFieldDefinition instances.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/2-creating-custom-dto-classes.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef generate_field_definitions(self, model_type: Any) -> Generator[DTOFieldDefinition, None, None]:\n```\n\n----------------------------------------\n\nTITLE: Extending Author Model with Book Relationship in Python\nDESCRIPTION: This code extends the Author model to include a relationship with the Book model. It demonstrates how to set up a one-to-many relationship between Author and Book using SQLAlchemy.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/01-modelling-and-features.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.base import UUIDBase\n\nclass Author(UUIDBase):\n    name: Mapped[str]\n    dob: Mapped[date]\n    books: Mapped[list[\"Book\"]] = relationship(\n        \"Book\", back_populates=\"author\", cascade=\"all, delete-orphan\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing SlugKey Mixin for SQLAlchemy Models in Python\nDESCRIPTION: This snippet defines a SlugKey mixin class that adds a slug field to SQLAlchemy models. It includes methods to generate and validate unique slugs based on the title field.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/04-repository-other.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport re\nfrom random import randint\nfrom slugify import slugify\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass SlugKey:\n    slug: Mapped[str] = mapped_column(String(length=100), unique=True, index=True)\n\n    @classmethod\n    def _create_slug(cls, title: str) -> str:\n        return slugify(title)\n\n    @classmethod\n    def _create_unique_slug(cls, session: Session, title: str) -> str:\n        slug = cls._create_slug(title)\n        original_slug = slug\n        count = 1\n        while True:\n            if not session.query(cls).filter(cls.slug == slug).first():\n                return slug\n            slug = f\"{original_slug}-{count}\"\n            count += 1\n\n    @classmethod\n    def _slugify(cls, title: str) -> str:\n        pattern = r\"[^\\w+]\"\n        return re.sub(pattern, \"-\", title.lower())\n\n    @classmethod\n    def _append_random_suffix(cls, slug: str) -> str:\n        return f\"{slug}-{randint(1000, 9999)}\"\n```\n\n----------------------------------------\n\nTITLE: Adding Query Parameter Filtering to TODO List in Python with Litestar\nDESCRIPTION: This snippet adds a query parameter 'done' to filter the TODO list. It demonstrates how to use function parameters as query parameters in Litestar and how to filter the list based on the parameter value.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom litestar import Litestar, get\n\n\n@dataclass\nclass TodoItem:\n    id: str\n    item: str\n    done: bool\n\n\n@get(\"/\")\ndef get_list(done: str) -> List[TodoItem]:\n    todos = [\n        TodoItem(id=\"1\", item=\"Make this list more useful\", done=False),\n        TodoItem(id=\"2\", item=\"Buy groceries\", done=False),\n        TodoItem(id=\"3\", item=\"Do laundry\", done=True),\n    ]\n    return [todo for todo in todos if str(int(todo.done)) == done]\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Refactoring TODO List with Dataclasses in Python\nDESCRIPTION: This snippet refactors the previous example to use dataclasses instead of dictionaries. It demonstrates how Litestar can work with more structured data types while still automatically serializing to JSON.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom litestar import Litestar, get\n\n\n@dataclass\nclass TodoItem:\n    id: str\n    item: str\n    done: bool\n\n\n@get(\"/\")\ndef get_list() -> List[TodoItem]:\n    return [\n        TodoItem(id=\"1\", item=\"Make this list more useful\", done=False),\n        TodoItem(id=\"2\", item=\"Buy groceries\", done=False),\n        TodoItem(id=\"3\", item=\"Do laundry\", done=True),\n    ]\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Path Parameters in Flask and Litestar\nDESCRIPTION: Illustrates how to define and use path parameters in Flask and Litestar. Includes examples for string, integer, and path-type parameters.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.route(\"/user/<username>\")\ndef show_user_profile(username):\n    return f\"User {username}\"\n\n\n@app.route(\"/post/<int:post_id>\")\ndef show_post(post_id):\n    return f\"Post {post_id}\"\n\n\n@app.route(\"/path/<path:subpath>\")\ndef show_subpath(subpath):\n    return f\"Subpath {subpath}\"\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom pathlib import Path\n\n\n@get(\"/user/{username:str}\")\ndef show_user_profile(username: str) -> str:\n    return f\"User {username}\"\n\n\n@get(\"/post/{post_id:int}\")\ndef show_post(post_id: int) -> str:\n    return f\"Post {post_id}\"\n\n\n@get(\"/path/{subpath:path}\")\ndef show_subpath(subpath: Path) -> str:\n    return f\"Subpath {subpath}\"\n\n\napp = Litestar([show_user_profile, show_post, show_subpath])\n```\n\n----------------------------------------\n\nTITLE: Implementing SerializationPluginProtocol for SQLAlchemy in Python\nDESCRIPTION: This example shows the implementation of SerializationPluginProtocol for SQLAlchemy models in the advanced_alchemy package. It includes methods to check if a type is supported and to create DTOs for SQLAlchemy models.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/plugins/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../../litestar/contrib/sqlalchemy/plugins/serialization.py\n   :language: python\n   :caption: ``SerializationPluginProtocol`` implementation example\n```\n\n----------------------------------------\n\nTITLE: Publishing Data to Channels in Python\nDESCRIPTION: Example showing how to publish data to a channel using the publish method of ChannelsPlugin.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nchannels.publish({\"message\": \"Hello\"}, \"general\")\n```\n\n----------------------------------------\n\nTITLE: Raw WebSocket Handler with Stream\nDESCRIPTION: Demonstrates implementing a raw WebSocket handler that combines streaming and receiving data without using the listener pattern.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/websockets.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@websocket(\"/ws\")\nasync def handler(socket: WebSocket) -> None:\n    async def counter() -> AsyncGenerator[int, None]:\n        for i in range(5):\n            yield i\n            await asyncio.sleep(1)\n\n    stream_task = create_task(\n        send_websocket_stream(\n            socket,\n            counter(),\n            listen_for_disconnect=False,\n        )\n    )\n\n    try:\n        while True:\n            data = await socket.receive_json()\n            print(f\"received {data}\")\n    except WebSocketDisconnect:\n        stream_task.cancel()\n        raise\n```\n\n----------------------------------------\n\nTITLE: Customizing JWT Payload Decoding in Python\nDESCRIPTION: Demonstration of customizing the JWT payload decoding process by overriding the decode_payload method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Custom Plain Text Exception Handler\nDESCRIPTION: Example of overriding the default exception handler to return plain-text responses instead of JSON.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/exceptions.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.exceptions import HTTPException\n\nasync def plain_text_exception_handler(request: Request, exc: HTTPException) -> Response:\n    return PlainTextResponse(content=exc.detail, status_code=exc.status_code)\n\napp = Litestar(\n    route_handlers=[...],\n    exception_handlers={HTTPException: plain_text_exception_handler}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Allowed Hosts Middleware in Litestar\nDESCRIPTION: This code demonstrates how to enable and configure the Allowed Hosts middleware in a Litestar application by passing an AllowedHostsConfig instance to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.config.allowed_hosts import AllowedHostsConfig\n\napp = Litestar(\n    route_handlers=[...],\n    allowed_hosts=AllowedHostsConfig(\n        allowed_hosts=[\"*.example.com\", \"www.wikipedia.org\"]\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Dataclasses for Improved Structure in Litestar TODO App\nDESCRIPTION: This example shows how to use dataclasses instead of plain dictionaries for better code structure and improved interactive documentation in a Litestar TODO application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/2-interacting-with-the-list.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass TodoItem:\n    title: str\n    done: bool = False\n\n@post(\"/\")\nasync def add_item(data: TodoItem) -> Dict[str, Any]:\n    todo_list.append(data)\n    return {\"message\": \"Item added successfully\", \"data\": data}\n```\n\n----------------------------------------\n\nTITLE: Creating Data with SQLAlchemy Repository in Python\nDESCRIPTION: This snippet demonstrates how to insert new data into the Author table using the repository's add method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    author_repo = context.get_repository(AuthorRepository)\n    author = await author_repo.add(\n        Author(\n            name=\"Ruka Vilas\",\n            dob=date(1993, 1, 1),\n            nationality=\"Australian\",\n        )\n    )\n    print(f\"Created author: {author}\")\n```\n\n----------------------------------------\n\nTITLE: Route-Level Authentication Exclusion in Litestar\nDESCRIPTION: Shows how to exclude specific routes from authentication using the exclude_from_auth parameter at the route decorator level.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/excluding-and-including-endpoints.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/secured\")\ndef secured_route() -> Any:\n    ...\n\n@get(\"/unsecured\", exclude_from_auth=True)\ndef unsecured_route() -> Any:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Custom Authentication Exclusion Key in Litestar\nDESCRIPTION: Demonstrates how to use a custom exclusion key (no_auth) instead of the default exclude_from_auth, including both route configuration and auth setup.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/excluding-and-including-endpoints.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/secured\")\ndef secured_route() -> Any:\n    ...\n\n@get(\"/unsecured\", no_auth=True)\ndef unsecured_route() -> Any:\n    ...\n\nsession_auth = SessionAuth[User, ServerSideSessionBackend](\nretrieve_user_handler=retrieve_user_handler,\n# we must pass a config for a session backend.\n# all session backends are supported\nsession_backend_config=ServerSideSessionConfig(),\n# exclude any URLs that should not have authentication.\n# We exclude the documentation URLs, signup and login.\nexclude=[\"/login\", \"/signup\", \"/schema\"],\nexclude_opt_key=\"no_auth\"  # default value is `exclude_from_auth`\n)\n```\n\n----------------------------------------\n\nTITLE: Bulk Insert with SQLAlchemy Repository in Python\nDESCRIPTION: This code demonstrates a bulk insert operation using the repository's add_many method, efficiently adding multiple records in a single transaction.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    state_repo = context.get_repository(StateRepository)\n    states = [State(**state) for state in fixture_data]\n    await state_repo.add_many(states)\n    print(f\"Inserted {len(states)} states\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Litestar CLI Plugin\nDESCRIPTION: Example of how to create a custom CLI plugin for Litestar using the CLIPluginProtocol. This plugin adds a new command to check if the app is in debug mode.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.plugins import CLIPluginProtocol\nfrom click import Group\n\n\nclass CLIPlugin(CLIPluginProtocol):\n    def on_cli_init(self, cli: Group) -> None:\n        @cli.command()\n        def is_debug_mode(app: Litestar):\n            print(app.debug)\n\n\napp = Litestar(plugins=[CLIPlugin()])\n```\n\n----------------------------------------\n\nTITLE: Implementing detect_nested_field Method for Custom DTO in Python\nDESCRIPTION: This method determines if a given field is a nested model field. It receives a FieldDefinition instance and should return a boolean indicating whether the field is nested.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/2-creating-custom-dto-classes.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef detect_nested_field(self, field_definition: FieldDefinition) -> bool:\n```\n\n----------------------------------------\n\nTITLE: Creating SQLAlchemy Model Repository in Python\nDESCRIPTION: This snippet shows how to create an AuthorRepository class by inheriting from SQLAlchemyAsyncRepository. It sets up the basic structure for repository operations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom advanced_alchemy.repository import SQLAlchemyAsyncRepository\n\nclass AuthorRepository(SQLAlchemyAsyncRepository[Author]):\n    \"\"\"Author repository.\"\"\"\n\n    model_type = Author\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Routes with Path Parameters in Litestar\nDESCRIPTION: This snippet demonstrates how to create dynamic routes using path parameters in Litestar. It shows a simple greeter function that uses a path parameter to personalize the greeting.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/2-interacting-with-the-list.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/{name:str}\")\nasync def greeter(name: str) -> str:\n    return \"Hello, \" + name\n```\n\n----------------------------------------\n\nTITLE: Router Registration Example\nDESCRIPTION: Demonstrates how to register routers with nested paths and handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Router, get\n\n@get(\"/{order_id:int}\")\ndef order_handler(order_id: int) -> None: ...\n\norder_router = Router(path=\"/orders\", route_handlers=[order_handler])\nbase_router = Router(path=\"/base\", route_handlers=[order_router])\napp = Litestar(route_handlers=[base_router])\n```\n\n----------------------------------------\n\nTITLE: Custom Pydantic Type Integration in Litestar\nDESCRIPTION: Shows how to implement and use custom Pydantic types directly within Litestar applications. This demonstrates Litestar's native support for Pydantic type handling.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/custom-types.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n/examples/encoding_decoding/custom_type_pydantic.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Files as Attachments in Python\nDESCRIPTION: Demonstrates how to configure static files to be sent as attachments using send_as_attachment parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(\n            path=\"/static\",\n            directories=[\"assets\"],\n            send_as_attachment=True,\n        )\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Multiple Event Listening in Litestar\nDESCRIPTION: Shows how to create a listener that handles multiple different event types using a single handler function.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.events import listener\n\n\n@listener(\"user_created\", \"password_changed\")\nasync def send_email_handler(email: str, message: str) -> None:\n    # do something here to send an email\n\n    await send_email(email, message)\n```\n\n----------------------------------------\n\nTITLE: Updating TODO Items with Path Parameters and POST Data in Litestar\nDESCRIPTION: This example combines path parameters and POST data to update a specific TODO item. It uses the item's title as a path parameter and receives updated item data in the request body.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/2-interacting-with-the-list.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@post(\"/{title:str}\")\nasync def update_item(title: str, data: TodoItem) -> Dict[str, Any]:\n    for item in todo_list:\n        if item.title == title:\n            item.done = data.done\n            return {\"message\": \"Item updated successfully\", \"data\": item}\n    return {\"message\": \"Item not found\"}, 404\n```\n\n----------------------------------------\n\nTITLE: Applying Middleware to Litestar Application\nDESCRIPTION: Shows how to apply a middleware factory to a Litestar application instance. The middleware will be executed for every request handled by the application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/using-middleware.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.types import ASGIApp, Scope, Receive, Send\nfrom litestar import Litestar\n\n\ndef middleware_factory(app: ASGIApp) -> ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -> None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n\n\napp = Litestar(route_handlers=[...], middleware=[middleware_factory])\n```\n\n----------------------------------------\n\nTITLE: Using the Prometheus Exporter in Litestar\nDESCRIPTION: Example of how to instrument a Litestar application with the Prometheus exporter. Shows basic setup and usage.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/prometheus.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Content of this code block is not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Custom Cache Response Filter in Litestar\nDESCRIPTION: Illustrates how to implement a custom cache response filter that only caches successful (2xx) responses.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Response\nfrom litestar.config.response_cache import ResponseCacheConfig\n\ndef custom_cache_response_filter(response: Response) -> bool:\n    return 200 <= response.status_code < 300\n\napp = Litestar(\n    response_cache_config=ResponseCacheConfig(\n        cache_response_filter=custom_cache_response_filter\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Bulk Delete with SQLAlchemy Repository in Python\nDESCRIPTION: This code demonstrates a bulk delete operation using the repository's delete_many method, efficiently removing multiple records in a single transaction.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    state_repo = context.get_repository(StateRepository)\n    await state_repo.delete_many([state.id for state in paginated_states])\n```\n\n----------------------------------------\n\nTITLE: Excluding Default Dependencies from OpenAPI Documentation\nDESCRIPTION: Shows how to use the Dependency function to explicitly mark parameters as dependencies, ensuring they are excluded from OpenAPI documentation even when they have default values.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndependency_with_dependency_fn_and_default.py\n```\n\n----------------------------------------\n\nTITLE: Extending AbstractMiddleware in Python\nDESCRIPTION: Shows how to create a middleware by extending the AbstractMiddleware class. This example demonstrates adding a process time header and using class variables to configure middleware behavior.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\nfrom litestar.enums import ScopeType\nfrom litestar.middleware import AbstractMiddleware\nfrom litestar.datastructures import MutableScopeHeaders\nfrom litestar.types import Message, Receive, Scope, Send\n\n\nclass MyMiddleware(AbstractMiddleware):\n    scopes = {ScopeType.HTTP}\n    exclude = [\"first_path\", \"second_path\"]\n    exclude_opt_key = \"exclude_from_middleware\"\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        start_time = time.monotonic()\n\n        async def send_wrapper(message: \"Message\") -> None:\n            if message[\"type\"] == \"http.response.start\":\n                process_time = time.monotonic() - start_time\n                headers = MutableScopeHeaders.from_message(message=message)\n                headers[\"X-Process-Time\"] = str(process_time)\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Creating Utility Functions for Database Operations in Python\nDESCRIPTION: This snippet defines utility functions for retrieving TODO items from the database. It includes functions to get all items and to get a single item by ID.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/4-final-touches-and-recap.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom litestar.exceptions import NotFoundException\n\nasync def get_all_todo_items(session: Session) -> list[TodoItem]:\n    result = await session.execute(select(TodoItem))\n    return result.scalars().all()\n\nasync def get_todo_item(session: Session, todo_id: int) -> TodoItem:\n    todo_item = await session.get(TodoItem, todo_id)\n    if not todo_item:\n        raise NotFoundException(detail=f\"Todo item {todo_id} not found\")\n    return todo_item\n```\n\n----------------------------------------\n\nTITLE: Removing Data with SQLAlchemy Repository in Python\nDESCRIPTION: This snippet demonstrates how to delete data from the database using the repository's remove method with a primary key.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    author_repo = context.get_repository(AuthorRepository)\n    await author_repo.remove(author.id)\n    print(f\"Removed author with id: {author.id}\")\n    print(f\"Author count: {await author_repo.count()}\")\n```\n\n----------------------------------------\n\nTITLE: Creating Request Logging Middleware in Python\nDESCRIPTION: Shows how to create a middleware for logging incoming HTTP requests by subclassing the MiddlewareProtocol. This example demonstrates accessing request information within the middleware.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom litestar.types import ASGIApp, Receive, Scope, Send\nfrom litestar import Request\nfrom litestar.middleware.base import MiddlewareProtocol\n\nlogger = logging.getLogger(__name__)\n\n\nclass MyRequestLoggingMiddleware(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -> None:  # can have other parameters as well\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] == \"http\":\n            request = Request(scope)\n            logger.info(\"Got request: %s - %s\", request.method, request.url)\n        await self.app(scope, receive, send)\n```\n\n----------------------------------------\n\nTITLE: Installing Litestar CLI with Standard Features\nDESCRIPTION: Command to install Litestar with the 'standard' extra, which includes all CLI features and dependencies like uvicorn and jsbeautifier.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install litestar[standard]\n```\n\n----------------------------------------\n\nTITLE: Implementing User Model with Role for Authorization in Python\nDESCRIPTION: Defines a 'User' model class with properties including 'id', 'email', 'name', 'role', and 'password'. The 'role' property uses the previously defined UserRole enum.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/guards.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass User:\n    def __init__(\n        self,\n        id: int,\n        email: str,\n        name: str,\n        role: UserRole,\n        password: str,\n    ) -> None:\n        self.id = id\n        self.email = email\n        self.name = name\n        self.role = role\n        self.password = password\n```\n\n----------------------------------------\n\nTITLE: Exempting Routes from CSRF Protection\nDESCRIPTION: This snippet shows how to mark specific routes as exempt from CSRF protection using the exclude_from_csrf parameter in the route decorator.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@post(\"/post\", exclude_from_csrf=True)\ndef handler() -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Organizing Handlers with Controller and DTOs in Litestar\nDESCRIPTION: This snippet shows how to organize handlers into a controller class in Litestar, demonstrating the use of controller-level DTO declarations. It illustrates how common configurations can be moved to the controller layer, reducing repetition in individual handlers.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/10-layered-dto-declarations.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Controller, get, post, put, patch, delete\nfrom litestar.dto import DTOConfig\nfrom litestar.dto.factory import dto_factory\nfrom litestar.enums import RequestEncodingType\nfrom litestar.params import Parameter\n\nfrom schemas import Person, PersonCreate, PersonUpdate, PersonPatch\n\n\nclass PersonController(Controller):\n    path = \"/people\"\n    dto = DTOConfig(PersonCreate)\n    return_dto = DTOConfig(Person)\n\n    @get()\n    def list_people(self) -> list[Person]:\n        ...\n\n    @post()\n    def create_person(self, data: PersonCreate) -> Person:\n        ...\n\n    @get(\"/{person_id:int}\")\n    def get_person(self, person_id: int) -> Person:\n        ...\n\n    @put(\"/{person_id:int}\")\n    def update_person(self, person_id: int, data: PersonUpdate) -> Person:\n        ...\n\n    @patch(\n        \"/{person_id:int}\",\n        dto=dto_factory(PersonPatch, json_schema_extra={\"examples\": [{\"name\": \"string\"}]}),\n    )\n    def patch_person(self, person_id: int, data: PersonPatch) -> Person:\n        ...\n\n    @delete(\"/{person_id:int}\")\n    def delete_person(self, person_id: int) -> None:\n        ...\n\n\nfrom litestar import Litestar\n\napp = Litestar([PersonController])\n```\n\n----------------------------------------\n\nTITLE: Migrating from AbstractMiddleware to ASGIMiddleware in Python\nDESCRIPTION: Shows how to migrate from using AbstractMiddleware to ASGIMiddleware for implementing middlewares. This example is referenced but the specific code is not provided in the text.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# This code snippet is referenced but not directly provided in the text\n```\n\n----------------------------------------\n\nTITLE: Defining TodoItem Model with SQLAlchemy in Python\nDESCRIPTION: This snippet defines the TodoItem model class representing a TODO item. It extends from SQLAlchemy's DeclarativeBase and includes fields for id, title, and completed status.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/4-final-touches-and-recap.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass TodoItem(DeclarativeBase):\n    __tablename__ = \"todo_items\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str] = mapped_column(String(100))\n    completed: Mapped[bool] = mapped_column(default=False)\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging without Litestar's LoggingConfig (Python)\nDESCRIPTION: This snippet shows how to configure logging in a Litestar application without using Litestar's LoggingConfig. It sets up a custom logger using Python's standard logging library.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/logging.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nfrom litestar import Litestar, Request, get\nfrom litestar.logging.config import LoggingConfig\n\n\ndef get_logger(mod_name: str) -> logging.Logger:\n    \"\"\"Return logger object.\"\"\"\n    format = \"%(asctime)s: %(name)s: %(levelname)s: %(message)s\"\n    logger = logging.getLogger(mod_name)\n    # Writes to stdout\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.INFO)\n    ch.setFormatter(logging.Formatter(format))\n    logger.addHandler(ch)\n    return logger\n\n\nlogger = get_logger(__name__)\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -> None:\n    logger.info(\"logger inside a request\")\n\n\napp = Litestar(\n    route_handlers=[my_router_handler],\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Client-Side Session Backend in Litestar\nDESCRIPTION: Illustrates how to set up client-side sessions using the ClientSideSessionBackend in Litestar. This backend offers AES-CGM encryption for secure cookie-based sessions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Content of cookie_backend.py is not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads in Litestar\nDESCRIPTION: This snippet shows how to handle file uploads in Litestar using the Body annotation with RequestEncodingType.MULTI_PART. It defines a route that accepts a list of uploaded files and returns their filenames.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@post(\"/upload/\")\nasync def upload_file(data: Annotated[list[UploadFile], Body(media_type=RequestEncodingType.MULTI_PART)]) -> dict[str, str]:\n    return {\"file_names\": [file.filename for file in data]}\n\napp = Litestar([upload_file])\n```\n\n----------------------------------------\n\nTITLE: Setting Up Litestar API Endpoint for Todo Items in Python\nDESCRIPTION: This code sets up an API endpoint at the root ('/') for adding TodoItems to a SQLite database. It includes the necessary imports and defines the handler function for both async and sync implementations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, post\nfrom litestar.status_codes import HTTP_201_CREATED\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n@post(\"/\", status_code=HTTP_201_CREATED)\nasync def add_todo_item(data: TodoItem, db_session: AsyncSession) -> TodoItem:\n    db_session.add(data)\n    await db_session.commit()\n    return data\n```\n\n----------------------------------------\n\nTITLE: Dictionary-based File Upload Handling\nDESCRIPTION: Shows how to handle file uploads using a dictionary approach\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.datastructures import UploadFile\n\nasync def handler(data: dict[str, UploadFile]) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Configuring GZIP Compression in Litestar\nDESCRIPTION: This snippet shows how to enable GZIP compression for responses in a Litestar application by passing a CompressionConfig instance with the 'gzip' backend to the Litestar constructor.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.config.compression import CompressionConfig\n\napp = Litestar(\n    route_handlers=[...],\n    compression_config=CompressionConfig(backend=\"gzip\", gzip_compress_level=9),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating AuthorRepository Instance Function in Python\nDESCRIPTION: This function creates and returns an instance of AuthorRepository, used for injecting a repository instance into controller routes. It takes a database session as a parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/03-repository-controller.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef get_author_repo(db_session: AsyncSession) -> AuthorRepository[Author]:\n    return AuthorRepository[Author](session=db_session, model=Author)\n```\n\n----------------------------------------\n\nTITLE: Indefinite Response Caching in Litestar\nDESCRIPTION: Demonstrates how to cache responses indefinitely using the CACHE_FOREVER sentinel.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.config.response_cache import CACHE_FOREVER\n\n@get(\"/\")\n@cache(expiration=CACHE_FOREVER)\ndef handler() -> dict[str, str]:\n    return {\"hello\": \"world\"}\n```\n\n----------------------------------------\n\nTITLE: Litestar Handlers Without SQLAlchemy Serialization Plugin\nDESCRIPTION: This code snippet shows the Litestar application handlers before implementing the SQLAlchemy Serialization Plugin. It demonstrates the more verbose approach required when not using the plugin, including separate serialization functions and type aliases.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/2-serialization-plugin.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/contrib/sqlalchemy/plugins/tutorial/full_app_no_plugins.py\n    :language: python\n    :linenos:\n    :lines: 1-12, 67-100\n```\n\n----------------------------------------\n\nTITLE: Mounting Starlette App in Litestar\nDESCRIPTION: Example demonstrating how to mount a Starlette ASGI application within a Litestar application. This shows the integration between different ASGI frameworks, particularly useful for incorporating third-party libraries.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmounting_starlette_app.py\n```\n\n----------------------------------------\n\nTITLE: Litestar Handlers Using SQLAlchemy Serialization Plugin\nDESCRIPTION: This code snippet shows the simplified Litestar application handlers after implementing the SQLAlchemy Serialization Plugin. It demonstrates how the handlers can now directly receive and return SQLAlchemy models without need for separate serialization functions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/2-serialization-plugin.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /examples/contrib/sqlalchemy/plugins/tutorial/full_app_with_serialization_plugin.py\n    :language: python\n    :linenos:\n    :lines: 1-13, 73-99\n```\n\n----------------------------------------\n\nTITLE: Essential Supervisor Control Commands\nDESCRIPTION: Basic shell commands for managing Supervisor services including reloading config, controlling service state, and viewing logs.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/supervisor.rst#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsudo supervisorctl reread\nsudo supervisorctl update\n```\n\nLANGUAGE: shell\nCODE:\n```\nsudo supervisorctl start exampleapp\nsudo supervisorctl stop exampleapp\nsudo supervisorctl restart exampleapp\nsudo supervisorctl status exampleapp\n```\n\nLANGUAGE: shell\nCODE:\n```\nsudo supervisorctl tail -f exampleapp\n```\n\n----------------------------------------\n\nTITLE: Litestar Route Handler with Injected Session\nDESCRIPTION: Example of a route handler using dependency injection to receive the database session as a parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/1-provide-session-with-di.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def add_item(item: ToDoItem, transaction: AsyncSession) -> ToDoItem:\n    transaction.add(item)\n    await transaction.flush()\n    return item\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection Without Provide\nDESCRIPTION: Shows how to declare dependencies without using Provide class, demonstrating both the old and new syntax.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def some_dependency() -> str: ...\n\n\napp = Litestar(dependencies={\"some\": Provide(some_dependency)})\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def some_dependency() -> str: ...\n\n\napp = Litestar(dependencies={\"some\": some_dependency})\n```\n\n----------------------------------------\n\nTITLE: Multiple Route Handler Registration\nDESCRIPTION: Demonstrates registering the same route handler multiple times on different paths.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Router, get\n\n@get(path=\"/handler\")\ndef my_route_handler() -> None: ...\n\ninternal_router = Router(path=\"/internal\", route_handlers=[my_route_handler])\npartner_router = Router(path=\"/partner\", route_handlers=[my_route_handler])\nconsumer_router = Router(path=\"/consumer\", route_handlers=[my_route_handler])\n\nLitestar(route_handlers=[internal_router, partner_router, consumer_router])\n```\n\n----------------------------------------\n\nTITLE: Custom Cache Key Builder in Litestar\nDESCRIPTION: Demonstrates how to implement a custom cache key builder function for application-wide caching.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/caching.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Request\nfrom litestar.config.response_cache import ResponseCacheConfig\n\ndef custom_key_builder(request: Request) -> str:\n    return f\"{request.method}:{request.url}\"\n\napp = Litestar(\n    response_cache_config=ResponseCacheConfig(cache_key_builder=custom_key_builder)\n)\n```\n\n----------------------------------------\n\nTITLE: Loading Fixture Data from JSON in Python\nDESCRIPTION: This function loads fixture data from a JSON file, demonstrating a pattern for populating the database with sample data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef load_fixture_data(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"Load fixture data from a JSON file.\"\"\"\n    with open(file_path, \"r\") as file:\n        data = json.load(file)\n    return data\n\nfixture_data = load_fixture_data(\"us_state_lookup.json\")\n```\n\n----------------------------------------\n\nTITLE: Raising HTTP Exceptions in Litestar\nDESCRIPTION: This snippet demonstrates how to raise an HTTPException in Litestar with a status code and custom detail message. It shows the use of keyword arguments for the exception, which is different from FastAPI.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.exceptions import HTTPException\n\n@get(\"/\")\nasync def index() -> None:\n    response_fields = {\"array\": \"value\"}\n    raise HTTPException(\n        status_code=400, detail=f\"can't get that field: {response_fields.get('array')}\"\n    )\n\napp = Litestar([index])\n```\n\n----------------------------------------\n\nTITLE: Implementing MiddlewareProtocol in Python\nDESCRIPTION: Demonstrates the minimal implementation of a middleware using the MiddlewareProtocol class. This protocol specifies the required methods for a middleware implementation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Protocol, Any\nfrom litestar.types import ASGIApp, Scope, Receive, Send\n\n\nclass MiddlewareProtocol(Protocol):\n    def __init__(self, app: ASGIApp, **kwargs: Any) -> None: ...\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Defining SQLAlchemy Models for Todo Items in Python\nDESCRIPTION: This snippet demonstrates how to define SQLAlchemy models for a Todo application, including a base model and a TodoItem class. It shows the structure for both async and sync implementations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass TodoItem(Base):\n    __tablename__ = \"todo_items\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    done: Mapped[bool] = mapped_column(default=False)\n```\n\n----------------------------------------\n\nTITLE: Importing Litestar LifeSpanHandler in Python\nDESCRIPTION: This snippet demonstrates how to import the LifeSpanHandler class from the Litestar testing module. The LifeSpanHandler is used for managing the lifecycle of the application during tests.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/testing.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom litestar.testing.life_span_handler import LifeSpanHandler\n```\n\n----------------------------------------\n\nTITLE: Using Field Renaming Strategy in Litestar DTO (Python)\nDESCRIPTION: This code snippet shows how to use a field renaming strategy in a Litestar DTO. It applies the 'upper' strategy to convert all field names to uppercase.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/05-renaming-fields.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get\nfrom litestar.dto import DataclassDTO, DTOConfig\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    address: str\n\n\nclass UserModelDTO(DataclassDTO[User]):\n    config = DTOConfig(\n        rename_strategy=\"upper\"\n    )\n\n\n@get(\"/\")\ndef index() -> User:\n    return User(name=\"John\", age=30, address=\"123 Main St\")\n\n\napp = Litestar(\n    route_handlers=[index],\n    dto=UserModelDTO,\n)\n```\n\n----------------------------------------\n\nTITLE: Process Execution with AnyIO\nDESCRIPTION: Example showing how to offload computationally intensive tasks to a separate process using AnyIO's to_process.run_sync function\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/sync-vs-async.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nanyio.to_process.run_sync\n```\n\n----------------------------------------\n\nTITLE: Installing Litestar with pip\nDESCRIPTION: Basic installation command for Litestar using pip. The standard installation includes commonly used extras like uvicorn and jinja2 for templating.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install litestar\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging Middleware in Litestar\nDESCRIPTION: Demonstrates how to set up and configure the logging middleware in Litestar. It shows how to obfuscate sensitive data in logs and handle compression of response bodies.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.middleware.logging import LoggingMiddlewareConfig\n\nlogging_middleware_config = LoggingMiddlewareConfig(\n    request_cookies_to_obfuscate={\"my-custom-session-key\"},\n    response_cookies_to_obfuscate={\"my-custom-session-key\"},\n    request_headers_to_obfuscate={\"my-custom-header\"},\n    response_headers_to_obfuscate={\"my-custom-header\"},\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Max Nested Depth in Litestar DTO Configuration\nDESCRIPTION: Example showing how to configure max_nested_depth in Litestar DTO to control the depth of nested object serialization. The code sets max_nested_depth to 2 to include children of children in the response.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/04-max-nested-depth.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n/examples/data_transfer_objects/factory/tutorial/max_nested_depth.py\n```\n\n----------------------------------------\n\nTITLE: Raising HTTP Exceptions in FastAPI\nDESCRIPTION: This code shows how to raise an HTTPException in FastAPI with a status code and custom detail message. It demonstrates the use of positional arguments for the exception.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def index() -> None:\n    response_fields = {\"array\": \"value\"}\n    raise HTTPException(\n        400, detail=f\"can't get that field: {response_fields.get('array')}\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Generating Jinja Module Documentation with Sphinx in reStructuredText\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.contrib.jinja module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/jinja.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\njinja\n=====\n\n.. automodule:: litestar.contrib.jinja\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Query Parameter in Python with Litestar\nDESCRIPTION: This snippet demonstrates how to make a query parameter optional by providing a default value. It shows how to handle cases where the query parameter is not provided, returning all items when the parameter is omitted.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/1-accessing-the-list.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom litestar import Litestar, get\n\n\n@dataclass\nclass TodoItem:\n    id: str\n    item: str\n    done: bool\n\n\n@get(\"/\")\ndef get_list(done: Optional[bool] = None) -> List[TodoItem]:\n    todos = [\n        TodoItem(id=\"1\", item=\"Make this list more useful\", done=False),\n        TodoItem(id=\"2\", item=\"Buy groceries\", done=False),\n        TodoItem(id=\"3\", item=\"Do laundry\", done=True),\n    ]\n    if done is not None:\n        return [todo for todo in todos if todo.done == done]\n    return todos\n\n\napp = Litestar(route_handlers=[get_list])\n```\n\n----------------------------------------\n\nTITLE: Importing Litestar Testing Module in Python\nDESCRIPTION: This snippet shows how to import the testing module from Litestar. It includes various classes and functions for testing Litestar applications.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/testing.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom litestar.testing import RequestFactory, BaseTestClient, TestClient, AsyncTestClient, create_async_test_client, create_test_client, subprocess_sync_client, subprocess_async_client\n```\n\n----------------------------------------\n\nTITLE: Setting Response Cookies in Litestar\nDESCRIPTION: Shows two equivalent methods for setting response cookies in Litestar 2.x using either Cookie objects or a simple dictionary mapping.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\", response_cookies=[Cookie(key=\"foo\", value=\"bar\")])\nasync def handler() -> None: ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/\", response_cookies={\"foo\": \"bar\"})\nasync def handler() -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Running Daphne ASGI Server with Default Configuration\nDESCRIPTION: Command to start the Daphne ASGI server with default settings, assuming the app is defined in 'app.py'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ndaphne app:app\n```\n\n----------------------------------------\n\nTITLE: SQLAlchemy Model Serialization\nDESCRIPTION: Defines type aliases and serialization function for converting SQLAlchemy models to JSON-serializable formats for API responses.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/0-introduction.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict, Sequence\n\nTodoType = TypedDict(\"TodoType\", {\"id\": int, \"text\": str, \"is_done\": bool})\nTodoCollectionType = Sequence[TodoType]\n\ndef serialize_todo(todo: TodoItem) -> TodoType:\n    return {\"id\": todo.id, \"text\": todo.text, \"is_done\": todo.is_done}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Session Middleware in Litestar\nDESCRIPTION: Shows how to set up and use session middleware in a Litestar application. This example demonstrates a basic 'Hello World' application with session middleware configured.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Content of this code block is not provided in the input text\n```\n\n----------------------------------------\n\nTITLE: Template Rendering Implementation\nDESCRIPTION: Shows the different approaches to template rendering between FastAPI and Litestar frameworks.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@app.get(\"/uploads\")\nasync def get_uploads(request: Request):\n    return templates.TemplateResponse(\n        \"uploads.html\", {\"request\": request, \"debug\": app.state.debug}\n    )\n```\n\nLANGUAGE: python\nCODE:\n```\n@get(\"/uploads\")\nasync def get_uploads(app_settings) -> Template:\n    return Template(\n        name=\"uploads.html\", context={\"debug\": app_settings.debug}\n    )\n```\n\n----------------------------------------\n\nTITLE: Counting Records with SQLAlchemy Repository in Python\nDESCRIPTION: This snippet shows how to count the number of records in the database using the repository's count method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    state_repo = context.get_repository(StateRepository)\n    print(f\"Remaining states: {await state_repo.count()}\")\n```\n\n----------------------------------------\n\nTITLE: Early Detection of Missing Dependencies in Litestar\nDESCRIPTION: Demonstrates how to use dependency markers for early detection of missing non-optional dependencies, preventing runtime failures by catching issues during application startup.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dependency-injection.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndependency_non_optional_not_provided.py\n```\n\n----------------------------------------\n\nTITLE: Multiple Controller Registration\nDESCRIPTION: Shows how to register the same controller multiple times on different paths.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Router, Controller, get\n\nclass MyController(Controller):\n   path = \"/controller\"\n\n   @get()\n   def handler(self) -> None: ...\n\ninternal_router = Router(path=\"/internal\", route_handlers=[MyController])\npartner_router = Router(path=\"/partner\", route_handlers=[MyController])\nconsumer_router = Router(path=\"/consumer\", route_handlers=[MyController])\n```\n\n----------------------------------------\n\nTITLE: Sync To Thread Route Handler Examples\nDESCRIPTION: Demonstrates different ways to handle synchronous route handlers with sync_to_thread option in Litestar 2.x.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@get()\ndef handler() -> None: ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@get(sync_to_thread=False)\ndef handler() -> None: ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@get(sync_to_thread=True)\ndef handler() -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Modern Static Files Router Migration in Python\nDESCRIPTION: Shows the recommended way to upgrade from StaticFilesConfig to create_static_files_router.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(\n    route_handlers=[create_static_files_router(path=\"/static\", directories=[\"assets\"])]\n)\n```\n\n----------------------------------------\n\nTITLE: Router Options Configuration for Static Files in Python\nDESCRIPTION: Example of passing additional router options when creating static files router.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(\n            path=\"/static\",\n            directories=[\"assets\"],\n            opt1=\"value1\",\n            opt2=\"value2\",\n        )\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: URL Encoded Form Data Handling\nDESCRIPTION: Shows how to handle URL encoded form data using RequestEncodingType.URL_ENCODED\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/requests.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.enums import RequestEncodingType\nfrom litestar.params import Body\n\nasync def handler(data: dict = Body(media_type=RequestEncodingType.URL_ENCODED)) -> None: ...\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Channels with Explicit Channel Names in Python\nDESCRIPTION: Example showing how to configure the ChannelsPlugin with explicitly defined channel names using the channels parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.channels import ChannelsPlugin\n\nchannels_plugin = ChannelsPlugin(..., channels=[\"foo\", \"bar\"])\n```\n\n----------------------------------------\n\nTITLE: Sample Response Outputs\nDESCRIPTION: Example outputs from the minimal application showing both a string response and a JSON response for the defined endpoints.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n\"Hello, world!\"\n```\n\nLANGUAGE: json\nCODE:\n```\n{\"book_id\": a1}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Minimal Litestar Application in Python\nDESCRIPTION: This code defines a basic Litestar application with two route handlers: an asynchronous and a synchronous hello world endpoint.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Minimal Litestar application.\"\"\"\n\nfrom asyncio import sleep\nfrom typing import Any, Dict\n\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\nasync def async_hello_world() -> Dict[str, Any]:\n    \"\"\"Route Handler that outputs hello world.\"\"\"\n    await sleep(0.1)\n    return {\"hello\": \"world\"}\n\n\n@get(\"/sync\", sync_to_thread=False)\ndef sync_hello_world() -> Dict[str, Any]:\n    \"\"\"Route Handler that outputs hello world.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Litestar(route_handlers=[sync_hello_world, async_hello_world])\n```\n\n----------------------------------------\n\nTITLE: FastAPI vs Litestar Basic Routing\nDESCRIPTION: Comparison of basic routing setup between FastAPI and Litestar. Shows how routes are registered using decorators in FastAPI versus standalone handlers in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def index() -> dict[str, str]: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n@get(\"/\")\nasync def index() -> dict[str, str]: ...\n\napp = Litestar([index])\n```\n\n----------------------------------------\n\nTITLE: Installing Prometheus Client as Separate Package\nDESCRIPTION: Command to install the prometheus-client package separately using pip.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/prometheus.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install prometheus-client\n```\n\n----------------------------------------\n\nTITLE: Excluding Individual Routes from CustomAuthenticationMiddleware in Python\nDESCRIPTION: This snippet illustrates how to exclude specific routes from the CustomAuthenticationMiddleware authentication process.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get\nfrom litestar.contrib.jwt import OAuth2Login\nfrom litestar.security.jwt import Token\n\n@get(\"/login\", exclude_from_auth=True)\ndef login_handler(login_data: OAuth2Login) -> Token:\n    # authenticate user\n    ...\n    # generate and return token\n    ...\n```\n\n----------------------------------------\n\nTITLE: Custom File System Integration for Static Files in Python\nDESCRIPTION: Example of using a custom file system implementation with create_static_files_router.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\nfrom fsspec import filesystem\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(\n            path=\"/static\",\n            directories=[\"assets\"],\n            file_system=filesystem(\"file\"),\n        )\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Files in Litestar\nDESCRIPTION: Demonstrates how to configure static file serving in Litestar using create_static_files_router. Unlike Flask's automatic static file serving, Litestar requires explicit configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files import create_static_files_router\n\napp = Litestar(route_handlers=[\n    create_static_files_router(path=\"/static\", directories=[\"assets\"]),\n])\n```\n\n----------------------------------------\n\nTITLE: Configuring Litestar with CustomAuthenticationMiddleware in Python\nDESCRIPTION: This code demonstrates how to pass the CustomAuthenticationMiddleware to the Litestar constructor when initializing the application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\n\napp = Litestar(\n    route_handlers=[...],\n    middleware=[\n        CustomAuthenticationMiddleware(\n            exclude=\"/public\",\n        )\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Running a Litestar Application with Uvicorn\nDESCRIPTION: Command to run a Litestar application using the Uvicorn ASGI server with auto-reload enabled for development.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nuvicorn my_app.main:app --reload\n```\n\n----------------------------------------\n\nTITLE: Configuring Backoff Strategy in Python\nDESCRIPTION: Example showing how to configure a channels plugin with backoff strategy for managing backpressure with a 1000 message limit.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/channels.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar.channels import ChannelsPlugin\nfrom litestar.channels.memory import MemoryChannelsBackend\n\nchannels = ChannelsPlugin(\n    backend=MemoryChannelsBackend(),\n    max_backlog=1000,\n    backlog_strategy=\"backoff\",\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Controllers with Litestar\nDESCRIPTION: Shows how to instantiate a Litestar application with controller-based route handlers, importing and registering a controller class.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\n\nfrom my_app.controllers.user import UserController\n\napp = Litestar(route_handlers=[UserController])\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Guards in Litestar\nDESCRIPTION: Shows how to implement route guards for authorization in Litestar using a guard function and applying it to a route handler.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/PYPI_README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\nfrom litestar.connection import ASGIConnection\nfrom litestar.handlers.base import BaseRouteHandler\nfrom litestar.exceptions import NotAuthorizedException\n\n\nasync def is_authorized(connection: ASGIConnection, handler: BaseRouteHandler) -> None:\n    # validate authorization\n    # if not authorized, raise NotAuthorizedException\n    raise NotAuthorizedException()\n\n\n@get(\"/\", guards=[is_authorized])\nasync def index() -> None: ...\n\n\napp = Litestar([index])\n```\n\n----------------------------------------\n\nTITLE: Installing Granian ASGI Server with pip\nDESCRIPTION: Command to install the Granian ASGI server using pip package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npip install granian\n```\n\n----------------------------------------\n\nTITLE: Configuring Sync vs Async Handlers in Litestar\nDESCRIPTION: Shows how to configure synchronous function handlers in Litestar using the sync_to_thread parameter. This parameter determines whether synchronous functions should run in a thread pool to prevent blocking the main event loop.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/admonitions/sync-to-thread-info.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@controller\ndef my_handler(self):\n    # Explicit thread pool usage\n    sync_to_thread=True  # Run in thread pool\n    \n    # For non-blocking sync functions\n    sync_to_thread=False  # Run directly\n```\n\n----------------------------------------\n\nTITLE: Dynamic Route Registration\nDESCRIPTION: Demonstrates dynamic route registration using the register method of the Litestar app instance.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n@get()\ndef root_handler() -> None: ...\n\napp = Litestar(route_handlers=[root_handler])\n\n@get(\"/sub-path\")\ndef sub_path_handler() -> None: ...\n\napp.register(sub_path_handler)\n```\n\n----------------------------------------\n\nTITLE: Raising HTTP Errors in Flask and Litestar\nDESCRIPTION: Shows how to raise HTTP errors in both frameworks. Flask uses the abort function, while Litestar raises an HTTPException.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, abort\n\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    abort(400, \"this did not work\")\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.exceptions import HTTPException\n\n\n@get(\"/\")\ndef index() -> None:\n    raise HTTPException(status_code=400, detail=\"this did not work\")\n\n\napp = Litestar([index])\n```\n\n----------------------------------------\n\nTITLE: Custom Router Class Implementation for Static Files in Python\nDESCRIPTION: Shows how to use a custom router class with create_static_files_router.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Router\nfrom litestar.static_files import create_static_files_router\n\nclass CustomRouter(Router):\n    pass\n\napp = Litestar(\n    route_handlers=[\n        create_static_files_router(\n            path=\"/static\",\n            directories=[\"assets\"],\n            router_class=CustomRouter,\n        )\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Supervisor Service for Litestar Application\nDESCRIPTION: Basic Supervisor configuration file that defines a service for running a Litestar application. Includes settings for directory, command, logging, and automatic process management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/supervisor.rst#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[program:exampleapp]\ndirectory=/opt/exampleapp/src\ncommand=/opt/exampleapp/venv/bin/litestar app.py\nredirect_stderr=true\nstdout_logfile=/var/log/exampleapp.log\nstdout_logfile_backups=10\nautostart=true\nautorestart=true\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Litestar Base DTO Module in reStructuredText\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the litestar.dto.base_dto module. This approach allows for comprehensive and up-to-date documentation of the module's contents.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/base_dto.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.dto.base_dto\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenTelemetry in Litestar Application\nDESCRIPTION: Python code demonstrating how to set up OpenTelemetry configuration and plugin in a Litestar application. This includes creating an OpenTelemetryConfig instance and adding it to the application via the plugins parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/open-telemetry.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.contrib.opentelemetry import OpenTelemetryConfig, OpenTelemetryPlugin\n\nopen_telemetry_config = OpenTelemetryConfig()\n\napp = Litestar(plugins=[OpenTelemetryPlugin(open_telemetry_config)])\n```\n\n----------------------------------------\n\nTITLE: Disabling Codegen Backend for Litestar DTO\nDESCRIPTION: Shows how to disable the codegen backend for a specific DTO in Litestar using the DTOConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/dto/0-basic-use.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom litestar.dto import DTOConfig, DataclassDTO\n\n@dataclass\nclass Foo:\n    name: str\n\nclass FooDTO(DataclassDTO[Foo]):\n    config = DTOConfig(experimental_codegen_backend=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Routing in Flask and Litestar\nDESCRIPTION: Demonstrates how to set up a basic web application with two routes in both Flask and Litestar. The example includes a root route and a redirect route.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, redirect, url_for\n\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    return \"hello\"\n\n\n@app.get(\"/hello\")\ndef hello():\n    return redirect(url_for(\"index\"))\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.response import Redirect\n\n\n@get(\"/\")\ndef index() -> str:\n    return \"hello\"\n\n\n@get(\"/hello\")\ndef hello() -> Redirect:\n    return Redirect(path=\"/\")\n\n\napp = Litestar([index, hello])\n```\n\n----------------------------------------\n\nTITLE: In-Handler Dynamic Route Registration\nDESCRIPTION: Shows how to register routes dynamically from within a route handler function.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nfrom litestar import Litestar, Request, get\n\n@get(\"/some-path\")\ndef route_handler(request: Request[Any, Any]) -> None:\n   @get(\"/sub-path\")\n   def sub_path_handler() -> None: ...\n\n   request.app.register(sub_path_handler)\n\napp = Litestar(route_handlers=[route_handler])\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Sleep Example in Python\nDESCRIPTION: Example showing how to make CPU-bound tasks asynchronous by introducing event loop switch points using asyncio.sleep(0)\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/sync-vs-async.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasyncio.sleep(0)\n```\n\n----------------------------------------\n\nTITLE: Application Lifespan Hook Migration Example\nDESCRIPTION: Demonstrates the migration from Starlite 1.51 to Litestar 2.x for application lifespan hooks, showing how to access application state.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef on_startup(state: State) -> None:\n    print(state.something)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef on_startup(app: Litestar) -> None:\n    print(app.state.something)\n```\n\n----------------------------------------\n\nTITLE: Rendering URL in HTML Template for Litestar and FastAPI\nDESCRIPTION: This snippet shows how to use the url_for function in an HTML template to generate a URL for a route named 'blabla' in both Litestar and FastAPI.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"{{ url_for('blabla') }}\">Blabla</a>\n```\n\n----------------------------------------\n\nTITLE: Using Immutable State in Litestar\nDESCRIPTION: Example of using ImmutableState to prevent state mutations in a Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/applications.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.datastructures import ImmutableState\n\n@get(\"/\")\ndef handler(state: ImmutableState) -> dict:\n    return {\"counter\": state.counter}\n\napp = Litestar(\n    route_handlers=[handler],\n    state=ImmutableState({\"counter\": 0})\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Response Headers in Litestar - v1.51 vs 2.x\nDESCRIPTION: Demonstrates the changes in setting response headers between Starlite 1.51 and Litestar 2.x. The new version supports both sequence of ResponseHeader objects and plain string mappings.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom starlite import ResponseHeader, get\n\n@get(response_headers={\"my-header\": ResponseHeader(value=\"header-value\")})\nasync def handler() -> str: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import ResponseHeader, get\n\n@get(response_headers=[ResponseHeader(name=\"my-header\", value=\"header-value\")])\nasync def handler() -> str: ...\n\n# or\n\n@get(response_headers={\"my-header\": \"header-value\"})\nasync def handler() -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Daphne Server Console Output\nDESCRIPTION: Example console output when starting the Daphne server, showing the server address and startup information.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nINFO - 2023-11-12 23:31:51,571 - daphne.cli - cli - Starting server at tcp:port=8000:interface=127.0.0.1\nINFO - 2023-11-12 23:31:51,572 - daphne.server - server - Listening on TCP address 127.0.0.1:8000\n```\n\n----------------------------------------\n\nTITLE: Alternative Decorator Syntax Example\nDESCRIPTION: Demonstrates how the @get decorator works under the hood by showing the equivalent non-decorator syntax.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/0-application-basics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def hello_world() -> str:\n    return \"Hello, world!\"\n\n\nhello_world = get(\"/\")(hello_world)\n```\n\n----------------------------------------\n\nTITLE: Controlling Exception Logging in Litestar (Python)\nDESCRIPTION: This snippet shows how to control exception logging by suppressing stack traces for specific exception types or HTTP status codes using the disable_stack_trace parameter in LoggingConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/logging.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.logging import LoggingConfig\n\n# Don't log stack traces for 404 errors and ValueError exceptions\nlogging_config = LoggingConfig(\n    debug=True,\n    disable_stack_trace={404, ValueError},\n)\n\napp = Litestar(logging_config=logging_config)\n```\n\n----------------------------------------\n\nTITLE: Automated Application Update Script for Supervisor\nDESCRIPTION: Comprehensive shell script for updating a Supervisor-managed application, including service control, git operations, dependency management, and configuration updates.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/supervisor.rst#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nexampleapp() {\n  case $1 in\n    update)\n      echo \"Updating exampleapp...\"\n\n      echo \" > Stopping service...\"\n      sudo supervisorctl stop exampleapp\n\n      echo \" > Pulling latest changes from repository...\"\n      cd /opt/exampleapp\n      git fetch --all\n      git reset --hard origin/master\n\n      echo \" > Updating Supervisor and shell configurations...\"\n      sudo ln -sf /opt/exampleapp/server/service.conf /etc/supervisor/conf.d/exampleapp.conf\n      sudo ln -sf /opt/exampleapp/server/alias.sh /etc/profile.d/exampleapp.sh\n      source /etc/profile.d/exampleapp.sh\n\n      echo \" > Reloading Supervisor configuration...\"\n      sudo supervisorctl reread\n      sudo supervisorctl update\n\n      source venv/bin/activate\n      echo \" > Installing updated dependencies...\"\n      python3 -m pip install -r requirements.txt\n      deactivate\n\n      echo \"Update process complete.\"\n\n      read -p \"Start the service? (y/n) \" -n 1 -r\n      echo\n      if [[ $REPLY =~ ^[Yy]$ ]]\n      then\n          echo \" > Starting service...\"\n          sudo supervisorctl start exampleapp\n      fi\n      ;;\n  esac\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection Implementation Comparison\nDESCRIPTION: Demonstrates the different approaches to dependency injection between FastAPI and Litestar. FastAPI uses Depends class while Litestar uses a dictionary with Provide class.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import FastAPI, Depends, APIRouter\n\nasync def route_dependency() -> bool: ...\nasync def nested_dependency() -> str: ...\nasync def router_dependency() -> int: ...\nasync def app_dependency(data: str = Depends(nested_dependency)) -> int: ...\n\nrouter = APIRouter(dependencies=[Depends(router_dependency)])\napp = FastAPI(dependencies=[Depends(nested_dependency)])\napp.include_router(router)\n\n@app.get(\"/\")\nasync def handler(\n    val_route: bool = Depends(route_dependency),\n    val_router: int = Depends(router_dependency),\n    val_nested: str = Depends(nested_dependency),\n    val_app: int = Depends(app_dependency),\n) -> None: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, Provide, get, Router\n\nasync def route_dependency() -> bool: ...\nasync def nested_dependency() -> str: ...\nasync def router_dependency() -> int: ...\nasync def app_dependency(nested: str) -> int: ...\n\n@get(\"/\", dependencies={\"val_route\": Provide(route_dependency)})\nasync def handler(\n    val_route: bool, val_router: int, val_nested: str, val_app: int\n) -> None: ...\n\nrouter = Router(dependencies={\"val_router\": Provide(router_dependency)})\napp = Litestar(\n    route_handlers=[handler],\n    dependencies={\n        \"val_app\": Provide(app_dependency),\n        \"val_nested\": Provide(nested_dependency),\n    },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for Litestar Application\nDESCRIPTION: This snippet shows the contents of a requirements.txt file, specifying the Litestar package with its standard extras to be installed.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nlitestar[standard]>=2.4.0,<3.0.0\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX Unit for Litestar\nDESCRIPTION: JSON configuration file for NGINX Unit to run a Litestar application, including listener and application settings.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/nginx-unit.rst#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"listeners\": {\n        \"*:8080\": {\n            \"pass\": \"applications/litestar\"\n        }\n    },\n    \"applications\": {\n        \"litestar\": {\n            \"type\": \"python 3.12\",\n            \"path\": \"/path/to/app\",\n            \"module\": \"run\",\n            \"callable\": \"app\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Litestar CLI with Entry Points (setup.py)\nDESCRIPTION: Example of how to add custom CLI commands to Litestar using entry points in a setup.py file with setuptools.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nsetup(\n   name=\"my-litestar-plugin\",\n   ...,\n   entry_points={\n       \"litestar.commands\": [\"my_command=my_litestar_plugin.cli:main\"],\n   },\n)\n```\n\n----------------------------------------\n\nTITLE: Documenting ChannelsException class in Litestar\nDESCRIPTION: This snippet uses the autoclass directive to generate documentation for the ChannelsException class from the litestar.channels.plugin module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/plugin.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: litestar.channels.plugin.ChannelsException\n```\n\n----------------------------------------\n\nTITLE: Before Send Hook Migration\nDESCRIPTION: Demonstrates the change in before_send hook signature, requiring an additional scope parameter in Litestar 2.x.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def before_send(message: Message, state: State) -> None: ...\n```\n\nLANGUAGE: python\nCODE:\n```\nasync def before_send(message: Message, state: State, scope: Scope) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Cookie Setting Implementation\nDESCRIPTION: Demonstrates the different approaches to setting cookies in FastAPI and Litestar. FastAPI uses response object while Litestar uses decorator arguments.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@app.get(\"/\")\nasync def index(response: Response) -> dict[str, str]:\n    response.set_cookie(key=\"my_cookie\", value=\"cookie_value\")\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@get(response_cookies={\"my-cookie\": \"cookie-value\"})\nasync def handler() -> str:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads in FastAPI\nDESCRIPTION: This code demonstrates how to handle file uploads in FastAPI using the File class. It defines a route that accepts a list of uploaded files and returns their filenames.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@app.post(\"/upload/\")\nasync def upload_file(files: list[UploadFile] = File(...)) -> dict[str, str]:\n    return {\"file_names\": [file.filename for file in files]}\n```\n\n----------------------------------------\n\nTITLE: Lifespan Context Manager Implementation\nDESCRIPTION: Shows how lifespan context managers are implemented differently in FastAPI and Litestar, with inverse parameter order.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@asynccontextmanager\nasync def lifespan(\n    _app: FastAPI,\n    app_settings: AppSettings,\n):\n    # Setup code here\n    yield\n    # Teardown code here\n```\n\nLANGUAGE: python\nCODE:\n```\n@asynccontextmanager\nasync def lifespan(\n    app_settings: AppSettings,\n    _app: Litestar,\n):\n    # Setup code here\n    yield\n    # Teardown code here\n```\n\n----------------------------------------\n\nTITLE: Running Uvicorn ASGI Server with Default Configuration\nDESCRIPTION: Command to start the Uvicorn ASGI server with default settings, assuming the app is defined in 'app.py'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nuvicorn app:app\n```\n\n----------------------------------------\n\nTITLE: Updating NGINX Unit Configuration\nDESCRIPTION: Command to update the running NGINX Unit service with a new configuration file using cURL.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/nginx-unit.rst#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X PUT --data-binary @unit.json --unix-socket /opt/homebrew/var/run/unit/control.sock http://localhost/config\n```\n\n----------------------------------------\n\nTITLE: Litestar Template Implementation\nDESCRIPTION: Demonstrates Litestar's template implementation using the Jinja template engine with explicit template configuration and route handler.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\nfrom litestar.contrib.jinja import JinjaTemplateEngine\nfrom litestar.response import Template\nfrom litestar.template.config import TemplateConfig\n\n@get(\"/hello/{name:str}\")\ndef hello(name: str) -> Template:\n    return Template(response_name=\"hello.html\", context={\"name\": name})\n\napp = Litestar(\n    [hello],\n    template_config=TemplateConfig(directory=\"templates\", engine=JinjaTemplateEngine),\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Litestar with JWT Support\nDESCRIPTION: Command to install Litestar with JWT extra, which includes pyjwt and cryptography packages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install litestar[jwt]\n```\n\n----------------------------------------\n\nTITLE: Sphinx AutoDoc Directive for Static Files Module\nDESCRIPTION: RestructuredText directive to automatically generate documentation for the litestar.static_files module, including all its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/static_files.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.static_files\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Read-Only Field Error in Litestar DTO\nDESCRIPTION: Example showing how a WriteDTO class configured to ignore an id field can lead to validation errors when creating new Person instances. The code illustrates a common pattern where certain fields should be server-generated rather than client-specified.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/07-read-only-fields.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nemphasize-lines: 14\n```\n\n----------------------------------------\n\nTITLE: Running Litestar App with SQLAlchemy Plugin\nDESCRIPTION: This bash command demonstrates how to run the Litestar application that has been configured with the SQLAlchemy Plugin.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ litestar run\n```\n\n----------------------------------------\n\nTITLE: Default Handler Names Example\nDESCRIPTION: Demonstrates the difference in default handler naming between FastAPI and Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@app.get(\"/blabla\")\nasync def blabla() -> str:\n```\n\n----------------------------------------\n\nTITLE: Installing Uvicorn ASGI Server with pip\nDESCRIPTION: Command to install the Uvicorn ASGI server using pip package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install uvicorn\n```\n\n----------------------------------------\n\nTITLE: Adding Todo Item via cURL Command\nDESCRIPTION: This bash command shows how to add a todo item by sending a POST request to the Litestar application's endpoint using cURL.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"Your Todo Title\", \"done\": false}' http://localhost:8000/\n```\n\n----------------------------------------\n\nTITLE: Documenting Litestar params module with Sphinx automodule directive\nDESCRIPTION: A Sphinx documentation directive that automatically generates API documentation for the litestar.params module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/params.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.params\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoDoc for Litestar Streaming Module\nDESCRIPTION: RestructuredText directive that configures automatic documentation generation for the litestar.response.streaming module, including all its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/streaming.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nstreaming\n=========\n\n.. automodule:: litestar.response.streaming\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Automatic Example Runner with Litestar Handler\nDESCRIPTION: Demonstrates how to create a simple Litestar application with an automatic example runner that executes HTTP requests during documentation building.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Dict\n\nfrom litestar import Litestar, get\n\n\n@get(\"/\")\ndef hello_world() -> Dict[str, str]:\n    \"\"\"Handler function that returns a greeting dictionary.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Litestar(route_handlers=[hello_world])\n\n# run: /\n```\n\n----------------------------------------\n\nTITLE: Flask Cookies and Headers\nDESCRIPTION: Shows how to set cookies and headers in Flask using make_response to create and modify the response object.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, make_response\n\napp = Flask(__name__)\n\n@app.get(\"/\")\ndef index():\n    response = make_response(\"hello\")\n    response.set_cookie(\"my-cookie\", \"cookie-value\")\n    response.headers[\"my-header\"] = \"header-value\"\n    return response\n```\n\n----------------------------------------\n\nTITLE: Defining a Person Model and GET Route Handler in Python\nDESCRIPTION: This snippet defines a Person dataclass model with name, age, and email attributes. It also includes a GET route handler that returns a Person object based on the name parameter.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom litestar import Litestar, get\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n    email: str\n\n\n@get(\"/person/{name:str}\")\ndef get_person(name: str) -> Person:\n    return Person(name=name, age=30, email=f\"{name}@example.com\")\n\n\napp = Litestar([get_person])\n```\n\n----------------------------------------\n\nTITLE: Accessing Request Object in Flask and Litestar\nDESCRIPTION: Shows how to access the request object in Flask (using a global variable) and Litestar (as a function parameter). Demonstrates printing the request method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, request\n\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    print(request.method)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, Request\n\n\n@get(\"/\")\ndef index(request: Request) -> None:\n    print(request.method)\n```\n\n----------------------------------------\n\nTITLE: Installing NGINX Unit on macOS\nDESCRIPTION: Commands to install NGINX Unit on macOS using Homebrew package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/nginx-unit.rst#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nbrew tap nginx/unit\nbrew install unit\nbrew install unit-python3\n```\n\n----------------------------------------\n\nTITLE: Creating Supervisor Service Management Aliases\nDESCRIPTION: Shell script that creates convenient aliases for managing a Supervisor service, including start, stop, restart, status, and log watching functionality.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/supervisor.rst#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexampleapp() {\n  case $1 in\n    start)\n      echo \"Starting exampleapp...\"\n      sudo supervisorctl start exampleapp\n      ;;\n\n    stop)\n      echo \"Stopping exampleapp...\"\n      sudo supervisorctl stop exampleapp\n      ;;\n\n    restart)\n      echo \"Restarting exampleapp...\"\n      sudo supervisorctl restart exampleapp\n      ;;\n\n    status)\n      echo \"Checking status of exampleapp...\"\n      sudo supervisorctl status exampleapp\n      ;;\n\n    watch)\n      echo \"Tailing logs for exampleapp...\"\n      sudo supervisorctl tail -f exampleapp\n      ;;\n\n    help)\n      cat << EOF\n      Available options:\n        exampleapp start    - Start the exampleapp service\n        exampleapp stop     - Stop the exampleapp service\n        exampleapp restart  - Restart the exampleapp service\n        exampleapp status   - Check the status of the exampleapp service\n        exampleapp watch    - Tail the logs for the exampleapp service\n      EOF\n      ;;\n\n    *)\n      echo \"Unknown command: $1\"\n      echo \"Use 'exampleapp help' for a list of available commands.\"\n      ;;\n  esac\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying JWT Issuer and Audience in Python\nDESCRIPTION: Example of setting up issuer and audience verification for JWT tokens in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/jwt.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Code content hidden in dropdown\n```\n\n----------------------------------------\n\nTITLE: Installing OpenTelemetry ASGI Instrumentation\nDESCRIPTION: Command to install OpenTelemetry ASGI instrumentation as a separate package using pip.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/open-telemetry.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install opentelemetry-instrumentation-asgi\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodoc for Litestar Redirect Module in reStructuredText\nDESCRIPTION: This snippet sets up Sphinx autodoc to generate documentation for the litestar.response.redirect module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/redirect.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.response.redirect\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Extending Litestar CLI with Entry Points (Poetry)\nDESCRIPTION: Example of how to add custom CLI commands to Litestar using entry points in a Poetry project configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.poetry.plugins.\"litestar.commands\"]\nmy_command = \"my_litestar_plugin.cli:main\"\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code debugger for Litestar CLI in JSON\nDESCRIPTION: This JSON configuration sets up VS Code debugger to run Litestar application using the CLI.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/debugging.rst#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Python: Litestar app\",\n    \"type\": \"python\",\n    \"request\": \"launch\",\n    \"module\": \"litestar\",\n    \"justMyCode\": true,\n    \"args\": [\"run\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Flask Template Implementation\nDESCRIPTION: Shows Flask's template implementation using Jinja2 templating engine with a simple route handler that renders a template.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route(\"/hello/<name>\")\ndef hello(name):\n    return render_template(\"hello.html\", name=name)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Event Handler Implementation in Litestar\nDESCRIPTION: Demonstrates an incorrect implementation of event handlers that would raise exceptions due to mismatched parameters.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@listener(\"user_deleted\")\nasync def send_farewell_email_handler(email: str) -> None:\n    await send_farewell_email(email)\n\n\n@listener(\"user_deleted\")\nasync def notify_customer_support(reason: str) -> None:\n    # do something here to send an email\n    await client.post(\"some-url\", reason)\n\n\n@dataclass\nclass DeleteUserDTO:\n    email: str\n    reason: str\n\n\n@post(\"/users\")\nasync def delete_user_handler(data: UserDTO, request: Request) -> None:\n    await user_repository.delete({\"email\": email})\n    request.app.emit(\"user_deleted\", email=data.email, reason=\"deleted\")\n```\n\n----------------------------------------\n\nTITLE: Running Granian ASGI Server with Default Configuration\nDESCRIPTION: Command to start the Granian ASGI server with default settings, assuming the app is defined in 'app.py'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ngranian --interface asgi app:app\n```\n\n----------------------------------------\n\nTITLE: Generating SQLAlchemy Plugin Documentation in reStructuredText\nDESCRIPTION: This snippet uses the automodule directive to automatically generate documentation for the SQLAlchemy plugin in Litestar. It includes all members of the litestar.plugins.sqlalchemy module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/sqlalchemy.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.plugins.sqlalchemy\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Uvicorn Server Console Output\nDESCRIPTION: Example console output when starting the Uvicorn server, showing the server address and startup information.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```\n\n----------------------------------------\n\nTITLE: Extending Litestar CLI with Entry Points (PDM)\nDESCRIPTION: Example of how to add custom CLI commands to Litestar using entry points in a PDM project configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[project.scripts]\nmy_command = \"my_litestar_plugin.cli:main\"\n\n# Or, as an entrypoint:\n\n[project.entry-points.\"litestar.commands\"]\nmy_command = \"my_litestar_plugin.cli:main\"\n```\n\n----------------------------------------\n\nTITLE: Litestar Cookies and Headers\nDESCRIPTION: Demonstrates two approaches to setting cookies and headers in Litestar: using route handler decorators and returning Response objects.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, Response\nfrom litestar.datastructures import ResponseHeader, Cookie\n\n@get(\n    \"/static\",\n    response_headers={\"my-header\": ResponseHeader(value=\"header-value\")},\n    response_cookies=[Cookie(\"my-cookie\", \"cookie-value\")],\n)\ndef static() -> str:\n    # you can set headers and cookies when defining handlers\n    ...\n\n@get(\"/dynamic\")\ndef dynamic() -> Response[str]:\n    # or dynamically, by returning an instance of Response\n    return Response(\n        \"hello\",\n        headers={\"my-header\": \"header-value\"},\n        cookies=[Cookie(\"my-cookie\", \"cookie-value\")],\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Litestar via pip\nDESCRIPTION: Command to install the Litestar framework using pip package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/PYPI_README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install litestar\n```\n\n----------------------------------------\n\nTITLE: Granian Server Console Output\nDESCRIPTION: Example console output when starting the Granian server, showing the server address and startup information.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n[INFO] Starting granian\n[INFO] Listening at: 127.0.0.1:8000\n```\n\n----------------------------------------\n\nTITLE: Multiple Path Route Handler Registration\nDESCRIPTION: Shows how to register a single handler function for multiple paths using a list of paths.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/routing/overview.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import get, Litestar\n\n@get([\"/\", \"/sub-path\"])\ndef handler() -> None: ...\n\napp = Litestar(route_handlers=[handler])\n```\n\n----------------------------------------\n\nTITLE: Documenting Serialization Module in Python\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.serialization module. It specifically documents the default_serializer, encode_json, decode_json, encode_msgpack, and decode_msgpack functions.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/serialization.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.serialization\n    :members: default_serializer, encode_json, decode_json, encode_msgpack, decode_msgpack\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Configuration for Litestar Pydantic Plugin\nDESCRIPTION: A Sphinx documentation configuration that specifies the automodule directive to generate documentation for the litestar.plugins.pydantic module. The directive includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/pydantic.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.plugins.pydantic\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Running Hypercorn ASGI Server with Default Configuration\nDESCRIPTION: Command to start the Hypercorn ASGI server with default settings, assuming the app is defined in 'app.py'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nhypercorn app:app\n```\n\n----------------------------------------\n\nTITLE: Setting Status Codes in Flask and Litestar\nDESCRIPTION: Demonstrates how to set custom status codes for responses in both frameworks. Flask allows returning a tuple, while Litestar uses decorators or Response objects.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    return \"not found\", 404\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, Response\n\n\n@get(\"/static\", status_code=404)\ndef static_status() -> str:\n    return \"not found\"\n\n\n@get(\"/dynamic\")\ndef dynamic_status() -> Response[str]:\n    return Response(\"not found\", status_code=404)\n\n\napp = Litestar([static_status, dynamic_status])\n```\n\n----------------------------------------\n\nTITLE: Litestar Typing Module Documentation Structure\nDESCRIPTION: RestructuredText directive specifying the current module and configuration for auto-documentation of the litestar.typing module and its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/typing.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. py:currentmodule:: litestar.typing\n\n.. automodule:: litestar.typing\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx AutoDoc Directive for Flash Plugin Module\nDESCRIPTION: Sphinx documentation directive to automatically generate API documentation from the litestar.plugins.flash module, including all members and docstrings.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/flash_messages.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.plugins.flash\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Displaying Litestar CLI Help\nDESCRIPTION: Command to display the most up-to-date reference for the Litestar CLI, showing all available commands and options.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nlitestar --help\n```\n\n----------------------------------------\n\nTITLE: Serialization in Flask and Litestar\nDESCRIPTION: Illustrates how serialization works in both frameworks. Flask uses a mix of explicit conversion and inference, while Litestar assumes JSON serialization by default unless specified otherwise.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/flask.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom flask import Flask, Response\n\n\napp = Flask(__name__)\n\n\n@app.get(\"/json\")\ndef get_json():\n    return {\"hello\": \"world\"}\n\n\n@app.get(\"/text\")\ndef get_text():\n    return \"hello, world!\"\n\n\n@app.get(\"/html\")\ndef get_html():\n    return Response(\"<strong>hello, world</strong>\", mimetype=\"text/html\")\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, MediaType\n\n\n@get(\"/json\")\ndef get_json() -> dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\n@get(\"/text\", media_type=MediaType.TEXT)\ndef get_text() -> str:\n    return \"hello, world\"\n\n\n@get(\"/html\", media_type=MediaType.HTML)\ndef get_html() -> str:\n    return \"<strong>hello, world</strong>\"\n\n\napp = Litestar([get_json, get_text, get_html])\n```\n\n----------------------------------------\n\nTITLE: Correct Event Handler Implementation in Litestar\nDESCRIPTION: Shows the correct way to implement event handlers using **kwargs to handle extra parameters.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@listener(\"user_deleted\")\nasync def send_farewell_email_handler(email: str, **kwargs) -> None:\n    await send_farewell_email(email)\n\n\n@listener(\"user_deleted\")\nasync def notify_customer_support(reason: str, **kwargs) -> None:\n    await client.post(\"some-url\", reason)\n```\n\n----------------------------------------\n\nTITLE: RST Autodoc Module Directive for Litestar attrs Plugin\nDESCRIPTION: ReStructuredText directive that automatically generates documentation for the litestar.plugins.attrs module by extracting docstrings and other documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/attrs.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nattrs\n=====\n\n.. automodule:: litestar.plugins.attrs\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Building Documentation Locally\nDESCRIPTION: Command to build the Litestar documentation locally without serving it.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake docs\n```\n\n----------------------------------------\n\nTITLE: Installing Prometheus Client as Litestar Extra\nDESCRIPTION: Command to install the Prometheus client as part of Litestar extras using pip.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/prometheus.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install litestar[prometheus]\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoModule Documentation for Litestar Session Middleware\nDESCRIPTION: Sphinx documentation directive that enables automatic documentation generation for the litestar.middleware.session.base module. The :members: flag indicates that all module members should be included in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/session/base.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.middleware.session.base\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodoc for OpenAPI Specification Module in reStructuredText\nDESCRIPTION: This snippet sets up the autodoc configuration for the litestar.openapi.spec module. It includes all members of the module and separately documents the SecurityRequirement data.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/openapi/spec.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nspec\n====\n\n\n.. automodule:: litestar.openapi.spec\n    :members:\n\n\n.. autodata:: litestar.openapi.spec.SecurityRequirement\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies with uv\nDESCRIPTION: Command to install all required development dependencies using uv, the recommended package installation tool for the Litestar project.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nuv sync\n```\n\n----------------------------------------\n\nTITLE: Running a Litestar Application\nDESCRIPTION: Commands to run a Litestar application using either the built-in CLI or Uvicorn directly with hot-reload enabled.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nlitestar run\n# Or you can run Uvicorn directly:\nuvicorn app:app --reload\n```\n\n----------------------------------------\n\nTITLE: Legacy StaticFilesConfig Usage in Python\nDESCRIPTION: Shows the deprecated way of configuring static files using StaticFilesConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/static-files.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar\nfrom litestar.static_files.config import StaticFilesConfig\n\napp = Litestar(\n    static_files_config=[StaticFilesConfig(path=\"/static\", directories=[\"assets\"])]\n)\n```\n\n----------------------------------------\n\nTITLE: Running Litestar with PDB flag using CLI\nDESCRIPTION: This command demonstrates how to run a Litestar application with the --pdb flag using the command-line interface.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/debugging.rst#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nlitestar run --pdb\n```\n\n----------------------------------------\n\nTITLE: Event Emitter Method Signature in Litestar\nDESCRIPTION: Shows the signature of the emit method in Litestar's event system.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/events.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef emit(self, event_id: str, *args: Any, **kwargs: Any) -> None: ...\n```\n\n----------------------------------------\n\nTITLE: Sphinx Autodoc Configuration for CSRF Middleware Module\nDESCRIPTION: Configuration for Sphinx's autodoc extension to automatically generate documentation for the csrf middleware module in Litestar. The directive includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/csrf.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.middleware.csrf\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Directives for Rate Limiting Middleware\nDESCRIPTION: RST directives for generating API documentation for Litestar's rate limiting middleware. The file uses automodule to document all members of the rate_limit middleware module and autoclass to specifically document the DurationUnit class.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/rate_limit.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nrate_limit\n==========\n\n.. automodule:: litestar.middleware.rate_limit\n    :members:\n\n.. autoclass:: litestar.middleware.rate_limit.DurationUnit\n```\n\n----------------------------------------\n\nTITLE: Including External Code References in RST Documentation\nDESCRIPTION: Shows how to reference external Python files in RST documentation using literalinclude directive.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: /examples/test_thing.py\n   :language: python\n   :caption: All includes should have a descriptive caption\n```\n\n----------------------------------------\n\nTITLE: Documenting Litestar Enums Module with Sphinx\nDESCRIPTION: Sphinx autodoc directive that automatically generates documentation for all members of the litestar.enums module. This uses reStructuredText format to configure module documentation generation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/enums.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nenums\n=====\n\n.. automodule:: litestar.enums\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Sphinx Documentation for Litestar Dataclass DTO Module\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.dto.dataclass_dto module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/dataclass_dto.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.dto.dataclass_dto\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Litestar Security Module in Python\nDESCRIPTION: This code snippet demonstrates how to import the security module from Litestar. It uses Python's automodule directive to automatically generate documentation for the security module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/security/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. automodule:: litestar.security\n```\n\n----------------------------------------\n\nTITLE: Starting NGINX Unit\nDESCRIPTION: Command to start the NGINX Unit process, replacing <user> with the system user.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/nginx-unit.rst#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nunitd --user <user>\n```\n\n----------------------------------------\n\nTITLE: Customizing Litestar debugger module with ipdb in Python\nDESCRIPTION: This code snippet demonstrates how to configure Litestar to use ipdb as the debugging module instead of the default pdb.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/debugging.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport ipdb\n\n\napp = Litestar(pdb_on_exception=True, debugger_module=ipdb)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Automodule for File Store Documentation\nDESCRIPTION: Sphinx configuration directive to automatically generate documentation for the litestar.stores.file module and all its members using reStructuredText format.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/file.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.stores.file\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx documentation for Litestar datastructures module\nDESCRIPTION: This RST (reStructuredText) snippet configures Sphinx documentation for the Litestar datastructures module. It uses automodule to include all members from the module and sets up a table of contents tree with a maximum depth of 1, referencing a submodule called 'secret_values'.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/datastructures/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\ndatastructures\n==============\n\n.. automodule:: litestar.datastructures\n    :members:\n\n.. toctree::\n    :maxdepth: 1\n\n    secret_values\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Litestar Repository Handlers in reStructuredText\nDESCRIPTION: This snippet uses the automodule directive to automatically generate documentation for all members of the litestar.repository.handlers module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/repository/handlers.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nhandlers\n=========\n\n.. automodule:: litestar.repository.handlers\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for Litestar File Response Module\nDESCRIPTION: Sphinx documentation configuration for auto-generating API documentation for the Litestar file response module using automodule directive.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/file.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.response.file\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Litestar data_extractors Module in reStructuredText\nDESCRIPTION: This code snippet is a reStructuredText directive that automatically generates documentation for the data_extractors module in the Litestar framework. It uses the automodule directive to include all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/data_extractors.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\ndata_extractors\n===============\n\n\n.. automodule:: litestar.data_extractors\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Router Documentation with RST\nDESCRIPTION: ReStructuredText directive to automatically generate documentation for the Router class from the litestar.router module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/router.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.router\n   :members: Router\n```\n\n----------------------------------------\n\nTITLE: Installing Daphne ASGI Server with pip\nDESCRIPTION: Command to install the Daphne ASGI server using pip package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install daphne\n```\n\n----------------------------------------\n\nTITLE: Using Server Lifespan Hook in Litestar CLI Plugin\nDESCRIPTION: Example of implementing a server lifespan hook in a Litestar CLI plugin. This hook allows running code before the server starts and after it stops, useful for one-time initialization tasks.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/cli.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nfrom litestar import Litestar\nfrom litestar.config.app import AppConfig\nfrom litestar.plugins.base import CLIPlugin\n\n\nclass StartupPrintPlugin(CLIPlugin):\n\n    @contextmanager\n    def server_lifespan(self, app: Litestar) -> Generator[None, None, None]:\n        print(\"i_run_before_startup_plugin\")  # noqa: T201\n        try:\n            yield\n        finally:\n            print(\"i_run_after_shutdown_plugin\")  # noqa: T201\n\ndef create_app() -> Litestar:\n    return Litestar(route_handlers=[], plugins=[StartupPrintPlugin()])\n```\n\n----------------------------------------\n\nTITLE: Sphinx Automodule Directive for Mako Templates Module\nDESCRIPTION: A Sphinx documentation directive that automatically generates API documentation for the litestar.contrib.mako module. It includes documentation for all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/mako.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.contrib.mako\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Redirecting Exceptions Documentation in reStructuredText\nDESCRIPTION: This snippet uses reStructuredText directives to mark the page as orphaned and redirect users to the updated location of the exceptions documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/repository/exceptions.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n:orphan:\n\nexceptions\n==========\n\nThis page has moved to :doc:`/reference/repository/exceptions`\n```\n\n----------------------------------------\n\nTITLE: Sphinx Automodule Directive for Litestar Logging Middleware\nDESCRIPTION: A reStructuredText directive that automatically generates documentation for the litestar.middleware.logging module and all its members. This directive instructs Sphinx to extract documentation from docstrings in the specified module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/logging.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.middleware.logging\n    :members:\n```\n\n----------------------------------------\n\nTITLE: RST Module Documentation\nDESCRIPTION: RST documentation directives for Litestar configuration modules that specify auto-documentation generation for various configuration components.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/config.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.config.allowed_hosts\n    :members:\n\n.. automodule:: litestar.config.app\n    :members:\n\n.. automodule:: litestar.config.compression\n    :members:\n\n.. automodule:: litestar.config.cors\n    :members:\n\n.. automodule:: litestar.config.csrf\n    :members:\n\n.. automodule:: litestar.config.response_cache\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating a Table of Contents for Litestar Contrib Extensions in reStructuredText\nDESCRIPTION: Defines a table of contents (toctree) directive for Litestar's contributed extensions and integrations. The toctree is set to a maximum depth of 1 and lists various extension modules that can be integrated with the Litestar framework.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    htmx\n    jinja\n    jwt\n    mako\n    opentelemetry\n    piccolo\n    pydantic\n    sqlalchemy/index\n```\n\n----------------------------------------\n\nTITLE: Sphinx Auto-Documentation Directive for Litestar DTO Types\nDESCRIPTION: ReStructuredText directive to automatically generate documentation from the litestar.dto.types module, including all members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/types.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.dto.types\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Importing Litestar Logging Configuration Module\nDESCRIPTION: This snippet demonstrates how to import and use the Litestar logging configuration module. It uses Python's autodoc feature to automatically generate documentation for all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/logging/config.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: litestar.logging.config\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Litestar Handlers Module with Sphinx\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to generate documentation for the litestar.handlers module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/handlers.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.handlers\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Updating Data with SQLAlchemy Repository in Python\nDESCRIPTION: This code shows how to update existing data in the database using the repository's update method.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/02-repository-introduction.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync with repository_factory() as context:\n    author_repo = context.get_repository(AuthorRepository)\n    author.nationality = \"Portuguese\"\n    updated_author = await author_repo.update(author)\n    print(f\"Updated author: {updated_author}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Release Notes Table of Contents in RST\nDESCRIPTION: Configures a table of contents structure for release notes documentation using restructuredText directives. Includes an orphan directive and links to version-specific changelog pages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n:orphan:\n\nRelease notes\n=============\n\n.. toctree::\n    :titlesonly:\n\n    whats-new-2\n    2.x Changelog <https://litestar.dev/2/release-notes/changelog.html>\n    1.x Changelog <https://litestar.dev/1/changelog.html>\n```\n\n----------------------------------------\n\nTITLE: Migrating from MiddlewareProtocol to ASGIMiddleware in Python\nDESCRIPTION: Illustrates the migration path from using MiddlewareProtocol to ASGIMiddleware for implementing middlewares. This example is referenced but the specific code is not provided in the text.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/creating-middleware.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# This code snippet is referenced but not directly provided in the text\n```\n\n----------------------------------------\n\nTITLE: ReST Directive for Auto-documenting Litestar DTO Field Module\nDESCRIPTION: A reStructuredText directive that instructs Sphinx to automatically generate documentation for all members in the litestar.dto.field module. This is used to create API reference documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/field.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.dto.field\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting Litestar Routes Module in Python\nDESCRIPTION: This snippet uses Sphinx's autodoc extension to automatically generate documentation for the litestar.routes module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/routes.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. automodule:: litestar.routes\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for SQLAlchemy Documentation in reStructuredText\nDESCRIPTION: This snippet defines a table of contents for SQLAlchemy-related documentation in Litestar using reStructuredText syntax. It includes links to sections on models and repositories, and a separate index for plugins.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n\n    models_and_repository\n    plugins/index\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation for Redis Store Module\nDESCRIPTION: RST directive to auto-generate module documentation for the Litestar Redis store implementation using Sphinx's automodule feature.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/redis.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.stores.redis\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Redirect for Handlers Documentation\nDESCRIPTION: RestructuredText directive that marks page as orphaned and sets up a redirect to the new handlers documentation location.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/repository/handlers.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n:orphan:\n\nhandlers\n=========\n\nThis page has moved to :doc:`/reference/repository/handlers`\n```\n\n----------------------------------------\n\nTITLE: Generating SQLAlchemy Plugin Documentation with reStructuredText\nDESCRIPTION: A reStructuredText directive that automatically generates documentation for all members in the 'litestar.contrib.sqlalchemy.plugins' module of the Litestar framework.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/sqlalchemy/plugins.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.contrib.sqlalchemy.plugins\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating a Table of Contents in reStructuredText\nDESCRIPTION: This snippet shows how to create a table of contents in reStructuredText for the SQLAlchemy plugin documentation. It includes links to separate pages for each plugin type.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    sqlalchemy_plugin\n    sqlalchemy_init_plugin\n    sqlalchemy_serialization_plugin\n```\n\n----------------------------------------\n\nTITLE: Docker Commands for Building and Managing Litestar Application Container\nDESCRIPTION: These shell commands demonstrate how to build, run, stop, start, and remove a Docker container for the Litestar application.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# Build the container\ndocker build -t exampleapp .\n\n# Run the container\ndocker run -d -p 80:80 --name exampleapp exampleapp\n\n# Stop the container\ndocker stop exampleapp\n\n# Start the container\ndocker start exampleapp\n\n# Remove the container\ndocker rm exampleapp\n```\n\n----------------------------------------\n\nTITLE: Generating Litestar Response Base Module Documentation in reStructuredText\nDESCRIPTION: This snippet uses the automodule directive to automatically generate documentation for the litestar.response.base module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/base.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.response.base\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Handlers with DTOs in Litestar\nDESCRIPTION: This snippet demonstrates how to declare multiple handlers with individual DTO declarations in a Litestar application. It shows the basic structure of defining separate handler functions for different HTTP methods, each with its own DTO configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/10-layered-dto-declarations.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get, post, put, patch, delete\nfrom litestar.dto import DTOConfig\nfrom litestar.dto.factory import dto_factory\nfrom litestar.enums import RequestEncodingType\nfrom litestar.params import Parameter\n\nfrom schemas import Person, PersonCreate, PersonUpdate, PersonPatch\n\n\n@get(\"/people\")\ndef list_people() -> list[Person]:\n    ...\n\n\n@post(\"/people\", dto=DTOConfig(PersonCreate))\ndef create_person(data: PersonCreate) -> Person:\n    ...\n\n\n@get(\"/people/{person_id:int}\", return_dto=DTOConfig(Person))\ndef get_person(person_id: int) -> Person:\n    ...\n\n\n@put(\"/people/{person_id:int}\", dto=DTOConfig(PersonUpdate))\ndef update_person(person_id: int, data: PersonUpdate) -> Person:\n    ...\n\n\n@patch(\n    \"/people/{person_id:int}\",\n    dto=dto_factory(PersonPatch, json_schema_extra={\"examples\": [{\"name\": \"string\"}]}),\n)\ndef patch_person(person_id: int, data: PersonPatch) -> Person:\n    ...\n\n\n@delete(\"/people/{person_id:int}\")\ndef delete_person(person_id: int) -> None:\n    ...\n\n\napp = Litestar([list_people, create_person, get_person, update_person, patch_person, delete_person])\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Model Exclusion in Litestar DTOs\nDESCRIPTION: Example showing how to exclude nested model fields using dotted path notation in Litestar DTOs. Demonstrates the relationship between Person and Address models, where the street field from the nested Address model is excluded using 'address.street' path.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/dto-tutorial/02-nested-exclude.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom litestar import get\nfrom litestar.dto import DTOFactory\n\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n    country: str\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n    address: Optional[Address] = None\n\n\nfactory = DTOFactory()\n\nReadDTO = factory.create(\n    Person,\n    exclude={\"address.street\"},\n)\n\n\n@get(\"/person\")\nasync def handler() -> Person:\n    address = Address(street=\"123 Main St\", city=\"New York\", country=\"USA\")\n    person = Person(name=\"John Doe\", age=30, address=address)\n    return person\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Directive for HTMX Plugin Module\nDESCRIPTION: An RST directive that automatically generates documentation for the HTMX plugin module in Litestar. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/htmx.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.plugins.htmx\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Installing SQLAlchemy Dependencies with pip\nDESCRIPTION: Commands for installing SQLAlchemy with aiosqlite support, either directly or through Litestar's extras.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/sqlalchemy/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'sqlalchemy[aiosqlite]'\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install 'litestar[standard,sqlalchemy]' aiosqlite\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Block for StoreRegistry Module\nDESCRIPTION: ReStructuredText documentation directive that auto-generates API documentation for the StoreRegistry class from the litestar.stores.registry module\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/registry.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.stores.registry\n    :members: StoreRegistry\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Litestar Middleware Documentation in reStructuredText\nDESCRIPTION: This reStructuredText code defines a table of contents for middleware documentation in the Litestar framework. It includes links to various middleware components such as allowed hosts, authentication, compression, CORS, CSRF, logging, rate limiting, and session management.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    allowed_hosts\n    authentication\n    compression\n    cors\n    csrf\n    logging\n    rate_limit\n    session/index\n```\n\n----------------------------------------\n\nTITLE: Installing Litestar with OpenTelemetry Support\nDESCRIPTION: Command to install Litestar with OpenTelemetry support using the package extra.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/open-telemetry.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install litestar[opentelemetry]\n```\n\n----------------------------------------\n\nTITLE: Sphinx automodule directive for Litestar compression middleware\nDESCRIPTION: This is a Sphinx documentation directive that automatically generates documentation for the compression middleware module in Litestar. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/compression.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.middleware.compression\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating a Litestar Hello World Application\nDESCRIPTION: Python code for a simple Litestar 'Hello World' application to be run with NGINX Unit.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/nginx-unit.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom litestar import Litestar, get\n\n@get(\"/\")\nasync def hello_world() -> str:\n    return \"Hello, World!\"\n\napp = Litestar([hello_world])\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Allowed Hosts Middleware in Python\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.middleware.allowed_hosts module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/allowed_hosts.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.middleware.allowed_hosts\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for Litestar DI Module\nDESCRIPTION: This reStructuredText directive auto-generates documentation for the 'litestar.di' module, including all its members. It's typically used in Sphinx documentation to create API references.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/di.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.di\n    :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure\nDESCRIPTION: ReStructuredText documentation layout defining the structure of a Litestar TODO application tutorial with table of contents and admonitions\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/todo-app/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. admonition:: Who is this tutorial for?\n    :class: info\n\n    This tutorial is intended to familiarize you with the basic concepts of Litestar.\n    If you have no prior experience with Litestar or web frameworks in general, this\n    is the right place to start.\n\n.. note::\n    Basic knowledge of Python and web development concepts are required.\n\n.. toctree::\n    :titlesonly:\n    :hidden:\n\n    0-application-basics\n    1-accessing-the-list\n    2-interacting-with-the-list\n    3-assembling-the-app\n```\n\n----------------------------------------\n\nTITLE: Generating Python Module Documentation with Sphinx\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.middleware.session.server_side module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/session/server_side.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.middleware.session.server_side\n\n    :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Litestar Response Module\nDESCRIPTION: ReStructuredText documentation configuration that auto-documents the litestar.response module and organizes related response documentation pages in a tree structure.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.response\n    :members:\n\n.. toctree::\n    :maxdepth: 1\n    :hidden:\n\n    base\n    file\n    redirect\n    streaming\n    sse\n    template\n```\n\n----------------------------------------\n\nTITLE: Defining User and Token Models in Python\nDESCRIPTION: This code snippet defines User and Token models as dataclasses for use in the authentication process.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/security/abstract-authentication-middleware.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n\n@dataclass\nclass User:\n    id: int\n    email: str\n\n\n@dataclass\nclass Token:\n    access_token: str\n    token_type: str\n```\n\n----------------------------------------\n\nTITLE: Documenting Session Authentication Classes with Sphinx RST\nDESCRIPTION: Sphinx documentation directives for auto-generating API documentation of Litestar's session authentication classes, including SessionAuth and SessionAuthMiddleware classes with their respective members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/security/session_auth.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: litestar.security.session_auth.SessionAuth\n    :members:\n\n.. autoclass:: litestar.security.session_auth.middleware.SessionAuthMiddleware\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Module Documentation in reStructuredText\nDESCRIPTION: Sets up automatic documentation generation for the litestar.pagination module using Sphinx automodule directive. This will include all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/pagination.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\npagination\n==========\n\n.. automodule:: litestar.pagination\n   :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Configuration for Piccolo ORM\nDESCRIPTION: ReStructuredText directive for generating automated documentation of the Piccolo ORM integration module. Uses automodule to document all members of the litestar.contrib.piccolo package.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/piccolo.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.contrib.piccolo\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Module Documentation with Sphinx Autodoc in RST\nDESCRIPTION: A ReStructuredText directive that uses Sphinx's autodoc extension to automatically generate documentation from the litestar.template module's docstrings and includes all members\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/template.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.template\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring CSRF Cookie and Header Names\nDESCRIPTION: This snippet shows how to customize the CSRF cookie name and header name in the CSRFConfig.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/middleware/builtin-middleware.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncsrf_config = CSRFConfig(secret=\"my-secret\", cookie_name='some-cookie-name', header_name='some-header-name')\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx AutoDoc for SQLAlchemy Base Module\nDESCRIPTION: RestructuredText directive for automatically generating API documentation from the Litestar SQLAlchemy base module. Uses Sphinx automodule directive to include all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/sqlalchemy/base.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nbase\n====\n\n.. automodule:: litestar.contrib.sqlalchemy.base\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Automodule Directive for CORS Documentation\nDESCRIPTION: Sphinx directive that automatically generates documentation for the Litestar CORS middleware module. This directive includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/cors.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.middleware.cors\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Defining RST Table of Contents for DTO Documentation\nDESCRIPTION: Sphinx RST directive that creates a table of contents tree for DTO-related documentation pages. The maxdepth parameter is set to 1 to limit the depth of the tree structure.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    config\n    data_structures\n    field\n    types\n    base_dto\n    msgspec_dto\n    dataclass_dto\n```\n\n----------------------------------------\n\nTITLE: Configuring RestructuredText Table of Contents\nDESCRIPTION: Defines a RestructuredText table of contents directive that lists documentation sections for the repository module. Uses the titlesonly option to show only top-level headings.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/repository/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :titlesonly:\n\n    abc\n    filters\n    exceptions\n    testing\n    handlers\n```\n\n----------------------------------------\n\nTITLE: Sphinx automodule directive for Litestar background tasks documentation\nDESCRIPTION: A reStructuredText directive that instructs Sphinx to automatically generate documentation for all members of the litestar.background_tasks module. This is part of the API documentation generation process.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/background_tasks.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredText\nCODE:\n```\n.. automodule:: litestar.background_tasks\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Defining BlogPost Model with Slug Field in Python\nDESCRIPTION: This snippet defines a BlogPost model using SQLAlchemy ORM. It includes a SlugKey mixin to add a slug field, and specifies UUID as the primary key. The model has title and content fields.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/repository-tutorial/04-repository-other.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass BlogPost(SlugKey, Base):\n    __tablename__ = \"blog_posts\"\n\n    id: Mapped[UUID] = mapped_column(primary_key=True, default=uuid4)\n    title: Mapped[str] = mapped_column(String(length=100))\n    content: Mapped[str] = mapped_column(Text)\n\n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(\n        default=datetime.utcnow, onupdate=datetime.utcnow\n    )\n\nclass BlogPostCreate(SQLAlchemyModel):\n    title: str\n    content: str\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for psycopg Backend in Litestar Channels\nDESCRIPTION: This reStructuredText snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the litestar.channels.backends.psycopg module. This includes classes, functions, and other objects defined in the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/psycopg.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.channels.backends.psycopg\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for Memory Channel Backend\nDESCRIPTION: RST directive to configure automatic documentation generation for the memory channel backend module in Litestar framework, including all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/memory.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nmemory\n======\n\n.. automodule:: litestar.channels.backends.memory\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Litestar Application Documentation with Sphinx\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.app module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/app.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.app\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation for Litestar CLI\nDESCRIPTION: RST directives for auto-generating documentation of the Litestar CLI module and the litestar command group.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/cli.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\ncli\n===\n\n.. automodule:: litestar.cli\n    :members:\n\n.. click:: litestar.cli:litestar_group\n   :prog: litestar\n   :nested: full\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for Litestar Authentication Middleware (RST)\nDESCRIPTION: A reStructuredText directive that configures Sphinx to automatically generate documentation for all members in the litestar.middleware.authentication module. This creates complete API documentation including classes, functions, and other members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/authentication.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.middleware.authentication\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code debugger for Uvicorn in JSON\nDESCRIPTION: This JSON configuration sets up VS Code debugger to run a Litestar application using Uvicorn.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/debugging.rst#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Python: Litestar app\",\n    \"type\": \"python\",\n    \"request\": \"launch\",\n    \"module\": \"uvicorn\",\n    \"justMyCode\": true,\n    \"args\": [\"app:app\"]\n}\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents Structure\nDESCRIPTION: Sphinx documentation table of contents tree structure defining the navigation hierarchy for Litestar's documentation\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :titlesonly:\n\n    applications\n    routing/index\n    requests\n    caching\n    channels\n    cli\n    databases/index\n    debugging\n    dependency-injection\n    dto/index\n    events\n    exceptions\n    htmx\n    lifecycle-hooks\n    logging\n    metrics/index\n    middleware/index\n    openapi/index\n    plugins/index\n    responses\n    security/index\n    static-files\n    custom-types\n    stores\n    templating\n    testing\n    websockets\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Module Documentation with reStructuredText\nDESCRIPTION: Sphinx documentation configuration directive that specifies auto-documentation settings for the litestar.response.template module. The :members: flag indicates that all module members should be included in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/template.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.response.template\n    :members:\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Block for Valkey Store Module\nDESCRIPTION: A reStructuredText documentation directive that generates API documentation for the litestar.stores.valkey module, including all of its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/valkey.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nvalkey\n======\n\n.. automodule:: litestar.stores.valkey\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Hypercorn Server Console Output\nDESCRIPTION: Example console output when starting the Hypercorn server, showing the server address and startup information.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n[2023-11-12 23:31:26 -0800] [16748] [INFO] Running on http://127.0.0.1:8000 (CTRL + C to quit)\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Table of Contents Definition\nDESCRIPTION: Defines the table of contents structure for the Litestar deployment documentation using ReStructuredText format. Lists the main deployment-related sections including nginx-unit, manual ASGI server deployment, Docker, and supervisor configurations.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n\n    nginx-unit\n    manually-with-asgi-server\n    docker\n    supervisor\n```\n\n----------------------------------------\n\nTITLE: OpenTelemetry Documentation Directives in ReStructuredText\nDESCRIPTION: ReStructuredText directives for auto-generating API documentation for the OpenTelemetry module and its hook handler class in Litestar.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/opentelemetry.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nopentelemetry\n=============\n\n.. automodule:: litestar.contrib.opentelemetry\n    :members:\n\n.. autoclass:: litestar.contrib.opentelemetry.config.OpenTelemetryHookHandler\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodocumentation for JWT Security Module in reStructuredText\nDESCRIPTION: This snippet configures the Sphinx autodocumentation for the JWT security module in Litestar. It specifies the module path and instructs Sphinx to document all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/security/jwt.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\njwt\n===\n\n.. automodule:: litestar.security.jwt\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Installing Hypercorn ASGI Server with pip\nDESCRIPTION: Command to install the Hypercorn ASGI server using pip package manager.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/manually-with-asgi-server.rst#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install hypercorn\n```\n\n----------------------------------------\n\nTITLE: Creating a Table of Contents in RST for Channels Documentation\nDESCRIPTION: This code snippet creates a table of contents in reStructuredText format for the channels documentation, linking to various related sections including plugin, subscriber, and backends.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nchannels\n========\n\n.. toctree::\n\n    plugin\n    subscriber\n    backends/index\n```\n\n----------------------------------------\n\nTITLE: Including External Documentation with Sphinx Directives in reStructuredText\nDESCRIPTION: This snippet demonstrates how to mark a document as an orphan and include external content in Sphinx documentation. It uses the ':orphan:' directive to prevent warnings about documents not included in any toctree, and the 'include' directive to embed the CONTRIBUTING.rst file from the parent directory.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/contribution-guide.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n:orphan:\n\n.. include:: ../CONTRIBUTING.rst\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Plugin Documentation with Sphinx in reStructuredText\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.openapi.plugins module. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/openapi/plugins.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.openapi.plugins\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Initializing SQLAlchemy Database in Python\nDESCRIPTION: This function initializes the database when the app starts up. It demonstrates how to drop and create tables for both async and sync implementations. Note that dropping tables should not be done in production.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def init_db(db: AsyncEngine) -> None:\n    async with db.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n```\n\n----------------------------------------\n\nTITLE: Generating Sphinx Documentation for Litestar Connection Module\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.connection module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/connection.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.connection\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in ReStructuredText for Litestar Tutorials\nDESCRIPTION: This snippet defines a table of contents for Litestar tutorials using ReStructuredText directives. It hides the table of contents and lists the available tutorials.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/tutorials/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :hidden:\n\n    todo-app/index\n    sqlalchemy/index\n    dto-tutorial/index\n    repository-tutorial/index\n```\n\n----------------------------------------\n\nTITLE: Release Management Shell Commands - Push Release Branch\nDESCRIPTION: Command to push the release branch to the remote repository.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin vX.Y.Z\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodoc for Litestar OpenAPI Module\nDESCRIPTION: A reStructuredText directive that configures Sphinx to automatically document the litestar.openapi module and all its members. This is used to generate comprehensive API documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/openapi/openapi.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.openapi\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Commands for Managing Litestar Application Deployment\nDESCRIPTION: These shell commands show how to build, run, and manage Docker Compose services for the Litestar application deployment.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/deployment/docker.rst#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# Build the containers\ndocker compose build\n\n# Run the containers\ndocker compose up\n\n# Run the containers in the background\ndocker compose up -d\n\n# Stop the containers\ndocker compose down\n```\n\n----------------------------------------\n\nTITLE: Configuring Autodoc for Litestar Controller Module in RST\nDESCRIPTION: RST directive that configures autodoc to generate documentation for the Litestar controller module. The directive includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/controller.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.controller\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for OpenAPI Documentation with reStructuredText\nDESCRIPTION: A reStructuredText directive that creates a table of contents for OpenAPI documentation, with links to pages about general OpenAPI usage, plugins, and specifications. The toctree is set to a maximum depth of 1.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/openapi/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    openapi\n    plugins\n    spec\n```\n\n----------------------------------------\n\nTITLE: Generating Structlog Plugin Documentation in RST\nDESCRIPTION: This RST code snippet uses Sphinx's automodule directive to automatically generate documentation for the litestar.plugins.structlog module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/structlog.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=========\nstructlog\n=========\n\n.. automodule:: litestar.plugins.structlog\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents Structure in ReStructuredText\nDESCRIPTION: Defines a toctree directive in ReStructuredText that creates a table of contents with a maximum depth of 1, listing three submodules: base, client_side, and server_side.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/session/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    base\n    client_side\n    server_side\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation for Prometheus Plugin in RST\nDESCRIPTION: Sphinx documentation configuration for the Prometheus plugin module in Litestar. This RST (reStructuredText) snippet sets up automatic documentation generation for the litestar.plugins.prometheus module and all its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/plugins/prometheus.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nprometheus\n==========\n\n.. automodule:: litestar.plugins.prometheus\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating RST Documentation for Litestar Channel Backends Base Module\nDESCRIPTION: RST directive to automatically generate documentation from Python docstrings in the litestar.channels.backends.base module. This includes documentation for all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/base.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.channels.backends.base\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Configuring RestructuredText Documentation for Testing Module\nDESCRIPTION: Sets up automatic documentation generation for the testing module within Litestar's repository package, specifically targeting the generic_mock_repository member.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/repository/testing.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.repository.testing\n    :members: generic_mock_repository\n```\n\n----------------------------------------\n\nTITLE: Documenting Client-Side Session Module in RST\nDESCRIPTION: ReStructuredText directive to automatically document the client-side session middleware module, including all its members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/middleware/session/client_side.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nclient_side\n===========\n\n.. automodule:: litestar.middleware.session.client_side\n\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Redis Backend Module using Sphinx\nDESCRIPTION: This reStructuredText (reST) snippet defines documentation for the Redis backend in Litestar's channels module. It uses Sphinx's automodule directive to automatically generate API documentation for all members in the specified module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/redis.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\nredis\n=====\n\n.. automodule:: litestar.channels.backends.redis\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Implementing DTO with Dataclass in Python\nDESCRIPTION: Example showing how to define a Data Transfer Object using dataclass and DataclassDTO with field exclusion configuration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/release-notes/whats-new-2.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom litestar import get\nfrom litestar.dto import DTOConfig, DataclassDTO\n\n\n@dataclass\nclass MyType:\n    some_field: str\n    another_field: int\n\n\nclass MyDTO(DataclassDTO[MyType]):\n    config = DTOConfig(exclude={\"another_field\"})\n\n\n@get(dto=MyDTO)\nasync def handler() -> MyType:\n    return MyType(some_field=\"some value\", another_field=42)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Stores in reStructuredText\nDESCRIPTION: This snippet defines a table of contents (toctree) for various store implementations in the Litestar project. It lists different types of stores including base, file, memory, redis, registry, and valkey.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nstores\n======\n\n.. toctree::\n\n    base\n    file\n    memory\n    redis\n    registry\n    valkey\n```\n\n----------------------------------------\n\nTITLE: RST AutoModule Documentation Configuration\nDESCRIPTION: Sphinx documentation directive to automatically generate documentation for the secret_values module in the Litestar package with all members included.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/datastructures/secret_values.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: litestar.datastructures.secret_values\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Release Management Shell Commands - Main Branch Checkout\nDESCRIPTION: Command to checkout the main branch when preparing a new release.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout main\n```\n\n----------------------------------------\n\nTITLE: Documenting Litestar Exceptions Modules with Sphinx\nDESCRIPTION: RST markup for Sphinx documentation that auto-generates API documentation for Litestar's exception modules. It includes directives for both the main exceptions module and the exceptions.responses submodule with their members.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/exceptions.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nexceptions\n==========\n\n.. automodule:: litestar.exceptions\n    :members:\n\n.. automodule:: litestar.exceptions.responses\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Litestar Concurrency Module with reStructuredText\nDESCRIPTION: This reStructuredText directive uses automodule to generate API documentation for the Litestar concurrency module. The ':members:' option ensures all module members are documented.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/concurrency.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nconcurrency\n===========\n\n.. automodule:: litestar.concurrency\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for Litestar's Picologging Module using Sphinx\nDESCRIPTION: This snippet uses Sphinx autodoc directives to automatically generate documentation for the picologging module in Litestar. It includes all members of the module in the generated documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/logging/picologging.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\npicologging\n============\n\n.. automodule:: litestar.logging.picologging\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Release Management Shell Commands - Create Release Branch\nDESCRIPTION: Command to create a new branch for the release.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout -b vX.Y.Z\n```\n\n----------------------------------------\n\nTITLE: Generating AsyncPG Backend Module Documentation with Sphinx\nDESCRIPTION: This snippet uses Sphinx's automodule directive to automatically generate documentation for the asyncpg backend module in Litestar's channels package. It includes all members of the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/asyncpg.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: litestar.channels.backends.asyncpg\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Litestar Memory Store Module in reStructuredText\nDESCRIPTION: This RST code snippet uses the automodule directive to automatically generate documentation for the litestar.stores.memory module. It includes all members of the module in the documentation.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/stores/memory.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nmemory\n======\n\n.. automodule:: litestar.stores.memory\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Basic Piccolo ORM Integration with Litestar\nDESCRIPTION: Example demonstrating the integration of Piccolo ORM with Litestar using PiccoloDTO for data flow control. Shows the base application setup with Piccolo ORM integration.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/piccolo.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# /examples/contrib/piccolo/app.py\n```\n\n----------------------------------------\n\nTITLE: Configuring automodule documentation for msgspec_dto in Litestar\nDESCRIPTION: A reStructuredText directive that generates documentation for the litestar.dto.msgspec_dto module. It includes the :members: option to document all module members automatically.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/dto/msgspec_dto.rst#2025-04-22_snippet_0\n\nLANGUAGE: reST\nCODE:\n```\n.. automodule:: litestar.dto.msgspec_dto\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Release Management Shell Commands - Release Preparation\nDESCRIPTION: Command to run the release preparation script that updates version numbers and creates draft releases.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npython tools/prepare_release.py <new version number> --update-version --create-draft-release\n```\n\n----------------------------------------\n\nTITLE: Documenting ChannelsPlugin class in Litestar\nDESCRIPTION: This snippet uses the autoclass directive to generate documentation for the ChannelsPlugin class from the litestar.channels.plugin module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/plugin.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: litestar.channels.plugin.ChannelsPlugin\n```\n\n----------------------------------------\n\nTITLE: Redirecting to Testing Documentation in reStructuredText\nDESCRIPTION: A reStructuredText directive that creates a reference link to the new location of the testing documentation within the repository.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/contrib/repository/testing.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n:doc:`/reference/repository/testing`\n```\n\n----------------------------------------\n\nTITLE: Generating SSE Module Documentation with Sphinx\nDESCRIPTION: This code snippet uses Sphinx's automodule directive to automatically generate documentation for all members of the litestar.response.sse module. It includes all public classes, functions, and attributes in the module.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/response/sse.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: litestar.response.sse\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Release Management Shell Commands - Commit Changes\nDESCRIPTION: Command to commit version changes to the main branch.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ngit commit -am \"chore(release): prepare release vX.Y.Z\"\n```\n\n----------------------------------------\n\nTITLE: Serving Documentation Locally\nDESCRIPTION: Command to serve the Litestar documentation locally for development and preview purposes.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/CONTRIBUTING.rst#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmake docs-serve\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Table of Contents\nDESCRIPTION: ReStructuredText table of contents directive listing backend integration documentation pages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/reference/channels/backends/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\nbackends\n========\n\n.. toctree::\n\n    base\n    memory\n    redis\n    psycopg\n    asyncpg\n```\n\n----------------------------------------\n\nTITLE: Defining RestructuredText Table of Contents for Database Documentation\nDESCRIPTION: RestructuredText directive defining a table of contents for database integration documentation, linking to SQLAlchemy and Piccolo database sections\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :titlesonly:\n\n    sqlalchemy/index\n    piccolo\n```\n\n----------------------------------------\n\nTITLE: Defining ReStructuredText Table of Contents\nDESCRIPTION: Defines a table of contents tree structure for metrics documentation using RST syntax, linking to open-telemetry and prometheus documentation pages.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/metrics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :titlesonly:\n\n    open-telemetry\n    prometheus\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Topics in reStructuredText\nDESCRIPTION: This snippet defines a table of contents (toctree) for the Topics section in the Litestar documentation. It specifies the title-only display and includes links to articles on synchronous vs asynchronous operations and deployment strategies.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/topics/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n    :titlesonly:\n    :caption: Articles\n\n    sync-vs-async\n    deployment/index\n```\n\n----------------------------------------\n\nTITLE: Referencing SQLAlchemy Plugins in reStructuredText\nDESCRIPTION: This snippet demonstrates how to reference Litestar's SQLAlchemy plugins using reStructuredText syntax. It includes class references for the full SQLAlchemy support plugin, application tooling plugin, and serialization support plugin.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/usage/databases/sqlalchemy/plugins/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n- :class:`litestar.contrib.sqlalchemy.plugins.SQLAlchemyPlugin`: Full SQLAlchemy support\n- :class:`litestar.contrib.sqlalchemy.plugins.SQLAlchemyInitPlugin`: Application tooling\n- :class:`litestar.contrib.sqlalchemy.plugins.SQLAlchemySerializationPlugin`: Serialization support\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication in FastAPI\nDESCRIPTION: This code shows how to implement authentication in FastAPI using dependency injection. It defines an authenticate function and uses it as a dependency for a route.\nSOURCE: https://github.com/litestar-org/litestar/blob/main/docs/migration/fastapi.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom fastapi import FastAPI, Depends, Request\n\n\nasync def authenticate(request: Request) -> None: ...\n\n\napp = FastAPI()\n\n\n@app.get(\"/\", dependencies=[Depends(authenticate)])\nasync def index() -> dict[str, str]: ...\n```"
  }
]