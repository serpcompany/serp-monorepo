[
  {
    "owner": "cloudflare",
    "repo": "agents",
    "content": "TITLE: Creating an AI Chat Agent using `AIChatAgent` and OpenAI in TypeScript\nDESCRIPTION: Example of a `DialogueAgent` extending `AIChatAgent` from `agents/ai-chat-agent` to facilitate conversational AI. It overrides `onChatMessage`, using utilities like `createDataStreamResponse` and `streamText` from `@ai-sdk/openai` to stream responses from an OpenAI model (gpt-4o) based on the current message history (`this.messages`). The `onFinish` callback, passed to `streamText`, ensures messages are saved by the base `AIChatAgent` after the stream completes.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AIChatAgent } from \"agents/ai-chat-agent\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { createDataStreamResponse, streamText } from \"@ai-sdk/core\"; // Assumed import for createDataStreamResponse\n\nexport class DialogueAgent extends AIChatAgent {\n  async onChatMessage(onFinish) {\n    return createDataStreamResponse({\n      execute: async (dataStream) => {\n        const stream = streamText({\n          model: openai(\"gpt-4o\"),\n          messages: this.messages,\n          onFinish, // call onFinish so that messages get saved\n        });\n\n        stream.mergeIntoDataStream(dataStream);\n      },\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Connections in an Agent using TypeScript\nDESCRIPTION: Shows a `DialogueAgent` extending `Agent` designed to handle persistent WebSocket connections. It implements the `onConnect` method, likely for initializing the connection state, and the `onMessage` method to process incoming messages, perform comprehension, and send responses back through the connection.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport class DialogueAgent extends Agent {\n  async onConnect(connection) {\n    await this.initiate(connection);\n  }\n\n  async onMessage(connection, message) {\n    const understanding = await this.comprehend(message);\n    await this.respond(connection, understanding);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Requests within an Agent in TypeScript\nDESCRIPTION: Defines an `APIAgent` class that extends `Agent` from the `agents` package. It overrides the `onRequest` method to specifically handle incoming HTTP requests. The method parses the request body as JSON, processes the data using a hypothetical `this.process` method, and returns a JSON response containing the result and a timestamp.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport class APIAgent extends Agent {\n  async onRequest(request) {\n    const data = await request.json();\n\n    return Response.json({\n      insight: await this.process(data),\n      moment: Date.now(),\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a React Chat Interface with `useAgentChat`\nDESCRIPTION: Demonstrates creating a React chat UI using hooks from the `agents` framework. It first connects to the agent using `useAgent`. Then, `useAgentChat` (from `agents/ai-react`) manages the chat state, providing `messages`, `input` value, `handleInputChange`, `handleSubmit` for sending messages, and `clearHistory`. The component renders the message history and an input form, enabling real-time, interactive chat with the connected AI agent.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAgent } from \"agents/react\";\nimport { useAgentChat } from \"agents/ai-react\";\n\nfunction ChatInterface() {\n  // Connect to the agent\n  const agent = useAgent({\n    agent: \"dialogue-agent\",\n  });\n\n  // Set up the chat interaction\n  const { messages, input, handleInputChange, handleSubmit, clearHistory } =\n    useAgentChat({\n      agent,\n      maxSteps: 5,\n    });\n\n  return (\n    <div className=\"chat-interface\">\n      {/* Message History */}\n      <div className=\"message-flow\">\n        {messages.map((message) => (\n          <div key={message.id} className=\"message\">\n            <div className=\"role\">{message.role}</div>\n            <div className=\"content\">{message.content}</div>\n          </div>\n        ))}\n      </div>\n\n      {/* Input Area */}\n      <form onSubmit={handleSubmit} className=\"input-area\">\n        <input\n          value={input}\n          onChange={handleInputChange}\n          placeholder=\"Type your message...\"\n          className=\"message-input\"\n        />\n      </form>\n\n      <button onClick={clearHistory} className=\"clear-button\">\n        Clear Chat\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HumanInTheLoop Agent Class in TypeScript\nDESCRIPTION: Defines an AI chat agent class that processes messages and checks for tool calls requiring human confirmation before execution. It implements the onChatMessage method to handle message processing and response streaming.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class HumanInTheLoop extends AIChatAgent<Env> {\n  async onChatMessage(onFinish: StreamTextOnFinishCallback<any>) {\n    return createDataStreamResponse({\n      execute: async (dataStream) => {\n        // Process messages and check for tool calls requiring confirmation\n        const processedMessages = await processToolCalls({\n          messages: this.messages,\n          dataStream,\n          tools: {\n            getWeatherInformation: {\n              requiresApproval: true,\n              execute: async ({ city }) => {\n                // Example tool implementation\n                return `The weather in ${city} is sunny.`;\n              },\n            },\n          },\n        });\n\n        // Stream response using the processed messages\n        streamText({\n          model: openai(\"gpt-4o\"),\n          messages: processedMessages,\n          tools,\n          onFinish,\n        }).mergeIntoDataStream(dataStream);\n      },\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Agent Class in TypeScript\nDESCRIPTION: Shows the fundamental structure of an agent by extending the `Agent` class from the `agents` package. It implements the asynchronous `onRequest` method to handle incoming requests and return a simple `Response` object. This serves as the starting point for creating custom agent logic.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agent } from \"agents\";\n\nexport class IntelligentAgent extends Agent {\n  async onRequest(request) {\n    // Transform intention into response\n    return new Response(\"Ready to assist.\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Agent State with `setState` and `onStateUpdate` in TypeScript\nDESCRIPTION: Shows how an agent (`ThinkingAgent` extending `Agent`) can manage its internal, persistent state. The `evolve` method demonstrates updating the state using `this.setState`, merging new insights into an array and incrementing an understanding counter. The `onStateUpdate` lifecycle hook is called automatically whenever the state changes, allowing the agent to react to its own state updates.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport class ThinkingAgent extends Agent {\n  async evolve(newInsight) {\n    this.setState({\n      ...this.state,\n      insights: [...(this.state.insights || []), newInsight],\n      understanding: this.state.understanding + 1,\n    });\n  }\n\n  onStateUpdate(state, source) {\n    console.log(\"Understanding deepened:\", {\n      newState: state,\n      origin: source,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenAI with an Agent in TypeScript\nDESCRIPTION: Demonstrates creating an `AIAgent` that utilizes the OpenAI API for chat completions. It requires the `agents` and `openai` packages. Inside `onRequest`, it initializes the OpenAI client using an API key from environment variables (`this.env.OPENAI_API_KEY`), sends the request text to the specified model ('gpt-4'), and returns the AI's response content. An example `processTask` method outline is also included.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agent } from \"agents\";\nimport { OpenAI } from \"openai\";\n\nexport class AIAgent extends Agent {\n  async onRequest(request) {\n    // Connect with AI capabilities\n    const ai = new OpenAI({\n      apiKey: this.env.OPENAI_API_KEY,\n    });\n\n    // Process and understand\n    const response = await ai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [{ role: \"user\", content: await request.text() }],\n    });\n\n    return new Response(response.choices[0].message.content);\n  }\n\n  async processTask(task) {\n    await this.understand(task);\n    await this.act();\n    await this.reflect();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hono Agent Classes and Middleware\nDESCRIPTION: This TypeScript snippet shows how to define agent classes, instantiate a Hono application, and integrate the agents middleware. It sets up the agent classes which extend from \"Agent\" class, including methods like onRequest, for handling requests. It then integrates agentsMiddleware into the Hono application for routing and handling incoming requests to the AI agents.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/hono-agents/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Hono } from \"hono\";\nimport { Agent } from \"agents\";\nimport { agentsMiddleware } from \"hono-agents\";\n\n// Define your agent classes\nexport class ChatAgent extends Agent {\n  async onRequest(request) {\n    return new Response(\"Ready to assist with chat.\");\n  }\n}\n\nexport class AssistantAgent extends Agent {\n  async onRequest(request) {\n    return new Response(\"I'm your AI assistant.\");\n  }\n}\n\n// Basic setup\nconst app = new Hono();\napp.use(\"*\", agentsMiddleware());\n\n// or with authentication\napp.use(\n  \"*\",\n  agentsMiddleware({\n    options: {\n      onBeforeConnect: async (req) => {\n        const token = req.headers.get(\"authorization\");\n        // validate token\n        if (!token) return new Response(\"Unauthorized\", { status: 401 });\n      },\n    },\n  })\n);\n\n// With error handling\napp.use(\"*\", agentsMiddleware({ onError: (error) => console.error(error) }));\n\n// With custom routing\napp.use(\n  \"*\",\n  agentsMiddleware({\n    options: {\n      prefix: \"agents\", // Handles /agents/* routes only\n    },\n  })\n);\n\nexport default app;\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Agent State with React UI using `useAgent`\nDESCRIPTION: Demonstrates synchronizing an agent's state with a React component's local state. The `useAgent` hook connects to `thinking-agent` and uses the `onStateUpdate` callback to update the local React state (`setState`) whenever the agent's state changes. Conversely, a button click handler (`increment`) calls `agent.setState` to update the agent's state, which then triggers the `onStateUpdate` callback, ensuring bidirectional synchronization.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from \"react\";\nimport { useAgent } from \"agents/react\";\n\nfunction StateInterface() {\n  const [state, setState] = useState({ counter: 0 });\n\n  const agent = useAgent({\n    agent: \"thinking-agent\",\n    onStateUpdate: (newState) => setState(newState),\n  });\n\n  const increment = () => {\n    agent.setState({ counter: state.counter + 1 });\n  };\n\n  return (\n    <div>\n      <div>Count: {state.counter}</div>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Features using AI Orchestrator and Workers in TypeScript\nDESCRIPTION: This asynchronous TypeScript function, `implementFeature`, orchestrates AI models to implement software features. It first calls `generateObject` with OpenAI's 'o1' model to create an implementation plan (files, change types, complexity) based on the input `featureRequest` string, validated using a Zod schema. Subsequently, it iterates through the plan, using `generateObject` again with OpenAI's 'gpt-4o' model and specialized system prompts for each file change type (create, modify, delete) to generate the actual code and explanation, also validated by Zod. It depends on `@ai-sdk/openai`, `ai`, and `zod`. The function returns an object containing the generated `plan` and the detailed `changes`.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/04 orchestrator.txt#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { openai } from '@ai-sdk/openai';\nimport { generateObject } from 'ai';\nimport { z } from 'zod';\n\nasync function implementFeature(featureRequest: string) {\n  // Orchestrator: Plan the implementation\n  const { object: implementationPlan } = await generateObject({\n    model: openai('o1'),\n    schema: z.object({\n      files: z.array(\n        z.object({\n          purpose: z.string(),\n          filePath: z.string(),\n          changeType: z.enum(['create', 'modify', 'delete']),\n        }),\n      ),\n      estimatedComplexity: z.enum(['low', 'medium', 'high']),\n    }),\n    system:\n      'You are a senior software architect planning feature implementations.',\n    prompt: `Analyze this feature request and create an implementation plan:\n    ${featureRequest}`,\n  });\n\n  // Workers: Execute the planned changes\n  const fileChanges = await Promise.all(\n    implementationPlan.files.map(async file => {\n      // Each worker is specialized for the type of change\n      const workerSystemPrompt = {\n        create:\n          'You are an expert at implementing new files following best practices and project patterns.',\n        modify:\n          'You are an expert at modifying existing code while maintaining consistency and avoiding regressions.',\n        delete:\n          'You are an expert at safely removing code while ensuring no breaking changes.',\n      }[file.changeType];\n\n      const { object: change } = await generateObject({\n        model: openai('gpt-4o'),\n        schema: z.object({\n          explanation: z.string(),\n          code: z.string(),\n        }),\n        system: workerSystemPrompt,\n        prompt: `Implement the changes for ${file.filePath} to support:\n        ${file.purpose}\n\n        Consider the overall feature context:\n        ${featureRequest}`,\n      });\n\n      return {\n        file,\n        implementation: change,\n      };\n    }),\n  );\n\n  return {\n    plan: implementationPlan,\n    changes: fileChanges,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Tasks within an Agent using TypeScript\nDESCRIPTION: Shows how a `TimeAwareAgent` (extending `Agent`) uses the `this.schedule` method to schedule future actions. Tasks can be scheduled after a delay (in milliseconds), using a cron string for recurring tasks, or at a specific `Date`. Each scheduled task calls a corresponding method (`quickInsight`, `dailySynthesis`, `yearlyAnalysis`) within the agent, potentially passing data provided during scheduling.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TimeAwareAgent extends Agent {\n  async initialize() {\n    // Quick reflection\n    this.schedule(10, \"quickInsight\", { focus: \"patterns\" });\n\n    // Daily synthesis\n    this.schedule(\"0 0 * * *\", \"dailySynthesis\", {\n      depth: \"comprehensive\",\n    });\n\n    // Milestone review\n    this.schedule(new Date(\"2024-12-31\"), \"yearlyAnalysis\");\n  }\n\n  async quickInsight(data) {\n    await this.analyze(data.focus);\n  }\n\n  async dailySynthesis(data) {\n    await this.synthesize(data.depth);\n  }\n\n  async yearlyAnalysis() {\n    await this.analyze();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to an Agent Directly using AgentClient in TypeScript\nDESCRIPTION: Demonstrates client-side code for connecting directly to an agent using the `AgentClient` class from `agents/client`. It initializes a connection to a specific agent instance identified by its class name (`agent`) and unique name (`name`). Event listeners are added to handle incoming messages, and the `connection.send` method is used to send JSON data to the agent.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AgentClient } from \"agents/client\";\n\nconst connection = new AgentClient({\n  agent: \"dialogue-agent\",\n  name: \"insight-seeker\",\n});\n\nconnection.addEventListener(\"message\", (event) => {\n  console.log(\"Received:\", event.data);\n});\n\nconnection.send(\n  JSON.stringify({\n    type: \"inquiry\",\n    content: \"What patterns do you see?\",\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Literary Translation with Feedback Optimization Using OpenAI GPT Models (JavaScript)\nDESCRIPTION: This function performs a threaded translation of text into a target language, utilizing GPT-4 models for initial translation, evaluation, and iterative improvement based on feedback. It depends on '@ai-sdk/openai' for model access, 'ai' library functions for text and object generation, and 'zod' for schema validation. The process aims to ensure high translation quality through multiple evaluation and refinement cycles, with input parameters including the source text and target language, and outputs the final translation and iteration count.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/05 evaluator.txt#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function translateWithFeedback(text: string, targetLanguage: string) {\n  let currentTranslation = '';\n  let iterations = 0;\n  const MAX_ITERATIONS = 3;\n\n  // Initial translation\n  const { text: translation } = await generateText({\n    model: openai('gpt-4o-mini'), // use small model for first attempt\n    system: 'You are an expert literary translator.',\n    prompt: `Translate this text to ${targetLanguage}, preserving tone and cultural nuances:\n    ${text}`,\n  });\n\n  currentTranslation = translation;\n\n  // Evaluation-optimization loop\n  while (iterations < MAX_ITERATIONS) {\n    // Evaluate current translation\n    const { object: evaluation } = await generateObject({\n      model: openai('gpt-4o'), // use a larger model to evaluate\n      schema: z.object({\n        qualityScore: z.number().min(1).max(10),\n        preservesTone: z.boolean(),\n        preservesNuance: z.boolean(),\n        culturallyAccurate: z.boolean(),\n        specificIssues: z.array(z.string()),\n        improvementSuggestions: z.array(z.string()),\n      }),\n      system: 'You are an expert in evaluating literary translations.',\n      prompt: `Evaluate this translation:\n\n      Original: ${text}\n      Translation: ${currentTranslation}\n\n      Consider:\n      1. Overall quality\n      2. Preservation of tone\n      3. Preservation of nuance\n      4. Cultural accuracy`,\n    });\n\n    // Check if quality meets threshold\n    if (\n      evaluation.qualityScore >= 8 &&\n      evaluation.preservesTone &&\n      evaluation.preservesNuance &&\n      evaluation.culturallyAccurate\n    ) {\n      break;\n    }\n\n    // Generate improved translation based on feedback\n    const { text: improvedTranslation } = await generateText({\n      model: openai('gpt-4o'), // use a larger model\n      system: 'You are an expert literary translator.',\n      prompt: `Improve this translation based on the following feedback:\n      ${evaluation.specificIssues.join('\\n')}\n      ${evaluation.improvementSuggestions.join('\\n')}\n\n      Original: ${text}\n      Current Translation: ${currentTranslation}`,\n    });\n\n    currentTranslation = improvedTranslation;\n    iterations++;\n  }\n\n  return {\n    finalTranslation: currentTranslation,\n    iterationsRequired: iterations,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Marketing Copy with Quality Checks using OpenAI in TypeScript\nDESCRIPTION: This asynchronous function `generateMarketingCopy` takes a string input and uses the OpenAI GPT-4o model to generate marketing copy. It first generates an initial version using `generateText`. Then, it evaluates the generated copy for quality metrics (presence of a call to action, emotional appeal, clarity) using `generateObject` and a Zod schema. If the quality metrics are below certain thresholds, it regenerates the copy with specific instructions for improvement before returning the final copy and its quality metrics. Dependencies include `@ai-sdk/openai`, `ai`, and `zod`.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/01 sequential.txt#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { openai } from \"@ai-sdk/openai\";\nimport { generateText, generateObject } from \"ai\";\nimport { z } from \"zod\";\n\nexport default async function generateMarketingCopy(input: string) {\n  const model = openai(\"gpt-4o\");\n\n  // First step: Generate marketing copy\n  const { text: copy } = await generateText({\n    model,\n    prompt: `Write persuasive marketing copy for: ${input}. Focus on benefits and emotional appeal.`,\n  });\n\n  // Perform quality check on copy\n  const { object: qualityMetrics } = await generateObject({\n    model,\n    schema: z.object({\n      hasCallToAction: z.boolean(),\n      emotionalAppeal: z.number().min(1).max(10),\n      clarity: z.number().min(1).max(10),\n    }),\n    prompt: `Evaluate this marketing copy for:\n    1. Presence of call to action (true/false)\n    2. Emotional appeal (1-10)\n    3. Clarity (1-10)\n\n    Copy to evaluate: ${copy}`,\n  });\n\n  // If quality check fails, regenerate with more specific instructions\n  if (\n    !qualityMetrics.hasCallToAction ||\n    qualityMetrics.emotionalAppeal < 7 ||\n    qualityMetrics.clarity < 7\n  ) {\n    const { text: improvedCopy } = await generateText({\n      model,\n      prompt: `Rewrite this marketing copy with:\n      ${!qualityMetrics.hasCallToAction ? \"- A clear call to action\" : \"\"}\n      ${qualityMetrics.emotionalAppeal < 7 ? \"- Stronger emotional appeal\" : \"\"}\n      ${qualityMetrics.clarity < 7 ? \"- Improved clarity and directness\" : \"\"}\n\n      Original copy: ${copy}`,\n    });\n    return { copy: improvedCopy, qualityMetrics };\n  }\n\n  return { copy, qualityMetrics };\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Multi-Domain Code Review with OpenAI SDK in JavaScript\nDESCRIPTION: This snippet defines an async function that performs three concurrent code reviews focusing on security, performance, and maintainability using different schemas and prompts. It then synthesizes these reviews into a concise summary with a final call to generateText. Dependencies include '@ai-sdk/openai', 'ai', and 'zod' libraries. Key parameters include code input, review model configuration, and schemas for expected review output.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/03 parallel.txt#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { openai } from '@ai-sdk/openai';\nimport { generateText, generateObject } from 'ai';\nimport { z } from 'zod';\n\n// Example: Parallel code review with multiple specialized reviewers\nasync function parallelCodeReview(code: string) {\n  const model = openai('gpt-4o');\n\n  // Run parallel reviews\n  const [securityReview, performanceReview, maintainabilityReview] =\n    await Promise.all([\n      generateObject({\n        model,\n        system:\n          'You are an expert in code security. Focus on identifying security vulnerabilities, injection risks, and authentication issues.',\n        schema: z.object({\n          vulnerabilities: z.array(z.string()),\n          riskLevel: z.enum(['low', 'medium', 'high']),\n          suggestions: z.array(z.string()),\n        }),\n        prompt: `Review this code:\n      ${code}`,\n      }),\n\n      generateObject({\n        model,\n        system:\n          'You are an expert in code performance. Focus on identifying performance bottlenecks, memory leaks, and optimization opportunities.',\n        schema: z.object({\n          issues: z.array(z.string()),\n          impact: z.enum(['low', 'medium', 'high']),\n          optimizations: z.array(z.string()),\n        }),\n        prompt: `Review this code:\n      ${code}`,\n      }),\n\n      generateObject({\n        model,\n        system:\n          'You are an expert in code quality. Focus on code structure, readability, and adherence to best practices.',\n        schema: z.object({\n          concerns: z.array(z.string()),\n          qualityScore: z.number().min(1).max(10),\n          recommendations: z.array(z.string()),\n        }),\n        prompt: `Review this code:\n      ${code}`,\n      }),\n    ]);\n\n  const reviews = [\n    { ...securityReview.object, type: 'security' },\n    { ...performanceReview.object, type: 'performance' },\n    { ...maintainabilityReview.object, type: 'maintainability' },\n  ];\n\n  // Aggregate results using another model instance\n  const { text: summary } = await generateText({\n    model,\n    system: 'You are a technical lead summarizing multiple code reviews.',\n    prompt: `Synthesize these code review results into a concise summary with key actions:\n    ${JSON.stringify(reviews, null, 2)}`,\n  });\n\n  return { reviews, summary };\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating an Agent with React using the `useAgent` Hook\nDESCRIPTION: Illustrates how to use the `useAgent` hook from `agents/react` within a React functional component (`AgentInterface`). The hook establishes and manages a connection to a specified agent (`dialogue-agent`, `insight-seeker`). Callbacks (`onMessage`, `onOpen`, `onClose`) handle connection events and incoming data. The returned `connection` object provides a `send` method to communicate back to the agent, triggered here by a button click.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAgent } from \"agents/react\";\n\nfunction AgentInterface() {\n  const connection = useAgent({\n    agent: \"dialogue-agent\",\n    name: \"insight-seeker\",\n    onMessage: (message) => {\n      console.log(\"Understanding received:\", message.data);\n    },\n    onOpen: () => console.log(\"Connection established\"),\n    onClose: () => console.log(\"Connection closed\"),\n  });\n\n  const inquire = () => {\n    connection.send(\n      JSON.stringify({\n        type: \"inquiry\",\n        content: \"What insights have you gathered?\",\n      })\n    );\n  };\n\n  return (\n    <div className=\"agent-interface\">\n      <button onClick={inquire}>Seek Understanding</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Agent Lifecycle: Creation and Connection in TypeScript\nDESCRIPTION: Illustrates how to manage agent instances using the environment bindings configured in `wrangler.toml`. It shows creating a new unique agent instance using `env.AIAgent.newUniqueId()` and `get()`, and then calling an agent method (`processTask`). It also suggests retrieving an existing agent, potentially using a custom helper function like `getAgentByName`.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a new instance\nconst id = env.AIAgent.newUniqueId();\nconst agent = env.AIAgent.get(id);\n\n// Initialize with purpose\nawait agent.processTask({\n  type: \"analysis\",\n  context: \"incoming_data\",\n  parameters: initialConfig,\n});\n\n// Or reconnect with an existing one\nconst existingAgent = await getAgentByName(env.AIAgent, \"data-analyzer\");\n```\n\n----------------------------------------\n\nTITLE: Generating AI Response based on Classification using generateText - TypeScript\nDESCRIPTION: Generates the final text response using the `generateText` function. The specific AI model ('gpt-4o-mini' or 'o1-mini') is selected based on the classified query complexity, and a relevant system prompt is chosen from a map based on the query type. The original customer query is used as the user prompt for generating the response.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n  // Route based on classification\n  // Set model and system prompt based on query type and complexity\n  const { text: response } = await generateText({\n    model:\n      classification.complexity === 'simple'\n        ? openai('gpt-4o-mini')\n        : openai('o1-mini'),\n    system: {\n      general:\n        'You are an expert customer service agent handling general inquiries.',\n      refund:\n        'You are a customer service agent specializing in refund requests. Follow company policy and collect necessary information.',\n      technical:\n        'You are a technical support specialist with deep product knowledge. Focus on clear step-by-step troubleshooting.',\n    }[classification.type],\n    prompt: query,\n  });\n```\n\n----------------------------------------\n\nTITLE: WebSocket Connection and Message Handling in Frontend with PartySocket\nDESCRIPTION: This code establishes a WebSocket connection from the frontend to a Durable Object instance using PartySocket SDK, enabling real-time communication for agent state updates. It listens for messages of type 'state' and updates the workflow state accordingly. Additionally, it can send initial run commands to start the agent workflow.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst socket = usePartySocket({\n  party: type,\n  room: \"default-room\",\n  onMessage: (e) => {\n    const data = JSON.parse(e.data);\n    switch (data.type) {\n      case \"state\":\n        setWorkflowState(data.state);\n        break;\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Building React Client for Human-in-the-Loop Chat Interface\nDESCRIPTION: Implements a React component that renders chat messages and tool approval requests. This component allows users to approve or reject tool invocations from the AI agent using buttons.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Chat() {\n  // Initialize agent and chat hooks\n  const agent = useAgent({ agent: \"human-in-the-loop\" });\n  const { messages, addToolResult } = useAgentChat({ agent });\n\n  return (\n    <div className=\"chat-container\">\n      {messages.map((message) => (\n        <div key={message.id}>\n          {/* Render normal messages */}\n          {message.type === \"text\" && (\n            <div className=\"message\">{message.content}</div>\n          )}\n\n          {/* Render tool approval requests */}\n          {message.type === \"tool-invocation\" && (\n            <div className=\"tool-approval\">\n              <p>\n                Approve {message.tool} for {message.args.city}?\n              </p>\n              <button onClick={() => addToolResult(message.id, \"approve\")}>\n                Yes\n              </button>\n              <button onClick={() => addToolResult(message.id, \"reject\")}>\n                No\n              </button>\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Classifying Customer Query with AI SDK generateObject - TypeScript\nDESCRIPTION: Initializes the 'gpt-4o' OpenAI model and uses the `generateObject` function from the AI SDK to classify the input customer query. It uses a Zod schema to enforce the structure of the AI's output, expecting fields for reasoning, query type (general, refund, technical), and complexity (simple, complex).\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n  const model = openai('gpt-4o');\n\n  // First step: Classify the query type\n  const { object: classification } = await generateObject({\n    model,\n    schema: z.object({\n      reasoning: z.string(),\n      type: z.enum(['general', 'refund', 'technical']),\n      complexity: z.enum(['simple', 'complex']),\n    }),\n    prompt: `Classify this customer query:\n    ${query}\n\n    Determine:\n    1. Query type (general, refund, or technical)\n    2. Complexity (simple or complex)\n    3. Brief reasoning for classification`,\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Objects for Agents in wrangler.toml\nDESCRIPTION: Provides a JSONC configuration snippet for `wrangler.toml` (or `.cloudflare/wrangler.toml`). It defines Durable Object bindings under the `durable_objects` key, mapping a name (e.g., `AIAgent`) to its corresponding class implementation. It also includes a mandatory `migrations` section with `new_sqlite_classes` to enable persistent state storage for the specified agent class.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_3\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"name\": \"AIAgent\",\n        \"class_name\": \"AIAgent\",\n      },\n    ],\n  },\n  \"migrations\": [\n    {\n      \"tag\": \"v1\",\n      // Mandatory for the Agent to store state\n      \"new_sqlite_classes\": [\"AIAgent\"],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Objects in wrangler.toml\nDESCRIPTION: This TOML configuration file demonstrates how to set up Durable Objects for the agents within a Cloudflare Workers project. It defines the bindings for each agent class to Durable Objects, enabling state management. It also sets up database migrations using SQLite.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/hono-agents/README.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[durable_objects]\nbindings = [\n  { name = \"ChatAgent\", class_name = \"ChatAgent\" },\n  { name = \"AssistantAgent\", class_name = \"AssistantAgent\" }\n]\n\n[[migrations]]\ntag = \"v1\"\nnew_sqlite_classes = [\"ChatAgent\", \"AssistantAgent\"]\n```\n\n----------------------------------------\n\nTITLE: Durable Object State Management for AI Agents\nDESCRIPTION: This snippet defines the internal state structure for a Durable Object managing an AI agent, including flags indicating whether the agent is running and its output data. It is used within the Durable Object class to maintain persistent state across executions, supporting real-time updates and persistence.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nstate: {\n  isRunning: boolean;\n  output: any;\n} = {\n  isRunning: false,\n  output: undefined,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Resources and Tools in McpAgent using MCP SDK\nDESCRIPTION: This snippet demonstrates the implementation of the McpAgent class, showcasing how to initialize an MCP server with specific name and version, then define a resource and a tool within the async init() method. It utilizes the MCP SDK functions `resource` and `tool` to register these entities, facilitating resource management and computation features.\nSOURCE: https://github.com/cloudflare/agents/blob/main/examples/mcp/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class MyMCP extends McpAgent<Env> {\n  server = new McpServer({\n    name: \"Demo\",\n    version: \"1.0.0\",\n  });\n\n  async init() {\n    this.server.resource(`counter`, `mcp://resource/counter`, (uri) => {\n      // ...\n    });\n\n    this.server.tool(\n      \"add\",\n      \"Add two numbers together\",\n      { a: z.number(), b: z.number() },\n      async ({ a, b }) => {\n        // ...\n      }\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining handleCustomerQuery function - TypeScript\nDESCRIPTION: Defines an asynchronous TypeScript function `handleCustomerQuery` that takes a customer query string as input. This function orchestrates the entire process of classifying the query and generating a response using AI models, returning the generated text response and the classification details.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function handleCustomerQuery(query: string) {\n```\n\n----------------------------------------\n\nTITLE: Setting Agent Initial State with TypeScript\nDESCRIPTION: This snippet demonstrates how to define an initial state for a Cloudflare Agent using the `initialState` property within a TypeScript class extending `Agent`. This state becomes the default when the agent starts and is automatically synchronized for use in client-side hooks.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/CHANGELOG.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype State = {\n  counter: number;\n  text: string;\n  color: string;\n};\n\nclass MyAgent extends Agent<Env, State> {\n  initialState = {\n    counter: 0,\n    text: \"\",\n    color: \"#3B82F6\"\n  };\n\n  doSomething() {\n    console.log(this.state); // {counter: 0, text: \"\", color: \"#3B82F6\"}, if you haven't set the state yet\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cloudflare Workers with wrangler.toml\nDESCRIPTION: Configuration file for Cloudflare Workers that defines the Durable Objects binding and migrations for the HumanInTheLoop agent class.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[[durable_objects.bindings]]\nbinding = \"HumanInTheLoop\"\nclass_name = \"HumanInTheLoop\"\n\n[[migrations]]\ntag = \"v1\"\nnew_sqlite_classes = [\"HumanInTheLoop\"]\n```\n\n----------------------------------------\n\nTITLE: Returning Response and Classification - TypeScript\nDESCRIPTION: Returns an object containing the generated text `response` from the AI model and the `classification` object obtained from the initial classification step. This allows the caller to utilize both the final response and the details about how the query was processed.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n  return { response, classification };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the `agents` Framework using npm\nDESCRIPTION: Provides shell commands to set up a project with the `agents` framework. The first command creates a new Cloudflare project using the `cloudflare/agents-starter` template, while the second command adds the `agents` package to an existing npm project.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Create a new project\nnpm create cloudflare@latest -- --template cloudflare/agents-starter\n\n# Or enhance an existing one\nnpm install agents\n```\n\n----------------------------------------\n\nTITLE: Initializing a Cloudflare Agents Project with npm - Bash\nDESCRIPTION: This snippet demonstrates how to create a new Cloudflare Agents project by running the provided npm command in a terminal. It uses the npm create utility with the cloudflare template for an agent-enabled starter, and also shows how to add the 'agents' package to an existing project via npm install. Prerequisites include Node.js, npm, and terminal access. Both commands output a project directory with necessary configuration or add the required dependencies for developing Cloudflare-based AI agents.\nSOURCE: https://github.com/cloudflare/agents/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create a new project\nnpm create cloudflare@latest -- --template cloudflare/agents-starter\n\n# Or add to existing project\nnpm install agents\n```\n\n----------------------------------------\n\nTITLE: Installing Hono Agents via npm\nDESCRIPTION: This snippet demonstrates the installation of required packages for using Cloudflare Agents with Hono. It uses the npm package manager to install \"agents\", \"hono\", and \"hono-agents\" packages. These dependencies are crucial for setting up and running AI agents within your Hono application.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/hono-agents/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install agents hono hono-agents\n```\n\n----------------------------------------\n\nTITLE: Importing AI SDK and Zod libraries - TypeScript\nDESCRIPTION: Imports the necessary functions and objects from the '@ai-sdk/openai', 'ai', and 'zod' libraries. These imports provide the capabilities to interact with AI models for text and object generation and to define data schemas for structured outputs.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { openai } from '@ai-sdk/openai';\nimport { generateObject, generateText } from 'ai';\nimport { z } from 'zod';\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Agent Playground with Node.js Bash Commands\nDESCRIPTION: This bash snippet provides commands to install necessary dependencies using npm and to start the development server for the Agent Playground project. These commands require Node.js and npm to be installed on the host machine, and should be executed in the project's root directory. Running these commands sets up the local environment, allowing users to access interactive agent examples at 'localhost:5173'.\nSOURCE: https://github.com/cloudflare/agents/blob/main/examples/playground/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Starting the Demo Environment (Bash)\nDESCRIPTION: This command first installs the necessary Node.js project dependencies using `npm install` (or `npm i`) and then starts the development servers for both the frontend React application and the backend Cloudflare Worker agent, typically via a script defined in `package.json`.\nSOURCE: https://github.com/cloudflare/agents/blob/main/examples/cross-domain/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i && npm start\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Starting Tic Tac Toe Smart Agent Demo in Bash\nDESCRIPTION: This Bash snippet demonstrates how to install all necessary Node.js dependencies using 'npm i' and then start the Tic Tac Toe smart agent demo with 'npm start'. This assumes the user has Node.js and npm already installed. The commands should be run in the root directory of the project to ensure correct installation and startup; no additional parameters are required.\nSOURCE: https://github.com/cloudflare/agents/blob/main/examples/tictactoe/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i && npm start\n```\n\n----------------------------------------\n\nTITLE: Starting the MCP Server Demo (Shell)\nDESCRIPTION: Installs Node.js dependencies using `npm install` and then starts the example MCP server using `npm start`. This server is a prerequisite for the Cloudflare Agent MCP client demo to connect to.\nSOURCE: https://github.com/cloudflare/agents/blob/main/examples/mcp-client/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Configuring API Keys in .env File for Agent Evaluations\nDESCRIPTION: Instructions for setting up API keys in the .env file to authenticate with various AI providers (OpenAI, Google, and Anthropic) before running agent evaluations. Any combination of these keys can be used depending on which models you want to test.\nSOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/evals/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=<your openai key>\nGOOGLE_GENERATIVE_AI_API_KEY=<your google key>\nANTHROPIC_API_KEY=<your anthropic key>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Cloudflare Agents Project\nDESCRIPTION: A bash command to install the necessary npm dependencies for the Cloudflare Agents project.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Deploying Cloudflare Agents with Wrangler CLI\nDESCRIPTION: A bash command to deploy the Cloudflare Agents application using the Wrangler CLI tool.\nSOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwrangler deploy\n```"
  }
]