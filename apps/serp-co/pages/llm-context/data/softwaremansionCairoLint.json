[
  {
    "owner": "software-mansion",
    "repo": "cairo-lint",
    "content": "TITLE: Refactored assertion in Cairo using assert! macro\nDESCRIPTION: This code snippet shows the improved Cairo function where the manual assertion using if and panic! is replaced with the idiomatic assert! macro. This enhances code clarity and adheres to standard Cairo practices for assertion checks.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_assert.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let a = 5;\n    assert!(a != 5, \"a shouldn't be equal to 5\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using is_ok method on Result type in Cairo\nDESCRIPTION: This snippet demonstrates the idiomatic way to check if a Result type is Ok by calling its is_ok method. It requires the Result type to have an is_ok method implemented. The snippet takes a Result value as input and returns a boolean indicating success. This method improves code clarity and reduces manual pattern matching.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_ok.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = res_val.is_ok();\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Implementation Using expect Method in Cairo\nDESCRIPTION: The improved version of the code that uses the built-in expect method, which is cleaner and more idiomatic Cairo code, as recommended by the lint rule.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_expect.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let foo: Option::<i32> = Option::None;\n    let _foo = foo.expect('err');\n}\n```\n\n----------------------------------------\n\nTITLE: Using is_none Method for Option Checking in Cairo\nDESCRIPTION: Shows the idiomatic method to determine if an Option<i32> is None by directly calling the is_none method in Cairo. This approach is concise, avoids boilerplate match code, and leverages the Option API. The input is an Option<i32>; the output is a boolean indicating whether the value is None.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_none.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = foo.is_none();\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Single-Arm Match to if let Statement - Cairo\nDESCRIPTION: This snippet shows the recommended way to handle a match expression with only one meaningful arm by rewriting it as an if let statement. The code checks if the variable matches Option::Some and, if so, executes the action. This approach results in more concise and idiomatic Cairo code. Requires the same dependencies as the previous snippet and yields the same behavior, accepting an Option variable and conditionally executing a function.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/destruct_match.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nif let Option::Some(val) = var {\n    do_smth(val),\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Option Unwrapping using unwrap_or_default() in Cairo\nDESCRIPTION: Shows the simplified way to unwrap a Cairo Option<u128> using the 'unwrap_or_default()' method. This method returns the contained value if Some, or the type's default value if None. This is the recommended alternative suggested by the 'manual_unwrap_or_default' lint.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_unwrap_or_default.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let x: Option<u128> = Option::Some(1038);\n    x.unwrap_or_default();\n}\n```\n\n----------------------------------------\n\nTITLE: Collapsible If-Else Example (After)\nDESCRIPTION: This Cairo code snippet presents the refactored version of the previous example, using an `else if` statement. This achieves the same functionality as the nested `if` structure but with improved readability and conciseness. No dependencies are needed to run this code.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/collapsible_if_else.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = true;\n    if x {\n        println!(\"x is true\");\n    } else if !x {\n        println!(\"x is false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Refactored expect_err Using Built-in Method in Cairo\nDESCRIPTION: This code snippet shows the suggested refactoring using the built-in `expect_err` method. It directly calls `foo.expect_err(err)` which achieves the same functionality as the manual implementation shown above in a more concise way.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_expect_err.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Result<i32> = Result::Err('err');\n    let err = 'this is an err';\n    let _foo = foo.expect_err(err);\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Boolean Comparison in Cairo\nDESCRIPTION: This Cairo snippet demonstrates the suggested simplification of the previous boolean comparison. Instead of explicitly comparing `x` to `true`, the code now directly uses `x` as the conditional expression in the `if` statement. This improved readability and avoids redundancy. This simplification relies on the inherent truthiness of the boolean variable.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/bool_comparison.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n   let x = true;\n   if x {\n       println!(\"x is true\");\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ok_or Method for Option to Result Conversion in Cairo\nDESCRIPTION: This snippet shows the recommended, more idiomatic way to convert an `Option<T>` to a `Result<T, E>` using the built-in `ok_or` method. This method achieves the same result as the manual match statement shown previously but in a more concise and readable format, which is preferred by the `manual_ok_or` lint.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_ok_or.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = foo.ok_or('this is an err');\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Equatable `if let` with Equality Check in Cairo\nDESCRIPTION: This snippet demonstrates the recommended alternative suggested by the `equatable_if_let` lint rule. It replaces the `if let` pattern match with a direct equality comparison (`==`) between the variable `a` and the value `Some(2)`, achieving the same conditional logic more concisely.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/equatable_if_let.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nif a == Some(2) {\n    // Code\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified while loop version in Cairo\nDESCRIPTION: This is the simplified and idiomatic version of the previous Cairo example, replacing the infinite loop with a 'while' loop that runs as long as 'x' is not equal to 10, incrementing 'x' each iteration. This pattern avoids explicit breaks and improves code clarity consistent with the lint recommendation.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/loop_for_while.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let mut x: u16 = 0;\n    while x != 10 {\n        x += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Comparison in Cairo\nDESCRIPTION: Shows the simplified version of the previous example, replacing the double comparison (`x == y || x > y`) with a single, equivalent comparison (`x >= y`). This is the suggested simplification by the `simplifiable_comparison` lint rule for improved conciseness.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/simplifiable_comparison.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    if x >= y {\n        true\n    } else {\n        false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing While Loop Exit Condition Using Equality Operator - Cairo\nDESCRIPTION: This snippet provides the optimized version of the previous function, replacing the less than or equal (<=) comparison with an equality (!=) check in the while loop's exit condition. The loop continues until the variable 'a' equals 10, incrementing 'a' on each iteration. This change improves code efficiency by simplifying the comparison logic. The example assumes no external dependencies and operates on u32 integers.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/inefficient_while_comp.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let mut a = 1_u32;\n    while a != 10 {\n        a += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Integer Comparison - Cairo\nDESCRIPTION: This Cairo code snippet shows the simplified version of the previous example, where the '+ 1' addition is removed and the '<' operator is used for direct comparison. This demonstrates how the `int_le_plus_one` lint helps improve code readability and efficiency.  The main function defines two u32 variables, x and y, and performs the simplified comparison.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/int_le_plus_one.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x < y {}\n}\n```\n\n----------------------------------------\n\nTITLE: Automatically Fixing Cairo lint Issues - Shell\nDESCRIPTION: This snippet demonstrates how to automatically attempt fixing linting issues found in a Cairo project using the Scarb toolchain. Running `scarb lint --fix` triggers Cairo lint to not only report problems but also apply automated corrections where possible, enhancing developer productivity by reducing manual edits. This requires Scarb and the Cairo lint plugin installed and configured.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nscarb lint --fix\n```\n\n----------------------------------------\n\nTITLE: Detecting manual error extraction in match expressions in Cairo\nDESCRIPTION: This code snippet shows a Cairo function that manually matches on a Result type to extract an error value and suggests replacing this pattern with the more concise `err()` method. It emphasizes code readability and consistency by avoiding manual match handling for errors.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_err.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n#[source]\nfn main() {\n    let foo: Result<i32> = Result::Err('err');\n    let _foo = match foo {\n        Result::Ok(_) => Option::None,\n        Result::Err(x) => Option::Some(x),\n    };\n}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n#[source]\nfn main() {\n    let foo: Result<i32> = Result::Err('err');\n    let _foo = foo.err();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cairo lint Rules via Scarb.toml - TOML\nDESCRIPTION: This snippet illustrates how to configure specific lint rules for Cairo lint by editing the `Scarb.toml` configuration file. Within the `[tool.cairo-lint]` section, individual lint rules such as `panic` and `bool_comparison` can be enabled or disabled by setting their boolean values. This fine-grained control allows developers to tailor linting behavior to their coding standards and preferences. The example shows enabling the `panic` lint (disabled by default) and disabling the `bool_comparison` lint (enabled by default).\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.cairo-lint]\npanic = true\nbool_comparison = false\n```\n\n----------------------------------------\n\nTITLE: Simplified Boolean Output for Redundant Comparison - Cairo\nDESCRIPTION: This Cairo code snippet presents the simplified version of the previous example. It initializes two u32 variables and returns `true` unconditionally, as the prior comparison was always true. This exemplifies the intended transformation encouraged by the redundant_comparison lint: replacing unnecessary double comparisons with a direct constant result. The function showcases optimal Cairo coding practices without dependencies.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/redundant_comparison.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    true\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Redundant Multiplication and Simplification in Cairo\nDESCRIPTION: Illustrates the 'redundant_op' lint rule. The first Cairo code block ('Before') shows a variable being multiplied by 1, which is redundant. The second block ('After') shows the simplified equivalent code where the redundant multiplication is removed, as suggested by the lint.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/redundant_op.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = 42;\n    let _y = x * 1;\n}\n```\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = 42;\n    let _y = x;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result.is_err Method in Cairo\nDESCRIPTION: This snippet presents the preferred idiomatic approach to check if a Cairo Result value is an error by using the is_err method. The is_err method is called directly on the result, returning a boolean without manual pattern matching. This requires only the standard Result type support in Cairo. The code is more concise and readable, setting the variable _a to true if res_val contains an error, or false otherwise. Ensure the Cairo version in use supports the is_err method on Result.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_err.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = res_val.is_err();\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Unnecessary Additions in Integer Comparison - Cairo\nDESCRIPTION: This code snippet demonstrates the `int_ge_plus_one` lint in Cairo.  It checks for instances where an integer is compared to another integer plus one using the '>=' operator, suggesting that the comparison can be simplified using the '>' operator. The snippet shows code that triggers the lint and the suggested simplification.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/int_ge_plus_one.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x >= y + 1 {}\n}\n```\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x > y {}\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified version using constant boolean in Cairo\nDESCRIPTION: Improved version of the function where the unnecessary comparison has been replaced with the constant boolean value. This is the recommended approach instead of comparing identical operands.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_comp_op.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> bool {\n    true\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid .clone() Usage on felt252 (Cairo)\nDESCRIPTION: This snippet shows an example of using the `.clone()` method on a `felt252` type. In Cairo, `felt252` is a `Copy` type, meaning its value is duplicated upon assignment or function calls, making an explicit `.clone()` call unnecessary and flagged by the `clone_on_copy` lint rule.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/clone_on_copy.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n    let a: felt252 = 'Hello';\n    let b = a.clone()\n```\n\n----------------------------------------\n\nTITLE: Checking Impossible Comparisons with Cairo in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates an impossible comparison scenario where a variable 'x' of type 'u32' is checked against conflicting conditions (x > 200 && x < 100). Such comparisons always evaluate to false and represent unreachable code. The snippet serves as an example tested or flagged by the lint rule. It depends on standard Cairo features for variable declaration and conditional branching, and illustrates inputs as unsigned 32-bit integers with boolean outputs controlling code flow.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/impossible_comparison.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u32 = 1;\n    if x > 200 && x < 100 {\n        //impossible to reach\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Cairo Code Removing Redundant Condition\nDESCRIPTION: This Cairo snippet shows the refactored version of the previous example, addressing the 'ifs_same_cond' lint warning. The redundant 'else if' block with the identical condition has been removed, simplifying the code to a single 'if' statement.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/ifs_same_cond.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let a = 1;\n    let b = 1;\n    if a == b {\n        println!(\"a is equal to b\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Collapsing Nested If Statements in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates the refactored version of the previous example, where the nested `if` statements are collapsed into a single `if` statement. The compound condition combines the checks from both nested `if` statements for a more concise and readable implementation. The output remains the same as the nested version. No external dependencies are required.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/collapsible_if.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = true;\n    let y = true;\n    let z = false;\n    if (x || z) && (y && z) {\n        println!(\"Hello\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Collapsible If-Else Example (Before)\nDESCRIPTION: This Cairo code snippet demonstrates a nested `if` statement within an `else` block, which the `collapsible_if_else` linter flags. The linter suggests refactoring this pattern into an `else if` statement for improved readability and conciseness. No dependencies are needed to run this code.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/collapsible_if_else.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = true;\n    if x {\n        println!(\"x is true\");\n    } else {\n        if !x {\n            println!(\"x is false\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Single-Arm Match to If Statement Lint - Cairo\nDESCRIPTION: This snippet demonstrates the lint rule usage by showing a Cairo match statement that performs an action only in one arm and can be rewritten as an if statement. It illustrates both the original match pattern and the simplified if equivalent. This lint aims to simplify code and improve readability.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/equality_match.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nmatch variable {\n    Option::None => println!(\"None\"),\n    Option::Some => (),\n};\n```\n\nLANGUAGE: Cairo\nCODE:\n```\nif variable.is_none() {\n    println!(\"None\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Redundant If/Else If Condition in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a scenario flagged by the 'ifs_same_cond' lint. It contains an 'if' statement immediately followed by an 'else if' statement, both checking the exact same condition (a == b), leading to redundant logic.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/ifs_same_cond.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let a = 1;\n    let b = 1;\n    if a == b {\n        println!(\"a is equal to b\");\n    } else if a == b {\n        println!(\"a is equal to b\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Redundant Comparison in Cairo\nDESCRIPTION: Demonstrates a Cairo function with a double comparison (`x == y || x > y`) that the `simplifiable_comparison` lint rule would flag. This pattern checks if `x` is equal to or greater than `y` using two separate comparisons, which can be simplified.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/simplifiable_comparison.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    if x == y || x > y {\n        true\n    } else {\n        false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of expect in Cairo\nDESCRIPTION: A code example showing a manual implementation of the expect functionality using match statements and panic calls, which the lint rule flags as problematic.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_expect.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let foo: Option::<i32> = Option::None;\n    let _foo = match foo {\n        Option::Some(x) => x,\n        Option::None => core::panic_with_felt252('err'),\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Redundant Arithmetical Comparisons to Constant Results - Cairo\nDESCRIPTION: Shows the refactored version of the previous snippet, replacing each redundant arithmetical comparison with the constant boolean value 'false'. This demonstrates the recommended simplification after the lint is applied. Inputs: a single u256 parameter. Outputs: always returns false. Prerequisites: Cairo environment. Limitation: The logic is static and does not vary with input since all comparisons are known to be false.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/neq_comp_op.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn foo(a: u256) -> bool {\n    let _z = false;\n    let _y = false;\n    false\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Result Error State Manually in Cairo\nDESCRIPTION: This snippet demonstrates a manual check to determine if a Cairo Result value holds an error by matching against the enum variants. The pattern match inspects whether the result is Ok or Err and maps them to boolean values. No external dependencies are required other than the Cairo language's core support for Result type. The variable res_val is a Result containing i32, and the output variable _a is set to true if the result is an error, or false otherwise. This approach is verbose and can be replaced by built-in methods for conciseness.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_err.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = match res_val {\n        Result::Ok(_) => false,\n        Result::Err(_) => true\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Division with Identical Operands - Cairo\nDESCRIPTION: This Cairo code snippet demonstrates the simplified form of the division operation where the operands are identical. The original expression `a / a` is replaced with the constant `1`. This function also takes a u256 integer as input and returns a u256 integer as output.  This simplification improves code readability and potentially performance.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/div_eq_op.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    1\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested simplification for subtraction with identical operands in Cairo\nDESCRIPTION: This code snippet demonstrates the suggested replacement for subtraction operations with identical operands, where the expression `a - a` is replaced with `0`. This simplification improves code readability and efficiency in Cairo programs. The eq_diff_op linter makes this suggestion.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_diff_op.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    0\n}\n```\n\n----------------------------------------\n\nTITLE: Checking manual is_some implementations in Cairo\nDESCRIPTION: This snippet demonstrates how manual checks for the Some variant of an Option type are replaced by calls to the built-in is_some method to improve code clarity and conciseness. It does not require any external dependencies beyond the standard Cairo Option type support. The input is an Option type value checked with a match statement, and the output is a boolean indicating presence of Some variant. This pattern is discouraged in favor of using is_some() directly.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_some.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = match foo {\n        Option::Some(_) => true,\n        Option::None => false,\n    };\n}\n```\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = foo.is_some();\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting inefficient bitwise AND for parity check in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates the pattern flagged by the `bitwise_for_parity_check` lint. It showcases an inefficient bitwise AND operation (`200_u32 & 1`) used to check for parity, which can be optimized by using the modulo operator (`%`) instead. The lint aims to improve code performance by suggesting this replacement.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/bitwise_for_parity_check.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let _a = 200_u32 & 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Contradictory Comparisons - Cairo\nDESCRIPTION: This code snippet demonstrates a contradictory comparison in Cairo. It checks if x is less than y AND x is greater than y, which will always be false. The expected input includes two unsigned 32-bit integers (x and y). The output is a boolean value. The purpose is to highlight a potential logical error within the code. The provided code checks for a case that would always be false because the condition states that x should be less than y and also be greater than y.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/contradictory_comparison.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    if x < y && x > y {\n        true\n    } else {\n        false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Manual 'ok' Method Usage in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates the manual implementation of result value extraction using a match expression and how it can be simplified by calling the 'ok()' method. It requires the 'Result' and 'Option' types. The input is a Result value potentially containing an error, and the output is an Option containing the inner value or None. The snippet highlights the pattern the lint detects to suggest replacing manual matches with the 'ok()' method for brevity and clarity.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_ok.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = match res_val {\n        Result::Ok(x) => Option::Some(x),\n        Result::Err(_) => Option::None,\n    };\n}\n```\n\nLANGUAGE: cairo\nCODE:\n```\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = res_val.ok();\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Redundant Boolean Comparisons in Cairo\nDESCRIPTION: This Cairo code snippet provides an example of a boolean comparison within an `if` statement. The code initializes a boolean variable `x` and then checks if `x` is equal to `true`. The linter suggests simplifying this by directly using `x` in the `if` condition. No dependencies are needed; it's a basic example of boolean logic in Cairo. The input is a boolean variable, and the expected output is the execution of the print statement if the condition is met.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/bool_comparison.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = true;\n    if x == true {\n        println!(\"x is true\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Nested If Statements in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a nested `if` statement. The outer `if` condition checks if `x` or `z` is true.  The inner `if` condition then evaluates if `y` and `z` are true. This construct can be refactored to a single, more readable `if` statement. No external dependencies are required for this snippet.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/collapsible_if.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = true;\n    let y = true;\n    let z = false;\n\n    if x || z {\n        if y && z {\n            println!(\"Hello\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Cairo Enum Variant Names Example\nDESCRIPTION: Presents the simplified version of the `enum Cake` from the previous example. The redundant \"Cake\" suffix has been removed from each variant name, demonstrating the recommended style suggested by the `enum_variant_names` lint rule.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/enum_variant_names.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nenum Cake {\n    BlackForest,\n    Hummingbird,\n    Battenberg,\n}\n```\n\n----------------------------------------\n\nTITLE: Manual expect_err Implementation in Cairo\nDESCRIPTION: This code snippet demonstrates a manual implementation of the `expect_err` method using a `match` statement on a `Result` type.  It checks if the `Result` is `Ok` and panics if so, otherwise returns the error. The lint flags this pattern.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_expect_err.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Result<i32> = Result::Err('err');\n    let err = 'this is an err';\n    let _foo = match foo {\n        Result::Ok(_) => core::panic_with_felt252(err),\n        Result::Err(x) => x,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Option Enum with Single Arm Using match - Cairo\nDESCRIPTION: This snippet demonstrates matching on a Cairo Option enum where only one arm (Option::Some) triggers an action, while the other arm is a no-op. This pattern can be considered non-idiomatic and is flagged by the destruct_match lint rule. Requires importing or defining the Option enum, matching variables, and a function such as do_smth. Accepts any Option variable and performs an action on its value if it is Some; otherwise, it does nothing.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/destruct_match.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nlet var = Option::Some(1_u32);\nmatch var {\n    Option::Some(val) => do_smth(val),\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Manual Assertion Using if statement in Cairo\nDESCRIPTION: This code snippet demonstrates a Cairo function that manually performs an assertion by checking a condition within an if statement and calling panic! if the condition is true. The purpose is to identify such manual assertions so that they can be replaced with the assert! macro for better readability and standardization.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_assert.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let a = 5;\n    if a == 5 {\n        panic!(\"a shouldn't be equal to 5\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Contradictory Comparisons - Cairo\nDESCRIPTION: This code snippet shows a simplified version of the previous example. Because the comparison in the previous snippet is contradictory, the whole `if-else` block can be reduced to just `false`. This highlights how contradictory comparisons can be optimized and cleaned up. This is a demonstration of the simplification after detecting a contradictory comparison.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/contradictory_comparison.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    false\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Redundant Logical AND Operation in Cairo\nDESCRIPTION: This Cairo code snippet shows the simplified version of the previous example, as suggested by the `eq_logical_op` lint. The redundant expression `a & a` is replaced directly with the operand `a`, resulting in equivalent but more concise code.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_logical_op.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    a\n}\n```\n\n----------------------------------------\n\nTITLE: Unnecessary Integer Addition in Comparison - Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a scenario where an integer is incremented by 1 before being compared with the '<=' operator.  The lint suggests simplifying the comparison by removing the '+ 1' and using '<' instead. The main function defines two u32 variables, x and y, and performs the unnecessary addition.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/int_le_plus_one.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x + 1 <= y {}\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Redundant Double Comparison - Cairo\nDESCRIPTION: This code snippet defines a Cairo function `main` that creates two unsigned 32-bit integers and checks if `x` is greater than or equal to `y` or less than or equal to `y`. The conditional always evaluates to true, making the comparison redundant. This demonstrates how the redundant_comparison lint can identify and flag such cases, aiding in code simplification. No external dependencies are required, and the function returns a boolean based on the redundant logical condition.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/redundant_comparison.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() -> bool {\n    let x = 5_u32;\n    let y = 10_u32;\n    if x >= y || x <= y {\n        true\n    } else {\n        false\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect 'break' Usage in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates the incorrect usage of 'break ();' within a loop, which the 'break_unit' lint rule flags. The parentheses after 'break' are unnecessary.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/break_unit.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    loop {\n        break ();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inefficient While Loop Using Comparison Operator - Cairo\nDESCRIPTION: This snippet shows a Cairo function using a while loop with a less than or equal (<=) comparison as the loop's exit condition. The function initializes a mutable variable 'a' of type u32 and increments it until it exceeds 10. No external dependencies are required. This pattern is flagged by the lint as potentially inefficient since the exit condition could be optimized to use equality instead of inequality for better performance.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/inefficient_while_comp.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let mut a = 1_u32;\n    while a <= 10 {\n        a += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Equatable `if let` Pattern in Cairo\nDESCRIPTION: This code snippet shows the `if let` pattern match that the `equatable_if_let` lint rule flags. It checks if the variable `a` is `Some` and its inner value is equal to `2`. The lint suggests this can be replaced by a direct equality check.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/equatable_if_let.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nif let Some(2) = a {\n    // Code\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Option Unwrapping in Cairo\nDESCRIPTION: Example Cairo code demonstrating manual unwrapping of an Option<u128> using an 'if let' statement. This pattern is identified by the 'manual_unwrap_or_default' lint rule because it can be simplified.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_unwrap_or_default.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let x: Option<u128> = Option::Some(1038);\n    if let Option::Some(v) = x {\n        v\n    } else {\n        0\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking manual is_ok implementation in Cairo\nDESCRIPTION: This snippet shows a manual pattern matching implementation to check if a Result type is Ok. It manually matches on the Result variant and returns true for Ok and false for Err. It requires Cairo language support and the Result type definition. Inputs include a Result value, and output is a boolean indicating if the value is Ok. This approach is less idiomatic and can be error-prone compared to using the built-in is_ok method.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_ok.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let res_val: Result<i32> = Result::Err('err');\n    let _a = match res_val {\n        Result::Ok(_) => true,\n        Result::Err(_) => false\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for None with Manual Pattern Matching in Cairo\nDESCRIPTION: Demonstrates how to manually check if an Option value is None by using a match expression in Cairo. This approach requires explicit handling of all Option cases and results in a boolean, but is more verbose than using built-in helper methods. No external dependencies are needed; input is an Option<i32> and output is a boolean indicating None status.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_is_none.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = match foo {\n        Option::Some(_) => false,\n        Option::None => true,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Manual Option to Result Conversion in Cairo\nDESCRIPTION: This snippet demonstrates a code pattern where a `match` statement is manually used to convert an `Option<T>` to a `Result<T, E>`. This specific implementation mimics the functionality of the standard `ok_or` method and is flagged by the `manual_ok_or` lint as it can be replaced with a more concise approach.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/manual_ok_or.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let foo: Option<i32> = Option::None;\n    let _foo = match foo {\n        Option::Some(v) => Result::Ok(v),\n        Option::None => Result::Err('this is an err'),\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Panic Usage in Cairo Functions - Cairo\nDESCRIPTION: This code snippet demonstrates the use of the 'panic!' macro within a Cairo function named 'main'. It illustrates a lint check target that detects panic invocations, aiding developers in avoiding unhandled error states at runtime. No external dependencies are required, and the function expects no inputs or outputs; it serves solely as a test case for the lint rule that identifies calls to 'panic!' in Cairo source code. Limitations include its minimal example nature, and it is meant only for static analysis demonstration.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/panic.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    panic!(\"panic\");\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Cairo Enum Call without Redundant Brackets\nDESCRIPTION: This snippet demonstrates the preferred way to call an empty enum variant in Cairo by omitting redundant parentheses. The `redundant_brackets_in_enum_call` lint rule suggests this syntax as a simplification. It shows the same enum defined in the previous example, instantiated using the cleaner syntax `MyEnum::Empty;`.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/redundant_brackets_in_enum_call.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nenum MyEnum {\n    Data: u8,\n    Empty,\n}\n\nfn main() {\n    let a = MyEnum::Empty;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Redundant Arithmetical Comparison Operations Using Cairo Lint - Cairo\nDESCRIPTION: Demonstrates a function in Cairo where arithmetical comparison operations (not equal, greater than, less than) are performed with identical operands, which will always yield constant boolean results. The purpose is to show the kind of patterns detected by the neq_comp_op lint rule. Inputs: a single u256 parameter. Outputs: boolean result based on a < a (always false). Prerequisites: Cairo environment. Limitation: The comparisons are redundant and always evaluate to false.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/neq_comp_op.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn foo(a: u256) -> bool {\n    let _z = a != a;\n    let _y = a > a;\n    a < a\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Division with Identical Operands - Cairo\nDESCRIPTION: This Cairo code snippet demonstrates an expression where a variable 'a' is divided by itself. The lint rule targets such expressions. It showcases a function 'foo' that takes a u256 integer as input and returns a u256 integer as output.  The identified pattern can be simplified by replacing the entire expression `a / a` with `1`.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/div_eq_op.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    a / a\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting subtraction with identical operands in Cairo\nDESCRIPTION: The eq_diff_op linter identifies subtraction operations where the operands are identical, such as `a - a`. The linter suggests replacing such expressions with `0` to improve code readability and efficiency. The linter operates on Cairo code.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_diff_op.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    a - a\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Redundant Cairo Enum Variant Names\nDESCRIPTION: Illustrates a Cairo enumeration (`enum Cake`) where all variant names end with the redundant suffix \"Cake\". This pattern is detected by the `enum_variant_names` lint rule, indicating potential for simplification.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/enum_variant_names.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nenum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n    BattenbergCake,\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Redundant Logical AND Operation in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a function `foo` containing a logical AND operation (`&`) where both operands are the same variable `a`. The `eq_logical_op` lint flags this pattern as redundant because `a & a` is equivalent to `a`.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_logical_op.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> u256 {\n    a & a\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Double Parentheses in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a scenario where the `double_parens` lint would be triggered due to the presence of unnecessary double parentheses around the number 0. The lint suggests removing the outer parentheses for cleaner code.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/double_parens.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> u32 {\n    ((0))\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing identical operands in Cairo\nDESCRIPTION: Example of a function using unnecessary comparison between identical operands, which will always return true. This code pattern is detected by the eq_comp_op lint.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_comp_op.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn foo(a: u256) -> bool {\n    a == a\n}\n```\n\n----------------------------------------\n\nTITLE: Example of loop with conditional break in Cairo\nDESCRIPTION: This Cairo code defines a 'loop' that increments a mutable variable 'x' until it is equal to 10, at which point it breaks out of the loop via a conditional 'if' statement. It serves as a pattern detection example for the lint rule, demonstrating non-idiomatic use of loops that can be simplified.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/loop_for_while.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let mut x: u16 = 0;\n    loop {\n        if x == 10 {\n            break;\n        }\n        x += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Cairo Expression\nDESCRIPTION: This Cairo code snippet shows the simplified version of the previous example, with the unnecessary double parentheses removed. This is the recommended output after applying the `double_parens` lint.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/double_parens.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> u32 {\n    0\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Redundant Brackets in Cairo Enum Call\nDESCRIPTION: This snippet shows an example of calling an empty enum variant in Cairo using redundant parentheses `(())`. The `redundant_brackets_in_enum_call` lint rule flags this pattern. It defines a simple enum and instantiates its empty variant with unnecessary brackets, which is considered a lint violation.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/redundant_brackets_in_enum_call.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nenum MyEnum {\n    Data: u8,\n    Empty,\n}\n\nfn main() {\n    let a = MyEnum::Empty(()); // redundant parentheses\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo lint Static Code Analysis - Shell\nDESCRIPTION: This snippet shows how to invoke Cairo lint using the Scarb toolchain via the shell. The `scarb lint` command performs static analysis on the Cairo project in the current directory, reporting any lint issues found. The snippet also includes a sample output demonstrating a warning about an unnecessary boolean comparison, helping users understand the typical feedback format. No additional dependencies besides having Scarb installed and configured are required.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscarb lint\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb lint\n  Linting hello_world v0.1.0 (/hello_world/Scarb.toml)\n  warning: Plugin diagnostic: Unnecessary comparison with a boolean value. Use the variable directly.\n   --> /hello_world/src/lib.cairo:2:8\n    |\n  2 |     if is_true() == true {\n    |        -----------------\n    |\n```\n\n----------------------------------------\n\nTITLE: Corrected 'break' Usage in Cairo\nDESCRIPTION: This Cairo code snippet shows the corrected version where the unnecessary parentheses have been removed from the 'break' statement, changing 'break ();' to 'break;' as suggested by the 'break_unit' lint rule.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/break_unit.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    loop {\n        break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reviewing Cairo-lint Snapshot Tests with Cargo Insta Bash Command\nDESCRIPTION: Provides the command to interactively review and approve or reject changes detected by the `insta` snapshot testing library. This command is typically run after `cargo test` indicates that snapshots have changed.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ncargo insta review\n```\n\n----------------------------------------\n\nTITLE: Detecting and Replacing pop_front Loops in Cairo\nDESCRIPTION: This snippet captures a Cairo lint rule that identifies loops using pop_front to iterate over a span. It compares the pattern with an equivalent 'for' loop to promote more idiomatic code. Dependencies include the Cairo source code and span data structures. The check inspects loop bodies for match statements on pop_front, then suggests replacing the pattern with a for-in loop. Inputs include the source code snippet; output is a suggested rewrite to improve code clarity and style.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/loop_match_pop_front.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n# loop_match_pop_front\n\nDefault: **Enabled**\n\n[Source Code](https://github.com/software-mansion/cairo-lint/tree/main/src/lints/loops/loop_match_pop_front.rs#L52)\n\n## What it does\n\nChecks for loops that are used to iterate over a span using `pop_front`.\n\n## Example\n\n```cairo\nlet a: Span<u32> = array![1, 2, 3].span();\nloop {\n    match a.pop_front() {\n        Option::Some(val) => {do_smth(val); },\n        Option::None => { break; }\n    }\n}\n```\n\nWhich can be rewritten as\n\n```cairo\nlet a: Span<u32> = array![1, 2, 3].span();\nfor val in a {\n    do_smth(val);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running Cairo-lint Tests with Custom Corelib Path Bash Command\nDESCRIPTION: Shows how to override the default core library path used by tests by setting the `CORELIB_PATH` environment variable. This allows contributors to test against a specific version or local build of the corelib instead of the one resolved by `scarb`.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nCORELIB_PATH=\"/path/to/corelib/src\" cargo test\n```\n\n----------------------------------------\n\nTITLE: Analyzing Unnecessary Subtraction in Integer >= Comparison Lint in Rust\nDESCRIPTION: This Rust code snippet implements a lint rule that detects redundant subtraction operations in integer comparison expressions within Cairo code. The lint identifies cases like 'x - 1 >= y' that can be simplified to 'x > y'. It depends on the Cairo source code and AST analysis libraries to parse and analyze source files, providing suggestions for code improvement.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/int_ge_min_one.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n# int_ge_min_one\n\nDefault: **Enabled**\n\n[Source Code](https://github.com/software-mansion/cairo-lint/tree/main/src/lints/int_op_one.rs#L86)\n\n## What it does\n\nCheck for unnecessary sub operation in integer >= comparison.\n\n## Example\n\n```cairo\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x - 1 >= y {}\n}\n```\n\nCan be simplified to:\n\n```cairo\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x > y {}\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Detecting Redundant Bitwise AND Operations in Cairo\nDESCRIPTION: This code implements a lint rule that checks for bitwise 'AND' operations with identical operands in Cairo source code. It is designed to enhance code clarity and efficiency by identifying opportunities for simplification.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/eq_bitwise_op.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n# eq_bitwise_op\n\nDefault: **Enabled**\n\n[Source Code](https://github.com/software-mansion/cairo-lint/tree/main/src/lints/eq_op.rs#L181)\n\n## What it does\n\nChecks for bitwise operation with identical operands.\n\n## Example\n\n```cairo\nfn foo(a: u256) -> u256 {\n    a & a\n}\n```\n\nCould be simplified by replacing the entire expression with the operand:\n\n```cairo\nfn foo(a: u256) -> u256 {\n    a\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Duplicate Underscore Argument Check in Cairo-Lint\nDESCRIPTION: This snippet contains the core implementation of the lint that inspects function arguments for naming conflicts involving underscores. It relies on Cairo-Lint's existing framework for code analysis and utilizes Rust dependencies for static analysis, referencing the source code location for further details.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/duplicate_underscore_args.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn foo(test: u32, _test: u32) {}\n```\n\n----------------------------------------\n\nTITLE: Checking for erased operations in Cairo code\nDESCRIPTION: This snippet implements a rule in a Cairo linter to detect operations that erase values like multiplication by zero or division by zero. It references source code from 'erasing_op.rs' and provides an example of code patterns that are targeted for simplification.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/erasing_op.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[erasing_op]\n\n// Default: **Enabled**\n\n// Reference to the source code implementing this lint rule\n// [Source Code](https://github.com/software-mansion/cairo-lint/tree/main/src/lints/erasing_op.rs#L41)\n\n// Description: This rule checks for operations that result in value erasure, such as multiplication by zero or division by zero.\n// Example includes functions that demonstrate how such expressions are written and how they can be simplified.\n\n// Example usage in Cairo:\n// ```cairo\n// fn main() {\n//     let x = 1;\n//     let _y = 0 * x;\n//     let _z = 0 / x;\n//     let _c = x & 0;\n// }\n// ```\n\n// Simplified version replacing operations with zero:\n// ```cairo\n// fn main() {\n//     let x = 1;\n//     let _y = 0;\n//     let _z = 0;\n//     let _c = 0;\n// }\n// ```\n```\n\n----------------------------------------\n\nTITLE: Linting loop to while simplification in Rust\nDESCRIPTION: This Rust snippet implements a lint rule that scans for 'loop' expressions enclosing an 'if' conditional statement with a 'break', recommending simplification into a 'while' loop to enhance code readability and idiomatic usage. It depends on Rust linting utilities and analysis of control flow constructs. The lint detects the common anti-pattern and outputs suggestions accordingly.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/loop_for_while.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nSource Code at https://github.com/software-mansion/cairo-lint/tree/main/src/lints/loops/loop_for_while.rs#L48\n```\n\n----------------------------------------\n\nTITLE: Analyzing integer less-or-equal comparison with sub operation in Cairo\nDESCRIPTION: This snippet describes the rule 'int_le_min_one', which checks for unnecessary subtraction in <= comparisons within Cairo code. It aims to identify cases where 'y - 1' in an 'x <= y - 1' comparison can be simplified to 'x < y', improving code efficiency and readability. The rule operates by parsing Cairo source code, detecting specific comparison patterns, and suggesting replacements to optimize the code. Dependencies include the cairo-lint source files, with focus on the 'int_op_one.rs' implementation for this rule.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/int_le_min_one.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n# int_le_min_one\n\nDefault: **Enabled**\n\n[Source Code](https://github.com/software-mansion/cairo-lint/tree/main/src/lints/int_op_one.rs#L180)\n\n## What it does\n\nCheck for unnecessary sub operation in integer <= comparison.\n\n## Example\n\n```cairo\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x <= y - 1 {}\n}\n```\n\nCan be simplified to:\n\n```cairo\nfn main() {\n    let x: u32 = 1;\n    let y: u32 = 1;\n    if x < y {}\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting Rust Lint Rule with Cairo Example\nDESCRIPTION: Illustrates the required documentation format for a new Rust Lint rule implementation that follows the `Lint` trait. It shows the structure of the doc comment, including sections for 'What it does' and 'Example', and how to include a placeholder for a Cairo code example within a markdown block.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n/// ## What it does\n///\n/// ## Example\n/// \n/// ```cairo\n/// // example code\n/// ```\nimpl Lint for MyRule {\n  // implementation ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Cairo-lint Documentation with Cargo Xtask Bash Command\nDESCRIPTION: Describes the shell command used to regenerate the documentation website content. This command leverages `cargo xtask` and should be run after adding or modifying lint rules or their documentation to ensure the website reflects the latest changes.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ncargo xtask update-docs\n```\n\n----------------------------------------\n\nTITLE: Running Cairo-lint Tests with Cargo Bash Command\nDESCRIPTION: Explains the standard command to execute the project's test suite. This command uses `cargo test` and relies on `scarb` being available in the system's PATH to correctly resolve the core library used for testing.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Detecting Empty Enum Variant Brackets in Cairo Code - Rust\nDESCRIPTION: This Rust snippet implements a linting rule that scans enum variants written in Cairo language and detects any variants declared with empty brackets, which are considered redundant. It requires the enums to be analyzed at the AST level, focusing on the variant's syntax to determine if brackets are empty. The input is Cairo source code enums, and the output is lint warnings recommending simplification by removing empty parentheses from the variant declaration. This helps in enforcing cleaner code style conventions.\nSOURCE: https://github.com/software-mansion/cairo-lint/blob/main/website/docs/lints/empty_enum_brackets_variant.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n enum MyEnum {\n    Data: u8,\n    Empty: ()       // redundant parentheses\n }\n```\n\nLANGUAGE: cairo\nCODE:\n```\n enum MyEnum {\n    Data(u8),\n    Empty,\n }\n```"
  }
]