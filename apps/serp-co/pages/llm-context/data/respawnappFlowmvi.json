[
  {
    "owner": "respawn-app",
    "repo": "flowmvi",
    "content": "TITLE: Configuring FlowMVI Store in Kotlin\nDESCRIPTION: This snippet demonstrates advanced configuration of a FlowMVI store, including dependency injection, side-effect strategies, debugging options, and various features like undo/redo, job management, and state serialization.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nclass CounterContainer(\n    private val repo: CounterRepository, // inject dependencies\n) {\n    val store = store<CounterState, CounterIntent, CounterAction>(initial = Loading) {\n\n        configure {\n            // use various side-effect strategies\n            actionShareBehavior = Distribute()\n\n            // checks and verifies your business logic for you\n            debuggable = true\n\n            // make the store fully async, parallel and thread-safe\n            parallelIntents = true\n            coroutineContext = Dispatchers.Default\n            stateStrategy = Atomic()\n        }\n\n        // out of the box logging\n        enableLogging()\n\n        // debug using the IDE plugin\n        enableRemoteDebugging()\n\n        // undo / redo any operation\n        val undoRedo = undoRedo()\n\n        // manage long-running jobs\n        val jobManager = manageJobs<CounterJob>()\n\n        // save and restore the state automatically\n        serializeState(\n            path = repo.cacheFile(\"counter\"),\n            serializer = DisplayingCounter.serializer(),\n        )\n\n        // perform long-running tasks on startup\n        init {\n            repo.startTimer()\n        }\n\n        // save resources when there are no subscribers\n        whileSubscribed {\n            repo.timer.collect {\n                updateState<DisplayingCounter, _> {\n                    copy(timer = timer)\n                }\n            }\n        }\n\n        // lazily evaluate and cache values, even when the method is suspending.\n        val pagingData by cache {\n            repo.getPagedDataSuspending()\n        }\n\n        // testable reducer as a function\n        reduce { intent: CounterIntent ->\n            when (intent) {\n                // typed state update prevents races and allows using sealed class hierarchies for LCE\n                is ClickedCounter -> updateState<DisplayingCounter, _> {\n                    copy(counter = counter + 1)\n                }\n            }\n        }\n\n        // cleanup resources\n        deinit {\n            repo.stopTimer()\n        }\n\n        // and 30+ more options to choose from...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MVI Contract Components in Kotlin\nDESCRIPTION: Demonstrates the structure of MVI contract including states, intents, and actions. States represent UI states like Loading and DisplayingCounter, intents handle user actions, and actions manage side effects.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\n// States\nsealed interface CounterState : MVIState {\n    data object Loading : CounterState\n    data class Error(val e: Exception) : CounterState\n    data class DisplayingCounter(val counter: Int) : CounterState\n}\n\n// MVI Style Intents\nsealed interface CounterIntent : MVIIntent {\n\n    data object ClickedNext : CounterIntent\n\n    data class ChangedCounter(val value: Int) : CounterIntent\n\n    data class GrantedPermission(val granted: Boolean, val permission: String) : CounterIntent\n}\n\n// MVVM+ Style Intents\ntypealias CounterIntent = LambdaIntent<CounterState, CounterAction>\n\n// Side-effects\nsealed interface CounterAction : MVIAction {\n\n    data class ShowMessage(val message: String) : CounterAction\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MVI Contract in FlowMVI\nDESCRIPTION: Example of defining a contract for FlowMVI that includes State, Intent, and Action interfaces. The code shows a state machine with Loading, Error, and Content states, along with an Intent for counter clicks and an Action for showing messages.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nsealed interface State : MVIState {\n\n    data object Loading : State\n    data class Error(val e: Exception) : State\n    data class Content(val counter: Int = 0) : State\n}\n\nsealed interface Intent : MVIIntent {\n    data object ClickedCounter : Intent\n}\n\nsealed interface Action : MVIAction {\n    data class ShowMessage(val message: String) : Action\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Business Logic with FlowMVI Store\nDESCRIPTION: Example of creating a FlowMVI store that implements business logic for a counter app. The code demonstrates error recovery, initialization, handling intents to update state, and triggering side effects through actions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nval counterStore = store(initial = State.Loading, scope = coroutineScope) {\n\n    install(analyticsPlugin) // install plugins you need\n\n    recover { e: Exception -> // recover from errors\n        updateState { State.Error(e) }\n        null\n    }\n    init { // load data\n        updateState {\n            State.Content(counter = repository.loadCounter())\n        }\n    }\n    reduce { intent: Intent -> // respond to events\n        when (intent) {\n            is ClickedCounter -> updateState<State.Content, _> {\n                action(ShowMessage(\"Incremented!\"))\n\n                copy(counter = counter + 1)\n            }\n        }\n    }\n}\n\nstore.intent(ClickedCounter)\n```\n\n----------------------------------------\n\nTITLE: Installing the Reduce Plugin in FlowMVI Store\nDESCRIPTION: Demonstrates how to add the reduce plugin to a FlowMVI store, which handles intent reduction to update state. The example shows a basic counter implementation with state updates.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\noverride val store = store(Loading) {\n    configure { /* ... */ }\n\n    reduce { intent ->\n        when (intent) {\n            is ChangedCounter -> updateState<_, DisplayingCounter> {\n                copy(intent.newValue)\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MVVM+ Style Intent in FlowMVI\nDESCRIPTION: Example of using the functional MVVM+ style in FlowMVI for handling intents with lambda blocks. This approach provides a more concise syntax compared to model-driven intents but requires the 'reduceLambdas' plugin to be installed.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nfun onItemClick(item: Item) = store.intent {\n    updateState {\n        copy(selectedItem = item)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FlowMVI Dependencies with Gradle KTS\nDESCRIPTION: Kotlin DSL configuration for adding FlowMVI dependencies to a project using Gradle KTS. Includes core modules for Kotlin Multiplatform, Compose integration, state preservation, testing, Android support, and debugging capabilities.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\ndependencies {\n    val flowmvi = \"< Badge above üëÜüèª >\"\n    // Core KMP module\n    commonMainImplementation(\"pro.respawn.flowmvi:core:$flowmvi\")\n    // compose multiplatform\n    commonMainImplementation(\"pro.respawn.flowmvi:compose:$flowmvi\")\n    // saving and restoring state\n    commonMainImplementation(\"pro.respawn.flowmvi:savedstate:$flowmvi\")\n    // essenty integration\n    commonMainImplementation(\"pro.respawn.flowmvi:essenty:$flowmvi\")\n    commonMainImplementation(\"pro.respawn.flowmvi:essenty-compose:$flowmvi\")\n    // testing DSL\n    commonTestImplementation(\"pro.respawn.flowmvi:test:$flowmvi\")\n    // android integration\n    androidMainImplementation(\"pro.respawn.flowmvi:android:$flowmvi\")\n    // remote debugging client (use on debug only)\n    debugImplementation(\"pro.respawn.flowmvi:debugger-plugin:$flowmvi\")\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Plugins in FlowMVI Store\nDESCRIPTION: Example showing how to install existing plugins and create custom plugins inline within a store builder. Demonstrates both pre-built plugin installation and on-the-fly plugin creation with custom intent handling.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\noverride val store = store(Loading) {\n\n    // install an existing plugin\n    install(\n        analyticsPlugin(),\n        diScopePlugin(),\n        // ...\n    )\n\n    // or build on-the-fly\n    install {\n        onIntent { intent ->\n            analytics.logUserAction(intent.name)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LCE State Family\nDESCRIPTION: Implementation of Loading-Content-Error (LCE) state pattern using sealed interface to ensure type safety and prevent invalid states.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nsealed interface LCEState : MVIState {\n\n    data object Loading : LCEState\n    data class Error(val e: Exception) : LCEState\n    data class Content(val items: List<Item>) : LCEState\n}\n```\n\n----------------------------------------\n\nTITLE: Full Store Configuration Options in Kotlin\nDESCRIPTION: Comprehensive example showing all available store configuration options including parallelization, overflow handling, and state management strategies.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nconfigure {\n    debuggable = false\n    name = null\n    parallelIntents = false\n    coroutineContext = EmptyCoroutineContext\n    actionShareBehavior = ActionShareBehavior.Distribute()\n    onOverflow = BufferOverflow.DROP_OLDEST\n    intentCapacity = Channel.UNLIMITED\n    stateStrategy = StateStrategy.Atomic(reentrant = true)\n    allowIdleSubscriptions = false\n    logger = if (debuggable) PlatformStoreLogger else NoOpStoreLogger\n    verifyPlugins = debuggable\n}\n```\n\n----------------------------------------\n\nTITLE: FlowMVI State Update DSL\nDESCRIPTION: Demonstration of FlowMVI's DSL functions for type-safe state updates and operations.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\n// capture and update\nupdateState<Content, _> { // this: LCEState.Content\n    copy(items = items + loadMoreItems())\n}\n\n// capture but do not change\nwithState<Error, _> { // this: LCEState.Error\n    action(ShowErrorMessage(exception = this.e))\n}\n```\n\n----------------------------------------\n\nTITLE: Testing FlowMVI Store in Kotlin\nDESCRIPTION: This example demonstrates how to test a FlowMVI store using the provided testing DSL. It shows asserting state changes and action emissions in response to intents.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nstore.subscribeAndTest {\n    // turbine + kotest example\n    ClickedCounter resultsIn {\n        states.test {\n            awaitItem() shouldBe State(counter = 1)\n        }\n        actions.test {\n            awaitItem() shouldBe ShowMessage\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using FlowMVI with Compose Multiplatform in Kotlin\nDESCRIPTION: This example demonstrates how to use FlowMVI with Compose Multiplatform. It shows subscribing to the store, handling actions, and rendering the UI based on the current state.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nfun CounterScreen() {\n    val store = counterStore\n\n    // subscribe to store based on system lifecycle - on any platform\n    val state by store.subscribe { action ->\n        when (action) {\n            is ShowMessage -> /* ... */\n        }\n    }\n\n    when (state) {\n        is DisplayingCounter -> {\n            Button(onClick = { store.intent(ClickedCounter) }) {\n                Text(\"Counter: ${state.counter}\")\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Reduce Plugin in a FlowMVI Store\nDESCRIPTION: Example of how to install and use the Reduce plugin in a FlowMVI store to process incoming intents.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    reduce { intent ->\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting FlowMVI Store with Automatic Scope Management\nDESCRIPTION: Shows how to create and start a FlowMVI store by providing a coroutine scope directly to the store builder. This approach automatically manages the store's lifecycle.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nfun counterStore(scope: CoroutineScope) = store(initial = Loading, scope = scope) { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive State Management with whileSubscribed\nDESCRIPTION: Example of reactive state management using the whileSubscribed plugin to prevent resource leaks by only updating state while subscribers are present. Combines multiple data sources into a single state.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(ProgressiveState()) { // initial value just like stateIn\n\n    whileSubscribed {\n        combine(\n            repo.getFeedFlow(),\n            repo.getRecommendationsFlow(),\n        ) { feed, recommendations ->\n            updateState {\n                copy(\n                    feed = FeedState.Content(feed),\n                    recommended = RecommendationsState.Content(recommendations),\n                )\n            }\n        // don't forget to collect the flow\n        // highlight-next-line\n        }.consume(Dispatchers.Default)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting FlowMVI Store with Manual Lifecycle Control\nDESCRIPTION: Demonstrates manual control of a FlowMVI store's lifecycle by creating a coroutine scope, starting the store, and handling shutdown. Useful when precise control over the store's lifecycle is needed.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nval scope = CoroutineScope()\nval store = counterStore()\n\n// start\nval lifecycle = store.start(scope)\n\n// stop\nscope.cancel()\n\n// or to keep the scope alive\nlifecycle.close()\n```\n\n----------------------------------------\n\nTITLE: Using Undo/Redo Plugin in FlowMVI Store\nDESCRIPTION: Demonstrates how to use the undo/redo plugin in a store. It shows how to observe the queue of events and implement undo/redo operations for user inputs.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_20\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    val undoRedo = undoRedo(queueSize = 10)\n\n    whileSubscribed {\n        undoRedo.queue.onEach { (i, canUndo, canRedo) ->\n            updateState {\n                copy(index = i, canUndo = canUndo, canRedo = canRedo)\n            }\n        }.collect()\n    }\n\n    reduce { intent ->\n        when (intent) {\n            is ClickedRedo -> undoRedo.redo()\n            is ClickedUndo -> undoRedo.undo()\n            is ChangedInput -> undoRedo(\n                redo = { updateState { copy(input = intent.current) } },\n                undo = { updateState { copy(input = intent.previous) } },\n            )\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to FlowMVI Store with Jetpack Compose\nDESCRIPTION: Shows how to integrate a FlowMVI store with Jetpack Compose by creating a composable function that subscribes to state changes and handles actions, using the IDE plugin's 'fmvis' template.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nfun CounterScreen(\n    container: CounterContainer = DI.inject(),\n) = with(container.store) {\n\n        val state by subscribe { action ->\n            when (action) {\n                is ShowMessage -> {\n                    /* ... */\n                }\n            }\n        }\n\n        CounterScreenContent(state)\n    }\n\n@Composable\nprivate fun IntentReceiver<CounterIntent>.CounterScreenContent(state: DisplayingCounterState) {\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MVI Container Class in Kotlin\nDESCRIPTION: Shows how to create a Container class that wraps the Store functionality. Includes type alias for pipeline context and demonstrates store initialization with dependencies.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nprivate typealias Ctx = PipelineContext<CounterState, CounterIntent, CounterAction>\n\nclass CounterContainer(\n    private val repo: CounterRepository,\n) : Container<CounterState, CounterIntent, CounterAction> {\n\n    override val store = store(initial = CounterState.Loading) {\n\n    }\n\n    // custom function\n    private fun Ctx.produceState(timer: Int) = updateState { DisplayingCounter(timer) }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Reduce Plugin in FlowMVI\nDESCRIPTION: The core implementation of the Reduce Plugin in FlowMVI that processes incoming intents. It can be configured to consume intents or let them pass to subsequent plugins.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nfun reducePlugin(\n    consume: Boolean = true,\n    name: String = ReducePluginName,\n    reduce: PipelineContext.(intent: I) -> Unit,\n) = plugin {\n    this.name = name\n\n    onIntent {\n        reduce(it)\n        it.takeUnless { consume }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Job Manager Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the job manager plugin which manages long-running coroutine jobs tied to the store lifecycle. The plugin cancels all jobs when the store stops.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_14\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <K : Any> jobManagerPlugin(\n    manager: JobManager<K>,\n    name: String? = JobManager.Name,\n) = plugin {\n    this.name = name\n\n    onStop { manager.cancelAll() }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Eager FlowMVI Plugin\nDESCRIPTION: Basic example of creating an eager plugin using the plugin builder DSL. Shows the minimal structure required for creating a type-safe plugin with generic state, intent and action types.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval plugin = plugin<ScreenState, ScreenIntent, ScreenAction> {\n    // dsl for intercepting is available\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Plugin Ordering Impact in FlowMVI\nDESCRIPTION: This example shows how the order of plugins affects store behavior by comparing a broken implementation where logging won't capture intents with a working implementation where logging is properly positioned before the reduce plugin.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nval broken = store(Loading) {\n    reduce {\n\n    }\n    // ‚ùå - logging plugin will not log any intents\n    // because they have been consumed by the reduce plugin\n    enableLogging()\n}\n\nval working = store(Loading) {\n    enableLogging()\n\n    reduce {\n        // ‚úÖ - logging plugin will get the intent before reduce() is run, and it does not consume the intent\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Undo/Redo Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the undo/redo plugin which manages a queue of operations that can be undone and repeated. The queue is reset when the store stops or when an exception occurs.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_19\n\nLANGUAGE: kotlin\nCODE:\n```\nfun undoRedoPlugin(\n    undoRedo: UndoRedo,\n    name: String? = null,\n    resetOnException: Boolean = true,\n) = plugin {\n    this.name = name\n\n    onStop { undoRedo.reset() }\n\n    if (resetOnException) onException {\n        it.also { undoRedo.reset() }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Lazy FlowMVI Plugin with Configuration Access\nDESCRIPTION: Example of creating a lazy plugin that has access to store configuration. Shows how to use configuration properties and implement exception handling that resets state to initial value.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nval resetStatePlugin = lazyPlugin<MVIState, MVIIntent, MVIAction> {\n    if (!config.debuggable) config.logger(Warn) { \"Plugin for store '${config.name}' is installed on a release build\" }\n\n    onException {\n        updateState { config.initial }  // reset the state\n        null\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Container Injection with Koin 4.1.x in FlowMVI\nDESCRIPTION: Defines two utility functions for Koin 4.1.x integration with FlowMVI: one to declare a container in a module, and another to inject the container in a composable function. This setup ensures containers survive configuration changes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/di.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\n@FlowMVIDSL\ninline fun <reified T : Container<S, I, A>, S : MVIState, I : MVIIntent, A : MVIAction> Module.container(\n    crossinline definition: Definition<T>,\n) = viewModel(qualifier<T>()) { params ->\n    ContainerViewModel<T, _, _, _>(container = definition(params))\n}\n\n@FlowMVIDSL\n@NonRestartableComposable\n@Composable\ninline fun <reified T : Container<S, I, A>, S : MVIState, I : MVIIntent, A : MVIAction> container(\n    key: String? = null,\n    scope: Scope = currentKoinScope(),\n    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current),\n    extras: CreationExtras = defaultExtras(viewModelStoreOwner),\n    noinline params: ParametersDefinition? = null,\n): T = koinViewModel<ContainerViewModel<T, S, I, A>>(\n    qualifier = qualifier<T>(),\n    parameters = params,\n    key = key,\n    scope = scope,\n    viewModelStoreOwner = viewModelStoreOwner,\n    extras = extras\n).container\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Plugin Decoration in Kotlin\nDESCRIPTION: Demonstrates how to create and apply a decorator to a plugin, showing the basic structure and usage of decorators with intent handling.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/decorators.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nval plugin = plugin<State, Intent, Action> {\n    onIntent {\n        // does stuff\n        it\n    }\n}\n\nval decorator = decorator<State, Intent, Action> {\n    name = \"FilterInvalidDecorator\"\n    onIntent { chain, intent ->\n        if (intent is InvalidIntent) return@onIntent null\n        chain.run { onIntent(intent) } // returns the result of the chain\n    }\n}\n\nval decoratedPlugin = decorator decorates plugin\n```\n\n----------------------------------------\n\nTITLE: Integrating FlowMVI with Android ViewModel in Kotlin\nDESCRIPTION: This snippet shows how to integrate FlowMVI with Android's ViewModel using Koin for dependency injection. It demonstrates setting up a module, creating a ViewModel, and using it in a Fragment.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nval module = module { // Koin example\n    factoryOf(::CounterContainer)\n    viewModel(qualifier<CounterContainer>()) { StoreViewModel(get<CounterContainer>()) }\n}\n\nclass ScreenFragment : Fragment() {\n\n    private val vm by viewModel(qualifier<CounterContainer>())\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        subscribe(vm, ::consume, ::render)\n    }\n\n    private fun render(state: CounterState) {\n        // update your views\n    }\n\n    private fun consume(action: CounterAction) {\n        // handle actions\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RetryDecorator Implementation in Kotlin\nDESCRIPTION: Demonstrates the implementation of a RetryDecorator that provides various retry strategies for failed intent processing.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/decorators.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <S : MVIState, I : MVIIntent, A : MVIAction> retryIntentsDecorator(\n    strategy: RetryStrategy,\n    name: String? = null,\n    selector: (intent: I, e: Exception) -> Boolean = { _, _ -> true },\n): StoreDecorator<S, I, A>\n```\n\n----------------------------------------\n\nTITLE: Preserving In-Memory Values in Reactive State Updates\nDESCRIPTION: Example showing how to preserve in-memory values like user input when updating state from external data sources, using the typed() function to safely access previous state values.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nsealed interface State : MVIState {\n\n    data object Loading : State\n    data class Content(\n        val items: List<Item>,\n        val searchQuery: String = \"\", // in-memory value\n    ) : State\n}\n\nval store = store(State.Loading) {\n\n    whileSubscribed {\n        repo.getItems().collect { items ->\n            updateState {\n                State.Content(\n                    items = items,\n                    // highlight-next-line\n                    searchQuery = typed<Content>()?.searchQuery ?: \"\" // preserve the input\n                )\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging Plugin in FlowMVI Store\nDESCRIPTION: Demonstrates how to enable the logging plugin for a FlowMVI store. This plugin prints store events to the specified logger, with platform-specific implementations.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_10\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    enableLogging()\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Init Plugin in a FlowMVI Store\nDESCRIPTION: Example of how to install and use the Init plugin in a FlowMVI store to execute initialization logic before the store starts.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    init { // this: PipelineContext\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Recover Plugin in FlowMVI\nDESCRIPTION: The implementation of the Recover Plugin that handles exceptions in the store's callbacks, plugins, or jobs. It can optionally swallow the exception by returning null.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nfun recoverPlugin(\n    name: String? = null,\n    recover: PipelineContext.(e: Exception) -> Exception?\n) = plugin {\n    this.name = name\n\n    onException(recover)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Recover Plugin in a FlowMVI Store\nDESCRIPTION: Example of how to install and use the Recover plugin in a FlowMVI store to handle exceptions that occur during store operation.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    recover { e: Exception ->\n\n        null\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing a Custom State Saver Plugin in FlowMVI\nDESCRIPTION: Configures a store with a custom state saver. The saveState plugin is installed with a custom saver, IO dispatcher context, and error handling settings.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/savedstate.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(initial = Loading) { // start with a default loading value as we still need it\n    saveState(\n        saver = CustomSaver(),\n        context = Dispatchers.IO,\n        resetOnException = true, // or false if you're brave\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using the WhileSubscribed Plugin in a FlowMVI Store\nDESCRIPTION: Example of how to install and use the WhileSubscribed plugin in a FlowMVI store to run operations only while the store has active subscribers.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    whileSubscribed { // optionally provide the number of subs\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using FlowMVI Containers with Koin in a Compose Application\nDESCRIPTION: Demonstrates how to use the container utility functions with Koin in a Compose application. Shows both module declaration and container usage in a composable function, including passing parameters.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/di.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval accountModule = module {\n    container { new(::GoogleSignInContainer) }\n    container { new(::SignInContainer) }\n}\n\n@Composable\nfun SignInScreen(\n    email: String,\n    container: SignInContainer = container { parametersOf(email) }, // parameters are passed to the container\n) {\n    // or as a field\n    val googleSignIn: GoogleSignInContainer = container()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deinit Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the deinit plugin which provides a simple DSL for handling store shutdown. Useful for resource cleanup or state management on store stop.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_23\n\nLANGUAGE: kotlin\nCODE:\n```\nfun deinitPlugin(\n    block: ShutdownContext.(e: Exception?) -> Unit\n) = plugin { onStop { block(it) } }\n```\n\n----------------------------------------\n\nTITLE: Using Cache Plugin with External Value in FlowMVI\nDESCRIPTION: Shows how to use the cache plugin with a value defined outside the store builder. The external value should only be accessed within the store lifecycle.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_13\n\nLANGUAGE: kotlin\nCODE:\n```\n// do not access outside the store lifecycle\n// need to specify type parameters - ambiguous\nval value = cached<_, State, Intent, Action> { produceTimer() }\n\nval store = store(Loading) {\n\n    install(cachePlugin(value))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Time Travel Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the time travel plugin which records all intents, actions, state changes, and other events in the store. Useful for debugging and testing.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_21\n\nLANGUAGE: kotlin\nCODE:\n```\nfun timeTravelPlugin(\n    timeTravel: TimeTravel,\n    name: String = TimeTravel.Name,\n) = plugin {\n    this.name = name\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Using Job Manager with External Manager in FlowMVI\nDESCRIPTION: Shows how to use an externally created job manager with a FlowMVI store. This allows for job management across multiple components.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_16\n\nLANGUAGE: kotlin\nCODE:\n```\nval manager = JobManager<Jobs>()\n\nval store = store(Loading) {\n\n    manageJobs(manager)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Non-Reentrant State Transactions\nDESCRIPTION: Example of configuring a FlowMVI store to use non-reentrant state transactions for better performance. This disables the ability to nest state updates but provides significant performance improvements.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(initial = Loading) {\n    configure {\n        stateStrategy = Atomic(reentrant = false)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Jobs with Job Manager in FlowMVI\nDESCRIPTION: Demonstrates how to register and manage jobs with the job manager. It shows job registration and cancellation based on specific conditions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_17\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n\n    val jobs = manageJobs()\n\n    init {\n        launch {\n            websocket.connect()\n        }.registerOrReplace(Jobs.Connection, jobs)\n    }\n\n    recover { e ->\n        if (e is DeviceOfflineException) jobs.cancel(Connection)\n        e\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Direct ViewModel with FlowMVI in Android\nDESCRIPTION: Example of a ViewModel that directly implements the ImmutableContainer interface. This approach is simpler but less compatible with multiplatform projects.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/android.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nclass CounterViewModel(\n    repo: CounterRepository,\n    handle: SavedStateHandle,\n) : ViewModel(), ImmutableContainer<CounterState, CounterIntent, CounterAction> {\n\n    // the store is lazy here, which is good for performance if you use other properties of the VM.\n    // if you don't want a lazy store, use the regular store() function here\n    override val store by lazyStore(\n        initial = Loading,\n        scope = viewModelScope,\n    ) {\n        configure {\n            debuggable = BuildConfig.DEBUG\n        }\n        enableLogging()\n        parcelizeState(handle)\n\n        /* ... everything else ... */\n        reduceLambdas() // <-- don't forget that lambdas must still be reduced\n    }\n\n    fun onClickCounter() = store.intent {\n        action(ShowCounterIncrementedMessage)\n        updateState<DisplayingCounter, _> {\n            copy(counter = counter + 1)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reset State Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the reset state plugin which resets the store state back to the initial state when the store stops. The timing depends on plugin installation order.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_24\n\nLANGUAGE: kotlin\nCODE:\n```\npublic fun resetStatePlugin() = plugin {\n    this.name = \"ResetStatePlugin\"\n    onStop {\n        updateStateImmediate { config.initial }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using FlowMVI Containers with Kodein in a Compose Application\nDESCRIPTION: Demonstrates how to use the container utility functions with Kodein in a Compose application. Shows both module declaration and container usage in a composable function with parameter passing.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/di.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nval accountModule by DI.Module {\n    container { new(::GoogleSignInContainer) }\n    container { email: String -> new(email, ::SignInContainer) } // added in Kodein 7.26\n}\n\n@Composable\nfun SignInScreen(\n    email: String,\n    container: SignInContainer = container(email),\n) {\n    val googleSignIn: GoogleSignInContainer = container()\n}\n```\n\n----------------------------------------\n\nTITLE: State Type Checking Example\nDESCRIPTION: Example of type checking and casting when working with state types, showing potential complexity without helper functions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nval current = state.value as? Content ?: return\n\n// use the property\nval items = current.items\n```\n\n----------------------------------------\n\nTITLE: Implementing Await Subscribers Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the await subscribers plugin which allows suspending until the store has a specified number of subscribers. It supports timeout and resubscription options.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_18\n\nLANGUAGE: kotlin\nCODE:\n```\nfun awaitSubscribersPlugin(\n    manager: SubscriberManager,\n    minSubs: Int = 1,\n    allowResubscription: Boolean = true,\n    suspendStore: Boolean = true,\n    timeout: Duration = Duration.INFINITE,\n    name: String = SubscriberManager.Name,\n) = plugin {\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Container Injection with Kodein 7.x in FlowMVI\nDESCRIPTION: Defines utility functions for Kodein 7.x integration with FlowMVI, including support for containers with and without parameters. Uses ViewModel infrastructure to ensure containers survive configuration changes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/di.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\ninline fun <reified T : Container<S, I, A>, S : MVIState, I : MVIIntent, A : MVIAction> DI.Builder.container(\n    @BuilderInference crossinline definition: NoArgBindingDI<Any>.() -> T\n) = bind<ContainerViewModel<T, S, I, A>>() with provider { ContainerViewModel(definition()) }\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INDENTATION\")\n@kotlin.internal.LowPriorityInOverloadResolution\ninline fun <\n        reified T : Container<S, I, A>,\n        reified P : Any,\n        S : MVIState,\n        I : MVIIntent,\n        A : MVIAction\n        > DI.Builder.container(\n    @BuilderInference crossinline definition: BindingDI<Any>.(P) -> T\n) = bind<ContainerViewModel<T, S, I, A>>() with factory { params: P -> ContainerViewModel(definition(params)) }\n\n@Composable\n@NonRestartableComposable\ninline fun <reified T : Container<S, I, A>, S : MVIState, I : MVIIntent, A : MVIAction> container(): T {\n    val vm by rememberViewModel<ContainerViewModel<T, S, I, A>>()\n    return vm.container\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INDENTATION\") // put in a separate package to remove the need for this suppress\n@kotlin.internal.LowPriorityInOverloadResolution\n@NonRestartableComposable\n@Composable\ninline fun <reified T : Container<S, I, A>, reified P : Any, S : MVIState, I : MVIIntent, A : MVIAction> container(\n    param: P,\n): T {\n    val vm by rememberViewModel<P, ContainerViewModel<T, S, I, A>>(arg = param)\n    return vm.container\n}\n```\n\n----------------------------------------\n\nTITLE: Nested State Families Implementation\nDESCRIPTION: Example of implementing nested state families for progressive content loading with multiple state types.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nsealed interface FeedState: MVIState {\n    data object Loading: FeedState\n    data class Content(val items: List<Item>): FeedState\n}\n\n// implementing `MVIState` for nested states is not required but beneficial\nsealed interface RecommendationsState: MVIState { /* ... */ }\n\ndata class ProgressiveState(\n    val feed: FeedState = FeedState.Loading,\n    val recommended: RecommendationsState = RecommendationsState.Loading,\n    /* ... */\n): MVIState\n```\n\n----------------------------------------\n\nTITLE: IntentTimeoutDecorator Implementation in Kotlin\nDESCRIPTION: Shows the implementation of an IntentTimeoutDecorator that enforces timeout constraints on intent processing.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/decorators.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <S : MVIState, I : MVIIntent, A : MVIAction> intentTimeoutDecorator(\n    timeout: Duration,\n    name: String? = \"IntentTimeout\",\n    crossinline onTimeout: suspend PipelineContext<S, I, A>.(I) -> I? = { throw StoreTimeoutException(timeout) },\n): PluginDecorator<S, I, A>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reentrant State Transactions in FlowMVI\nDESCRIPTION: Example of nested state updates in reentrant mode, showing how FlowMVI prevents deadlocks by not creating new transactions for nested update blocks.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nupdateState {\n    updateState {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ConflateDecorator Implementation in Kotlin\nDESCRIPTION: Demonstrates the implementation of a ConflateDecorator that prevents duplicate intent processing based on a comparison function.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/decorators.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <S : MVIState, I : MVIIntent, A : MVIAction> conflateIntentsDecorator(\n    name: String? = \"ConflateIntents\",\n    crossinline compare: ((it: I, other: I) -> Boolean) = MVIIntent::equals,\n): PluginDecorator<S, I, A>\n```\n\n----------------------------------------\n\nTITLE: Creating a Serialization Chain with TypedSaver in Kotlin\nDESCRIPTION: Demonstrates how to create a saver chain to store a specific type of state in a compressed JSON file. This example combines TypedSaver, JsonSaver, and CompressedFileSaver for efficient state persistence.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/savedstate.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval saver = TypedSaver<DisplayingCounter, CounterState>(\n    JsonSaver(\n        json = Json,\n        serializer = DisplayingCounter.serializer(),\n        delegate = CompressedFileSaver(path),\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring MVI Store Settings in Kotlin\nDESCRIPTION: Demonstrates basic store configuration with debuggable flag and store naming. Shows how to initialize store with initial state and configure basic settings.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store<CounterState, CounterIntent, CounterAction>(initial = CounterState.Loading) {\n\n    configure {\n        debuggable = BuildFlags.debuggable\n        name = \"CounterStore\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the WhileSubscribed Plugin in FlowMVI\nDESCRIPTION: The implementation of the WhileSubscribed plugin that runs a job when the store has a minimum number of subscribers and cancels it when the subscription count drops below the minimum.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\nfun whileSubscribedPlugin(\n    minSubscriptions: Int = 1,\n    block: suspend PipelineContext.() -> Unit,\n) = plugin {\n    val job = SubscriptionHolder()\n    onSubscribe { current ->\n        when {\n            current < minSubscriptions -> job.cancelAndJoin()\n            job.isActive -> Unit // condition was already satisfied\n            current >= minSubscriptions -> job.start(this) { block() } // new async job\n        }\n    }\n    onUnsubscribe { current ->\n        if (current < minSubscriptions) job.cancelAndJoin()\n    }\n    onStop { job.cancel() }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the SerializeState Plugin for File-Based State Persistence\nDESCRIPTION: Demonstrates how to use the serializeState plugin shortcut for serializing state to a file. This approach uses default settings with a specified file path, serializer, and error recovery strategy.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/savedstate.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nserializeState(\n    path = path, // (1)\n    serializer = DisplayingCounter.serializer(), // (2)\n    recover = NullRecover // (3)\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating FlowMVI with Android Views\nDESCRIPTION: Example of integrating a FlowMVI Container with an Android Fragment, including lifecycle handling, state rendering, and action consumption.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/android.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nclass CounterFragment : Fragment() {\n\n    private val binding by viewBinding<CounterFragmentBinding>()\n    private val store: CounterContainer by container() // see DI guide for implementation\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        subscribe(container, ::consume, ::render)\n\n        with(binding) {\n            tvCounter.setOnClickListener(store::onClickCounter) // let's say we are using MVVM+ style.\n        }\n    }\n\n    private fun render(state: CounterState): Unit = with(binding) {\n        with(state) {\n            tvCounter.text = counter.toString()\n            /* ... update ALL views! ... */\n        }\n    }\n\n    private fun consume(action: CounterAction): Unit = when (action) {\n        is ShowMessage -> Snackbar.make(binding.root, action.message, Snackbar.LENGTH_SHORT).show()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ParcelizeState Plugin for Android SavedStateHandle\nDESCRIPTION: Shows how to use the parcelizeState plugin to store state in Android's SavedStateHandle. This is specifically for Android platform integration, allowing state to persist across process death.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/savedstate.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nparcelizeState<DisplayingCounter, _, _, _>(\n    handle = savedStateHandle,\n    key = \"CounterState\",\n)\n```\n\n----------------------------------------\n\nTITLE: Using Job Manager with Internal Manager in FlowMVI\nDESCRIPTION: Demonstrates how to create and use a job manager within a store. This allows for managing coroutine jobs with an enumeration of job types.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_15\n\nLANGUAGE: kotlin\nCODE:\n```\nenum class Jobs { Connection }\n\nval store = store(Loading) {\n\n    val jobs: JobManager<Jobs> = manageJobs()\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to FlowMVI Store in Compose\nDESCRIPTION: Example of how to subscribe to a FlowMVI store in a Compose component, handling both state changes and actions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nfun CounterScreen(\n    container: CounterContainer,\n) = with(container.store) {\n\n        val state by subscribe { action ->\n            when (action) {\n                is ShowMessage -> {\n                    /* ... */\n                }\n            }\n        }\n\n        CounterScreenContent(state)\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Retained Store Component\nDESCRIPTION: Example of creating a retained store component using Essenty integration. Shows how to implement a feature container and component that retains state across configuration changes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\n// inject dependencies and write your logic as usual\nclass FeatureContainer(\n    private val repo: CounterRepository,\n) {\n\n    val store = store<CounterState, CounterIntent, CounterAction>(Loading) {\n        // ...\n    }\n}\n\nclass CounterComponent(\n    context: ComponentContext,\n    container: () -> FeatureContainer = { inject() },  // inject via DI as a factory or provide manually\n) : ComponentContext by context,\n    Store<CounterState, CounterIntent, CounterAction> by context.retainedStore(factory = container) {\n\n    init {\n        subscribe {\n            actions.collect { action: CounterAction ->\n\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component with Coroutine Scope\nDESCRIPTION: Example of implementing a component with a custom coroutine scope for store management.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nclass CounterComponent(\n    componentContext: ComponentContext,\n) : ComponentContext by componentContext {\n\n    private val scope = coroutineScope()\n\n    val store = store<State, Intent, Action>(Loading, scope) { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Time Travel Plugin in FlowMVI Store\nDESCRIPTION: Demonstrates how to use the time travel plugin in a store. Shows how to access recorded events for verification or debugging purposes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_22\n\nLANGUAGE: kotlin\nCODE:\n```\nval store = store(Loading) {\n    val timeTravel = timeTravel()\n\n    init {\n        assert(timeTravel.starts == 1)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UI Subscription with Lifecycle\nDESCRIPTION: Example of implementing UI subscription with lifecycle management in a Composable function.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nfun CounterScreen(component: CounterComponent) {\n\n    // when overriding Container\n    val state by component.subscribe()\n\n    // when just using a property\n    val state by component.store.subscribe(component)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Retained Store with Custom Scope\nDESCRIPTION: Example of configuring a retained store with custom scope and parameters. Shows how to customize the store initialization and scope management.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nretainedStore(\n    initial = Loading,\n    scope = retainedScope(),\n    key = \"Type of the State class by default\",\n    factory = { /* inject here */ },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Lifecycle Provider\nDESCRIPTION: Example of implementing a custom lifecycle provider using CompositionLocal for store subscription.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nfun CounterScreen(component: CounterComponent) {\n\n    // do this somewhere in your navigation logic\n    ProvideSubscriberLifecycle(component) {\n        val state by component.store.subscribe(DefaultLifecycle)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Init Plugin in FlowMVI\nDESCRIPTION: The implementation of the Init Plugin that executes actions before the Store starts. This runs each time the store starts and can perform setup tasks.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nfun initPlugin(\n    block: suspend PipelineContext.() -> Unit,\n) = plugin {\n\n    onStart(block)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Remote Debugger Installation in Kotlin Multiplatform\nDESCRIPTION: This code demonstrates how to implement the remote debugger installation across different source sets in a Kotlin Multiplatform project. It includes expect and actual implementations for various platforms.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\n// commonMain -> InstallDebugger.kt\nexpect fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.remoteDebugger()\n\n// androidDebug -> InstallDebugger.kt\nactual fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.remoteDebugger(\n) = install(debuggerPlugin())\n\n// androidRelease -> InstallDebugger.kt\nactual fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.remoteDebugger() = Unit\n\n// conditional installation for other platforms:\nactual fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.remoteDebugger() {\n    enableRemoteDebugging()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe Intents with Sealed Interfaces\nDESCRIPTION: Demonstrates how to subclass intents by target state to make it impossible to send an intent for an incorrect state at compile time.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nsealed interface CounterIntent: MVIIntent {\n    sealed interface DisplayingCounterIntent: MVIIntent\n    sealed interface ErrorIntent : MVIIntent\n    sealed interface LoadingIntent : MVIIntent\n}\n\n// then, use\nIntentReceiver<DisplayingCounterIntent>.DisplayingCounterContent()\n```\n\n----------------------------------------\n\nTITLE: Implementing Store Configuration Injection in Kotlin\nDESCRIPTION: This snippet shows how to set up store configuration injection using a factory pattern. It includes interfaces and extension functions for configuring stores with custom settings.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\ninterface ConfigurationFactory {\n\n    operator fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.invoke(name: String)\n}\n\ninline fun <reified S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.configure(\n    configuration: StoreConfiguration,\n    name: String,\n) = with(configuration) {\n    invoke(name = name)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Pure UI Composables with IntentReceiver\nDESCRIPTION: Example of implementing a pure UI Composable function that uses IntentReceiver to handle user interactions and send intents back to the store.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\n@Composable\nprivate fun IntentReceiver<CounterIntent>.CounterScreenContent(state: CounterState) {\n    when (state) {\n        is DisplayingCounter -> {\n            Button(onClick = { intent(ClickedCounter) }) { // intent() available from the receiver parameter\n                Text(\"Counter: ${state.counter}\")\n            }\n        }\n        /* ... */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Configuration Factory in Kotlin\nDESCRIPTION: This code snippet demonstrates the implementation of a default configuration factory for FlowMVI stores. It includes various configuration options and plugin installations.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\ninternal class DefaultConfigurationFactory(\n    analytics: Analytics,\n) : ConfigurationFactory {\n\n    override operator fun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.invoke(\n        name: String,\n    ) {\n        configure {\n            this.name = name\n            debuggable = BuildFlags.debuggable // set up using an expect-actual\n            actionShareBehavior = ActionShareBehavior.Distribute()\n            onOverflow = SUSPEND\n            parallelIntents = true\n            logger = CustomLogger\n        }\n        enableLogging()\n        enableRemoteDebugging()\n\n        install(analyticsPlugin(analytics)) // custom plugins\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Cache Plugin with Internal Value in FlowMVI\nDESCRIPTION: Demonstrates how to use the cache plugin with a value defined inside the store builder. The plugin provides a delegate similar to lazy but tied to the store lifecycle.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_12\n\nLANGUAGE: kotlin\nCODE:\n```\nsuspend fun produceTimer(): Flow<Int>\n\nval store = store(Loading) {\n\n    val timer by cache {\n        produceTimer().stateIn(scope = this, initial = 0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Analytics Plugin for FlowMVI in Kotlin\nDESCRIPTION: This snippet shows how to create a plugin for FlowMVI to handle analytics events. It demonstrates hooking into various lifecycle events like start, intent, exception, subscribe, unsubscribe, and stop.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nfun analyticsPlugin(analytics: Analytics) = plugin<MVIState, MVIIntent, MVIAction> {\n    onStart {\n        analytics.logScreenView(config.name) // name of the screen\n    }\n    onIntent { intent ->\n        analytics.logUserAction(intent.name)\n    }\n    onException { e ->\n        analytics.logError(e)\n    }\n    onSubscribe {\n        analytics.logEngagementStart()\n    }\n    onUnsubscribe {\n        analytics.logEngagementEnd()\n    }\n    onStop {\n        analytics.logScreenLeave()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cache Plugin in FlowMVI\nDESCRIPTION: Shows the implementation of the cache plugin which provides a lifecycle-aware value cache. The plugin initializes values on store start and clears them on store stop.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_11\n\nLANGUAGE: kotlin\nCODE:\n```\nfun <T> cachePlugin(\n    init: suspend PipelineContext.() -> T,\n) = plugin {\n\n    val value = CachedValue<T>(init)\n\n    onStart { value.init() }\n\n    onStop { value.clear() }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing FlowMVI Plugin in Kotlin\nDESCRIPTION: This snippet shows how to test a FlowMVI plugin using the testing DSL. It demonstrates simulating lifecycle events and asserting the plugin's behavior and state changes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_9\n\nLANGUAGE: kotlin\nCODE:\n```\nval timer = Timer()\ntimerPlugin(timer).test(Loading) {\n\n    onStart()\n\n    // time travel keeps track of all plugin operations for you\n    assert(timeTravel.starts == 1)\n    assert(state is DisplayingCounter)\n    assert(timer.isStarted)\n\n    onStop(null)\n\n    assert(!timer.isStarted)\n}\n```\n\n----------------------------------------\n\nTITLE: Using updateStateImmediate for Performance-Critical Updates\nDESCRIPTION: Example of using updateStateImmediate to bypass locks, plugins, and thread safety for text field input handling, providing a solution for Compose TextField jank.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_8\n\nLANGUAGE: kotlin\nCODE:\n```\ndata class State(val input: String = \"\") : MVIState\n\n@Composable\nfun IntentReceiver<Intent>.ScreenContent(state: State) {\n\n    TextField(\n        value = state.input,\n        onValueChange = { intent(ChangedInput(it)) },\n    )\n}\n\nval store = store(State()) {\n    reduce { intent ->\n        when(intent) {\n            is ChangedInput -> updateStateImmediate {\n                copy(input = intent.value)\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Caching Paging Flow in FlowMVI Store\nDESCRIPTION: This snippet shows how to cache a paging flow using the cachePlugin in a FlowMVI store. It addresses issues with recreating and re-caching flows on every subscription when using androidx.paging library.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/FAQ.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nval pagingFlow by cache {\n    repo.getPagingDataFlow().cachedIn(this)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Undelivered Actions in FlowMVI Store (Kotlin)\nDESCRIPTION: A callback for handling actions that were not delivered to subscribers, such as when using certain ActionShareBehaviors or when the store is stopped. It should be fast, non-blocking, and must not throw exceptions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_7\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ShutdownContext<S, I, A>.onUndeliveredAction(action: A): Unit = Unit\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Reducer Plugin in FlowMVI\nDESCRIPTION: This code demonstrates how to create a custom reducer interface and a corresponding plugin for FlowMVI. It allows for more flexible state management while maintaining the simplicity of the library.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/FAQ.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nfun interface Reducer<S : MVIState, I : MVIIntent> {\n\n    operator fun S.invoke(intent: I): S\n}\n\nfun <S : MVIState, I : MVIIntent, A : MVIAction> StoreBuilder<S, I, A>.reduce(\n    reducer: Reducer<S, I>\n) = reducePlugin<S, I, A>(consume = true) {\n    updateState {\n        with(reducer) { invoke(it) }\n    }\n}.install()\n```\n\n----------------------------------------\n\nTITLE: Configuring FlowMVI Dependencies using Gradle Kotlin DSL\nDESCRIPTION: Configuration snippet for adding FlowMVI dependencies using Gradle Kotlin DSL. Demonstrates adding various modules to different source sets including core, compose, savedstate, essenty integration, test, and android-specific modules.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\ndependencies {\n    val flowmvi = \"< Badge above üëÜüèª >\"\n    // Core KMP module\n    commonMainImplementation(\"pro.respawn.flowmvi:core:$flowmvi\")\n    // compose multiplatform\n    commonMainImplementation(\"pro.respawn.flowmvi:compose:$flowmvi\")\n    // saving and restoring state\n    commonMainImplementation(\"pro.respawn.flowmvi:savedstate:$flowmvi\")\n    // essenty integration\n    commonMainImplementation(\"pro.respawn.flowmvi:essenty:$flowmvi\")\n    commonMainImplementation(\"pro.respawn.flowmvi:essenty-compose:$flowmvi\")\n    // testing DSL\n    commonTestImplementation(\"pro.respawn.flowmvi:test:$flowmvi\")\n    // android integration\n    androidMainImplementation(\"pro.respawn.flowmvi:android:$flowmvi\")\n    // remote debugging client\n    androidDebugImplementation(\"pro.respawn.flowmvi:debugger-plugin:$flowmvi\")\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Store Shutdown in FlowMVI (Kotlin)\nDESCRIPTION: A callback invoked when the store is closed, either normally or exceptionally. It receives an optional exception and allows for final state updates, but should be fast and non-blocking.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ShutdownContext<S, I, A>.onStop(e: Exception?): Unit = Unit\n```\n\n----------------------------------------\n\nTITLE: BatchIntentsDecorator Implementation in Kotlin\nDESCRIPTION: Shows the function signature for creating a BatchIntentsDecorator that queues and processes intents in batches based on specified modes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/decorators.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nfun batchIntentsDecorator(\n    mode: BatchingMode,\n    queue: BatchQueue<I> = BatchQueue(),\n    name: String? = \"BatchIntentsDecorator\"\n): PluginDecorator<S, I, A>\n```\n\n----------------------------------------\n\nTITLE: Handling Undelivered Intents in FlowMVI Store (Kotlin)\nDESCRIPTION: A callback for handling intents that were not delivered to the store, such as when the buffer overflows or the store is stopped. It should be fast, non-blocking, and must not throw exceptions.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nfun ShutdownContext<S, I, A>.onUndeliveredIntent(intent: I): Unit = Unit\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic FlowMVI State\nDESCRIPTION: Basic implementation of an immutable state class using Kotlin data class that implements the MVIState interface. Shows a simple counter state with loading indicator.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\ndata class CounterState(\n    val counter: Int = 0,\n    val isLoading: Boolean = false\n) : MVIState\n```\n\n----------------------------------------\n\nTITLE: Understanding Plugin Execution Order and Side Effects in FlowMVI\nDESCRIPTION: This example demonstrates more complex ordering issues in FlowMVI stores, including how serializeState and custom plugins can interfere with expected behavior when not properly ordered.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/prebuilt.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nval broken = store(Loading) {\n\n    serializeState() // ‚ÄºÔ∏è restores state on start\n\n    init {\n        updateState {\n            Loading // ü§¶‚Äç and the state is immediately overwritten\n        }\n    }\n\n    // this happened because serializeState() uses onStart() under the hood, and init does too.\n    // Init is run after serializeState because it was installed later.\n}\n// or\nval broken = store(Loading) {\n\n    install(customUndocumentedPlugin()) // ‚ÄºÔ∏è you don't know what this plugin does\n\n    reduce {\n        // ‚ùå intents are not reduced because the plugin consumed them\n    }\n    init {\n        updateState {\n            // ‚ùå states are not changed because the plugin veto'd the change\n        }\n        action(MyAction) // ‚ùå actions are replaced with something else\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Unsubscription in FlowMVI Store (Kotlin)\nDESCRIPTION: A callback function executed when a subscriber cancels its subscription job. It receives the current subscriber count and is executed after the subscriber has been removed and the count decremented.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\nsuspend fun PipelineContext<S, I, A>.onUnsubscribe(subscriberCount: Int): Unit = Unit\n```\n\n----------------------------------------\n\nTITLE: Configuring FlowMVI Dependencies in Version Catalogs (TOML)\nDESCRIPTION: TOML configuration for adding FlowMVI dependencies to a project using Gradle version catalogs. Includes core modules, testing utilities, Compose integration, Android support, state preservation, debugging tools, and Essenty integration.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/quickstart.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[versions]\nflowmvi = \"< Badge above üëÜüèª >\"\n\n[dependencies]\n# Core KMP module\nflowmvi-core = { module = \"pro.respawn.flowmvi:core\", version.ref = \"flowmvi\" }\n# Test DSL\nflowmvi-test = { module = \"pro.respawn.flowmvi:test\", version.ref = \"flowmvi\" }\n# Compose multiplatform\nflowmvi-compose = { module = \"pro.respawn.flowmvi:compose\", version.ref = \"flowmvi\" }\n# Android (common + view-based)\nflowmvi-android = { module = \"pro.respawn.flowmvi:android\", version.ref = \"flowmvi\" }\n# Multiplatform state preservation\nflowmvi-savedstate = { module = \"pro.respawn.flowmvi:savedstate\", version.ref = \"flowmvi\" }\n# Remote debugging client\nflowmvi-debugger = { module = \"pro.respawn.flowmvi:debugger-plugin\", version.ref = \"flowmvi\" }\n# Essenty (Decompose) integration\nflowmvi-essenty = { module = \"pro.respawn.flowmvi:essenty\", version.ref = \"flowmvi\" }\nflowmvi-essenty-compose = { module = \"pro.respawn.flowmvi:essenty-compose\", version.ref = \"flowmvi\" }\n```\n\n----------------------------------------\n\nTITLE: FlowMVI Plugin Name Installation Examples\nDESCRIPTION: Examples demonstrating plugin naming rules and installation behavior, including scenarios that will throw exceptions and valid installation patterns.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/plugins/custom.md#2025-04-23_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nloggingPlugin(\"foo\")\nanalyticsPlugin(\"foo\") // -> will throw\n\nloggingPlugin(null)\nanalyticsPlugin(null) // -> OK\n\nloggingPlugin(\"plugin1\")\nloggingPlugin(\"plugin1\") // -> will throw\n\nloggingPlugin(\"plugin1\")\nloggingPlugin(\"plugin2\") // -> OK, but same logs will be printed twice\n\nloggingPlugin(null)\nloggingPlugin(null) // -> OK, but same logs will be printed twice\n\nval plugin = loggingPlugin(null)\ninstall(plugin)\ninstall(plugin) // -> will throw\n```\n\n----------------------------------------\n\nTITLE: Configuring Stability Definitions for FlowMVI\nDESCRIPTION: Text file containing stability definitions needed for the Compose compiler to recognize FlowMVI classes as stable.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npro.respawn.flowmvi.api.MVIIntent\npro.respawn.flowmvi.api.MVIState\npro.respawn.flowmvi.api.MVIAction\npro.respawn.flowmvi.api.Store\npro.respawn.flowmvi.api.Container\npro.respawn.flowmvi.api.ImmutableStore\npro.respawn.flowmvi.dsl.LambdaIntent\npro.respawn.flowmvi.api.SubscriberLifecycle\npro.respawn.flowmvi.api.IntentReceiver\n```\n\n----------------------------------------\n\nTITLE: Creating Compose Previews with EmptyReceiver\nDESCRIPTION: Implementation of preview parameters and composable previews for FlowMVI UI components using EmptyReceiver to handle intents in preview mode.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\nprivate class StateProvider : CollectionPreviewParameterProvider<CounterState>(\n    listOf(DisplayingCounter(counter = 1), Loading)\n)\n\n@Composable\n@Preview\nprivate fun CounterScreenPreview(\n    @PreviewParameter(StateProvider::class) state: CounterState,\n) = EmptyReceiver {\n    CounterScreenContent(state)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing FlowMVI Essenty Dependencies\nDESCRIPTION: Dependency declarations for FlowMVI Essenty integration, including retained stores, coroutine scopes, and lifecycle support for store subscription.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/essenty.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Includes retained stores and coroutine scopes\nflowmvi-essenty = { module = \"pro.respawn.flowmvi:essenty\", version.ref = \"flowmvi\" }\n# Includes lifecycle support for store subscription\nflowmvi-essenty-compose = { module = \"pro.respawn.flowmvi:essenty-compose\", version.ref = \"flowmvi\" }\n```\n\n----------------------------------------\n\nTITLE: Race Condition Example\nDESCRIPTION: Demonstration of potential race conditions in state management without proper synchronization.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/statemanagement.md#2025-04-23_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\nval state = MutableStateFlow(State(items = emptyList()))\n\nsuspend fun loadMoreItems() {\n    val lastIndex = state.value.items.lastIndex // (1)\n    val newItems = repository.requestItems(atIndex = lastIndex, amount = 20)\n    state.value = state.value.copy(items = items + newItems) // (2)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Android Debug Manifest for Network Security\nDESCRIPTION: This XML snippet shows how to configure the Android debug manifest to allow cleartext traffic for specific domains, which is necessary for debugging on emulators and local networks.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\">\n\n    <application android:networkSecurityConfig=\"@xml/network_security_config\"\n            tools:node=\"merge\">\n\n    </application>\n\n</manifest>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Gradle Dependencies for FlowMVI Debugger\nDESCRIPTION: This snippet shows how to add the necessary dependencies for the FlowMVI debugger in the build.gradle.kts file. It includes debug and native implementations of the debugger library.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\ndependencies {\n    debugImplementation(libs.flowmvi.debugger) // android Debug (name is incorrect on the kotlin plugin side)\n    nativeMainImplementation(libs.flowmvi.debugger) // other platforms\n    implementation(libs.flowmvi.core)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JVM Target for Kotlin Multiplatform in build.gradle.kts\nDESCRIPTION: This snippet shows how to configure the JVM target to 11 for Kotlin Multiplatform compilation in the build.gradle.kts file. It addresses the 'Cannot inline bytecode' error by setting the proper JVM target.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/FAQ.md#2025-04-23_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nkotlin {\n    androidTarget { // do the same for JVM/desktop target as well\n        compilerOptions {\n            jvmTarget.set(JvmTarget.JVM_11)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding FlowMVI SavedState Dependency in Gradle/Maven\nDESCRIPTION: Adds the FlowMVI savedstate artifact as a dependency to your project. This module provides functionality to save and restore the state of a store.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/state/savedstate.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nflowmvi-savedstate = { module = \"pro.respawn.flowmvi:savedstate\", version.ref = \"flowmvi\" }\n```\n\n----------------------------------------\n\nTITLE: Setting Java Compatibility in Android Gradle File\nDESCRIPTION: This code snippet demonstrates how to set the Java compatibility version to 11 in the Android section of the gradle file. It ensures proper compatibility with the JVM target set in the Kotlin configuration.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/FAQ.md#2025-04-23_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nandroid {\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FlowMVI API Packages in Kotlin\nDESCRIPTION: Declares package names for core FlowMVI components including MVIIntent, MVIState, MVIAction, Store, Container, and ImmutableStore. These form the backbone of the FlowMVI architecture for managing state and actions in a Kotlin application.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/stability_definitions.txt#2025-04-23_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\npro.respawn.flowmvi.api.MVIIntent\npro.respawn.flowmvi.api.MVIState\npro.respawn.flowmvi.api.MVIAction\npro.respawn.flowmvi.api.Store\npro.respawn.flowmvi.api.Container\npro.respawn.flowmvi.api.ImmutableStore\npro.respawn.flowmvi.dsl.LambdaIntent\npro.respawn.flowmvi.api.SubscriberLifecycle\npro.respawn.flowmvi.api.IntentReceiver\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Properties for FlowMVI Build\nDESCRIPTION: Local properties configuration file containing required settings for building the FlowMVI project. Includes Sonatype credentials for publishing, signing configuration, SDK directory path, and release flag.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\n# only required for publishing\nsonatypeUsername=...\nsonatypePassword=...\nsigning.key=...\nsigning.password=...\n# always required\nsdk.dir=...\nrelease=false\n```\n\n----------------------------------------\n\nTITLE: Configuring Android Network Security for Debugging\nDESCRIPTION: This XML configuration allows cleartext traffic for specific domains used in debugging, such as the Android emulator host and local network addresses.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/misc/debugging.md#2025-04-23_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <domain-config cleartextTrafficPermitted=\"true\">\n        <domain includeSubdomains=\"true\">10.0.2.2</domain>\n        <domain includeSubdomains=\"true\">192.168.*</domain>\n    </domain-config>\n</network-security-config>\n```\n\n----------------------------------------\n\nTITLE: Configuring FlowMVI Dependencies using TOML Version Catalogs\nDESCRIPTION: Configuration snippet for adding FlowMVI dependencies using Gradle version catalogs in TOML format. This defines various FlowMVI modules including core, test, compose, android, savedstate, debugger and essenty integration.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[versions]\nflowmvi = \"< Badge above üëÜüèª >\"\n\n[dependencies]\n# Core KMP module\nflowmvi-core = { module = \"pro.respawn.flowmvi:core\", version.ref = \"flowmvi\" }\n# Test DSL\nflowmvi-test = { module = \"pro.respawn.flowmvi:test\", version.ref = \"flowmvi\" }\n# Compose multiplatform\nflowmvi-compose = { module = \"pro.respawn.flowmvi:compose\", version.ref = \"flowmvi\" }\n# Android (common + view-based)\nflowmvi-android = { module = \"pro.respawn.flowmvi:android\", version.ref = \"flowmvi\" }\n# Multiplatform state preservation\nflowmvi-savedstate = { module = \"pro.respawn.flowmvi:savedstate\", version.ref = \"flowmvi\" }\n# Remote debugging client\nflowmvi-debugger-client = { module = \"pro.respawn.flowmvi:debugger-plugin\", version.ref = \"flowmvi\" }\n# Essenty (Decompose) integration\nflowmvi-essenty = { module = \"pro.respawn.flowmvi:essenty\", version.ref = \"flowmvi\" }\nflowmvi-essenty-compose = { module = \"pro.respawn.flowmvi:essenty-compose\", version.ref = \"flowmvi\" }\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access with robots.txt\nDESCRIPTION: This robots.txt file instructs all web crawlers ('User-agent: *') not to crawl the '/javadocs/' directory of the website. This is commonly used to prevent search engines from indexing API documentation or other technical content that doesn't need to be publicly indexed.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/static/robots.txt#2025-04-23_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-agent: *\nDisallow: /javadocs/*\n```\n\n----------------------------------------\n\nTITLE: Configuring Compose Compiler for FlowMVI in Gradle\nDESCRIPTION: Gradle configuration to set up the Compose compiler to use stability definitions for FlowMVI classes.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\ncomposeCompiler {\n    stabilityConfigurationFiles.add(rootProject.layout.projectDirectory.file(\"stability_definitions.txt\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding FlowMVI Dependencies with Toml\nDESCRIPTION: Configuration for adding FlowMVI Compose dependencies to your project using version catalogs in Gradle.\nSOURCE: https://github.com/respawn-app/flowmvi/blob/master/docs/docs/integrations/compose.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[versions]\nflowmvi = \"< Badge above üëÜüèª >\"\n\n[dependencies]\nflowmvi-compose = { module = \"pro.respawn.flowmvi:compose\", version.ref = \"flowmvi\" }\n```"
  }
]