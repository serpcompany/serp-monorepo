[
  {
    "owner": "slackapi",
    "repo": "bolt-python",
    "content": "TITLE: Initializing Bolt App and Handling Messages in Python\nDESCRIPTION: This snippet sets up a Bolt app that listens for 'hello' messages and responds with an interactive message containing a button. It demonstrates how to use blocks to create structured messages.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Listens to incoming messages that contain \"hello\"\n@app.message(\"hello\")\ndef message_hello(message, say):\n    # say() sends a message to the channel where the event was triggered\n    say(\n        blocks=[\n            {\n                \"type\": \"section\",\n                \"text\": {\"type\": \"mrkdwn\", \"text\": f\"Hey there <@{message['user']}>!\"},\n                \"accessory\": {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"Click Me\"},\n                    \"action_id\": \"button_click\"\n                }\n            }\n        ],\n        text=f\"Hey there <@{message['user']}>!\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Slack Bolt Application\nDESCRIPTION: Example of creating a basic Slack Bolt application with logging configuration and server initialization.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\nfrom slack_bolt import App\n\n# export SLACK_SIGNING_SECRET=***\n# export SLACK_BOT_TOKEN=xoxb-***\napp = App()\n\n# Add functionality here\n\nif __name__ == \"__main__\":\n    app.start(3000)  # POST http://localhost:3000/slack/events\n```\n\n----------------------------------------\n\nTITLE: Initializing Bolt Python App with Socket Mode\nDESCRIPTION: Python code to initialize a Bolt app with bot token and socket mode handler, using environment variables for secure token access.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# Initializes your app with your bot token and socket mode handler\napp = App(token=os.environ.get(\"SLACK_BOT_TOKEN\"))\n\n# Start your app\nif __name__ == \"__main__\":\n    SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"]).start()\n```\n\n----------------------------------------\n\nTITLE: Handling Button Click Actions in Bolt for Python\nDESCRIPTION: This snippet demonstrates how to handle a button click action in a Bolt app. It acknowledges the action and sends a message mentioning the user who clicked the button.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@app.action(\"button_click\")\ndef action_button_click(body, ack, say):\n    # Acknowledge the action\n    ack()\n    say(f\"<@{body['user']['id']}> clicked the button\")\n```\n\n----------------------------------------\n\nTITLE: Basic Action Listener in Slack Bolt Python\nDESCRIPTION: Demonstrates how to listen for a specific action_id using the @app.action decorator. Shows the basic pattern of acknowledging the action request using ack().\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/actions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Your listener will be called every time a block element with the action_id \"approve_button\" is triggered\n@app.action(\"approve_button\")\ndef update_message(ack):\n    ack()\n    # Update the message to reflect the action\n```\n\n----------------------------------------\n\nTITLE: Implementing Socket Mode with Bolt for Python\nDESCRIPTION: This code demonstrates how to set up a basic Slack Bolt application using Socket Mode. It initializes the App with a bot token, creates a SocketModeHandler, and starts listening for events. Environment variables for both app-level and bot tokens are required.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/socket-mode.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# 事前に Slack アプリをインストールし 'xoxb-' で始まるトークンを入手\napp = App(token=os.environ[\"SLACK_BOT_TOKEN\"])\n\n# ここでミドルウェアとリスナーの追加を行います\n\nif __name__ == \"__main__\":\n    # export SLACK_APP_TOKEN=xapp-***\n    # export SLACK_BOT_TOKEN=xoxb-***\n    handler = SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"])\n    handler.start()\n```\n\n----------------------------------------\n\nTITLE: Starting Bolt App in Python\nDESCRIPTION: This snippet shows how to start the Bolt app, either using Socket Mode or as an HTTP server. It uses environment variables to configure the app.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Start your app\nif __name__ == \"__main__\":\n    app.start(port=int(os.environ.get(\"PORT\", 3000)))\n```\n\n----------------------------------------\n\nTITLE: Publishing Views to App Home Tab Using Bolt for Python\nDESCRIPTION: This code snippet shows how to listen for the app_home_opened event and publish a customized view to a user's App Home tab. It uses the client.views_publish method to create a home view with welcome text that includes the user's mention and a link to documentation. Error handling is included to catch and log any exceptions during the process.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/app-home.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.event(\"app_home_opened\")\ndef update_home_tab(client, event, logger):\n    try:\n        # Call views.publish with the built-in client\n        client.views_publish(\n            # Use the user ID associated with the event\n            user_id=event[\"user\"],\n            # Home tabs must be enabled in your app configuration\n            view={\n                \"type\": \"home\",\n                \"blocks\": [\n                    {\n                        \"type\": \"section\",\n                        \"text\": {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"*Welcome home, <@\" + event[\"user\"] + \"> :house:*\"\n                        }\n                    },\n                    {\n                        \"type\": \"section\",\n                        \"text\": {\n                          \"type\": \"mrkdwn\",\n                          \"text\": \"Learn how home tabs can be more useful and interactive <https://docs.slack.dev/surfaces/app-home|*in the documentation*>.\"\n                        }\n                    }\n                ]\n            }\n        )\n    except Exception as e:\n        logger.error(f\"Error publishing home tab: {e}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Socket Mode with Bolt for Python\nDESCRIPTION: This code shows how to implement Socket Mode using AsyncApp and AsyncSocketModeHandler for asyncio-based applications. It uses aiohttp by default and requires the application to be fully implemented using the async/await programming model.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/socket-mode.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.app.async_app import AsyncApp\n# デフォルトは aiohttp を使った実装\nfrom slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler\n\napp = AsyncApp(token=os.environ[\"SLACK_BOT_TOKEN\"])\n\n# ここでミドルウェアとリスナーの追加を行います\n\nasync def main():\n    handler = AsyncSocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"])\n    await handler.start_async()\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Initializing Slack Bolt App with Socket Mode in Python\nDESCRIPTION: Sets up a Slack Bolt app using Socket Mode, listens for 'hello' messages, and responds with a button. Requires SLACK_BOT_TOKEN and SLACK_APP_TOKEN environment variables.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# Initializes your app with your bot token and socket mode handler\napp = App(token=os.environ.get(\"SLACK_BOT_TOKEN\"))\n\n# Listens to incoming messages that contain \"hello\"\n# To learn available listener arguments,\n# visit https://tools.slack.dev/bolt-python/api-docs/slack_bolt/kwargs_injection/args.html\n@app.message(\"hello\")\ndef message_hello(message, say):\n    # say() sends a message to the channel where the event was triggered\n    say(f\"Hey there <@{message['user']}>!\")\n\n# Start your app\nif __name__ == \"__main__\":\n    SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"]).start()\n```\n\n----------------------------------------\n\nTITLE: Configuring OAuth Settings in Bolt for Python\nDESCRIPTION: This code demonstrates basic OAuth configuration for a Bolt for Python application. It sets up client credentials, scopes, and file-based installation and state stores to handle the OAuth flow.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.oauth.oauth_settings import OAuthSettings\nfrom slack_sdk.oauth.installation_store import FileInstallationStore\nfrom slack_sdk.oauth.state_store import FileOAuthStateStore\n\noauth_settings = OAuthSettings(\n    client_id=os.environ[\"SLACK_CLIENT_ID\"],\n    client_secret=os.environ[\"SLACK_CLIENT_SECRET\"],\n    scopes=[\"channels:read\", \"groups:read\", \"chat:write\"],\n    installation_store=FileInstallationStore(base_dir=\"./data/installations\"),\n    state_store=FileOAuthStateStore(expiration_seconds=600, base_dir=\"./data/states\")\n)\n\napp = App(\n    signing_secret=os.environ[\"SLACK_SIGNING_SECRET\"],\n    oauth_settings=oauth_settings\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Global Shortcuts and Opening Modals in Slack Bolt for Python\nDESCRIPTION: This snippet demonstrates how to listen for a global shortcut with the callback_id 'open_modal', acknowledge the shortcut request, and open a modal using the views_open method. It includes a basic modal structure with text and context blocks.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/shortcuts.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# The open_modal shortcut listens to a shortcut with the callback_id \"open_modal\"\n@app.shortcut(\"open_modal\")\ndef open_modal(ack, shortcut, client):\n    # Acknowledge the shortcut request\n    ack()\n    # Call the views_open method using the built-in WebClient\n    client.views_open(\n        trigger_id=shortcut[\"trigger_id\"],\n        # A simple view payload for a modal\n        view={\n            \"type\": \"modal\",\n            \"title\": {\"type\": \"plain_text\", \"text\": \"My App\"},\n            \"close\": {\"type\": \"plain_text\", \"text\": \"Close\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"About the simplest modal you could conceive of :smile:\\n\\nMaybe <https://docs.slack.dev/block-kit/#making-things-interactive|*make the modal interactive*> or <https://docs.slack.dev/surfaces/modals|*learn more advanced modal use cases*>.\"\n                    }\n                },\n                {\n                    \"type\": \"context\",\n                    \"elements\": [\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"Psssst this modal was designed using <https://api.slack.com/tools/block-kit-builder|*Block Kit Builder*>\"\n                        }\n                    ]\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Sending Simple Messages with Bolt-Python\nDESCRIPTION: Demonstrates how to listen for specific message content and respond using the say() function. This example listens for 'knock knock' messages and responds with an italicized 'who's there?' message.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/message-sending.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Listens for messages containing \"knock knock\" and responds with an italicized \"who's there?\"\n@app.message(\"knock knock\")\ndef ask_who(message, say):\n    say(\"_Who's there?_\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Slack Bolt App with HTTP in Python\nDESCRIPTION: Sets up a Slack Bolt app using HTTP, listens for 'hello' messages, and responds. Requires SLACK_BOT_TOKEN and SLACK_SIGNING_SECRET environment variables.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\n\n# Initializes your app with your bot token and signing secret\napp = App(\n    token=os.environ.get(\"SLACK_BOT_TOKEN\"),\n    signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\")\n)\n\n# Listens to incoming messages that contain \"hello\"\n# To learn available listener arguments,\n# visit https://tools.slack.dev/bolt-python/api-docs/slack_bolt/kwargs_injection/args.html\n@app.message(\"hello\")\ndef message_hello(message, say):\n    # say() sends a message to the channel where the event was triggered\n    say(f\"Hey there <@{message['user']}>!\")\n\n# Start your app\nif __name__ == \"__main__\":\n    app.start(port=int(os.environ.get(\"PORT\", 3000)))\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Lazy Listeners in Slack Bolt for Python\nDESCRIPTION: This snippet demonstrates how to implement lazy listeners in a Slack Bolt app, allowing time-consuming processes to run beyond the 3-second acknowledgment window. It shows how to separate the acknowledgment function from the long-running process.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/lazy-listeners.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef respond_to_slack_within_3_seconds(body, ack):\n    text = body.get(\"text\")\n    if text is None or len(text) == 0:\n        ack(f\":x: Usage: /start-process (description here)\")\n    else:\n        ack(f\"Accepted! (task: {body['text']})\") \n\nimport time\ndef run_long_process(respond, body):\n    time.sleep(5)  # longer than 3 seconds\n    respond(f\"Completed! (task: {body['text']})\") \n\napp.command(\"/start-process\")(\n    # ack() is still called within 3 seconds\n    ack=respond_to_slack_within_3_seconds,\n    # Lazy function is responsible for processing the event\n    lazy=[run_long_process]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Core AI Assistant Functionality in Slack Bolt Python\nDESCRIPTION: Main implementation of an AI assistant using Bolt's Assistant class, including handlers for thread start, user messages, and typing indicators. Uses thread context management and supports suggested prompts.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nassistant = Assistant()\n\n# This listener is invoked when a human user opened an assistant thread\n@assistant.thread_started\ndef start_assistant_thread(say: Say, set_suggested_prompts: SetSuggestedPrompts):\n    # Send the first reply to the human who started chat with your app's assistant bot\n    say(\":wave: Hi, how can I help you today?\")\n\n    # Setting suggested prompts is optional\n    set_suggested_prompts(\n        prompts=[\n            # If the suggested prompt is long, you can use {\"title\": \"short one to display\", \"message\": \"full prompt\"} instead\n            \"What does SLACK stand for?\",\n            \"When Slack was released?\",\n        ],\n    )\n\n# This listener is invoked when the human user sends a reply in the assistant thread\n@assistant.user_message\ndef respond_in_assistant_thread(\n    payload: dict,\n    logger: logging.Logger,\n    context: BoltContext,\n    set_status: SetStatus,\n    client: WebClient,\n    say: Say,\n):\n    try:\n        # Tell the human user the assistant bot acknowledges the request and is working on it\n        set_status(\"is typing...\")\n\n        # Collect the conversation history with this user\n        replies_in_thread = client.conversations_replies(\n            channel=context.channel_id,\n            ts=context.thread_ts,\n            oldest=context.thread_ts,\n            limit=10,\n        )\n        messages_in_thread: List[Dict[str, str]] = []\n        for message in replies_in_thread[\"messages\"]:\n            role = \"user\" if message.get(\"bot_id\") is None else \"assistant\"\n            messages_in_thread.append({\"role\": role, \"content\": message[\"text\"]})\n\n        # Pass the latest prompt and chat history to the LLM (call_llm is your own code)\n        returned_message = call_llm(messages_in_thread)\n\n        # Post the result in the assistant thread\n        say(text=returned_message)\n\n    except Exception as e:\n        logger.exception(f\"Failed to respond to an inquiry: {e}\")\n        # Don't forget sending a message telling the error\n        # Without this, the status 'is typing...' won't be cleared, therefore the end-user is unable to continue the chat\n        say(f\":warning: Sorry, something went wrong during processing your request (error: {e})\") \n\n# Enable this assistant middleware in your Bolt app\napp.use(assistant)\n```\n\n----------------------------------------\n\nTITLE: Sending Complex Messages with Blocks in Bolt-Python\nDESCRIPTION: Shows how to send messages with Block Kit components using the say() function. This example listens for calendar emoji reactions and responds with a message containing a date picker block.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/message-sending.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Sends a section block with datepicker when someone reacts with a 📅 emoji\n@app.event(\"reaction_added\")\ndef show_datepicker(event, say):\n    reaction = event[\"reaction\"]\n    if reaction == \"calendar\":\n        blocks = [{\n          \"type\": \"section\",\n          \"text\": {\"type\": \"mrkdwn\", \"text\": \"Pick a date for me to remind you\"},\n          \"accessory\": {\n              \"type\": \"datepicker\",\n              \"action_id\": \"datepicker_remind\",\n              \"initial_date\": \"2020-05-04\",\n              \"placeholder\": {\"type\": \"plain_text\", \"text\": \"Select a date\"}\n          }\n        }]\n        say(\n            blocks=blocks,\n            text=\"Pick a date for me to remind you\"\n        )\n```\n\n----------------------------------------\n\nTITLE: Basic Message Listening with String Pattern in Slack Bolt Python\nDESCRIPTION: This snippet demonstrates how to listen for messages containing a specific emoji (👋) and respond to the user. It uses the app.message() decorator with a string pattern and accesses the message user ID to create a personalized response.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/message-listening.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# This will match any message that contains 👋\n@app.message(\":wave:\")\ndef say_hello(message, say):\n    user = message['user']\n    say(f\"Hi there, <@{user}>!\")\n```\n\n----------------------------------------\n\nTITLE: Sending Interactive Messages with Buttons in Slack Bolt Python App\nDESCRIPTION: Extends the Slack Bolt app to send an interactive message with a button when receiving a 'hello' message. Uses Socket Mode for communication.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# Initializes your app with your bot token and socket mode handler\napp = App(\n    token=os.environ.get(\"SLACK_BOT_TOKEN\"),\n    # signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\") # not required for socket mode\n)\n\n# Listens to incoming messages that contain \"hello\"\n@app.message(\"hello\")\ndef message_hello(message, say):\n    # say() sends a message to the channel where the event was triggered\n    say(\n        blocks=[\n            {\n                \"type\": \"section\",\n                \"text\": {\"type\": \"mrkdwn\", \"text\": f\"Hey there <@{message['user']}>!\"},\n                \"accessory\": {\n                    \"type\": \"button\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"Click Me\"},\n                    \"action_id\": \"button_click\"\n                }\n            }\n        ],\n        text=f\"Hey there <@{message['user']}>!\"\n    )\n\n# Start your app\nif __name__ == \"__main__\":\n    SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"]).start()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Authorization for Slack Bolt App in Python\nDESCRIPTION: This code snippet demonstrates how to implement a custom authorize function for a Slack Bolt app. It includes an example of storing installation data, defining an authorize function that retrieves the appropriate credentials, and initializing the App with the custom authorize function.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/authorization.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\n# Import the AuthorizeResult class\nfrom slack_bolt.authorization import AuthorizeResult\n\n# This is just an example (assumes there are no user tokens)\n# You should store authorizations in a secure DB\ninstallations = [\n    {\n      \"enterprise_id\": \"E1234A12AB\",\n      \"team_id\": \"T12345\",\n      \"bot_token\": \"xoxb-123abc\",\n      \"bot_id\": \"B1251\",\n      \"bot_user_id\": \"U12385\"\n    },\n    {\n      \"team_id\": \"T77712\",\n      \"bot_token\": \"xoxb-102anc\",\n      \"bot_id\": \"B5910\",\n      \"bot_user_id\": \"U1239\",\n      \"enterprise_id\": \"E1234A12AB\"\n    }\n]\n\ndef authorize(enterprise_id, team_id, logger):\n    # You can implement your own logic to fetch token here\n    for team in installations:\n        # enterprise_id doesn't exist for some teams\n        is_valid_enterprise = \"enterprise_id\" not in team or enterprise_id == team[\"enterprise_id\"]\n        if is_valid_enterprise and team[\"team_id\"] == team_id:\n          # Return an instance of AuthorizeResult\n          # If you don't store bot_id and bot_user_id, could also call `from_auth_test_response` with your bot_token to automatically fetch them\n          return AuthorizeResult(\n              enterprise_id=enterprise_id,\n              team_id=team_id,\n              bot_token=team[\"bot_token\"],\n              bot_id=team[\"bot_id\"],\n              bot_user_id=team[\"bot_user_id\"]\n          )\n\n    logger.error(\"No authorization information was found\")\n\napp = App(\n    signing_secret=os.environ[\"SLACK_SIGNING_SECRET\"],\n    authorize=authorize\n)\n```\n\n----------------------------------------\n\nTITLE: Opening a Modal with Blocks in Slack using Bolt for Python\nDESCRIPTION: This code listens for a shortcut trigger and opens a modal with text sections and input fields. It includes acknowledging the request, using the trigger_id from the payload, and defining the modal's structure with blocks, including a button and a multiline text input field.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/opening-modals.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ショートカットの呼び出しをリッスン\n@app.shortcut(\"open_modal\")\ndef open_modal(ack, body, client):\n    # コマンドのリクエストを確認\n    ack()\n    # 組み込みのクライアントで views_open を呼び出し\n    client.views_open(\n        # 受け取りから 3 秒以内に有効な trigger_id を渡す\n        trigger_id=body[\"trigger_id\"],\n        # ビューのペイロード\n        view={\n            \"type\": \"modal\",\n            # ビューの識別子\n            \"callback_id\": \"view_1\",\n            \"title\": {\"type\": \"plain_text\", \"text\":\"My App\"},\n            \"submit\": {\"type\": \"plain_text\", \"text\":\"Submit\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"mrkdwn\", \"text\":\"Welcome to a modal with _blocks_\"},\n                    \"accessory\": {\n                        \"type\": \"button\",\n                        \"text\": {\"type\": \"plain_text\", \"text\":\"Click me!\"},\n                        \"action_id\": \"button_abc\"\n                    }\n                },\n                {\n                    \"type\": \"input\",\n                    \"block_id\": \"input_c\",\n                    \"label\": {\"type\": \"plain_text\", \"text\":\"What are your hopes and dreams?\"},\n                    \"element\": {\n                        \"type\": \"plain_text_input\",\n                        \"action_id\": \"dreamy_input\",\n                        \"multiline\":True\n                    }\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Socket Mode with Bolt for Python\nDESCRIPTION: Basic example of setting up a Slack app using Socket Mode with the SocketModeHandler. Requires SLACK_APP_TOKEN and SLACK_BOT_TOKEN as environment variables.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/socket-mode.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# Install the Slack app and get xoxb- token in advance\napp = App(token=os.environ[\"SLACK_BOT_TOKEN\"])\n\n# Add middleware / listeners here\n\nif __name__ == \"__main__\":\n    # export SLACK_APP_TOKEN=xapp-***\n    # export SLACK_BOT_TOKEN=xoxb-***\n    handler = SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"])\n    handler.start()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Step with User Interaction in Python\nDESCRIPTION: This example shows how to create a custom step that posts a message with a button and handles the button click event. It demonstrates function-scoped interactivity events and delayed completion of the custom step.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/custom-steps.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# This sample custom step posts a message with a button\n@app.function(\"custom_step_button\")\ndef sample_step_callback(inputs, say, fail):\n    try:\n        say(\n            channel=inputs[\"user_id\"],  # sending a DM to this user\n            text=\"Click the button to signal the step completion\",\n            blocks=[\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"mrkdwn\", \"text\": \"Click the button to signal step completion\"},\n                    \"accessory\": {\n                        \"type\": \"button\",\n                        \"text\": {\"type\": \"plain_text\", \"text\": \"Complete step\"},\n                        \"action_id\": \"sample_click\",\n                    },\n                }\n            ],\n        )\n    except Exception as e:\n        fail(f\"Failed to handle a function request (error: {e})\")\n\n# Your listener will be called every time a block element with the action_id \"sample_click\" is triggered\n@app.action(\"sample_click\")\ndef handle_sample_click(ack, body, context, client, complete, fail):\n    ack()\n    try:\n        # Since the button no longer works, we should remove it\n        client.chat_update(\n            channel=context.channel_id,\n            ts=body[\"message\"][\"ts\"],\n            text=\"Congrats! You clicked the button\",\n        )\n\n        # Signal that the custom step completed successfully\n        complete({\"user_id\": context.actor_user_id})\n    except Exception as e:\n        fail(f\"Failed to handle a function request (error: {e})\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Global Error Handler in Slack Bolt Python\nDESCRIPTION: This code demonstrates how to implement a custom global error handler using the app.error decorator. The handler function logs the error details and request body, providing better visibility when errors occur in a Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/errors.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.error\ndef custom_error_handler(error, body, logger):\n    logger.exception(f\"Error: {error}\")\n    logger.info(f\"Request body: {body}\")\n```\n\n----------------------------------------\n\nTITLE: Using Regular Expressions for Message Patterns in Bolt for Python\nDESCRIPTION: This code shows how to use regular expressions to match more complex message patterns in Slack. It listens for messages containing 'hi', 'hello', or 'hey' and responds with a greeting. The matched pattern is available in the context object.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/message-listening.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport re\n\n@app.message(re.compile(\"(hi|hello|hey)\"))\ndef say_hello_regex(say, context):\n    # 正規表現のマッチ結果は context.matches に設定される\n    greeting = context['matches'][0]\n    say(f\"{greeting}, how are you?\")\n```\n\n----------------------------------------\n\nTITLE: Scheduling Slack Messages with WebClient in Python Bolt\nDESCRIPTION: Demonstrates how to use the WebClient to schedule a future message in Slack. The example shows a message listener that schedules a message to be posted at a specific Unix timestamp using chat_scheduleMessage method.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/web-api.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.message(\"wake me up\")\ndef say_hello(client, message):\n    # Unix Epoch time for September 30, 2020 11:59:59 PM\n    when_september_ends = 1601510399\n    channel_id = message[\"channel\"]\n    client.chat_scheduleMessage(\n        channel=channel_id,\n        post_at=when_september_ends,\n        text=\"Summer has come and passed\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Handling Channel Summary Workflow with AI Integration\nDESCRIPTION: Python function that handles a channel summary request from a workflow, retrieves conversation history, and generates a summary using an AI provider. It processes channel messages and returns the summary through the workflow completion handler.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ai.providers import get_provider_response\nfrom logging import Logger\nfrom slack_bolt import Complete, Fail, Ack\nfrom slack_sdk import WebClient\nfrom ..listener_utils.listener_constants import SUMMARIZE_CHANNEL_WORKFLOW\nfrom ..listener_utils.parse_conversation import parse_conversation\n\n\"\"\"\nHandles the event to summarize a Slack channel's conversation history.\nIt retrieves the conversation history, parses it, generates a summary using an AI response,\nand completes the workflow with the summary or fails if an error occurs.\n\"\"\"\n\ndef handle_summary_function_callback(\n    ack: Ack, inputs: dict, fail: Fail, logger: Logger, client: WebClient, complete: Complete\n):\n    ack()\n    try:\n        user_context = inputs[\"user_context\"]\n        channel_id = inputs[\"channel_id\"]\n        history = client.conversations_history(channel=channel_id, limit=10)[\"messages\"]\n        conversation = parse_conversation(history)\n\n        summary = get_provider_response(user_context[\"id\"], SUMMARIZE_CHANNEL_WORKFLOW, conversation)\n\n        complete({\"user_context\": user_context, \"response\": summary})\n    except Exception as e:\n        logger.exception(e)\n        fail(e)\n```\n\n----------------------------------------\n\nTITLE: Implementing Context-Enriching Middleware in Slack Bolt Python\nDESCRIPTION: This code demonstrates the implementation of middleware functions to enrich context with user tasks and format them as Slack blocks. It shows how to fetch data from an external system, process it through multiple middleware functions, and finally use the enriched context in an event listener to publish a view to a user's home tab.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/context.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Listener middleware to fetch tasks from external system using user ID\ndef fetch_tasks(context, event, next):\n    user = event[\"user\"]\n    try:\n        # Assume get_tasks fetchs list of tasks from DB corresponding to user ID\n        user_tasks = db.get_tasks(user)\n        tasks = user_tasks\n    except Exception:\n        # get_tasks() raises exception because no tasks are found\n        tasks = []\n    finally:\n        # Put user's tasks in context\n        context[\"tasks\"] = tasks\n        next()\n\n# Listener middleware to create a list of section blocks\ndef create_sections(context, next):\n    task_blocks = []\n    # Loops through tasks added to context in previous middleware\n    for task in context[\"tasks\"]:\n        task_blocks.append(\n            {\n              \"type\": \"section\",\n              \"text\": {\n                  \"type\": \"mrkdwn\",\n                  \"text\": f\"*{task['title']}*\\n{task['body']}\"\n              },\n              \"accessory\": {\n                  \"type\": \"button\",\n                  \"text\": {\n                    \"type\": \"plain_text\",\n                    \"text\": \"See task\"\n                  },\n                  \"url\": task[\"url\"],\n                }\n            }\n        )\n    # Put list of blocks in context\n    context[\"blocks\"] = task_blocks\n    next()\n\n# Listen for user opening app home\n# Include fetch_tasks middleware\n@app.event(\n  event = \"app_home_opened\",\n  middleware = [fetch_tasks, create_sections]\n)\ndef show_tasks(event, client, context):\n    # Publish view to user's home tab\n    client.views_publish(\n        user_id=event[\"user\"],\n        view={\n            \"type\": \"home\",\n            \"blocks\": context[\"blocks\"]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Regular Expression Pattern Matching for Messages in Slack Bolt Python\nDESCRIPTION: This snippet shows how to use regular expressions for more advanced message pattern matching. It listens for any message containing common greetings (hi, hello, or hey) and responds accordingly, using the context object to access the matched text.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/message-listening.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport re\n\n@app.message(re.compile(\"(hi|hello|hey)\"))\ndef say_hello_regex(say, context):\n    # regular expression matches are inside of context.matches\n    greeting = context['matches'][0]\n    say(f\"{greeting}, how are you?\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Echo Command Handler in Bolt Python for Slack\nDESCRIPTION: This code snippet demonstrates how to create a handler for the '/echo' slash command using Bolt Python. It acknowledges the command and responds by echoing the text provided in the command.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/commands.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# The echo command simply echoes on command\n@app.command(\"/echo\")\ndef repeat_text(ack, respond, command):\n    # Acknowledge command request\n    ack()\n    respond(f\"{command['text']}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Flask Adapter for Bolt Python App\nDESCRIPTION: This snippet demonstrates how to create a Bolt app, initialize a Flask app, and use the SlackRequestHandler to integrate Bolt with Flask. It includes setting up a Slack command and handling incoming Slack events.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/adapters.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt import App\napp = App(\n    signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\"),\n    token=os.environ.get(\"SLACK_BOT_TOKEN\")\n)\n\n# There is nothing specific to Flask here!\n# App is completely framework/runtime agnostic\n@app.command(\"/hello-bolt\")\ndef hello(body, ack):\n    ack(f\"Hi <@{body['user_id']}>!\")\n\n# Initialize Flask app\nfrom flask import Flask, request\nflask_app = Flask(__name__)\n\n# SlackRequestHandler translates WSGI requests to Bolt's interface\n# and builds WSGI response from Bolt's response.\nfrom slack_bolt.adapter.flask import SlackRequestHandler\nhandler = SlackRequestHandler(app)\n\n# Register routes to Flask app\n@flask_app.route(\"/slack/events\", methods=[\"POST\"])\ndef slack_events():\n    # handler runs App's dispatch method\n    return handler.handle(request)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Custom Step in Python\nDESCRIPTION: This snippet demonstrates how to create a basic custom step that formats an input message. It uses the @app.function decorator to define the step callback, handles inputs, and uses the complete() function to provide outputs.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/custom-steps.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# This sample custom step formats an input and outputs it\n@app.function(\"sample_custom_step\")\ndef sample_step_callback(inputs: dict, fail: Fail, complete: Complete):\n    try:\n        message = inputs[\"message\"]\n        complete(\n            outputs={\n                \"message\": f\":wave: You submitted the following message: \\n\\n>{message}\"\n            }\n        )\n    except Exception as e:\n        fail(f\"Failed to handle a custom step request (error: {e})\")\n        raise e\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Custom Step Handler in Python\nDESCRIPTION: Example of a basic custom step implementation that formats an input message. Uses the @app.function decorator to handle the step callback, with complete() and fail() handlers for success and error cases.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-steps.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# This sample custom step formats an input and outputs it\n@app.function(\"sample_custom_step\")\ndef sample_step_callback(inputs: dict, fail: Fail, complete: Complete):\n    try:\n        message = inputs[\"message\"]\n        complete(\n            outputs={\n                \"message\": f\":wave: You submitted the following message: \\n\\n>{message}\"\n            }\n        )\n    except Exception as e:\n        fail(f\"Failed to handle a custom step request (error: {e})\")\n        raise e\n```\n\n----------------------------------------\n\nTITLE: Handling Team Join Event in Slack with Python Bolt\nDESCRIPTION: This snippet demonstrates how to use the `@app.event()` decorator to listen for the 'team_join' event and send a welcome message to a new user in a predefined channel.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/event-listening.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# When a user joins the workspace, send a message in a predefined channel asking them to introduce themselves\n@app.event(\"team_join\")\ndef ask_for_introduction(event, say):\n    welcome_channel_id = \"C12345\"\n    user_id = event[\"user\"]\n    text = f\"Welcome to the team, <@{user_id}>! 🎉 You can introduce yourself in this channel.\"\n    say(text=text, channel=welcome_channel_id)\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Socket Mode with Bolt for Python\nDESCRIPTION: Example of using AsyncSocketModeHandler with AsyncApp for asyncio-based Socket Mode connections. This implementation uses the default aiohttp-based adapter and requires async/await programming model.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/socket-mode.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.app.async_app import AsyncApp\n# The default is the aiohttp based implementation\nfrom slack_bolt.adapter.socket_mode.async_handler import AsyncSocketModeHandler\n\napp = AsyncApp(token=os.environ[\"SLACK_BOT_TOKEN\"])\n\n# Add middleware / listeners here\n\nasync def main():\n    handler = AsyncSocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"])\n    await handler.start_async()\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Initializing WorkflowStep and Registering with Bolt App in Python\nDESCRIPTION: This snippet demonstrates how to create a WorkflowStep instance and register it with a Bolt app. It includes placeholders for edit, save, and execute callbacks.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/steps-from-apps.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.workflows.step import WorkflowStep\n\n# Initiate the Bolt app as you normally would\napp = App(\n    token=os.environ.get(\"SLACK_BOT_TOKEN\"),\n    signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\")\n)\n\ndef edit(ack, step, configure):\n    pass\n\ndef save(ack, view, update):\n    pass\n\ndef execute(step, complete, fail):\n    pass\n\n# Create a new WorkflowStep instance\nws = WorkflowStep(\n    callback_id=\"add_task\",\n    edit=edit,\n    save=save,\n    execute=execute,\n)\n\n# Pass Step to set up listeners\napp.step(ws)\n```\n\n----------------------------------------\n\nTITLE: Listening for Actions with Constrained Objects in Python\nDESCRIPTION: This example shows how to use constrained objects to listen for actions with specific block_id and action_id combinations. It also demonstrates adding a reaction to the message that triggered the action.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/actions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# この関数は、block_id が 'assign_ticket' に一致し\n# かつ action_id が 'select_user' に一致する場合にのみ呼び出される\n@app.action({\n    \"block_id\": \"assign_ticket\",\n    \"action_id\": \"select_user\"\n})\ndef update_message(ack, body, client):\n    ack()\n\n    if \"container\" in body and \"message_ts\" in body[\"container\"]:\n        client.reactions_add(\n            name=\"white_check_mark\",\n            channel=body[\"channel\"][\"id\"],\n            timestamp=body[\"container\"][\"message_ts\"],\n        )\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncApp with Event Handling in Python\nDESCRIPTION: Demonstrates basic setup of AsyncApp with async event handling for app mentions. Shows how to handle Slack events asynchronously and make API calls using aiohttp.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/async.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Requirement: install aiohttp\nfrom slack_bolt.async_app import AsyncApp\napp = AsyncApp()\n\n@app.event(\"app_mention\")\nasync def handle_mentions(event, client, say):  # async function\n    api_response = await client.reactions_add(\n        channel=event[\"channel\"],\n        timestamp=event[\"ts\"],\n        name=\"eyes\",\n    )\n    await say(\"What's up?\")\n\nif __name__ == \"__main__\":\n    app.start(3000)\n```\n\n----------------------------------------\n\nTITLE: Action Response Using respond() in Slack Bolt Python\nDESCRIPTION: Shows how to use the respond() method to reply to actions using the response_url functionality, which allows for more customized message responses.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/actions.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Listens to actions triggered with action_id of \"user_select\"\n@app.action(\"user_select\")\ndef select_user(ack, action, respond):\n    ack()\n    respond(f\"You selected <@{action['selected_user']}>\")\n```\n\n----------------------------------------\n\nTITLE: Responding to Actions Using respond() Method in Python\nDESCRIPTION: This example demonstrates how to use the respond() method to reply to an action. It uses the response_url associated with the action to send a message, allowing for more flexible responses including ephemeral messages.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/actions.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# 'user_select' という action_id を持つアクションのトリガーをリッスン\n@app.action(\"user_select\")\ndef select_user(ack, action, respond):\n    ack()\n    respond(f\"You selected <@{action['selected_user']}>\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Bolt Python Logging with Event Handler\nDESCRIPTION: Demonstrates how to set up logging in a Bolt Python application, including global logging configuration and message-specific logging within an app mention event handler. Shows both basic logging setup and usage of the logger within event listeners.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/logging.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\n# logger in a global context\n# requires importing logging\nlogging.basicConfig(level=logging.DEBUG)\n\n@app.event(\"app_mention\")\ndef handle_mention(body, say, logger):\n    user = body[\"event\"][\"user\"]\n    # single logger call\n    # global logger is passed to listener\n    logger.debug(body)\n    say(f\"{user} mentioned your app\")\n```\n\n----------------------------------------\n\nTITLE: Constrained Action Listener in Slack Bolt Python\nDESCRIPTION: Shows how to use a constraints object to listen for actions with specific block_id and action_id combinations. Includes reaction handling using the Slack client.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/actions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Your function will only be called when the action_id matches 'select_user' AND the block_id matches 'assign_ticket'\n@app.action({\n    \"block_id\": \"assign_ticket\",\n    \"action_id\": \"select_user\"\n})\ndef update_message(ack, body, client):\n    ack()\n\n    if \"container\" in body and \"message_ts\" in body[\"container\"]:\n        client.reactions_add(\n            name=\"white_check_mark\",\n            channel=body[\"channel\"][\"id\"],\n            timestamp=body[\"container\"][\"message_ts\"],\n        )\n```\n\n----------------------------------------\n\nTITLE: Handling View Closures in Slack Bolt for Python\nDESCRIPTION: This snippet shows how to handle view_closed requests. It demonstrates opening a modal view with a notify_on_close property and using the app.view_closed() decorator to handle the closure event.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/view-submissions.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclient.views_open(\n    trigger_id=body.get(\"trigger_id\"),\n    view={\n        \"type\": \"modal\",\n        \"callback_id\": \"modal-id\",  # Used when calling view_closed\n        \"title\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Modal title\"\n        },\n        \"blocks\": [],\n        \"close\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Cancel\"\n        },\n        \"notify_on_close\": True,  # This attribute is required\n    }\n)\n\n# Handle a view_closed request\n@app.view_closed(\"modal-id\")\ndef handle_view_closed(ack, body, logger):\n    ack()\n    logger.info(body)\n```\n\n----------------------------------------\n\nTITLE: Implementing Execute Callback for WorkflowStep in Python\nDESCRIPTION: This code snippet illustrates how to implement the execute callback for a WorkflowStep. It shows how to handle successful execution using complete() and failure scenarios using fail().\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/steps-from-apps.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef execute(step, complete, fail):\n    inputs = step[\"inputs\"]\n    # if everything was successful\n    outputs = {\n        \"task_name\": inputs[\"task_name\"][\"value\"],\n        \"task_description\": inputs[\"task_description\"][\"value\"],\n    }\n    complete(outputs=outputs)\n\n    # if something went wrong\n    error = {\"message\": \"Just testing step failure!\"}\n    fail(error=error)\n\nws = WorkflowStep(\n    callback_id=\"add_task\",\n    edit=edit,\n    save=save,\n    execute=execute,\n)\napp.step(ws)\n```\n\n----------------------------------------\n\nTITLE: Opening a Slack Modal with Bolt for Python\nDESCRIPTION: This code listens for a shortcut invocation and opens a modal dialog in Slack. It uses the client.views_open method to display a modal with a button and text input field. The modal includes a callback_id for identifying view submissions, a title, submit button, and interactive block elements.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/opening-modals.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Listen for a shortcut invocation\n@app.shortcut(\"open_modal\")\ndef open_modal(ack, body, client):\n    # Acknowledge the command request\n    ack()\n    # Call views_open with the built-in client\n    client.views_open(\n        # Pass a valid trigger_id within 3 seconds of receiving it\n        trigger_id=body[\"trigger_id\"],\n        # View payload\n        view={\n            \"type\": \"modal\",\n            # View identifier\n            \"callback_id\": \"view_1\",\n            \"title\": {\"type\": \"plain_text\", \"text\": \"My App\"},\n            \"submit\": {\"type\": \"plain_text\", \"text\": \"Submit\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"mrkdwn\", \"text\": \"Welcome to a modal with _blocks_\"},\n                    \"accessory\": {\n                        \"type\": \"button\",\n                        \"text\": {\"type\": \"plain_text\", \"text\": \"Click me!\"},\n                        \"action_id\": \"button_abc\"\n                    }\n                },\n                {\n                    \"type\": \"input\",\n                    \"block_id\": \"input_c\",\n                    \"label\": {\"type\": \"plain_text\", \"text\": \"What are your hopes and dreams?\"},\n                    \"element\": {\n                        \"type\": \"plain_text_input\",\n                        \"action_id\": \"dreamy_input\",\n                        \"multiline\": True\n                    }\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Listening to Shortcuts with Constraint Objects in Slack Bolt for Python\nDESCRIPTION: This snippet shows how to use a constraints object to listen for shortcuts with specific callback_id and type. It demonstrates opening a modal when the callback_id is 'open_modal' and the type is 'message_action'.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/shortcuts.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Your listener will only be called when the callback_id matches 'open_modal' AND the type matches 'message_action'\n@app.shortcut({\"callback_id\": \"open_modal\", \"type\": \"message_action\"})\ndef open_modal(ack, shortcut, client):\n    # Acknowledge the shortcut request\n    ack()\n    # Call the views_open method using one of the built-in WebClients\n    client.views_open(\n        trigger_id=shortcut[\"trigger_id\"],\n        view={\n            \"type\": \"modal\",\n            \"title\": {\"type\": \"plain_text\", \"text\": \"My App\"},\n            \"close\": {\"type\": \"plain_text\", \"text\": \"Close\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\n                        \"type\": \"mrkdwn\",\n                        \"text\": \"About the simplest modal you could conceive of :smile:\\n\\nMaybe <https://docs.slack.dev/block-kit/#making-things-interactive|*make the modal interactive*> or <https://docs.slack.dev/surfaces/modals|*learn more advanced modal use cases*>.\"\n                    }\n                },\n                {\n                    \"type\": \"context\",\n                    \"elements\": [\n                        {\n                            \"type\": \"mrkdwn\",\n                            \"text\": \"Psssst this modal was designed using <https://api.slack.com/tools/block-kit-builder|*Block Kit Builder*>\"\n                        }\n                    ]\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Edit Callback for WorkflowStep in Python\nDESCRIPTION: This code snippet shows how to implement the edit callback for a WorkflowStep. It demonstrates opening a configuration modal for the step using the configure() utility.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/steps-from-apps.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef edit(ack, step, configure):\n    ack()\n\n    blocks = [\n        {\n            \"type\": \"input\",\n            \"block_id\": \"task_name_input\",\n            \"element\": {\n                \"type\": \"plain_text_input\",\n                \"action_id\": \"name\",\n                \"placeholder\": {\"type\": \"plain_text\", \"text\": \"Add a task name\"},\n            },\n            \"label\": {\"type\": \"plain_text\", \"text\": \"Task name\"},\n        },\n        {\n            \"type\": \"input\",\n            \"block_id\": \"task_description_input\",\n            \"element\": {\n                \"type\": \"plain_text_input\",\n                \"action_id\": \"description\",\n                \"placeholder\": {\"type\": \"plain_text\", \"text\": \"Add a task description\"},\n            },\n            \"label\": {\"type\": \"plain_text\", \"text\": \"Task description\"},\n        },\n    ]\n    configure(blocks=blocks)\n\nws = WorkflowStep(\n    callback_id=\"add_task\",\n    edit=edit,\n    save=save,\n    execute=execute,\n)\napp.step(ws)\n```\n\n----------------------------------------\n\nTITLE: Implementing Listener Middleware and Matchers in Slack Bolt Python\nDESCRIPTION: Demonstrates two approaches to filtering bot messages in Slack Bolt: using traditional listener middleware with next() calls and using simplified listener matchers that return boolean values. The code shows how to attach middleware to event listeners and implement message filtering logic.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/listener-middleware.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Listener middleware which filters out messages with \"bot_message\" subtype\ndef no_bot_messages(message, next):\n    subtype = message.get(\"subtype\")\n    if subtype != \"bot_message\":\n       next()\n\n# This listener only receives messages from humans\n@app.event(event=\"message\", middleware=[no_bot_messages])\ndef log_message(logger, event):\n    logger.info(f\"(MSG) User: {event['user']}\\nMessage: {event['text']}\")\n\n# Listener matchers: simplified version of listener middleware\ndef no_bot_messages(message) -> bool:\n    return message.get(\"subtype\") != \"bot_message\"\n\n@app.event(\n    event=\"message\", \n    matchers=[no_bot_messages]\n    # or matchers=[lambda message: message.get(\"subtype\") != \"bot_message\"]\n)\ndef log_message(logger, event):\n    logger.info(f\"(MSG) User: {event['user']}\\nMessage: {event['text']}\")\n```\n\n----------------------------------------\n\nTITLE: Processing View Submissions in Slack Bolt for Python\nDESCRIPTION: This snippet illustrates how to handle a view_submission request. It demonstrates input validation, acknowledging the request, saving data to a database, and sending a verification message to the user.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/view-submissions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Handle a view_submission request\n@app.view(\"view_1\")\ndef handle_submission(ack, body, client, view, logger):\n    # Assume there's an input block with `input_c` as the block_id and `dreamy_input`\n    hopes_and_dreams = view[\"state\"][\"values\"][\"input_c\"][\"dreamy_input\"]\n    user = body[\"user\"][\"id\"]\n    # Validate the inputs\n    errors = {}\n    if hopes_and_dreams is not None and len(hopes_and_dreams) <= 5:\n        errors[\"input_c\"] = \"The value must be longer than 5 characters\"\n    if len(errors) > 0:\n        ack(response_action=\"errors\", errors=errors)\n        return\n    # Acknowledge the view_submission request and close the modal\n    ack()\n    # Do whatever you want with the input data - here we're saving it to a DB\n    # then sending the user a verification of their submission\n\n    # Message to send user\n    msg = \"\"\n    try:\n        # Save to DB\n        msg = f\"Your submission of {hopes_and_dreams} was successful\"\n    except Exception as e:\n        # Handle error\n        msg = \"There was an error with your submission\"\n\n    # Message the user\n    try:\n        client.chat_postMessage(channel=user, text=msg)\n    except e:\n        logger.exception(f\"Failed to post a message {e}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Block Kit Interactions in AI Assistant Thread\nDESCRIPTION: Implementation of Block Kit button interactions in AI assistant threads, showing how to handle bot messages and add interactive elements like buttons.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\napp = App(\n    token=os.environ[\"SLACK_BOT_TOKEN\"],\n    # This must be set to handle bot message events\n    ignoring_self_assistant_message_events_enabled=False,\n)\n\nassistant = Assistant()\n\n@assistant.thread_started\ndef start_assistant_thread(say: Say):\n    say(\n        text=\":wave: Hi, how can I help you today?\",\n        blocks=[\n            {\n                \"type\": \"section\",\n                \"text\": {\"type\": \"mrkdwn\", \"text\": \":wave: Hi, how can I help you today?\"},\n            },\n            {\n                \"type\": \"actions\",\n                \"elements\": [\n                    # You can have multiple buttons here\n                    {\n                        \"type\": \"button\",\n                        \"action_id\": \"assistant-generate-random-numbers\",\n                        \"text\": {\"type\": \"plain_text\", \"text\": \"Generate random numbers\"},\n                        \"value\": \"clicked\",\n                    },\n                ],\n            },\n        ],\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Sanic Integration with AsyncApp\nDESCRIPTION: Shows how to integrate Slack Bolt's AsyncApp with Sanic web framework, including request handling and event processing. Demonstrates framework-agnostic event handling and server configuration.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/async.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.async_app import AsyncApp\napp = AsyncApp()\n\n# There is nothing specific to Sanic here!\n# AsyncApp is completely framework/runtime agnostic\n@app.event(\"app_mention\")\nasync def handle_app_mentions(say):\n    await say(\"What's up?\")\n\nimport os\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom slack_bolt.adapter.sanic import AsyncSlackRequestHandler\n\n# Create an adapter for Sanic with the App instance\napp_handler = AsyncSlackRequestHandler(app)\n# Create a Sanic app\napi = Sanic(name=\"awesome-slack-app\")\n\n@api.post(\"/slack/events\")\nasync def endpoint(req: Request):\n    # app_handler internally runs the App's dispatch method\n    return await app_handler.handle(req)\n\nif __name__ == \"__main__\":\n    api.run(host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 3000)))\n```\n\n----------------------------------------\n\nTITLE: Creating Jira Issue in Slack Bolt Python Custom Step\nDESCRIPTION: This code snippet shows how to create a Jira issue as part of a custom step in a Slack Bolt Python app. It handles input parameters, makes an API call to Jira, and completes the step with the issue details or fails with an error message.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@app.function(\"create_issue\")\ndef create_issue_callback(ack: Ack, inputs: dict, fail: Fail, complete: Complete, logger: logging.Logger):\n    ack()\n    JIRA_BASE_URL = os.getenv(\"JIRA_BASE_URL\")\n\n    headers = {\n        \"Authorization\": f'Bearer {os.getenv(\"JIRA_SERVICE_TOKEN\")}',\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    try:\n        project: str = inputs[\"project\"]\n        issue_type: str = inputs[\"issuetype\"]\n\n        url = f\"{JIRA_BASE_URL}/rest/api/latest/issue\"\n\n        payload = json.dumps(\n            {\n                \"fields\": {\n                    \"description\": inputs[\"description\"],\n                    \"issuetype\": {\"id\" if issue_type.isdigit() else \"name\": issue_type},\n                    \"project\": {\"id\" if project.isdigit() else \"key\": project},\n                    \"summary\": inputs[\"summary\"],\n                },\n            }\n        )\n\n        response = requests.post(url, data=payload, headers=headers)\n\n        response.raise_for_status()\n        json_data = json.loads(response.text)\n        complete(outputs={\n            \"issue_id\": json_data[\"id\"],\n            \"issue_key\": json_data[\"key\"],\n            \"issue_url\": f'https://{JIRA_BASE_URL}/browse/{json_data[\"key\"]}'\n        })\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a step request (error: {e}\")\n\n```\n\n----------------------------------------\n\nTITLE: Updating Views on Submission in Slack Bolt for Python\nDESCRIPTION: This snippet demonstrates how to update a view in response to a view_submission event. It uses the app.view() decorator to handle the submission and acknowledges with a new view.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/view-submissions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Update the view on submission \n@app.view(\"view_1\")\ndef handle_submission(ack, body):\n    # The build_new_view() method returns a modal view\n    # To build a modal view, we recommend using Block Kit Builder:\n    # https://app.slack.com/block-kit-builder/#%7B%22type%22:%22modal%22,%22callback_id%22:%22view_1%22,%22title%22:%7B%22type%22:%22plain_text%22,%22text%22:%22My%20App%22,%22emoji%22:true%7D,%22blocks%22:%5B%5D%7D\n    ack(response_action=\"update\", view=build_new_view(body))\n```\n\n----------------------------------------\n\nTITLE: Filtering Message Subtypes in Slack Events with Python Bolt\nDESCRIPTION: This code shows how to use the `@app.event()` decorator with a dictionary argument to filter for specific message subtypes, in this case, listening for changed messages and logging the changes.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/event-listening.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Matches all modified messages\n@app.event({\n    \"type\": \"message\",\n    \"subtype\": \"message_changed\"\n})\ndef log_message_change(logger, event):\n    user, text = event[\"user\"], event[\"text\"]\n    logger.info(f\"The user {user} changed the message to {text}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Flask Adapter for Slack Bolt Python\nDESCRIPTION: This code demonstrates how to create a simplified Flask adapter for Slack Bolt Python. It shows the conversion between Flask requests and Bolt requests, handling of responses, and the main handler class that dispatches requests to the Bolt app. This adapter enables seamless integration between a Flask web application and Slack's Bolt framework.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/custom-adapters.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Necessary imports for Flask\nfrom flask import Request, Response, make_response\n\nfrom slack_bolt.app import App\nfrom slack_bolt.request import BoltRequest\nfrom slack_bolt.response import BoltResponse\n\n# This example is a simplified version of the Flask adapter\n# For a more detailed, complete example, look in the adapter folder\n# github.com/slackapi/bolt-python/blob/main/slack_bolt/adapter/flask/handler.py\n\n# Takes in an HTTP request and converts it to a standard BoltRequest\ndef to_bolt_request(req: Request) -> BoltRequest:\n    return BoltRequest(\n        body=req.get_data(as_text=True),\n        query=req.query_string.decode(\"utf-8\"),\n        headers=req.headers,\n    )\n\n# Takes in a BoltResponse and converts it to a standard Flask response\ndef to_flask_response(bolt_resp: BoltResponse) -> Response:\n    resp: Response = make_response(bolt_resp.body, bolt_resp.status)\n    for k, values in bolt_resp.headers.items():\n        for v in values:\n            resp.headers.add_header(k, v)\n    return resp\n\n# Instantiated from your app\n# Accepts a Flask app\nclass SlackRequestHandler:\n    def __init__(self, app: App):\n        self.app = app\n\n    # handle() will be called from your Flask app \n    # when you receive a request from Slack\n    def handle(self, req: Request) -> Response:\n        # This example does not cover OAuth\n        if req.method == \"POST\":\n            # Dispatch the request for Bolt to handle and route\n            bolt_resp: BoltResponse = self.app.dispatch(to_bolt_request(req))\n            return to_flask_response(bolt_resp)\n\n        return make_response(\"Not Found\", 404)\n```\n\n----------------------------------------\n\nTITLE: Handling Interactive Button Click in Slack Bolt Python Custom Step\nDESCRIPTION: This snippet demonstrates how to handle an interactive button click associated with a custom step in a Slack Bolt Python app. It completes the step with the user ID or fails with an error message.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@app.action(\"sample_click\")\ndef handle_sample_click(context: BoltContext, complete: Complete, fail: Fail, logger: logging.Logger):\n    try:\n        # Signal the step has completed once the button is clicked\n        complete({\"user_id\": context.actor_user_id})\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a step request (error: {e}\")\n\n```\n\n----------------------------------------\n\nTITLE: Customizing OAuth Defaults in Bolt for Python\nDESCRIPTION: This code shows how to customize the OAuth flow with custom success and failure handlers, custom paths, and additional settings. It demonstrates defining callback functions that return custom responses for successful and failed OAuth installations.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-17_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.oauth.callback_options import CallbackOptions, SuccessArgs, FailureArgs\nfrom slack_bolt.response import BoltResponse\n\ndef success(args: SuccessArgs) -> BoltResponse:\n    assert args.request is not None\n    return BoltResponse(\n        status=200,  # you can redirect users too\n        body=\"Your own response to end-users here\"\n    )\n\ndef failure(args: FailureArgs) -> BoltResponse:\n    assert args.request is not None\n    assert args.reason is not None\n    return BoltResponse(\n        status=args.suggested_status_code,\n        body=\"Your own response to end-users here\"\n    )\n\ncallback_options = CallbackOptions(success=success, failure=failure)\n\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.oauth.oauth_settings import OAuthSettings\nfrom slack_sdk.oauth.installation_store import FileInstallationStore\nfrom slack_sdk.oauth.state_store import FileOAuthStateStore\n\napp = App(\n    signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\"),\n    installation_store=FileInstallationStore(base_dir=\"./data/installations\"),\n    oauth_settings=OAuthSettings(\n        client_id=os.environ.get(\"SLACK_CLIENT_ID\"),\n        client_secret=os.environ.get(\"SLACK_CLIENT_SECRET\"),\n        scopes=[\"app_mentions:read\", \"channels:history\", \"im:history\", \"chat:write\"],\n        user_scopes=[],\n        redirect_uri=None,\n        install_path=\"/slack/install\",\n        redirect_uri_path=\"/slack/oauth_redirect\",\n        state_store=FileOAuthStateStore(expiration_seconds=600, base_dir=\"./data/states\"),\n        callback_options=callback_options,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Listener for Time Off Request\nDESCRIPTION: Python function that handles the workflow step execution, creating an interactive message with approve/deny buttons.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@app.function(\"request_time_off\")\ndef handle_request_time_off(inputs: dict, fail: Fail, logger: logging.Logger, say: Say):\n\n    submitter_id = inputs[\"submitter_id\"]\n    manager_id = inputs[\"manager_id\"]\n\n    try:\n        say(\n            channel=manager_id,\n            text=f\"<@{submitter_id}> requested time off! What say you?\",\n            blocks=[\n                {\n                    \"type\": 'section',\n                    \"text\": {\n                        \"type\": 'mrkdwn',\n                        \"text\": f\"<@{submitter_id}> requested time off! What say you?\",\n                    },\n                },\n                {\n                    'type': 'actions',\n                    'elements': [\n                        {\n                            'type': 'button',\n                            'text': {\n                                'type': 'plain_text',\n                                'text': 'Approve',\n                                'emoji': True,\n                            },\n                            'value': 'approve',\n                            'action_id': 'approve_button',\n                        },\n                        {\n                            'type': 'button',\n                            'text': {\n                                'type': 'plain_text',\n                                'text': 'Deny',\n                                'emoji': True,\n                            },\n                            'value': 'deny',\n                            'action_id': 'deny_button',\n                        },\n                    ],\n                },\n            ],\n        )\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a function request (error: {e})\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Socket Mode Handler\nDESCRIPTION: Example of implementing Socket Mode functionality in a Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\n\n# Install the Slack app and get xoxb- token in advance\napp = App(token=os.environ[\"SLACK_BOT_TOKEN\"])\n\n# Add functionality here\n\nif __name__ == \"__main__\":\n    # Create an app-level token with connections:write scope\n    handler = SocketModeHandler(app, os.environ[\"SLACK_APP_TOKEN\"])\n    handler.start()\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Listener for Custom Step (Python)\nDESCRIPTION: This code snippet demonstrates how to implement a function listener in Bolt-Python to handle the execution of a custom step. It sends a message to the user with a button to complete the step.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@app.function(\"sample_step\")\ndef handle_sample_step_event(inputs: dict, say: Say, fail: Fail, logger: logging.Logger):\n    user_id = inputs[\"user_id\"]\n\n    try:\n        say(\n            channel=user_id,  # sending a DM to this user\n            text=\"Click the button to signal the step has completed\",\n            blocks=[\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"mrkdwn\", \"text\": \"Click the button to signal the step has completed\"},\n                    \"accessory\": {\n                        \"type\": \"button\",\n                        \"text\": {\"type\": \"plain_text\", \"text\": \"Complete step\"},\n                        \"action_id\": \"sample_click\",\n                    },\n                }\n            ],\n        )\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a step request (error: {e}\")\n```\n\n----------------------------------------\n\nTITLE: Updating Slack Modal View with Button Action Handler\nDESCRIPTION: Example demonstrating how to update a modal view in response to a button click using views_update. The code shows handling a button action with ID 'button_abc', acknowledging the request, and updating the modal with new content including text and an image.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/updating-pushing-views.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Listen for a button invocation with action_id `button_abc` (assume it's inside of a modal)\n@app.action(\"button_abc\")\ndef update_modal(ack, body, client):\n    # Acknowledge the button request\n    ack()\n    # Call views_update with the built-in client\n    client.views_update(\n        # Pass the view_id\n        view_id=body[\"view\"][\"id\"],\n        # String that represents view state to protect against race conditions\n        hash=body[\"view\"][\"hash\"],\n        # View payload with updated blocks\n        view={\n            \"type\": \"modal\",\n            # View identifier\n            \"callback_id\": \"view_1\",\n            \"title\": {\"type\": \"plain_text\", \"text\": \"Updated modal\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": \"You updated the modal!\"}\n                },\n                {\n                    \"type\": \"image\",\n                    \"image_url\": \"https://media.giphy.com/media/SVZGEcYt7brkFUyU90/giphy.gif\",\n                    \"alt_text\": \"Yay! The modal was updated\"\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Listening for Messages Containing an Emoji in Slack with Bolt for Python\nDESCRIPTION: This code demonstrates how to listen for messages containing the wave emoji (:wave:) in Slack and respond with a greeting that mentions the user. The message() decorator is used to filter messages containing a specific string pattern.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/message-listening.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# '👋' が含まれるすべてのメッセージに一致\n@app.message(\":wave:\")\ndef say_hello(message, say):\n    user = message['user']\n    say(f\"Hi there, <@{user}>!\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Listener for Button Click (Python)\nDESCRIPTION: This snippet shows how to implement an action listener in Bolt-Python to handle the button click event from the custom step. It updates the message, removes the button, and signals the step completion.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@app.action(\"sample_click\")\ndef handle_sample_click(\n    ack: Ack, body: dict, context: BoltContext, client: WebClient, complete: Complete, fail: Fail, logger: logging.Logger\n):\n    ack()\n\n    try:\n        # Since the button no longer works, we should remove it\n        client.chat_update(\n            channel=context.channel_id,\n            ts=body[\"message\"][\"ts\"],\n            text=\"Congrats! You clicked the button\",\n        )\n\n        # Signal that the step completed successfully\n        complete({\"user_id\": context.actor_user_id})\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a step request (error: {e}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Middleware in Slack Bolt Python\nDESCRIPTION: This snippet demonstrates how to create a global middleware function for authentication using an external system. The middleware looks up a user by their Slack ID, adds user data to the context, and sends an error message if authentication fails. It properly calls next() to continue the execution chain.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/global-middleware.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.use\ndef auth_acme(client, context, logger, payload, next):\n    slack_user_id = payload[\"user\"]\n    help_channel_id = \"C12345\"\n\n    try:\n        # Look up user in external system using their Slack user ID\n        user = acme.lookup_by_id(slack_user_id)\n        # Add that to context\n        context[\"user\"] = user\n    except Exception:\n        client.chat_postEphemeral(\n            channel=payload[\"channel\"],\n            user=slack_user_id,\n            text=f\"Sorry <@{slack_user_id}>, you aren't registered in Acme or there was an error with authentication. Please post in <#{help_channel_id}> for assistance\"\n        )\n\n    # Pass control to the next middleware\n    next()\n```\n\n----------------------------------------\n\nTITLE: Action Response Using say() in Slack Bolt Python\nDESCRIPTION: Demonstrates responding to an action using the say() method, which sends a message back to the conversation where the action occurred.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/actions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Your listener will be called every time an interactive component with the action_id \"approve_button\" is triggered\n@app.action(\"approve_button\")\ndef approve_request(ack, say):\n    # Acknowledge action request\n    ack()\n    say(\"Request approved 👍\")\n```\n\n----------------------------------------\n\nTITLE: Interactive Custom Step Implementation in Python\nDESCRIPTION: Example of an interactive custom step that posts a message with a button and handles the button click action. Includes both the step definition and action handler.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-steps.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# This sample custom step posts a message with a button\n@app.function(\"custom_step_button\")\ndef sample_step_callback(inputs, say, fail):\n    try:\n        say(\n            channel=inputs[\"user_id\"],  # sending a DM to this user\n            text=\"Click the button to signal the step completion\",\n            blocks=[\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"mrkdwn\", \"text\": \"Click the button to signal step completion\"},\n                    \"accessory\": {\n                        \"type\": \"button\",\n                        \"text\": {\"type\": \"plain_text\", \"text\": \"Complete step\"},\n                        \"action_id\": \"sample_click\",\n                    },\n                }\n            ],\n        )\n    except Exception as e:\n        fail(f\"Failed to handle a function request (error: {e})\")\n\n# Your listener will be called every time a block element with the action_id \"sample_click\" is triggered\n@app.action(\"sample_click\")\ndef handle_sample_click(ack, body, context, client, complete, fail):\n    ack()\n    try:\n        # Since the button no longer works, we should remove it\n        client.chat_update(\n            channel=context.channel_id,\n            ts=body[\"message\"][\"ts\"],\n            text=\"Congrats! You clicked the button\",\n        )\n\n        # Signal that the custom step completed successfully\n        complete({\"user_id\": context.actor_user_id})\n    except Exception as e:\n        fail(f\"Failed to handle a function request (error: {e})\")\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Step in Slack App Manifest (JSON)\nDESCRIPTION: This snippet shows how to define a custom step named 'sample_step' in the manifest.json file of a Slack app. It specifies the step's title, description, input parameters, and output parameters.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"functions\": {\n        \"sample_step\": {\n            \"title\": \"Sample step\",\n            \"description\": \"Runs sample step\",\n            \"input_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"Message recipient\",\n                    \"is_required\": true,\n                    \"hint\": \"Select a user in the workspace\",\n                    \"name\": \"user_id\"\n                }\n            },\n            \"output_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"User that completed the step\",\n                    \"is_required\": true,\n                    \"name\": \"user_id\"\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Sample Step Event in Slack Bolt Python\nDESCRIPTION: This snippet demonstrates how to handle a sample step event in a Slack Bolt Python app. It posts a message to the user and completes the step or logs an error if it fails.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@app.function(\"sample_step\")\ndef handle_sample_step_event(inputs: dict, fail: Fail, complete: Complete,logger: logging.Logger):\n    user_id = inputs[\"user_id\"]\n    try:\n        client.chat_postMessage( \n            channel=user_id, \n            text=f\"Greetings <@{user_id}>!\" \n        )\n        complete({\"user_id\": user_id})\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to complete the step: {e}\")\n\n```\n\n----------------------------------------\n\nTITLE: Integrating AsyncApp with Sanic Web Framework in Python\nDESCRIPTION: This snippet shows how to use AsyncApp with the Sanic web framework. It includes setting up event handlers, creating a Sanic app, and defining an endpoint for Slack events.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/async.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.async_app import AsyncApp\napp = AsyncApp()\n\n# ここには Sanic に固有の記述はありません\n# AsyncApp はフレームワークやランタイムに依存しません\n@app.event(\"app_mention\")\nasync def handle_app_mentions(say):\n    await say(\"What's up?\")\n\nimport os\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom slack_bolt.adapter.sanic import AsyncSlackRequestHandler\n\n# App のインスタンスから Sanic 用のアダプターを作成します\napp_handler = AsyncSlackRequestHandler(app)\n# Sanic アプリを作成します\napi = Sanic(name=\"awesome-slack-app\")\n\n@api.post(\"/slack/events\")\nasync def endpoint(req: Request):\n    # app_handler では内部的にアプリのディスパッチメソッドが実行されます\n    return await app_handler.handle(req)\n\nif __name__ == \"__main__\":\n    api.run(host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 3000)))\n```\n\n----------------------------------------\n\nTITLE: Creating Async Slack Bolt Application\nDESCRIPTION: Example of creating an asynchronous Slack Bolt application using asyncio and AIOHTTP.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt.async_app import AsyncApp\n\napp = AsyncApp()\n\n@app.event(\"app_mention\")\nasync def event_test(body, say, logger):\n    logger.info(body)\n    await say(\"What's up?\")\n\n@app.command(\"/hello-bolt-python\")\nasync def command(ack, body, respond):\n    await ack()\n    await respond(f\"Hi <@{body['user_id']}>!\")\n\nif __name__ == \"__main__\":\n    app.start(3000)\n```\n\n----------------------------------------\n\nTITLE: Handling External Select Menu Options in Python Slack Bolt\nDESCRIPTION: Example demonstrating how to respond to an external_select options request using the Bolt for Python framework. The code shows filtering options based on user input and acknowledging the request with filtered results.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/select-menu-options.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example of responding to an external_select options request\n@app.options(\"external_action\")\ndef show_options(ack, payload):\n    options = [\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": \"Option 1\"},\n            \"value\": \"1-1\",\n        },\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": \"Option 2\"},\n            \"value\": \"1-2\",\n        },\n    ]\n    keyword = payload.get(\"value\")\n    if keyword is not None and len(keyword) > 0:\n        options = [o for o in options if keyword in o[\"text\"][\"text\"]]\n    ack(options=options)\n```\n\n----------------------------------------\n\nTITLE: Defining Interactive Custom Step in Slack App Manifest\nDESCRIPTION: This JSON snippet demonstrates how to define an interactive custom step in the Slack app manifest. It includes input and output parameters for a step that involves user interaction.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/custom-steps.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"functions\": {\n        \"custom_step_button\": {\n            \"title\": \"Custom step with a button\",\n            \"description\": \"Custom step that waits for a button click\",\n            \"input_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"The recipient of a message with a button\",\n                    \"is_required\": true\n                }\n            },\n            \"output_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"The user that completed the function\",\n                    \"is_required\": true\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Button Click for Random Number Generation in Slack Bolt (Python)\nDESCRIPTION: This function is triggered when a button is clicked to generate random numbers. It opens a modal view for the user to configure the number of random numbers to generate.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@app.action(\"assistant-generate-random-numbers\")\ndef configure_random_number_generation(ack: Ack, client: WebClient, body: dict):\n    ack()\n    client.views_open(\n        trigger_id=body[\"trigger_id\"],\n        view={\n            \"type\": \"modal\",\n            \"callback_id\": \"configure_assistant_summarize_channel\",\n            \"title\": {\"type\": \"plain_text\", \"text\": \"My Assistant\"},\n            \"submit\": {\"type\": \"plain_text\", \"text\": \"Submit\"},\n            \"close\": {\"type\": \"plain_text\", \"text\": \"Cancel\"},\n            \"private_metadata\": json.dumps(\n                {\n                    \"channel_id\": body[\"channel\"][\"id\"],\n                    \"thread_ts\": body[\"message\"][\"thread_ts\"],\n                }\n            ),\n            \"blocks\": [\n                {\n                    \"type\": \"input\",\n                    \"block_id\": \"num\",\n                    \"label\": {\"type\": \"plain_text\", \"text\": \"# of outputs\"},\n                    \"element\": {\n                        \"type\": \"static_select\",\n                        \"action_id\": \"input\",\n                        \"placeholder\": {\"type\": \"plain_text\", \"text\": \"How many numbers do you need?\"},\n                        \"options\": [\n                            {\"text\": {\"type\": \"plain_text\", \"text\": \"5\"}, \"value\": \"5\"},\n                            {\"text\": {\"type\": \"plain_text\", \"text\": \"10\"}, \"value\": \"10\"},\n                            {\"text\": {\"type\": \"plain_text\", \"text\": \"20\"}, \"value\": \"20\"},\n                        ],\n                        \"initial_option\": {\"text\": {\"type\": \"plain_text\", \"text\": \"5\"}, \"value\": \"5\"},\n                    },\n                }\n            ],\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Running Socket Mode Application\nDESCRIPTION: Commands for running a Slack Bolt application in Socket Mode.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_APP_TOKEN=xapp-***\nexport SLACK_BOT_TOKEN=xoxb-***\npython app.py\n```\n\n----------------------------------------\n\nTITLE: Responding to External Select Options Request in Slack Bolt Python\nDESCRIPTION: Example of responding to an external_select options request by using the `ack()` function to provide a list of menu options. This pattern is used when defining custom option menus for Slack interactive components.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/acknowledge.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example of responding to an external_select options request\n@app.options(\"menu_selection\")\ndef show_menu_options(ack):\n    options = [\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": \"Option 1\"},\n            \"value\": \"1-1\",\n        },\n        {\n            \"text\": {\"type\": \"plain_text\", \"text\": \"Option 2\"},\n            \"value\": \"1-2\",\n        },\n    ]\n    ack(options=options)\n```\n\n----------------------------------------\n\nTITLE: Setting up Bolt Python Environment\nDESCRIPTION: Instructions for setting up a Python virtual environment and installing the Bolt framework dependencies.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Python 3.6+ required\npython -m venv .venv\nsource .venv/bin/activate\n\npip install -U pip\npip install slack_bolt\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Listener for Manager Response\nDESCRIPTION: Python function that handles the manager's response to the time off request, updating the message and completing the workflow step.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@app.action(re.compile(\"(approve_button|deny_button)\"))\ndef manager_resp_handler(ack: Ack, action, body: dict, client: WebClient, complete: Complete, fail: Fail, logger: logging.Logger):\n\n    ack()\n\n    try:\n        inputs = body['function_data']['inputs']\n        manager_id = inputs['manager_id']\n        submitter_id = inputs['submitter_id']\n        request_decision = action['value']\n\n        client.chat_update(\n            channel=body['channel']['id'],\n            message=body['message'],\n            ts=body[\"message\"][\"ts\"],\n            text=f'Request {\"approved\" if request_decision == \"approve\" else \"denied\"}!'\n        )\n\n        complete({\n            'manager_id': manager_id,\n            'submitter_id': submitter_id,\n            'request_decision':  request_decision == 'approve'\n        })\n\n    except Exception as e:\n        logger.exception(e)\n        fail(f\"Failed to handle a function request (error: {e})\")\n```\n\n----------------------------------------\n\nTITLE: Handling Bot Messages for Random Number Generation in Slack Bolt (Python)\nDESCRIPTION: This function responds to bot messages, specifically handling the random number generation request. It generates the requested number of random numbers and posts them as a reply.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n@assistant.bot_message\ndef respond_to_bot_messages(logger: logging.Logger, set_status: SetStatus, say: Say, payload: dict):\n    try:\n        if payload.get(\"metadata\", {}).get(\"event_type\") == \"assistant-generate-random-numbers\":\n            set_status(\"is generating an array of random numbers...\")\n            time.sleep(1)\n            nums: Set[str] = set()\n            num = payload[\"metadata\"][\"event_payload\"][\"num\"]\n            while len(nums) < num:\n                nums.add(str(random.randint(1, 100)))\n            say(f\"Here you are: {', '.join(nums)}\")\n        else:\n            pass\n\n    except Exception as e:\n        logger.exception(f\"Failed to respond to an inquiry: {e}\")\n```\n\n----------------------------------------\n\nTITLE: AWS Lambda Deployment Commands for Slack Bolt App\nDESCRIPTION: Commands for deploying a Slack Bolt application to AWS Lambda. It includes package installation, configuration of requirements, and Lambda deployment with proper environment variables.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/lazy-listeners.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install slack_bolt\n# Save the source code as main.py\n# and refer handler as `handler: main.handler` in config.yaml\n\n# https://pypi.org/project/python-lambda/\npip install python-lambda\n\n# Configure config.yml properly\n# lambda:InvokeFunction & lambda:GetFunction are required for running lazy listeners\nexport SLACK_SIGNING_SECRET=***\nexport SLACK_BOT_TOKEN=xoxb-***\necho 'slack_bolt' > requirements.txt\nlambda deploy --config-file config.yaml --requirements requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Running Slack Bolt Application\nDESCRIPTION: Commands for running a Slack Bolt application with required environment variables.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_SIGNING_SECRET=***\nexport SLACK_BOT_TOKEN=xoxb-***\npython app.py\n\n# in another terminal\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Processing Modal Submission for Random Number Generation in Slack Bolt (Python)\nDESCRIPTION: This function handles the submission of the modal for random number generation. It extracts the user's input and posts a message to continue the process.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n@app.view(\"configure_assistant_summarize_channel\")\ndef receive_random_number_generation_details(ack: Ack, client: WebClient, payload: dict):\n    ack()\n    num = payload[\"state\"][\"values\"][\"num\"][\"input\"][\"selected_option\"][\"value\"]\n    thread = json.loads(payload[\"private_metadata\"])\n\n    client.chat_postMessage(\n        channel=thread[\"channel_id\"],\n        thread_ts=thread[\"thread_ts\"],\n        text=f\"OK, you need {num} numbers. I will generate it shortly!\",\n        metadata={\n            \"event_type\": \"assistant-generate-random-numbers\",\n            \"event_payload\": {\"num\": int(num)},\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Handling User Messages in Slack Bolt Assistant (Python)\nDESCRIPTION: This function responds to user messages in the assistant thread. It sets a typing status and instructs the user to use the buttons in the first reply.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/ai-apps.md#2025-04-17_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n@assistant.user_message\ndef respond_to_user_messages(logger: logging.Logger, set_status: SetStatus, say: Say):\n    try:\n        set_status(\"is typing...\")\n        say(\"Please use the buttons in the first reply instead :bow:\")\n    except Exception as e:\n        logger.exception(f\"Failed to respond to an inquiry: {e}\")\n        say(f\":warning: Sorry, something went wrong during processing your request (error: {e})\")\n\n# Enable this assistant middleware in your Bolt app\napp.use(assistant)\n```\n\n----------------------------------------\n\nTITLE: Implementing Save Callback for WorkflowStep in Python\nDESCRIPTION: This snippet demonstrates how to implement the save callback for a WorkflowStep. It shows how to extract values from the view submission and use the update() method to save the step configuration.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/steps-from-apps.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef save(ack, view, update):\n    ack()\n\n    values = view[\"state\"][\"values\"]\n    task_name = values[\"task_name_input\"][\"name\"]\n    task_description = values[\"task_description_input\"][\"description\"]\n                \n    inputs = {\n        \"task_name\": {\"value\": task_name[\"value\"]},\n        \"task_description\": {\"value\": task_description[\"value\"]}\n    }\n    outputs = [\n        {\n            \"type\": \"text\",\n            \"name\": \"task_name\",\n            \"label\": \"Task name\",\n        },\n        {\n            \"type\": \"text\",\n            \"name\": \"task_description\",\n            \"label\": \"Task description\",\n        }\n    ]\n    update(inputs=inputs, outputs=outputs)\n\nws = WorkflowStep(\n    callback_id=\"add_task\",\n    edit=edit,\n    save=save,\n    execute=execute,\n)\napp.step(ws)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Sanic Integration\nDESCRIPTION: Command-line instructions for installing required packages and starting a Sanic server for Slack Bolt integration.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/async.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install requirements\npip install slack_bolt sanic uvicorn\n# Save the source as async_app.py\nuvicorn async_app:api --reload --port 3000 --log-level debug\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Workflow Step in Slack App Manifest\nDESCRIPTION: JSON configuration for defining a custom workflow step in the Slack app manifest. This example shows the structure for input and output parameters, as well as step metadata.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"functions\": {\n    \"sample_step\": {\n        \"title\": \"Sample step\",\n        \"description\": \"Runs sample step\",\n        \"input_parameters\": {\n          \"properties\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"Message recipient\",\n                \"hint\": \"Select a user in the workspace\",\n                \"name\": \"user_id\"\n            }\n          },\n          \"required\": {\n            \"user_id\"\n          }\n        },\n        \"output_parameters\": {\n          \"properties\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"User that received the message\",\n                \"name\": \"user_id\"\n            }\n          },\n          \"required\": {\n            \"user_id\"\n          }\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AWS Lambda Implementation of Lazy Listeners for Slack Bolt\nDESCRIPTION: Complete implementation of a Slack Bolt application with lazy listeners for AWS Lambda. The code includes the application setup, command handler with separate acknowledgment and processing functions, and the Lambda handler function.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/lazy-listeners.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt import App\nfrom slack_bolt.adapter.aws_lambda import SlackRequestHandler\n\n# process_before_response must be True when running on FaaS\napp = App(process_before_response=True)\n\ndef respond_to_slack_within_3_seconds(body, ack):\n    text = body.get(\"text\")\n    if text is None or len(text) == 0:\n        ack(\":x: Usage: /start-process (description here)\")\n    else:\n        ack(f\"Accepted! (task: {body['text']})\") \n\nimport time\ndef run_long_process(respond, body):\n    time.sleep(5)  # longer than 3 seconds\n    respond(f\"Completed! (task: {body['text']})\") \n\napp.command(\"/start-process\")(\n    ack=respond_to_slack_within_3_seconds,  # responsible for calling `ack()`\n    lazy=[run_long_process]  # unable to call `ack()` / can have multiple functions\n)\n\ndef handler(event, context):\n    slack_handler = SlackRequestHandler(app=app)\n    return slack_handler.handle(event, context)\n```\n\n----------------------------------------\n\nTITLE: Specifying Slack SDK Dependency Version Range for Python\nDESCRIPTION: This line defines the acceptable version range for the slack_sdk package. It requires a version greater than or equal to 3.35.0 but less than 4.0.0, ensuring compatibility with recent features while avoiding potential breaking changes in major version 4.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: PlainText\nCODE:\n```\nslack_sdk>=3.35.0,<4\n```\n\n----------------------------------------\n\nTITLE: Workflow Step Configuration in App Manifest\nDESCRIPTION: JSON configuration defining the workflow step parameters including input and output configurations.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"functions\": {\n        \"request_time_off\": {\n            \"title\": \"Request time off\",\n            \"description\": \"Submit a request to take time off\",\n            \"input_parameters\": {\n                \"manager_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"Manager\",\n                    \"description\": \"Approving manager\",\n                    \"is_required\": true,\n                    \"hint\": \"Select a user in the workspace\",\n                    \"name\": \"manager_id\"\n                },\n                \"submitter_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"Submitting user\",\n                    \"description\": \"User that submitted the request\",\n                    \"is_required\": true,\n                    \"name\": \"submitter_id\"\n                }\n            },\n            \"output_parameters\": {\n                \"manager_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"Manager\",\n                    \"description\": \"Approving manager\",\n                    \"is_required\": true,\n                    \"name\": \"manager_id\"\n                },\n                \"request_decision\": {\n                    \"type\": \"boolean\",\n                    \"title\": \"Request decision\",\n                    \"description\": \"Decision to the request for time off\",\n                    \"is_required\": true,\n                    \"name\": \"request_decision\"\n                },\n                \"submitter_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"Submitting user\",\n                    \"description\": \"User that submitted the request\",\n                    \"is_required\": true,\n                    \"name\": \"submitter_id\"\n                }\n            }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Modal Payload Structure in JSON\nDESCRIPTION: This JSON structure defines the layout and content of a modal in Slack. It includes a title, submit and close buttons, and an input block for user text entry. This payload is used to create the modal interface when triggered by a slash command.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/modals.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"modal\",\n  \"callback_id\": \"gratitude-modal\",\n  \"title\": {\n    \"type\": \"plain_text\",\n    \"text\": \"Gratitude Box\",\n    \"emoji\": true\n  },\n  \"submit\": {\n    \"type\": \"plain_text\",\n    \"text\": \"Submit\",\n    \"emoji\": true\n  },\n  \"close\": {\n    \"type\": \"plain_text\",\n    \"text\": \"Cancel\",\n    \"emoji\": true\n  },\n  \"blocks\": [\n    {\n      \"type\": \"input\",\n      \"block_id\": \"my_block\",\n      \"element\": {\n        \"type\": \"plain_text_input\",\n        \"action_id\": \"my_action\"\n      },\n      \"label\": {\n        \"type\": \"plain_text\",\n        \"text\": \"Say something nice!\",\n        \"emoji\": true\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Slack Bolt Project\nDESCRIPTION: This snippet lists the required Python packages and their minimum versions for a project using Slack Bolt, Flask, and Gunicorn. It includes the core Slack Bolt library, Flask web framework (version 1.1 or higher), and Gunicorn WSGI HTTP Server (version 20 or higher).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/flask-gunicorn/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\nFlask>=1.1\ngunicorn>=20\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Step in Slack App Manifest\nDESCRIPTION: This JSON snippet shows how to define a custom step in the Slack app manifest. It specifies the step's title, description, input parameters, and output parameters.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/custom-steps.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"functions\": {\n        \"sample_custom_step\": {\n            \"title\": \"Sample custom step\",\n            \"description\": \"Run a sample custom step\",\n            \"input_parameters\": {\n                \"message\": {\n                    \"type\": \"string\",\n                    \"title\": \"Message\",\n                    \"description\": \"A message to be formatted by the custom step\",\n                    \"is_required\": true\n                }\n            },\n            \"output_parameters\": {\n                \"message\": {\n                    \"type\": \"string\",\n                    \"title\": \"Messge\",\n                    \"description\": \"A formatted message\",\n                    \"is_required\": true\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Org-Ready Apps in Slack App Manifest\nDESCRIPTION: JSON configuration to enable org-ready apps in the Slack app manifest. This setting is required for custom workflow steps.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"settings\": {\n        \"org_deploy_enabled\": true,\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for Slack Bolt\nDESCRIPTION: This snippet lists the required Python packages for the Slack Bolt project. It includes the slack_bolt package and the aiohttp library with a version range of 3.x but less than 4.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/aiohttp/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\naiohttp>=3,<4\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Bot Token Environment Variable\nDESCRIPTION: Shell command to set the Slack bot token as an environment variable for secure access.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nexport SLACK_BOT_TOKEN=xoxb-<your-bot-token>\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory for Bolt Python App\nDESCRIPTION: Shell commands to create a new directory for the Bolt Python project and navigate into it.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmkdir first-bolt-app\ncd first-bolt-app\n```\n\n----------------------------------------\n\nTITLE: Python Package Requirements\nDESCRIPTION: Specifies version constraints for Python web server packages. Requires uvicorn web server below version 1.0 and aiohttp HTTP client between versions 3.0 and 4.0.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/asgi/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nuvicorn<1\naiohttp>=3,<4\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Slack App\nDESCRIPTION: Configuration of essential environment variables including the Slack bot token and signing secret required for app authentication.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/getting_started/README.md#2025-04-17_snippet_0\n\nLANGUAGE: zsh\nCODE:\n```\n# Replace with your signing secret and token\nexport SLACK_BOT_TOKEN=<your-bot-token>\nexport SLACK_SIGNING_SECRET=<your-signing-secret>\n```\n\n----------------------------------------\n\nTITLE: Specifying Starlette and Uvicorn Version Requirements\nDESCRIPTION: Defines version constraints for Starlette and Uvicorn libraries. Starlette is required to be version 0.13 or higher, but less than 1. Uvicorn must be less than version 1.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/starlette/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\nstarlette>=0.13,<1\nuvicorn<1\n```\n\n----------------------------------------\n\nTITLE: Setting up Environment for Single-workspace Slack App in Django\nDESCRIPTION: Commands for setting up a Python virtual environment, installing dependencies, configuring environment variables, and running a Django application for a single-workspace Slack app integration.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/django/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv .venv\nsource .venv/bin/activate\npip install -U pip\npip install -r requirements.txt\n\nexport SLACK_SIGNING_SECRET=(You can find this value at Settings > Basic Information > App Credentials > Signing Secret)\nexport SLACK_BOT_TOKEN=(You can find this value at Settings > Install App > Bot User OAuth Token)\n\npython manage.py migrate\npython manage.py runserver 0.0.0.0:3000\n```\n\n----------------------------------------\n\nTITLE: Specifying Tornado Version Requirement for Bolt-Python\nDESCRIPTION: This line specifies the version requirement for the Tornado web framework in the Bolt-Python project. It requires Tornado version 6.x, ensuring compatibility with the latest features of version 6 while avoiding potential breaking changes in version 7.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/tornado/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ntornado>=6,<7\n```\n\n----------------------------------------\n\nTITLE: Adding Function Executed Event Subscription in App Manifest\nDESCRIPTION: JSON configuration to add the function_executed event subscription in the Slack app manifest.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"settings\": {\n        \"event_subscriptions\": {\n            \"bot_events\": [\n                \"function_executed\"\n            ]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Manifest for Slack App\nDESCRIPTION: JSON manifest file reference for creating the Slack app with required scopes and configurations\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nreference title=\"manifest.json\"\nhttps://github.com/slack-samples/bolt-python-jira-functions/blob/main/manifest.json\n```\n\n----------------------------------------\n\nTITLE: Specifying Bottle Framework Version Requirement in Python\nDESCRIPTION: This requirement specifies that the Python project depends on the Bottle web framework with version constraints. It requires Bottle version 0.12 or higher, but strictly less than version 1.0.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/bottle/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nbottle>=0.12,<1\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Virtual Environment for Bolt App\nDESCRIPTION: Shell commands to create and activate a Python virtual environment for managing project dependencies.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m venv .venv\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Specifying dependency versions for Sanic and Uvicorn\nDESCRIPTION: Defines version constraints for two key dependencies: Sanic web framework (version 20.x) and Uvicorn ASGI server (before version 1). These specific version pins help ensure compatibility and stability.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/sanic/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsanic>=20,<21\nuvicorn<1\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for OAuth Lambda Example\nDESCRIPTION: This bash snippet shows the required environment variables needed for the OAuth Lambda example, including Slack API credentials and S3 bucket names for storing installation data and state.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/aws_lambda/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSLACK_SIGNING_SECRET=  # Signing Secret from Basic Information page\nSLACK_CLIENT_ID= # Client ID from Basic Information page\nSLACK_CLIENT_SECRET # Client Secret from Basic Information page\nSLACK_SCOPES= \"app_mentions:read,chat:write\"\nSLACK_INSTALLATION_S3_BUCKET_NAME: # The name of installations bucket\nSLACK_STATE_S3_BUCKET_NAME: # The name of the state store bucket\nexport\n```\n\n----------------------------------------\n\nTITLE: Installing Python Test Dependencies without AsyncIO\nDESCRIPTION: Package requirements file specifying pytest and pytest-cov dependencies with version constraints. Includes a note about tornado compatibility issue that affects version selection.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/testing_without_asyncio.txt#2025-04-17_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n# pip install -r requirements/testing_without_asyncio.txt\npytest>=6.2.5,<8.4        # https://github.com/tornadoweb/tornado/issues/3375\npytest-cov>=3,<7\n```\n\n----------------------------------------\n\nTITLE: Dependencies for Slack Bolt Python Application\nDESCRIPTION: Core package dependencies required for running a Slack Bolt Python application. Includes the Slack Bolt SDK, Flask web framework (version 1.1 or higher), and Gunicorn WSGI server (version 20 or higher).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/heroku/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nslack_bolt\nFlask>=1.1\ngunicorn>=20\n```\n\n----------------------------------------\n\nTITLE: Installing slack_sdk Package with pip\nDESCRIPTION: This command installs the slack_sdk Python package using pip, which is the primary SDK for building Slack applications in Python.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/aws_lambda/requirements_oauth.txt#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nslack_sdk\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Slack Bolt Project\nDESCRIPTION: This snippet lists the required Python packages and their version constraints for the Slack Bolt project. It includes slack_bolt (no version specified), fastapi (less than version 1), and aiohttp (version 3 or higher, but less than 4).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/fastapi-gunicorn/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\nfastapi<1\naiohttp>=3,<4\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Authorization for Multi-Workspace Slack Apps in Python\nDESCRIPTION: This code snippet demonstrates how to implement a custom authorization function for a Slack app that can be installed in multiple workspaces. It uses a list of installations to look up the appropriate bot token and other necessary information based on the enterprise_id and team_id.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/authorization.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom slack_bolt import App\n# AuthorizeResult クラスをインポートします\nfrom slack_bolt.authorization import AuthorizeResult\n\n# これはあくまでサンプル例です（ユーザートークンがないことを想定しています）\n# 実際にはセキュアな DB に認可情報を保存してください\ninstallations = [\n    {\n      \"enterprise_id\":\"E1234A12AB\",\n      \"team_id\":\"T12345\",\n      \"bot_token\": \"xoxb-123abc\",\n      \"bot_id\":\"B1251\",\n      \"bot_user_id\":\"U12385\"\n    },\n    {\n      \"team_id\":\"T77712\",\n      \"bot_token\": \"xoxb-102anc\",\n      \"bot_id\":\"B5910\",\n      \"bot_user_id\":\"U1239\",\n      \"enterprise_id\":\"E1234A12AB\"\n    }\n]\n\ndef authorize(enterprise_id, team_id, logger):\n    # トークンを取得するためのあなたのロジックをここに記述します\n    for team in installations:\n        # 一部のチームは enterprise_id を持たない場合があります\n        is_valid_enterprise = \"enterprise_id\" not in team or enterprise_id == team[\"enterprise_id\"]\n        if is_valid_enterprise and team[\"team_id\"] == team_id:\n          # AuthorizeResult のインスタンスを返します\n          # bot_id と bot_user_id を保存していない場合、bot_token を使って `from_auth_test_response` を呼び出すと、自動的に取得できます\n          return AuthorizeResult(\n              enterprise_id=enterprise_id,\n              team_id=team_id,\n              bot_token=team[\"bot_token\"],\n              bot_id=team[\"bot_id\"],\n              bot_user_id=team[\"bot_user_id\"]\n          )\n\n    logger.error(\"No authorization information was found\")\n\napp = App(\n    signing_secret=os.environ[\"SLACK_SIGNING_SECRET\"],\n    authorize=authorize\n)\n```\n\n----------------------------------------\n\nTITLE: Action Listener Structure Description in Markdown\nDESCRIPTION: Detailed explanation of the .action() listener structure, including its arguments and callback function utilities like client, action, complete, and fail methods. The snippet describes how to handle action events from Slack button interactions.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nSimilar to a function listener, the action listener registration method (.action()) takes two arguments:\\n\\n- The first argument is the unique callback ID of the action that your app will respond to.\\n- The second argument is an asynchronous callback function, where we define the logic that will run when Slack tells our app that the manager has clicked or tapped the Approve button or the Deny button.\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for Slack Bolt Project\nDESCRIPTION: This snippet lists the required Python packages and their minimum versions for a Slack Bolt project. It includes Slack Bolt itself, Flask web framework (version 1.1 or higher), and Gunicorn WSGI HTTP Server (version 20 or higher).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/google_cloud_run/flask-gunicorn/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\nFlask>=1.1\ngunicorn>=20\n```\n\n----------------------------------------\n\nTITLE: Implementing Slack Bolt App with Flask Adapter in Python\nDESCRIPTION: This code snippet demonstrates how to set up a Slack Bolt app using the Flask adapter. It includes initializing the Bolt app, defining a command handler, setting up the Flask app, and registering a route for Slack events.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/adapters.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom slack_bolt import App\napp = App(\n    signing_secret=os.environ.get(\"SLACK_SIGNING_SECRET\"),\n    token=os.environ.get(\"SLACK_BOT_TOKEN\")\n)\n\n# ここには Flask 固有の記述はありません\n# App はフレームワークやランタイムに一切依存しません\n@app.command(\"/hello-bolt\")\ndef hello(body, ack):\n    ack(f\"Hi <@{body['user_id']}>!\")\n\n# Flask アプリを初期化します\nfrom flask import Flask, request\nflask_app = Flask(__name__)\n\n# SlackRequestHandler は WSGI のリクエストを Bolt のインターフェイスに合った形に変換します\n# Bolt レスポンスからの WSGI レスポンスの作成も行います\nfrom slack_bolt.adapter.flask import SlackRequestHandler\nhandler = SlackRequestHandler(app)\n\n# Flask アプリへのルートを登録します\n@flask_app.route(\"/slack/events\", methods=[\"POST\"])\ndef slack_events():\n    # handler はアプリのディスパッチメソッドを実行します\n    return handler.handle(request)\n```\n\n----------------------------------------\n\nTITLE: Local Project Setup Commands\nDESCRIPTION: Series of commands to clone the project, set up a virtual environment, and install dependencies for the Bolt Python project.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/getting_started/README.md#2025-04-17_snippet_1\n\nLANGUAGE: zsh\nCODE:\n```\n# Clone this project onto your machine\ngit clone https://github.com/slackapi/bolt-python.git\n\n# Change into this project\ncd bolt-python/examples/getting_started/\n\n# Setup virtual environment\npython3 -m venv .venv\nsource .venv/bin/activate\n\n# Install the dependencies\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Updating a Modal View with views_update in Slack Bolt for Python\nDESCRIPTION: Demonstrates how to update an existing modal when a button with action_id 'button_abc' is clicked. The code listens for the button interaction, acknowledges the request, and then updates the modal with new content including text and an image.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/updating-pushing-views.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# モーダルに含まれる、`button_abc` という action_id のボタンの呼び出しをリッスン\n@app.action(\"button_abc\")\ndef update_modal(ack, body, client):\n    # ボタンのリクエストを確認\n    ack()\n    # 組み込みのクライアントで views_update を呼び出し\n    client.views_update(\n        # view_id を渡すこと\n        view_id=body[\"view\"][\"id\"],\n        # 競合状態を防ぐためのビューの状態を示す文字列\n        hash=body[\"view\"][\"hash\"],\n        # 更新後の blocks を含むビューのペイロード\n        view={\n            \"type\": \"modal\",\n            # ビューの識別子\n            \"callback_id\": \"view_1\",\n            \"title\": {\"type\": \"plain_text\", \"text\":\"Updated modal\"},\n            \"blocks\": [\n                {\n                    \"type\": \"section\",\n                    \"text\": {\"type\": \"plain_text\", \"text\":\"You updated the modal!\"}\n                },\n                {\n                    \"type\": \"image\",\n                    \"image_url\": \"https://media.giphy.com/media/SVZGEcYt7brkFUyU90/giphy.gif\",\n                    \"alt_text\":\"Yay!The modal was updated\"\n                }\n            ]\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Slack Bolt Adapter Dependencies with pip\nDESCRIPTION: This pip requirements file specifies the dependencies needed for various Slack Bolt adapters. It includes web frameworks, AWS libraries, and other utilities with specific version constraints. Some dependencies are conditional based on the Python version being used.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/adapter.txt#2025-04-17_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n# pip install -r requirements/adapter.txt\n# NOTE: any of async ones requires pip install -r requirements/async.txt too\n# used only under slack_bolt/adapter\nboto3<=2\nbottle>=0.12,<1\nchalice<=1.27.3; python_version==\"3.6\"\nchalice>=1.28,<2; python_version>\"3.6\"\nCherryPy>=18,<19\nDjango>=3,<6\nfalcon>=2,<5; python_version<\"3.11\"\nfalcon>=3.1.1,<5; python_version>=\"3.11\"\nfastapi>=0.70.0,<1\nFlask>=1,<4\nWerkzeug>=2,<4\npyramid>=1,<3\nsanic>=20,<21; python_version==\"3.6\"\nsanic>=21,<24; python_version>\"3.6\" and python_version<=\"3.8\"\nsanic>=21,<26; python_version>\"3.8\"\nstarlette>=0.19.1,<1\ntornado>=6,<7\nuvicorn<1                                # The oldest version can vary among Python runtime versions\ngunicorn>=20,<24\nwebsocket_client>=1.2.3,<2               # Socket Mode 3rd party implementation\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Slack Bolt Python Project\nDESCRIPTION: This snippet lists the required dependencies for the Slack Bolt Python project. It includes the slack_bolt library, Flask framework with a version greater than 1, and uWSGI server with version 2.x.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/flask-uwsgi/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nslack_bolt\nFlask>1\nuWSGI>=2,<3\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncApp and Handling Events in Python\nDESCRIPTION: This snippet demonstrates how to initialize AsyncApp, handle app_mention events asynchronously, and start the app. It requires aiohttp to be installed.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/async.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# aiohttp のインストールが必要です\nfrom slack_bolt.async_app import AsyncApp\napp = AsyncApp()\n\n@app.event(\"app_mention\")\nasync def handle_mentions(event, client, say):  # 非同期関数\n    api_response = await client.reactions_add(\n        channel=event[\"channel\"],\n        timestamp=event[\"ts\"],\n        name=\"eyes\",\n    )\n    await say(\"What's up?\")\n\nif __name__ == \"__main__\":\n    app.start(3000)\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Slack Bolt Project\nDESCRIPTION: This snippet lists the required Python packages and their version constraints for the Slack Bolt project. It includes slack_bolt (no version specified), aiohttp (version 3.x), and sanic (version 20.x).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/sanic/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\naiohttp>=3,<4\nsanic>=20,<21\n```\n\n----------------------------------------\n\nTITLE: Starting Development Servers\nDESCRIPTION: Commands to start the ngrok tunnel for local development and launch the Python application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/getting_started/README.md#2025-04-17_snippet_2\n\nLANGUAGE: zsh\nCODE:\n```\nngrok http 3000\npython3 app.py\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Slack Bolt Project\nDESCRIPTION: This snippet lists the required Python packages and their version constraints for the Slack Bolt project. It includes slack_bolt (no version specified), aiohttp (version 3.x), and sanic (version 20.x).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/google_cloud_run/sanic/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nslack_bolt\naiohttp>=3,<4\nsanic>=20,<21\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Windows\nDESCRIPTION: Commands to set required environment variables including Slack tokens and JIRA credentials on Windows\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nset SLACK_BOT_TOKEN=<your-bot-token>\nset SLACK_APP_TOKEN=<your-app-token>\nset JIRA_CLIENT_ID=<client-id>\nset JIRA_CLIENT_SECRET=<client-secret>\n```\n\n----------------------------------------\n\nTITLE: Installing Async Dependencies for Slack Bolt Python\nDESCRIPTION: Specifies required Python packages and their version constraints for async functionality. Includes aiohttp for HTTP client/server and websockets for WebSocket connections, with specific version ranges to ensure compatibility.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/async.txt#2025-04-17_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n# pip install -r requirements/async.txt\naiohttp>=3,<4\nwebsockets<16\n```\n\n----------------------------------------\n\nTITLE: Starting Python Virtual Environment for macOS\nDESCRIPTION: Commands to create and activate Python virtual environment on macOS\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv .venv\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for Slack Bolt App\nDESCRIPTION: Lists required Python packages and their version constraints for a Slack Bolt application. Includes Slack Bolt SDK (v0.6+), Sanic web framework (v20.x), uvicorn ASGI server (pre-1.0), and SQLite database support.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/sqlalchemy/requirements_async.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nslack_bolt>=0.6\nsanic>=20,<21\nuvicorn<1\ndatabases[sqlite]\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Lists required Python packages and their version constraints for a Slack Bolt application. Includes Flask (version >1), slack_bolt (any version), and google-cloud-datastore (version >=2.1.0 and <3).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/google_cloud_functions/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nFlask>1\nslack_bolt\ngoogle-cloud-datastore>=2.1.0,<3\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory\nDESCRIPTION: Command to change into the project directory after cloning\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd bolt-python-jira-functions\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for Slack Bolt\nDESCRIPTION: Lists required Python packages for a Slack Bolt application. Requires slack_bolt package and aiohttp library version 3.x for async HTTP functionality.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/google_cloud_run/aiohttp/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nslack_bolt\naiohttp>=3,<4\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment on Windows\nDESCRIPTION: Commands to create and activate a Python virtual environment on Windows systems.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npy -m venv .venv\n.venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Specifying Package Dependencies for Bolt-Python\nDESCRIPTION: This snippet defines the required Python packages with version constraints. It requires aiohttp version 3.x but less than 4, and aiohttp-devtools version 0.13.x but less than 0.14.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/aiohttp_devtools/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\naiohttp>=3,<4\naiohttp-devtools>=0.13,<0.14\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment on macOS\nDESCRIPTION: Commands to create and activate a Python virtual environment on macOS systems.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv .venv\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Setting up Environment for OAuth-enabled Multi-workspace Slack App in Django\nDESCRIPTION: Commands for configuring and running a Django application with OAuth support for multi-workspace Slack app integration, including environment variables for client credentials and scopes.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/django/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -m venv .venv\nsource .venv/bin/activate\npip install -U pip\npip install -r requirements.txt\n\nexport SLACK_SIGNING_SECRET=(You can find this value at Settings > Basic Information > App Credentials > Signing Secret)\nexport SLACK_CLIENT_ID=(You can find this value at Settings > Basic Information > App Credentials > Client ID)\nexport SLACK_CLIENT_SECRET=(You can find this value at Settings > Basic Information > App Credentials > Client Secret)\nexport SLACK_SCOPES=app_mentions:read,chat:write\n\npython manage.py migrate\npython manage.py runserver 0.0.0.0:3000\n```\n\n----------------------------------------\n\nTITLE: Serving Built Site for Local Testing\nDESCRIPTION: NPM command to serve the built static site locally for testing before deployment.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm run serve\n```\n\n----------------------------------------\n\nTITLE: Specifying Django and Slack Bolt version requirements\nDESCRIPTION: Defines the required versions for Django and Slack Bolt packages. Django must be version 3.2 or higher, but less than 4. Slack Bolt must be version 1.7 or higher, but less than 2.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/django/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\nDjango>=3.2,<4\nslack-bolt>=1.7,<2\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Slack Bolt Python Project\nDESCRIPTION: This snippet lists the required dependencies for a Python project. It includes the slack_bolt library without version constraints and specifies uvicorn with a version less than 1.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/docker/asgi/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\nslack_bolt\nuvicorn<1\n```\n\n----------------------------------------\n\nTITLE: Content Folder Structure\nDESCRIPTION: Detailed overview of how English and Japanese page files are organized in parallel directory structures, illustrating which files get translated and how English fallbacks work.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\ndocs/\n├── content/ (English pages)\n│   ├── example-page.md \n│   ├── getting-started.md\n│   └── concepts\n│       └── sending-message.md\n├── i18n/ja-jp\n│   └── docusaurus-plugin-content-docs/ \n│       └── current/ (Japanese pages)\n│           ├── getting-started.md\n│           └── concepts\n│               └── sending-message.md\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Slack Bolt Python Project\nDESCRIPTION: This snippet defines the required packages for a Python project. It includes slack_bolt without version constraints and Flask with a specific version range.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/google_app_engine/flask/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt\nFlask>=1.1,<2\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Command to install all required dependencies from the requirements.txt file.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Japanese Documentation File Structure\nDESCRIPTION: Directory structure showing how documentation files are organized, with English content in the main docs folder and Japanese translations in the i18n subdirectory.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ndocs/\n├── content/\n│   ├── getting-started.md\n│   └── concepts\n│       └── sending-message.md\n├── i18n/ja-jp\n│   ├── code.json\n│   ├── docusaurus-theme-classic/\n│   │   ├── footer.json\n│   │   └── navbar.json\n│   └── docusaurus-plugin-content-docs/\n│       └── current/\n│           ├── getting-started.md\n│           └── concepts\n│               └── sending-message.md\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for Bolt Testing with AsyncIO\nDESCRIPTION: This snippet specifies the Python package dependencies required for testing the Bolt framework. It includes references to other requirement files for testing without AsyncIO and async-specific dependencies. It also pins the pytest-asyncio package to a version less than 1.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/testing.txt#2025-04-17_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\n# pip install -r requirements/testing.txt\n-r testing_without_asyncio.txt\n-r async.txt\npytest-asyncio<1;\n```\n\n----------------------------------------\n\nTITLE: Specifying Gunicorn Version Constraint for Bolt-Python\nDESCRIPTION: This snippet defines a version constraint for Gunicorn, limiting it to versions less than 23. This ensures compatibility with the Bolt-Python project and prevents potential issues with newer, potentially incompatible versions of Gunicorn.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/wsgi/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\ngunicorn<23\n```\n\n----------------------------------------\n\nTITLE: Starting the Bolt Application\nDESCRIPTION: Command to start the Python Bolt application server.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npython app.py\n```\n\n----------------------------------------\n\nTITLE: Japanese Page Title Format Example\nDESCRIPTION: Example showing how to provide a Japanese title for documentation pages, either through the frontmatter title field or as the first heading.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n---\ntitle: こんにちは\n---\n\n# こんにちは\n\n```\n\n----------------------------------------\n\nTITLE: Package Name Definition - Slack Bolt Python\nDESCRIPTION: Simple text file defining the package name 'slack-bolt' for the Python implementation of Slack's Bolt framework.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/getting_started/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nslack-bolt\n```\n\n----------------------------------------\n\nTITLE: Installing Slack Bolt Python Package\nDESCRIPTION: Pip command to install the slack_bolt Python package in the virtual environment.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npip install slack_bolt\n```\n\n----------------------------------------\n\nTITLE: Cloning Bolt Python Custom Step Template\nDESCRIPTION: Commands to clone the sample project repository and change into the project directory.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-python-custom-step-template boltstep\n```\n\nLANGUAGE: shell\nCODE:\n```\ncd boltstep\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies\nDESCRIPTION: Lists required Python packages with version constraints. Includes Falcon web framework (v2.x), Gunicorn WSGI server (v20.x), and Uvicorn ASGI server.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/falcon/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfalcon>=2,<3\ngunicorn>=20,<21\nuvicorn\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables\nDESCRIPTION: Example of setting up environment variables for Slack app and bot tokens in the .env file.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nSLACK_APP_TOKEN=<your_app_token>\nSLACK_BOT_TOKEN=<your_bot_token>\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for macOS\nDESCRIPTION: Commands to set environment variables for bot and app tokens, along with API keys for OpenAI and Anthropic on macOS.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_BOT_TOKEN=<your-bot-token>\nexport SLACK_APP_TOKEN=<your-app-token>\nexport OPENAI_API_KEY=<your-api-key>\nexport ANTHROPIC_API_KEY=<your-api-key>\n```\n\n----------------------------------------\n\nTITLE: Running Bolt Python App\nDESCRIPTION: Shell command to run the Bolt Python app using the Python interpreter.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\npython3 app.py\n```\n\n----------------------------------------\n\nTITLE: Specifying CherryPy Version Dependency for Bolt-Python Application\nDESCRIPTION: This dependency specification requires CherryPy version 18.x.x (greater than or equal to 18, but less than 19). CherryPy is a Python web framework that's likely used to handle HTTP requests in the Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/cherrypy/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCherryPy>=18,<19\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Windows\nDESCRIPTION: Commands to set environment variables for bot and app tokens, along with API keys for OpenAI and Anthropic on Windows.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nset SLACK_BOT_TOKEN=<your-bot-token>\nset SLACK_APP_TOKEN=<your-app-token>\nset OPENAI_API_KEY=<your-api-key>\nset ANTHROPIC_API_KEY=<your-api-key>\n```\n\n----------------------------------------\n\nTITLE: Setting Slack App Token Environment Variable\nDESCRIPTION: Shell command to set the Slack app-level token as an environment variable for secure access.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nexport SLACK_APP_TOKEN=<your-app-level-token>\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for macOS\nDESCRIPTION: Commands to set required environment variables including Slack tokens and JIRA credentials on macOS\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_BOT_TOKEN=<your-bot-token>\nexport SLACK_APP_TOKEN=<your-app-token>\nexport JIRA_CLIENT_ID=<client-id>\nexport JIRA_CLIENT_SECRET=<client-secret>\n```\n\n----------------------------------------\n\nTITLE: Flask Version Dependency Specification\nDESCRIPTION: Version requirement specification indicating Flask version must be greater than 1.0. This is typically used in requirements or dependency configuration files.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/flask/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nFlask>1\n```\n\n----------------------------------------\n\nTITLE: Starting Python Virtual Environment for Windows\nDESCRIPTION: Commands to create and activate Python virtual environment on Windows\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npy -m venv .venv\n.venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Middleware for Authentication in Bolt for Python\nDESCRIPTION: This code demonstrates how to create a global middleware function that authenticates users against an external system. It captures the Slack user ID from the payload, looks up the user in an external system, and stores the result in the context. If authentication fails, it sends an ephemeral message to the user.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/global-middleware.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@app.use\ndef auth_abc(client, context, logger, payload, next):\n    slack_user_id = payload[\"user\"]\n    help_channel_id = \"C12345\"\n\n    try:\n        # Slack のユーザー ID を使って外部のシステムでユーザーを検索します\n        user = abc.lookup_by_id(slack_user_id)\n        # 結果を context に保存します\n        context[\"user\"] = user\n    except Exception:\n        client.chat_postEphemeral(\n            channel=payload[\"channel\"],\n            user=slack_user_id,\n            text=f\"Sorry <@{slack_user_id}>, you aren't registered in ABC or there was an error with authentication.Please post in <#{help_channel_id}> for assistance\"\n        )\n\n    # 次のミドルウェアに実行権を渡します\n    next()\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies\nDESCRIPTION: Command to install required Python packages from requirements.txt\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Pyramid Framework Version Constraint\nDESCRIPTION: Defines the acceptable version range for the Pyramid web framework dependency. Allows versions greater than or equal to 1.0 but less than 2.0.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/pyramid/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: requirements.txt\nCODE:\n```\npyramid>=1,<2\n```\n\n----------------------------------------\n\nTITLE: Cloning Project Repository\nDESCRIPTION: Command to clone the starter template repository for the JIRA integration project\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-python-jira-functions.git\n```\n\n----------------------------------------\n\nTITLE: Installing Latest Node Version with NVM\nDESCRIPTION: Command to install the latest version of Node using NVM. Docusaurus requires at least Node 18.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnvm install node\n```\n\n----------------------------------------\n\nTITLE: Verifying Python Virtual Environment Activation\nDESCRIPTION: Shell command to confirm that the Python virtual environment is active by checking the Python path.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/getting-started.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nwhich python3\n# Output: /path/to/first-bolt-app/.venv/bin/python3\n```\n\n----------------------------------------\n\nTITLE: Starting Local Docusaurus Development Server\nDESCRIPTION: NPM command to start a local development server for the Docusaurus site, which opens a browser window and supports live updates.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for slackapi/bolt-python\nDESCRIPTION: This snippet lists the required Python packages and their specific versions for the project. It includes mypy for type checking, flake8 for linting, and black for code formatting. The comment indicates that the black version is pinned due to Python 3.6 support constraints.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/tools.txt#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nmypy==1.15.0\nflake8==7.2.0\nblack==24.8.0             # Until we drop Python 3.6 support, we have to stay with this version\n```\n\n----------------------------------------\n\nTITLE: Installing Package Dependencies\nDESCRIPTION: Command to install the necessary package dependencies for the Bolt app.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Specifying Version Constraints for FastAPI and Uvicorn\nDESCRIPTION: This snippet defines version constraints for FastAPI and Uvicorn packages. It ensures that versions less than 1.0 are used for both dependencies, likely to maintain compatibility with the project.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/fastapi/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfastapi<1\nuvicorn<1\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for Slack Bolt\nDESCRIPTION: Commands to set up a Python virtual environment and install required dependencies for the Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-existing.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m venv .venv \nsource .venv/bin/activate \npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Required IAM Permissions for Lambda-based Lazy Listeners\nDESCRIPTION: JSON configuration defining the IAM permissions required for a Lambda function to execute lazy listeners. The function needs lambda:InvokeFunction and lambda:GetFunction permissions.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/concepts/lazy-listeners.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"lambda:InvokeFunction\",\n                \"lambda:GetFunction\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the Starter Template\nDESCRIPTION: Command to clone the bolt-python-ai-chatbot repository which serves as the starter template for the project.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-python-ai-chatbot.git\n```\n\n----------------------------------------\n\nTITLE: Creating IAM Policy JSON for S3 Bucket Access\nDESCRIPTION: This JSON defines an IAM policy that grants Get, Put, and Delete permissions on specified S3 buckets, which will be used to store Slack installation data and OAuth state.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/aws_lambda/README.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:Get*\",\n                \"s3:Put*\",\n                \"s3:Delete*\",\n                \"s3-object-lambda:*\"\n            ],\n            \"Resource\": [\n                \"<your-first-bucket-arn>/*\",   // don't forget the `/*`\n                \"<your-second-bucket-arn>/*\"\n            ]\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Function Runtime for Existing Slack Apps\nDESCRIPTION: JSON configuration to set the function runtime for existing Slack apps when adding custom workflow steps. This setting is required in the app manifest.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"settings\": {\n\t...\n\t\"function_runtime\": \"remote\"\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Local Server\nDESCRIPTION: Command to start the local Python server running the Bolt application\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-for-jira.md#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npython app.py\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Command to start the local development server for the Bolt app.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/custom-steps-workflow-builder-new.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Responding to Actions Using say() Method in Python\nDESCRIPTION: This snippet illustrates how to respond to an action using the say() method, which sends a message to the conversation where the action occurred. It shows acknowledging the action and then sending a response message.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/actions.md#2025-04-17_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# 'approve_button' という action_id のインタラクティブコンポーネントがトリガーされると、このリスナーが呼ばれる\n@app.action(\"approve_button\")\ndef approve_request(ack, say):\n    # アクションのリクエストを確認\n    ack()\n    say(\"Request approved 👍\")\n```\n\n----------------------------------------\n\nTITLE: Changing to Project Directory\nDESCRIPTION: Command to navigate into the project directory after cloning the repository.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/tutorial/ai-chatbot.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd bolt-python-ai-chatbot\n```\n\n----------------------------------------\n\nTITLE: Listening for Actions with Simple Action ID in Python\nDESCRIPTION: This snippet demonstrates how to listen for a button click action with a specific action_id using the Bolt for Python framework. It shows the basic structure of an action listener, including the necessary acknowledgment.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/actions.md#2025-04-17_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# 'approve_button' という action_id のブロックエレメントがトリガーされるたびに、このリスナーが呼び出させれる\n@app.action(\"approve_button\")\ndef update_message(ack):\n    ack()\n    # アクションへの反応としてメッセージを更新\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Bolt-Python Documentation Website\nDESCRIPTION: A detailed file tree showing the organization of the Docusaurus website including documentation, translations, static assets, and configuration files.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nwebsite/\n├── docs/ (the good stuff. md and mdx files supported)\n│   ├── getting-started.md\n│   └── concepts\n│       └── sending-message.md\n├── i18n/ja/ (the japanese translations)\n│   ├──docusaurus-theme-classic/ (footer/navbar translations)\n│   └──docusaurus-plugin-content-docs/\n│       └── current/ ( file names need to exactly match **/docs/, but japanese content)\n│           ├── getting-started.md\n│           └── concepts\n│               └── sending-message.md\n├── static/\n│   ├── css/\n│   │   └── custom.css (the css for everything!)\n│   ├── img/ (the pictures for the site)\n│   │   ├── rory.png \n│   │   └── oslo.svg \n│   └── api-docs/slack_bolt (the generated reference docs with their own HTML/CSS)\n│       ├── index.html \n│       └── adaptor \n│           └── index.html \n├── src/\n│   ├── pages/ (stuff that isn't docs. This is empty for this repo!)\n│   └── theme/ (only contains the 404 page)\n├── docusaurus.config.js (main config file)\n├── footerConfig.js (footer. go to main repo to change)\n├── navbarConfig.js (navbar. go to main repo to change)\n└── sidebar.js (manually set where the docs are in the sidebar.)\n```\n\n----------------------------------------\n\nTITLE: Custom Step Manifest Configuration in JSON\nDESCRIPTION: JSON configuration for the custom step in the app manifest, defining input and output parameters with their types and requirements.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-steps.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"sample_custom_step\": {\n        \"title\": \"Sample custom step\",\n        \"description\": \"Run a sample custom step\",\n        \"input_parameters\": {\n            \"message\": {\n                \"type\": \"string\",\n                \"title\": \"Message\",\n                \"description\": \"A message to be formatted by the custom step\",\n                \"is_required\": true,\n            }\n        },\n        \"output_parameters\": {\n            \"message\": {\n                \"type\": \"string\",\n                \"title\": \"Messge\",\n                \"description\": \"A formatted message\",\n                \"is_required\": true,\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Custom Step Manifest Configuration in JSON\nDESCRIPTION: JSON configuration for the interactive custom step in the app manifest, defining user ID input and output parameters.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-steps.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"custom_step_button\": {\n        \"title\": \"Custom step with a button\",\n        \"description\": \"Custom step that waits for a button click\",\n        \"input_parameters\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"The recipient of a message with a button\",\n                \"is_required\": true,\n            }\n        },\n        \"output_parameters\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"The user that completed the function\",\n                \"is_required\": true\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Docusaurus Project\nDESCRIPTION: NPM command to install required packages for the Docusaurus project, necessary before running the site locally for the first time.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing NVM for Node Management\nDESCRIPTION: Command to install Node Version Manager (NVM), which is required to manage Node versions for Docusaurus development.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Running Local Development Server in Japanese\nDESCRIPTION: Command to start the local development server for the Japanese version of the documentation site.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start -- --locale ja-jp\n```\n\n----------------------------------------\n\nTITLE: Example of Translation JSON Format\nDESCRIPTION: Example of how UI elements are translated using JSON objects with message and description fields in the docusaurus-theme-classic folder.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n{\n  \"item.label.Hello\": {\n    \"message\": \"こんにちは\",\n    \"description\": \"The title of the page\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: This snippet lists the required Python packages and their version constraints for the project. It includes Slack Bolt version 0.6 or higher, Flask version greater than 1, and SQLAlchemy with no specific version requirement.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/sqlalchemy/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nslack_bolt>=0.6\nFlask>1\nSQLAlchemy\n```\n\n----------------------------------------\n\nTITLE: Importing Slack SDK Module in Python\nDESCRIPTION: This snippet imports the slack_sdk module, which provides the necessary tools and functions to interact with Slack's API. This import statement is typically used at the beginning of a Python script or module that requires Slack functionality.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/examples/aws_chalice/requirements.txt#2025-04-17_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nslack_sdk\n```\n\n----------------------------------------\n\nTITLE: Email Contact Information in Markdown\nDESCRIPTION: Markdown formatted email link for Slack developer support contact\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/content/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nsupport@slack.com\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages and Starting Sanic Server\nDESCRIPTION: This bash snippet shows the commands to install necessary packages and start a Sanic server on port 3000 for a Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/async.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# 必要なパッケージをインストールします\npip install slack_bolt sanic uvicorn\n# ソースファイルを async_app.py として保存します\nuvicorn async_app:api --reload --port 3000 --log-level debug\n```\n\n----------------------------------------\n\nTITLE: Installing Testing Dependencies for Slack Bolt Python Adapters\nDESCRIPTION: Specifies required Python packages for testing Slack Bolt adapters. Includes moto for AWS mocking, docker for container support, boddle for Bottle framework testing, and sanic-testing for Sanic framework tests (Python >3.6 only).\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/requirements/adapter_testing.txt#2025-04-17_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n# pip install -r requirements/adapter_testing.txt\nmoto>=3,<6                               # For AWS tests\ndocker>=5,<8                             # Used by moto\nboddle>=0.2,<0.3                         # For Bottle app tests\nsanic-testing>=0.7; python_version>\"3.6\"\n```\n\n----------------------------------------\n\nTITLE: Building Static Content for Deployment\nDESCRIPTION: NPM command to generate static content into the build directory for deployment.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/README.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Running Docusaurus in Japanese Locale\nDESCRIPTION: Command to start the Docusaurus development server with the Japanese locale for testing the Japanese version of the documentation site.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start -- --locale ja-jp\n```\n\n----------------------------------------\n\nTITLE: Example of code.json Translation\nDESCRIPTION: Example of a translation entry in code.json for common UI elements provided by Docusaurus, showing how to translate the copy button label on code blocks.\nSOURCE: https://github.com/slackapi/bolt-python/blob/main/docs/i18n/ja-jp/README.md#2025-04-17_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n  \"theme.CodeBlock.copy\": {\n    \"message\": \"コピー\",\n    \"description\": \"The copy button label on code blocks\"\n  },\n```"
  }
]