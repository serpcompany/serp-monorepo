[
  {
    "owner": "samchon",
    "repo": "typia",
    "content": "TITLE: Basic Typia Type Assertion\nDESCRIPTION: Simple example showing Typia's type assertion using pure TypeScript type IBbsArticle.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntypia.assert<IBbsArticle>(article);\n```\n\n----------------------------------------\n\nTITLE: Typia Core API Overview in TypeScript\nDESCRIPTION: Summary of the main API functions provided by typia, including runtime validators, JSON functions, LLM function calling schema generators, Protocol Buffer utilities, and random data generators.\nSOURCE: https://github.com/samchon/typia/blob/master/README.md#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n\n// JSON FUNCTIONS\nexport namespace json {\n  export function application<T>(): IJsonApplication; // JSON schema\n  export function assertParse<T>(input: string): T; // type safe parser\n  export function assertStringify<T>(input: T): string; // safe and faster\n}\n\n// LLM FUNCTION CALLING SCHEMA\nexport namespace llm {\n  // application schema from a class or interface type\n  export function application<App, Model>(): ILlmApplication<Model>;\n  // structured output\n  export function parameters<P, Model>(): ILlmSchema.IParameters<Model>; \n  export function schema<T, Model>(): ILlmSchema<Model>; // type schema\n}\n\n// PROTOCOL BUFFER\nexport namespace protobuf {\n  export function message<T>(): string; // Protocol Buffer message\n  export function assertDecode<T>(buffer: Uint8Array): T; // safe decoder\n  export function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\n```\n\n----------------------------------------\n\nTITLE: Defining LLM Schema Types and Interfaces in TypeScript\nDESCRIPTION: Implements a comprehensive type system for LLM function calling schemas. Includes type definitions for different LLM providers like ChatGPT, Claude, Gemini, and Llama, along with their respective configurations and parameters. The code uses TypeScript's advanced type features including generics, namespaces, and union types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/ILlmSchemaSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IChatGptSchema } from \"./IChatGptSchema\";\nimport { IClaudeSchema } from \"./IClaudeSchema\";\nimport { IGeminiSchema } from \"./IGeminiSchema\";\nimport { ILlamaSchema } from \"./ILlamaSchema\";\nimport { ILlmSchemaV3 } from \"./ILlmSchemaV3\";\nimport { ILlmSchemaV3_1 } from \"./ILlmSchemaV3_1\";\n\n/**\n * The schemas for the LLM function calling.\n *\n * `ILlmSchema` is an union type collecting every the schemas for the\n * LLM function calling.\n *\n * Select a proper schema type according to the LLM provider you're using.\n *\n * @template Model Name of the target LLM model\n * @reference https://platform.openai.com/docs/guides/function-calling\n * @reference https://platform.openai.com/docs/guides/structured-outputs\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type ILlmSchema<Model extends ILlmSchema.Model = ILlmSchema.Model> =\n  ILlmSchema.ModelSchema[Model];\n\nexport namespace ILlmSchema {\n  export type Model = \"chatgpt\" | \"claude\" | \"gemini\" | \"llama\" | \"3.0\" | \"3.1\";\n  export interface ModelConfig {\n    chatgpt: IChatGptSchema.IConfig;\n    claude: IClaudeSchema.IConfig;\n    gemini: IGeminiSchema.IConfig;\n    llama: ILlamaSchema.IConfig;\n    \"3.0\": ILlmSchemaV3.IConfig;\n    \"3.1\": ILlmSchemaV3_1.IConfig;\n  }\n  export interface ModelParameters {\n    chatgpt: IChatGptSchema.IParameters;\n    claude: IClaudeSchema.IParameters;\n    gemini: IGeminiSchema.IParameters;\n    llama: ILlamaSchema.IParameters;\n    \"3.0\": ILlmSchemaV3.IParameters;\n    \"3.1\": ILlmSchemaV3_1.IParameters;\n  }\n  export interface ModelSchema {\n    chatgpt: IChatGptSchema;\n    claude: IClaudeSchema;\n    gemini: IGeminiSchema;\n    llama: ILlamaSchema;\n    \"3.0\": ILlmSchemaV3;\n    \"3.1\": ILlmSchemaV3_1;\n  }\n\n  /**\n   * Type of function parameters.\n   *\n   * `ILlmSchema.IParameters` is a type defining a function's pamameters\n   * as a keyworded object type.\n   *\n   * It also can be utilized for the structured output metadata.\n   *\n   * @reference https://platform.openai.com/docs/guides/structured-outputs\n   */\n  export type IParameters<Model extends ILlmSchema.Model = ILlmSchema.Model> =\n    ILlmSchema.ModelParameters[Model];\n\n  /**\n   * Configuration for the LLM schema composition.\n   */\n  export type IConfig<Model extends ILlmSchema.Model = ILlmSchema.Model> =\n    ILlmSchema.ModelConfig[Model];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the assert() Function and TypeGuardError in typia\nDESCRIPTION: Declaration of the assert() function in typia which validates a value against a type, and the TypeGuardError class which provides detailed error information when validation fails.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function assert<T>(input: T): T;\nexport function assert<T>(input: unknown): T;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Typia Pure TypeScript Interface Definition\nDESCRIPTION: Pure TypeScript interface definitions used by Typia, showing how validation can be achieved without extra decorators or schema definitions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing LLM Application with Typia for BBS Article Service and ChatGPT\nDESCRIPTION: This snippet creates an LLM application using Typia, configuring it for a BBS Article Service and specifically for use with ChatGPT. It demonstrates type inference and LLM integration in TypeScript.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationExampleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nimport { BbsArticleService } from \"./BbsArticleService\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleService,\n  \"chatgpt\"\n>();\nconsole.log(app);\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Parse Functions in Typia\nDESCRIPTION: Exports namespace 'json' with three type-safe parsing functions: isParse, assertParse, and validateParse that handle JSON strings with type validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace json {\n  export function isParse<T>(input: string): Primitive<T> | null;\n  export function assertParse<T>(input: string): Primitive<T>;\n  export function validateParse<T>(input: string): IValidation<Primitive<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Validation Tags in TypeScript with typia\nDESCRIPTION: Example of creating custom type tags for validation in typia. This code defines three custom tags: Dollar (validates dollar amount strings), Postfix (validates strings with specific endings), and IsEven (validates even numbers), and implements them in a Something interface for validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const assertSomething = typia.createAssert<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;  \n}>\n\ntype Postfix<Value extends string> = tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\n  kind: \"isEven\";\n  target: Value extends number ? \"number\" : \"bigint\";\n  value: undefined;\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>\n\ntype Numeric<Value extends number | bigint> = Value extends number \n  ? Value\n  : `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\n  dollar: string & Dollar;\n  postfix: string & Postfix<\"!!!\">;\n  isEven: number & IsEven<number>;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Code for Type Assertion\nDESCRIPTION: This snippet shows the generated TypeScript code that implements the type assertion defined in the source file. It includes detailed type checking logic for the IMember interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = (input: any): input is IMember => {\n  const $is_uuid = (typia.createIs as any).is_uuid;\n  const $is_email = (typia.createIs as any).is_email;\n  return (\n    \"object\" === typeof input &&\n    null !== input &&\n    \"string\" === typeof input.id &&\n    $is_uuid(input.id) &&\n    \"string\" === typeof input.email &&\n    $is_email(input.email) &&\n    \"number\" === typeof input.age &&\n    19 <= input.age &&\n    100 >= input.age\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Defining BBS Article Creation and Update Schema in JSON\nDESCRIPTION: Comprehensive JSON schema that defines two main operations for a BBS system: article creation and article updating. The schema includes detailed specifications for input parameters, output format, and validation rules for article properties like title, body, and thumbnail.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationSeparateJsonSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"model\": \"claude\",\n  \"options\": {\n    \"reference\": false\n  },\n  \"functions\": [\n    {\n      \"name\": \"create\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"input\": {\n            \"description\": \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            \"type\": \"object\",\n            \"properties\": {\n              \"title\": {\n                \"title\": \"Title of the article\",\n                \"description\": \"Title of the article.\\n\\nRepresentative title of the article.\",\n                \"type\": \"string\"\n              },\n              \"body\": {\n                \"title\": \"Content body\",\n                \"description\": \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                \"type\": \"string\"\n              },\n              \"thumbnail\": {\n                \"title\": \"Thumbnail image URI\",\n                \"description\": \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                \"oneOf\": [\n                  {\n                    \"type\": \"null\"\n                  },\n                  {\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"contentMediaType\": \"image/*\"\n                  }\n                ]\n              }\n            },\n            \"required\": [\n              \"title\",\n              \"body\",\n              \"thumbnail\"\n            ]\n          }\n        },\n        \"required\": [\n          \"input\"\n        ],\n        \"additionalProperties\": false,\n        \"$defs\": {}\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Typia Core API Functions\nDESCRIPTION: Overview of Typia's main API functions including runtime validators, JSON handlers, LLM function calling schema, Protocol Buffer operations, and random data generation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/index.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function assertGuard<T>(input: unknown): asserts input is T;\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n\n// JSON FUNCTIONS\nexport namespace json {\n  export function application<T>(): IJsonApplication; // JSON schema\n  export function assertParse<T>(input: string): T; // type safe parser\n  export function assertStringify<T>(input: T): string; // safe and faster\n}\n\n// LLM FUNCTION CALLING SCHEMA\nexport namespace llm {\n  // application schema from a class or interface type\n  export function application<App, Model>(): ILlmApplication<Model>;\n  // structured output\n  export function parameters<P, Model>(): ILlmSchema.IParameters<Model>; \n  export function schema<T, Model>(): ILlmSchema<Model>; // type schema\n}\n\n// PROTOCOL BUFFER\nexport namespace protobuf {\n  export function message<T>(): string; // Protocol Buffer message\n  export function assertDecode<T>(buffer: Uint8Array): T; // safe decoder\n  export function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\n```\n\n----------------------------------------\n\nTITLE: TypeScript Configuration for typia\nDESCRIPTION: tsconfig.json configuration for enabling typia transformation. Requires strict mode and plugin configuration to enable the transformation process.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"strictNullChecks\": true, \n    \"plugins\": [\n      { \"transform\": \"typia/lib/transform\" }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Assertion Function Implementation in TypeScript\nDESCRIPTION: Implements a type assertion function that validates object properties including string type checking, pattern matching, and maximum length validation. Contains error handling logic and custom error factory support.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexpected: \"string & MaxLength<8>\",\nvalue: input.extension,\n},\n_errorFactory,\n))) ||\n__typia_transform__assertGuard._assertGuard(\n  _exceptionable,\n  {\n    method: \"typia.createAssert\",\n    path: _path + \".extension\",\n    expected: '((string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<8>) | null)',\n    value: input.extension,\n  },\n  _errorFactory,\n)) &&\n(\"string\" === typeof input.url ||\n  __typia_transform__assertGuard._assertGuard(\n    _exceptionable,\n    {\n      method: \"typia.createAssert\",\n      path: _path + \".url\",\n      expected: \"string\",\n      value: input.url,\n    },\n    _errorFactory,\n));\nconst __is = (input) =>\n  \"object\" === typeof input && null !== input && _io0(input);\nlet _errorFactory;\nreturn (input, errorFactory) => {\n  if (false === __is(input)) {\n    _errorFactory = errorFactory;\n    ((input, _path, _exceptionable = true) =>\n      ((\"object\" === typeof input && null !== input) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"IBbsArticle\",\n            value: input,\n          },\n          _errorFactory,\n        )) &&\n        _ao0(input, _path + \"\", true)) ||\n      __typia_transform__assertGuard._assertGuard(\n        true,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \"\",\n          expected: \"IBbsArticle\",\n          value: input,\n        },\n        _errorFactory,\n      ))(input, \"$input\", true);\n  }\n  return input;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Bulletin Board Article Interface and Schema with Typia\nDESCRIPTION: Defines a TypeScript interface for bulletin board articles with detailed field documentation and type constraints. Uses typia to generate a ChatGPT-compatible schema with UUID, date-time formats, and image URI validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmSchemaExampleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst $defs: Record<string, IChatGptSchema> = {};\nexport const schema: IChatGptSchema = typia.llm.schema<\n  IBbsArticle, \n  \"chatgpt\",\n  { reference: true }\n>({\n  $defs,\n});\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\ninterface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Title of the article.\n   *\n   * Representative title of the article.\n   */\n  title: string;\n\n  /**\n   * Content body.\n   *\n   * Content body of the article writtn in the markdown format.\n   */\n  body: string;\n\n  /**\n   * Thumbnail image URI.\n   *\n   * Thumbnail image URI which can represent the article.\n   *\n   * If configured as `null`, it means that no thumbnail image in the article.\n   */\n  thumbnail:\n    | null\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BBS Article Service Class in TypeScript\nDESCRIPTION: A comprehensive implementation of a bulletin board service class with CRUD operations. Uses UUID for article identification and includes type-safe operations with TypeScript interfaces. The service maintains an in-memory array of articles and provides methods for listing, creating, updating, and deleting articles.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/BbsArticleServiceSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport class BbsArticleService {\n  private readonly articles: IBbsArticle[] = [];\n\n  /**\n   * Get all articles.\n   *\n   * List up every articles archived in the BBS DB.\n   *\n   * @returns List of every articles\n   */\n  public index(): IBbsArticle[] {\n    return this.articles;\n  }\n\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  public create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): IBbsArticle {\n    const article: IBbsArticle = {\n      id: v4(),\n      title: props.input.title,\n      body: props.input.body,\n      thumbnail: props.input.thumbnail,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n    this.articles.push(article);\n    return article;\n  }\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  public update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): void {\n    const article: IBbsArticle | undefined = this.articles.find(\n      (a) => a.id === props.id,\n    );\n    if (article === undefined)\n      throw new Error(\"Unable to find the matched article.\");\n    if (props.input.title !== undefined) article.title = props.input.title;\n    if (props.input.body !== undefined) article.body = props.input.body;\n    if (props.input.thumbnail !== undefined)\n      article.thumbnail = props.input.thumbnail;\n    article.updated_at = new Date().toISOString();\n  }\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  public erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): void {\n    const index: number = this.articles.findIndex((a) => a.id === props.id);\n    if (index === -1) throw new Error(\"Unable to find the matched article.\");\n    this.articles.splice(index, 1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Typia's TypeScript Transformation Capability\nDESCRIPTION: Example of how typia transforms TypeScript type validators into runtime functions during compilation. The example shows a simple string validator being transformed from TypeScript to JavaScript.\nSOURCE: https://github.com/samchon/typia/blob/master/README.md#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n\n//----\n// examples/checkUUID.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Package.json Configuration for typia\nDESCRIPTION: package.json configuration with prepare script to install ts-patch. Also shows the dependency versions for typia, ts-patch, and typescript.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"prepare\": \"ts-patch install\"\n  },\n  \"dependencies\": {\n    \"typia\": \"^6.0.6\"\n  },\n  \"devDependencies\": {\n    \"ts-patch\": \"^3.2.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Type Checking in TypeScript\nDESCRIPTION: Defines the isFunction namespace and related type checking functions in typia. The implementation allows for checking both function parameters and return values, with support for Promise return types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace functional {\n  export function isFunction<T extends (...args: any[]) => any>(\n    func: T,\n  ): T extends (...args: infer Arguments) => infer Output\n    ? Output extends Promise<infer R>\n      ? (...args: Arguments) => Promise<R | null>\n      : (...args: Arguments) => Output | null\n    : never;\n  export function isParameters;\n  export function isReturn;\n\n  export function isEqualsFunction;\n  export function isEqualsParameters;\n  export function isEqualsReturn;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Output from typia's AOT Compilation\nDESCRIPTION: The JavaScript code generated by typia's AOT compilation process. It shows the optimized validation logic with detailed error handling that checks each property against its type constraints.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nimport { v4 } from \"uuid\";\n(() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.assert\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.assert\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.assert\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.assert\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})()({{\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 18, // wrong, must be greater than 19\n}});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Tags for Enhanced Validation in TypeScript\nDESCRIPTION: This snippet demonstrates how to use type tags and comment tags in TypeScript to define custom validation rules for various data types. It includes examples of integer validation, range checks, string patterns, and complex array and map validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\n  /**\n   * @type uint32\n   */\n  type: number;\n\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\n  /**\n   * @minLength 3\n   */\n  string: string;\n\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n\n  /**\n   * Type tag can perform union type.\n   *\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\n   */\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\n\n  /**\n   * In the Array case, only type tag can restrict element type.\n   */\n  array: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n\n  /**\n   * Also, only type tag can handle map type.\n   */\n  map: Map<\n    number & tags.Type<\"uint32\">,\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n  >;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Validation with typia Transformation\nDESCRIPTION: Example of AOT (Ahead of Time) compilation with typia. Shows the TypeScript source code with type definition and validation rules using tags for format and range validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const check = typia.createIs<IMember>();\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comment Tag Validation in TypeScript\nDESCRIPTION: Demonstrates the use of comment tags for type validation using typia. Shows how to define custom validation rules for numbers, strings and patterns using JSDoc-style comments. Includes examples of limitations with union types, arrays, and maps.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\n  /**\n   * @type uint32\n   */\n  type: number;\n\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n\n  /**\n   * @minLength 3\n   */\n  string: string;\n\n  /**\n   * @Pattern /^[a-z]+$/\n   */\n  pattern: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BBS Article Controller Interface with TypeScript and Typia\nDESCRIPTION: Implements a bulletin board system controller interface with create, update and erase operations using Typia's type system. Includes detailed type definitions for article creation, updates, and entity structure with proper validation tags.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication, ILlmFunction } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\nconst func: ILlmFunction<\"chatgpt\"> | undefined = app.functions.find(\n  func => func.name === \"create\"\n);\nconsole.log(func?.description);\n\ninterface BbsArticleController {\n  create(props: {\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n\n  update(props: {\n    id: string & tags.Format<\"uuid\">;\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n\n  erase(props: {\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\n\ninterface IBbsArticle extends IBbsArticle.ICreate {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n  updated_at: string & tags.Format<\"date-time\">;\n}\nnamespace IBbsArticle {\n  export interface ICreate {\n    title: string;\n    body: string;\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Specialized JSON Schema with Typia in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a specialized JSON schema using Typia. It includes various type tags and comment tags to define specific constraints and metadata for each property in the schema.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nexport const schema: IChatGptSchema = typia.llm.schema<Special, \"claude\">();\n\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n\n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n\n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n\n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n\n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n\n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\n```\n\n----------------------------------------\n\nTITLE: Transformed JavaScript Output\nDESCRIPTION: Compiled JavaScript code after typia's transformation. Shows how the TypeScript type validation gets transformed into runtime validation code with optimized checks.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport typia from \"typia\";\nexport const check = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    19 < input.age &&\n    input.age <= 100;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Typia Core Type Assertion Functions\nDESCRIPTION: Core type assertion function declarations in Typia, providing type checking and assertion capabilities for TypeScript types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport function createAssert<T>(): (input: unknown) => T;\nexport function createAssertEquals<T>(): (input: unknown) => T;\n\nexport function createAssertGuard<T>(): AssertionGuard<T>;\nexport function createAssertGuardEquals<T>(): AssertionGuard<T>;\n```\n\n----------------------------------------\n\nTITLE: Creating Random Data Generator Function in TypeScript\nDESCRIPTION: Defines a function to create a random data generator for a given type T. The generator can optionally use a custom IRandomGenerator.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function createRandom<T>(): (g?: IRandomGenerator) => Resolved<T>;\n```\n\n----------------------------------------\n\nTITLE: Initializing Agentica AI Agent with BbsArticleService\nDESCRIPTION: This snippet demonstrates how to create an Agentica AI agent using the BbsArticleService. It shows both a simplified pseudo code version and a more detailed real code implementation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/chat.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\n\nimport { BbsArticleService } from \"./BbsArticleService\";\n\nconst agent = new Agentica({\n  controllers: [\n    typia.llm.application<BbsArticleService>(),\n  ]\n});\nawait agent.conversate(\"Hello, I want to create an article.\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\n\nimport { BbsArticleService } from \"./BbsArticleService\";\n\nconst agent = new Agentica({\n  model: \"chatgpt\",\n  service: {\n    api: new OpenAI({ apiKey: \"*****\" }),\n    model: \"gpt-4o-mini\",\n  },\n  controllers: [\n    {\n      protocol: \"class\",\n      name: \"bbs\",\n      application: typia.llm.application<BbsArticleService>(),\n      execute: new BbsArticleService(),\n    },\n  ],\n});\nawait agent.conversate(\"Hello, I want to create an article.\");\n```\n\n----------------------------------------\n\nTITLE: Implementing LLM Namespace Functions in TypeScript\nDESCRIPTION: Defines three main functions in the llm namespace: application() for LLM function calling schemas, parameters() for structured output, and schema() for type schemas. Each function supports generic type parameters for customization.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/application.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Function Calls in ChatGPT LLM Application\nDESCRIPTION: This function validates and corrects function calls for a ChatGPT LLM application. It finds the matching function, validates the arguments, and handles errors by initiating a retry with feedback. The function supports multiple retry attempts with increasing success rates.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/ValidationFeedbackExampleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication, ILlmFunction, IValidation } from \"@samchon/openapi\";\nimport { FunctionCall } from \"pseudo\";\n\nexport const correctFunctionCall = (props: {\n  functionCall: FunctionCall;\n  application: ILlmApplication<\"chatgpt\">;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    props.application.functions.find((f) => f.name === call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return props.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(\n    props.functionCall.arguments,\n  );\n  if (result.success === false) {\n    // 1st trial: 30% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return props.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Random Function Signature in TypeScript\nDESCRIPTION: Core function signature for Typia's random data generator that accepts an optional IRandomGenerator parameter.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function random<T>(g?: IRandomGenerator): Resolved<T>;\n```\n\n----------------------------------------\n\nTITLE: Using validate() Function with Custom Interface in TypeScript\nDESCRIPTION: Demonstrates the usage of typia.validate() function with a custom IMember interface. It shows how to validate an object against the interface and handle validation errors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nconst res: typia.IValidation<IMember> = typia.validate<IMember>({\n  id: 5, // wrong, must be string (uuid)\n  age: 20.75, // wrong, not integer\n  email: \"samchon.github@gmail.com\",\n});\n\nif (!res.success) console.log(res.errors);\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Specializing LLM Schemas with Type Tags and Comments in TypeScript\nDESCRIPTION: This example demonstrates how to use type tags, comment tags, and description comments to create specialized fields in JSON schemas for LLM applications. It showcases various property types and their corresponding schema representations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nexport const schema: IChatGptSchema = typia.llm.schema<Special, \"claude\">({\n  $defs: {},\n});\n\ninterface Special {\n  /**\n   * Deprecated tags are just used for marking.\n   *\n   * @title Unsigned integer\n   * @deprecated\n   */\n  type: number & tags.Type<\"int32\">;\n\n  /**\n   * Internal tagged property never be shown in JSON schema.\n   *\n   * It even doesn't be shown in other `typia` functions like `assert<T>()`.\n   *\n   * @internal\n   */\n  internal: number[];\n\n  /**\n   * Hidden tagged property never be shown in JSON schema.\n   *\n   * However, it would be shown in other `typia` functions like `stringify<T>()`.\n   *\n   * @hidden\n   */\n  hidden: boolean;\n\n  /**\n   * You can limit the range of number.\n   *\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n\n  /**\n   * You can limit the length of string.\n   *\n   * Also, multiple range conditions are also possible.\n   */\n  string: string &\n    (\n      | (tags.MinLength<3> & tags.MaxLength<24>)\n      | (tags.MinLength<40> & tags.MaxLength<100>)\n    );\n\n  /**\n   * You can limit the pattern of string.\n   *\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n\n  /**\n   * You can limit the format of string.\n   *\n   * @format date-time\n   */\n  format: string | null;\n\n  /**\n   * In the Array case, possible to restrict its elements.\n   */\n  array: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing OpenAPI Specification and LLM Integration with Mermaid\nDESCRIPTION: This Mermaid flowchart illustrates the process of upgrading and normalizing OpenAPI specifications, and their integration with LLM function calling for various AI models including ChatGPT, Claude, Gemini, and Llama.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/chat.mdx#2025-04-20_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart\n  subgraph \"OpenAPI Specification\"\n    v20(\"Swagger v2.0\") --upgrades--> emended[[\"OpenAPI v3.1 (emended)\"]]\n    v30(\"OpenAPI v3.0\") --upgrades--> emended\n    v31(\"OpenAPI v3.1\") --emends--> emended\n  end\n  subgraph \"OpenAPI Generator\"\n    emended --normalizes--> migration[[\"Migration Schema\"]]\n    migration --\"Artificial Intelligence\"--> lfc{{\"LLM Function Calling\"}}\n    lfc --\"OpenAI\"--> chatgpt(\"ChatGPT\")\n    lfc --\"Anthropic\"--> claude(\"Claude\")\n    lfc --\"Google\"--> gemini(\"Gemini\")\n    lfc --\"Meta\"--> llama(\"Llama\")\n  end\n```\n\n----------------------------------------\n\nTITLE: Random Generator Interface Definition\nDESCRIPTION: Comprehensive interface definition for random data generation, including methods for primitive types, arrays, and formatted strings like emails, UUIDs, and timestamps.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Customizable } from \"./typings/Customizable\";\n\nexport interface IRandomGenerator {\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n\n  customs?: IRandomGenerator.CustomMap;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Function Assertion APIs in typia\nDESCRIPTION: Defines the functional namespace in typia with multiple function assertion APIs that can validate function parameters and return values in different ways.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace functional {\n  export function assertFunction<T extends Function>(func: T): T;\n  export function assertParameters<T extends Function>(func: T): T;\n  export function assertReturn<T extends Function>(func: T): T;\n\n  export function assertEqualsFunction<T extends Function>(func: T): T;\n  export function assertEqualsParameters<T extends Function>(func: T): T;\n  export function assertEqualsReturn<T extends Function>(func: T): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NestJS Controller with Nestia Decorators\nDESCRIPTION: Example of a NestJS controller using Nestia's TypedRoute and TypedBody decorators for enhanced performance and type safety. The controller handles BBS article storage with automatic validation and JSON serialization optimizations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/utilization/nestjs.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Controller } from \"@nestjs/common\";\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\n\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Store a new content.\n   *\n   * @param input Content to store\n   * @returns Newly archived article\n   */\n  @TypedRoute.Post() // 200x faster and safer JSON.stringify()\n  public async store(\n    @TypedBody() input: IBbsArticle.IStore, // 20,000x faster validator\n  ): Promise<IBbsArticle>;\n    // do not need DTO class definition,\n    // just fine with interface\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LLM Function Interface in TypeScript\nDESCRIPTION: Defines an interface for LLM function metadata including name, parameters, validation, and output schema. Includes support for parameter separation between LLM and human inputs, along with comprehensive validation capabilities for handling LLM-generated arguments.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/ILlmFunctionSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmSchema } from \"./ILlmSchema\";\nimport { IValidation } from \"./IValidation\";\n\nexport interface ILlmFunction<Model extends ILlmSchema.Model> {\n  name: string;\n  parameters: ILlmSchema.ModelParameters[Model];\n  separated?: ILlmFunction.ISeparated<Model>;\n  output?: ILlmSchema.ModelSchema[Model];\n  description?: string | undefined;\n  deprecated?: boolean | undefined;\n  tags?: string[] | undefined;\n  validate: (args: unknown) => IValidation<unknown>;\n}\n\nexport namespace ILlmFunction {\n  export interface ISeparated<Model extends ILlmSchema.Model> {\n    llm: ILlmSchema.ModelParameters[Model];\n    human: ILlmSchema.ModelParameters[Model] | null;\n    validate?: ((args: unknown) => IValidation<unknown>) | undefined;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using typia.llm.parameters() for OpenAI ChatGPT structured output\nDESCRIPTION: This example demonstrates how to use typia.llm.parameters() function to generate a structured output schema for OpenAI's ChatGPT API. It defines an IMember interface and uses it to create a JSON schema for the API request.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/parameters.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport OpenAI from \"openai\";\nimport typia, { tags } from \"typia\";\n\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\n\nconst main = async (): Promise<void> => {\n  const client: OpenAI = new OpenAI({\n    apiKey: TestGlobal.env.CHATGPT_API_KEY,\n    // apiKey: \"<YOUR_OPENAI_API_KEY>\",\n  });\n  const completion: OpenAI.ChatCompletion =\n    await client.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: [\n            \"I am a new member of the community.\",\n            \"\",\n            \"My name is John Doe, and I am 25 years old.\",\n            \"I like playing basketball and reading books,\",\n            \"and joined to this community at 2022-01-01.\",\n          ].join(\"\\n\"),\n        },\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"member\",\n          schema: typia.llm.parameters<IMember, \"chatgpt\">() as any,\n        },\n      },\n    });\n  console.log(JSON.parse(completion.choices[0].message.content!));\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Creating Assert Function for BBS Article\nDESCRIPTION: Creates an assert function for the IBbsArticle interface using typia's createAssert method.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport const assertArticle = typia.createAssert<IBbsArticle>();\n```\n\n----------------------------------------\n\nTITLE: Validating Hono Request Body with Typia\nDESCRIPTION: Example showing how to set up request body validation in a Hono application using typia-validator middleware. The code demonstrates creating a validation function for an IBbsArticle type and applying it to a POST endpoint.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/utilization/hono.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Hono } from \"hono\";\nimport { typiaValidator } from '@hono/typia-validator'\nimport typia, { type tags } from \"typia\";\n\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n\n/** create a validate function */\nconst validate = typia.createValidate<IBbsArticle>();\n\nconst app = new Hono();\n\napp.post(\"/\",\n  typiaValidator('json', validate),\n  (c) => {\n    const data = c.req.valid(\"json\");\n    return c.json({\n      id: data.id,\n      title: data.title,\n      body: data.body,\n      created_at: data.created_at,\n    });\n  });\n\nexport default app;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Router with Typia Type Validation\nDESCRIPTION: Sets up a tRPC router with Typia type assertions for input and output validation. Creates an endpoint for storing BBS articles with automatic type checking and data transformation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/utilization/trpc.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from \"@trpc/server\";\nimport { v4 } from \"uuid\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n\nconst server = initTRPC.create();\n\nexport const appRouter = server.router({\n  store: server.procedure\n    .input(typia.createAssert<IBbsArticle.IStore>())\n    .output(typia.createAssert<IBbsArticle>())\n    .query(({ input }) => {\n      return {\n        id: v4(),\n        writer: input.writer,\n        title: input.title,\n        body: input.body,\n        created_at: new Date().toString(),\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Customizing LLM Schema with Custom Properties in TypeScript\nDESCRIPTION: Demonstrates how to add custom properties to LLM schema using TagBase.schema and JsonSchemaPlugin. Custom properties must start with 'x-' prefix according to LLM schema rules.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\n\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\n\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n\ntypia.llm.schema<IAccount, \"chatgpt\">();\n```\n\n----------------------------------------\n\nTITLE: Configuring LLM Application with Type Validation\nDESCRIPTION: Defines an application configuration for a bulletin board system with article management. Includes import statements for typia validation utilities and defines model specifications, options, and function definitions for article operations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationJavaScriptSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport * as __typia_transform__isFormatUri from \"typia/lib/internal/_isFormatUri.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"index\",\n      parameters: {\n        type: \"object\",\n        properties: {},\n        additionalProperties: false,\n        required: [],\n        $defs: {},\n      },\n      output: {\n        description: \"List of every articles\",\n        type: \"array\",\n        items: {\n          description: \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n          type: \"object\",\n          properties: {\n            id: {\n              title: \"Primary Key\",\n              description: \"Primary Key.\\n\\n\\n@format uuid\",\n              type: \"string\",\n            },\n            created_at: {\n              title: \"Creation time of the article\",\n              description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n              type: \"string\",\n            },\n            updated_at: {\n              title: \"Last updated time of the article\",\n              description: \"Last updated time of the article.\\n\\n\\n@format date-time\",\n              type: \"string\",\n            },\n            title: {\n              title: \"Title of the article\",\n              description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n              type: \"string\",\n            },\n            body: {\n              title: \"Content body\",\n              description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n              type: \"string\",\n            },\n            thumbnail: {\n              title: \"Thumbnail image URI\",\n              description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n              anyOf: [\n                {\n                  type: \"null\",\n                },\n                {\n                  type: \"string\",\n                  description: \"@format uri\\n@contentMediaType image/*\",\n                },\n              ],\n            },\n          },\n          required: [\n            \"id\",\n            \"created_at\",\n            \"updated_at\",\n            \"title\",\n            \"body\",\n            \"thumbnail\",\n          ],\n        },\n      },\n      description: \"Get all articles.\\n\\nList up every articles archived in the BBS DB.\",\n      validate: (() => {\n        const __is = (input) => true;\n        let errors;\n        let _report;\n        return (input) => {\n          if (false === __is(input)) {\n            errors = [];\n            _report = __typia_transform__validateReport._validateReport(errors);\n            ((input, _path, _exceptionable = true) => true)(\n              input,\n              \"$input\",\n              true,\n            );\n            const success = 0 === errors.length;\n            return success\n              ? {\n                  success,\n                  data: input,\n                }\n              : {\n                  success,\n                  errors,\n                  data: input,\n                };\n          }\n          return {\n            success: true,\n            data: input,\n          };\n        };\n      })(),\n    },\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description: \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description: \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description: \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description: \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n      validate: (() => {\n        const _io0 = (input) =>\n          \"object\" === typeof input.input &&\n          null !== input.input &&\n          _io1(input.input);\n        const _io1 = (input) =>\n          \"string\" === typeof input.title &&\n          \"string\" === typeof input.body &&\n          (null === input.thumbnail ||\n            (\"string\" === typeof input.thumbnail &&\n              __typia_transform__isFormatUri._isFormatUri(input.thumbnail)));\n        const _vo0 = (input, _path, _exceptionable = true) =>\n          [\n            ((\"object\" === typeof input.input && null !== input.input) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"IBbsArticle.ICreate\",\n                value: input.input,\n              })) &&\n              _vo1(input.input, _path + \".input\", true && _exceptionable)) ||\n              _report(_exceptionable, {\n                path: _path + \".input\",\n                expected: \"IBbsArticle.ICreate\",\n                value: input.input,\n              }),\n          ].every((flag) => flag);\n        const _vo1 = (input, _path, _exceptionable = true) =>\n          [\n            \"string\" === typeof input.title ||\n              _report(_exceptionable, {\n                path: _path + \".title\",\n                expected: \"string\",\n                value: input.title,\n              }),\n            \"string\" === typeof input.body ||\n              _report(_exceptionable, {\n                path: _path + \".body\",\n                expected: \"string\",\n                value: input.body,\n              }),\n            null === input.thumbnail ||\n              (\"string\" === typeof input.thumbnail &&\n                (__typia_transform__isFormatUri._isFormatUri(input.thumbnail) ||\n                  _report(_exceptionable, {\n                    path: _path + \".thumbnail\",\n                    expected: 'string & Format<\"uri\">',\n                    value: input.thumbnail,\n                  }))) ||\n              _report(_exceptionable, {\n                path: _path + \".thumbnail\",\n                expected:\n                  '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | null)',\n                value: input.thumbnail,\n              }),\n          ].every((flag) => flag);\n        const __is = (input) =>\n          \"object\" === typeof input && null !== input && _io0(input);\n        let errors;\n        let _report;\n        return (input) => {\n```\n\n----------------------------------------\n\nTITLE: Using typia.assert() with Tagged Types\nDESCRIPTION: Example of using typia.assert() with a typed interface that includes tag metadata for validation. The code demonstrates validating a member object with UUID, email format, and numeric range constraints.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 18, // wrong, must be greater than 19\n});\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Tag in TypeScript\nDESCRIPTION: This snippet defines a Type tag for various numeric types, including int32, uint32, int64, uint64, float, and double, with specific validation logic for each.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TagBase } from \"./TagBase\";\n\nexport type Type<\n  Value extends \"int32\" | \"uint32\" | \"int64\" | \"uint64\" | \"float\" | \"double\",\n> = TagBase<{\n  target: Value extends \"int64\" | \"uint64\" ? \"bigint\" | \"number\" : \"number\";\n  kind: \"type\";\n  value: Value;\n  validate: Value extends \"int32\"\n    ? `Math.floor($input) === $input && -2147483648 <= $input && $input <= 2147483647`\n    : Value extends \"uint32\"\n    ? `Math.floor($input) === $input && 0 <= $input && $input <= 4294967295`\n    : Value extends \"int64\"\n    ? {\n        number: `Math.floor($input) === $input && -9223372036854775808 <= $input && $input <= 9223372036854775807`;\n        bigint: `true`;\n      }\n    : Value extends \"uint64\"\n    ? {\n        number: `Math.floor($input) === $input && 0 <= $input && $input <= 18446744073709551615`;\n        bigint: `BigInt(0) <= $input`;\n      }\n    : Value extends \"float\"\n    ? `-1.175494351e38 <= $input && $input <= 3.4028235e38`\n    : `true`;\n  exclusive: true;\n}>;\n```\n\n----------------------------------------\n\nTITLE: Creating Agentica AI Agent with Swagger Document\nDESCRIPTION: This snippet shows how to create an Agentica AI agent using a Swagger document. It includes both a simplified pseudo code version and a more detailed real code implementation for a shopping chatbot.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/chat.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport typia from \"typia\";\n\nconst agent = new Agentica({\n  controllers: [\n    await fetch(\n      \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n    ).then(r => r.json()),\n    typia.llm.application<ShoppingCounselor>(),\n    typia.llm.application<ShoppingPolicy>(),\n    typia.llm.application<ShoppingSearchRag>(),\n  ],\n});\nawait agent.conversate(\"I wanna buy MacBook Pro\");\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Agentica } from \"@agentica/core\";\nimport { OpenApi, HttpLlm } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nconst main = async (): Promise<void> => {\n  const agent = new Agentica({\n    model: \"chatgpt\",\n    vendor: {\n      api: new OpenAI({ apiKey: \"*****\" }),\n      model: \"gpt-4o-mini\",\n    },\n    controllers: [\n      {\n        protocol: \"http\",\n        name: \"shopping\",\n        application: HttpLlm.application({\n          model: \"chatgpt\",\n          document: OpenApi.convert(\n            await fetch(\n              \"https://shopping-be.wrtn.ai/editor/swagger.json\",\n            ).then(r => r.json()),\n          ),\n        }),\n        connection: {\n          host: \"https://shopping-be.wrtn.ai\",\n          headers: {\n            Authorization: \"Bearer *****\",\n          },\n        },\n      },\n      {\n        protocol: \"class\",\n        name: \"counselor\",\n        application: \n          typia.llm.application<ShoppingCounselor, \"chatgpt\">(),\n        execute: new ShoppingCounselor(),\n      },\n      {\n        protocol: \"class\",\n        name: \"policy\",\n        application: \n          typia.llm.application<ShoppingPolicy, \"chatgpt\">(),\n        execute: new ShoppingPolicy(),\n      },\n      {\n        protocol: \"class\",\n        name: \"rag\",\n        application: \n          typia.llm.application<ShoppingSearchRag, \"chatgpt\">(),\n        execute: new ShoppingSearchRag(),\n      },\n    ],\n  });\n  await agent.conversate(\"I wanna buy MacBook Pro\");\n};\nmain().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Defining Typia Validation Functions in TypeScript\nDESCRIPTION: Defines the createValidate and createValidateEquals functions for generating reusable validation functions in typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function createValidate<T> = (input: unknown) => IValidation<T>;\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T>;\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Schema Generator Function in TypeScript\nDESCRIPTION: Defines the core schema generation function with version control support for OpenAPI 3.0 and 3.1.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace json {\n  export function schemas<\n    Schemas extends unknown[],\n    Version extends \"3.0\" | \"3.1\" = \"3.1\",\n  >(): IJsonSchemaCollection<Version>;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Using assertParse for Type-Safe JSON Parsing\nDESCRIPTION: Demonstrates practical usage of typia.json.assertParse with a strongly-typed interface example that includes validation tags for UUID, email, and number constraints. Shows both TypeScript source and compiled JavaScript.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nconst json: string = JSON.stringify(typia.random<IMember>());\nconst parsed: IMember = typia.json.assertParse<IMember>(json);\n\nconsole.log(json === JSON.stringify(parsed)); // true\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst json = JSON.stringify(\n  (() => {\n    const _ro0 = (_recursive = false, _depth = 0) => ({\n      id: (\n        _generator?.uuid ??\n        __typia_transform__randomFormatUuid._randomFormatUuid\n      )(),\n      email: (\n        _generator?.email ??\n        __typia_transform__randomFormatEmail._randomFormatEmail\n      )(),\n      age: (\n        _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n      )({\n        type: \"integer\",\n        exclusiveMinimum: true,\n        minimum: 19,\n        maximum: 100,\n      }),\n    });\n    let _generator;\n    return (generator) => {\n      _generator = generator;\n      return _ro0();\n    };\n  })()(),\n);\nconst parsed = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.assertParse\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.email &&\n      (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.assertParse\",\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        },\n        _errorFactory,\n      ));\n```\n\n----------------------------------------\n\nTITLE: Generated Protobuf Schema from TypeScript Interface using typia\nDESCRIPTION: This JavaScript code represents the output of typia.protobuf.message() function when applied to the IMember interface. It shows how TypeScript types and tags are translated into Protocol Buffer syntax.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message IMember {\",\n  \"  oneof id {\",\n  \"    bytes v13 = 13;\",\n  \"    uint64 v12 = 12;\",\n  \"    string v11 = 11;\",\n  \"  }\",\n  \"  optional string name = 20;\",\n  \"  repeated IMember children = 30;\",\n  \"  map<string, string> keywords = 40;\",\n  \"  oneof thumbnail {\",\n  \"    bytes v41 = 41;\",\n  \"    string v42 = 42;\",\n  \"  }\",\n  \"  required string email = 43;\",\n  \"  repeated IHobby hobbies = 44;\",\n  \"}\",\n  \"\",\n  \"message IHobby {\",\n  \"  required string id = 1;\",\n  \"  required string name = 2;\",\n  \"  required bool valid = 3;\",\n  \"}\",\n].join(\"\\n\");\n```\n\n----------------------------------------\n\nTITLE: Defining assertGuard Function Signatures\nDESCRIPTION: Type assertion guard functions that validate types and provide type narrowing without returning values.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport function assertGuard<T>(input: T): asserts input is T;\nexport function assertGuard<T>(input: unknown): asserts input is T;\n\nexport function assertGuardEquals<T>(input: T): asserts input is T;\nexport function assertGuardEquals<T>(input: unknown): asserts input is T;\n```\n\n----------------------------------------\n\nTITLE: Defining Query Manipulation Functions in typia\nDESCRIPTION: Exports HTTP query manipulation functions for parsing URL query strings with type safety. Includes primary functions and factory functions that create specialized query parsers with different validation behaviors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace http {\n  export function query<T extends object>(input: Query): Resolved<T>;\n  export function assertQuery<T extends object>(input: Query): Resolved<T>;\n  export function isQuery<T extends object>(input: Query): Resolved<T> | null;\n  export function validateQuery<T extends object>(\n    input: Query,\n  ): IValidation<Resolved<T>>;\n\n  export function createQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createAssertQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T>;\n  export function createIsQuery<T extends object>(): (\n    input: Query,\n  ) => Resolved<T> | null;\n  export function createValidateQuery<T extends object>(): (\n    input: Query,\n  ) => IValidation<Resolved<T>>;\n}\ntype Query = string | URLSearchParams;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Type Tags for Typia in TypeScript\nDESCRIPTION: This snippet shows how to define custom type tags for typia, including Dollar, Postfix, and IsEven tags. It also demonstrates how to use these tags in an interface definition.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkSomething = typia.createIs<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))\";\n}>;\n\ntype Postfix<Value extends string> = tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\n  kind: \"isEven\";\n  target: Value extends number ? \"number\" : \"bigint\";\n  value: undefined;\n  validate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\n  dollar: string & Dollar;\n  postfix: string & Postfix<\"!!!\">;  isEven: number & IsEven<number>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using typia's random function with generator\nDESCRIPTION: Core function to generate random data of type T with an optional custom generator.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport function random<T>(g?: IRandomGenerator): Resolved<T>;\n```\n\n----------------------------------------\n\nTITLE: Defining IBbsArticle Interface in TypeScript\nDESCRIPTION: This code snippet defines the IBbsArticle interface and its related types for a BBS article. It includes properties for the article's ID, creation time, update time, title, body, and thumbnail. The interface uses typia tags for type validation and formatting.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/IBbsArticleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { tags } from \"typia\";\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\nexport interface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n \n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n \n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n \n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n \n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n \n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BbsArticleController with Hidden Functions in TypeScript\nDESCRIPTION: This snippet defines a BbsArticleController interface with CRUD operations for a bulletin board system. It demonstrates the use of @hidden, @internal, and @human tags to exclude certain functions from the LLM application generation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n\n  /**\n   * Read an article.\n   * \n   * Reads an article from the DB.\n   * \n   * @param props Properties of read function\n   * @returns The article\n   * @hidden\n   */\n  at(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<IBbsArticle>;\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   * @internal\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   * @human\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of assertGuard Usage\nDESCRIPTION: Shows how to use assertGuard for type narrowing with an interface definition and unknown input type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IPoint {\n  x: number;\n  y: number;\n}\nconst input: unknown = { x: 1, y: 2 };\n\n// PERFORM THE ASSERTION GUARD\ntypia.assertGuard<IPoint>(input);\n\n// FROM NOW ON, \"input\" IS THE \"IPoint\" TYPE\ninput.x; // OK\ninput.y; // OK\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Buffer Encoding Functions in TypeScript\nDESCRIPTION: Declares namespace 'protobuf' with functions for encoding, validating, and asserting Protocol Buffer data. These functions convert TypeScript objects to Uint8Array representations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace protobuf {\n  export function encode<T>(input: T): Uint8Array;\n  export function isEncode<T>(input: T): Uint8Array | null;\n  export function assertEncode<T>(input: T): Uint8Array;\n  export function validateEncode<T>(input: T): IValidation<Uint8Array>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using assertFunction in TypeScript\nDESCRIPTION: Demonstrates how to use typia.functional.assertFunction to wrap a function that adds two numbers. The wrapped function will validate that both parameters and the return value are numbers.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst func = typia.functional.assertFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Buffer Decoder Functions\nDESCRIPTION: Defines namespace protobuf with four decoder functions for handling Protocol Buffer binary data conversion to TypeScript types. Includes basic decode, type guard decode, assertion decode, and validation decode functions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace protobuf {\n  export function decode<T>(buffer: Uint8Array): Resolved<T>;\n  export function isDecode<T>(buffer: Uint8Array): Resolved<T> | null;\n  export function assertDecode<T>(buffer: Uint8Array): Resolved<T>;\n  export function validateDecode<T>(\n    buffer: Uint8Array,\n  ): IValidation<Resolved<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LLM Function Calling and Schema Generation in TypeScript\nDESCRIPTION: This snippet shows the typia.llm namespace with functions for generating LLM application schemas, parameters, and type schemas. It includes type definitions for various LLM models and configuration options.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n\n  // +VALIDATE FUNCTION EMBEDDED\n  export function applicationOfValidate<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplicationOfValidate.IOptions<Model>, \"separate\">>,\n  ): ILlmApplicationOfValidate<Model>;\n\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class for Type Validation Failures\nDESCRIPTION: Definition of the TypeGuardError class that extends Error and provides detailed information about type validation failures with properties for method, path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining assertEquals Function Signatures in TypeScript\nDESCRIPTION: Function overloads for assertEquals that perform strict type checking and prohibit superfluous properties. Accepts both typed and unknown inputs.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport function assertEquals<T>(input: T): T;\nexport function assertEquals<T>(input: unknown): T;\n```\n\n----------------------------------------\n\nTITLE: Declaring JSON stringify() functions in TypeScript\nDESCRIPTION: Defines the typia.json namespace with stringify(), isStringify(), assertStringify(), and validateStringify() function signatures for JSON serialization.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace json {\n  export function stringify<T>(input: T): string;\n  export function isStringify<T>(input: T | unknown): string | null;\n  export function assertStringify<T>(input: T | unknown): string;\n  export function validateStringify<T>(input: T | unknown): IValidation<string>;\n}\n```\n\n----------------------------------------\n\nTITLE: IValidation Interface Definition for Type Validation Results\nDESCRIPTION: Defines the IValidation type and related interfaces for representing the results of type validation, including success case with validated data or failure case with detailed error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Primitive Type Conversion for JSON\nDESCRIPTION: Defines the Primitive type and related utility types that convert complex types to JSON-compatible primitive types, handling special cases like classes with toJSON methods, native classes, and various data structures.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Primitive type of JSON.\n *\n * `Primitive<T>` is a TMP (Type Meta Programming) type which converts\n * its argument as a primitive type within framework JSON.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be an empty object (`{}`).\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Native Class            | never\n * Others                  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n  ? T\n  : PrimitiveMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype PrimitiveMain<Instance> = Instance extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<Instance> extends bigint\n  ? never\n  : ValueOf<Instance> extends boolean | number | string\n  ? ValueOf<Instance>\n  : Instance extends Function\n  ? never\n  : ValueOf<Instance> extends object\n  ? Instance extends object\n    ? Instance extends NativeClass\n      ? never\n      : Instance extends IJsonable<infer Raw>\n      ? ValueOf<Raw> extends object\n        ? Raw extends object\n          ? PrimitiveObject<Raw> // object would be primitified\n          : never // cannot be\n        : ValueOf<Raw> // atomic value\n      : PrimitiveObject<Instance> // object would be primitified\n    : never // cannot be\n  : ValueOf<Instance>;\n\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n  ? IsTuple<Instance> extends true\n    ? PrimitiveTuple<Instance>\n    : PrimitiveMain<T>[]\n  : {\n      [P in keyof Instance]: PrimitiveMain<Instance[P]>;\n    };\n\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [PrimitiveMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [PrimitiveMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\n  : [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype NativeClass =\n  | Set<any>\n  | Map<any, any>\n  | WeakSet<any>\n  | WeakMap<any, any>\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array\n  | BigUint64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array\n  | ArrayBuffer\n  | SharedArrayBuffer\n  | DataView;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer U>\n    ? Instance extends U\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n\ninterface IJsonable<T> {\n  toJSON(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating ChatGPT Schema Parameters from TypeScript Interface using Typia\nDESCRIPTION: This snippet defines an IMember interface with various typed properties, including email and date format tags. It then uses Typia's LLM feature to generate ChatGPT schema parameters based on this interface. The result is logged to the console.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmParametersExampleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IChatGptSchema } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\ninterface IMember {\n  email: string & tags.Format<\"email\">;\n  name: string;\n  age: number;\n  hobbies: string[];\n  joined_at: string & tags.Format<\"date\">;\n}\nconst p: IChatGptSchema.IParameters = typia.llm.parameters<IMember, \"chatgpt\">();\nconsole.log(p);\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class Definition\nDESCRIPTION: Error class for type guard failures that includes method name, property path, expected type, and actual value information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Clerk Structure with Typia in TypeScript\nDESCRIPTION: This code snippet implements validation for a clerk structure within the department. It checks for correct data types and value ranges for name, age, authority, and joined_at fields. The age is validated to be between 19 and 100, and the joined_at field is checked for date format.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".age\",\n          expected: \"(number & ExclusiveMinimum<19> & Maximum<100>)\",\n          value: input.age,\n        },\n        _errorFactory,\n      )) &&\n    (\"number\" === typeof input.authority ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".authority\",\n          expected: \"number\",\n          value: input.authority,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.joined_at &&\n      (/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(\n        input.joined_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".joined_at\",\n            expected: 'string & Format<\"date\">',\n            value: input.joined_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".joined_at\",\n          expected: '(string & Format<\"date\">)',\n          value: input.joined_at,\n        },\n        _errorFactory,\n      ));\n```\n\n----------------------------------------\n\nTITLE: Defining Typia Prune Functions in TypeScript\nDESCRIPTION: This snippet defines various prune functions in Typia, including basic pruning, assert pruning, is pruning, and validate pruning. It also includes functions to create these pruning operations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport function prune<T>(input: T): void;\nexport function assertPrune<T>(input: T | unknown): T;\nexport function isPrune<T>(input: T | unknown): T | null;\nexport function validatePrune<T>(input: T | unknown): IValidation<T>;\n\nexport function createPrune<T>(): (input: T) => void;\nexport function createAssertPrune<T>(): (input: T | unknown) => T;\nexport function createIsPrune<T>(): (input: T | unknown) => T | null;\nexport function createValidatePrune<T>(): (input: T | unknown) => IValidation<T>;\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema with Typia in JavaScript\nDESCRIPTION: This snippet defines a JSON schema for a user object using Typia. It specifies properties such as email, name, age, hobbies, and joined_at, along with their types and constraints. The schema also includes format specifications for email and date fields.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmParametersJavaScriptSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nconst p = {\n  type: \"object\",\n  properties: {\n    email: {\n      description: \"@format email\",\n      type: \"string\",\n    },\n    name: {\n      type: \"string\",\n    },\n    age: {\n      type: \"number\",\n    },\n    hobbies: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n      },\n    },\n    joined_at: {\n      description: \"@format date\",\n      type: \"string\",\n    },\n  },\n  required: [\"email\", \"name\", \"age\", \"hobbies\", \"joined_at\"],\n  additionalProperties: false,\n  $defs: {},\n};\nconsole.log(p);\n```\n\n----------------------------------------\n\nTITLE: Implementing createAssertStringify for IDepartment in TypeScript\nDESCRIPTION: Demonstrates the usage of typia.json.createAssertStringify<T>() to create a reusable assertion function for the IDepartment interface. Includes type definitions with tags for validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const assertDepartment = typia.json.createAssertStringify<IDepartment>();\n\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string & tags.MinLength<3>;\n  limit: number & tags.Type<\"int32\">;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n  authority: number;\n  joined_at: string & tags.Format<\"date\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Department Structure with Typia in TypeScript\nDESCRIPTION: This code snippet implements detailed validation for a department structure using Typia. It checks for correct data types, formats (like UUID and date), value ranges, and nested structures. The validation includes checks for id, name, limit, and an array of clerks.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(\n        input.id,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      ((Math.floor(input.limit) === input.limit &&\n        -2147483648 <= input.limit &&\n        input.limit <= 2147483647) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.misc.assertClone\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.misc.assertClone\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertClone\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n```\n\n----------------------------------------\n\nTITLE: Type Guard Error Class Definition\nDESCRIPTION: Error class definition for type guard failures, containing method name, path, expected type, and actual value information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Custom Data Structure with Protocol Buffers in JavaScript/TypeScript\nDESCRIPTION: This function decodes a Protocol Buffer encoded message into a custom data structure representing a member with various properties. It handles different data types, nested structures, and collections like arrays and maps.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst decoded = (() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: new Uint8Array([]),\n      name: null,\n      children: [],\n      keywords: new Map(),\n      thumbnail: new Uint8Array([]),\n      email: \"\",\n      hobbies: [],\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 13:\n          // bytes;\n          output.id = reader.bytes();\n          break;\n        case 12:\n          // uint64;\n          output.id = Number(reader.uint64());\n          break;\n        case 11:\n          // string;\n          output.id = reader.string();\n          break;\n        case 20:\n          // string;\n          output.name = reader.string();\n          break;\n        case 30:\n          // Array<IMember>;\n          output.children.push(_pdo0(reader, reader.uint32()));\n          break;\n        case 40:\n          // Map<string, string>;\n          (() => {\n            output.keywords ??= new Map();\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: \"\",\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // string;\n                  entry.key = reader.string();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.keywords.set(entry.key, entry.value);\n          })();\n          break;\n        case 41:\n          // bytes;\n          output.thumbnail = reader.bytes();\n          break;\n        case 42:\n          // string;\n          output.thumbnail = reader.string();\n          break;\n        case 43:\n          // string;\n          output.email = reader.string();\n          break;\n        case 44:\n          // Array<IHobby>;\n          // (Incomplete implementation)\n```\n\n----------------------------------------\n\nTITLE: Defining IRandomGenerator Interface for Custom Random Generation\nDESCRIPTION: Interface definition for random data generation with methods for different data types and formats. Includes support for custom generators through the CustomMap interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Customizable } from \"./typings/Customizable\";\n\nexport interface IRandomGenerator {\n  // REGULAR\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n\n  //----\n  // FORMAT\n  //----\n  // SPECIAL CHARACTERS\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n\n  // ADDRESSES\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n\n  // TIMESTAMPS\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n\n  // POINTERS\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n\n  customs?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\n  export type CustomMap = {\n    [Type in keyof Customizable]?: (\n      tags: ITypeTag[],\n    ) => Customizable[Type] | undefined;\n  };\n\n  export interface ITypeTag {\n    name: string;\n    kind: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: Defines the IValidation interface and its related types for representing validation results in typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LLM Function Call Validation in TypeScript\nDESCRIPTION: This snippet defines a function 'correctFunctionCall' that validates LLM function calls using typia. It handles function lookup, argument validation, and provides detailed error feedback for retry attempts.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/chat.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FunctionCall } from \"pseudo\";\nimport { ILlmFunction, IValidation } from \"typia\";\n\nexport const correctFunctionCall = (p: {\n  call: FunctionCall;\n  functions: Array<ILlmFunction<\"chatgpt\">>;\n  retry: (reason: string, errors?: IValidation.IError[]) => Promise<unknown>;\n}): Promise<unknown> => {\n  // FIND FUNCTION\n  const func: ILlmFunction<\"chatgpt\"> | undefined =\n    p.functions.find((f) => f.name === p.call.name);\n  if (func === undefined) {\n    // never happened in my experience\n    return p.retry(\n      \"Unable to find the matched function name. Try it again.\",\n    );\n  }\n\n  // VALIDATE\n  const result: IValidation<unknown> = func.validate(p.call.arguments);\n  if (result.success === false) {\n    // 1st trial: 50% (gpt-4o-mini in shopping mall chatbot)\n    // 2nd trial with validation feedback: 99%\n    // 3nd trial with validation feedback again: never have failed\n    return p.retry(\n      \"Type errors are detected. Correct it through validation errors\",\n      {\n        errors: result.errors,\n      },\n    );\n  }\n  return result.data;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for BBS Article using typia in JavaScript\nDESCRIPTION: This code creates a JSON schema that defines the structure of a bulletin board article. It imports typia for schema validation and defines properties including id (UUID format), title, body, thumbnail (optional URI), and timestamps with proper validation constraints.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmSchemaJavaScriptSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nconst $defs = {};\nexport const schema = ((props) => {\n  if (undefined !== props?.$defs)\n    Object.assign(props.$defs, {\n      IBbsArticle: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n        },\n        required: [\n          \"id\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n          \"created_at\",\n          \"updated_at\",\n        ],\n      },\n    });\n  return {\n    $ref: \"#/$defs/IBbsArticle\",\n  };\n})({\n  $defs,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class in TypeScript\nDESCRIPTION: Defines a custom error class for type guard errors, including method, path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Tags in TypeScript\nDESCRIPTION: This snippet demonstrates the creation and usage of custom tags (Dollar, Postfix, PowerOf) in Typia, including their definitions and application in an interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nexport const checkTagCustom = typia.createIs<TagCustom>();\n\ninterface TagCustom {\n  id: string & typia.tags.Format<\"uuid\">;\n  dollar: string & Dolloar;\n  postfix: string & Postfix<\"abcd\">;\n  powerOf: number & PowerOf<2>;\n}\n\ntype Dolloar = typia.tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = typia.tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\n  kind: \"powerOf\";\n  target: \"number\";\n  value: Value;\n  validate: `(() => {\n        const denominator: number = Math.log(${Value});\n        const value: number = Math.log($input) / denominator;\n        return Math.abs(value - Math.round(value)) < 0.00000001;\n    })()`;\n}>;\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interface with LLM Schema Descriptions\nDESCRIPTION: This snippet demonstrates how to document a TypeScript interface with detailed descriptions for LLM schemas. It shows different ways to specify titles and descriptions using comment styles and tags, including the use of @title and @description.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IMember {\n  /**\n   * Primary Key.\n   * \n   * Above \"Primary Key\" would be the title of LLM schema. \n   */\n  id: string;\n\n  /**\n   * Below \"Age of the member\" would be the title of LLM schema.\n   * \n   * @title Age of the member\n   */\n  age: number;\n\n  /**\n   * @title Email address of the member\n   * @description The description property also can be filled by \n   *              the comment tag `@description`. Instead, be\n   *              careful about the indentation.\n   */\n  email: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Tags in TypeScript\nDESCRIPTION: Demonstrates how to create custom type tags with typia including various validation rules for numbers, strings, patterns, formats, arrays and maps. Shows intersection with built-in type tags for validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\n  type: number & tags.Type<\"uint32\">;\n\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\n  string: string & tags.MinLength<3>;\n\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n\n  /**\n   * Type tag can perform union type.\n   *\n   * In here case, format can be oneof `ipv4` or `ipv6` format.\n   */\n  format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">)) | null;\n\n  /**\n   * In the Array case, only type tag can restrict element type.\n   */\n  array: Array<string & tags.Format<\"uuid\">> &\n    tags.MinItems<3> &\n    tags.MaxItems<100>;\n\n  /**\n   * Also, only type tag can handle map type.\n   */\n  map: Map<\n    number & tags.Type<\"uint32\">,\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n  >;\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting and Pruning IDepartment Object in TypeScript\nDESCRIPTION: This code snippet implements type assertion and pruning for an IDepartment object. It includes nested checks for property types, value ranges, and format validation. The pruning function removes any properties not defined in the IDepartment interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        ((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.misc.assertPrune\",\n              path: _path + \"\",\n              expected: \"IDepartment\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \"\",\n            expected: \"IDepartment\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  const __prune = (input) => {\n    if (\"object\" === typeof input && null !== input) _po0(input);\n  };\n  return (input, errorFactory) => {\n    input = __assert(input, errorFactory);\n    __prune(input);\n    return input;\n  };\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Validation Logic for Custom Tags\nDESCRIPTION: This snippet shows the compiled JavaScript code generated by typia for the custom tag validations defined in TypeScript. It includes optimized runtime checks for each specified constraint, demonstrating how typia translates type and comment tags into efficient validation logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatIpv4 from \"typia/lib/internal/_isFormatIpv4.js\";\nimport * as __typia_transform__isFormatIpv6 from \"typia/lib/internal/_isFormatIpv6.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    Math.floor(input.type) === input.type &&\n    0 <= input.type &&\n    input.type <= 4294967295 &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern &&\n    RegExp(\"^[a-z]+$\").test(input.pattern) &&\n    (null === input.format ||\n      (\"string\" === typeof input.format &&\n        (__typia_transform__isFormatIpv4._isFormatIpv4(input.format) ||\n          __typia_transform__isFormatIpv6._isFormatIpv6(input.format)))) &&\n    Array.isArray(input.array) &&\n    3 <= input.array.length &&\n    input.array.length <= 100 &&\n    input.array.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        __typia_transform__isFormatUuid._isFormatUuid(elem),\n    ) &&\n    input.map instanceof Map &&\n    (() =>\n      [...input.map].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"number\" === typeof elem[0] &&\n          __typia_transform__isTypeUint32._isTypeUint32(elem[0]) &&\n          Array.isArray(elem[1]) &&\n          1 <= elem[1].length &&\n          elem[1].every(\n            (elem) =>\n              \"string\" === typeof elem &&\n              __typia_transform__isFormatUuid._isFormatUuid(elem),\n          ),\n      ))();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class in TypeScript\nDESCRIPTION: This snippet defines a TypeGuardError class that extends the Error class. It includes properties for method, path, expected value, and actual value, which are useful for type checking and validation errors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema Collection Interface\nDESCRIPTION: Defines the interface structure for JSON schema collections supporting both OpenAPI 3.0 and 3.1 versions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { OpenApi, OpenApiV3 } from \"@samchon/openapi\";\n\nexport type IJsonSchemaCollection<Version extends \"3.0\" | \"3.1\" = \"3.1\"> =\n  Version extends \"3.0\" ? IJsonSchemaCollection.IV3_0 : IJsonSchemaCollection.IV3_1;\nexport namespace IJsonSchemaCollection {\n  export interface IV3_0 {\n    version: \"3.0\";\n    schemas: OpenApiV3.IJsonSchema[];\n    components: OpenApiV3.IComponents;\n  }\n  export interface IV3_1 {\n    version: \"3.1\";\n    components: OpenApi.IComponents;\n    schemas: OpenApi.IJsonSchema[];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolved Type for Type Erasure in TypeScript\nDESCRIPTION: Defines a utility type that erases method properties from types, resolving them to their primitive counterparts or simplified object structures.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Tag Structure in TypeScript\nDESCRIPTION: This snippet defines the base structure for Typia tags, including properties for target type, kind, value, validation, and exclusivity rules.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type TagBase<Props extends TagBase.IProps<any, any, any, any, any>> = {\n  /**\n   * This is a dummy property for compilation.\n   *\n   * It does not mean anything in runtime.\n   */\n  \"typia.tag\"?: Props;\n};\nexport namespace TagBase {\n  export interface IProps<\n    Target extends \"bigint\" | \"number\" | \"string\" | \"array\",\n    Kind extends string,\n    Value extends boolean | bigint | number | string | undefined,\n    Validate extends\n      | string\n      | {\n          [key in Target]?: string;\n        },\n    Exclusive extends boolean | string[],\n  > {\n    /**\n     * Target type.\n     *\n     * If user tries to adapt this tag to a different type, it would be a compile\n     * error.\n     *\n     * For example, you've configured target type as `string`, but user adapted it\n     * onto a `number` type (`number & YourCustomTag<Value>`), then it would be\n     * blocked by TypeScript compiler.\n     */\n    target: Target;\n\n    /**\n     * What kind of tag is this?\n     */\n    kind: Kind;\n\n    /**\n     * Value to be configured by user.\n     */\n    value: Value;\n\n    /**\n     * Validation code.\n     *\n     * This code would be inserted into the generated validation function.\n     * In here script, target variable name must be `$input`. The variable name\n     * `$input` would be transformed to the suitable when compilation.\n     *\n     * Also, If you've take a mistake on this script, compile error would be\n     * occurred. So, define it with confidence. Compiler will block all your\n     * mistakes.\n     */\n    validate: Validate;\n\n    /**\n     * Exclusive option.\n     *\n     * If this property configured as `true`, same {@link kind} tag cannot be\n     * duplicated in the target type. Otherwise, if you've configured this property\n     * as string array, all of the {@link kind} value assigned tag cannot be\n     * compatible in the target type.\n     *\n     * @default false\n     */\n    exclusive?: Exclusive | string[];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using assertPrune Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the typia.misc.assertPrune() function to prune a randomly generated IDepartment object. It includes interface definitions for IDepartment and IClerk.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst department: IDepartment = typia.random<IDepartment>();\nconst pruned: IDepartment = typia.misc.assertPrune(department);\nconsole.log(pruned);\n\ninterface IDepartment {\n  /**\n   * @format uuid\n   */\n  id: string;\n\n  /**\n   * @minLength 3\n   */\n  name: string;\n\n  /**\n   * @type int\n   */\n  limit: number;\n\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  age: number;\n\n  authority: number;\n\n  /**\n   * @format date\n   */\n  joined_at: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: Defines the IValidation interface and its related types for representing validation results. It includes success and failure cases, along with detailed error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Guard Error Class Definition\nDESCRIPTION: Defines an error class for type guard failures that includes method name, path, expected type, and actual value information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Member Schema Generation Example\nDESCRIPTION: Demonstrates schema generation for a member interface with type tags and format validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const MemberSchema = typia.json.schemas<[IMember], \"3.0\">();\n\ninterface IMember {\n  /**\n   * Unique user ID generated by server.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Email address of the member.\n   */\n  email: string & tags.Format<\"email\">;\n\n  /**\n   * Age of the member.\n   *\n   * For reference, only adult can be a member.\n   */\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const MemberSchema = {\n  version: \"3.0\",\n  components: {\n    schemas: {\n      IMember: {\n        type: \"object\",\n        properties: {\n          id: {\n            type: \"string\",\n            format: \"uuid\",\n            title: \"Unique user ID generated by server\",\n            description: \"Unique user ID generated by server.\",\n          },\n          email: {\n            type: \"string\",\n            format: \"email\",\n            title: \"Email address of the member\",\n            description: \"Email address of the member.\",\n          },\n          age: {\n            type: \"integer\",\n            exclusiveMinimum: true,\n            minimum: 19,\n            maximum: 100,\n            title: \"Age of the member\",\n            description: \"Age of the member.\\n\\nFor reference, only adult can be a member.\",\n          },\n        },\n        required: [\"id\", \"email\", \"age\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/IMember\",\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interfaces for BBS Article\nDESCRIPTION: Defines TypeScript interfaces for a BBS article and attachment file, including type constraints and validation tags.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\n\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n\n  /**\n   * URL of the file.\n   */\n  url: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Stringify Function Generators in TypeScript\nDESCRIPTION: Declares namespace 'json' with functions for creating stringify, isStringify, assertStringify, and validateStringify operations. These functions generate reusable JSON stringification methods for TypeScript types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace json {\n  export function createStringify<T>(): (input: T) => string;\n  export function createIsStringify<T>(): (input: unknown) => string | null;\n  export function createAssertStringify<T>(\n   errorFactory?: undefined | ((props: TypeGuardError.IProps) => Error),\n  ): (input: unknown) => string; \n  export function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining typia.protobuf.message() Function Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript function signature for typia.protobuf.message(). The function takes no arguments and returns a string representation of a Protocol Buffer message.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace protobuf {\n  export function message<T>(): string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ILlmApplication Interface in TypeScript for LLM Function Calling\nDESCRIPTION: This interface represents a collection of LLM function calling schemas composed from a TypeScript class or interface. It includes support for parameter separation between LLM and human inputs, along with model configuration options.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/ILlmApplicationSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmFunction } from \"./ILlmFunction\";\nimport { ILlmSchema } from \"./ILlmSchema\";\n\n/**\n * Application of LLM function calling.\n *\n * `ILlmApplication` is a data structure representing a collection of\n * {@link ILlmFunction LLM function calling schemas}, composed from a native\n * TypeScript class (or interface) type by the `typia.llm.application<App, Model>()`\n * function.\n *\n * Also, there can be some parameters (or their nested properties) which must be\n * composed by Human, not by LLM. File uploading feature or some sensitive information\n * like secret key (password) are the examples. In that case, you can separate the\n * function parameters to both LLM and human sides by configuring the\n * {@link ILlmApplication.IOptions.separate} property. The separated parameters are\n * assigned to the {@link ILlmFunction.separated} property.\n *\n * For reference, when both LLM and Human filled parameter values to call, you can\n * merge them by calling the {@link HttpLlm.mergeParameters} function. In other words,\n * if you've configured the {@link ILlmApplication.IOptions.separate} property, you\n * have to merge the separated parameters before the function call execution.\n *\n * @reference https://platform.openai.com/docs/guides/function-calling\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface ILlmApplication<\n  Model extends ILlmSchema.Model,\n  Class extends object = any,\n> {\n  /**\n   * Model of the LLM.\n   */\n  model: Model;\n\n  /**\n   * List of function metadata.\n   *\n   * List of function metadata that can be used for the LLM function call.\n   */\n  functions: ILlmFunction<Model>[];\n\n  /**\n   * Configuration for the application.\n   */\n  options: ILlmApplication.IOptions<Model>;\n\n  /**\n   * Class type, the source of the LLM application.\n   *\n   * This property is just for the generic type inference,\n   * and its value is always `undefined`.\n   */\n  __class?: Class | undefined;\n}\nexport namespace ILlmApplication {\n  /**\n   * Options for application composition.\n   */\n  export type IOptions<Model extends ILlmSchema.Model> = {\n    /**\n     * Separator function for the parameters.\n     *\n     * When composing parameter arguments through LLM function call,\n     * there can be a case that some parameters must be composed by human,\n     * or LLM cannot understand the parameter.\n     *\n     * For example, if the parameter type has configured\n     * {@link IGeminiSchema.IString.contentMediaType} which indicates file\n     * uploading, it must be composed by human, not by LLM\n     * (Large Language Model).\n     *\n     * In that case, if you configure this property with a function that\n     * predicating whether the schema value must be composed by human or\n     * not, the parameters would be separated into two parts.\n     *\n     * - {@link ILlmFunction.separated.llm}\n     * - {@link ILlmFunction.separated.human}\n     *\n     * When writing the function, note that returning value `true` means\n     * to be a human composing the value, and `false` means to LLM\n     * composing the value. Also, when predicating the schema, it would\n     * better to utilize the {@link GeminiTypeChecker} like features.\n     *\n     * @param schema Schema to be separated.\n     * @returns Whether the schema value must be composed by human or not.\n     * @default null\n     */\n    separate: null | ((schema: ILlmSchema.ModelSchema[Model]) => boolean);\n  } & ILlmSchema.ModelConfig[Model];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class in TypeScript\nDESCRIPTION: This snippet defines the TypeGuardError class, which extends the Error class and includes additional properties for method, path, expected value, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Header Processing Functions in TypeScript\nDESCRIPTION: This snippet defines a namespace 'http' with various functions for processing HTTP headers. It includes functions for assertion, validation, and type checking of headers against a generic type T.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace http {\n  export function headers<T extends object>(input: Headers): Resolved<T>;\n  export function assertHeaders<T extends object>(input: Headers): Resolved<T>;\n  export function isHeaders<T extends object>(\n    input: Headers,\n  ): Resolved<T> | null;\n  export function validateHeaders<T extends object>(\n    input: Headers,\n  ): IValidation<Resolved<T>>;\n\n  export function createHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createAssertHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T>;\n  export function createIsHeaders<T extends object>(): (\n    input: Headers,\n  ) => Resolved<T> | null;\n  export function createValidateHeaders<T extends object>(): (\n    input: Headers,\n  ) => IValidation<Resolved<T>>;\n}\ntype Headers = Record<string, string | string[] | undefined>;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Tags for Random Data Generation in TypeScript\nDESCRIPTION: Shows how to use Type Tags with typia.random<T>() for specialized random data generation. This example includes various type constraints and format specifications.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nconst data: TypeTag = typia.random<TypeTag>();\n\nconsole.log(data);\n\ninterface TypeTag {\n  type: number & tags.Type<\"int32\">;\n  number?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n  string: string & tags.MinLength<3>;\n  pattern: string & tags.Pattern<\"^[a-z]+$\">;\n  format: (string & tags.Format<\"date-time\">) | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Discriminated Unions with Typia Validation\nDESCRIPTION: Demonstrates how to use discriminated unions with typia.validate<T>() function for type-safe validation results.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst something: unknown = ...;\nconst result: typia.IValidation<string> = typia.validate<string>(something);\n\nif (results.success) {\n  // become typia.IValidation.Success<string> type\n  result.data; // accessible\n} else {\n  // become typia.IValidation.Failure type\n  result.errors; //accessible\n}\n```\n\n----------------------------------------\n\nTITLE: Query Parser Example in TypeScript\nDESCRIPTION: Demonstrates how to create a query parser for an interface with various property types including optional number, boolean, string array, and nullable string. Uses typia.http.createQuery to generate a type-safe query parser.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IQuery {\n  limit?: number;\n  enforce: boolean;\n  values?: string[];\n  atomic: string | null;\n  indexes: number[];\n}\ntypia.http.createQuery<IQuery>();\n```\n\n----------------------------------------\n\nTITLE: Using validateFunction with Detailed Error Reporting\nDESCRIPTION: Example of using validateFunction to perform detailed validation with error reporting on a numeric addition function.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst func = typia.functional.validateFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Primitive Type Definition and Conversion in TypeScript\nDESCRIPTION: Type definitions for converting complex types to primitive JSON types, handling special cases for built-in classes and custom objects with toJSON methods.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n  ? T\n  : PrimitiveMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype PrimitiveMain<Instance> = Instance extends [never]\n  ? never\n  : ValueOf<Instance> extends bigint\n  ? never\n  : ValueOf<Instance> extends boolean | number | string\n  ? ValueOf<Instance>\n  : Instance extends Function\n  ? never\n  : ValueOf<Instance> extends object\n  ? Instance extends object\n    ? Instance extends NativeClass\n      ? never\n      : Instance extends IJsonable<infer Raw>\n      ? ValueOf<Raw> extends object\n        ? Raw extends object\n          ? PrimitiveObject<Raw>\n          : never\n        : ValueOf<Raw>\n      : PrimitiveObject<Instance>\n    : never\n  : ValueOf<Instance>;\n```\n\n----------------------------------------\n\nTITLE: Custom Type Tag Example for Random Generation\nDESCRIPTION: Example of implementing custom type tags for random data generation with typia, showing how to define custom validation logic and integrate with typia.random.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nconst data: TagCustom = typia.random<TagCustom>({\n  customs: {\n    string: (tags) => {\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\n        return \"$\" + RandomGenerator.integer();\n      const postfix = tags.find((t) => t.kind === \"postfix\");\n      if (postfix !== undefined)\n        return RandomGenerator.string() + postfix.value;\n    },\n  },\n});\n\nconsole.log(data);\n\ninterface TagCustom {\n  id: string & typia.tags.Format<\"uuid\">;\n  dollar: string & Dolloar;\n  postfix: string & Postfix<\"abcd\">;\n  powerOf: number & PowerOf<2>;\n}\n\ntype Dolloar = typia.tags.TagBase<{\n  kind: \"dollar\";\n  target: \"string\";\n  value: undefined;\n  validate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = typia.tags.TagBase<{\n  kind: \"postfix\";\n  target: \"string\";\n  value: Value;\n  validate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype PowerOf<Value extends number> = typia.tags.TagBase<{\n  kind: \"powerOf\";\n  target: \"number\";\n  value: Value;\n  validate: `(() => {\n        const denominator: number = Math.log(${Value});\n        const value: number = Math.log($input) / denominator;\n        return Math.abs(value - Math.round(value)) < 0.00000001;\n    })()`;\n}>;\n```\n\n----------------------------------------\n\nTITLE: Using Comment Tags for Random Data Generation in TypeScript\nDESCRIPTION: Demonstrates the use of Comment Tags with typia.random<T>() for specialized random data generation. This approach uses JSDoc-style comments to specify type constraints and formats.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst data: CommentTag = typia.random<CommentTag>();\n\nconsole.log(data);\n\ninterface CommentTag {\n  /**\n   * @type int\n   */\n  type: number;\n\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  number?: number;\n\n  /**\n   * @minLength 3\n   */\n  string: string;\n\n  /**\n   * @pattern ^[a-z]+$\n   */\n  pattern: string;\n\n  /**\n   * @format date-time\n   */\n  format: string | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Typia Validation Functions for Discriminated Unions\nDESCRIPTION: Defines the validate and createValidate functions for use with discriminated unions in typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: This snippet defines the IValidation interface and its associated types for success and failure cases. It includes structures for validation results and error reporting.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T = unknown> =\n  | IValidation.ISuccess<T>\n  | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T = unknown> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Complex TypeScript Interface for Protobuf Schema Generation\nDESCRIPTION: This code defines a complex TypeScript interface IMember with various field types and typia tags. It demonstrates how to use tags for specifying sequence numbers, custom types, and format constraints.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntypia.protobuf.message<IMember>();\n\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Resolution Utility\nDESCRIPTION: Type utility for resolving complex types by erasing methods and converting built-in types to their primitive equivalents\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Type Validator for Map in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a type validator for a Map with string keys and boolean, number, or string values using typia.createIs<T>().\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntypia.createIs<Map<string, boolean | number | string>>();\n```\n\n----------------------------------------\n\nTITLE: Recursive Type Handling in LLM Schema\nDESCRIPTION: Demonstrates how recursive types are handled in LLM schema, showing the limitation of recursive structure repetition to 3 times with removal after 4 depths.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntypia.llm.schema<IDepartment, \"gemini\">();\n\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  department: IDepartment[];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Protobuf Decode Function with Typia\nDESCRIPTION: Demonstrates a practical usage of typia.protobuf.createDecode for creating a reusable Protocol Buffer decoder. The example defines an IMember interface with tags for Protocol Buffer serialization and creates a decoder function.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n \nexport const decode = typia.protobuf.createDecode<IMember>();\n\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\ninterface IHobby {\n  id: string & tags.Format<\"uuid\">;\n  name: string;\n  valid: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of createSnake Function in TypeScript\nDESCRIPTION: Demonstrates how to use the typia.notations.createSnake<T>() function to generate a snake case converter for a specific interface with camelCase and PascalCase property names.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IPerson {\n  isMyNameSamchon?: boolean;\n  HelloTheNewWorld: string;\n  ToHTML: string;\n}\ntypia.notations.createSnake<IPerson>();\n```\n\n----------------------------------------\n\nTITLE: Defining LLM-related functions in typia namespace\nDESCRIPTION: This snippet shows the structure of the typia.llm namespace, including the parameters() function used for generating structured output schemas for LLMs. It also includes other related functions like application() and schema().\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/parameters.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace llm {\n  // LLM FUNCTION CALLING APPLICATION SCHEMA\n  export function application<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplication.IOptions<Model>, \"separate\">>,\n  ): ILlmApplication<Model>;\n\n  // +VALIDATE FUNCTION EMBEDDED\n  export function applicationOfValidate<\n    App extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    options?: Partial<Pick<ILlmApplicationOfValidate.IOptions<Model>, \"separate\">>,\n  ): ILlmApplicationOfValidate<Model>;\n\n  // STRUCTURED OUTPUT\n  export function parameters<\n    Parameters extends Record<string, any>,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(): ILlmSchema.ModelParameters[Model];\n\n  // TYPE SCHEMA\n  export function schema<\n    T,\n    Model extends ILlmSchema.Model,\n    Config extends Partial<ILlmSchema.ModelConfig[Model]> = {},\n  >(\n    ...$defs: Extract<\n      ILlmSchema.ModelSchema[Model],\n      { $ref: string }\n    > extends never\n      ? []\n      : [Record<string, ILlmSchema.ModelSchema[Model]>]\n  ): ILlmSchema.ModelSchema[Model];\n}\n```\n\n----------------------------------------\n\nTITLE: Resolved Type Implementation\nDESCRIPTION: Implements the Resolved type that handles type erasure of methods. It converts built-in classes to primitive types and custom classes to resolved objects, stripping away methods while maintaining data structure.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Validation Interface Definition\nDESCRIPTION: Defines interfaces for validation results including success and failure cases with associated data and error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of assertEquals Usage with Interface\nDESCRIPTION: Demonstrates usage of assertEquals with a typed interface including format and range validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  sex: 1, // extra\n});\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Typia Notation Snake Case Functions for Type Conversion\nDESCRIPTION: Declares the namespace of functions for converting object property names to snake case with various validation options. Includes direct conversion functions and factory functions that create converters.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace notations {\n  export function snake<T>(input: T): SnakeCase<T>;\n  export function assertSnake<T>(input: T | unknown): SnakeCase<T>;\n  export function isSnake<T>(input: T | unknown): SnakeCase<T> | null;\n  export function validateSnake<T>(\n    input: T | unknown,\n  ): IValidation<SnakeCase<T>>;\n\n  export function createSnake<T>(): (input: T) => SnakeCase<T>;\n  export function createAssertSnake<T>(): (input: T | unknown) => SnakeCase<T>;\n  export function createIsSnake<T>(): (\n    input: T | unknown,\n  ) => SnakeCase<T> | null;\n  export function createValidateSnake<T>(): (\n    input: T | unknown,\n  ) => IValidation<SnakeCase<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Typia Protocol Buffer Decode Function in TypeScript\nDESCRIPTION: Demonstrates the usage of the typia.protobuf.decode<T>() function, which is used for decoding Protocol Buffer messages in TypeScript. This snippet is part of a larger explanation about type compatibility between Protocol Buffer and TypeScript.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntypia.protobuf.decode<T>()\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Validation Functions in TypeScript\nDESCRIPTION: Runtime validation implementation for checking JSON data structure with type guards for email format and age range constraints. Uses custom error handling and type checking.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        ((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.json.assertParse\",\n              path: _path + \"\",\n              expected: \"IMember\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.json.assertParse\",\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n```\n\n----------------------------------------\n\nTITLE: Resolved Type Definition for Type Erasure\nDESCRIPTION: Type meta programming utility that converts its argument to a resolved type by erasing method properties and converting built-in classes to their primitive types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: This snippet defines an IValidation type and namespace with interfaces for successful and failed validations. It includes types for validation results and error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Protobuf Encoding and Decoding\nDESCRIPTION: This compiled JavaScript file contains the implementation of Protobuf message schema, decode function, and encode function for the 'CommentTagExample' interface. It includes detailed logic for reading and writing Protobuf messages.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message CommentTagExample {\",\n  \"  required int32 int32 = 1;\",\n  \"  optional uint32 uint32 = 2;\",\n  \"  optional uint64 uint64 = 3;\",\n  \"  required int64 int64 = 4;\",\n  \"  optional float float = 5;\",\n  \"  required double double = 6;\",\n  \"  required string string = 7;\",\n  \"}\",\n].join(\"\\n\");\n//----\n// DECODE FUNCTION\n//----\n(() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      int32: undefined,\n      uint32: null,\n      uint64: undefined,\n      int64: undefined,\n      float: null,\n      double: undefined,\n      string: \"\",\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // int32;\n          output.int32 = reader.int32();\n          break;\n        case 2:\n          // uint32;\n          output.uint32 = reader.uint32();\n          break;\n        case 3:\n          // uint64;\n          output.uint64 = Number(reader.uint64());\n          break;\n        case 4:\n          // int64;\n          output.int64 = Number(reader.int64());\n          break;\n        case 5:\n          // float;\n          output.float = reader.float();\n          break;\n        case 6:\n          // double;\n          output.double = reader.double();\n          break;\n        case 7:\n          // string;\n          output.string = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n//----\n// ENCODE FUNCTION\n//----\n(() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"int32\": (number & Type<\"int32\">);\n      writer.uint32(8);\n      writer.int32(input.int32);\n      // property \"uint32\": ((number & Type<\"uint32\">) | null | undefined);\n      if (undefined !== input.uint32 && null !== input.uint32) {\n        writer.uint32(16);\n        writer.uint32(input.uint32);\n      }\n      // property \"uint64\": ((number & Type<\"uint64\">) | undefined);\n      if (undefined !== input.uint64) {\n        writer.uint32(24);\n        writer.uint64(input.uint64);\n      }\n      // property \"int64\": (number & Type<\"int64\">);\n      writer.uint32(32);\n      writer.int64(input.int64);\n      // property \"float\": ((number & Type<\"float\">) | null);\n      if (null !== input.float) {\n        writer.uint32(45);\n        writer.float(input.float);\n      }\n      // property \"double\": number;\n      writer.uint32(49);\n      writer.double(input.double);\n      // property \"string\": string;\n      writer.uint32(58);\n      writer.string(input.string);\n    };\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Using typia.json.isStringify() in TypeScript\nDESCRIPTION: Demonstrates the usage of typia.json.isStringify() function with a complex object structure and type annotations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nconst department: IDepartment = typia.random<IDepartment>();\nconst json: string | null = typia.json.isStringify(department);\n\nconsole.log(json); // not null, but string\n\ninterface IDepartment {\n  id: string & tags.Format<\"uuid\">;\n  name: string & tags.MinLength<3>;\n  limit: number & tags.Type<\"int32\">;\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n  age: number \n    & tags.Type<\"uint32\"> \n    & tags.ExclusiveMinimum<19> \n    & tags.Maximum<100>;\n  authority: number;\n  joined_at: string & tags.Format<\"date\">;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BBS Article Interfaces and Controller in TypeScript\nDESCRIPTION: This snippet defines the main interfaces and controller for BBS article management. It includes definitions for article creation, update, and deletion, along with their respective properties and types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication, ILlmFunction } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\",\n>();\nconst func: ILlmFunction<\"chatgpt\"> | undefined = app.functions.find(\n  func => func.name === \"create\"\n);\nconsole.log(func?.parameters.properties.input?.description);\n\n/**\n * Article entity.\n *\n * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\n */\ninterface IBbsArticle extends IBbsArticle.ICreate {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of the article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Last updated time of the article.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n}\nnamespace IBbsArticle {\n  /**\n   * Information of the article to create.\n   */\n  export interface ICreate {\n    /**\n     * Title of the article.\n     *\n     * Representative title of the article.\n     */\n    title: string;\n\n    /**\n     * Content body.\n     *\n     * Content body of the article writtn in the markdown format.\n     */\n    body: string;\n\n    /**\n     * Thumbnail image URI.\n     *\n     * Thumbnail image URI which can represent the article.\n     *\n     * If configured as `null`, it means that no thumbnail image in the article.\n     */\n    thumbnail:\n      | null\n      | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">);\n  }\n\n  /**\n   * Information of the article to update.\n   *\n   * Only the filled properties will be updated.\n   */\n  export type IUpdate = Partial<ICreate>;\n}\n\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle>;\n\n  /**\n   * Update an article.\n   *\n   * Updates an article with new content.\n   *\n   * @param props Properties of update function\n   * @param input New content to update\n   */\n  update(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New content to update.\n     */\n    input: IBbsArticle.IUpdate;\n  }): Promise<void>;\n\n  /**\n   * Erase an article.\n   *\n   * Erases an article from the DB.\n   *\n   * @param props Properties of erase function\n   */\n  erase(props: {\n    /**\n     * Target article's {@link IBbsArticle.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n  }): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Validation Implementation Example\nDESCRIPTION: Example showing how to use typia.is() to validate an object against an interface with format and type tags.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst matched: boolean = typia.is<IMember>({\n  id: v4(),\n  email: \"samchon.github@gmai19l.com\",\n  age: 30,\n});\n\nconsole.log(matched); // true\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolved Type in TypeScript\nDESCRIPTION: Defines a complex type utility 'Resolved' that erases methods from types and resolves built-in classes to their primitive counterparts. It includes various helper types for type manipulation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: IValidation Interface for Type Validation Results\nDESCRIPTION: Defines the IValidation type and namespace which represents either a successful validation with typed data or a failure with error details. Used by validateParse to return comprehensive validation results.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/parse.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Random Data Generation Example\nDESCRIPTION: Practical example demonstrating random data generation with type constraints and formatting.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nconst member: IMember = typia.random<IMember>();\nconsole.log(member);\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomFormatEmail from \"typia/lib/internal/_randomFormatEmail.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport typia from \"typia\";\nconst member = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    email: (\n      _generator?.email ??\n      __typia_transform__randomFormatEmail._randomFormatEmail\n    )(),\n    age: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconsole.log(member);\n```\n\n----------------------------------------\n\nTITLE: Using isFunction Type Checker Example\nDESCRIPTION: Demonstrates how to use the isFunction utility to type check a simple numeric addition function. Shows practical usage with multiple function calls.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst func = typia.functional.isFunction(\n  (x: number, y: number): number => x + y,\n);\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffers Encoding with Typia\nDESCRIPTION: This complex snippet implements Protocol Buffers encoding for a custom data structure. It includes type checking, handling of various data types, and nested object encoding. The code uses a custom ProtobufWriter and ProtobufSizer for efficient binary encoding.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst byte = (() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"id\": ((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>));\n      if (input.id instanceof Uint8Array) {\n        writer.uint32(106);\n        writer.bytes(input.id);\n      } else if (\"number\" === typeof input.id) {\n        writer.uint32(96);\n        writer.uint64(input.id);\n      } else if (\"string\" === typeof input.id) {\n        writer.uint32(90);\n        writer.string(input.id);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>))',\n          value: input.id,\n        });\n      // property \"name\": ((string & Sequence<20>) | null);\n      if (null !== input.name) {\n        writer.uint32(162);\n        writer.string(input.name);\n      }\n      // property \"children\": (Array<IMember> & Sequence<30>);\n      if (0 !== input.children.length) {\n        for (const elem of input.children) {\n          writer.uint32(242);\n          writer.fork();\n          _peo0(elem);\n          writer.ldelim();\n        }\n      }\n      // property \"keywords\": (Map<string, string> & Sequence<40>);\n      for (const [key, value] of input.keywords) {\n        writer.uint32(322);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(key);\n        writer.uint32(18);\n        writer.string(value);\n        writer.ldelim();\n      }\n      // property \"thumbnail\": ((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array);\n      if (input.thumbnail instanceof Uint8Array) {\n        writer.uint32(330);\n        writer.bytes(input.thumbnail);\n      } else if (\"string\" === typeof input.thumbnail) {\n        writer.uint32(338);\n        writer.string(input.thumbnail);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array)',\n          value: input.thumbnail,\n        });\n      // property \"email\": (string & Format<\"email\">);\n      writer.uint32(346);\n      writer.string(input.email);\n      // property \"hobbies\": Array<IHobby>;\n      if (0 !== input.hobbies.length) {\n        for (const elem of input.hobbies) {\n          writer.uint32(354);\n          writer.fork();\n          _peo1(elem);\n          writer.ldelim();\n        }\n      }\n    };\n    const _peo1 = (input) => {\n      // property \"id\": (string & Format<\"uuid\">);\n      writer.uint32(10);\n      writer.string(input.id);\n      // property \"name\": string;\n      writer.uint32(18);\n      writer.string(input.name);\n      // property \"valid\": boolean;\n      writer.uint32(24);\n      writer.bool(input.valid);\n    };\n    const _io0 = (input) =>\n      null !== input.id &&\n      undefined !== input.id &&\n      (\"string\" === typeof input.id ||\n        (\"number\" === typeof input.id &&\n          __typia_transform__isTypeUint64._isTypeUint64(input.id)) ||\n        input.id instanceof Uint8Array) &&\n      (null === input.name || \"string\" === typeof input.name) &&\n      Array.isArray(input.children) &&\n      input.children.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n      ) &&\n      input.keywords instanceof Map &&\n      (() =>\n        [...input.keywords].every(\n          (elem) =>\n            Array.isArray(elem) &&\n            elem.length === 2 &&\n            \"string\" === typeof elem[0] &&\n            \"string\" === typeof elem[1],\n        ))() &&\n      null !== input.thumbnail &&\n      undefined !== input.thumbnail &&\n      ((\"string\" === typeof input.thumbnail &&\n        __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n        input.thumbnail instanceof Uint8Array) &&\n      \"string\" === typeof input.email &&\n      __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n      Array.isArray(input.hobbies) &&\n      input.hobbies.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n      );\n    const _io1 = (input) =>\n      \"string\" === typeof input.id &&\n      __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n      \"string\" === typeof input.name &&\n      \"boolean\" === typeof input.valid;\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})()(member);\n```\n\n----------------------------------------\n\nTITLE: Article Erase Validation Implementation\nDESCRIPTION: Implements validation for article deletion operation. Validates the presence and format of article ID as UUID.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationJavaScriptSnippet.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst _io0 = (input) =>\n  \"string\" === typeof input.id &&\n  __typia_transform__isFormatUuid._isFormatUuid(input.id);\n\nconst _vo0 = (input, _path, _exceptionable = true) =>\n  [\n    (\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        _report(_exceptionable, {\n          path: _path + \".id\",\n          expected: 'string & Format<\"uuid\">',\n          value: input.id,\n        }))) ||\n      _report(_exceptionable, {\n        path: _path + \".id\",\n        expected: '(string & Format<\"uuid\">)',\n        value: input.id,\n      }),\n  ].every((flag) => flag);\n```\n\n----------------------------------------\n\nTITLE: Defining IRandomGenerator Interface in TypeScript\nDESCRIPTION: Specifies the interface for custom random data generators in Typia. It includes methods for generating various data types and formats, as well as support for custom generators.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Customizable } from \"./typings/Customizable\";\n\nexport interface IRandomGenerator {\n  // REGULAR\n  boolean(): boolean;\n  integer(minimum?: number, maximum?: number): number;\n  bigint(minimum?: bigint, maximum?: bigint): bigint;\n  number(minimum?: number, maximum?: number): number;\n  string(length?: number): string;\n\n  array<T>(closure: (index: number) => T, count?: number): T[];\n  length(): number;\n  pattern(regex: RegExp): string;\n\n  //----\n  // FORMAT\n  //----\n  // SPECIAL CHARACTERS\n  byte(): string;\n  password(): string;\n  regex(): string;\n  uuid(): string;\n\n  // ADDRESSES\n  email(): string;\n  hostname(): string;\n  idnEmail(): string;\n  idnHostname(): string;\n  iri(): string;\n  iriReference(): string;\n  ipv4(): string;\n  ipv6(): string;\n  uri(): string;\n  uriReference(): string;\n  uriTemplate(): string;\n  url(): string;\n\n  // TIMESTAMPS\n  datetime(minimum?: number, maximum?: number): string;\n  date(minimum?: number, maximum?: number): string;\n  time(): string;\n  duration(): string;\n\n  // POINTERS\n  jsonPointer(): string;\n  relativeJsonPointer(): string;\n\n  customs?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\n  export type CustomMap = {\n    [Type in keyof Customizable]?: (\n      tags: ITypeTag[],\n    ) => Customizable[Type] | undefined;\n  };\n  export interface ITypeTag {\n    name: string;\n    kind: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pruning Function for IDepartment Object in TypeScript\nDESCRIPTION: This code snippet defines pruning functions for the IDepartment object and its nested clerk objects. It removes any properties that are not part of the defined interface structure.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst _po0 = (input) => {\n    if (Array.isArray(input.clerks)) _pp0(input.clerks);\n    for (const key of Object.keys(input)) {\n      if (\"id\" === key || \"name\" === key || \"limit\" === key || \"clerks\" === key)\n        continue;\n      delete input[key];\n    }\n  };\n  const _po1 = (input) => {\n    for (const key of Object.keys(input)) {\n      if (\n        \"name\" === key ||\n        \"age\" === key ||\n        \"authority\" === key ||\n        \"joined_at\" === key\n      )\n        continue;\n      delete input[key];\n    }\n  };\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for BBS Article Management\nDESCRIPTION: This snippet shows the compiled JavaScript version of the TypeScript code. It includes the LLM application configuration, function definitions, and type descriptions for BBS article management.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n    },\n    {\n      name: \"update\",\n      parameters: {\n        description: \" Properties of update function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description:\n              \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [],\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n    },\n    {\n      name: \"erase\",\n      parameters: {\n        description: \" Properties of erase function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n        },\n        required: [\"id\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Erase an article.\\n\\nErases an article from the DB.\",\n    },\n  ],\n};\nconst func = app.functions.find((func) => func.name === \"create\");\nconsole.log(func?.parameters.properties.input?.description);\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of validateFunction\nDESCRIPTION: Shows the compiled JavaScript implementation of validateFunction with full error reporting and validation logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nconst func = (() => {\n  const __validate_param_0 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  const __validate_param_1 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  const __validate_return = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let errors;\n    let $report;\n    return (input) => {\n      if (false === __is(input)) {\n        errors = [];\n        $report = __typia_transform__validateReport._validateReport(errors);\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"number\",\n            value: input,\n          }))(input, \"$input\", true);\n        const success = 0 === errors.length;\n        return {\n          success,\n          errors,\n          data: success ? input : undefined,\n        };\n      }\n      return {\n        success: true,\n        errors: [],\n        data: input,\n      };\n    };\n  })();\n  return (x, y) => {\n    const paramErrorResults = [__validate_param_0(x), __validate_param_1(y)]\n      .map((r, i) =>\n        true === r.success\n          ? r\n          : {\n              ...r,\n              errors: r.errors.map((error) => ({\n                ...error,\n                path: error.path.replace(\"$input\", `$input.parameters[${i}]`),\n              })),\n            },\n      )\n      .filter((r) => false === r.success);\n    if (0 !== paramErrorResults.length)\n      return {\n        success: false,\n        errors: paramErrorResults.map((r) => r.errors).flat(),\n      };\n    const result = __validate_return(((x, y) => x + y)(x, y));\n    if (false === result.success)\n      result.errors = result.errors.map((error) => ({\n        ...error,\n        path: error.path.replace(\"$input\", \"$input.return\"),\n      }));\n    return result;\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Declaring Special Numeric Types with Typia Type Tags in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to use Typia's type tags to declare special numeric types, including atomic types, union types, and their usage in arrays and maps. It also shows how to generate protobuf message schemas and create encode/decode functions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ninterface TypeTagExample {\n  // ATOMIC TYPES\n  int32: number & tags.Type<\"int32\">;\n  uint32: number & tags.Type<\"uint32\">;\n  uint64: bigint & tags.Type<\"uint64\">;\n  int64: number & tags.Type<\"int64\">;\n  float: number & tags.Type<\"float\">;\n  double: number | undefined;\n  string: string | null;\n\n  // UNION TYPES\n  uint32_or_double: number & (tags.Type<\"uint32\"> | tags.Type<\"double\">);\n  int32_or_uint64:\n    | (number & tags.Type<\"int32\">)\n    | (bigint & tags.Type<\"uint64\">);\n  int32_or_float_or_uint64:\n    | (number & (tags.Type<\"int32\"> | tags.Type<\"float\">))\n    | (bigint & tags.Type<\"uint64\">);\n\n  // ARRAY AND MAP\n  uint64_array: Array<bigint & tags.Type<\"uint64\">>;\n  int32_map?: Map<number & tags.Type<\"int32\">, string> | null;\n}\n\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<TypeTagExample>();\n\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<TypeTagExample>();\n\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<TypeTagExample>();\n```\n\n----------------------------------------\n\nTITLE: Configuring LLM Application with Typia for Claude in TypeScript\nDESCRIPTION: This snippet creates an ILlmApplication for Claude using Typia. It defines a separate function that checks if a schema is a string and has a contentMediaType. The application is configured for the BbsArticleService.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationSeparateExampleSnippet.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ClaudeTypeChecker, IClaudeSchema, ILlmApplication } from \"@samchon/openapi\";\nimport typia from \"typia\";\n\nimport { BbsArticleService } from \"./BbsArticleService\";\n\nconst app: ILlmApplication<\"claude\"> = typia.llm.application<\n  BbsArticleService,\n  \"claude\"\n>({\n  separate: (schema: IClaudeSchema) =>\n    ClaudeTypeChecker.isString(schema) && schema.contentMediaType !== undefined,\n});\nconsole.log(app);\n```\n\n----------------------------------------\n\nTITLE: Defining Customizable Interface for Random Generators in TypeScript\nDESCRIPTION: Specifies the Customizable interface used in IRandomGenerator for custom type generation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n```\n\n----------------------------------------\n\nTITLE: SnakeCase Type Implementation for Property Name Conversion\nDESCRIPTION: Defines the SnakeCase type and supporting utility types for converting object property names from camelCase or PascalCase to snake_case. Handles various complex types including arrays, tuples, maps, and nested objects.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Snake case type.\n *\n * `SnakeCase` type is a type that all keys of an object are converted to snake case.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be snake cased\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type SnakeCase<T> = Equal<T, SnakageMain<T>> extends true\n  ? T\n  : SnakageMain<T>;\n\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype SnakageMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? SnakageObject<T>\n  : T;\n\ntype SnakageObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? SnakageTuple<T>\n    : SnakageMain<U>[]\n  : T extends Set<infer U>\n  ? Set<SnakageMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<SnakageMain<K>, SnakageMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as SnakageString<Key & string>]: SnakageMain<T[Key]>;\n    };\n\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype SnakageTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [SnakageMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [SnakageMain<F>, ...SnakageTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [SnakageMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [SnakageMain<F>?, ...SnakageTuple<Rest>]\n  : [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype SnakageString<Key extends string> = Key extends `${infer _}`\n  ? SnakageStringRepeatedly<Key, \"\">\n  : Key;\ntype SnakageStringRepeatedly<\n  S extends string,\n  Previous extends string,\n> = S extends `${infer First}${infer Second}${infer Rest}`\n  ? `${Underscore<Previous, First>}${Lowercase<First>}${Underscore<\n      First,\n      Second\n    >}${Lowercase<Second>}${SnakageStringRepeatedly<Rest, Second>}`\n  : S extends `${infer First}`\n  ? `${Underscore<Previous, First>}${Lowercase<First>}`\n  : \"\";\ntype Underscore<First extends string, Second extends string> = First extends\n  | UpperAlphabetic\n  | \"\"\n  | \"_\"\n  ? \"\"\n  : Second extends UpperAlphabetic\n  ? \"_\"\n  : \"\";\ntype UpperAlphabetic =\n  | \"A\"\n  | \"B\"\n  | \"C\"\n  | \"D\"\n  | \"E\"\n  | \"F\"\n  | \"G\"\n  | \"H\"\n  | \"I\"\n  | \"J\"\n  | \"K\"\n  | \"L\"\n  | \"M\"\n  | \"N\"\n  | \"O\"\n  | \"P\"\n  | \"Q\"\n  | \"R\"\n  | \"S\"\n  | \"T\"\n  | \"U\"\n  | \"V\"\n  | \"W\"\n  | \"X\"\n  | \"Y\"\n  | \"Z\";\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class for Error Handling\nDESCRIPTION: Declares a TypeGuardError class that extends the built-in Error class. It includes properties for method, path, expected value, and actual value, which are useful for detailed error reporting in type guard operations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for createAssertStringify Implementation\nDESCRIPTION: Shows the compiled JavaScript output for the createAssertStringify implementation. Includes type checking and assertion logic for the IDepartment and IClerk interfaces.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatDate from \"typia/lib/internal/_isFormatDate.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport * as __typia_transform__jsonStringifyString from \"typia/lib/internal/_jsonStringifyString.js\";\nimport typia from \"typia\";\nexport const assertDepartment = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    __typia_transform__isTypeInt32._isTypeInt32(input.limit) &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    !Number.isNaN(input.authority) &&\n    \"string\" === typeof input.joined_at &&\n    __typia_transform__isFormatDate._isFormatDate(input.joined_at);\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      (__typia_transform__isTypeInt32._isTypeInt32(input.limit) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.json.createAssertStringify\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.json.createAssertStringify\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (19 < input.age ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          },\n          _errorFactory,\n        )) &&\n      (input.age <= 100 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.authority && !Number.isNaN(input.authority)) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".authority\",\n          expected: \"number\",\n          value: input.authority,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.joined_at &&\n      (__typia_transform__isFormatDate._isFormatDate(input.joined_at) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.json.createAssertStringify\",\n            path: _path + \".joined_at\",\n            expected: 'string & Format<\"date\">',\n            value: input.joined_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.json.createAssertStringify\",\n          path: _path + \".joined_at\",\n          expected: '(string & Format<\"date\">)',\n          value: input.joined_at,\n        },\n        _errorFactory,\n      ));\n```\n\n----------------------------------------\n\nTITLE: Encoding Custom Data Structure with Protocol Buffers in JavaScript/TypeScript\nDESCRIPTION: This function encodes a custom data structure representing a member with various properties using Protocol Buffers. It handles different data types, nested structures, and collections like arrays and maps.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst encoded = (() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"id\": ((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>));\n      if (input.id instanceof Uint8Array) {\n        writer.uint32(106);\n        writer.bytes(input.id);\n      } else if (\"number\" === typeof input.id) {\n        writer.uint32(96);\n        writer.uint64(input.id);\n      } else if (\"string\" === typeof input.id) {\n        writer.uint32(90);\n        writer.string(input.id);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((Uint8Array & Sequence<13>) | (number & Type<\"uint64\"> & Sequence<12>) | (string & Sequence<11>))',\n          value: input.id,\n        });\n      // property \"name\": ((string & Sequence<20>) | null);\n      if (null !== input.name) {\n        writer.uint32(162);\n        writer.string(input.name);\n      }\n      // property \"children\": (Array<IMember> & Sequence<30>);\n      if (0 !== input.children.length) {\n        for (const elem of input.children) {\n          writer.uint32(242);\n          writer.fork();\n          _peo0(elem);\n          writer.ldelim();\n        }\n      }\n      // property \"keywords\": (Map<string, string> & Sequence<40>);\n      for (const [key, value] of input.keywords) {\n        writer.uint32(322);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(key);\n        writer.uint32(18);\n        writer.string(value);\n        writer.ldelim();\n      }\n      // property \"thumbnail\": ((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array);\n      if (input.thumbnail instanceof Uint8Array) {\n        writer.uint32(330);\n        writer.bytes(input.thumbnail);\n      } else if (\"string\" === typeof input.thumbnail) {\n        writer.uint32(338);\n        writer.string(input.thumbnail);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.encode\",\n          expected:\n            '((string & Format<\"uri\"> & ContentMediaType<\"image/*\">) | Uint8Array)',\n          value: input.thumbnail,\n        });\n      // property \"email\": (string & Format<\"email\">);\n      writer.uint32(346);\n      writer.string(input.email);\n      // property \"hobbies\": Array<IHobby>;\n      if (0 !== input.hobbies.length) {\n        for (const elem of input.hobbies) {\n          writer.uint32(354);\n          writer.fork();\n          _peo1(elem);\n          writer.ldelim();\n        }\n      }\n    };\n    const _peo1 = (input) => {\n      // property \"id\": (string & Format<\"uuid\">);\n      writer.uint32(10);\n      writer.string(input.id);\n      // property \"name\": string;\n      writer.uint32(18);\n      writer.string(input.name);\n      // property \"valid\": boolean;\n      writer.uint32(24);\n      writer.bool(input.valid);\n    };\n    const _io0 = (input) =>\n      null !== input.id &&\n      undefined !== input.id &&\n      (\"string\" === typeof input.id ||\n        (\"number\" === typeof input.id &&\n          __typia_transform__isTypeUint64._isTypeUint64(input.id)) ||\n        input.id instanceof Uint8Array) &&\n      (null === input.name || \"string\" === typeof input.name) &&\n      Array.isArray(input.children) &&\n      input.children.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n      ) &&\n      input.keywords instanceof Map &&\n      (() =>\n        [...input.keywords].every(\n          (elem) =>\n            Array.isArray(elem) &&\n            elem.length === 2 &&\n            \"string\" === typeof elem[0] &&\n            \"string\" === typeof elem[1],\n        ))() &&\n      null !== input.thumbnail &&\n      undefined !== input.thumbnail &&\n      ((\"string\" === typeof input.thumbnail &&\n        __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n        input.thumbnail instanceof Uint8Array) &&\n      \"string\" === typeof input.email &&\n      __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n      Array.isArray(input.hobbies) &&\n      input.hobbies.every(\n        (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n      );\n    const _io1 = (input) =>\n      \"string\" === typeof input.id &&\n      __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n      \"string\" === typeof input.name &&\n      \"boolean\" === typeof input.valid;\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})()(member);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom HTTP Headers Interface in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom interface for HTTP headers and use the typia.http.createHeaders function to generate a type-safe header processing function.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IHeaders {\n  \"x-Category\": \"x\" | \"y\" | \"z\";\n  \"x-MEMO\"?: string;\n  \"x-nAmE\"?: string;\n  \"x-Values\": number[];\n  \"x-FlAgS\": boolean[];\n  \"X-Descriptions\": string[];\n}\ntypia.http.createHeaders<IHeaders>();\n```\n\n----------------------------------------\n\nTITLE: Validating and Encoding Protocol Buffer Message in TypeScript\nDESCRIPTION: This code snippet performs type checking and validation for a complex object structure, including nested arrays, maps, and custom types. It then encodes the validated data into a Protocol Buffer format using Typia's ProtobufSizer and ProtobufWriter.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\n(null === input.name || \"string\" === typeof input.name) &&\nArray.isArray(input.children) &&\ninput.children.every(\n  (elem) => \"object\" === typeof elem && null !== elem && _io0(elem),\n) &&\ninput.keywords instanceof Map &&\n(() =>\n  [...input.keywords].every(\n    (elem) =>\n      Array.isArray(elem) &&\n      elem.length === 2 &&\n      \"string\" === typeof elem[0] &&\n      \"string\" === typeof elem[1],\n  ))() &&\nnull !== input.thumbnail &&\nundefined !== input.thumbnail &&\n((\"string\" === typeof input.thumbnail &&\n  __typia_transform__isFormatUri._isFormatUri(input.thumbnail)) ||\n  input.thumbnail instanceof Uint8Array) &&\n\"string\" === typeof input.email &&\n__typia_transform__isFormatEmail._isFormatEmail(input.email) &&\nArray.isArray(input.hobbies) &&\ninput.hobbies.every(\n  (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n);\nconst _io1 = (input) =>\n\"string\" === typeof input.id &&\n__typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n\"string\" === typeof input.name &&\n\"boolean\" === typeof input.valid;\n_peo0(input);\nreturn writer;\n};\nreturn (input) => {\nconst sizer = encoder(\n  new __typia_transform__ProtobufSizer._ProtobufSizer(),\n  input,\n);\nconst writer = encoder(\n  new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n  input,\n);\nreturn writer.buffer();\n};\n```\n\n----------------------------------------\n\nTITLE: Strict Equality Function Signatures\nDESCRIPTION: Function signatures for strict equality checking that prohibits superfluous properties.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function equals<T>(input: T): input is T;\nexport function equals<T>(input: unknown): input is T;\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class Definition for Error Handling\nDESCRIPTION: Defines the TypeGuardError class that provides detailed information about type validation failures, including the method used, path to the error, expected type, and actual value received.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of Protobuf Decoder\nDESCRIPTION: Shows the JavaScript code generated from the TypeScript Protocol Buffer decoder definition. Demonstrates how typia compiles the type information into runtime decoder functions with efficient Protocol Buffer parsing logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport typia from \"typia\";\nexport const decode = (() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: new Uint8Array([]),\n      name: null,\n      children: [],\n      keywords: new Map(),\n      thumbnail: new Uint8Array([]),\n      email: \"\",\n      hobbies: [],\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 13:\n          // bytes;\n          output.id = reader.bytes();\n          break;\n        case 12:\n          // uint64;\n          output.id = Number(reader.uint64());\n          break;\n        case 11:\n          // string;\n          output.id = reader.string();\n          break;\n        case 20:\n          // string;\n          output.name = reader.string();\n          break;\n        case 30:\n          // Array<IMember>;\n          output.children.push(_pdo0(reader, reader.uint32()));\n          break;\n        case 40:\n          // Map<string, string>;\n          (() => {\n            output.keywords ??= new Map();\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: \"\",\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // string;\n                  entry.key = reader.string();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.keywords.set(entry.key, entry.value);\n          })();\n          break;\n        case 41:\n          // bytes;\n          output.thumbnail = reader.bytes();\n          break;\n        case 42:\n          // string;\n          output.thumbnail = reader.string();\n          break;\n        case 43:\n          // string;\n          output.email = reader.string();\n          break;\n        case 44:\n          // Array<IHobby>;\n          output.hobbies.push(_pdo1(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  const _pdo1 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      id: \"\",\n      name: \"\",\n      valid: undefined,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // string;\n          output.id = reader.string();\n          break;\n        case 2:\n          // string;\n          output.name = reader.string();\n          break;\n        case 3:\n          // bool;\n          output.valid = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Decode Functions in Typia\nDESCRIPTION: Exports the protobuf namespace with functions for decoding Protocol Buffers into TypeScript types. Includes functions for basic decoding, type-guard decoding, assertion-based decoding, and validation-based decoding.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace protobuf {\n  export function createDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createIsDecode<T>: (buffer: Uint8Array) => Resolved<T> | null;\n  export function createAssertDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\n  export function createValidateDecode<T>(): (\n      buffer: Uint8Array\n  ) => IValidation<Resolved<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Parameter Decoders with Format and Type Constraints\nDESCRIPTION: Example of using typia.http.createParameter<T>() to create parameter decoders with format and type constraints. Shows how to create decoders for UUID string format and uint32 number type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ntypia.http.createParameter<string & tags.Format<\"uuid\">>();\ntypia.http.createParameter<number & tags.Type<\"uint32\">>();\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Specialized JSON Schema with Typia\nDESCRIPTION: This snippet shows the compiled JavaScript output for the specialized JSON schema. It demonstrates how the TypeScript type definitions and tags are transformed into a JavaScript object representing the schema.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const schema = {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"integer\",\n      deprecated: true,\n      title: \"Unsigned integer\",\n      description: \"Deprecated tags are just used for marking.\",\n    },\n    number: {\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n      title: \"You can limit the range of number\",\n      description: \"You can limit the range of number.\",\n    },\n    string: {\n      oneOf: [\n        {\n          type: \"string\",\n          minLength: 3,\n          maxLength: 24,\n        },\n        {\n          type: \"string\",\n          minLength: 40,\n          maxLength: 100,\n        },\n      ],\n      title: \"You can limit the length of string\",\n      description:\n        \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n    },\n    pattern: {\n      type: \"string\",\n      pattern: \"^[a-z]+$\",\n      title: \"You can limit the pattern of string\",\n      description: \"You can limit the pattern of string.\",\n    },\n    format: {\n      oneOf: [\n        {\n          type: \"string\",\n          format: \"date-time\",\n        },\n        {\n          type: \"null\",\n        },\n      ],\n      title: \"You can limit the format of string\",\n      description: \"You can limit the format of string.\",\n    },\n    array: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        format: \"uuid\",\n      },\n      minItems: 3,\n      title: \"In the Array case, possible to restrict its elements\",\n      description: \"In the Array case, possible to restrict its elements.\",\n    },\n  },\n  required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\n  additionalProperties: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Strict Equality Validation Example\nDESCRIPTION: Demonstrates the difference between is() and equals() functions when handling objects with extra properties.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst input: unknown = {\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n  extra: \"superfluous property\", // extra\n};\nconst is: boolean = typia.is<IMember>(input);\nconst equals: boolean = typia.equals<IMember>(input);\n\nconsole.log(is, equals); // true, false\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class in TypeScript\nDESCRIPTION: Declares a TypeGuardError class extending Error, used for type guard failures. It includes properties for the method, path, expected type, and actual value causing the error.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pascal Case Conversion in TypeScript\nDESCRIPTION: Shows an example of using the typia.notations.createPascal function to create a pascal case converter for an IPerson interface. This demonstrates how to use the library for converting object properties to pascal case.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IPerson {\n  is_my_name_samchon?: boolean;\n  helloTheNewWorld: string;\n  toHTML: string;\n}\ntypia.notations.createPascal<IPerson>();\n```\n\n----------------------------------------\n\nTITLE: Defining Camel Case Conversion Functions in TypeScript\nDESCRIPTION: Defines a set of functions for converting object properties to camel case, including type-safe assertions and validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace notations {\n  export function camel<T>(input: T): CamelCase<T>;\n  export function assertCamel<T>(input: T | unknown): CamelCase<T>;\n  export function isCamel<T>(input: T | unknown): CamelCase<T> | null;\n  export function validateCamel<T>(\n    input: T | unknown,\n  ): IValidation<CamelCase<T>>;\n\n  export function createCamel<T>(): (input: T) => CamelCase<T>;\n  export function createAssertCamel<T>(): (input: T | unknown) => CamelCase<T>;\n  export function createIsCamel<T>(): (\n    input: T | unknown,\n  ) => CamelCase<T> | null;\n  export function createValidateCamel<T>(): (\n    input: T | unknown,\n  ) => IValidation<CamelCase<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Bigint and Tuple Type Restrictions Example\nDESCRIPTION: Shows unsupported type usage that results in compilation errors. Demonstrates that LLM schema does not support bigint and tuple types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntypia.llm.schema<bigint, \"chatgpt\">({});\ntypia.llm.schema<[number, string], \"claude\">({});\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Schema with Typia in TypeScript\nDESCRIPTION: This snippet demonstrates how to add custom properties to the JSON schema using Typia. It uses the 'tags.TagBase.schema' property and 'tags.JsonSchemaPlugin' type to include custom 'x-' prefixed properties in the schema.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\n\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\n\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n \ntypia.llm.schema<IAccount, \"chatgpt\">();\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimum Tag in TypeScript\nDESCRIPTION: This snippet shows the implementation of a Minimum tag for number and bigint types, extending the TagBase structure.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TagBase } from \"./TagBase\";\n\nexport type Minimum<Value extends number | bigint> = TagBase<{\n  target: Value extends number ? \"number\" : \"bigint\";\n  kind: \"minimum\";\n  value: Value;\n  validate: `${Numeric<Value>} <= $input`;\n  exclusive: [\"minimum\", \"exclusiveMinimum\"];\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n  ? Value\n  : `BigInt(${Value})`;\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError class in TypeScript\nDESCRIPTION: Declares the TypeGuardError class extending Error, used for handling type guard errors in typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled Type Tag Validation in JavaScript\nDESCRIPTION: The compiled JavaScript version of the type tag implementation, showing the runtime validation logic generated by typia including type checks and format validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatIpv4 from \"typia/lib/internal/_isFormatIpv4.js\";\nimport * as __typia_transform__isFormatIpv6 from \"typia/lib/internal/_isFormatIpv6.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.type) &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern &&\n    RegExp(\"^[a-z]+$\").test(input.pattern) &&\n    (null === input.format ||\n      (\"string\" === typeof input.format &&\n        (__typia_transform__isFormatIpv4._isFormatIpv4(input.format) ||\n          __typia_transform__isFormatIpv6._isFormatIpv6(input.format)))) &&\n    Array.isArray(input.array) &&\n    3 <= input.array.length &&\n    input.array.length <= 100 &&\n    input.array.every(\n      (elem) =>\n        \"string\" === typeof elem &&\n        __typia_transform__isFormatUuid._isFormatUuid(elem),\n    ) &&\n    input.map instanceof Map &&\n    (() =>\n      [...input.map].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"number\" === typeof elem[0] &&\n          __typia_transform__isTypeUint32._isTypeUint32(elem[0]) &&\n          Array.isArray(elem[1]) &&\n          1 <= elem[1].length &&\n          elem[1].every(\n            (elem) =>\n              \"string\" === typeof elem &&\n              __typia_transform__isFormatUuid._isFormatUuid(elem),\n          ),\n      ))();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: Defines an interface for validation results, including success and failure cases with associated data and errors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusable Validation Function Signatures\nDESCRIPTION: Function signatures for creating reusable type validation functions to optimize compiled JavaScript size.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\n```\n\n----------------------------------------\n\nTITLE: Cloning Department and Clerk Structures in TypeScript\nDESCRIPTION: These functions create clones of the department and clerk structures after validation. The _co0 function clones the department, while _co1 clones individual clerks. These ensure that the validated data is properly structured for further use.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst _co0 = (input) => ({\n    id: input.id,\n    name: input.name,\n    limit: input.limit,\n    clerks: _cp0(input.clerks),\n  });\n  const _co1 = (input) => ({\n    name: input.name,\n    age: input.age,\n    authority: input.authority,\n    joined_at: input.joined_at,\n  });\n```\n\n----------------------------------------\n\nTITLE: Validating Map<string, boolean | number | string> in TypeScript\nDESCRIPTION: Demonstrates how to create a validation function for a Map with string keys and boolean, number, or string values using typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntypia.createIs<Map<string, boolean | number | string>>();\n```\n\n----------------------------------------\n\nTITLE: Assertion Guard Type Definition\nDESCRIPTION: Type definition for assertion guards that ensure input values match expected types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport type AssertionGuard<T> = (input: unknown) => asserts input is T;\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for assertFunction\nDESCRIPTION: Shows the compiled JavaScript code for the assertFunction example. It demonstrates how typia transforms TypeScript type annotations into runtime validation code with detailed error handling.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__functionalTypeGuardErrorFactory from \"typia/lib/internal/_functionalTypeGuardErrorFactory.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst func = (() => {\n  const errorFactoryWrapper =\n    __typia_transform__functionalTypeGuardErrorFactory._functionalTypeGuardErrorFactory;\n  const __assert_param_0 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path\n            ? p.path.replace(\"$input\", \"$input.parameters[0]\")\n            : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const __assert_param_1 = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path\n            ? p.path.replace(\"$input\", \"$input.parameters[1]\")\n            : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const __assert_return = (() => {\n    const __is = (input) => \"number\" === typeof input;\n    let _errorFactory;\n    return (\n      input,\n      errorFactory = (p) =>\n        errorFactoryWrapper({\n          ...p,\n          path: p.path ? p.path.replace(\"$input\", \"$input.return\") : undefined,\n        }),\n    ) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          \"number\" === typeof input ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.functional.assertFunction\",\n              path: _path + \"\",\n              expected: \"number\",\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  return (x, y) => {\n    __assert_param_0(x);\n    __assert_param_1(y);\n    return __assert_return(((x, y) => x + y)(x, y));\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: Declares an IValidation type and namespace with interfaces for successful and failed validations. It includes structures for validation results and error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: IValidation Interface Definition\nDESCRIPTION: Defines the IValidation type and namespace for representing validation results. It includes success and failure interfaces, with the failure case containing detailed error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Checking and Assertion Functions in TypeScript\nDESCRIPTION: These functions implement type checking (__is) and assertion (__assert) for the department structure. They ensure that the input matches the expected structure before proceeding with cloning or further processing.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  const __assert = (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.misc.assertClone\",\n              path: _path + \"\",\n              expected: \"IDepartment\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.misc.assertClone\",\n            path: _path + \"\",\n            expected: \"IDepartment\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n  const __clone = (input) => _co0(input);\n  return (input, errorFactory) => __clone(__assert(input, errorFactory));\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Specialized LLM Schema\nDESCRIPTION: This is the compiled JavaScript output of the specialized LLM schema example. It shows how the TypeScript interface and type tags are transformed into a JSON schema object with various property constraints and descriptions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const schema = {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"integer\",\n      deprecated: true,\n      title: \"Unsigned integer\",\n      description: \"Deprecated tags are just used for marking.\",\n    },\n    number: {\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n      title: \"You can limit the range of number\",\n      description: \"You can limit the range of number.\",\n    },\n    string: {\n      oneOf: [\n        {\n          type: \"string\",\n          minLength: 3,\n          maxLength: 24,\n        },\n        {\n          type: \"string\",\n          minLength: 40,\n          maxLength: 100,\n        },\n      ],\n      title: \"You can limit the length of string\",\n      description:\n        \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n    },\n    pattern: {\n      type: \"string\",\n      pattern: \"^[a-z]+$\",\n      title: \"You can limit the pattern of string\",\n      description: \"You can limit the pattern of string.\",\n    },\n    format: {\n      oneOf: [\n        {\n          type: \"string\",\n          format: \"date-time\",\n        },\n        {\n          type: \"null\",\n        },\n      ],\n      title: \"You can limit the format of string\",\n      description: \"You can limit the format of string.\",\n    },\n    array: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        format: \"uuid\",\n      },\n      minItems: 3,\n      title: \"In the Array case, possible to restrict its elements\",\n      description: \"In the Array case, possible to restrict its elements.\",\n    },\n  },\n  required: [\"type\", \"string\", \"pattern\", \"format\", \"array\"],\n  additionalProperties: false,\n};\n```\n\n----------------------------------------\n\nTITLE: Type Resolution Implementation\nDESCRIPTION: Complex type resolution utility that converts class types to their primitive equivalents and handles various type transformations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true ? T : ResolvedMain<T>;\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Customized JSON Schema with Typia\nDESCRIPTION: This snippet shows the compiled JavaScript output for the customized JSON schema. It demonstrates how the custom properties are included in the final schema object.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n({\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"string\",\n      \"x-placeholder\": \"Write you account code please\",\n    },\n    balance: {\n      type: \"number\",\n      \"x-monetary\": \"dollar\",\n    },\n  },\n  required: [\"code\", \"balance\"],\n  additionalProperties: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Property Encoding\nDESCRIPTION: Encodes various property types (float, double, string, uint32, int32, uint64) with type validation and sequence numbering. Handles single values, arrays, and maps using a Protocol Buffer writer implementation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nwriter.uint32(405);\nwriter.float(input.float);\nif (undefined !== input.double) {\n  writer.uint32(481);\n  writer.double(input.double);\n}\nif (null !== input.string) {\n  writer.uint32(562);\n  writer.string(input.string);\n}\nif (\"number\" === typeof input.uint32_or_double && Math.floor(input.uint32_or_double) === input.uint32_or_double && 0 <= input.uint32_or_double && input.uint32_or_double <= 4294967295) {\n  writer.uint32(488);\n  writer.uint32(input.uint32_or_double);\n} else if (\"number\" === typeof input.uint32_or_double && true) {\n  writer.uint32(497);\n  writer.double(input.uint32_or_double);\n}\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class Definition\nDESCRIPTION: Defines the TypeGuardError class which extends the built-in Error class. Used for reporting type validation errors with detailed information about the method, path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Assert Clone\nDESCRIPTION: Demonstrates practical usage of assertClone function with a department interface including nested clerk objects.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nconst department: IDepartment = typia.random<IDepartment>();\nconst cloned: IDepartment = typia.misc.assertClone(department);\n\nconsole.log(cloned);\n\ninterface IDepartment {\n  /**\n   * @format uuid\n   */\n  id: string;\n\n  /**\n   * @minLength 3\n   */\n  name: string;\n\n  /**\n   * @type int\n   */\n  limit: number;\n\n  clerks: IClerk[];\n}\ninterface IClerk {\n  name: string;\n\n  /**\n   * @exclusiveMinimum 19\n   * @maximum 100\n   */\n  age: number;\n\n  authority: number;\n\n  /**\n   * @format date\n   */\n  joined_at: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Protobuf Field Types with Custom Byte Order in TypeScript\nDESCRIPTION: This snippet shows the implementation of protobuf field handling with explicit byte sequence tags. It handles various field types including int32, uint32, uint64, float, and handles nested complex structures like arrays and maps.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n      Math.floor(input.int32_or_float_or_uint64) ===\n          input.int32_or_float_or_uint64 &&\n        -2147483648 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 2147483647\n      ) {\n        writer.uint32(96);\n        writer.int32(input.int32_or_float_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_float_or_uint64) {\n        writer.uint32(104);\n        writer.uint64(input.int32_or_float_or_uint64);\n      } else if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n        -1.175494351e38 <= input.int32_or_float_or_uint64 &&\n        input.int32_or_float_or_uint64 <= 3.4028235e38\n      ) {\n        writer.uint32(117);\n        writer.float(input.int32_or_float_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected:\n            '((bigint & Type<\"uint64\">) | (number & (Type<\"int32\"> | Type<\"float\">))))',\n          value: input.int32_or_float_or_uint64,\n        });\n      // property \"uint64_array\": Array<bigint & Type<\"uint64\">>;\n      if (0 !== input.uint64_array.length) {\n        writer.uint32(122);\n        writer.fork();\n        for (const elem of input.uint64_array) {\n          writer.uint64(elem);\n        }\n        writer.ldelim();\n      }\n      // property \"int32_map\": (Map<(number & Type<\"int32\">), string> | null | undefined);\n      if (undefined !== input.int32_map && null !== input.int32_map) {\n        for (const [key, value] of input.int32_map) {\n          writer.uint32(130);\n          writer.fork();\n          writer.uint32(8);\n          writer.int32(key);\n          writer.uint32(18);\n          writer.string(value);\n          writer.ldelim();\n        }\n      }\n    };\n    _peo0(input);\n    return writer;\n  };\n  return (input) => {\n    const sizer = encoder(\n      new __typia_transform__ProtobufSizer._ProtobufSizer(),\n      input,\n    );\n    const writer = encoder(\n      new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n      input,\n    );\n    return writer.buffer();\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolved Type Utility for Method Erasure\nDESCRIPTION: Defines the Resolved type utility that erases method properties from types. Transforms built-in wrapper classes to primitive types and custom classes to plain objects, maintaining data structure while removing behavior.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Resolved type erased every methods.\n *\n * `Resolved` is a type of TMP (Type Meta Programming) type which converts\n * its argument as a resolved type that erased every method properties.\n *\n * If the target argument is a built-in class which returns its origin primitive type\n * through the `valueOf()` method like the `String` or `Number`, its return type would\n * be the `string` or `number`. Otherwise, the built-in class does not have the\n * `valueOf()` method, the return type would be same with the target argument.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom methods\n * would be erased and its prototype would be changed to the primitive `object`.\n * Therefore, return type of the TMP type finally be the resolved object.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `BigInt`                | `bigint`\n * `String`                | `string`\n * `Class`                 | `interface`\n * Native Class or Others  | No change\n *\n * @template T Target argument type.\n * @author Jeongho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n */\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\ntype ResolvedObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? ResolvedTuple<T>\n    : ResolvedMain<U>[]\n  : T extends Set<infer U>\n  ? Set<ResolvedMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<ResolvedMain<K>, ResolvedMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [P in keyof T]: ResolvedMain<T[P]>;\n    };\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [ResolvedMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [ResolvedMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n  : [];\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeGuardError Class in TypeScript\nDESCRIPTION: Declares a custom error class 'TypeGuardError' for handling type guard failures. It includes properties for the method, path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Array and Map Encoding\nDESCRIPTION: Handles encoding of array types (uint64_array) and map types (int32_map) with proper Protocol Buffer formatting including length delimiting and key-value pair serialization.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nif (0 !== input.uint64_array.length) {\n  writer.uint32(722);\n  writer.fork();\n  for (const elem of input.uint64_array) {\n    writer.uint64(elem);\n  }\n  writer.ldelim();\n}\nif (undefined !== input.int32_map && null !== input.int32_map) {\n  for (const [key, value] of input.int32_map) {\n    writer.uint32(802);\n    writer.fork();\n    writer.uint32(8);\n    writer.int32(key);\n    writer.uint32(18);\n    writer.string(value);\n    writer.ldelim();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Erase Article Endpoint in JSON Schema\nDESCRIPTION: Specifies the structure for the 'erase' endpoint parameters. It requires a UUID 'id' to identify the target article for deletion. The schema ensures proper request validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationSeparateJsonSnippet.mdx#2025-04-20_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"erase\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"id\": {\n        \"title\": \"Target article's {@link IBbsArticle.id}\",\n        \"description\": \"Target article's {@link IBbsArticle.id}.\",\n        \"type\": \"string\",\n        \"format\": \"uuid\"\n      }\n    },\n    \"required\": [\n      \"id\"\n    ],\n    \"additionalProperties\": false,\n    \"$defs\": {}\n  },\n  \"description\": \"Erase an article.\\n\\nErases an article from the DB.\",\n  \"separated\": {\n    \"llm\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"title\": \"Target article's {@link IBbsArticle.id}\",\n          \"description\": \"Target article's {@link IBbsArticle.id}.\",\n          \"type\": \"string\",\n          \"format\": \"uuid\"\n        }\n      },\n      \"required\": [\n        \"id\"\n      ],\n      \"additionalProperties\": false,\n      \"$defs\": {}\n    },\n    \"human\": null\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for typia.json.isStringify()\nDESCRIPTION: Shows the compiled JavaScript code for the typia.json.isStringify() example, demonstrating AOT compilation and optimized type checking.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomFormatDate from \"typia/lib/internal/_randomFormatDate.js\";\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isFormatDate from \"typia/lib/internal/_isFormatDate.js\";\nimport * as __typia_transform__jsonStringifyString from \"typia/lib/internal/_jsonStringifyString.js\";\nimport * as __typia_transform__jsonStringifyNumber from \"typia/lib/internal/_jsonStringifyNumber.js\";\nimport typia from \"typia\";\nconst department = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n        minLength: 3,\n      },\n    ),\n    limit: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    clerks: (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n      type: \"array\",\n      element: () => _ro1(_recursive, _recursive ? 1 + _depth : _depth),\n    }),\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    age: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n    authority: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n    joined_at: (\n      _generator?.date ?? __typia_transform__randomFormatDate._randomFormatDate\n    )(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst json = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    __typia_transform__isTypeInt32._isTypeInt32(input.limit) &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    !Number.isNaN(input.authority) &&\n    \"string\" === typeof input.joined_at &&\n    __typia_transform__isFormatDate._isFormatDate(input.joined_at);\n  const _so0 = (input) =>\n    `{\"id\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.id)},\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"limit\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.limit)},\"clerks\":${`[${input.clerks.map((elem) => _so1(elem)).join(\",\")}]`}}`;\n  const _so1 = (input) =>\n    `{\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"age\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.age)},\"authority\":${__typia_transform__jsonStringifyNumber._jsonStringifyNumber(input.authority)},\"joined_at\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.joined_at)}}`;\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  const __stringify = (input) => _so0(input);\n  return (input) => (__is(input) ? __stringify(input) : null);\n})()(department);\nconsole.log(json); // not null, but string\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Random Data Generation with Typia\nDESCRIPTION: Shows the compiled JavaScript output for random data generation using Typia. It includes imports for various random generation functions and implements the random data generation logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomPick from \"typia/lib/internal/_randomPick.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomPattern from \"typia/lib/internal/_randomPattern.js\";\nimport * as __typia_transform__randomFormatDatetime from \"typia/lib/internal/_randomFormatDatetime.js\";\nimport typia from \"typia\";\nconst data = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    type: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    number: __typia_transform__randomPick._randomPick([\n      () => undefined,\n      () =>\n        (_generator?.number ?? __typia_transform__randomNumber._randomNumber)({\n          type: \"number\",\n          exclusiveMinimum: true,\n          minimum: 19,\n          maximum: 100,\n        }),\n    ])(),\n    string: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n      minLength: 3,\n    }),\n    pattern: (\n      _generator?.pattern ?? __typia_transform__randomPattern._randomPattern\n    )(new RegExp(\"^[a-z]+$\")),\n    format: __typia_transform__randomPick._randomPick([\n      () => null,\n      () =>\n        (\n          _generator?.datetime ??\n          __typia_transform__randomFormatDatetime._randomFormatDatetime\n        )(),\n    ])(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconsole.log(data);\n```\n\n----------------------------------------\n\nTITLE: Defining Type Assertion in TypeScript Source Code\nDESCRIPTION: This snippet shows an example of a TypeScript source file that defines a type assertion using Typia. It imports a type and exports a function that validates that type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nimport { IMember } from \"../structures/IMember\";\n\nexport const check = typia.createIs<IMember>();\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class Definition\nDESCRIPTION: Defines the TypeGuardError class that is thrown when type validation fails. It contains information about the failed validation including method name, path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: TypeGuardError Class Definition\nDESCRIPTION: Defines the TypeGuardError class which is thrown when type validation fails. It includes information about the method, path, expected type, and actual value that caused the error.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Schema with Native Date Class in TypeScript\nDESCRIPTION: This snippet shows how Typia handles the Date class as an exception when generating JSON schemas, treating it as a string with date-time format.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface Native {\n  date: Date;\n}\ntypia.json.schemas<[Native]>();\n```\n\n----------------------------------------\n\nTITLE: Map Type Validation Example\nDESCRIPTION: Example of type validation for Map objects with complex value types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntypia.createIs<Map<string, boolean | number | string>>();\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for validate() Function Usage\nDESCRIPTION: Shows the compiled JavaScript output for the TypeScript example using typia.validate(). It includes the generated validation logic and error reporting mechanism.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nconst res = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.id &&\n        (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n          $report(_exceptionable, {\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        }),\n      (\"string\" === typeof input.email &&\n        (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n          $report(_exceptionable, {\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        }),\n      (\"number\" === typeof input.age &&\n        (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          })) &&\n        (19 < input.age ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          })) &&\n        (input.age <= 100 ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        }),\n    ].every((flag) => flag);\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = __typia_transform__validateReport._validateReport(errors);\n      ((input, _path, _exceptionable = true) =>\n        ((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          })) &&\n          _vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"IMember\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})()({\n  id: 5, // wrong, must be string (uuid)\n  age: 20.75, // wrong, not integer\n  email: \"samchon.github@gmail.com\",\n});\nif (!res.success) console.log(res.errors);\n```\n\n----------------------------------------\n\nTITLE: Type Guard Error Class Definition\nDESCRIPTION: Defines an error class for type guard failures with method, path, expected type, and actual value information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface in TypeScript\nDESCRIPTION: Declares interfaces for validation results, including success and failure cases. It provides a structure for returning validation outcomes with detailed error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Camel Case Conversion in TypeScript\nDESCRIPTION: Demonstrates the usage of typia's camel case conversion function with a sample interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IPerson {\n  is_my_name_samchon?: boolean;\n  HelloTheNewWorld: string;\n  ToHTML: string;\n}\ntypia.notations.createCamel<IPerson>();\n```\n\n----------------------------------------\n\nTITLE: Dynamic Property Restrictions in LLM Schema\nDESCRIPTION: Shows how dynamic property types (Record<string, T>) are not supported in ChatGPT and Gemini schemas, requiring alternative implementations using array structures.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/schema.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ntypia.llm.schema<Record<string, number>, \"chatgpt\">({});\ntypia.llm.schema<Record<string, number>, \"gemini\">();\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf Schema from TypeScript Interface\nDESCRIPTION: This Protobuf schema represents the 'CommentTagExample' interface defined in TypeScript. It includes message fields corresponding to the interface properties with their respective types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\nmessage CommentTagExample {\n  required int32 int32 = 1;\n  optional uint32 uint32 = 2;\n  optional uint64 uint64 = 3;\n  required int64 int64 = 4;\n  optional float float = 5;\n  required double double = 6;\n  required string string = 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizable Interface Definition\nDESCRIPTION: Interface that defines the primitive types that can be customized in the random generator.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing typia with pnpm\nDESCRIPTION: Commands to install typia and run the setup wizard using pnpm package manager with the explicit pnpm manager flag.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install typia\npnpm typia setup --manager pnpm\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript interface for Person entity\nDESCRIPTION: This snippet demonstrates how to define a TypeScript interface for a Person entity with various properties including nested objects and arrays. It showcases Typia's ability to handle complex type structures.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IPerson {\n    id: string;\n    name: string;\n    age: number;\n    email: string;\n    gender: \"male\" | \"female\";\n    birthdate: Date;\n    address: {\n        street: string;\n        city: string;\n        country: string;\n        zipCode: string;\n    };\n    hobbies: string[];\n    education: Array<{\n        degree: string;\n        major: string;\n        university: string;\n        graduationYear: number;\n    }>;\n    workExperience: {\n        company: string;\n        position: string;\n        startDate: Date;\n        endDate?: Date;\n    }[];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation Interface for Validation Results\nDESCRIPTION: Declares an IValidation type and associated interfaces for representing the success or failure of a validation operation. It includes structures for successful validations with data and failed validations with error details.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining validate() Function Signatures in TypeScript\nDESCRIPTION: Defines two overloads of the validate() function in TypeScript. The first overload takes a generic type T as input, while the second accepts an unknown type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Container Type Restrictions in TypeScript to Protocol Buffer Conversion\nDESCRIPTION: This code snippet demonstrates the restrictions on container types when using typia.protobuf functions. It shows that multi-dimensional arrays, nested containers, and union types in container values are not supported. It also illustrates limitations on Map key types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface IPointer<T> {\n  value: T;\n}\ninterface Cat {\n  type: \"cat\";\n  name: string;\n  ribbon: boolean;\n}\ninterface Dog {\n  type: \"dog\";\n  name: string;\n  hunt: boolean;\n}\n\ntypia.protobuf.message<IPointer<number[][]>>();\ntypia.protobuf.createEncode<IPointer<Record<string, string[]>>>();\ntypia.protobuf.createDecode<IPointer<Map<string, Cat | Dog>>>();\n\ntypia.protobuf.message<IPointer<Map<Cat, string>>>();\ntypia.protobuf.message<IPointer<Map<number | string, Dog>>>();\n```\n\nLANGUAGE: bash\nCODE:\n```\nmain.ts:17:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Array<Array<number>>>[key]: Array<Array<number>>\n  - does not support over two dimensional array type\n\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- IPointer<Record<string, Array<string>>>[key]: Record<string, Array<string>>\n  - does not support dynamic object with array value type\n\nmain.ts:19:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- IPointer<Map<string, Cat | Dog>>[key]: Map<string, (Cat | Dog)>\n  - does not support union type in map value type\n\nmain.ts:21:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Map<Cat, string>>[key]: Map<Cat, string>\n  - does not support non-atomic key typed map\n\nmain.ts:22:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Map<string | number, Dog>>[key]: Map<(number | string), Dog>\n  - does not support union key typed map\n  - does not support non-atomic key typed map\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Validation Implementation\nDESCRIPTION: Shows the compiled JavaScript code that implements the type validation logic defined by the comment tags. Includes runtime checks for number ranges, string lengths, and pattern matching.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const checkCustomTag = (() => {\n  const _io0 = (input) =>\n    \"number\" === typeof input.type &&\n    Math.floor(input.type) === input.type &&\n    0 <= input.type &&\n    input.type <= 4294967295 &&\n    (undefined === input.number ||\n      (\"number\" === typeof input.number &&\n        19 < input.number &&\n        input.number <= 100)) &&\n    \"string\" === typeof input.string &&\n    3 <= input.string.length &&\n    \"string\" === typeof input.pattern;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Installing typia with yarn\nDESCRIPTION: Commands to install typia and run the setup wizard using yarn package manager with the explicit yarn manager flag. Note that Yarn Berry is not supported.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Type Checker for String\nDESCRIPTION: Shows the compiled JavaScript output of the Typia type checker for the string type. This demonstrates how Typia transforms the TypeScript type into a runtime function.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/index.mdx#2025-04-20_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolved Type in TypeScript\nDESCRIPTION: This complex snippet defines a Resolved type that erases methods from types and resolves them to their primitive representations. It includes various utility types for handling different scenarios.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never // (special trick for jsonable | null) type\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n\n// ... (rest of the type definitions)\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Parameter Functions in Typia\nDESCRIPTION: Defines the typia.http.parameter<T>() function and typia.http.createParameter<T>() factory function for decoding URL path parameters with type validation. These functions accept string inputs and convert them to specified atomic types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace http {\n  export function parameter<T extends Atomic.Type | null>(input: string): T;\n  export function createParameter<T extends Atomic.Type | null>(): (\n    input: string,\n  ) => T;\n}\n```\n\n----------------------------------------\n\nTITLE: Showcasing Unsupported Types in TypeScript to Protocol Buffer Conversion\nDESCRIPTION: This code snippet demonstrates various unsupported types when using typia.protobuf.message function. It includes examples of any, unknown, functional types, Set, WeakSet, WeakMap, Date, String, and ArrayBuffer, which are not allowed in Protocol Buffer conversion.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface Something {\n  any: any;\n  unknown: unknown;\n  closure: () => void;\n  dict: Set<string> | WeakSet<Something> | WeakMap<Something, string>;\n  date: Date;\n  classic: String;\n  buffer: ArrayBuffer;\n}\n\ntypia.protobuf.message<Something>();\n```\n\nLANGUAGE: bash\nCODE:\n```\nmain.ts:13:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- Something.any: any\n  - does not support any type\n\n- Something.unknown: any\n  - does not support any type\n\n- Something.closure: unknown\n  - does not support functional type\n\n- Something.dict: (Set<string> | WeakMap | WeakSet)\n  - does not support Set type\n  - does not support WeakSet type. Use Array type instead.\n  - does not support WeakMap type. Use Map type instead.\n\n- Something.date: Date\n  - does not support Date type. Use string type instead.\n\n- Something.classic: String\n  - does not support String type. Use string type instead.\n\n- Something.buffer: ArrayBuffer\n  - does not support ArrayBuffer type. Use Uint8Array type instead.\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Custom Tags in Typia\nDESCRIPTION: This snippet shows the compiled JavaScript output for the custom tags defined in TypeScript, demonstrating how Typia transforms the type checks into runtime validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport typia from \"typia\";\nexport const checkTagCustom = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"abcd\") &&\n    \"number\" === typeof input.powerOf &&\n    (() => {\n      const denominator = Math.log(2);\n      const value = Math.log(input.powerOf) / denominator;\n      return Math.abs(value - Math.round(value)) < 1e-8;\n    })();\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Installing typia with bun\nDESCRIPTION: Commands to install typia and run the setup wizard using bun package manager with the explicit bun manager flag.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add typia\nbun typia setup --manager bun\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Schema with Unsupported Types in TypeScript\nDESCRIPTION: This snippet demonstrates an attempt to generate a JSON schema using Typia with unsupported bigint types, which results in compile-time errors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\ninterface Something {\n  bigint: bigint;\n  array: bigint[];\n  nested: Nested;\n}\ninterface Nested {\n  uint64: bigint & tags.Type<\"uint64\">;\n}\n\ntypia.json.schemas<[Something]>();\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Encoder Factory\nDESCRIPTION: Creates and returns a Protocol Buffer encoder function that uses both a sizer and writer to properly format the binary output buffer.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nreturn (input) => {\n  const sizer = encoder(\n    new __typia_transform__ProtobufSizer._ProtobufSizer(),\n    input,\n  );\n  const writer = encoder(\n    new __typia_transform__ProtobufWriter._ProtobufWriter(sizer),\n    input,\n  );\n  return writer.buffer();\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Pattern Tag in TypeScript\nDESCRIPTION: This snippet shows the implementation of a Pattern tag for string types, using a regular expression for validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/tags.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TagBase } from \"./TagBase\";\n\nexport type Pattern<Value extends string> = TagBase<{\n  target: \"string\";\n  kind: \"pattern\";\n  value: Value;\n  validate: `/${Value}/.test($input)`;\n}>;\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of Parameter Decoders\nDESCRIPTION: The compiled JavaScript output showing the implementation details of parameter decoders with format and type constraints. Demonstrates the runtime validation logic for UUID strings and uint32 numbers.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_50\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport * as __typia_transform__httpParameterReadString from \"typia/lib/internal/_httpParameterReadString.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__httpParameterReadNumber from \"typia/lib/internal/_httpParameterReadNumber.js\";\nimport typia from \"typia\";\n(input) => {\n  const assert = (() => {\n    const __is = (input) =>\n      \"string\" === typeof input &&\n      __typia_transform__isFormatUuid._isFormatUuid(input);\n    let _errorFactory;\n    return (input, errorFactory) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          (\"string\" === typeof input &&\n            (__typia_transform__isFormatUuid._isFormatUuid(input) ||\n              __typia_transform__assertGuard._assertGuard(\n                true,\n                {\n                  method: \"typia.http.createParameter\",\n                  path: _path + \"\",\n                  expected: 'string & Format<\"uuid\">',\n                  value: input,\n                },\n                _errorFactory,\n              ))) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.http.createParameter\",\n              path: _path + \"\",\n              expected: '(string & Format<\"uuid\">)',\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const value =\n    __typia_transform__httpParameterReadString._httpParameterReadString(input);\n  return assert(value);\n};\n(input) => {\n  const assert = (() => {\n    const __is = (input) =>\n      \"number\" === typeof input &&\n      __typia_transform__isTypeUint32._isTypeUint32(input);\n    let _errorFactory;\n    return (input, errorFactory) => {\n      if (false === __is(input)) {\n        _errorFactory = errorFactory;\n        ((input, _path, _exceptionable = true) =>\n          (\"number\" === typeof input &&\n            (__typia_transform__isTypeUint32._isTypeUint32(input) ||\n              __typia_transform__assertGuard._assertGuard(\n                true,\n                {\n                  method: \"typia.http.createParameter\",\n                  path: _path + \"\",\n                  expected: 'number & Type<\"uint32\">',\n                  value: input,\n                },\n                _errorFactory,\n              ))) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.http.createParameter\",\n              path: _path + \"\",\n              expected: '(number & Type<\"uint32\">)',\n              value: input,\n            },\n            _errorFactory,\n          ))(input, \"$input\", true);\n      }\n      return input;\n    };\n  })();\n  const value =\n    __typia_transform__httpParameterReadNumber._httpParameterReadNumber(input);\n  return assert(value);\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for IMember Validation\nDESCRIPTION: Shows the compiled JavaScript code for the IMember validation function, including internal typia transformations and validations.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatEmail from \"typia/lib/internal/_isFormatEmail.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__validateReport from \"typia/lib/internal/_validateReport.js\";\nimport typia from \"typia\";\nexport const validateMember = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    \"string\" === typeof input.email &&\n    __typia_transform__isFormatEmail._isFormatEmail(input.email) &&\n    \"number\" === typeof input.age &&\n    __typia_transform__isTypeUint32._isTypeUint32(input.age) &&\n    19 < input.age &&\n    input.age <= 100;\n  const _vo0 = (input, _path, _exceptionable = true) =>\n    [\n      (\"string\" === typeof input.id &&\n        (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n          $report(_exceptionable, {\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        }),\n      (\"string\" === typeof input.email &&\n        (__typia_transform__isFormatEmail._isFormatEmail(input.email) ||\n          $report(_exceptionable, {\n            path: _path + \".email\",\n            expected: 'string & Format<\"email\">',\n            value: input.email,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".email\",\n          expected: '(string & Format<\"email\">)',\n          value: input.email,\n        }),\n      (\"number\" === typeof input.age &&\n        (__typia_transform__isTypeUint32._isTypeUint32(input.age) ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: 'number & Type<\"uint32\">',\n            value: input.age,\n          })) &&\n        (19 < input.age ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & ExclusiveMinimum<19>\",\n            value: input.age,\n          })) &&\n        (input.age <= 100 ||\n          $report(_exceptionable, {\n            path: _path + \".age\",\n            expected: \"number & Maximum<100>\",\n            value: input.age,\n          }))) ||\n        $report(_exceptionable, {\n          path: _path + \".age\",\n          expected:\n            '(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\n          value: input.age,\n        }),\n    ].every((flag) => flag);\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let errors;\n  let $report;\n  return (input) => {\n    if (false === __is(input)) {\n      errors = [];\n      $report = __typia_transform__validateReport._validateReport(errors);\n      ((input, _path, _exceptionable = true) =>\n        ((\"object\" === typeof input && null !== input) ||\n          $report(true, {\n            path: _path + \"\",\n            expected: \"IMember\",\n            value: input,\n          })) &&\n          _vo0(input, _path + \"\", true)) ||\n        $report(true, {\n          path: _path + \"\",\n          expected: \"IMember\",\n          value: input,\n        }))(input, \"$input\", true);\n      const success = 0 === errors.length;\n      return {\n        success,\n        errors,\n        data: success ? input : undefined,\n      };\n    }\n    return {\n      success: true,\n      errors: [],\n      data: input,\n    };\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Manual Installation with pnpm\nDESCRIPTION: Commands for manually installing typia, typescript, and ts-patch as dependencies using pnpm.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npnpm install --save typia\npnpm install --save-dev typescript ts-patch\n```\n\n----------------------------------------\n\nTITLE: Validation Interface Definition\nDESCRIPTION: Defines interfaces for validation results including success and failure cases with detailed error information.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Member Assertion Implementation Example\nDESCRIPTION: Example implementation of a type assertion for member data with format validation and numeric constraints.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const assertMember = typia.createAssert<IMember>();\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CamelCase Type in TypeScript\nDESCRIPTION: Defines a complex type for converting object keys to camel case, handling various data types and nested structures.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Camel case type.\n *\n * `CamelCase` type is a type that all keys of an object are camelized.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be camelized\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type CamelCase<T> = Equal<T, CamelizeMain<T>> extends true\n  ? T\n  : CamelizeMain<T>;\n\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype CamelizeMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? CamelizeObject<T>\n  : T;\n\ntype CamelizeObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? CamelizeTuple<T>\n    : CamelizeMain<U>[]\n  : T extends Set<infer U>\n  ? Set<CamelizeMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<CamelizeMain<K>, CamelizeMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as CamelizeString<Key & string>]: CamelizeMain<T[Key]>;\n    };\n\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype CamelizeTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [CamelizeMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [CamelizeMain<F>, ...CamelizeTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [CamelizeMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [CamelizeMain<F>?, ...CamelizeTuple<Rest>]\n  : [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype CamelizeString<Key extends string> = Key extends `_${infer R}`\n  ? `_${CamelizeString<R>}`\n  : Key extends `${infer F}${infer R}`\n  ? `${Lowercase<F>}${CamelizeStringRepeatedly<R>}`\n  : Key;\ntype CamelizeStringRepeatedly<Key extends string> =\n  Key extends `${infer F}_${infer R}`\n    ? `${F}${Capitalize<CamelizeStringRepeatedly<R>>}`\n    : Key;\n```\n\n----------------------------------------\n\nTITLE: Installing typia with npm\nDESCRIPTION: Commands to install typia and run the setup wizard using npm package manager.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install typia\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Custom Type Tags Validation\nDESCRIPTION: This is the compiled JavaScript code for the custom type tags validation. It implements the validation logic for the Dollar, Postfix, and IsEven tags defined in the TypeScript code.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nexport const checkSomething = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"!!!\") &&\n    \"number\" === typeof input.isEven &&\n    input.isEven % 2 === 0;\n  return (input) => \"object\" === typeof input && null !== input && _io0(input);\n})();\n```\n\n----------------------------------------\n\nTITLE: Manual Installation with yarn\nDESCRIPTION: Commands for manually installing typia, typescript, and ts-patch as dependencies using yarn. Note that Yarn Berry is not supported.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn add -D typescript ts-patch\n```\n\n----------------------------------------\n\nTITLE: Configuring Typia Plugin in tsconfig.json\nDESCRIPTION: Shows how to configure the typia plugin in tsconfig.json to enable validation of function types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeGuardError Class for Error Handling\nDESCRIPTION: Defines the TypeGuardError class that extends the standard Error class to provide detailed type validation error information. Includes properties for the method name, property path, expected type, and actual value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom JSON Schema Properties Implementation\nDESCRIPTION: Shows how to add custom properties to JSON schema definitions using tags.TagBase.schema and tags.JsonSchemaPlugin.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n \ntype Monetary<Value extends string> = tags.TagBase<{\n  target: \"number\";\n  kind: \"monetary\";\n  value: Value;\n  schema: {\n    \"x-monetary\": Value;\n  };\n}>;\n\ntype Placeholder<Value extends string> = tags.JsonSchemaPlugin<{\n  \"x-placeholder\": Value;\n}>;\n\ninterface IAccount {\n  code: string & Placeholder<\"Write you account code please\">;\n  balance: number & Monetary<\"dollar\">;\n};\n \ntypia.json.schemas<[IAccount]>();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      IAccount: {\n        type: \"object\",\n        properties: {\n          code: {\n            type: \"string\",\n            \"x-placeholder\": \"Write you account code please\",\n          },\n          balance: {\n            type: \"number\",\n            \"x-monetary\": \"dollar\",\n          },\n        },\n        required: [\"code\", \"balance\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/IAccount\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Manual Installation with bun\nDESCRIPTION: Commands for manually installing typia, typescript, and ts-patch as dependencies using bun.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbun add typia\nbun add -d typescript ts-patch\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Output for Custom Validation Tags\nDESCRIPTION: The compiled JavaScript code resulting from the TypeScript custom tags implementation. It shows how typia transforms type assertions into runtime validation logic that checks for dollar strings, postfixed strings, and even numbers.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertSomething = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.dollar &&\n    input.dollar[0] === \"$\" &&\n    !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n    \"string\" === typeof input.postfix &&\n    input.postfix.endsWith(\"!!!\") &&\n    \"number\" === typeof input.isEven &&\n    input.isEven % 2 === 0;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.dollar &&\n      ((input.dollar[0] === \"$\" &&\n        !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".dollar\",\n            expected: \"string & Dollar\",\n            value: input.dollar,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".dollar\",\n          expected: \"(string & Dollar)\",\n          value: input.dollar,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.postfix &&\n      (input.postfix.endsWith(\"!!!\") ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".postfix\",\n            expected: 'string & Postfix<\"!!!\">', \n            value: input.postfix,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".postfix\",\n          expected: '(string & Postfix<\"!!!\">)',\n          value: input.postfix,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.isEven &&\n      (input.isEven % 2 === 0 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".isEven\",\n            expected: \"number & IsEven<number>\",\n            value: input.isEven,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".isEven\",\n          expected: \"(number & IsEven<number>)\",\n          value: input.isEven,\n        },\n        _errorFactory,\n      ));\n  const __is = (input) =>\n    \"object\" === typeof input && null !== input && _io0(input);\n  let _errorFactory;\n  return (input, errorFactory) => {\n    if (false === __is(input)) {\n      _errorFactory = errorFactory;\n      ((input, _path, _exceptionable = true) =>\n        (((\"object\" === typeof input && null !== input) ||\n          __typia_transform__assertGuard._assertGuard(\n            true,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \"\",\n              expected: \"Something\",\n              value: input,\n            },\n            _errorFactory,\n          )) &&\n          _ao0(input, _path + \"\", true)) ||\n        __typia_transform__assertGuard._assertGuard(\n          true,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \"\",\n            expected: \"Something\",\n            value: input,\n          },\n          _errorFactory,\n        ))(input, \"$input\", true);\n    }\n    return input;\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Running prepare script with npm\nDESCRIPTION: Command to run the prepare script to install ts-patch using npm.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prepare\n```\n\n----------------------------------------\n\nTITLE: Article Update Validation Implementation\nDESCRIPTION: Implements validation logic for updating an article. Checks for valid UUID, input object structure, and validates optional fields like title, body, and thumbnail URI.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationJavaScriptSnippet.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst _io0 = (input) =>\n  \"string\" === typeof input.id &&\n  __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n  \"object\" === typeof input.input &&\n  null !== input.input &&\n  false === Array.isArray(input.input) &&\n  _io1(input.input);\n\nconst _io1 = (input) =>\n  (undefined === input.title || \"string\" === typeof input.title) &&\n  (undefined === input.body || \"string\" === typeof input.body) &&\n  (null === input.thumbnail ||\n    undefined === input.thumbnail ||\n    (\"string\" === typeof input.thumbnail &&\n      __typia_transform__isFormatUri._isFormatUri(input.thumbnail)));\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Interfaces in Typia\nDESCRIPTION: Specifies the IValidation namespace and interfaces for handling validation results. Includes structures for both successful validations (with typed data) and validation failures (with detailed error information).\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Encode Function Declarations\nDESCRIPTION: Namespace containing Protocol Buffer encoding function declarations for converting types to Uint8Array\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace protobuf {\n  export function encode<T>(): (input: T) => Uint8Array;\n  export function isEncode<T>(): (input: T) => Uint8Array | null;\n  export function assertEncode<T>(): (input: T) => Uint8Array;\n  export function validateEncode<T>(): (input: T) => IValidation<Uint8Array>;\n}\n```\n\n----------------------------------------\n\nTITLE: Running prepare script with pnpm\nDESCRIPTION: Command to run the prepare script to install ts-patch using pnpm.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npnpm prepare\n```\n\n----------------------------------------\n\nTITLE: Generated JSON Schema Output for Native Date Class\nDESCRIPTION: This snippet displays the generated JSON schema output for an interface containing a Date property, showing how it's represented as a string with date-time format.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/schema.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n({\n  version: \"3.1\",\n  components: {\n    schemas: {\n      Native: {\n        type: \"object\",\n        properties: {\n          date: {\n            type: \"string\",\n            format: \"date-time\",\n          },\n        },\n        required: [\"date\"],\n      },\n    },\n  },\n  schemas: [\n    {\n      $ref: \"#/components/schemas/Native\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Running prepare script with bun\nDESCRIPTION: Command to run the prepare script to install ts-patch using bun.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nbun prepare\n```\n\n----------------------------------------\n\nTITLE: Resolved Type Utility Implementation\nDESCRIPTION: Implements a type meta programming utility that erases method properties and resolves types to their primitive equivalents where applicable.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n  ? T\n  : ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<T> = T extends [never]\n  ? never\n  : ValueOf<T> extends boolean | number | bigint | string\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? ResolvedObject<T>\n  : ValueOf<T>;\n```\n\n----------------------------------------\n\nTITLE: Generating Random Data with Typia Transformers\nDESCRIPTION: This snippet shows the generation of random data using various Typia transformer functions. It includes conditional logic based on depth and recursion, and handles different data types like arrays, strings, and custom objects.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            \"x-protobuf-sequence\": 30,\n            element: () => _ro0(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n    keywords: new Map(\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => [\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n              (\n                _generator?.string ??\n                __typia_transform__randomString._randomString\n              )({\n                type: \"string\",\n              }),\n            ],\n          })\n        : [],\n    ),\n    thumbnail: __typia_transform__randomPick._randomPick([\n      () =>\n        (\n          _generator?.uri ?? __typia_transform__randomFormatUri._randomFormatUri\n        )(),\n      () =>\n        new Uint8Array(\n          5 >= _depth\n            ? (\n                _generator?.array ?? __typia_transform__randomArray._randomArray\n              )({\n                type: \"array\",\n                element: () =>\n                  (\n                    _generator?.integer ??\n                    __typia_transform__randomInteger._randomInteger\n                  )({\n                    type: \"integer\",\n                    minimum: 0,\n                    maximum: 255,\n                  }),\n              })\n            : [],\n        ),\n    ])(),\n    email: (\n      _generator?.email ??\n      __typia_transform__randomFormatEmail._randomFormatEmail\n    )(),\n    hobbies:\n      5 >= _depth\n        ? (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n            type: \"array\",\n            element: () => _ro1(true, _recursive ? 1 + _depth : _depth),\n          })\n        : [],\n```\n\n----------------------------------------\n\nTITLE: Type Testing Function Signatures\nDESCRIPTION: Core type validation function signatures in Typia for testing value types against TypeScript types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function is<T>(input: T): input is T;\nexport function is<T>(input: unknown): input is T;\n```\n\n----------------------------------------\n\nTITLE: Installing unplugin-typia with pnpm\nDESCRIPTION: Commands to install unplugin-typia via JSR and set up typia using pnpm manager.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\npnpm dlx jsr add -D @ryoppippi/unplugin-typia\npnpm install typia\npnpm typia setup --manager pnpm\n```\n\n----------------------------------------\n\nTITLE: Defining Pascal Case Functions in Typia Namespace\nDESCRIPTION: Declares a set of functions in the typia.notations namespace for converting, asserting, validating, and creating pascal case transformations. These functions operate on generic types and provide type-safe conversions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace notations {\n  export function pascal<T>(input: T): PascalCase<T>;\n  export function assertPascal<T>(input: T | unknown): PascalCase<T>;\n  export function isPascal<T>(input: T | unknown): PascalCase<T> | null;\n  export function validatePascal<T>(\n    input: T | unknown,\n  ): IValidation<PascalCase<T>>;\n\n  export function createPascal<T>(): (input: T) => PascalCase<T>;\n  export function createAssertPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T>;\n  export function createIsPascal<T>(): (\n    input: T | unknown,\n  ) => PascalCase<T> | null;\n  export function createValidatePascal<T>(): (\n    input: T | unknown,\n  ) => IValidation<PascalCase<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing unplugin-typia with npm\nDESCRIPTION: Commands to install unplugin-typia via JSR or npm, plus typia setup instructions for bundler integration.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nnpx jsr add -D @ryoppippi/unplugin-typia # via jsr (recommended)\n# npm install -D @ryoppippi/unplugin-typia # via npm\n\nnpm install --save typia\nnpx typia setup\n```\n\n----------------------------------------\n\nTITLE: Using createValidate for IMember Interface in TypeScript\nDESCRIPTION: Demonstrates how to use typia.createValidate to generate a reusable validation function for an IMember interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n\nexport const validateMember = typia.createValidate<IMember>();\n\ninterface IMember {\n  id: string & tags.Format<\"uuid\">;\n  email: string & tags.Format<\"email\">;\n  age: number &\n    tags.Type<\"uint32\"> &\n    tags.ExclusiveMinimum<19> &\n    tags.Maximum<100>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Object Structure for Random Generation\nDESCRIPTION: This snippet defines the structure of objects to be randomly generated. It includes properties like id, name, and valid, using various random generation functions from the Typia library.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst _ro1 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    valid: (\n      _generator?.boolean ?? __typia_transform__randomBoolean._randomBoolean\n    )({\n      type: \"boolean\",\n    }),\n  });\n```\n\n----------------------------------------\n\nTITLE: Decoding Protocol Buffer Data in JavaScript\nDESCRIPTION: This code snippet defines two decoding functions (_pdo0 and _pdo1) that parse Protocol Buffer encoded data. It handles fields like 'id', 'name', 'valid', and 'hobbies', using a custom ProtobufReader to read different data types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\noutput.hobbies.push(_pdo1(reader, reader.uint32()));\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst _pdo1 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nid: \"\",\nname: \"\",\nvalid: undefined,\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// string;\noutput.id = reader.string();\nbreak;\ncase 2:\n// string;\noutput.name = reader.string();\nbreak;\ncase 3:\n// bool;\noutput.valid = reader.bool();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nreturn (input) => {\nconst reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\nreturn _pdo0(reader);\n};\n})()(encoded);\nconsole.log(member, decoded);\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating Code with npm\nDESCRIPTION: Commands for installing Typia and its dependencies, then using the typia CLI to generate transformed TypeScript code.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n# INSTALL TYPIA\nnpm install --save typia\nnpm install --save-dev typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nnpx typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Camel Case Conversion\nDESCRIPTION: Shows the compiled JavaScript output for the camel case conversion function, implementing the conversion logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    isMyNameSamchon: input.is_my_name_samchon,\n    helloTheNewWorld: input.HelloTheNewWorld,\n    toHTML: input.ToHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating TypeScript Code with Bun\nDESCRIPTION: This snippet shows how to use Bun to install Typia and TypeScript, then generate transformed TypeScript code. It uses the same command structure as the other package managers.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n# INSTALL TYPIA\nbun add typia\nbun add -d typescript\nbun typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Defining Clone Function Namespace in TypeScript\nDESCRIPTION: Defines the misc namespace containing various clone function signatures for deep copying with optional type validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport namespace misc {\n  export function clone<T>(input: T): T;\n  export function assertClone<T>(input: T | unknown): Resolved<T>;\n  export function isClone<T>(input: T | unknown): Resolved<T> | null;\n  export function validateClone<T>(input: T | unknown): IValidation<Resolved<T>>;\n\n  export function createClone<T>(): (input: T) => Resolved<T>;\n  export function createAssertClone<T>(): (input: T | unknown) => Resolved<T>;\n  export function createIsClone<T>(): (input: T | unknown) => Resolved<T> | null;\n  export function createValidateClone<T>(): (\n      input: T | unknown\n  ) => IValidation<Resolved<T>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of BBS Article Controller\nDESCRIPTION: The compiled JavaScript output showing the runtime configuration of the LLM application with detailed type information and validation rules for the BBS article management system.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    strict: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        description: \" Properties of create function\",\n        type: \"object\",\n        properties: {\n          input: {\n            description: \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description: \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description: \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n      },\n      description: \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n    },\n    {\n      name: \"update\",\n      parameters: {\n        description: \" Properties of update function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description: \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description: \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description: \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description: \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description: \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [],\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n    },\n    {\n      name: \"erase\",\n      parameters: {\n        description: \" Properties of erase function\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description: \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n        },\n        required: [\"id\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Erase an article.\\n\\nErases an article from the DB.\",\n    },\n  ],\n};\nconst func = app.functions.find((func) => func.name === \"create\");\nconsole.log(func?.description);\nconsole.log(func?.parameters.description);\nconsole.log(func?.output?.description);\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of isFunction\nDESCRIPTION: Shows the compiled JavaScript output for the isFunction type checker, including runtime type validation logic for parameters and return value.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/functional.mdx#2025-04-20_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\nimport typia from \"typia\";\nconst func = (() => {\n  const __is_param_0 = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  const __is_param_1 = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  const __is_return = (() => {\n    return (input) => \"number\" === typeof input;\n  })();\n  return (x, y) => {\n    if (false === __is_param_0(x)) return null;\n    if (false === __is_param_1(y)) return null;\n    const result = ((x, y) => x + y)(x, y);\n    return __is_return(result) ? result : null;\n  };\n})();\nfunc(3, 4);\nfunc(4, 5);\n```\n\n----------------------------------------\n\nTITLE: Installing Typia with yarn (Berry not supported)\nDESCRIPTION: Commands for installing Typia using yarn, with a note that Yarn Berry is not supported.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn add -D typescript\n```\n\n----------------------------------------\n\nTITLE: Manual Installation with npm\nDESCRIPTION: Commands for manually installing typia, typescript, and ts-patch as dependencies using npm.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save typia\nnpm install --save-dev typescript ts-patch\n```\n\n----------------------------------------\n\nTITLE: Assertion Guard Usage Example\nDESCRIPTION: Demonstrates proper usage of assertion guards with explicit type declarations to avoid TypeScript compiler errors.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/assert.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { AssertionGuard } from \"typia\";\n\n//MUST DECLARE THE VARIABLE TYPE\nconst explicit: AssertionGuard<number> = typia.createAssertGuard<number>();\n\n// IF NOT, COMPILATION ERROR BE OCCURRED\nconst implicit = typia.createAssertGuard<number>();\n```\n\n----------------------------------------\n\nTITLE: Type Guard Error Class Definition\nDESCRIPTION: Error class for handling type guard failures with method, path, expected type and actual value information\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TypeGuardError extends Error {\n  public readonly method: string;\n  public readonly path: string | undefined;\n  public readonly expected: string;\n  public readonly value: any;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Special Numeric Types with Comment Tags in TypeScript\nDESCRIPTION: This TypeScript code defines an interface 'CommentTagExample' using @type comment tags to specify special numeric types. It also includes functions for Protobuf message schema, decoding, and encoding.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\nexport interface CommentTagExample {\n  /**\n   * @type int32\n   */\n  int32: number;\n\n  /**\n   * @type uint32\n   */\n  uint32?: number | null;\n\n  /**\n   * @type uint64\n   */\n  uint64?: number;\n\n  /**\n   * @type int64\n   */\n  int64: number;\n\n  /**\n   * @type float\n   */\n  float: number | null;\n\n  double: number;\n\n  string: string;\n}\n\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<CommentTagExample>();\n\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<CommentTagExample>();\n\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<CommentTagExample>();\n```\n\n----------------------------------------\n\nTITLE: Configuring Express.js Route with Typia in JavaScript\nDESCRIPTION: This code snippet defines an Express.js application configuration, including a route handler that processes input and returns a success response. It appears to use Typia for type validation, though the full context is not provided.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationJavaScriptSnippet.mdx#2025-04-20_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n            success: true,\n            data: input,\n          };\n        };\n      })(),\n    },\n  ],\n};\nconsole.log(app);\n```\n\n----------------------------------------\n\nTITLE: Class Validator Implementation\nDESCRIPTION: Example showing how class-validator requires multiple decorators and class definitions for validation. Includes API property decorators and validation rules for a BBS article system.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\n\nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n\n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n\n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n\n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating Code with pnpm\nDESCRIPTION: Commands for installing Typia and its dependencies using pnpm, then generating transformed TypeScript code with the typia CLI.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n# INSTALL TYPIA\npnpm install --save typia\npnpm install --save-dev typescript\n```\n\n----------------------------------------\n\nTITLE: Defining IValidation interface in TypeScript\nDESCRIPTION: Declares the IValidation type and related interfaces for handling validation results in typia.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Object Stringify Test in TypeScript\nDESCRIPTION: A TypeScript function demonstrating how to add a test for the typia.json.stringify() method with recursive objects. It includes random data generation, stringification, and result comparison.\nSOURCE: https://github.com/samchon/typia/blob/master/CONTRIBUTING.md#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\"\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nexport function test_stringify_object_recursive(): void\n{\n    const department: IDepartment = {\n        name: RandomGenerator.string(),\n        parent: {\n            name: RandomGenerator.string(),\n            parent: {\n                name: RandomGenerator.string(),\n                parent: null\n            }\n        }\n    };\n\n    const json: string = typia.json.stringify<IDepartment>(department);\n    const expected: string = JSON.stringify(department);\n\n    if (json !== expected)\n        throw new Error(\"Bug on typia.json.stringify(): failed to understand the recursive object.\");\n}\n\ninterface IDepartment\n{\n    name: string;\n    parent: IDepartment | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Stringify Function in TypeScript\nDESCRIPTION: This code snippet appears to be part of a function that generates a JSON stringify implementation for a specific type. It includes type assertions, error handling, and custom serialization logic.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/json/stringify.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\npath: _path + \".joined_at\",\nexpected: 'string & Format<\"date\">',\nvalue: input.joined_at,\n},\n_errorFactory,\n))) ||\n__typia_transform__assertGuard._assertGuard(\n_exceptionable,\n{\nmethod: \"typia.json.createAssertStringify\",\npath: _path + \".joined_at\",\nexpected: '(string & Format<\"date\">)',\nvalue: input.joined_at,\n},\n_errorFactory,\n));\nconst _so0 = (input) =>\n`{\"id\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.id)},\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"limit\":${input.limit},\"clerks\":${`[${input.clerks.map((elem) => _so1(elem)).join(\",\")}]`}}`;\nconst _so1 = (input) =>\n`{\"name\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.name)},\"age\":${input.age},\"authority\":${input.authority},\"joined_at\":${__typia_transform__jsonStringifyString._jsonStringifyString(input.joined_at)}}`;\nconst __is = (input) =>\n\"object\" === typeof input && null !== input && _io0(input);\nlet _errorFactory;\nconst __assert = (input, errorFactory) => {\nif (false === __is(input)) {\n_errorFactory = errorFactory;\n((input, _path, _exceptionable = true) =>\n((\"object\" === typeof input && null !== input) ||\n__typia_transform__assertGuard._assertGuard(\ntrue,\n{\nmethod: \"typia.json.createAssertStringify\",\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input,\n},\n_errorFactory,\n)) &&\n_ao0(input, _path + \"\", true)) ||\n__typia_transform__assertGuard._assertGuard(\ntrue,\n{\nmethod: \"typia.json.createAssertStringify\",\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input,\n},\n_errorFactory,\n))(input, \"$input\", true);\n}\nreturn input;\n};\nconst __stringify = (input) => _so0(input);\nreturn (input, errorFactory) => {\n__assert(input, errorFactory);\nreturn __stringify(input);\n};\n```\n\n----------------------------------------\n\nTITLE: Creating TypeScript Type Checker for String\nDESCRIPTION: Demonstrates how to use Typia to create a type checker for the string type. This example shows the TypeScript code that defines the type checker function.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/index.mdx#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for BBS Article Assertion\nDESCRIPTION: The compiled JavaScript code generated by typia for runtime type assertion of the IBbsArticle interface. It includes optimized validation logic for each property.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__isFormatUuid from \"typia/lib/internal/_isFormatUuid.js\";\nimport * as __typia_transform__isFormatDateTime from \"typia/lib/internal/_isFormatDateTime.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nexport const assertArticle = (() => {\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    __typia_transform__isFormatUuid._isFormatUuid(input.id) &&\n    (null === input.files ||\n      (Array.isArray(input.files) &&\n        input.files.every(\n          (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n        ))) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        5 <= input.title.length &&\n        input.title.length <= 100)) &&\n    \"string\" === typeof input.body &&\n    \"string\" === typeof input.created_at &&\n    __typia_transform__isFormatDateTime._isFormatDateTime(input.created_at);\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    RegExp(\"^[a-z0-9]+$\").test(input.name) &&\n    input.name.length <= 255 &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        RegExp(\"^[a-z0-9]+$\").test(input.extension) &&\n        input.extension.length <= 8)) &&\n    \"string\" === typeof input.url;\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (__typia_transform__isFormatUuid._isFormatUuid(input.id) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.files ||\n      ((Array.isArray(input.files) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".files\",\n            expected: \"(Array<IAttachmentFile> | null)\",\n            value: input.files,\n          },\n          _errorFactory,\n        )) &&\n        input.files.every(\n          (elem, _index2) =>\n            (((\"object\" === typeof elem && null !== elem) ||\n              __typia_transform__assertGuard._assertGuard(\n                _exceptionable,\n                {\n                  method: \"typia.createAssert\",\n                  path: _path + \".files[\" + _index2 + \"]\",\n                  expected: \"IAttachmentFile\",\n                  value: elem,\n                },\n                _errorFactory,\n              )) &&\n              _ao1(\n                elem,\n                _path + \".files[\" + _index2 + \"]\",\n                true && _exceptionable,\n              )) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.createAssert\",\n                path: _path + \".files[\" + _index2 + \"]\",\n                expected: \"IAttachmentFile\",\n                value: elem,\n              },\n              _errorFactory,\n            ),\n        )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".files\",\n          expected: \"(Array<IAttachmentFile> | null)\",\n          value: input.files,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.title ||\n      (\"string\" === typeof input.title &&\n        (5 <= input.title.length ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MinLength<5>\",\n              value: input.title,\n            },\n            _errorFactory,\n          )) &&\n        (input.title.length <= 100 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".title\",\n              expected: \"string & MaxLength<100>\",\n              value: input.title,\n            },\n            _errorFactory,\n          ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".title\",\n          expected: \"((string & MinLength<5> & MaxLength<100>) | null)\",\n          value: input.title,\n        },\n        _errorFactory,\n      )) &&\n    (\"string\" === typeof input.body ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".body\",\n          expected: \"string\",\n          value: input.body,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.created_at &&\n      (__typia_transform__isFormatDateTime._isFormatDateTime(\n        input.created_at,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".created_at\",\n            expected: 'string & Format<\"date-time\">',\n            value: input.created_at,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".created_at\",\n          expected: '(string & Format<\"date-time\">)',\n          value: input.created_at,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.name &&\n      (RegExp(\"^[a-z0-9]+$\").test(input.name) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n            value: input.name,\n          },\n          _errorFactory,\n        )) &&\n      (input.name.length <= 255 ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.createAssert\",\n            path: _path + \".name\",\n            expected: \"string & MaxLength<255>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.createAssert\",\n          path: _path + \".name\",\n          expected: '(string & Pattern<\"^[a-z0-9]+$\"> & MaxLength<255>)',\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    (null === input.extension ||\n      (\"string\" === typeof input.extension &&\n        (RegExp(\"^[a-z0-9]+$\").test(input.extension) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n              expected: 'string & Pattern<\"^[a-z0-9]+$\">',\n              value: input.extension,\n            },\n            _errorFactory,\n          )) &&\n        (input.extension.length <= 8 ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.createAssert\",\n              path: _path + \".extension\",\n\n```\n\n----------------------------------------\n\nTITLE: AJV JSON Schema Definition\nDESCRIPTION: JSON schema definition required by AJV for validation, showing the verbose nature of schema definitions compared to pure TypeScript types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/pure.mdx#2025-04-20_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"schemas\": [\n    {\n      \"$ref\": \"#/components/schemas/IBbsArticle\"\n    }\n  ],\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"nullable\": true,\n            \"title\": \"List of attached files\",\n            \"description\": \"List of attached files.\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating Code with bun\nDESCRIPTION: Commands for installing Typia and its dependencies using bun, then generating transformed TypeScript code with the typia CLI.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n# INSTALL TYPIA\nbun add typia\nbun add -d typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nbun typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Custom Type Tag Example\nDESCRIPTION: The compiled JavaScript output of the custom type tag example, showing how typia transforms TypeScript code with internal type handling.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\nconst data = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    dollar: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n    }),\n    postfix: (\n      _generator?.string ?? __typia_transform__randomString._randomString\n    )({\n      type: \"string\",\n    }),\n    powerOf: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()({\n  customs: {\n    string: (tags) => {\n      if (tags.find((t) => t.kind === \"dollar\") !== undefined)\n        return \"$\" + RandomGenerator.integer();\n      const postfix = tags.find((t) => t.kind === \"postfix\");\n      if (postfix !== undefined)\n        return RandomGenerator.string() + postfix.value;\n    },\n  },\n});\nconsole.log(data);\n```\n\n----------------------------------------\n\nTITLE: Auto Type Casting Example\nDESCRIPTION: Shows how to use type validation for safe type casting with automatic type inference.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst input: unknown = {\n  id: v4(),\n  email: \"samchon.github@gmail.com\",\n  age: 30,\n} as any;\n\nif (typia.is<IMember>(input)) {\n  // auto type casting\n  console.log(input.id, input.email, input.age);\n}\n```\n\n----------------------------------------\n\nTITLE: Generated LLM Application Schema in JavaScript\nDESCRIPTION: This snippet shows the generated LLM application schema in JavaScript. It includes only the 'create' and 'update' functions, as the 'at' and 'erase' functions were hidden using comment tags in the TypeScript source.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = {\n  model: \"chatgpt\",\n  options: {\n    reference: false,\n    separate: null,\n  },\n  functions: [\n    {\n      name: \"create\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          input: {\n            description:\n              \"Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the current {@link IBbsArticle.ICreate} type:\\n\\n> Information of the article to create.\\n\\n------------------------------\\n\\nDescription of the parent {@link IBbsArticle} type:\\n\\n> Article entity.\\n> \\n> `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n            additionalProperties: false,\n          },\n        },\n        required: [\"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      output: {\n        description:\n          \"Article entity.\\n\\n`IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).\",\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Primary Key\",\n            description: \"Primary Key.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          created_at: {\n            title: \"Creation time of the article\",\n            description: \"Creation time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          updated_at: {\n            title: \"Last updated time of the article\",\n            description:\n              \"Last updated time of the article.\\n\\n\\n@format date-time\",\n            type: \"string\",\n          },\n          title: {\n            title: \"Title of the article\",\n            description:\n              \"Title of the article.\\n\\nRepresentative title of the article.\",\n            type: \"string\",\n          },\n          body: {\n            title: \"Content body\",\n            description:\n              \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n            type: \"string\",\n          },\n          thumbnail: {\n            title: \"Thumbnail image URI\",\n            description:\n              \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n            anyOf: [\n              {\n                type: \"null\",\n              },\n              {\n                type: \"string\",\n                description: \"@format uri\\n@contentMediaType image/*\",\n              },\n            ],\n          },\n        },\n        required: [\n          \"id\",\n          \"created_at\",\n          \"updated_at\",\n          \"title\",\n          \"body\",\n          \"thumbnail\",\n        ],\n        additionalProperties: false,\n      },\n      description:\n        \"Create a new article.\\n\\nWrites a new article and archives it into the DB.\",\n      strict: true,\n    },\n    {\n      name: \"update\",\n      parameters: {\n        type: \"object\",\n        properties: {\n          id: {\n            title: \"Target article's {@link IBbsArticle.id}\",\n            description:\n              \"Target article's {@link IBbsArticle.id}.\\n\\n\\n@format uuid\",\n            type: \"string\",\n          },\n          input: {\n            description:\n              \"Make all properties in T optional\\n\\n------------------------------\\n\\nDescription of the current {@link PartialIBbsArticle.ICreate} type:\\n\\n> Make all properties in T optional\",\n            type: \"object\",\n            properties: {\n              title: {\n                title: \"Title of the article\",\n                description:\n                  \"Title of the article.\\n\\nRepresentative title of the article.\",\n                type: \"string\",\n              },\n              body: {\n                title: \"Content body\",\n                description:\n                  \"Content body.\\n\\nContent body of the article writtn in the markdown format.\",\n                type: \"string\",\n              },\n              thumbnail: {\n                title: \"Thumbnail image URI\",\n                description:\n                  \"Thumbnail image URI.\\n\\nThumbnail image URI which can represent the article.\\n\\nIf configured as `null`, it means that no thumbnail image in the article.\",\n                anyOf: [\n                  {\n                    type: \"null\",\n                  },\n                  {\n                    type: \"string\",\n                    description: \"@format uri\\n@contentMediaType image/*\",\n                  },\n                ],\n              },\n            },\n            required: [\"title\", \"body\", \"thumbnail\"],\n            additionalProperties: false,\n          },\n        },\n        required: [\"id\", \"input\"],\n        additionalProperties: false,\n        $defs: {},\n      },\n      description: \"Update an article.\\n\\nUpdates an article with new content.\",\n      strict: true,\n    },\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Map Type Validation\nDESCRIPTION: This is the compiled JavaScript code for the Map type validator. It checks if the input is a Map instance and validates the key-value pairs according to the specified types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n(() => {\n  return (input) =>\n    input instanceof Map &&\n    (() =>\n      [...input].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"string\" === typeof elem[0] &&\n          (\"string\" === typeof elem[1] ||\n            \"number\" === typeof elem[1] ||\n            \"boolean\" === typeof elem[1]),\n      ))();\n})();\n```\n\n----------------------------------------\n\nTITLE: Customizable Type Interface\nDESCRIPTION: Interface defining customizable primitive types for random generation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/random.mdx#2025-04-20_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Customizable {\n  number: number;\n  string: string;\n  bigint: bigint;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating TypeScript Code with pnpm\nDESCRIPTION: This snippet shows how to use pnpm to install Typia and generate transformed TypeScript code. It specifies input and output directories and the TypeScript configuration file.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n# GENERATE TRANSFORMED TYPESCRIPT CODES\npnpm typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript Implementation of Snake Case Converter\nDESCRIPTION: Shows the compiled JavaScript output for the snake case converter, which transforms camelCase and PascalCase property names to snake_case while preserving the structure of the input object.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    is_my_name_samchon: input.isMyNameSamchon,\n    hello_the_new_world: input.HelloTheNewWorld,\n    to_html: input.ToHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Typia Playground Component in JSX/TSX\nDESCRIPTION: A simple component import and rendering in JSX/TSX syntax. It imports the Playground component from a relative path and renders it directly without passing any props.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/playground/index.mdx#2025-04-20_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Playground from \"../../src/pages/Playground\";\n\n<Playground />\n```\n\n----------------------------------------\n\nTITLE: Implementing PascalCase Type Transformation\nDESCRIPTION: Defines a complex set of type transformations for converting object keys to pascal case. It handles various data structures including arrays, tuples, sets, maps, and nested objects. The implementation includes special cases for primitive wrappers and built-in objects.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Pascal case type.\n *\n * `PascalCase` type is a type that all keys of an object are pascalized.\n *\n * It also erase every method properties like {@link Resolved} type.\n *\n * @template T Target type to be pascalized\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport type PascalCase<T> = Equal<T, PascalizeMain<T>> extends true\n  ? T\n  : PascalizeMain<T>;\n\n/* -----------------------------------------------------------\n    OBJECT CONVERSION\n----------------------------------------------------------- */\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype PascalizeMain<T> = T extends [never]\n  ? never // special trick for (jsonable | null) type\n  : T extends { valueOf(): boolean | bigint | number | string }\n  ? ValueOf<T>\n  : T extends Function\n  ? never\n  : T extends object\n  ? PascalizeObject<T>\n  : T;\n\ntype PascalizeObject<T extends object> = T extends Array<infer U>\n  ? IsTuple<T> extends true\n    ? PascalizeTuple<T>\n    : PascalizeMain<U>[]\n  : T extends Set<infer U>\n  ? Set<PascalizeMain<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<PascalizeMain<K>, PascalizeMain<V>>\n  : T extends WeakSet<any> | WeakMap<any, any>\n  ? never\n  : T extends\n      | Date\n      | Uint8Array\n      | Uint8ClampedArray\n      | Uint16Array\n      | Uint32Array\n      | BigUint64Array\n      | Int8Array\n      | Int16Array\n      | Int32Array\n      | BigInt64Array\n      | Float32Array\n      | Float64Array\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | DataView\n      | Blob\n      | File\n  ? T\n  : {\n      [Key in keyof T as PascalizeString<Key & string>]: PascalizeMain<T[Key]>;\n    };\n\n/* -----------------------------------------------------------\n    SPECIAL CASES\n----------------------------------------------------------- */\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\n  never,\n]\n  ? false\n  : T extends readonly any[]\n  ? number extends T[\"length\"]\n    ? false\n    : true\n  : false;\ntype PascalizeTuple<T extends readonly any[]> = T extends []\n  ? []\n  : T extends [infer F]\n  ? [PascalizeMain<F>]\n  : T extends [infer F, ...infer Rest extends readonly any[]]\n  ? [PascalizeMain<F>, ...PascalizeTuple<Rest>]\n  : T extends [(infer F)?]\n  ? [PascalizeMain<F>?]\n  : T extends [(infer F)?, ...infer Rest extends readonly any[]]\n  ? [PascalizeMain<F>?, ...PascalizeTuple<Rest>]\n  : [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n  ? boolean\n  : IsValueOf<Instance, Number> extends true\n  ? number\n  : IsValueOf<Instance, String> extends true\n  ? string\n  : Instance;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n  ? Object extends IValueOf<infer Primitive>\n    ? Instance extends Primitive\n      ? false\n      : true // not Primitive, but Object\n    : false // cannot be\n  : false;\n\ninterface IValueOf<T> {\n  valueOf(): T;\n}\n\n/* -----------------------------------------------------------\n    STRING CONVERTER\n----------------------------------------------------------- */\ntype PascalizeString<Key extends string> = Key extends `_${infer R}`\n  ? `_${PascalizeString<R>}`\n  : Key extends `${infer F}${infer R}`\n  ? `${Uppercase<F>}${PascalizeStringRepeatedly<R>}`\n  : Key;\ntype PascalizeStringRepeatedly<Key extends string> =\n  Key extends `${infer F}_${infer R}`\n    ? `${F}${Capitalize<PascalizeStringRepeatedly<R>>}`\n    : Key;\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Map Validation\nDESCRIPTION: Shows the compiled JavaScript code for validating a Map with string keys and boolean, number, or string values.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/validate.mdx#2025-04-20_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n(() => {\n  return (input) =>\n    input instanceof Map &&\n    (() =>\n      [...input].every(\n        (elem) =>\n          Array.isArray(elem) &&\n          elem.length === 2 &&\n          \"string\" === typeof elem[0] &&\n          (\"string\" === typeof elem[1] ||\n            \"number\" === typeof elem[1] ||\n            \"boolean\" === typeof elem[1]),\n      ))();\n})();\n```\n\n----------------------------------------\n\nTITLE: Importing Components in JSX/MDX\nDESCRIPTION: Demonstrates importing React components from nextra and Material-UI libraries for documentation purposes.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Tabs } from 'nextra/components'\nimport Alert from '@mui/material/Alert';\nimport AlertTitle from '@mui/material/AlertTitle';\n```\n\n----------------------------------------\n\nTITLE: Installing Typia and Generating TypeScript Code with Yarn\nDESCRIPTION: This snippet demonstrates how to use Yarn to install Typia and TypeScript, then generate transformed TypeScript code. It includes the same command parameters as the pnpm version.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n# INSTALL TYPIA\nyarn add typia\nyarn add -D typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nyarn typia generate \\\n  --input src/templates \\\n  --output src/generated \\\n  --project tsconfig.json\n```\n\n----------------------------------------\n\nTITLE: Importing React Components for Documentation UI\nDESCRIPTION: Import statements for UI components used in the documentation page, including Tabs from nextra/components and Alert components from Material-UI.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Tabs } from 'nextra/components'\nimport Alert from '@mui/material/Alert';\nimport AlertTitle from '@mui/material/AlertTitle';\n```\n\n----------------------------------------\n\nTITLE: Typia Transformation Example\nDESCRIPTION: Demonstration of how Typia transforms TypeScript type checking code during compilation, showing both the source TypeScript and compiled JavaScript output.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/index.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n//----\n// examples/checkString.ts\n//----\nimport typia, { tags } from \"typia\";\nexport const checkString = typia.createIs<string>();\n\n//----\n// examples/checkUUID.js\n//----\nimport typia from \"typia\";\nexport const checkString = (() => {\n  return (input) => \"string\" === typeof input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Typia Type Tags and Protobuf Functions\nDESCRIPTION: This is the compiled JavaScript output for the TypeScript code using Typia type tags. It includes the implementation of protobuf message schema generation, decode function, and encode function for the TypeTagExample interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__ProtobufReader from \"typia/lib/internal/_ProtobufReader.js\";\nimport * as __typia_transform__throwTypeGuardError from \"typia/lib/internal/_throwTypeGuardError.js\";\nimport * as __typia_transform__isTypeInt32 from \"typia/lib/internal/_isTypeInt32.js\";\nimport * as __typia_transform__isTypeUint32 from \"typia/lib/internal/_isTypeUint32.js\";\nimport * as __typia_transform__isTypeInt64 from \"typia/lib/internal/_isTypeInt64.js\";\nimport * as __typia_transform__isTypeFloat from \"typia/lib/internal/_isTypeFloat.js\";\nimport * as __typia_transform__ProtobufSizer from \"typia/lib/internal/_ProtobufSizer.js\";\nimport * as __typia_transform__ProtobufWriter from \"typia/lib/internal/_ProtobufWriter.js\";\nimport typia from \"typia\";\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n[\n  'syntax = \"proto3\";',\n  \"\",\n  \"message TypeTagExample {\",\n  \"  required int32 int32 = 1;\",\n  \"  required uint32 uint32 = 2;\",\n  \"  required uint64 uint64 = 3;\",\n  \"  required int64 int64 = 4;\",\n  \"  required float float = 5;\",\n  \"  optional double double = 6;\",\n  \"  optional string string = 7;\",\n  \"  oneof uint32_or_double {\",\n  \"    uint32 v8 = 8;\",\n  \"    double v9 = 9;\",\n  \"  }\",\n  \"  oneof int32_or_uint64 {\",\n  \"    int32 v10 = 10;\",\n  \"    uint64 v11 = 11;\",\n  \"  }\",\n  \"  oneof int32_or_float_or_uint64 {\",\n  \"    int32 v12 = 12;\",\n  \"    uint64 v13 = 13;\",\n  \"    float v14 = 14;\",\n  \"  }\",\n  \"  repeated uint64 uint64_array = 15;\",\n  \"  map<int32, string> int32_map = 16;\",\n  \"}\",\n].join(\"\\n\");\n//----\n// DECODE FUNCTION\n//----\n(() => {\n  const _pdo0 = (reader, length = -1) => {\n    length = length < 0 ? reader.size() : reader.index() + length;\n    const output = {\n      int32: undefined,\n      uint32: undefined,\n      uint64: undefined,\n      int64: undefined,\n      float: undefined,\n      double: undefined,\n      string: null,\n      uint32_or_double: undefined,\n      int32_or_uint64: undefined,\n      int32_or_float_or_uint64: undefined,\n      uint64_array: [],\n      int32_map: null,\n    };\n    while (reader.index() < length) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          // int32;\n          output.int32 = reader.int32();\n          break;\n        case 2:\n          // uint32;\n          output.uint32 = reader.uint32();\n          break;\n        case 3:\n          // uint64;\n          output.uint64 = reader.uint64();\n          break;\n        case 4:\n          // int64;\n          output.int64 = Number(reader.int64());\n          break;\n        case 5:\n          // float;\n          output.float = reader.float();\n          break;\n        case 6:\n          // double;\n          output.double = reader.double();\n          break;\n        case 7:\n          // string;\n          output.string = reader.string();\n          break;\n        case 8:\n          // uint32;\n          output.uint32_or_double = reader.uint32();\n          break;\n        case 9:\n          // double;\n          output.uint32_or_double = reader.double();\n          break;\n        case 10:\n          // int32;\n          output.int32_or_uint64 = reader.int32();\n          break;\n        case 11:\n          // uint64;\n          output.int32_or_uint64 = reader.uint64();\n          break;\n        case 12:\n          // int32;\n          output.int32_or_float_or_uint64 = reader.int32();\n          break;\n        case 13:\n          // uint64;\n          output.int32_or_float_or_uint64 = reader.uint64();\n          break;\n        case 14:\n          // float;\n          output.int32_or_float_or_uint64 = reader.float();\n          break;\n        case 15:\n          // Array<(bigint & Type<\"uint64\">)>;\n          if (2 === (tag & 7)) {\n            const piece = reader.uint32() + reader.index();\n            while (reader.index() < piece)\n              output.uint64_array.push(reader.uint64());\n          } else output.uint64_array.push(reader.uint64());\n          break;\n        case 16:\n          // Map<(number & Type<\"int32\">), string>;\n          (() => {\n            const piece = reader.uint32() + reader.index();\n            const entry = {\n              key: undefined,\n              value: \"\",\n            };\n            while (reader.index() < piece) {\n              const kind = reader.uint32();\n              switch (kind >>> 3) {\n                case 1:\n                  // int32;\n                  entry.key = reader.int32();\n                  break;\n                case 2:\n                  // string;\n                  entry.value = reader.string();\n                  break;\n                default:\n                  reader.skipType(kind & 7);\n                  break;\n              }\n            }\n            output.int32_map ??= new Map();\n            output.int32_map.set(entry.key, entry.value);\n          })();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return output;\n  };\n  return (input) => {\n    const reader = new __typia_transform__ProtobufReader._ProtobufReader(input);\n    return _pdo0(reader);\n  };\n})();\n//----\n// ENCODE FUNCTION\n//----\n(() => {\n  const encoder = (writer, input) => {\n    const _peo0 = (input) => {\n      // property \"int32\": (number & Type<\"int32\">);\n      writer.uint32(8);\n      writer.int32(input.int32);\n      // property \"uint32\": (number & Type<\"uint32\">);\n      writer.uint32(16);\n      writer.uint32(input.uint32);\n      // property \"uint64\": (bigint & Type<\"uint64\">);\n      writer.uint32(24);\n      writer.uint64(input.uint64);\n      // property \"int64\": (number & Type<\"int64\">);\n      writer.uint32(32);\n      writer.int64(input.int64);\n      // property \"float\": (number & Type<\"float\">);\n      writer.uint32(45);\n      writer.float(input.float);\n      // property \"double\": (number | undefined);\n      if (undefined !== input.double) {\n        writer.uint32(49);\n        writer.double(input.double);\n      }\n      // property \"string\": (null | string);\n      if (null !== input.string) {\n        writer.uint32(58);\n        writer.string(input.string);\n      }\n      // property \"uint32_or_double\": (number & (Type<\"uint32\"> | Type<\"double\">));\n      if (\n        \"number\" === typeof input.uint32_or_double &&\n        Math.floor(input.uint32_or_double) === input.uint32_or_double &&\n        0 <= input.uint32_or_double &&\n        input.uint32_or_double <= 4294967295\n      ) {\n        writer.uint32(64);\n        writer.uint32(input.uint32_or_double);\n      } else if (\"number\" === typeof input.uint32_or_double && true) {\n        writer.uint32(73);\n        writer.double(input.uint32_or_double);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected: '(number & (Type<\"uint32\"> | Type<\"double\">))',\n          value: input.uint32_or_double,\n        });\n      // property \"int32_or_uint64\": ((bigint & Type<\"uint64\">) | (number & Type<\"int32\">));\n      if (\"number\" === typeof input.int32_or_uint64) {\n        writer.uint32(80);\n        writer.int32(input.int32_or_uint64);\n      } else if (\"bigint\" === typeof input.int32_or_uint64) {\n        writer.uint32(88);\n        writer.uint64(input.int32_or_uint64);\n      } else\n        __typia_transform__throwTypeGuardError._throwTypeGuardError({\n          method: \"typia.protobuf.createEncode\",\n          expected: '((bigint & Type<\"uint64\">) | (number & Type<\"int32\">))',\n          value: input.int32_or_uint64,\n        });\n      // property \"int32_or_float_or_uint64\": ((bigint & Type<\"uint64\">) | (number & (Type<\"int32\"> | Type<\"float\">)));\n      if (\n        \"number\" === typeof input.int32_or_float_or_uint64 &&\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for HTTP Headers Processing\nDESCRIPTION: This snippet shows the compiled JavaScript code for processing HTTP headers based on the TypeScript interface. It includes type conversion and array handling for various header types.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_46\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__httpHeaderReadNumber from \"typia/lib/internal/_httpHeaderReadNumber.js\";\nimport * as __typia_transform__httpHeaderReadBoolean from \"typia/lib/internal/_httpHeaderReadBoolean.js\";\nimport typia from \"typia\";\n(() => {\n  return (input) => {\n    const output = {\n      \"x-Category\": input[\"x-category\"],\n      \"x-MEMO\": input[\"x-memo\"],\n      \"x-nAmE\": input[\"x-name\"],\n      \"x-Values\": Array.isArray(input[\"x-values\"])\n        ? input[\"x-values\"].map(\n            __typia_transform__httpHeaderReadNumber._httpHeaderReadNumber,\n          )\n        : (input[\"x-values\"]\n            ?.split(\", \")\n            ?.map(\n              __typia_transform__httpHeaderReadNumber._httpHeaderReadNumber,\n            ) ?? []),\n      \"x-FlAgS\": Array.isArray(input[\"x-flags\"])\n        ? input[\"x-flags\"].map(\n            __typia_transform__httpHeaderReadBoolean._httpHeaderReadBoolean,\n          )\n        : (input[\"x-flags\"]\n            ?.split(\", \")\n            ?.map(\n              __typia_transform__httpHeaderReadBoolean._httpHeaderReadBoolean,\n            ) ?? []),\n      \"X-Descriptions\": Array.isArray(input[\"x-descriptions\"])\n        ? input[\"x-descriptions\"].map((str) => str.trim())\n        : (input[\"x-descriptions\"]?.split(\", \")?.map((str) => str.trim()) ??\n          []),\n    };\n    return output;\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Configuring Typia Plugin for Function Validation in TypeScript\nDESCRIPTION: This snippet shows how to configure the typia plugin in tsconfig.json to enable validation of function types. It sets the 'functional' option to true in the plugin configuration.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/validators/is.mdx#2025-04-20_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\",\n        \"functional\": true\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Performance Benchmark Tables - Various Operations\nDESCRIPTION: Multiple markdown tables showing performance comparisons (in MB/sec) between different libraries for operations like validation, assertion, stringification across different data structure types.\nSOURCE: https://github.com/samchon/typia/blob/master/benchmark/src/results/AMD EPYC 7763 64-Core Processor/README.md#2025-04-20_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Types | typia | typebox | ajv | io-ts | zod | class-validator \n-------|------|------|------|------|------|------\n object (simple) | 100,471 | 99,740 | 4,248 | 453 | 62 | 6.54 \n object (hierarchical) | 21,409 | 21,533 | 5,445 | 725 | 44 | 12 \n object (recursive) | 11,339 | 11,504 | 2,869 | 690 | 8.77 | 11 \n object (union, explicit) | 2,574 | 1,514 | 139 | 371 | 4.59 |  -  \n object (union, implicit) | 2,119 |  -  |  -  |  -  |  -  |  -  \n array (recursive) | 6,318 | 7,799 | 2,608 | 692 | 11 | 9.46 \n array (union, explicit) | 2,292 | 1,347 | 225 | 258 | 2.39 |  -  \n array (union, implicit) | 2,043 |  -  |  -  |  -  |  -  |  -  \n ultimate union | 675 |  -  |  -  |  -  |  -  |  -  \n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for assertPrune Example\nDESCRIPTION: This snippet shows the compiled JavaScript version of the assertPrune example. It includes complex type checking and validation logic generated from the TypeScript code.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__randomFormatUuid from \"typia/lib/internal/_randomFormatUuid.js\";\nimport * as __typia_transform__randomString from \"typia/lib/internal/_randomString.js\";\nimport * as __typia_transform__randomInteger from \"typia/lib/internal/_randomInteger.js\";\nimport * as __typia_transform__randomArray from \"typia/lib/internal/_randomArray.js\";\nimport * as __typia_transform__randomNumber from \"typia/lib/internal/_randomNumber.js\";\nimport * as __typia_transform__randomFormatDate from \"typia/lib/internal/_randomFormatDate.js\";\nimport * as __typia_transform__assertGuard from \"typia/lib/internal/_assertGuard.js\";\nimport typia from \"typia\";\nconst department = (() => {\n  const _ro0 = (_recursive = false, _depth = 0) => ({\n    id: (\n      _generator?.uuid ?? __typia_transform__randomFormatUuid._randomFormatUuid\n    )(),\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n        minLength: 3,\n      },\n    ),\n    limit: (\n      _generator?.integer ?? __typia_transform__randomInteger._randomInteger\n    )({\n      type: \"integer\",\n    }),\n    clerks: (_generator?.array ?? __typia_transform__randomArray._randomArray)({\n      type: \"array\",\n      element: () => _ro1(_recursive, _recursive ? 1 + _depth : _depth),\n    }),\n  });\n  const _ro1 = (_recursive = false, _depth = 0) => ({\n    name: (_generator?.string ?? __typia_transform__randomString._randomString)(\n      {\n        type: \"string\",\n      },\n    ),\n    age: (_generator?.number ?? __typia_transform__randomNumber._randomNumber)({\n      type: \"number\",\n      exclusiveMinimum: true,\n      minimum: 19,\n      maximum: 100,\n    }),\n    authority: (\n      _generator?.number ?? __typia_transform__randomNumber._randomNumber\n    )({\n      type: \"number\",\n    }),\n    joined_at: (\n      _generator?.date ?? __typia_transform__randomFormatDate._randomFormatDate\n    )(),\n  });\n  let _generator;\n  return (generator) => {\n    _generator = generator;\n    return _ro0();\n  };\n})()();\nconst pruned = (() => {\n  const _pp0 = (input) =>\n    input.forEach((elem) => {\n      if (\"object\" === typeof elem && null !== elem) _po1(elem);\n    });\n  const _io0 = (input) =>\n    \"string\" === typeof input.id &&\n    /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n      input.id,\n    ) &&\n    \"string\" === typeof input.name &&\n    3 <= input.name.length &&\n    \"number\" === typeof input.limit &&\n    Math.floor(input.limit) === input.limit &&\n    -2147483648 <= input.limit &&\n    input.limit <= 2147483647 &&\n    Array.isArray(input.clerks) &&\n    input.clerks.every(\n      (elem) => \"object\" === typeof elem && null !== elem && _io1(elem),\n    );\n  const _io1 = (input) =>\n    \"string\" === typeof input.name &&\n    \"number\" === typeof input.age &&\n    19 < input.age &&\n    input.age <= 100 &&\n    \"number\" === typeof input.authority &&\n    \"string\" === typeof input.joined_at &&\n    /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/.test(input.joined_at);\n  const _ao0 = (input, _path, _exceptionable = true) =>\n    ((\"string\" === typeof input.id &&\n      (/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n        input.id,\n      ) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".id\",\n            expected: 'string & Format<\"uuid\">',\n            value: input.id,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".id\",\n          expected: '(string & Format<\"uuid\">)',\n          value: input.id,\n        },\n        _errorFactory,\n      )) &&\n    ((\"string\" === typeof input.name &&\n      (3 <= input.name.length ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".name\",\n            expected: \"string & MinLength<3>\",\n            value: input.name,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".name\",\n          expected: \"(string & MinLength<3>)\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.limit &&\n      ((Math.floor(input.limit) === input.limit &&\n        -2147483648 <= input.limit &&\n        input.limit <= 2147483647) ||\n        __typia_transform__assertGuard._assertGuard(\n          _exceptionable,\n          {\n            method: \"typia.misc.assertPrune\",\n            path: _path + \".limit\",\n            expected: 'number & Type<\"int32\">',\n            value: input.limit,\n          },\n          _errorFactory,\n        ))) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".limit\",\n          expected: '(number & Type<\"int32\">)',\n          value: input.limit,\n        },\n        _errorFactory,\n      )) &&\n    (((Array.isArray(input.clerks) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      )) &&\n      input.clerks.every(\n        (elem, _index2) =>\n          (((\"object\" === typeof elem && null !== elem) ||\n            __typia_transform__assertGuard._assertGuard(\n              _exceptionable,\n              {\n                method: \"typia.misc.assertPrune\",\n                path: _path + \".clerks[\" + _index2 + \"]\",\n                expected: \"IClerk\",\n                value: elem,\n              },\n              _errorFactory,\n            )) &&\n            _ao1(\n              elem,\n              _path + \".clerks[\" + _index2 + \"]\",\n              true && _exceptionable,\n            )) ||\n          __typia_transform__assertGuard._assertGuard(\n            _exceptionable,\n            {\n              method: \"typia.misc.assertPrune\",\n              path: _path + \".clerks[\" + _index2 + \"]\",\n              expected: \"IClerk\",\n              value: elem,\n            },\n            _errorFactory,\n          ),\n      )) ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".clerks\",\n          expected: \"Array<IClerk>\",\n          value: input.clerks,\n        },\n        _errorFactory,\n      ));\n  const _ao1 = (input, _path, _exceptionable = true) =>\n    (\"string\" === typeof input.name ||\n      __typia_transform__assertGuard._assertGuard(\n        _exceptionable,\n        {\n          method: \"typia.misc.assertPrune\",\n          path: _path + \".name\",\n          expected: \"string\",\n          value: input.name,\n        },\n        _errorFactory,\n      )) &&\n    ((\"number\" === typeof input.age &&\n      (19 < input.age ||\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Results Table - Type Validation Performance\nDESCRIPTION: Performance benchmark tables comparing validation speeds across different libraries and data structures. Measurements are in Megabytes per second showing throughput for various operations like type checking, assertion, validation, error handling, optimization, and serialization.\nSOURCE: https://github.com/samchon/typia/blob/master/benchmark/src/results/11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz/README.md#2025-04-20_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Types | typia | typebox | ajv | io-ts | zod | class-validator \n-------|------|------|------|------|------|------\n object (simple) | 103,389 | 103,319 | 3,271 | 335 | 41 | 3.56 \n object (hierarchical) | 15,924 | 18,460 | 3,616 | 528 | 27 | 6.66 \n object (recursive) | 9,513 | 10,611 | 1,660 | 481 | 5.05 | 6.50 \n object (union, explicit) | 1,499 | 1,215 | 84 | 283 | 2.74 |  -  \n object (union, implicit) | 1,147 |  -  |  -  |  -  |  -  |  -  \n array (recursive) | 6,503 | 7,392 | 1,772 | 510 | 6.03 | 5.51 \n array (union, explicit) | 1,615 | 1,099 | 162 | 182 | 1.32 |  -  \n array (union, implicit) | 1,855 |  -  |  -  |  -  |  -  |  -  \n ultimate union | 342 |  -  |  -  |  -  |  -  |  -  \n```\n\n----------------------------------------\n\nTITLE: Validation Result Handler\nDESCRIPTION: Generic validation result handler that processes validation outcomes and returns a structured response with success status and error details if any.\nSOURCE: https://github.com/samchon/typia/blob/master/website/src/snippets/LlmApplicationJavaScriptSnippet.mdx#2025-04-20_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nreturn (input) => {\n  if (false === __is(input)) {\n    errors = [];\n    _report = __typia_transform__validateReport._validateReport(errors);\n    const success = 0 === errors.length;\n    return success\n      ? {\n          success,\n          data: input,\n        }\n      : {\n          success,\n          errors,\n          data: input,\n        };\n  }\n  return {\n    success: true,\n    data: input,\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Running prepare script with yarn\nDESCRIPTION: Command to run the prepare script to install ts-patch using yarn. Note that Yarn Berry is not supported.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/setup.mdx#2025-04-20_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# YARN BERRY IS NOT SUPPORTED\nyarn prepare\n```\n\n----------------------------------------\n\nTITLE: Compiled Query Parser in JavaScript\nDESCRIPTION: Shows the compiled JavaScript output of the TypeScript query parser example. Demonstrates how typia transforms the type definitions into runtime code that handles type conversion for each field based on its defined type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_40\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as __typia_transform__httpQueryParseURLSearchParams from \"typia/lib/internal/_httpQueryParseURLSearchParams.js\";\nimport * as __typia_transform__httpQueryReadNumber from \"typia/lib/internal/_httpQueryReadNumber.js\";\nimport * as __typia_transform__httpQueryReadBoolean from \"typia/lib/internal/_httpQueryReadBoolean.js\";\nimport * as __typia_transform__httpQueryReadString from \"typia/lib/internal/_httpQueryReadString.js\";\nimport * as __typia_transform__httpQueryReadArray from \"typia/lib/internal/_httpQueryReadArray.js\";\nimport typia from \"typia\";\n(() => {\n  return (input) => {\n    input =\n      __typia_transform__httpQueryParseURLSearchParams._httpQueryParseURLSearchParams(\n        input,\n      );\n    const output = {\n      limit:\n        __typia_transform__httpQueryReadNumber._httpQueryReadNumber(\n          input.get(\"limit\"),\n        ) ?? undefined,\n      enforce: __typia_transform__httpQueryReadBoolean._httpQueryReadBoolean(\n        input.get(\"enforce\"),\n      ),\n      values: __typia_transform__httpQueryReadArray._httpQueryReadArray(\n        input\n          .getAll(\"values\")\n          .map((elem) =>\n            __typia_transform__httpQueryReadString._httpQueryReadString(elem),\n          ),\n        undefined,\n      ),\n      atomic: __typia_transform__httpQueryReadString._httpQueryReadString(\n        input.get(\"atomic\"),\n      ),\n      indexes: input\n        .getAll(\"indexes\")\n        .map((elem) =>\n          __typia_transform__httpQueryReadNumber._httpQueryReadNumber(elem),\n        ),\n    };\n    return output;\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Invalid LLM Application Type Definition in TypeScript\nDESCRIPTION: Example demonstrating invalid type definitions in LLM application that violate Typia's restrictions. Shows errors when return type is union with undefined and when parameter is not an object type.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/application.mdx#2025-04-20_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ILlmApplication } from \"@samchon/openapi\";\nimport typia, { tags } from \"typia\";\n\nconst app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n  BbsArticleController,\n  \"chatgpt\"\n>();\n\nconsole.log(app);\n\ninterface BbsArticleController {\n  /**\n   * Create a new article.\n   *\n   * Writes a new article and archives it into the DB.\n   *\n   * @param props Properties of create function\n   * @returns Newly created article\n   */\n  create(props: {\n    /**\n     * Information of the article to create\n     */\n    input: IBbsArticle.ICreate;\n  }): Promise<IBbsArticle | undefined>;\n\n  erase(id: string & tags.Format<\"uuid\">): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Terminal Output for Article Creation Function\nDESCRIPTION: Shows the console output displaying the description of the article creation function from the LLM application.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/strategy.mdx#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCreate a new article.\n\nWrites a new article and archives it into the DB.\n```\n\n----------------------------------------\n\nTITLE: Compiled JavaScript for Pascal Case Conversion\nDESCRIPTION: Shows the compiled JavaScript output for the pascal case conversion example. It demonstrates how the TypeScript code is transformed into a runtime function that performs the property name conversions.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nimport typia from \"typia\";\n(() => {\n  const $co0 = (input) => ({\n    IsMyNameSamchon: input.is_my_name_samchon,\n    HelloTheNewWorld: input.helloTheNewWorld,\n    ToHTML: input.toHTML,\n  });\n  return (input) =>\n    \"object\" === typeof input && null !== input ? $co0(input) : input;\n})();\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Usage Example\nDESCRIPTION: Demonstrates practical usage of Protocol Buffer encoding and decoding with type definitions including tags and format validation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia, { tags } from \"typia\";\n \nconst member: IMember = typia.random<IMember>();\nconst encoded: Uint8Array = typia.protobuf.encode<IMember>(member);\nconst decoded: IMember = typia.protobuf.decode<IMember>(encoded);\nconsole.log(member, decoded);\n\ninterface IMember {\n  id:\n    | (string & tags.Sequence<11>)\n    | (number & tags.Type<\"uint64\"> & tags.Sequence<12>)\n    | (Uint8Array & tags.Sequence<13>);\n  name: (string & tags.Sequence<20>) | null;\n  children: Array<IMember> & tags.Sequence<30>;\n  keywords: Map<string, string> & tags.Sequence<40>;\n  thumbnail:\n    | (string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">)\n    | Uint8Array;\n  email: string & tags.Format<\"email\">;\n  hobbies: Array<IHobby>;\n}\n```\n\n----------------------------------------\n\nTITLE: Validation Interface Definitions\nDESCRIPTION: Interface definitions for validation results including success and failure cases with error details\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/encode.mdx#2025-04-20_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport type IValidation<T> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport namespace IValidation {\n  export interface ISuccess<T> {\n    success: true;\n    data: T;\n  }\n  export interface IFailure {\n    success: false;\n    errors: IError[];\n    data: unknown;\n  }\n  export interface IError {\n    path: string;\n    expected: string;\n    value: any;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Nextra Tab Components in JSX\nDESCRIPTION: Import statement for the Tabs component from the Nextra components library, which is used for creating tabbed interfaces in documentation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Tabs } from 'nextra/components'\n```\n\n----------------------------------------\n\nTITLE: Executing Test Commands for Typia Project in Bash\nDESCRIPTION: A series of bash commands to compile, prepare, and run tests for the Typia project. These steps are crucial before sending a pull request to ensure code quality and functionality.\nSOURCE: https://github.com/samchon/typia/blob/master/CONTRIBUTING.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# COMPILE\nnpm run build\n\n# PREPARE\nnpm run test:generate\n\n# DO TEST\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Importing Material-UI Alert Components in JSX\nDESCRIPTION: Import statements for Alert and AlertTitle components from Material-UI, which are used to display alert messages with titles in the documentation interface.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/decode.mdx#2025-04-20_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport Alert from '@mui/material/Alert';\nimport AlertTitle from '@mui/material/AlertTitle';\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsupported Top-Level Types in TypeScript to Protocol Buffer Conversion\nDESCRIPTION: This code snippet shows examples of unsupported top-level types when using typia.protobuf functions. It demonstrates that the top-level type must be a sole and static object, and that primitive types, arrays, dynamic objects, and union types are not allowed.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/protobuf/message.mdx#2025-04-20_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport typia from \"typia\";\n\ninterface Cat {\n    type: \"cat\";\n    name: string;\n    ribbon: boolean;\n}\ninterface Dog {\n    type: \"dog\";\n    name: string;\n    hunt: boolean;\n}\n\ntypia.protobuf.message<bigint>();\ntypia.protobuf.createDecode<Record<string, number>>();\ntypia.protobuf.createDecode<Map<number & typia.tags.Type<\"float\">, Dog>>();\ntypia.protobuf.createEncode<boolean[]>();\ntypia.protobuf.createEncode<Cat | Dog>();\n```\n\nLANGUAGE: bash\nCODE:\n```\nmain.ts:14:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- bigint\n  - target type must be a sole and static object type\n\nmain.ts:15:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- Record<string, number>\n  - target type must be a sole and static object type\n\nmain.ts:16:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- Map<(number & Type<\"float\">), Dog>\n  - target type must be a sole and static object type\n\n- (number & Type<\"float\">)\n  - target type must be a sole and static object type\n\nmain.ts:17:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- Array<boolean>\n  - target type must be a sole and static object type\n\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- (Cat | Dog)\n  - target type must be a sole and static object type\n```\n\n----------------------------------------\n\nTITLE: LLM Application Error Output\nDESCRIPTION: Terminal output showing compilation errors for invalid type definitions in the LLM application code\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/llm/application.mdx#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrc/examples/llm.application.violation.ts:4:41 - error TS(typia.llm.application): unsupported type detected    \n\n- BbsArticleController.create: unknown\n  - LLM application's function (\"create\")'s return type must not be union type with undefined.    \n\n- BbsArticleController.erase: unknown\n  - LLM application's function (\"erase\")'s parameter must be an object type.\n\n4 const app: ILlmApplication<\"chatgpt\"> = typia.llm.application<\n                                          ~~~~~~~~~~~~~~~~~~~~~~\n5   BbsArticleController,\n  ~~~~~~~~~~~~~~~~~~~~~~~\n6   \"chatgpt\"\n  ~~~~~~~~~~~\n7 >();\n  ~~~\n\n\nFound 1 error in src/examples/llm.application.violation.ts:4\n```\n\n----------------------------------------\n\nTITLE: Markdown Section Header\nDESCRIPTION: Defines section header for the misc module documentation.\nSOURCE: https://github.com/samchon/typia/blob/master/website/pages/docs/misc.mdx#2025-04-20_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## `misc` module\n```"
  }
]