[
  {
    "owner": "moka-rs",
    "repo": "moka",
    "content": "TITLE: Asynchronous Cache Example with Tokio - Rust\nDESCRIPTION: This code demonstrates how to use the asynchronous cache from the `moka::future` module with the Tokio runtime. It creates a cache, spawns multiple async tasks to insert, retrieve, and invalidate entries, and then verifies the results. Note that the `future` feature needs to be enabled. It utilizes `Cache::new` to initialize the cache and `insert`, `get`, `invalidate` methods, all of which are async and need to be awaited.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Use the asynchronous cache.\nuse moka::future::Cache;\n\n#[tokio::main]\nasync fn main() {\n    const NUM_TASKS: usize = 16;\n    const NUM_KEYS_PER_TASK: usize = 64;\n\n    fn value(n: usize) -> String {\n        format!(\"value {n}\")\n    }\n\n    // Create a cache that can store up to 10,000 entries.\n    let cache = Cache::new(10_000);\n\n    // Spawn async tasks and write to and read from the cache.\n    let tasks: Vec<_> = (0..NUM_TASKS)\n        .map(|i| {\n            // To share the same cache across the async tasks, clone it.\n            // This is a cheap operation.\n            let my_cache = cache.clone();\n            let start = i * NUM_KEYS_PER_TASK;\n            let end = (i + 1) * NUM_KEYS_PER_TASK;\n\n            tokio::spawn(async move {\n                // Insert 64 entries. (NUM_KEYS_PER_TASK = 64)\n                for key in start..end {\n                    // insert() is an async method, so await it.\n                    my_cache.insert(key, value(key)).await;\n                    // get() returns Option<String>, a clone of the stored value.\n                    assert_eq!(my_cache.get(&key).await, Some(value(key)));\n                }\n\n                // Invalidate every 4 element of the inserted entries.\n                for key in (start..end).step_by(4) {\n                    // invalidate() is an async method, so await it.\n                    my_cache.invalidate(&key).await;\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all tasks to complete.\n    futures_util::future::join_all(tasks).await;\n\n    // Verify the result.\n    for key in 0..(NUM_TASKS * NUM_KEYS_PER_TASK) {\n        if key % 4 == 0 {\n            assert_eq!(cache.get(&key).await, None);\n        } else {\n            assert_eq!(cache.get(&key).await, Some(value(key)));\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Synchronous Cache Example with Multi-threading - Rust\nDESCRIPTION: This code demonstrates how to use the synchronous cache from the `moka::sync` module in a multi-threaded environment. It creates a cache, spawns multiple threads to insert, retrieve, and invalidate entries, and then verifies the results. It utilizes `Cache::new` to initialize the cache and `insert`, `get`, `invalidate` methods for operations.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Use the synchronous cache.\nuse moka::sync::Cache;\n\nuse std::thread;\n\nfn value(n: usize) -> String {\n    format!(\"value {n}\")\n}\n\nfn main() {\n    const NUM_THREADS: usize = 16;\n    const NUM_KEYS_PER_THREAD: usize = 64;\n\n    // Create a cache that can store up to 10,000 entries.\n    let cache = Cache::new(10_000);\n\n    // Spawn threads and read and update the cache simultaneously.\n    let threads: Vec<_> = (0..NUM_THREADS)\n        .map(|i| {\n            // To share the same cache across the threads, clone it.\n            // This is a cheap operation.\n            let my_cache = cache.clone();\n            let start = i * NUM_KEYS_PER_THREAD;\n            let end = (i + 1) * NUM_KEYS_PER_THREAD;\n\n            thread::spawn(move || {\n                // Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)\n                for key in start..end {\n                    my_cache.insert(key, value(key));\n                    // get() returns Option<String>, a clone of the stored value.\n                    assert_eq!(my_cache.get(&key), Some(value(key)));\n                }\n\n                // Invalidate every 4 element of the inserted entries.\n                for key in (start..end).step_by(4) {\n                    my_cache.invalidate(&key);\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete.\n    threads.into_iter().for_each(|t| t.join().expect(\"Failed\"));\n\n    // Verify the result.\n    for key in 0..(NUM_THREADS * NUM_KEYS_PER_THREAD) {\n        if key % 4 == 0 {\n            assert_eq!(cache.get(&key), None);\n        } else {\n            assert_eq!(cache.get(&key), Some(value(key)));\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Avoiding Value Cloning with Arc - Rust\nDESCRIPTION: This example demonstrates how to avoid expensive value cloning when using `get` on the concurrent caches (`sync` and `future`). It utilizes `std::sync::Arc` to wrap the value before storing it in the cache, making the clone operation cheap.  Dependencies: `std::sync::Arc`\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Arc;\n\nlet key = ...\nlet large_value = vec![0u8; 2 * 1024 * 1024]; // 2 MiB\n\n// When insert, wrap the large_value by Arc.\ncache.insert(key.clone(), Arc::new(large_value));\n\n// get() will call Arc::clone() on the stored value, which is cheap.\ncache.get(&key);\n\n```\n\n----------------------------------------\n\nTITLE: Size Aware Eviction - Rust\nDESCRIPTION: This code demonstrates how to use size-aware eviction with Moka's synchronous cache.  It defines a `weigher` closure to calculate the size of each entry based on the value's length and sets a `max_capacity` for the cache. It uses `Cache::builder()` to configure the cache and `build()` to finalize the creation.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse moka::sync::Cache;\n\nfn main() {\n    let cache = Cache::builder()\n        // A weigher closure takes &K and &V and returns a u32 representing the\n        // relative size of the entry. Here, we use the byte length of the value\n        // String as the size.\n        .weigher(|_key, value: &String| -> u32 {\n            value.len().try_into().unwrap_or(u32::MAX)\n        })\n        // This cache will hold up to 32MiB of values.\n        .max_capacity(32 * 1024 * 1024)\n        .build();\n    cache.insert(0, \"zero\".to_string());\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using async_eviction_listener Method\nDESCRIPTION: This example demonstrates how to use the `async_eviction_listener` method to define an asynchronous eviction listener for a `future::Cache`. The listener removes a data file associated with the evicted entry. It requires the use of `FutureExt::boxed` to convert the async closure into a `ListenerFuture`.\nSOURCE: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse moka::notification::ListenerFuture;\n// FutureExt trait provides the boxed method.\nuse moka::future::FutureExt;\n\nlet eviction_listener = move |k, v: PathBuf, cause| -> ListenerFuture {\n    println!(\"\\n== An entry has been evicted. k: {k:?}, v: {v:?}, cause: {cause:?}\");\n    let file_mgr2 = Arc::clone(&file_mgr1);\n\n    // Create a Future that removes the data file at the path `v`.\n    async move {\n        // Acquire the write lock of the DataFileManager.\n        let mut mgr = file_mgr2.write().await;\n        // Remove the data file. We must handle error cases here to\n        // prevent the listener from panicking.\n        if let Err(_e) = mgr.remove_data_file(v.as_path()).await {\n            eprintln!(\"Failed to remove a data file at {v:?}\");\n        }\n    }\n    // Convert the regular Future into ListenerFuture. This method is\n    // provided by moka::future::FutureExt trait.\n    .boxed()\n};\n\n// Create the cache. Set time to live for two seconds and set the\n// eviction listener.\nlet cache = Cache::builder()\n    .max_capacity(100)\n    .time_to_live(Duration::from_secs(2))\n    .async_eviction_listener(eviction_listener)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Replacing Blocking API with Tokio Runtime\nDESCRIPTION: This code demonstrates how to replace the removed `blocking` method of `future::Cache` using the Tokio runtime's `block_on` method. It shows how to obtain a handle to the current Tokio runtime in an async context and use it to call the cache's async function from outside the async context within a spawned thread.\nSOURCE: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() {\n    // Create a future cache.\n    let cache = Arc::new(moka::future::Cache::new(100));\n\n    // In async context, you can obtain a handle to the current Tokio runtime.\n    let rt = tokio::runtime::Handle::current();\n\n    // Spawn an OS thread. Pass the handle and cache.\n    let thread = {\n        let cache = Arc::clone(&cache);\n\n        std::thread::spawn(move || {\n            // Call async function using block_on method of Tokio runtime.\n            rt.block_on(cache.insert(0, 'a'));\n        })\n    };\n\n    // Wait for the threads to complete.\n    thread.join().unwrap();\n\n    // Check the result.\n    assert_eq!(cache.get(&0).await, Some('a'));\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Blocking API with async-std Runtime\nDESCRIPTION: This code shows how to replace the removed `blocking` method of `future::Cache` using the `async_std::task::block_on` method. It demonstrates how to call the cache's async function from outside the async context within a spawned thread.\nSOURCE: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Arc;\n\n#[async_std::main]\nasync fn main() {\n    // Create a future cache.\n    let cache = Arc::new(moka::future::Cache::new(100));\n\n    // Spawn an OS thread. Pass the cache.\n    let thread = {\n        let cache = Arc::clone(&cache);\n\n        std::thread::spawn(move || {\n            use async_std::task::block_on;\n\n            // Call async function using block_on method of async_std.\n            block_on(cache.insert(0, 'a'));\n        })\n    };\n\n    // Wait for the threads to complete.\n    thread.join().unwrap();\n\n    // Check the result.\n    assert_eq!(cache.get(&0).await, Some('a'));\n}\n```\n\n----------------------------------------\n\nTITLE: Using eviction_listener Method\nDESCRIPTION: This example demonstrates how to use the `eviction_listener` method to define a synchronous eviction listener for a `future::Cache`. The listener prints a message to the console when a key is evicted, showing the key and the cause of eviction.\nSOURCE: https://github.com/moka-rs/moka/blob/main/MIGRATION-GUIDE.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet eviction_listener = |key, _value, cause| {\n    println!(\"Evicted key {key}. Cause: {cause:?}\");\n};\n\nlet cache = Cache::builder()\n    .max_capacity(100)\n    .expire_after(expiry)\n    .eviction_listener(eviction_listener)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Adding Moka dependency for synchronous cache - Rust\nDESCRIPTION: This command adds the Moka crate with the 'sync' feature enabled to your project's dependencies.  The 'sync' feature enables the synchronous cache implementation, suitable for use in non-async contexts.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n# To use the synchronous cache:\ncargo add moka --features sync\n```\n\n----------------------------------------\n\nTITLE: Adding Moka dependency for asynchronous cache - Rust\nDESCRIPTION: This command adds the Moka crate with the 'future' feature enabled to your project's dependencies.  The 'future' feature enables the asynchronous cache implementation, designed for use with async runtimes such as Tokio or async-std.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n# To use the asynchronous cache:\ncargo add moka --features future\n```\n\n----------------------------------------\n\nTITLE: Running Moka Examples\nDESCRIPTION: This snippet shows how to run a Moka cache example using Cargo. The command includes specifying the example name and enabling the 'sync' and 'future' features.\nSOURCE: https://github.com/moka-rs/moka/blob/main/examples/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run --example <example_name> -F sync,future\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with Features\nDESCRIPTION: This command executes all tests for the Moka project, including those that require the 'future' feature and documentation tests found within the README file. It uses the 'trybuild' configuration flag.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ RUSTFLAGS='--cfg trybuild' cargo test --all-features\n```\n\n----------------------------------------\n\nTITLE: Running Tests without Default Features\nDESCRIPTION: This command runs all tests for the Moka project, but it excludes the default features and enables the 'future' and 'sync' features explicitly.  This allows testing specific configurations of the crate.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ RUSTFLAGS='--cfg trybuild' cargo test \\\n    --no-default-features --features 'future, sync'\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation\nDESCRIPTION: This command generates the documentation for the Moka project using the nightly Rust toolchain. It disables dependencies and enables the 'future' and 'sync' features. It also configures rustdoc with the 'docsrs' feature.\nSOURCE: https://github.com/moka-rs/moka/blob/main/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo +nightly -Z unstable-options --config 'build.rustdocflags=\"--cfg docsrs\"' \\\n    doc --no-deps --features 'future, sync'\n```"
  }
]