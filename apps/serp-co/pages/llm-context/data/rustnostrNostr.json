[
  {
    "owner": "rust-nostr",
    "repo": "nostr",
    "content": "TITLE: Initializing and Using the Nostr SDK Client in Rust\nDESCRIPTION: This Rust example demonstrates initializing the `nostr-sdk` client using `tokio` for async operations. It shows how to generate new keys or parse existing ones, configure client options including setting up a proxy for Tor relays, add multiple relays (including read-only), connect to them, define and set user metadata, and publish events like a standard text note and a Proof-of-Work (POW) text note. It uses the `nostr_sdk::prelude` for convenience.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr-sdk/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n\nuse nostr_sdk::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Generate new random keys\n    let keys = Keys::generate();\n\n    // Or use your already existing (from hex or bech32)\n    let keys = Keys::parse(\"hex-or-bech32-secret-key\")?;\n\n    // Show bech32 public key\n    let bech32_pubkey: String = keys.public_key().to_bech32()?;\n    println!(\"Bech32 PubKey: {}\", bech32_pubkey);\n\n    // Configure client to use proxy for `.onion` relays\n    let addr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST, 9050));\n    let connection: Connection = Connection::new()\n        .proxy(addr) // Use `.embedded_tor()` instead to enable the embedded tor client (require `tor` feature)\n        .target(ConnectionTarget::Onion);\n    let opts = Options::new().connection(connection);\n\n    // Create new client with custom options\n    let client = Client::builder().signer(keys.clone()).opts(opts).build();\n\n    // Add relays\n    client.add_relay(\"wss://relay.damus.io\").await?;\n    client.add_relay(\"ws://jgqaglhautb4k6e6i2g34jakxiemqp6z4wynlirltuukgkft2xuglmqd.onion\").await?;\n    \n    // Add read relay\n    client.add_read_relay(\"wss://relay.nostr.info\").await?;\n\n    // Connect to relays\n    client.connect().await;\n\n    let metadata = Metadata::new()\n        .name(\"username\")\n        .display_name(\"My Username\")\n        .about(\"Description\")\n        .picture(Url::parse(\"https://example.com/avatar.png\")?)\n        .banner(Url::parse(\"https://example.com/banner.png\")?)\n        .nip05(\"username@example.com\")\n        .lud16(\"pay@yukikishimoto.com\")\n        .custom_field(\"custom_field\", \"my value\");\n\n    // Update metadata\n    client.set_metadata(&metadata).await?;\n\n    // Publish a text note\n    let builder = EventBuilder::text_note(\"My first text note from rust-nostr!\");\n    client.send_event_builder(builder).await?;\n\n    // Create a POW text note\n    let builder = EventBuilder::text_note(\"POW text note from nostr-sdk\").pow(20);\n    client.send_event_builder(builder).await?; // Send to all relays\n    // client.send_event_builder_to([\"wss://relay.damus.io\"], builder).await?; // Send to specific relay\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Signing Metadata and Text Note Events with rust-nostr Rust\nDESCRIPTION: This snippet shows how to create metadata for a user including fields like name, display name, description, picture URL, banner URL, and custom fields using the Metadata builder pattern. It then demonstrates creating and signing a metadata event and text note events (regular and with proof-of-work) using EventBuilder. Dependencies include 'nostr::prelude::*' and URL parsing from the standard library. Inputs are user metadata details and text note content, outputs are signed Event objects ready for publishing.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet metadata = Metadata::new()\n    .name(\"username\")\n    .display_name(\"My Username\")\n    .about(\"Description\")\n    .picture(Url::parse(\"https://example.com/avatar.png\")?)\n    .banner(Url::parse(\"https://example.com/banner.png\")?)\n    .nip05(\"username@example.com\")\n    .lud16(\"pay@yukikishimoto.com\")\n    .custom_field(\"custom_field\", \"my value\");\n\nlet event: Event = EventBuilder::metadata(&metadata).sign_with_keys(&keys)?;\n\n// New text note\nlet event: Event = EventBuilder::text_note(\"Hello from rust-nostr\").sign_with_keys(&keys)?;\n\n// New POW text note\nlet event: Event = EventBuilder::text_note(\"POW text note from rust-nostr\").pow(20).sign_with_keys(&keys)?;\n```\n\n----------------------------------------\n\nTITLE: Generating and Using Keys with rust-nostr Rust\nDESCRIPTION: This snippet demonstrates how to generate new random keys or parse existing keys from hex or bech32 strings using the rust-nostr crate. It shows converting the public key to bech32 format for display. Key dependencies include the 'nostr::prelude::*' import. The snippet expects no input parameters and outputs a public key string in bech32 format after key generation or parsing.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse nostr::prelude::*;\n\nfn main() -> Result<()> {\n    // Generate new random keys\n    let keys = Keys::generate();\n\n    // Or use your already existing (from hex or bech32)\n    let keys = Keys::parse(\"hex-or-bech32-secret-key\")?;\n\n    // Convert public key to bech32\n    println!(\"Public key: {}\", keys.public_key().to_bech32()?);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Nostr Client Event to JSON with rust-nostr Rust\nDESCRIPTION: This snippet demonstrates converting a signed Event into a client message JSON string using the ClientMessage wrapper's as_json() method. It requires a constructed and signed Event input and outputs the serialized JSON string representing the client message for transmission or logging.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet json = ClientMessage::event(event).as_json();\nprintln!(\"{json}\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Nostr MLS Memory Storage in Rust\nDESCRIPTION: Provides example Rust code demonstrating how to initialize the NostrMlsMemoryStorage with default settings and with a custom cache size. The snippet shows usage of the NostrMlsMemoryStorage struct and its associated methods `default()` for a default cache size (1000 items) and `with_cache_size(size)` to specify a custom LRU cache size. It requires the nostr_mls_memory_storage and nostr_mls_storage crates, with focus on constructing instances that implement the NostrMlsStorageProvider trait.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr-mls-memory-storage/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse nostr_mls_memory_storage::NostrMlsMemoryStorage;\nuse nostr_mls_storage::NostrMlsStorageProvider;\n\n// Create a new memory storage instance\nlet storage = NostrMlsMemoryStorage::default();\n\n// Or create with a custom cache size\nlet custom_storage = NostrMlsMemoryStorage::with_cache_size(100);\n```\n\n----------------------------------------\n\nTITLE: Writing Generics with Trait Bounds in Rust\nDESCRIPTION: Demonstrates the preferred style for defining generic type parameters and their trait bounds using the where clause, improving readability and maintainability. Requires basic understanding of Rust generics and trait bounds. Input includes generic type parameters and function arguments; output produces an instance of Self or the respective implemented trait. Limitation: Avoids direct inline trait bounds for clarity.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\npub fn new<N, T, P, E>(user_id: i32, name: N, title: T, png_sticker: P, emojis: E) -> Self\nwhere\n    N: Into<String>,\n    T: Into<String>,\n    P: Into<InputFile>,\n    E: Into<String>,\n{ ... }\n```\n\nLANGUAGE: rust\nCODE:\n```\n// BAD\npub fn new<N: Into<String>,\n           T: Into<String>,\n           P: Into<InputFile>,\n           E: Into<String>>\n    (user_id: i32, name: N, title: T, png_sticker: P, emojis: E) -> Self { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits with Where Clauses in Rust\nDESCRIPTION: Illustrates how to use where clauses for trait bounds when implementing traits for generic types, enhancing code structure and legibility. No external dependencies. Expects a generic type parameter with certain trait implementations and produces an implementation for that type. Limitation: Avoids inline trait bounds in the impl header.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nimpl<T> Trait for Wrap<T>\nwhere\n    T: Trait\n{ ... }\n```\n\nLANGUAGE: rust\nCODE:\n```\n// BAD\nimpl<T: Trait> Trait for Wrap<T> { ... }\n```\n\n----------------------------------------\n\nTITLE: Referring to the Implemented Type with Self in Rust\nDESCRIPTION: Shows the best practice of using Self instead of the type name within implementation blocks, simplifying maintenance and refactoring. No special dependencies other than the implemented type. Used when writing methods for enums or structs; expects standard Rust type and method syntax. Outputs logic that is easier to copy-paste and refactor.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl ErrorKind {\n    // GOOD\n    fn print(&self) {\n        match self {\n            Self::Io => println!(\"Io\"),\n            Self::Network => println!(\"Network\"),\n            Self::Json => println!(\"Json\"),\n        }\n    }\n\n    // BAD\n    fn print(&self) {\n        match self {\n            ErrorKind::Io => println!(\"Io\"),\n            ErrorKind::Network => println!(\"Network\"),\n            ErrorKind::Json => println!(\"Json\"),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Self for Constructors in Rust\nDESCRIPTION: Emphasizes returning Self in constructor methods for consistency and clarity. No external dependencies required. Method expects arguments relevant to the type, such as lifetimes or references, and returns Self. Outputs easier-to-refactor code and avoids redundancy in type names.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> AnswerCallbackQuery<'a> {\n    // GOOD\n    fn new<C>(bot: &'a Bot, callback_query_id: C) -> Self\n    where\n        C: Into<String>,\n    { ... }\n\n    // BAD\n    fn new<C>(bot: &'a Bot, callback_query_id: C) -> AnswerCallbackQuery<'a>\n    where\n        C: Into<String>,\n    { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using match Versus if let in Rust for Conditionals\nDESCRIPTION: Illustrates the preference for using match statements over if let ... else for conditional logic, enhancing explicitness and maintainability. No dependencies required. Input is an Option type check; output is a clearer conditional. Limitation: Use if let for single-arm with empty else only.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nmatch ctx.expected_type.as_ref() {\n    Some(expected_type) => completion_ty == expected_type && !expected_type.is_unit(),\n    None => false,\n}\n\n// BAD\nif let Some(expected_type) = ctx.expected_type.as_ref() {\n    completion_ty == expected_type && !expected_type.is_unit()\n} else {\n    false\n}\n```\n\n----------------------------------------\n\nTITLE: Using if let with Single Non-Empty Arm in Rust\nDESCRIPTION: Shows when to use if let for conditional handling where the alternative branch is intentionally empty. Provides a cleaner and more compact expression in such cases. No additional dependencies. Expected for situations where only Some variant is handled and None is ignored.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nif let Some(expected_type) = this.as_ref() {\n    // Handle it\n}\n\n// BAD\nmatch this.as_ref() {\n    Some(expected_type) => {\n        // Handle it\n    },\n    None => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sub-Modules as Separate Files in Rust\nDESCRIPTION: Enforces declaring sub-modules with mod x; and defining them in x.rs files, except for special test/bench modules. This boosts project modularity and file organization. Expects modules, files, and attributes as input; outputs modular and testable code. Limitation: Internal, crate-private modules must follow this except for test/bench modules.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nmod x;\n\n// BAD\nmod x {\n    ..\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\n#[cfg(test)]\nmod tests {\n    ..\n}\n\n// BAD\nmod tests;\n```\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\n#[cfg(bench)]\nmod benches {\n    ..\n}\n\n// BAD\nmod benches;\n```\n\n----------------------------------------\n\nTITLE: Import Style for Implementing Display in Rust\nDESCRIPTION: Specifies importing trait modules (like core::fmt) and using short module names in implementation blocks for traits, promoting concise syntax. Applicable to Display or other format traits. Inputs include a struct or enum and the related trait; output uses the short import format rather than inline full paths. Limitation: Limited to trait implementation style.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nuse core::fmt;\n\nimpl fmt::Display for RenameError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { .. }\n}\n\n// BAD\nimpl core::fmt::Display for RenameError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Full Paths for Logging with tracing Crate in Rust\nDESCRIPTION: Enforces always using the full path when invoking macros from the tracing crate to reduce import block clutter and ensure uniformity. Requires the tracing crate as a dependency. The input is a logging statement; the expected output is a consistent pattern of logging across the codebase. Limitation: Avoids aliased or glob imports for tracing.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\ntracing::warn!(\"Everything is on fire\");\n\n// BAD\nuse tracing::warn;\n\nwarn!(\"Everything is on fire\");\n```\n\n----------------------------------------\n\nTITLE: Importing Sub-Modules with Self in Rust\nDESCRIPTION: Shows the preferred import style for sub-modules, using self:: to disambiguate and improve clarity. No extra dependencies. Input is sub-module code; output is cleaner, less ambiguous imports inside the parent module.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// GOOD\nmod x;\n\nuse self::x::Y;\n\n// BAD\nmod x;\n\nuse x::Y;\n```\n\n----------------------------------------\n\nTITLE: Preferred Order of Imports in Rust\nDESCRIPTION: Demonstrates the recommended order for imports: standard Rust library first, external crates second, then current sub-modules, followed by internal crate modules. No external tools required. Inputs are various import statements; produces a clean, logically ordered import block. Limitation: Only applies to modules and imports within Rust files.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CODE_STYLE.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// First core, alloc and/or std\nuse core::fmt;\nuse std::{...};\n\n// Second, external crates (both crates.io crates and other rust-analyzer crates).\nuse crate_foo::{ ... };\nuse crate_bar::{ ... };\n\n// If applicable, the current sub-modules\nmod x;\nmod y;\n\n// Finally, the internal crate modules and submodules\nuse crate::{};\nuse super::{};\nuse self::y::Y;\n```\n\n----------------------------------------\n\nTITLE: Rust API Deprecation\nDESCRIPTION: Describes the process of using the `#[deprecated]` attribute in Rust to discourage the use of old APIs, specifying that deprecated APIs are typically maintained for one release cycle before removal.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n#[deprecated]\n```\n\n----------------------------------------\n\nTITLE: Installing Nostr CLI with Cargo - Bash\nDESCRIPTION: Demonstrates how to install the nostr-cli executable using Rust's cargo package manager. Requires Rust and Cargo to be installed on the system. This command fetches and builds nostr-cli from crates.io, installing it globally on your path. No parameters required; the output is a globally available nostr-cli binary. Ensure you have the necessary permissions to install global binaries.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr-cli/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install nostr-cli\n```\n\n----------------------------------------\n\nTITLE: Displaying Nostr CLI Help Options - Bash\nDESCRIPTION: Provides a command for displaying all available nostr-cli commands and options. Assumes nostr-cli is installed and available on the system's executable path. The command outputs a help message detailing usage, flags, and subcommands available for the CLI. No input parameters are needed. Output is written to the terminal, and may vary between versions; check for updates in the help output.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr-cli/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnostr-cli --help\n```\n\n----------------------------------------\n\nTITLE: Compiling Nostr SDK for WASM on macOS\nDESCRIPTION: This shell command sequence outlines the steps required to compile the `nostr-sdk` crate for the `wasm32-unknown-unknown` target specifically on macOS. It involves installing the `llvm` package using Homebrew, determining its installation path, and then setting the `LLVM_PATH`, `AR`, and `CC` environment variables before executing the `cargo build` command with the specified WASM target.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr-sdk/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbrew install llvm\nLLVM_PATH=$(brew --prefix llvm)\nAR=\"${LLVM_PATH}/bin/llvm-ar\" CC=\"${LLVM_PATH}/bin/clang\" cargo build --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Building and Compiling rust-nostr for WebAssembly on macOS Shell\nDESCRIPTION: This shell snippet provides instructions to install LLVM on macOS to enable building the rust-nostr crate for the wasm32-unknown-unknown target. It sets environment variables for LLVM-related tools and invokes cargo build with the specified target. It is a prerequisite step for enabling WebAssembly support in this crate.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/crates/nostr/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbrew install llvm\nLLVM_PATH=$(brew --prefix llvm)\nAR=\"${LLVM_PATH}/bin/llvm-ar\" CC=\"${LLVM_PATH}/bin/clang\" cargo build --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - nostr crate\nDESCRIPTION: Illustrates the commit message format for changes to the `nostr` crate, including a short description and a longer explanation of the changes, linking it to a related issue.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nnostr: add NIP32 support\n\nAdded kinds, tags and EventBuilder constructors to support NIP32.\n\nCloses https://<domain>.com/rust-nostr/nostr/issue/1234\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - pool crate\nDESCRIPTION: Demonstrates the commit message format for changes to the `pool` crate, providing a clear description of the fix and linking it to the relevant issue.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\npool: fix connection issues\n\nLong description...\n\nFixes https://<domain>.com/rust-nostr/nostr/issue/5612\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - nwc crate\nDESCRIPTION: Presents the commit message format for contributions to the `nwc` crate, specifically adding support for `pay_multiple_invoices` and referencing the corresponding issue.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nnwc: add `pay_multiple_invoices` support\n\nCloses https://<domain>.com/rust-nostr/nostr/issue/2222\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - ffi crate (EventBuilder)\nDESCRIPTION: Shows the commit message structure for modifications to the `ffi` crate, focused on exposing `EventBuilder::mute_list`.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nffi: expose `EventBuilder::mute_list`\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - ffi crate (AbortHandle)\nDESCRIPTION: Illustrates the commit message format for the `ffi` crate, specifically for adding an `AbortHandle` and detailing the changes made.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\nffi: add `AbortHandle`\n\n- Return `AbortHandle` in `Client::handle_notifications`\n- Another change...\n```\n\n----------------------------------------\n\nTITLE: Rust Commit Style Example - js bindings\nDESCRIPTION: Provides an example of the commit message format when modifying JavaScript bindings, in this case, replacing the log file path with the module path.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: Text\nCODE:\n```\njs: replace log `file path` with `module path`\n```\n\n----------------------------------------\n\nTITLE: Executing Pre-Release Checks in Rust Nostr Project\nDESCRIPTION: Command to verify that everything compiles properly before initiating a release. This is a crucial first step in the release process to ensure code quality.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/contrib/release/RELEASE_STEPS.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njust check\n```\n\n----------------------------------------\n\nTITLE: Publishing Rust Crates and Bindings\nDESCRIPTION: Commands for publishing crates using either the just task runner or a bash script. This step releases the Rust components to their respective package repositories.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/contrib/release/RELEASE_STEPS.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\njust release\n```\n\nLANGUAGE: bash\nCODE:\n```\nbash ./contrib/scripts/release.sh\n```\n\n----------------------------------------\n\nTITLE: Verifying Rust Book Documentation\nDESCRIPTION: Command to check that the Rust book documentation is valid and up-to-date. This ensures that the documentation examples are working with the new release.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/contrib/release/RELEASE_STEPS.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\njust check-book\n```\n\n----------------------------------------\n\nTITLE: Importing PGP Key via GPG (Bash)\nDESCRIPTION: This command uses the GnuPG (gpg) tool to import a public PGP key from the specified keyserver using its fingerprint. This is a standard method for obtaining a recipient's public key to encrypt sensitive information or verify signatures, facilitating secure communication for vulnerability reporting. It requires replacing the placeholder \"<fingerprint>\" with the actual key fingerprint.\nSOURCE: https://github.com/rust-nostr/nostr/blob/master/SECURITY.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngpg --keyserver hkps://keys.openpgp.org --recv-keys \"<fingerprint>\"\n```"
  }
]