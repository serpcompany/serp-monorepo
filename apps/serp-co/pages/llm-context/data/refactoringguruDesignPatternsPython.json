[
  {
    "owner": "refactoringguru",
    "repo": "design-patterns-python",
    "content": "TITLE: Implementing Decorators for the Concrete Component in Python\nDESCRIPTION: This snippet demonstrates how to implement decorator classes that wrap the ConcreteComponent, adding or modifying behavior dynamically. It involves subclassing and composition, with decorators wrapping other components or decorators. The structure supports nested decorators, as shown in the client scenario.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Decorator/Conceptual/Output.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass ConcreteDecoratorA:\n    def __init__(self, component):\n        self._component = component\n    def operation(self):\n        return f\"Decorated A({self._component.operation()})\"\n```\n\nLANGUAGE: Python\nCODE:\n```\nclass ConcreteDecoratorB:\n    def __init__(self, component):\n        self._component = component\n    def operation(self):\n        return f\"Decorated B({self._component.operation()})\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Proxy Design Pattern in Python with Access Control and Logging\nDESCRIPTION: This code snippet demonstrates the Proxy design pattern implementation where a Proxy class controls access to a RealSubject, adding access checking before forwarding requests and logging after handling the request. The Client code works with both the RealSubject and Proxy transparently.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Proxy/Conceptual/Output.txt#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nClient: Executing the client code with a real subject:\nRealSubject: Handling request.\n\nClient: Executing the same client code with a proxy:\nProxy: Checking access prior to firing a real request.\nRealSubject: Handling request.\nProxy: Logging the time of request.\n```\n\n----------------------------------------\n\nTITLE: Implementing Adapter Class to Translate Adaptee Interface in Python\nDESCRIPTION: Implements the Adapter class that inherits from Target and composes an instance of Adaptee. This class adapts the incompatible interface of Adaptee by overriding the request method to translate the Adaptee's specific_request output (a reversed string) into a human-readable string. It requires instances of Adaptee as dependencies, taking no parameters beyond object instantiation. The output is the translated string representing Adaptee's special behavior in a compatible format.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/object/Output.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass Adapter(Target):\n    def __init__(self, adaptee: Adaptee) -> None:\n        self.adaptee = adaptee\n\n    def request(self) -> str:\n        return f\"(TRANSLATED) {self.adaptee.specific_request()[::-1]}\"\n```\n\n----------------------------------------\n\nTITLE: Creating the Adapter Class in Python to Bridge Target and Adaptee\nDESCRIPTION: Implements the Adapter class that inherits from Target and wraps an Adaptee instance. It translates calls from the Target interface into calls to the Adaptee's specific methods, facilitating compatibility.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/class/Output.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass Adapter(Target):\n    def __init__(self, adaptee):\n        self.adaptee = adaptee\n\n    def request(self):\n        # Translates the request to the Adaptee's method\n        return self.adaptee.specific_request()\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Command and Invoker in Python\nDESCRIPTION: This snippet shows a SimpleCommand class that performs a simple action (printing a greeting) and an Invoker class that orchestrates the execution of commands.  The SimpleCommand takes a payload (the greeting) and executes it.  The Invoker asks if anybody wants anything done before and after command execution.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Command/Conceptual/Output.txt#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Implementing Complex Command and Receiver in Python\nDESCRIPTION: This demonstrates a ComplexCommand and a Receiver. The ComplexCommand uses a Receiver to perform more complicated actions, such as sending an email or saving a report. The Receiver encapsulates the actual work. There are no specific parameters shown in this extract, but the Receiver's methods implicitly handle the details of 'Send email.' and 'Save report.'\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Command/Conceptual/Output.txt#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Defining the Originator Class for State Management in Python\nDESCRIPTION: This snippet defines the Originator class responsible for creating and restoring its internal state. It includes methods to set the current state, save it to a Memento, and restore its state from a given Memento, enabling undo operations. Dependencies are minimal, relying on standard Python structures.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Memento/Conceptual/Output.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Originator:\n    def __init__(self, state):\n        self._state = state\n\n    def set_state(self, state):\n        self._state = state\n\n    def save_to_memento(self):\n        return Memento(self._state)\n\n    def restore_from_memento(self, memento):\n        self._state = memento.get_state()\n\n    def get_state(self):\n        return self._state\n```\n\n----------------------------------------\n\nTITLE: Implementing the Caretaker Class for Saving and Restoring States in Python\nDESCRIPTION: This snippet implements the Caretaker class that manages a list of Memento objects, enabling saving current states and rolling back to previous states by index. It acts as the caretaker in the pattern, decoupling the state storage from the Originator. Dependencies include basic list operations.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Memento/Conceptual/Output.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass Caretaker:\n    def __init__(self):\n        self._mementos = []\n\n    def add_memento(self, memento):\n        self._mementos.append(memento)\n\n    def get_memento(self, index):\n        return self._mementos[index]\n\n    def list_mementos(self):\n        return self._mementos\n```\n\n----------------------------------------\n\nTITLE: Defining the Memento Class for State Storage in Python\nDESCRIPTION: This snippet introduces the Memento class, which encapsulates the state of the Originator at a specific point in time. It provides methods to retrieve the stored state, facilitating the rollback process in the design pattern. The class is simple and depends solely on storing the state value.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Memento/Conceptual/Output.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Memento:\n    def __init__(self, state):\n        self._state = state\n\n    def get_state(self):\n        return self._state\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Concrete Component in Python\nDESCRIPTION: This code snippet defines a basic concrete component class that provides core functionality in the design pattern, serving as the object that can be decorated or extended. It involves no dependencies beyond standard Python classes.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Decorator/Conceptual/Output.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass ConcreteComponent:\n    def operation(self):\n        return \"Result: ConcreteComponent\"\n```\n\n----------------------------------------\n\nTITLE: Defining Adaptee Class with Specialized Behavior in Python\nDESCRIPTION: Defines the Adaptee class that has a specialized behavior with an incompatible interface, demonstrated by returning a reversed string. This class has a method named differently from the Target's request method, requiring adaptation. There are no dependencies, and it outputs a reversed string representing special behavior.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/object/Output.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Adaptee:\n    def specific_request(self) -> str:\n        return \".eetpadA eht fo roivaheb laicepS\"\n```\n\n----------------------------------------\n\nTITLE: Defining Target Class in Python\nDESCRIPTION: Defines the Target class which provides the default interface expected by the client. It implements a method representing standard behavior used within the Adapter pattern. There are no dependencies or parameters. The output is a string indicating default behavior.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/object/Output.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Target:\n    def request(self) -> str:\n        return \"The default target\\'s behavior.\"\n```\n\n----------------------------------------\n\nTITLE: Implementing the Target Interface in Python\nDESCRIPTION: Defines the Target class representing the interface the client expects. It provides a standard method for clients to interact with objects, serving as the expected interface for adapters.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/class/Output.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Target:\n    def request(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining the Adaptee with a Different Interface in Python\nDESCRIPTION: Defines the Adaptee class with a non-standard method or interface that is incompatible with the Target's expected interface. It often contains legacy or specialized code requiring adaptation.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Adapter/Conceptual/class/Output.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Adaptee:\n    def specific_request(self):\n        return \".eetpadA eht fo roivaheb laicepS\"\n```\n\n----------------------------------------\n\nTITLE: Bridge Pattern Implementation Output in Python\nDESCRIPTION: Example output from a Bridge pattern implementation showing how different abstractions interact with different concrete implementations. The pattern separates abstractions from their implementations allowing them to vary independently.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Bridge/Conceptual/Output.txt#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nAbstraction: Base operation with:\nConcreteImplementationA: Here's the result on the platform A.\n\nExtendedAbstraction: Extended operation with:\nConcreteImplementationB: Here's the result on the platform B.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Composite Pattern Output in Python\nDESCRIPTION: This snippet shows the console output from a Composite pattern implementation in Python. It demonstrates how clients can work with individual objects (Leaf) and compositions of objects (Branch) using the same interface, allowing for tree structure manipulation regardless of component type.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/src/Composite/Conceptual/Output.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nClient: I've got a simple component:\nRESULT: Leaf\n\nClient: Now I've got a composite tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))\n\nClient: I don't need to check the components classes even when managing the tree:\nRESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)\n```\n\n----------------------------------------\n\nTITLE: Executing Python Examples\nDESCRIPTION: This code snippet demonstrates how to execute the Python examples from the command line. It uses the python executable to run the main.py file located in the specified path.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npython src/Path-to-example/main.py\n```\n\n----------------------------------------\n\nTITLE: Multi-Language Comments Example\nDESCRIPTION: This code snippet demonstrates the use of multi-language comments within the Python code.  It includes English (EN) and Russian (RU) translations of the comments to support website generation of separate examples for listed languages. Ignoring non-English comments is encouraged if only making modifications to one language.\nSOURCE: https://github.com/refactoringguru/design-patterns-python/blob/main/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\n    EN: All products families have the same varieties (MacOS/Windows).\n\n    This is a MacOS variant of a button.\n\n    RU: Все семейства продуктов имеют одни и те же вариации (MacOS/Windows).\n\n    Это вариант кнопки под MacOS.\n    \"\"\"\n```"
  }
]