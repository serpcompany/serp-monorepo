[
  {
    "owner": "hypergonial",
    "repo": "hikari-arc",
    "content": "TITLE: Creating Type Aliases in Python 3.10 & 3.11\nDESCRIPTION: Example showing how to create type aliases in Python 3.10 and 3.11 by assigning complex types to variables for reuse in function signatures.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nDataT = list[dict[str, set[int]]]\n\ndef do_stuff(data: DataT) -> DataT:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating REST Discord Bot with Slash Commands\nDESCRIPTION: Example code demonstrating how to create a Discord bot using RESTBot with a slash command that mentions users. Shows basic setup and command implementation for REST-based interactions.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/getting_started.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\n# Create an instance of a RESTBot\n# Paste your token from the dev portal in here\nbot = hikari.RESTBot(\"TOKEN\")\n\n# Pass it to arc\nclient = arc.RESTClient(bot)\n\n\n@client.include # Add it to the client\n@arc.slash_command(\"hi\", \"Say hi to someone!\") # Define a new command\nasync def hi_slash(\n    ctx: arc.RESTContext,\n    # Add a new slash option that asks for a user\n    user: arc.Option[hikari.User, arc.UserParams(\"The user to say hi to.\")]\n) -> None:\n    await ctx.respond(f\"Hey {user.mention}!\")\n\n# This should be the last line, no code will be run after this\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Hikari-Arc with Gateway Bot\nDESCRIPTION: Example demonstrating how to set up a basic Discord bot using hikari-arc with a gateway bot. It includes creating a slash command that mentions a user.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/README.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\nbot = hikari.GatewayBot(\"TOKEN\") # or hikari.RESTBot\nclient = arc.GatewayClient(bot) # or arc.RESTClient\n\n@client.include\n@arc.slash_command(\"hi\", \"Say hi!\")\nasync def ping(\n    ctx: arc.GatewayContext,\n    user: arc.Option[hikari.User, arc.UserParams(\"The user to say hi to.\")]\n) -> None:\n    await ctx.respond(f\"Hey {user.mention}!\")\n\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Setting Error Handler for Gateway Client in Python\nDESCRIPTION: This snippet shows how to set an error handler for a Gateway client using the set_error_handler method within a loader function.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/error_handling.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@arc.loader\nasync def load(client: arc.GatewayClient) -> None:\n    client.set_error_handler(some_func)\n```\n\n----------------------------------------\n\nTITLE: Creating Gateway Discord Bot with Slash Commands\nDESCRIPTION: Example code demonstrating how to create a Discord bot using GatewayBot with a slash command that mentions users. Shows basic setup and command implementation.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/getting_started.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\n# Create an instance of a GatewayBot\n# Paste your bot token from the dev portal in here\nbot = hikari.GatewayBot(\"TOKEN\")\n\n# Pass it to arc\nclient = arc.GatewayClient(bot)\n\n\n@client.include # Add it to the client\n@arc.slash_command(\"hi\", \"Say hi to someone!\") # Define a new command\nasync def hi_slash(\n    ctx: arc.GatewayContext,\n    # Add a new slash option that asks for a user\n    user: arc.Option[hikari.User, arc.UserParams(\"The user to say hi to.\")]\n) -> None:\n    await ctx.respond(f\"Hey {user.mention}!\")\n\n# This should be the last line, no code will be run after this\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Creating a REST Extension with Plugin in Hikari-arc\nDESCRIPTION: This snippet shows how to create an extension file containing a REST plugin. It includes the necessary loader and optional unloader functions for managing the plugin in a REST-based bot.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport arc\n\nplugin = arc.RESTPlugin(\"foo\")\n\n@plugin.include\n@arc.slash_command(\"foo\", \"Foo command\")\nasync def foo_cmd(\n    ctx: arc.RESTContext,\n) -> None:\n    await ctx.respond(f\"Foo!\")\n\n# This will run when the extension is loaded\n# If there is no loader, the extension cannot be loaded!\n@arc.loader\ndef loader(client: arc.RESTClient) -> None:\n    client.add_plugin(plugin)\n\n# If you add an unloader, the extension can also be unloaded at runtime!\n# Adding an unloader is optional.\n@arc.unloader\ndef unloader(client: arc.RESTClient) -> None:\n    client.remove_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Creating a Message Event Listener with GatewayClient in Hikari-Arc\nDESCRIPTION: This code demonstrates how to set up a basic event listener for message creation events using hikari.GatewayBot and arc.GatewayClient. The listener ignores messages from bots (including itself) and responds to any human message with 'Hi!'.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/events.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# This only works with Gateway bots\nbot = hikari.GatewayBot(\"...\")\nclient = arc.GatewayClient(bot)\n\n# ...\n\n@client.listen()\nasync def on_message(event: hikari.MessageCreateEvent) -> None:\n\n    # Ignore ourselves & other bots\n    if not event.is_human:\n        return\n\n    await client.rest.create_message(event.channel_id, \"Hi!\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Gateway Extension with Plugin in Hikari-arc\nDESCRIPTION: This snippet shows how to create an extension file containing a Gateway plugin. It includes the necessary loader and optional unloader functions that manage the plugin when the extension is loaded or unloaded.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport arc\n\nplugin = arc.GatewayPlugin(\"foo\")\n\n@plugin.include\n@arc.slash_command(\"foo\", \"Foo command\")\nasync def foo_cmd(\n    ctx: arc.GatewayContext,\n) -> None:\n    await ctx.respond(f\"Foo!\")\n\n# This will run when the extension is loaded\n# If there is no loader, the extension cannot be loaded!\n@arc.loader\ndef loader(client: arc.GatewayClient) -> None:\n    client.add_plugin(plugin)\n\n# If you add an unloader, the extension can also be unloaded at runtime!\n# Adding an unloader is optional.\n@arc.unloader\ndef unloader(client: arc.GatewayClient) -> None:\n    client.remove_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Enabling Both Installation Types for All Commands in Gateway Client\nDESCRIPTION: Configures a GatewayClient to support both guild and user installation types, allowing the application to be installed in either context.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclient = arc.GatewayClient(\n    bot,\n    integration_types=[\n        hikari.ApplicationIntegrationType.GUILD_INSTALL,\n        hikari.ApplicationIntegrationType.USER_INSTALL\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing User Context Menu Command\nDESCRIPTION: Example showing how to create a user context menu command using both Gateway and REST approaches. The command responds with a greeting mentioning the target user.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/context_menu.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.user_command(\"Say Hi\")\nasync def hi_user(ctx: arc.GatewayContext, user: hikari.User) -> None:\n    await ctx.respond(f\"Hey {user.mention}!\")\n```\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.user_command(\"Say Hi\")\nasync def hi_user(ctx: arc.RESTContext, user: hikari.User) -> None:\n    await ctx.respond(f\"Hey {user.mention}!\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Gateway Context Subcommands\nDESCRIPTION: Implements permission management subcommands using Gateway context, including get and edit operations for both users and roles.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/command_groups.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@user.include\n@arc.slash_subcommand(\"get\", \"Get permissions for a user\")\nasync def perms_user_get(ctx: arc.GatewayContext) -> None:\n    ...\n\n@user.include\n@arc.slash_subcommand(\"edit\", \"Edit permissions for a user\")\nasync def perms_user_edit(ctx: arc.GatewayContext) -> None:\n    ...\n\n@role.include\n@arc.slash_subcommand(\"get\", \"Get permissions for a role\")\nasync def perms_role_get(ctx: arc.GatewayContext) -> None:\n    ...\n\n@role.include\n@arc.slash_subcommand(\"edit\", \"Edit permissions for a role\")\nasync def perms_role_edit(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Context Menu Command\nDESCRIPTION: Example showing how to create a message context menu command using both Gateway and REST approaches. The command responds with a greeting mentioning the author of the target message.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/context_menu.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.message_command(\"Say Hi\")\nasync def hi_message(ctx: arc.GatewayContext, message: hikari.Message) -> None:\n    await ctx.respond(f\"Hey {message.author.mention}!\")\n```\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.message_command(\"Say Hi\")\nasync def hi_message(ctx: arc.RESTContext, message: hikari.Message) -> None:\n    await ctx.respond(f\"Hey {message.author.mention}!\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Text Channel using REST Client in Hikari/Arc\nDESCRIPTION: This snippet shows how to create a new text channel using a REST client's REST module. Similar to the Gateway example, it creates a slash command that takes a channel name parameter and creates a text channel in the current guild.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hikari_fundamentals.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"make_channel\", \"Make a new channel!\")\nasync def make_channel(\n    ctx: arc.RESTContext,\n    name: arc.Option[str, arc.StrParams(\"The channel's name\")]\n) -> None:\n    await client.rest.create_guild_text_channel(ctx.guild_id, name)\n    await ctx.respond(\"Channel created!\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Top-Level Slash Command Group\nDESCRIPTION: Creates a top-level slash command group for permissions management using the Client.include_slash_group() method.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/command_groups.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npermissions = client.include_slash_group(\"permissions\", \"Get or edit permissions for a user or role\")\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies in REST Commands\nDESCRIPTION: Demonstrates how to inject the MyDatabase dependency into a slash command using REST client. The command increments a counter stored in the database.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"increment\", \"Increment a counter!\")\n# We inject a dependency of type 'MyDatabase' here.\nasync def increment(\n    ctx: arc.RESTContext, db: MyDatabase = arc.inject()\n) -> None:\n    db.value += 1\n    await ctx.respond(f\"Counter is at: `{db.value}`\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Gateway Plugin with Commands in Hikari-arc\nDESCRIPTION: This snippet demonstrates how to create a Gateway plugin, add slash commands to it, and add the plugin to the client. Plugins allow grouping related commands together and applying shared settings to them.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.GatewayPlugin(\"plugin name\")\n\n@plugin.include\n@arc.slash_command(\"name\", \"description\")\nasync def plugin_cmd(ctx: arc.GatewayContext) -> None:\n    ...\n\n@plugin.include\n@arc.slash_command(\"other-name\", \"description\")\nasync def other_plugin_cmd(ctx: arc.GatewayContext) -> None:\n    ...\n\nclient.add_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Implementing Gateway Command Concurrency Limiting in Python\nDESCRIPTION: Example of implementing channel-based concurrency limiting for a Gateway slash command. The code limits the command to 1 instance per channel and includes error handling for max concurrency situations.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/concurrency_limiting.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n# Limit the command to 1 instance per channel\n@arc.with_concurrency_limit(arc.channel_concurrency(1))\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.GatewayContext) -> None:\n    await ctx.respond(\"Hello, I'm running for the next 10 seconds!\")\n    await asyncio.sleep(10.0)\n    await ctx.edit_initial_response(\"I'm done!\")\n\n@foo.set_error_handler\nasync def foo_error_handler(ctx: arc.GatewayContext, error: Exception) -> None:\n    if isinstance(error, arc.MaxConcurrencyReachedError):\n        await ctx.respond(\n            \"Max concurrency reached!\"\n            f\"\\nThis command can only have `{error.max_concurrency}` instances running.\"\n        )\n    else:\n        raise error\n```\n\n----------------------------------------\n\nTITLE: Setting Dependencies with REST Client\nDESCRIPTION: Shows how to set up a basic database dependency using RESTClient in Hikari Arc. Creates a simple MyDatabase class and registers it as a dependency.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\nimport hikari\nimport arc\n\n# This is just an example \"database\" that stores a single integer\nclass MyDatabase:\n    def __init__(self, value: int) -> None:\n        self.value = value\n\nbot = hikari.RESTBot(\"TOKEN\")\nclient = arc.RESTClient(bot)\n\n\ndatabase = MyDatabase(value=0)\n\n# We declare a new dependency of type 'MyDatabase' and the value of 'database'\nclient.set_type_dependency(MyDatabase, database)\n```\n\n----------------------------------------\n\nTITLE: Implementing REST Command Concurrency Limiting in Python\nDESCRIPTION: Example of implementing channel-based concurrency limiting for a REST slash command. The code limits the command to 1 instance per channel and includes error handling for max concurrency situations.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/concurrency_limiting.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n# Limit the command to 1 instance per channel\n@arc.with_concurrency_limit(arc.channel_concurrency(1))\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.RESTContext) -> None:\n    await ctx.respond(\"Hello, I'm running for the next 10 seconds!\")\n    await asyncio.sleep(10.0)\n    await ctx.edit_initial_response(\"I'm done!\")\n\n@foo.set_error_handler\nasync def foo_error_handler(ctx: arc.RESTContext, error: Exception) -> None:\n    if isinstance(error, arc.MaxConcurrencyReachedError):\n        await ctx.respond(\n            \"Max concurrency reached!\"\n            f\"\\nThis command can only have `{error.max_concurrency}` instances running.\"\n        )\n    else:\n        raise error\n```\n\n----------------------------------------\n\nTITLE: Implementing Gateway Interval Loop with Class\nDESCRIPTION: Example of creating and starting a recurring task using the IntervalLoop class with a Gateway client.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/loops.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def loopy_loop(value: int) -> None:\n    print(value)\n\n# Create a loop by passing the function in\nloop = arc.utils.IntervalLoop(loopy_loop, seconds=10.0)\n\n# Somewhere else:\n\n@client.add_startup_hook\nasync def startup(client: arc.GatewayClient) -> None:\n    # Start the loop by passing all the parameters it needs\n    loop.start(value=10)\n```\n\n----------------------------------------\n\nTITLE: Using Named Choices in Gateway Slash Command\nDESCRIPTION: Demonstrates how to use a mapping for named choices. Users see the names (one, two, three) while the command receives the corresponding values (1, 2, 3).\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"choices\", \"I can't choose!\")\nasync def choices_command(\n    ctx: arc.GatewayContext,\n    # Set the 'choices' parameter to all the valid values your option can be\n    choose_me: arc.Option[int, arc.IntParams(\"Choose me!\", choices={\"one\": 1, \"two\": 2, \"three\": 3})]\n) -> None:\n    await ctx.respond(f\"You wrote: `{choose_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Gateway Interval Loop with Decorator\nDESCRIPTION: Example of creating and starting a recurring task using the interval_loop decorator with a Gateway client.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/loops.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@arc.utils.interval_loop(seconds=10.0)\nasync def loopy_loop(value: int) -> None:\n    print(value)\n\n# Somewhere else:\n\n@client.add_startup_hook\nasync def startup(client: arc.GatewayClient) -> None:\n    # Start the loop by passing all the parameters it needs\n    loopy_loop.start(value=10)\n```\n\n----------------------------------------\n\nTITLE: Declaring Basic Option in Gateway Slash Command\nDESCRIPTION: Shows how to declare a required integer option in a gateway slash command. The option uses arc.Option with IntParams to define a number parameter.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def options_cmd(\n    ctx: arc.GatewayContext,\n    number: arc.Option[int, arc.IntParams(\"A number\")]\n) -> None:\n    await ctx.respond(f\"You provided {number}!\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Options in REST Slash Command\nDESCRIPTION: Demonstrates how to make options not required in a REST slash command by setting default values. Includes an integer option with default value 10 and a nullable User option.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def options_cmd(\n    ctx: arc.RESTContext,\n    number: arc.Option[int, arc.IntParams(\"A number\")] = 10,\n    user: arc.Option[hikari.User | None, arc.UserParams(\"A user\")] = None,\n) -> None:\n    await ctx.respond(f\"You provided {number} and {user.mention if user else None}!\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Message Event Listener in a Plugin for Hikari-Arc\nDESCRIPTION: This snippet shows how to implement an event listener within a plugin using arc.GatewayPlugin. Similar to the client-level listener, it responds to human messages with 'Hi!' while ignoring bot messages.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/events.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.GatewayPlugin(\"name\")\n\n# ...\n\n@plugin.listen()\nasync def on_message(event: hikari.MessageCreateEvent) -> None:\n\n    # Ignore ourselves & other bots\n    if not event.is_human:\n        return\n\n    await plugin.client.rest.create_message(event.channel_id, \"Hi!\")\n```\n\n----------------------------------------\n\nTITLE: Implementing REST Autodefer in Discord Commands\nDESCRIPTION: Shows implementation of a time-consuming Discord slash command with REST autodefer functionality\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/interactions.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport arc\nimport asyncio\n\n# ... Snip\n\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def takes_time(context: arc.RESTContext) -> None:\n    await asyncio.sleep(10) # Simulate something taking a long time\n    await context.respond(\"Finished!\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Text Channel using Gateway Client in Hikari/Arc\nDESCRIPTION: This snippet demonstrates how to create a new text channel using a Gateway client's REST module. It defines a slash command that takes a channel name as input and creates a new text channel in the guild where the command was invoked.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hikari_fundamentals.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"make_channel\", \"Make a new channel!\")\nasync def make_channel(\n    ctx: arc.GatewayContext,\n    name: arc.Option[str, arc.StrParams(\"The channel's name\")]\n) -> None:\n    await client.rest.create_guild_text_channel(ctx.guild_id, name)\n    await ctx.respond(\"Channel created!\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Ephemeral Autodefer in Gateway Commands\nDESCRIPTION: Demonstrates how to configure ephemeral autodefer mode in Discord gateway commands\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/interactions.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport arc\nimport asyncio\n\n# ... Snip\n\n@client.include\n@arc.slash_command(\"name\", \"description\", autodefer=AutodeferMode.EPHEMERAL)\nasync def takes_time(context: arc.GatewayContext) -> None:\n    await asyncio.sleep(10)\n    await context.respond(\"Finished!\") # This will now be an ephemeral response!\n```\n\n----------------------------------------\n\nTITLE: Enabling Both Installation Types for All Commands in REST Client\nDESCRIPTION: Configures a RESTClient to support both guild and user installation types, allowing the application to be installed in either context.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclient = arc.RESTClient(\n    bot,\n    integration_types=[\n        hikari.ApplicationIntegrationType.GUILD_INSTALL,\n        hikari.ApplicationIntegrationType.USER_INSTALL\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple Extensions from Directory in Gateway Bot\nDESCRIPTION: This snippet shows how to load all extensions from a specific directory in a Gateway bot. The load_extensions_from method automatically finds and loads all valid extension modules.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\nbot = hikari.GatewayBot(\"TOKEN\")\nclient = arc.GatewayClient(bot)\n\n# Will run foo.loader() and bar.loader()\nclient.load_extensions_from(\"extensions\")\n\n\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Gateway Implementation with Abstract Database\nDESCRIPTION: Shows how to use dependency injection with abstract database types in a Gateway command implementation.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nis_testing = True # Change me!\n\nclient = arc.GatewayClient(...)\n\nif is_testing:\n    client.set_type_dependency(Database, MockDatabase())\nelse:\n    client.set_type_dependency(Database, ProductionDatabase())\n\n@client.include\n@arc.slash_command(\"fetch\", \"Fetch totally real data some of the time!\")\n# We inject 'Database' here, the caller doesn't know which\n# implementation it will get!\nasync def fetch_data(\n    ctx: arc.GatewayContext, db: Database = arc.inject()\n) -> None:\n    data = await db.fetch_data()\n    await ctx.respond(f\"Data is: `{data}`\")\n```\n\n----------------------------------------\n\nTITLE: Aborting Command Execution by Raising an Exception\nDESCRIPTION: Example of a pre-execution hook that can abort command execution by raising an exception. This approach allows the exception to be handled by error handlers.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef my_check(ctx: arc.Context[Any]) -> None:\n    if ctx.author.id != 1234567890:\n        raise Exception(\"Unauthorized user tried to run command!\")\n```\n\n----------------------------------------\n\nTITLE: Loading a Single Extension in Gateway Bot\nDESCRIPTION: This snippet shows how to load a single extension in a Gateway bot. The load_extension method is used to load a specific extension module from the extensions directory.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\nbot = hikari.GatewayBot(\"TOKEN\")\nclient = arc.GatewayClient(bot)\n\n# Will run foo.loader()\nclient.load_extension(\"extensions.foo\")\n\n\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: REST Implementation with Abstract Database\nDESCRIPTION: Shows how to use dependency injection with abstract database types in a REST command implementation.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nis_testing = True # Change me!\n\nclient = arc.RESTClient(...)\n\nif is_testing:\n    client.set_type_dependency(Database, MockDatabase())\nelse:\n    client.set_type_dependency(Database, ProductionDatabase())\n\n@client.include\n@arc.slash_command(\"fetch\", \"Fetch totally real data some of the time!\")\n# We inject 'Database' here, the caller doesn't know which\n# implementation it will get!\nasync def fetch_data(\n    ctx: arc.RESTContext, db: Database = arc.inject()\n) -> None:\n    data = await db.fetch_data()\n    await ctx.respond(f\"Data is: `{data}`\")\n```\n\n----------------------------------------\n\nTITLE: Class Type Hints\nDESCRIPTION: Demonstrates using custom classes as types in function parameters and return values.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Person:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\n\ndef get_person_name(one_person: Person) -> str:\n    return one_person.name\n```\n\n----------------------------------------\n\nTITLE: Setting Dependencies with Gateway Client\nDESCRIPTION: Shows how to set up a basic database dependency using GatewayClient in Hikari Arc. Creates a simple MyDatabase class and registers it as a dependency.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport typing\n\nimport hikari\nimport arc\n\n# This is just an example \"database\" that stores a single integer\nclass MyDatabase:\n    def __init__(self, value: int) -> None:\n        self.value = value\n\nbot = hikari.GatewayBot(\"TOKEN\")\nclient = arc.GatewayClient(bot)\n\n\ndatabase = MyDatabase(value=0)\n\n# We declare a new dependency of type 'MyDatabase' and the value of 'database'\nclient.set_type_dependency(MyDatabase, database)\n```\n\n----------------------------------------\n\nTITLE: Configuring Ephemeral Autodefer in REST Commands\nDESCRIPTION: Demonstrates how to configure ephemeral autodefer mode in Discord REST commands\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/interactions.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport arc\nimport asyncio\n\n# ... Snip\n\n@client.include\n@arc.slash_command(\"name\", \"description\", autodefer=AutodeferMode.EPHEMERAL)\nasync def takes_time(context: arc.RESTContext) -> None:\n    await asyncio.sleep(10)\n    await context.respond(\"Finished!\") # This will now be an ephemeral response!\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Regular Functions\nDESCRIPTION: Shows how to inject dependencies into regular Python functions using the @inject_dependencies decorator. Compares a value with the database counter.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@client.inject_dependencies\ndef compare_counter(value: int, db: MyDatabase = arc.inject()) -> None:\n    if value > db.value:\n        print(\"Value is bigger!\")\n    else:\n        print(\"Counter is bigger or equal!\")\n```\n\n----------------------------------------\n\nTITLE: Aborting Command Execution with HookResult\nDESCRIPTION: Example of a pre-execution hook that can silently abort command execution by returning HookResult with abort=True. This approach doesn't raise an exception that needs handling.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef my_check(ctx: arc.Context[Any]) -> arc.HookResult:\n    if ctx.author.id != 1234567890:\n        return arc.HookResult(abort=True)\n    return arc.HookResult()\n```\n\n----------------------------------------\n\nTITLE: Abstract Database Implementation Example\nDESCRIPTION: Demonstrates dependency injection with abstract base classes, showing how to swap between production and mock database implementations.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport abc\n\n# Abstract base type for a database of some kind\nclass Database(abc.ABC):\n\n    @abc.abstractmethod\n    async def fetch_data(self) -> int:\n        ...\n\n# \"Real\" database\nclass ProductionDatabase(Database):\n\n    async def fetch_data(self) -> int:\n        # Fetch data from a supposed \"database\"\n        return 10\n\n# Testing database\nclass MockDatabase(Database):\n\n    async def fetch_data(self) -> int:\n        # Return \"fake\" testing data\n        return 0\n```\n\n----------------------------------------\n\nTITLE: Implementing REST Interval Loop with Decorator\nDESCRIPTION: Example of creating and starting a recurring task using the interval_loop decorator with a REST client.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/loops.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@arc.utils.interval_loop(seconds=10.0)\nasync def loopy_loop(value: int) -> None:\n    print(value)\n\n# Somewhere else:\n\n@client.add_startup_hook\nasync def startup(client: arc.RESTClient) -> None:\n    # Start the loop by passing all the parameters it needs\n    loopy_loop.start(value=10)\n```\n\n----------------------------------------\n\nTITLE: Listing Guild Roles from Client Cache in Hikari/Arc\nDESCRIPTION: This snippet demonstrates how to access the client's cache to retrieve information about all roles in a guild. It uses the cache module to get a view of all roles, then formats them as mentions in a response message.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hikari_fundamentals.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"roles\", \"List all the roles in this guild!\")\nasync def channel_info(ctx: arc.GatewayContext) -> None:\n    # This returns a mapping of {role_id: role object}\n    roles = client.cache.get_roles_view_for_guild(ctx.guild_id)\n    # Concatenate the mentions into a string\n    role_mentions = \" \".join(role.mention for role in roles.values())\n\n    await ctx.respond(f\"The roles in this guild are: {role_mentions}\")\n```\n\n----------------------------------------\n\nTITLE: Registering a Pre-execution Hook with a Gateway Command\nDESCRIPTION: Example showing how to attach a pre-execution hook to a Gateway slash command using the @arc.with_hook decorator. This hook will run before the command is executed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.with_hook(my_hook)\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Restricting Channel Types in Channel Options\nDESCRIPTION: Shows how to restrict the types of channels a user can pass to a channel option. Examples include limiting to textable guild channels or specific channel types like news or text.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntextable: arc.Option[hikari.TextableGuildChannel, arc.ChannelParams(...)]\n```\n\nLANGUAGE: python\nCODE:\n```\nnews_or_text: arc.Option[hikari.GuildTextChannel | hikari.GuildNewsChannel, arc.ChannelParams(...)]\n```\n\n----------------------------------------\n\nTITLE: Declaring Basic Option in REST Slash Command\nDESCRIPTION: Shows how to declare a required integer option in a REST slash command. The option uses arc.Option with IntParams to define a number parameter.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def options_cmd(\n    ctx: arc.RESTContext,\n    number: arc.Option[int, arc.IntParams(\"A number\")]\n) -> None:\n    await ctx.respond(f\"You provided {number}!\")\n```\n\n----------------------------------------\n\nTITLE: Registering a Pre-execution Hook with a REST Command\nDESCRIPTION: Example showing how to attach a pre-execution hook to a REST slash command using the @arc.with_hook decorator. This hook will run before the command is executed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.with_hook(my_hook)\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handler for Gateway Command in Python\nDESCRIPTION: This snippet demonstrates how to create a local error handler for a Gateway command using the @set_error_handler decorator. It shows error raising in the command and handling in the error handler.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/error_handling.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def error_command_func(ctx: arc.GatewayContext) -> None:\n    raise RuntimeError(\"I'm an error!\")\n\n# 'error_command_func' in this case is the command function name\n@error_command_func.set_error_handler\nasync def error_handler(ctx: arc.GatewayContext, exc: Exception) -> None:\n    if isinstance(exc, RuntimeError):\n        print(f\"Handled error: {exc}\")\n        return\n    raise exc\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Options in Gateway Slash Command\nDESCRIPTION: Demonstrates how to make options not required by setting default values. Includes an integer option with default value 10 and a nullable User option with default None.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def options_cmd(\n    ctx: arc.GatewayContext,\n    number: arc.Option[int, arc.IntParams(\"A number\")] = 10,\n    user: arc.Option[hikari.User | None, arc.UserParams(\"A user\")] = None,\n) -> None:\n    await ctx.respond(f\"You provided {number} and {user.mention if user else None}!\")\n```\n\n----------------------------------------\n\nTITLE: Registering a Post-execution Hook with a Gateway Command\nDESCRIPTION: Example showing how to attach a post-execution hook to a Gateway slash command using the @arc.with_post_hook decorator. This hook runs after command execution.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.with_post_hook(my_hook)\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating Subgroups for Permissions\nDESCRIPTION: Defines subgroups for user and role permissions management using SlashGroup.include_subgroup method.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/command_groups.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nuser = permissions.include_subgroup(\"user\", \"Get or edit permissions for a user\")\nrole = permissions.include_subgroup(\"role\", \"Get or edit permissions for a role\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Pre-execution Hook in Python\nDESCRIPTION: A simple example of defining a pre-execution hook function that prints a message before a command runs. This demonstrates the basic structure of hooks in arc, which take a Context parameter and return either None or a HookResult.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nimport arc\n\n# Snip\n\ndef my_hook(ctx: arc.Context[Any]) -> None:\n    print(f\"Command {ctx.command.name} is about to run!\")\n```\n\n----------------------------------------\n\nTITLE: Adding Hooks to a Gateway Plugin\nDESCRIPTION: Example showing how to add a pre-execution hook to a Gateway plugin. This hook will run before all commands in the plugin are executed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.GatewayPlugin(\"name\")\nplugin.add_hook(my_hook)\n```\n\n----------------------------------------\n\nTITLE: Checking Installation and Invocation Context in Gateway Command\nDESCRIPTION: A slash command that determines its installation and invocation contexts at runtime, responding differently based on where it was invoked and how it was installed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@arc.slash_command(\n    \"install_details\",\n    \"Check command installation details\",\n    integration_types=[\n        hikari.ApplicationIntegrationType.USER_INSTALL,\n        hikari.ApplicationIntegrationType.GUILD_INSTALL,\n    ],\n)\nasync def my_command(ctx: arc.GatewayContext) -> None:\n    # Figure out where the command was invoked\n    match ctx.invocation_context:\n        case hikari.ApplicationContextType.GUILD:\n            await ctx.respond(\"Hello from a guild!\")\n        case hikari.ApplicationContextType.BOT_DM:\n            await ctx.respond(\"Hello from a DM!\")\n        case hikari.ApplicationContextType.PRIVATE_CHANNEL:\n            await ctx.respond(\"Hello from a group DM!\")\n\n    # Figure out how the command was installed\n    await ctx.respond(\n        f\"User who installed me: {ctx.authorizing_user_id or 'Not installed by user'}\\n\"\n        f\"Guild who installed me: {ctx.authorizing_guild_id or 'Not installed in guild'}\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Hook Execution Order with REST Example\nDESCRIPTION: Example demonstrating hook execution order in a REST application. Hooks are executed from client level down to command level, in the order they were added.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclient = arc.RESTClient(...)\nclient.add_hook(hook_a)\n\nplugin = arc.RESTPlugin(\"name\")\nplugin.add_hook(hook_b)\nplugin.add_hook(hook_c)\n\ngroup = plugin.include_slash_group(...)\ngroup.add_hook(hook_d)\n\n@group.include\n@arc.with_hook(hook_f)\n@arc.with_hook(hook_e)\n@arc.slash_subcommand(\"name\", \"description\")\nasync def my_command(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Choices in Gateway Slash Command\nDESCRIPTION: Shows how to add predefined choices to an option using the 'choices' parameter. The command allows users to select from a list of integers (1, 2, or 3).\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"choices\", \"I can't choose!\")\nasync def choices_command(\n    ctx: arc.GatewayContext,\n    # Set the 'choices' parameter to all the valid values your option can be\n    choose_me: arc.Option[int, arc.IntParams(\"Choose me!\", choices=[1, 2, 3])]\n) -> None:\n    await ctx.respond(f\"You wrote: `{choose_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Adding Hooks to a REST Plugin\nDESCRIPTION: Example showing how to add a pre-execution hook to a REST plugin. This hook will run before all commands in the plugin are executed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.RESTPlugin(\"name\")\nplugin.add_hook(my_hook)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handler for REST Command in Python\nDESCRIPTION: This snippet illustrates how to create a local error handler for a REST command using the @set_error_handler decorator. It demonstrates error raising in the command and handling in the error handler.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/error_handling.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def error_command_func(ctx: arc.RESTContext) -> None:\n    raise RuntimeError(\"I'm an error!\")\n\n# 'error_command_func' in this case is the command function name\n@error_command_func.set_error_handler\nasync def error_handler(ctx: arc.RESTContext, exc: Exception) -> None:\n    if isinstance(exc, RuntimeError):\n        print(f\"Handled error: {exc}\")\n        return\n    raise exc\n```\n\n----------------------------------------\n\nTITLE: Using Autocomplete in Gateway Slash Command\nDESCRIPTION: Shows how to add autocomplete functionality to a string option using the 'autocomplete_with' parameter, which references the previously defined autocomplete callback function.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"autocomplete\", \"Autocomplete options!\")\nasync def autocomplete_command(\n    ctx: arc.GatewayContext,\n    # Set the 'autocomplete_with' parameter to the function that will be used to autocomplete the option\n    complete_me: arc.Option[str, arc.StrParams(\"I'll complete you!\", autocomplete_with=provide_opts)]\n) -> None:\n    await ctx.respond(f\"You wrote: `{complete_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Implementing REST Context Subcommands\nDESCRIPTION: Implements permission management subcommands using REST context, including get and edit operations for both users and roles.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/command_groups.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@user.include\n@arc.slash_subcommand(\"get\", \"Get permissions for a user\")\nasync def perms_user_get(ctx: arc.RESTContext) -> None:\n    ...\n\n@user.include\n@arc.slash_subcommand(\"edit\", \"Edit permissions for a user\")\nasync def perms_user_edit(ctx: arc.RESTContext) -> None:\n    ...\n\n@role.include\n@arc.slash_subcommand(\"get\", \"Get permissions for a role\")\nasync def perms_role_get(ctx: arc.RESTContext) -> None:\n    ...\n\n@role.include\n@arc.slash_subcommand(\"edit\", \"Edit permissions for a role\")\nasync def perms_role_edit(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Setting Error Handler for REST Client in Python\nDESCRIPTION: This snippet demonstrates how to set an error handler for a REST client using the set_error_handler method within a loader function.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/error_handling.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@arc.loader\nasync def load(client: arc.RESTClient) -> None:\n    client.set_error_handler(some_func)\n```\n\n----------------------------------------\n\nTITLE: Registering a Post-execution Hook with a REST Command\nDESCRIPTION: Example showing how to attach a post-execution hook to a REST slash command using the @arc.with_post_hook decorator. This hook runs after command execution.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.with_post_hook(my_hook)\n@arc.slash_command(\"name\", \"description\")\nasync def foo(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Autocomplete Callback for REST\nDESCRIPTION: Creates an autocomplete callback function for a REST client that suggests different options based on the length of the user's input. Returns a list of string choices.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def provide_opts(data: arc.AutocompleteData[arc.RESTClient, str]) -> list[str]:\n    if data.focused_value and len(data.focused_value) > 20:\n        return [\"That\", \"is\", \"so\", \"long!\"]\n    return [\"Short\", \"is\", \"better!\"]\n```\n\n----------------------------------------\n\nTITLE: Using Choices in REST Slash Command\nDESCRIPTION: Shows how to add predefined choices to an option in a REST slash command. The command allows users to select from a list of integers (1, 2, or 3).\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"choices\", \"I can't choose!\")\nasync def choices_command(\n    ctx: arc.RESTContext,\n    # Set the 'choices' parameter to all the valid values your option can be\n    choose_me: arc.Option[int, arc.IntParams(\"Choose me!\", choices=[1, 2, 3])]\n) -> None:\n    await ctx.respond(f\"You wrote: `{choose_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Using Annotated for Metadata in Type Hints\nDESCRIPTION: Example demonstrating how to use the Annotated type from the typing module to add metadata to type hints without changing the actual type checking behavior.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\ndef say_hello(name: Annotated[str, \"this is just metadata\"]) -> str:\n    return f\"Hello {name}\"\n```\n\n----------------------------------------\n\nTITLE: Getting Dependencies Without Injection\nDESCRIPTION: Demonstrates how to directly access dependencies without using injection, using the Client.get_type_dependency method.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef compare_counter(value: int) -> None:\n    db = client.get_type_dependency(MyDatabase)\n\n    if value > db.value:\n        print(\"Value is bigger!\")\n    else:\n        print(\"Counter is bigger or equal!\")\n```\n\n----------------------------------------\n\nTITLE: Defining Autocomplete Callback for Gateway\nDESCRIPTION: Creates an autocomplete callback function for a gateway client that suggests different options based on the length of the user's input. Returns a list of string choices.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nasync def provide_opts(data: arc.AutocompleteData[arc.GatewayClient, str]) -> list[str]:\n    if data.focused_value and len(data.focused_value) > 20:\n        return [\"That\", \"is\", \"so\", \"long!\"]\n    return [\"Short\", \"is\", \"better!\"]\n```\n\n----------------------------------------\n\nTITLE: Migrating Startup/Shutdown Hooks in Hikari-arc v2.0\nDESCRIPTION: Example showing how to migrate from deprecated set_startup_hook and set_shutdown_hook methods to the new add_startup_hook and add_shutdown_hook methods.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/changelog.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Before 2.0\n\n@client.set_startup_hook\nasync def startup_hook(client: arc.GatewayClient) -> None:\n    print(\"Client started up!\")\n\n@client.set_shutdown_hook\nasync def shutdown_hook(client: arc.GatewayClient) -> None:\n    print(\"Client shut down!\")\n\n# After 2.0\n\n@client.add_startup_hook\nasync def startup_hook(client: arc.GatewayClient) -> None:\n    print(\"Client started up!\")\n\n@client.add_shutdown_hook\nasync def shutdown_hook(client: arc.GatewayClient) -> None:\n    print(\"Client shut down!\")\n```\n\n----------------------------------------\n\nTITLE: Creating Another Gateway Extension with Plugin in Hikari-arc\nDESCRIPTION: This snippet demonstrates another example of a Gateway extension file with a plugin. It follows the same pattern with loader and unloader functions to manage the extension's lifecycle.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport arc\n\nplugin = arc.GatewayPlugin(\"bar\")\n\n@plugin.include\n@arc.slash_command(\"bar\", \"Bar command\")\nasync def bar_cmd(\n    ctx: arc.GatewayContext,\n) -> None:\n    await ctx.respond(f\"Bar!\")\n\n@arc.loader\ndef loader(client: arc.GatewayClient) -> None:\n    client.add_plugin(plugin)\n\n\n@arc.unloader\ndef unloader(client: arc.GatewayClient) -> None:\n    client.remove_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Using Autocomplete in REST Slash Command\nDESCRIPTION: Shows how to add autocomplete functionality to a string option in a REST slash command using the 'autocomplete_with' parameter, which references a callback function.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"autocomplete\", \"Autocomplete options!\")\nasync def autocomplete_command(\n    ctx: arc.RESTContext,\n    # Set the 'autocomplete_with' parameter to the function that will be used to autocomplete the option\n    complete_me: arc.Option[str, arc.StrParams(\"I'll complete you!\", autocomplete_with=provide_opts)]\n) -> None:\n    await ctx.respond(f\"You wrote: `{complete_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Configuring User-Only Installation for Gateway Command\nDESCRIPTION: Creates a slash command that can only be installed to users, not to guilds, using the GatewayClient.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Only allow this command to be installed to users\n@arc.slash_command(\n    \"my_command\",\n    \"My command description\",\n    integration_types=[hikari.ApplicationIntegrationType.USER_INSTALL],\n)\nasync def my_command(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating Guild-Only Command with User Installation in Gateway\nDESCRIPTION: Creates a slash command that can only be invoked in a guild but must be installed by a user, using the GatewayClient.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@arc.slash_command(\n    \"my_command\",\n    \"My command description\",\n    invocation_contexts=[hikari.ApplicationContextType.GUILD],\n    integration_types=[hikari.ApplicationIntegrationType.USER_INSTALL]\n)\nasync def my_command(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: REST Startup Hook Implementation\nDESCRIPTION: Shows how to add a startup hook for REST clients to execute code after the client has fully initialized.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/startup_shutdown.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@client.add_startup_hook\nasync def startup_hook(client: arc.RESTClient) -> None:\n    print(\"Client started up!\")\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies in Gateway Commands\nDESCRIPTION: Demonstrates how to inject the MyDatabase dependency into a slash command using Gateway client. The command increments a counter stored in the database.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/dependency_injection.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"increment\", \"Increment a counter!\")\n# We inject a dependency of type 'MyDatabase' here.\nasync def increment(\n    ctx: arc.GatewayContext, db: MyDatabase = arc.inject()\n) -> None:\n    db.value += 1\n    await ctx.respond(f\"Counter is at: `{db.value}`\")\n```\n\n----------------------------------------\n\nTITLE: Configuring User-Only Installation for REST Command\nDESCRIPTION: Creates a slash command that can only be installed to users, not to guilds, using the RESTClient.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Only allow this command to be installed to users\n@arc.slash_command(\n    \"my_command\",\n    \"My command description\",\n    integration_types=[hikari.ApplicationIntegrationType.USER_INSTALL]\n)\nasync def my_command(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Gateway Shutdown Hook Implementation\nDESCRIPTION: Example of implementing a shutdown hook for Gateway clients to handle cleanup operations during bot shutdown.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/startup_shutdown.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@client.add_shutdown_hook\nasync def shutdown_hook(client: arc.GatewayClient) -> None:\n    print(\"Client shut down!\")\n```\n\n----------------------------------------\n\nTITLE: Simple Types Declaration\nDESCRIPTION: Shows function parameter typing with various basic Python types including str, int, float, bool, and bytes.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):\n    return item_a, item_b, item_c, item_d, item_d, item_e\n```\n\n----------------------------------------\n\nTITLE: Startup Event Listener Implementation\nDESCRIPTION: Shows how to listen for the arc.StartedEvent to handle startup operations via event listeners instead of hooks.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/startup_shutdown.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@client.listen()\nasync def on_startup(event: arc.StartedEvent) -> None:\n    print(\"Client started up!\")\n```\n\n----------------------------------------\n\nTITLE: Setting Default Permissions for Gateway Plugin Commands\nDESCRIPTION: This snippet shows how to set default permissions for all commands in a Gateway plugin. In this example, all commands will require the MANAGE_GUILD permission by default.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.GatewayPlugin(\"plugin name\", default_permissions=hikari.Permissions.MANAGE_GUILD)\n```\n\n----------------------------------------\n\nTITLE: Setting Default Permissions for REST Plugin Commands\nDESCRIPTION: This snippet demonstrates how to set default permissions for all commands in a REST plugin. Similar to the Gateway example, all commands will require the MANAGE_GUILD permission by default.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.RESTPlugin(\"plugin name\", default_permissions=hikari.Permissions.MANAGE_GUILD)\n```\n\n----------------------------------------\n\nTITLE: Using Named Choices in REST Slash Command\nDESCRIPTION: Demonstrates how to use a mapping for named choices in a REST slash command. Users see the names while the command receives the corresponding values.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/options.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n@arc.slash_command(\"choices\", \"I can't choose!\")\nasync def choices_command(\n    ctx: arc.RESTContext,\n    # Set the 'choices' parameter to all the valid values your option can be\n    choose_me: arc.Option[int, arc.IntParams(\"Choose me!\", choices={\"one\": 1, \"two\": 2, \"three\": 3})]\n) -> None:\n    await ctx.respond(f\"You wrote: `{choose_me}`\")\n```\n\n----------------------------------------\n\nTITLE: Loading a Single Extension in REST Bot\nDESCRIPTION: This snippet demonstrates how to load a single extension in a REST bot. Similar to the Gateway example, the load_extension method is used to load a specific extension module.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\nbot = hikari.RESTBot(\"TOKEN\")\nclient = arc.RESTClient(bot)\n\n# Will run foo.loader()\nclient.load_extension(\"extensions.foo\")\n\n\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Hook Execution Order with Gateway Example\nDESCRIPTION: Example demonstrating hook execution order in a Gateway application. Hooks are executed from client level down to command level, in the order they were added.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclient = arc.GatewayClient(...)\nclient.add_hook(hook_a)\n\nplugin = arc.GatewayPlugin(\"name\")\nplugin.add_hook(hook_b)\nplugin.add_hook(hook_c)\n\ngroup = plugin.include_slash_group(...)\ngroup.add_hook(hook_d)\n\n@group.include\n@arc.with_hook(hook_f)\n@arc.with_hook(hook_e)\n@arc.slash_subcommand(\"name\", \"description\")\nasync def my_command(ctx: arc.GatewayContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple Extensions from Directory in REST Bot\nDESCRIPTION: This snippet demonstrates how to load all extensions from a specific directory in a REST bot. The load_extensions_from method automatically finds and loads all valid extension modules.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport hikari\nimport arc\n\nbot = hikari.RESTBot(\"TOKEN\")\nclient = arc.RESTClient(bot)\n\n# Will run foo.loader() and bar.loader()\nclient.load_extensions_from(\"extensions\")\n\n\nbot.run()\n```\n\n----------------------------------------\n\nTITLE: Implementing REST Interval Loop with Class\nDESCRIPTION: Example of creating and starting a recurring task using the IntervalLoop class with a REST client.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/loops.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def loopy_loop(value: int) -> None:\n    print(value)\n\n# Create a loop by passing the function in\nloop = arc.utils.IntervalLoop(loopy_loop, seconds=10.0)\n\n# Somewhere else:\n\n@client.add_startup_hook\nasync def startup(client: arc.RESTClient) -> None:\n    # Start the loop by passing all the parameters it needs\n    loop.start(value=10)\n```\n\n----------------------------------------\n\nTITLE: Creating Guild-Only Command with User Installation in REST\nDESCRIPTION: Creates a slash command that can only be invoked in a guild but must be installed by a user, using the RESTClient.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@arc.slash_command(\n    \"my_command\",\n    \"My command description\",\n    invocation_contexts=[hikari.ApplicationContextType.GUILD],\n    integration_types=[hikari.ApplicationIntegrationType.USER_INSTALL]\n)\nasync def my_command(ctx: arc.RESTContext) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Channel Rate Limiter with REST Command\nDESCRIPTION: Example of using a channel limiter to restrict a REST command to 2 uses every 10 seconds per channel. Includes error handling for the UnderCooldownError exception.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n# Limit the command to 2 uses every 10 seconds per channel.\n@arc.with_hook(arc.channel_limiter(10.0, 2))\n@arc.slash_command(\"ping\", \"Pong!\")\nasync def ping(ctx: arc.RESTContext) -> None:\n    await ctx.respond(\"Pong!\")\n\n\n@ping.set_error_handler\nasync def ping_error_handler(\n    ctx: arc.RESTContext, error: Exception\n) -> None:\n    if isinstance(error, arc.UnderCooldownError):\n        await ctx.respond(\n            \"Command is on cooldown!\"\n            f\"\\nTry again in `{error.retry_after}` seconds.\"\n        )\n    else:\n        raise error\n```\n\n----------------------------------------\n\nTITLE: Function With Type Hints\nDESCRIPTION: Shows the same name formatting function with added type hints for better IDE support and code clarity.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef print_full_name(first_name: str, last_name: str):\n    full_name = first_name.title() + \" \" + last_name.title()\n    print(full_name)\n\n\nprint_full_name(\"john\", \"doe\")\n```\n\n----------------------------------------\n\nTITLE: Creating Another REST Extension with Plugin in Hikari-arc\nDESCRIPTION: This snippet demonstrates another example of a REST extension file with a plugin. It follows the same loader/unloader pattern for managing the plugin's lifecycle in a REST-based bot.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport arc\n\nplugin = arc.RESTPlugin(\"bar\")\n\n@plugin.include\n@arc.slash_command(\"bar\", \"Bar command\")\nasync def bar_cmd(\n    ctx: arc.RESTContext,\n) -> None:\n    await ctx.respond(f\"Bar!\")\n\n@arc.loader\ndef loader(client: arc.RESTClient) -> None:\n    client.add_plugin(plugin)\n\n\n@arc.unloader\ndef unloader(client: arc.RESTClient) -> None:\n    client.remove_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Basic Function Without Type Hints\nDESCRIPTION: Demonstrates a simple function that concatenates and formats names without type hints, showing the limitations of IDE support.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef print_full_name(first_name, last_name):\n    full_name = first_name.title() + \" \" + last_name.title()\n    print(full_name)\n\n\nprint_full_name(\"john\", \"doe\")\n```\n\n----------------------------------------\n\nTITLE: Gateway Startup Hook Implementation\nDESCRIPTION: Demonstrates how to add a startup hook for Gateway clients that executes after command syncing and bot initialization is complete.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/startup_shutdown.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@client.add_startup_hook\nasync def startup_hook(client: arc.GatewayClient) -> None:\n    print(\"Client started up!\")\n```\n\n----------------------------------------\n\nTITLE: Generic List Type Hint\nDESCRIPTION: Shows how to use type hints with generic list types that contain other types.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef process_items(items: list[str]) -> None:\n    for item in items:\n        print(item)\n```\n\n----------------------------------------\n\nTITLE: Checking Installation and Invocation Context in REST Command\nDESCRIPTION: A slash command that determines its installation and invocation contexts at runtime, responding differently based on where it was invoked and how it was installed.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/installation_contexts.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@arc.slash_command(\n    \"install_details\",\n    \"Check command installation details\",\n    integration_types=[\n        hikari.ApplicationIntegrationType.USER_INSTALL,\n        hikari.ApplicationIntegrationType.GUILD_INSTALL,\n    ],\n)\nasync def my_command(ctx: arc.RESTContext) -> None:\n    # Figure out where the command was invoked\n    match ctx.invocation_context:\n        case hikari.ApplicationContextType.GUILD:\n            await ctx.respond(\"Hello from a guild!\")\n        case hikari.ApplicationContextType.BOT_DM:\n            await ctx.respond(\"Hello from a DM!\")\n        case hikari.ApplicationContextType.PRIVATE_CHANNEL:\n            await ctx.respond(\"Hello from a group DM!\")\n\n    # Figure out how the command was installed\n    await ctx.respond(\n        f\"User who installed me: {ctx.authorizing_user_id or 'Not installed by user'}\\n\"\n        f\"Guild who installed me: {ctx.authorizing_guild_id or 'Not installed in guild'}\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Tuple and Set Type Hints\nDESCRIPTION: Demonstrates type hinting for tuple and set collections with various internal types.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef process_items(items_t: tuple[int, int, str], items_s: set[bytes]) -> None:\n    return items_t, items_s\n```\n\n----------------------------------------\n\nTITLE: Type Checking Example\nDESCRIPTION: Demonstrates type checking by showing a function with incorrect type usage that would trigger IDE warnings.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_name_with_age(name: str, age: int):\n    name_with_age = name + \" is this old: \" + age\n    print(name_with_age)\n```\n\n----------------------------------------\n\nTITLE: Dictionary Type Hints\nDESCRIPTION: Shows how to define type hints for dictionaries with specific key and value types.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef process_items(prices: dict[str, float]) -> None:\n    for item_name, item_price in prices.items():\n        print(item_name)\n        print(item_price)\n```\n\n----------------------------------------\n\nTITLE: Creating Ephemeral Response in Discord Interaction\nDESCRIPTION: Demonstrates how to create an ephemeral (private) message response in a Discord interaction using hikari flags\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/interactions.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nawait context.respond(\"I'm secret!\", flags=hikari.MessageFlag.EPHEMERAL)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Complex Type Hints in Python\nDESCRIPTION: Example showing a function that uses verbose complex type annotations (list of dictionaries containing sets of integers) as both input and output types.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef do_stuff(data: list[dict[str, set[int]]]) -> list[dict[str, set[int]]]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Channel Rate Limiter with Gateway Command\nDESCRIPTION: Example of using a channel limiter to restrict a Gateway command to 2 uses every 10 seconds per channel. Includes error handling for the UnderCooldownError exception.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/hooks.md#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@client.include\n# Limit the command to 2 uses every 10 seconds per channel.\n@arc.with_hook(arc.channel_limiter(10.0, 2))\n@arc.slash_command(\"ping\", \"Pong!\")\nasync def ping(ctx: arc.GatewayContext) -> None:\n    await ctx.respond(\"Pong!\")\n\n\n@ping.set_error_handler\nasync def ping_error_handler(\n    ctx: arc.GatewayContext, error: Exception\n) -> None:\n    if isinstance(error, arc.UnderCooldownError):\n        await ctx.respond(\n            \"Command is on cooldown!\"\n            f\"\\nTry again in `{error.retry_after}` seconds.\"\n        )\n    else:\n        raise error\n```\n\n----------------------------------------\n\nTITLE: Migrating DM Settings in Hikari-arc v2.0\nDESCRIPTION: Example showing how to migrate from the deprecated is_dm_enabled setting to the new invocation_contexts approach for controlling DM access.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/changelog.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Before 2.0\nclient = arc.GatewayClient(..., is_dm_enabled=False)\n\n# After 2.0\n\n# Omit hikari.ApplicationContextType.BOT_DM to disable DMs\n# You may also want to remove PRIVATE_CHANNEL if you don't want to support group DMs\nclient = arc.GatewayClient(\n    ...,\n    invocation_contexts=[\n        hikari.ApplicationContextType.GUILD,\n        hikari.ApplicationContextType.PRIVATE_CHANNEL\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Type Aliases in Python 3.12+\nDESCRIPTION: Example showing the dedicated syntax for declaring type aliases in Python 3.12+ using the 'type' keyword to simplify complex type annotations.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntype DataT = list[dict[str, set[int]]]\n\ndef do_stuff(data: DataT) -> DataT:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Gateway Autodefer in Discord Commands\nDESCRIPTION: Shows implementation of a time-consuming Discord slash command with gateway autodefer functionality\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/interactions.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport arc\nimport asyncio\n\n# ... Snip\n\n@client.include\n@arc.slash_command(\"name\", \"description\")\nasync def takes_time(context: arc.GatewayContext) -> None:\n    await asyncio.sleep(10) # Simulate something taking a long time\n    await context.respond(\"Finished!\")\n```\n\n----------------------------------------\n\nTITLE: Migrating Channel Access in Hikari-arc v2.0\nDESCRIPTION: Example showing how to migrate from the deprecated get_channel method to the new channel property in Context and AutocompleteData classes.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/changelog.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Before 2.0\n\n@arc.slash_command(\"test\", \"Test command\")\nasync def test(ctx: arc.GatewayContext) -> None:\n    channel = ctx.get_channel()\n\n# After 2.0\n\n@arc.slash_command(\"test\", \"Test command\")\nasync def test(ctx: arc.GatewayContext) -> None:\n    channel = ctx.channel\n```\n\n----------------------------------------\n\nTITLE: Creating a REST Plugin with Commands in Hikari-arc\nDESCRIPTION: This snippet shows how to create a REST plugin, add slash commands to it, and add the plugin to the client. Similar to Gateway plugins, REST plugins group related commands together for REST-based bots.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/plugins_extensions.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nplugin = arc.RESTPlugin(\"plugin name\")\n\n@plugin.include\n@arc.slash_command(\"name\", \"description\")\nasync def plugin_cmd(ctx: arc.RESTContext) -> None:\n    ...\n\n@plugin.include\n@arc.slash_command(\"other-name\", \"description\")\nasync def other_plugin_cmd(ctx: arc.RESTContext) -> None:\n    ...\n\nclient.add_plugin(plugin)\n```\n\n----------------------------------------\n\nTITLE: Verifying Hikari-Arc Installation\nDESCRIPTION: Commands to check if hikari-arc has been successfully installed. It includes a note for Windows users.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m arc\n# On Windows you may need to run:\npy -m arc\n```\n\n----------------------------------------\n\nTITLE: REST Shutdown Hook Implementation\nDESCRIPTION: Demonstrates adding a shutdown hook for REST clients to perform cleanup tasks when the bot is shutting down.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/startup_shutdown.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@client.add_shutdown_hook\nasync def shutdown_hook(client: arc.RESTClient) -> None:\n    print(\"Client shut down!\")\n```\n\n----------------------------------------\n\nTITLE: Installing Hikari-Arc via pip\nDESCRIPTION: Command to install the Hikari-Arc library using pip package manager.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/getting_started.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install hikari-arc\n```\n\n----------------------------------------\n\nTITLE: Running Hikari-Arc Examples\nDESCRIPTION: Command to execute example bot scripts after configuring the token in the hikari.GatewayBot or hikari.RESTBot constructor.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npython example_name.py\n```\n\n----------------------------------------\n\nTITLE: Union Type Hints\nDESCRIPTION: Demonstrates how to specify multiple possible types using union type hints.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef process_item(item: int | str) -> None:\n    print(item)\n```\n\n----------------------------------------\n\nTITLE: Verifying Hikari-Arc Installation - macOS/Linux\nDESCRIPTION: Command to verify successful installation of Hikari-Arc on macOS and Linux systems.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/getting_started.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m arc\n```\n\n----------------------------------------\n\nTITLE: Loops API Reference in Markdown\nDESCRIPTION: Markdown documentation structure for the loops module that contains implementation details for executing repeated functions with intervals in the arc library.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/api_reference/utils/loops.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Loops\ndescription: Loops API reference\n---\n\n# Loops\n\nThis module contains the loop implementations in `arc`. Loops can be used to call a function repeatedly with a given interval.\n\n::: arc.utils.loops\n```\n\n----------------------------------------\n\nTITLE: Installing Cron Dependencies for Hikari-Arc\nDESCRIPTION: Command to install hikari-arc with cron functionality support using pip.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/loops.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install hikari-arc[cron]\n```\n\n----------------------------------------\n\nTITLE: Running Nox for Code Quality Checks in Hikari-Arc using Shell\nDESCRIPTION: This command runs Nox to perform various code quality checks, including typing errors, antipatterns, bad practices, formatting, and tests for the Hikari-Arc project.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/CONTRIBUTING.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nuv run nox\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with UV for Hikari-Arc in Shell\nDESCRIPTION: This command uses UV to install all required dependencies, including extras and development dependencies, for the Hikari-Arc project in a virtual environment.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/CONTRIBUTING.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ uv sync --all-extras --dev\n```\n\n----------------------------------------\n\nTITLE: Verifying Hikari-Arc Installation - Windows\nDESCRIPTION: Command to verify successful installation of Hikari-Arc on Windows systems.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/getting_started.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npy -m arc\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Base Class for Limiters in Python\nDESCRIPTION: This code snippet defines an abstract base class 'Limiter' for implementing rate limiting functionality. It includes abstract methods for acquiring and releasing permits, as well as a context manager for automatic permit management.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/api_reference/abc/limiter.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Limiter(abc.ABC):\n    \"\"\"Abstract base class for limiters.\n\n    This class defines the interface for limiters.\n    \"\"\"\n\n    @abc.abstractmethod\n    async def acquire(self) -> None:\n        \"\"\"Acquire a permit from the limiter.\n\n        This method should be implemented by subclasses to define how permits are acquired.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    async def release(self) -> None:\n        \"\"\"Release a permit back to the limiter.\n\n        This method should be implemented by subclasses to define how permits are released.\n        \"\"\"\n        ...\n\n    async def __aenter__(self) -> None:\n        \"\"\"Acquire a permit when entering the context manager.\"\"\"\n        await self.acquire()\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        \"\"\"Release the permit when exiting the context manager.\"\"\"\n        await self.release()\n```\n\n----------------------------------------\n\nTITLE: Installing Hikari-Arc via pip\nDESCRIPTION: Command to install the hikari-arc package using pip. It installs the latest version of the package.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install -U hikari-arc\n```\n\n----------------------------------------\n\nTITLE: Function Return Type Annotation\nDESCRIPTION: Demonstrates how to annotate function return types using the -> notation.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n\n----------------------------------------\n\nTITLE: Optional Type with None\nDESCRIPTION: Shows how to declare optional types that can be None using union syntax.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/guides/typing.md#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef say_hi(name: str | None = None) -> None:\n    if name is not None:\n        print(f\"Hey {name}!\")\n    else:\n        print(\"Hello World\")\n```\n\n----------------------------------------\n\nTITLE: Custom CSS for Documentation Page\nDESCRIPTION: CSS styling to hide the default h1 heading and content button in the Material for MkDocs theme.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/index.md#2025-04-16_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n<style>\n  .md-typeset h1,\n  .md-content__button {\n    display: none;\n  }\n</style>\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Documentation Locally with Nox\nDESCRIPTION: Command to run a nox session that builds and serves the documentation locally. After execution, users can access the documentation by opening the URL provided in the terminal output.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnox -s servedocs\n```\n\n----------------------------------------\n\nTITLE: Markdown Reference Directives for Context API Documentation\nDESCRIPTION: Markdown directives that import and display documentation for the context module in Hikari-Arc. The file includes references to the base context API and autocomplete functionality using the ::: directive syntax.\nSOURCE: https://github.com/hypergonial/hikari-arc/blob/main/docs/api_reference/context.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: arc.context.base\n::: arc.context.autocomplete\n```"
  }
]