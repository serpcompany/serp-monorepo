[
  {
    "owner": "yagestudios",
    "repo": "minecs",
    "content": "TITLE: Dynamic Entity and Component Management in minECS - TypeScript\nDESCRIPTION: Provides examples for adding and removing entities and components at runtime, ensuring complete cleanup of components when entities are deleted. Demonstrates API usage for dynamic world modifications. Dependencies: minECS, createWorld, addEntity, addComponent, removeComponent, removeEntity. Inputs: world, entity, component references. Outputs: updated world state post entity/component mutation.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst world = createWorld();\nconst entity = addEntity(world);\naddComponent(world, SomeComponent, entity);\nremoveComponent(world, SomeComponent, entity);\nremoveEntity(world, entity); // Cleans up all components associated with the entity\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Worlds in minECS - TypeScript\nDESCRIPTION: Illustrates how to serialize world state into JSON, binary, and base64 formats using serializeWorld, and how to restore via deserializeWorld. Ensures persistence and transferability of complete ECS state for saving/loading. Dependencies: minECS, SerialMode, world instance. Inputs: current world state. Outputs: serialized representations and newly constructed world instances.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst json = serializeWorld(SerialMode.JSON, world);\nconst buffer = serializeWorld(SerialMode.BINARY, world);\nconst base64 = serializeWorld(SerialMode.BASE64, world);\n\nconst newWorldFromJSON = deserializeWorld(json);\nconst newWorldFromBinary = deserializeWorld(buffer);\nconst newWorldFromBase64 = deserializeWorld(base64);\n```\n\n----------------------------------------\n\nTITLE: Creating Movement System with @System Decorator in minECS - TypeScript\nDESCRIPTION: Defines a system that operates on Position and Velocity components, updating the position based on velocity using the @System decorator. Shows dependency injection for required components, with per-entity execution pattern. Dependencies: minECS, SystemImpl, World type, Position, Velocity components. Inputs: world instance, entity id. Outputs: mutates Position component values for affected entities.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@System(Position, Velocity)\nclass MovementSystem extends SystemImpl {\n  run = (world: World, entity: number) => {\n    const position = world(Position, entity);\n    const velocity = world(Velocity, entity);\n\n    position.x += velocity.x;\n    position.y += velocity.y;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Worlds and Entities in minECS - TypeScript\nDESCRIPTION: Shows basic world lifecycle: creation, entity addition, component assignment, state mutation by systems, and state querying. Demonstrates stepWorld simulation updating entity state. Dependencies: minECS, createWorld, addEntity, addComponent, stepWorld functions, Position/Velocity components. Inputs: world instance, entity id, component data. Outputs: current state of Position component via console log.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst world = createWorld();\nconst entity = addEntity(world);\n\naddComponent(world, Position, entity);\naddComponent(world, Velocity, entity, {\n  x: 30,\n  y: 30,\n});\n\nconsole.log({ ...world(Position, entity) }); // { x: 0, y: 0, type: \"Position\" }\n\nstepWorld(world);\n\nconsole.log({ ...world(Position, entity) }); //  { x: 30, y: 30, type: \"Position\" }\n```\n\n----------------------------------------\n\nTITLE: Modeling Advanced Nested Components and Nullable Types in minECS - TypeScript\nDESCRIPTION: Demonstrates how to define complex and nested component schemas with support for arrays, objects, strings, booleans, nested schemas, and nullable fields using minECS decorators. Useful for advanced ECS scenarios that require structured and optional state. Dependencies: minECS, Component and type/nullable/defaultValue decorators, existing Schema-based types. Inputs: component property definitions, types. Outputs: enhanced component definitions available for registration and use.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component()\nclass Complex extends Schema {\n  @type(Position)\n  position: Position;\n\n  @type(\"string\")\n  @defaultValue(\"hello\")\n  message: string;\n\n  @type([\"number\"])\n  numbers: number[];\n\n  @type(\"boolean\")\n  @defaultValue(true)\n  flag: boolean;\n\n  @type(\"object\")\n  obj: any;\n\n  @type(\"string\")\n  @nullable()\n  nullableString: string | null;\n}\n\n@Component()\nclass NestedComplex extends Schema {\n  @type(Complex)\n  complex: Complex;\n\n  @type([Complex])\n  complexes: Complex[];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Components with @Component Decorator in minECS - TypeScript\nDESCRIPTION: Demonstrates how to define serializable component schemas in minECS using the @Component decorator and Schema classes. Each property is typed and can receive default values via decorators. Components automatically register upon import. Dependencies: minECS library, TypeScript decorators, Schema base class. Inputs: component property definitions. Outputs: registered and typed ECS components.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Component()\nclass Position extends Schema {\n  @type(\"number\")\n  @defaultValue(0)\n  x: number;\n\n  @type(\"number\")\n  @defaultValue(0)\n  y: number;\n}\n\n@Component()\nclass Velocity extends Schema {\n  @type(\"number\")\n  @defaultValue(0)\n  x: number;\n\n  @type(\"number\")\n  @defaultValue(0)\n  y: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling System Execution Order with Depth in minECS - TypeScript\nDESCRIPTION: Demonstrates the use of the static depth property to set automatic execution order for systems. Lower depth values run first; negative depths disable auto-run, requiring manual invocation. Dependencies: minECS, SystemImpl, system decorators. Inputs: none (shown via class definition). Outputs: affects execution scheduling of system classes in engine loop.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n@System(...)\nclass SomeSystem extends SystemImpl {\n  static depth = 0;  // Lower numbers run first, executed automatically\n}\n```\n\n----------------------------------------\n\nTITLE: System Initialization and Cleanup in minECS - TypeScript\nDESCRIPTION: Shows how to implement system hooks for per-entity initialization (init) when entities match system criteria, and cleanup (cleanup) when components are removed or entities deleted. Used for resource allocation, effect setup, or state teardown. Dependencies: minECS, SystemImpl, System decorator. Inputs: world, entity id. Outputs: user-defined initialization or cleanup side effects.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n@System(...)\nclass SomeInitializationSystem extends SystemImpl {\n  init = (world: World, eid: number) => {\n    // Initialization code here\n  };\n}\n\n@System(...)\nclass SomeCleanupSystem extends SystemImpl {\n  cleanup = (world: World, eid: number) => {\n    // Cleanup code here\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Manual System Execution in minECS - TypeScript\nDESCRIPTION: Demonstrates defining a system that is only executed manually by assigning a negative depth, and details how to run such systems for all entities or a specific entity. Useful for logic requiring explicit control. Dependencies: minECS, SystemImpl, getSystem, run/runAll API, world and entity instances. Inputs: world, entity id. Outputs: manual invocation triggers system for targeted entities.\nSOURCE: https://github.com/yagestudios/minecs/blob/main/README.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n@System(...)\nclass ManualOnlySystem extends SystemImpl {\n  static depth = -1;  // This system will only run when manually triggered\n\n  run = (world: World, eid: number) => {\n    // Implementation details\n  };\n}\n\nconst world = createWorld();\nconst system = getSystem(world, ManualOnlySystem);\nsystem.runAll(world); // Runs the system manually for all entities\nsystem.run(world, entity); // Runs the system manually for a specific entity\n```"
  }
]