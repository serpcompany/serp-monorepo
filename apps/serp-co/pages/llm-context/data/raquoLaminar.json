[
  {
    "owner": "raquo",
    "repo": "laminar",
    "content": "TITLE: Implementing TodoMVC with Laminar in Scala.js\nDESCRIPTION: This code snippet demonstrates a full implementation of the TodoMVC application using Laminar, a Scala.js library for building reactive web applications. It includes model definitions, state management, and view components for rendering the todo list, input fields, and status bar.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/todomvc.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nobject TodoMvcApp {\n\n  // This implementation is very loosely based on Outwatch TodoMVC, for comparison see\n  // https://github.com/clovellytech/outwatch-examples/tree/master/todomvc/src/main/scala/todomvc\n\n\n  // --- Models ---\n\n  case class TodoItem(id: Int, text: String, completed: Boolean)\n\n\n  sealed abstract class Filter(val name: String, val passes: TodoItem => Boolean)\n\n  object ShowAll extends Filter(\"All\", _ => true)\n\n  object ShowActive extends Filter(\"Active\", !_.completed)\n\n  object ShowCompleted extends Filter(\"Completed\", _.completed)\n\n  val filters: List[Filter] = ShowAll :: ShowActive :: ShowCompleted :: Nil\n\n\n  sealed trait Command\n\n  case class Create(itemText: String) extends Command\n\n  case class UpdateText(itemId: Int, text: String) extends Command\n\n  case class UpdateCompleted(itemId: Int, completed: Boolean) extends Command\n\n  case class Delete(itemId: Int) extends Command\n\n  case object DeleteCompleted extends Command\n\n\n  // --- State ---\n\n  // Var-s are reactive state variables suitable for both local state and redux-like global stores.\n  // Laminar uses my library Airstream as its reactive layer https://github.com/raquo/Airstream\n\n  private val itemsVar = Var(List[TodoItem]())\n\n  private val filterVar = Var[Filter](ShowAll)\n\n  private var lastId = 1 // just for auto-incrementing IDs\n\n  private val commandObserver = Observer[Command] {\n    case Create(itemText) =>\n      lastId += 1\n      if (filterVar.now() == ShowCompleted)\n        filterVar.set(ShowAll)\n      itemsVar.update(_ :+ TodoItem(id = lastId, text = itemText, completed = false))\n    case UpdateText(itemId, text) =>\n      itemsVar.update(_.map(item => if (item.id == itemId) item.copy(text = text) else item))\n    case UpdateCompleted(itemId, completed) =>\n      itemsVar.update(_.map(item => if (item.id == itemId) item.copy(completed = completed) else item))\n    case Delete(itemId) =>\n      itemsVar.update(_.filterNot(_.id == itemId))\n    case DeleteCompleted =>\n      itemsVar.update(_.filterNot(_.completed))\n  }\n\n\n  // --- Views ---\n\n  lazy val node: HtmlElement = {\n    val todoItemsSignal = itemsVar\n      .signal\n      .combineWith(filterVar.signal)\n      .mapN(_ filter _.passes)  \n    div(\n      cls(\"todoapp\"),\n      div(\n        cls(\"header\"),\n        h1(\"todos\"),\n        renderNewTodoInput,\n      ),\n      div(\n        hideIfNoItems,\n        cls(\"main\"),\n        ul(\n          cls(\"todo-list\"),\n          children <-- todoItemsSignal.split(_.id)(renderTodoItem)\n        )\n      ),\n      renderStatusBar\n    )\n  }\n\n  private def renderNewTodoInput =\n    input(\n      cls(\"new-todo\"),\n      placeholder(\"What needs to be done?\"),\n      autoFocus(true),\n      onEnterPress\n        .mapToValue\n        .filter(_.nonEmpty)\n        .map(Create(_))\n        .setValue(\"\") --> commandObserver\n    )\n\n  // Render a single item. Note that the result is a single element: not a stream, not some virtual DOM representation.\n  private def renderTodoItem(itemId: Int, initialTodo: TodoItem, itemSignal: Signal[TodoItem]): HtmlElement = {\n    val isEditingVar = Var(false) // Example of local state\n    val updateTextObserver = commandObserver.contramap[UpdateText] { updateCommand =>\n      isEditingVar.set(false)\n      updateCommand\n    }\n    li(\n      cls <-- itemSignal.map(item => Map(\"completed\" -> item.completed)),\n      onDblClick.filter(_ => !isEditingVar.now()).mapTo(true) --> isEditingVar.writer,\n      children <-- isEditingVar.signal.map[List[HtmlElement]] {\n        case true =>\n          renderTextUpdateInput(itemId, itemSignal, updateTextObserver) :: Nil\n        case false =>\n          List(\n            renderCheckboxInput(itemId, itemSignal),\n            label(child.text <-- itemSignal.map(_.text)),\n            button(\n              cls(\"destroy\"),\n              onClick.mapTo(Delete(itemId)) --> commandObserver\n            )\n          )\n      }\n    )\n  }\n\n  // Note that we pass reactive variables: `itemSignal` for reading, `updateTextObserver` for writing\n  private def renderTextUpdateInput(\n    itemId: Int,\n    itemSignal: Signal[TodoItem],\n    updateTextObserver: Observer[UpdateText]\n  ) =\n    input(\n      cls(\"edit\"),\n      defaultValue <-- itemSignal.map(_.text),\n      onMountFocus,\n      onEnterPress.mapToValue.map(UpdateText(itemId, _)) --> updateTextObserver,\n      onBlur.mapToValue.map(UpdateText(itemId, _)) --> updateTextObserver\n    )\n\n  private def renderCheckboxInput(itemId: Int, itemSignal: Signal[TodoItem]) =\n    input(\n      cls(\"toggle\"),\n      typ(\"checkbox\"),\n      checked <-- itemSignal.map(_.completed),\n      onInput.mapToChecked.map { isChecked =>\n        UpdateCompleted(itemId, completed = isChecked)\n      } --> commandObserver\n    )\n\n  private def renderStatusBar =\n    footerTag(\n      hideIfNoItems,\n      cls(\"footer\"),\n      span(\n        cls(\"todo-count\"),\n        child.text <-- itemsVar.signal\n          .map(_.count(!_.completed))\n          .map(pluralize(_, \"item left\", \"items left\")),\n      ),\n      ul(\n        cls(\"filters\"),\n        filters.map(filter => li(renderFilterButton(filter)))\n      ),\n      child.maybe <-- itemsVar.signal.map { items =>\n        if (items.exists(ShowCompleted.passes)) Some(\n          button(\n            cls(\"clear-completed\"),\n            \"Clear completed\",\n            onClick.map(_ => DeleteCompleted) --> commandObserver\n          )\n        ) else None\n      }\n    )\n\n  private def renderFilterButton(filter: Filter) =\n    a(\n      cls(\"selected\") <-- filterVar.signal.map(_ == filter),\n      onClick.preventDefault.mapTo(filter) --> filterVar.writer,\n      filter.name\n    )\n\n  // Every little thing in Laminar can be abstracted away\n  private def hideIfNoItems: Mod[HtmlElement] =\n    display <-- itemsVar.signal.map { items =>\n      if (items.nonEmpty) \"\" else \"none\"\n    }\n\n\n  // --- Generic helpers ---\n\n  private def pluralize(num: Int, singular: String, plural: String): String =\n    s\"$num ${if (num == 1) singular else plural}\"\n\n  private val onEnterPress = onKeyPress.filter(_.keyCode == dom.KeyCode.Enter)\n}\n\n\n// Render app\n\nrender(containerNode, TodoMvcApp.node)\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled Text Input with Validation in Laminar (Scala.js)\nDESCRIPTION: This code demonstrates a controlled input pattern in Laminar where the input value is bound to a Var observable. It implements input validation to only allow numeric characters and provides functionality to reset the input to a predefined value. The form includes submission handling that displays the current zip code value.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/controlled-inputs.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval zipVar = Var(\"\")\n\nval app = div(\n  form(\n    onSubmit\n      .preventDefault\n      .mapTo(zipVar.now()) --> (zip => dom.window.alert(zip)),\n    p(\n      label(\"Zip code: \"),\n      input(\n        placeholder(\"12345\"),\n        maxLength(5), // HTML can help block some undesired input\n        controlled(\n          value <-- zipVar,\n          onInput.mapToValue.filter(_.forall(Character.isDigit)) --> zipVar\n        )\n      ),\n      button(\n        typ(\"button\"), // HTML buttons are of type \"submit\" by default\n        \"Set SF zip code\",\n        onClick.mapTo(\"94110\") --> zipVar\n      )\n    ),\n    p(\n      \"Your zip code: \",\n      child.text <-- zipVar\n    ),\n    // Using the form element's onSubmit in this example,\n    // but you could also respond on button click if you\n    // don't want a form element\n    button(typ(\"submit\"), \"Submit\")\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Implementing a basic component in Laminar with Scala\nDESCRIPTION: Demonstrates how to create a simple component that accepts a string caption and a color stream, showcasing how Laminar elements manage their own reactivity while remaining composable.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\n// Define your \"Component\"\ndef Caption(caption: String, colorStream: EventStream[String]): HtmlElement = {\n  span(color <-- colorStream, caption)\n}\n \n// Now use it\nval prettyColorStream: EventStream[String] = ???\nval myDiv: HtmlElement = div(\n  \"Hello \",\n  Caption(\"World\", prettyColorStream)\n)\n```\n\n----------------------------------------\n\nTITLE: Form State Management and Validation in Scala.js using Laminar\nDESCRIPTION: Implements a reactive form system with validation for zip code and description fields. The code includes state management using Var, custom validation logic, controlled form inputs, and error display handling. It demonstrates Laminar's reactive programming model with signals and observers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/form-state.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\ncase class FormState(\n  zip: String = \"\",\n  description: String = \"\",\n  showErrors: Boolean = false\n) {\n\n  def hasErrors: Boolean = zipError.nonEmpty || descriptionError.nonEmpty\n\n  def zipError: Option[String] = {\n    if (zip.forall(Character.isDigit) && zip.length == 5) {\n      None\n    } else {\n      Some(\"Zip code must consist of 5 digits\")\n    }\n  }\n\n  def descriptionError: Option[String] = {\n    if (description.nonEmpty) {\n      None\n    } else {\n      Some(\"Description must not be empty.\")\n    }\n  }\n\n  def displayError(error: FormState => Option[String]): Option[String] = {\n    error(this).filter(_ => showErrors)\n  }\n}\n\nval stateVar = Var(FormState())\n\nval zipWriter = stateVar.updater[String]((state, zip) => state.copy(zip = zip))\n\nval descriptionWriter = stateVar.updater[String]((state, desc) => state.copy(description = desc))\n\nval submitter = Observer[FormState] { state =>\n  if (state.hasErrors) {\n    stateVar.update(_.copy(showErrors = true))\n  } else {\n    dom.window.alert(s\"Zip: ${state.zip}; Description: ${state.description}\")\n  }\n}\n\ndef renderInputRow(error: FormState => Option[String])(mods: Modifier[HtmlElement]*): HtmlElement = {\n  val errorSignal = stateVar.signal.map(_.displayError(error))\n  div(\n    cls(\"-inputRow\"),\n    cls(\"x-hasError\") <-- errorSignal.map(_.nonEmpty),\n    p(mods),\n    child.maybe <-- errorSignal.map(_.map(err => div(cls(\"-error\"), err)))\n  )\n}\n\nval app = div(\n  form(\n    onSubmit\n      .preventDefault\n      .mapTo(stateVar.now()) --> submitter,\n\n    renderInputRow(_.zipError)(\n      label(\"Zip code: \"),\n      input(\n        placeholder(\"12345\"),\n        controlled(\n          value <-- stateVar.signal.map(_.zip),\n          onInput.mapToValue.filter(_.forall(Character.isDigit)) --> zipWriter\n        )\n      ),\n      button(\n        typ(\"button\"), // \"submit\" is the default in HTML\n        \"Set SF zip code\",\n        onClick.mapTo(\"94110\") --> zipWriter\n      )\n    ),\n\n    renderInputRow(_.descriptionError)(\n      label(\"Description: \"),\n      input(\n        controlled(\n          value <-- stateVar.signal.map(_.description),\n          onInput.mapToValue --> descriptionWriter\n        )\n      ),\n      button(\n        typ(\"button\"), // \"submit\" is the default in HTML\n        \"Clear\",\n        onClick.mapTo(\"\") --> descriptionWriter\n      )\n    ),\n\n    p(\n      button(typ(\"submit\"), \"Submit\")\n    )\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Efficient User Rendering Function with Signal\nDESCRIPTION: Reimplements the user rendering function to accept a signal of user updates. This approach enables efficient updates by reusing DOM elements and only updating the changed properties.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ndef newRenderUser(userId: String, initialUser: User, userSignal: Signal[User]): HtmlElement = {\n  div(\n    p(\"user id: \" + userId),\n    p(\"name: \", text <-- userSignal.map(_.name))\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reactive Hello World App with Laminar in Scala.js\nDESCRIPTION: This Scala.js snippet creates a simple reactive UI with Laminar that updates a greeting based on user input. It uses a Var to store the name state, creates a UI with input field and display, and renders it to a container element in the DOM.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/hello-world.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport org.scalajs.dom\nimport com.raquo.laminar.api.L.{*, given}\n\nval nameVar = Var(initial = \"world\")\n\nval rootElement = div(\n  label(\"Your name: \"),\n  input(\n    onMountFocus,\n    placeholder := \"Enter your name here\",\n    onInput.mapToValue --> nameVar\n  ),\n  span(\n    \"Hello, \",\n    child.text <-- nameVar.signal.map(_.toUpperCase)\n  )\n)\n\n// In most other examples, containerNode will be set to this behind the scenes\nval containerNode = dom.document.querySelector(\"#mdoc-html-run0\")\n\nrender(containerNode, rootElement)\n```\n\n----------------------------------------\n\nTITLE: Mounting Laminar Application with Components\nDESCRIPTION: Demonstrates how to compose and mount a Laminar application with nested components and event streams.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval nameStream: EventStream[String] = ???\nval colorStream: EventStream[String] = ???\n\nval appDiv: Div = div(\n  h1(\"User Welcomer 9000\"),\n  div(\n    \"Please accept our greeting: \",\n    Hello(nameStream, colorStream) // Inserts the Laminar div element here\n  )\n)\n\n// Mount the application into a pre-existing container\nrender(dom.document.querySelector(\"#appContainer\"), appDiv)\n```\n\n----------------------------------------\n\nTITLE: AJAX Requests using AjaxStream in Laminar\nDESCRIPTION: Demonstrates how to make AJAX requests using Laminar's AjaxStream API for scenarios like file upload progress tracking.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_91\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  AjaxStream.get(\"/api/kittens\") --> { xhr =>\n    dom.console.log(xhr.responseText)\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reactive Counter Component with Laminar in Scala.js\nDESCRIPTION: This snippet demonstrates creating a reusable Counter component with Laminar that maintains count state, allows selecting different step sizes, and provides increment/decrement buttons. It showcases Laminar's reactive programming model including Var, EventBus, Signal, and DOM event handling.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/counter.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\ndef Counter(label: String, initialStep: Int): HtmlElement = {\n\n  val allowedSteps = List(1, 2, 3, 5, 10)\n\n  val stepVar = Var(initialStep)\n\n  val diffBus = new EventBus[Int]\n\n  val countSignal: Signal[Int] = diffBus.events.scanLeft(initial = 0)(_ + _)\n\n  div(\n    p(\n      \"Step: \",\n      select(\n        value <-- stepVar.signal.map(_.toString),\n        onChange.mapToValue.map(_.toInt) --> stepVar,\n        allowedSteps.map { step =>\n          option(value := step.toString, step)\n        }\n      )\n    ),\n    p(\n      label + \": \",\n      b(child.text <-- countSignal),\n      \" \",\n      // Two different ways to get stepVar's value:\n      button(\n        \"–\",\n        onClick.mapTo(-1 * stepVar.now()) --> diffBus\n      ),\n      button(\n        \"+\",\n        onClick.compose(_.sample(stepVar.signal)) --> diffBus\n      )\n    )\n  )\n}\n\nval app = div(\n  h1(\"Let's count!\"),\n  Counter(\"Sheep\", initialStep = 3)\n)\n\n// In most other examples, containerNode will be set to this behind the scenes\nval containerNode = dom.document.querySelector(\"#mdoc-html-run0\")\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Complex Element Lifecycle Example with Mounting and Subscription Management in Scala Laminar\nDESCRIPTION: A comprehensive example showing element creation, mounting, amendment with new subscriptions, and the behavior of onMountCallback. It demonstrates when callbacks are triggered and how subscriptions behave when elements are mounted and unmounted.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_78\n\nLANGUAGE: scala\nCODE:\n```\nval inputEl = input(onMountCallback(_ => println(\"OG\"))) // create element\nval rootNode = render(inputEl) // mount it. This will print \"OG\"\nval printBus: EventBus[String] = new EventBus \n\ninputEl.amend(\n  printBus.events --> (str => println(\"Mod: \" + str)),\n  onMountCallback { _ =>\n    println(\"New gang\") // this will print nothing right now\n  },\n  onMountCallback { ctx =>\n    printBus.events.foreach(str => \"Mount: \" + str)(ctx.owner)\n  }\n)\n\nprintBus.writer.onNext(\"hello\") // this will print \"Mod: hello\"\n \nrootNode.unmount() // unmount the element\nrootNode.mount() // this will print both \"OG\" and \"New gang\"\n\nprintBus.writer.onNext(\"hi\") // this will print \"Mod: hi\" and \"Mount: hi\"\n```\n\n----------------------------------------\n\nTITLE: Interactive Form with Event Bus and Dynamic Updates\nDESCRIPTION: Shows how to create an interactive form with input binding and dynamic updates using EventBus.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval nameBus = new EventBus[String]\nval colorStream: EventStream[String] = nameBus.events.map { name =>\n  if (name == \"Sebastien\") \"red\" else \"unset\" // make Sebastien feel special\n}\n\nval appDiv: Div = div(\n  h1(\"User Welcomer 9000\"),\n  div(\n    \"Please enter your name:\",\n    input(\n      typ := \"text\",\n      onInput.mapToValue --> nameBus // extract text entered into this input node whenever the user types in it\n    )\n  ),\n  div(\n    \"Please accept our greeting: \",\n    Hello(nameBus.events, colorStream)\n  )\n)\n\nrender(dom.document.querySelector(\"#appContainer\"), appDiv)\n```\n\n----------------------------------------\n\nTITLE: Nesting and Children in Laminar Element Creation\nDESCRIPTION: Illustrates how to create nested HTML elements with various modifiers and children in Laminar. It includes setting attributes, styles, and text content for different elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval inputCaption = span(\"First & last name:\")\nval inputMods = Seq(typ := \"text\", defaultValue := \"Me\")  \n\ndiv(\n  h1(\"Hello world\", color := \"red\"),\n  inputCaption,\n  input(inputMods, nameAttr := \"fullName\"),\n  div(\n    \">>\",\n    button(\"Submit\"),\n    \"<<\"\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Split Operations in Scala\nDESCRIPTION: Shows how to split an Observable[ADT] into multiple Signal[Subtype] using pattern matching. Demonstrates page routing example with different page types.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-12-13-laminar-v17.2.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Page\nobject HomePage extends Page\nobject LoginPage extends Page\ncase class UserPage(userId: Int) extends Page\n\nval pageSignal: Signal[Page] = ??? // router.currentPageSignal\n\nval elementSignal: Signal[HtmlElement] =\n  pageSignal\n    .splitMatchOne\n    .handleValue(HomePage) {\n      div(h1(\"Home page\"))\n    }\n    .handleValue(LoginPage) {\n      div(h1(\"Login page\"))\n    }\n    .handleType[UserPage] { (initialUserPage, userPageSignal) =>\n      div(\n        h1(\"User #\", text <-- userPageSignal.map(_.id))\n      )\n    }\n    .toSignal\n```\n\n----------------------------------------\n\nTITLE: Rendering Laminar Elements to DOM\nDESCRIPTION: Example showing how to render a Laminar application by mounting a root element into an existing DOM container. Demonstrates creating a basic component hierarchy and mounting/unmounting functionality.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval appContainer: dom.Element = dom.document.querySelector(\"#appContainer\")\nval appElement: Div = div(\n  h1(\"Hello\"),\n  \"Current time is:\",\n  b(\"12:00\") \n)\n \nval root: RootNode = render(appContainer, appElement)\n```\n\n----------------------------------------\n\nTITLE: Rendering Dynamic Children in Laminar with <-- Operator\nDESCRIPTION: Demonstrates how to subscribe to an Observable of children elements using the <-- operator. This allows for reactive updates to the DOM when the signal emits new values.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\n// Can be any Seq-like collection\nval childrenSignal: Signal[List[Node]] = ???\ndiv(\"Hello, \", children <-- childrenSignal)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Laminar Element with Dynamic Text\nDESCRIPTION: Demonstrates creating a basic Laminar div element with static and dynamic text content using event streams.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\n\nval streamOfNames: EventStream[String] = ???\nval helloDiv: Div = div(\"Hello, \", child.text <-- streamOfNames)\n```\n\n----------------------------------------\n\nTITLE: Efficient Element Updates with Signals in Scala\nDESCRIPTION: Demonstrates the proper way to update DOM element properties without recreating elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_97\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  span(\n    color <-- userSignal.map(_.prefColor),\n    text <-- userSignal.map(_.name)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: EventStream Callback Usage Examples in Scala\nDESCRIPTION: Demonstrates practical usage of different EventStream callback patterns including regular callbacks, JS callbacks, and observers in a Laminar component context.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval (stream1, callback) = EventStream.withCallback[String]\nval (stream2, jsCallback) = EventStream.withJsCallback[String]\nval (stream3, observer) = EventStream.withObserver[String]\n\ncallback(\"1\") // Make `stream1` emit `1`. Similarly for other pairs.\n\ndiv(\n  onMountCallback(_ => callback(\"Mounted!\")),\n  ReactJsButtonComponent.Props(\n    caption = \"Click 2\",\n    onClick = jsCallback // js.Function1[String, Unit]\n  ).render,\n  button(\"Click 3\", onClick.mapTo(\"Clicked!\") --> observer),\n  div(\"stream1: \", child.text <-- stream1),\n  div(\"stream2: \", child.text <-- stream2),\n  div(\"stream3: \", child.text <-- stream3)\n)\n```\n\n----------------------------------------\n\nTITLE: Reactive Conditional Rendering in Scala using Laminar\nDESCRIPTION: Illustrates reactive conditional rendering techniques in Laminar, using Signals and EventStreams to dynamically update the DOM based on changing conditions.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nval boolSignal: Signal[Boolean] = ???\nval userStream: EventStream[User] = ???\nval maybeElementSignal: Signal[Option[HtmlElement]] = ???\n```\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  child <-- maybeElementSignal.map(_.getOrElse(span(\"no data\")))\n)\n\ndiv(\n  child.maybe <-- maybeElementSignal\n)\n\n// Cache these to avoid re-creating them on repeated events\nlazy val trueDiv = div(\"true\")\nlazy val falseDiv = div(\"false\")\n\ndiv(\n  child <-- boolSignal.map(if (_) trueDiv else falseDiv)\n)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval maybeActiveUserSignal: Signal[Option[User]] =\n  userStream\n    .startWithNone\n    .map(maybeUser => maybeUser.filter(_.isActive))\n\nval emptyElement = span(\"no active user\")\n\n// using .splitOption instead of .map for efficiency\ndiv(\n  child <-- maybeActiveUserSignal.splitOption(\n    (initialActiveUser, activeUserSignal) => {\n      div(\n        idAttr := s\"user-${initialActiveUser.id}\",\n        text <-- activeUserSignal.map(_.name)\n      )\n    },\n    ifEmpty = emptyElement\n  )\n)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval maybeUserSignal: Signal[Option[User]] =\n  userStream\n    .startWithNone\n    .combineWithFn(boolSignal, {\n      case (Some(user), true) => Some(user)\n      case _ => None\n    })\n\n// using .splitOption instead of .map for efficiency\ndiv(\n  child.maybe <-- maybeUserSignal.splitOption(\n    (initialUser, userSignal) => {\n      div(\n        idAttr := s\"user-${initialUser.id}\",\n        text <-- userSignal.map(_.name)\n      )\n    }\n  )\n)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Renders \"Hello\" when boolSignal value is true, nothing otherwise.\ndiv(\n  child(div(\"Hello\")) <-- boolSignal\n)\n\n// Renders \"Hello world\" when boolSignal value is true, nothing otherwise.\ndiv(\n  children(\n    div(\"Hello, \"),\n    span(\"world\")\n  ) <-- boolSignal\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering conditional elements with Signal in Laminar\nDESCRIPTION: Shows how to dynamically render different element types based on a Signal value. This example conditionally displays either a link or an italic text element depending on the presence of a URL.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ndef MaybeBlogUrl(maybeUrlSignal: Signal[Option[String]]): Signal[HtmlElement] = {\n  maybeUrlSignal.map {\n    case Some(url) => a(href := url, \"a blog\")\n    case None => i(\"no blog\")\n  }\n}\n\nval maybeBlogUrlSignal: Signal[Option[String]] = ???\nval app: HtmlElement = div(\n  \"Hello, I have \",\n  child <-- MaybeBlogUrl(maybeBlogUrlSignal),\n  \", isn't it great?\"\n)\n```\n\n----------------------------------------\n\nTITLE: Listening to User Input with Laminar in Scala.js\nDESCRIPTION: This snippet demonstrates how to listen to user input in a text field and checkbox using Laminar's reactive system. It creates Var objects to hold state and uses event streams to update these variables when users interact with the inputs.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/uncontrolled-inputs.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval inputTextVar = Var(\"\")\n\nval checkedVar = Var(false)\n\nval app = div(\n  p(\n    label(\"Name: \"),\n    input(\n      onInput.mapToValue --> inputTextVar\n    )\n  ),\n  p(\n    \"You typed: \",\n    child.text <-- inputTextVar\n  ),\n  p(\n    label(\"I like to check boxes: \"),\n    input(\n      typ(\"checkbox\"),\n      onInput.mapToChecked --> checkedVar\n    )\n  ),\n  p(\n    \"You checked the box: \",\n    child.text <-- checkedVar\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Rendering Immutable Collections with Laminar\nDESCRIPTION: Demonstrates the standard approach of rendering children from an observable of an immutable collection using split operator. The code shows both the rendering pattern and how to update the collection.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nval usersVar = Var[List[User]](???)\n\n// Render\ndiv(children <-- usersVar.signal.split(_.userId)(renderUser))\n\n// Update\nusersVar.update(_.updated(ix, newUser))\n```\n\n----------------------------------------\n\nTITLE: EventStream Callback Implementation in Scala\nDESCRIPTION: Shows the implementation of EventStream.withCallback, demonstrating how to create streams fed by callbacks or observers in a React hooks-like style.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef withCallback[A]: (EventStream[A], A => Unit) = {\n  val bus = new EventBus[A]\n  (bus.events, bus.writer.onNext)\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Dynamic List Rendering with Airstream's split Operator\nDESCRIPTION: Demonstrates the recommended approach for rendering dynamic lists in Laminar using Airstream's split operator. This efficiently updates only the changed elements without recreating the entire list.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nval userElementsSignal: EventStream[List[HtmlElement]] =\n  usersStream.split(_.id)(newRenderUser)\n \ndiv(\n  children <-- userElementsSignal\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Dynamic Children with children.command in Laminar\nDESCRIPTION: Shows a complete example of using children.command with a button that adds new child elements on click, demonstrating how to use CollectionCommand.Append.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nval commandBus = new EventBus[ChildrenCommand]\nval commandStream = commandBus.events\nvar counter = 0\ndiv(\n  \"Hello, \",\n  children.command <-- commandStream,\n  button(\n    \"Add a child\",\n    onClick.map { _ =>\n      counter += 1\n      CollectionCommand.Append(span(s\"Child # $counter\"))\n    } --> commandBus\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Debounce for Input Validation in Scala.js with Laminar\nDESCRIPTION: This snippet demonstrates how to use debounce functionality in Laminar to validate email input. It creates an input field that checks for email validity after a 1-second delay from the last input event, preventing unnecessary validations during rapid typing.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/time.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\ndef emailError(email: String): Option[String] =\n  if (email.isEmpty)\n    Some(\"Please fill out email\")\n  else if (!email.contains('@'))\n    Some(\"Invalid email!\")\n  else\n    None\n\nval inputBus = new EventBus[String]\n\nval debouncedErrorStream: EventStream[Option[String]] = \n  inputBus.events\n    .debounce(1000)\n    .map(emailError)\n\nval app = div(\n  span(\n    label(\"Your email: \"),\n    input(\n      value <-- inputBus.events,\n      onInput.mapToValue --> inputBus\n    )\n  ),\n  child <-- debouncedErrorStream.map {\n    case Some(err) => span(cls(\"-error\"), \"Error: \" + err)\n    case None      => span(cls(\"-success\"), \"Email ok!\")\n  }\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Text Input Component in Laminar\nDESCRIPTION: Shows how to create a reusable text input component in Laminar that accepts modifiers as varargs. This allows flexible configuration of the input element without needing to whitelist all possible configurations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// Simple component\ndef TextInput(inputMods: Modifier[Input]*): HtmlElement =\n  div(\n    cls := \"TextInput\",\n    input(typ := \"text\", inputMods)\n  )\n\n// Usage (data binding with arrows will be explained later)\ndiv(\n  TextInput(defaultValue := \"Enter your age\", value <-- ageVar, onInput --> ageVar)\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Mutable Collection in Var (Scala)\nDESCRIPTION: Demonstrates how to properly update a mutable collection inside a Var to trigger an update in Laminar. This is necessary because mutating the collection directly does not cause the Var to emit an update.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nmyVar.update { mutableArr =>\n  mutableArr.update(ix, newValue)\n  mutableArr\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Input Component without Redundant State in Scala\nDESCRIPTION: Demonstrates the correct approach to handling input state by avoiding redundant variables and using direct signal mapping.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_99\n\nLANGUAGE: scala\nCODE:\n```\ndef nameInput(userVar: Var[User]): HtmlElement = {\n  input(\n    value <-- userVar.signal.map(_.name),\n    onInput.mapToValue --> { newName =>\n      userVar.update(user => user.copy(name = newName)) \n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ajax Request Handler in Laminar with Scala.js\nDESCRIPTION: Creates an interactive Ajax testing interface using Laminar and AirStream. Features include multiple request options, progress tracking, request abortion, and error handling. Uses reactive programming patterns with Var and Signal for state management.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/ajax.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.airstream.web.AjaxStream\nimport com.raquo.airstream.web.AjaxStream.AjaxStreamError\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\ncase class AjaxOption(name: String, url: String)\n\nval options = List(\n  AjaxOption(\"Valid Ajax request\", \"https://api.zippopotam.us/us/90210\"),\n  AjaxOption(\"Download 100MB file (gives you time to abort)\", \"https://cachefly.cachefly.net/100mb.test\"),\n  AjaxOption(\"URL that will fail due to invalid domain\", \"https://api.zippopotam.uxx/us/90210\"),\n  AjaxOption(\"URL that will fail due to CORS restriction\", \"https://unsplash.com/photos/KDYcgCEoFcY/download?force=true\")\n)\nval selectedOptionVar = Var(options.head)\nval pendingRequestVar = Var[Option[dom.XMLHttpRequest]](None)\nval eventsVar = Var(List.empty[String])\n\nval app: HtmlElement = div(\n  h1(\"Ajax Tester\"),\n  options.map { option =>\n    div(\n      input(\n        typ(\"radio\"),\n        idAttr(option.name),\n        nameAttr(\"ajaxOption\"),\n        checked <-- selectedOptionVar.signal.map(_ == option),\n        onChange.mapTo(option) --> selectedOptionVar\n      ),\n      label(forId(option.name), \" \" + option.name)\n    )\n  },\n  br(),\n  div(\n    button(\n      \"Send\",\n      inContext { thisNode =>\n        val clickStream = thisNode.events(onClick).sample(selectedOptionVar.signal)\n        val responseStream = clickStream.flatMapSwitch { opt =>\n          AjaxStream\n            .get(\n              url = opt.url,\n              requestObserver = pendingRequestVar.someWriter,\n              progressObserver = eventsVar.updater { (evs, p) =>\n                val ev = p._2\n                evs :+ s\"Progress: ${ev.loaded} / ${ev.total} (lengthComputable = ${ev.lengthComputable})\"\n              },\n              readyStateChangeObserver = eventsVar.updater { (evs, req) =>\n                evs :+ s\"Ready state: ${req.readyState}\"\n              }\n            )\n            .map(\"Response: \" + _.responseText)\n            .recover { case err: AjaxStreamError => Some(err.getMessage) }\n        }\n\n        List(\n          clickStream.map(opt => List(s\"Starting: GET ${opt.url}\")) --> eventsVar,\n          responseStream --> eventsVar.updater[String](_ :+ _)\n        )\n      }\n    ),\n    \" \",\n    button(\n      \"Abort\",\n      onClick --> (_ => pendingRequestVar.now().foreach(_.abort()))\n    )\n  ),\n  div(\n    h2(\"Events:\"),\n    div(children <-- eventsVar.signal.map(_.map(div(_))))\n  )\n)\n\nval containerNode = dom.document.querySelector(\"#mdoc-html-run0\")\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Flat-mapping Events to AJAX Requests in Laminar (Scala)\nDESCRIPTION: Demonstrates how to use `flatMap` to create a new stream for each input event, in this case making an AJAX request for each input value change.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_60\n\nLANGUAGE: scala\nCODE:\n```\ndef makeAjaxRequest(): EventStream[Response] = AjaxStream.get(...).map(...)\n\ninput(\n  onInput\n    .mapToValue\n    .flatMap(txt => makeAjaxRequest(txt)) --> observer\n)\n```\n\n----------------------------------------\n\nTITLE: Simple Input Box Component with Event Bus\nDESCRIPTION: Demonstrates creating a reusable input box component that accepts a caption and event bus for value updates.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef InputBox(caption: String, textBus: WriteBus[String]): Div = {\n  div(\n    caption,\n    input(\n      typ := \"text\",\n      onInput.mapToValue --> textBus\n    )\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom HTML Properties and Event Props in Laminar\nDESCRIPTION: Demonstrates how to define custom HTML properties and event handlers in Laminar for attributes not available in the standard library. This approach allows you to extend Laminar's capabilities without modifying the core library.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.codecs.*\nval superValue: HtmlProp[String, String] = htmlProp(\"superValue\", StringAsIsCodec) // imaginary prop\nval onTouchMove: EventProp[dom.TouchEvent] = eventProp(\"touchmove\")\n\ndiv(\n  superValue := \"imaginary prop example\",\n  onTouchMove --> eventBus\n)\n```\n\n----------------------------------------\n\nTITLE: Custom DOM Properties Syntax Comparison in Scala\nDESCRIPTION: Demonstrates the old and new syntax for creating custom DOM properties, event properties, and styles in Laminar. The new syntax reduces boilerplate when defining interfaces for third-party web components.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// BEFORE:\nval superValue: ReactiveProp[String, String] = new ReactiveProp(\"superValue\", StringAsIsCodec)\nval onWhatever: ReactiveEventProp[dom.WhateverEvent] = new ReactiveEventProp(\"whatever\")\nval innerColor: ReactiveStyle[String] = new ReactiveStyle(new generic.Style[String](\"innerColor\", \"inner-color\"))\n\n// AFTER:\nval superValue: ReactiveProp[String, String] = customProp(\"superValue\", StringAsIsCodec)\nval onWhatever: ReactiveEventProp[dom.WhateverEvent] = customEventProp(\"whatever\")\nval innerColor: ReactiveStyle[String] = customStyle(\"inner-color\")\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern: Piping Observables into Individual Properties in Laminar\nDESCRIPTION: The correct way to handle conditional modifiers in Laminar, by mapping observables directly to individual properties. This allows Laminar to properly manage granular DOM updates.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_101\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  cls(\"active\") <-- userSignal.map(_.isActive),\n  opacity <-- userSignal.map(if (_.isActive) 1 else 0.5)\n)\n```\n\n----------------------------------------\n\nTITLE: Using splitTry for Handling Success/Failure States in Scala\nDESCRIPTION: Demonstrates the new splitTry operator which allows for branch-specific handling of Try values in reactive streams, providing properly typed callbacks for success and failure cases.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval userTrySignal: Signal[Try[User]] = ???\ndiv(\n  child <-- userTrySignal.splitTry(\n    success = (initialUser: User, userSignal: Signal[User]) =>\n       div(\"User name: \", text <-- userSignal.map(_.name)),\n    failure = (initialErr: Throwable, errSignal: Signal[Throwable]) =>\n       div(\"Something is wrong: \", text <-- errSignal.map(_.getMessage))\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Static Conditional Rendering in Scala using Laminar\nDESCRIPTION: Demonstrates various patterns for static conditional rendering in Laminar, including the use of 'when', 'whenNot', and if-else statements to conditionally render elements or apply modifiers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nval bool: Boolean = ???\nval option: Option[String] = ???\n\ndiv(\n  when(bool)(\n    b(\"world\"),\n    span(\", and everyone\")\n  )\n)\n\ndiv(\n  whenNot(bool) {\n    b(\"world\")\n  }\n)\n\ndiv(\n  \"Hello\",\n  if (bool) b(\" world\") else emptyNode\n)\n\ndiv(\n  \"Hello \",\n  if (bool)\n    b(\"world\") :: Nil\n  else\n    div(\"foo\") :: div(\"bar\") :: Nil \n)\n\na(\n  option.map(str => href := str), // conditionally apply a modifier \n  option.map(str => span(str))\n)\n\ndiv(\n  option.map(str => span(str)).getOrElse(\"– nothing –\")\n)\n\nval element = div(/*...*/)\n\nif (bool) {\n  // apply modifiers to existing element\n  element.amend(\n    rel := \"foo\",\n    span(\"Append another child\")\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Arrow Methods Syntax Sugar in Laminar (Scala)\nDESCRIPTION: Demonstrates various ways to use arrow methods (-->, <--) with different types of Sinks and Sources in Laminar. Includes examples with EventBus, Var, and custom functions.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nval intBus = new EventBus[Int]\nval textVar = Var(\"\")\ninput(\n  onClick.mapTo(1) --> intBus,\n  value <-- textVar,\n  onInput.mapToValue --> textVar,\n  onMouseOver --> { ev => println(ev) },\n  onChange --> { _ => println(\"committed\") },\n  onBlur.mapTo(\"blur\") --> println\n)\n```\n\n----------------------------------------\n\nTITLE: Using flatMapSwitch for Async Operations in Scala\nDESCRIPTION: Demonstrates safe usage of flatMapSwitch (formerly flatMap) for handling asynchronous operations like network requests. This pattern is fine because asynchronous events don't suffer from the same glitch issues as synchronous operations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// This is fine.\nval userS: Signal[User] = ???\nval responseS: EventStream[Response] = userS.flatMapSwitch { user =>\n  FetchStream.get(s\"/user/${user.id}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Event Composition in Laminar (Scala)\nDESCRIPTION: Shows a more complex example of using composeEvents with both EventProcessor and stream operators.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval $allowClick: Signal[Boolean] = ???\n \na(\n  composeEvents(onClick.preventDefault) {\n    _.withCurrentValueOf($allowClick)\n      .collect { case (ev, true) => ev }\n  } --> eventObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Correct Signal Combination using combineWith in Scala\nDESCRIPTION: Shows the proper way to combine two signals using combineWith operator, avoiding unnecessary transaction boundaries.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_94\n\nLANGUAGE: scala\nCODE:\n```\nval resultSignal: Signal[(Int, Boolean)] = intSignal.combineWith(boolSignal)\n```\n\n----------------------------------------\n\nTITLE: FetchStream API Examples\nDESCRIPTION: Demonstrates various ways to use FetchStream for making HTTP requests with different response handling approaches.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nFetchStream.get(\n  url,\n  _.redirect(_.follow),\n  _.referrerPolicy(_.`no-referrer`),\n  _.abortStream(...)\n) // EventStream[String] of response body\n```\n\nLANGUAGE: scala\nCODE:\n```\nFetchStream.raw.get(url) // EventStream[dom.Response]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval Fetch = FetchStream.withCodec(encodeRequest, decodeResponse)\n\nFetch.post(url, _.body(myRequest)) // EventStream[MyResponse]\n```\n\n----------------------------------------\n\nTITLE: Rendering Loading State in Scala using Laminar and Airstream\nDESCRIPTION: Demonstrates how to handle asynchronous requests and render loading states using Laminar and Airstream's Async Status Operators.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nval requestS: EventStream[Request] = ???\n\ntype Response = String // could be whatever\n\nval responseS: EventStream[Status[Request, Response]] =\n  requestS.flatMapWithStatus { request =>\n    // returns EventStream[Response]\n    FetchStream.get(request.url, request.options)\n  }\n\nval isLoadingS: EventStream[Boolean] = responseS.map(_.isPending)\n\nval textS: EventStream[String] =\n  responseS.foldStatus(\n    resolved = _.toString,\n    pending = _ => \"Loading...\" \n  )\n\n// Example usage:\ndiv(\n  child(img(src(\"spinner.gif\"))) <-- isLoadingS,\n  text <-- textS\n)\n\n// Or, perhaps more realistically:\ndiv(\n  child <-- responseS.splitStatus(\n    (resolved, _) => div(\"Response: \" + resolved.output.toString),\n    (pending, _) => div(img(src(\"spinner.gif\")), \"Loading ...\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Managing CSS Classes in Scala using Laminar's 'cls' Attribute\nDESCRIPTION: Explains the special behavior of the 'cls' attribute in Laminar for managing CSS classes, including static and reactive class application and removal.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_43\n\nLANGUAGE: css\nCODE:\n```\n/* CSS */\n\n.LabelComponent {\n  font-size: 20pt;\n  color: red;\n}\n.vip {\n  text-transform: uppercase;\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Scala\n\nval veryImportant: Modifier[HtmlElement] = cls := \"vip\"\n\ndef Label(caption: String): HtmlElement = div(\n  veryImportant,\n  cls := \"LabelComponent\",\n  caption\n)\n \nval myLabel: HtmlElement = Label(\"Hi, I'm a caption.\") \n```\n\nLANGUAGE: scala\nCODE:\n```\nval someBoolean: Boolean = ???\n\n// Add multiple class names\ncls := (\"class1\", \"class2\")\ncls := List(\"class1\", \"class2\")\n \n// Remember that apply method is alias for :=. Below is the same as above\ncls(\"class1\", \"class2\")\ncls(List(\"class1\", \"class2\"))\n \n// Add class name conditionally (true = add, false = do nothing)\ncls := (\"class1\" -> true, \"class2\" -> false)\ncls := Seq(\"class1\" -> true, \"class2\" -> someBoolean)\ncls := (Seq(\"class1\" -> true, \"class2\" -> someBoolean), Seq(\"class3\" -> someBoolean))\ncls := Map(\"class1\" -> true, \"class2\" -> false)\n \n// Add class names conditionally (true = add, false = do nothing)\ncls(\"class1\") := true\ncls(\"class1 class2\") := someBoolean\ncls(\"class1\", \"class2\") := true\n```\n\nLANGUAGE: scala\nCODE:\n```\nval classesStream: EventStream[Seq[String]] = ???\nval isSelectedSignal: Signal[Boolean] = ???\n \ndiv(\n  cls := \"MyComponent\",\n  cls <-- classesStream,\n  cls(\"class1\", \"class2\") <-- isSelectedSignal,\n  cls <-- boolSignal.map { isSelected =>\n    if (isSelected) \"always x-selected\" else \"always\"\n  },\n  cls <-- isSelectedSignal.map { isSelected =>\n    List(\"always\" -> true, \"x-selected\" -> isSelected)\n  },\n  cls <-- isSelectedSignal.map { isSelected =>\n    Map(\"always\" -> true, \"x-selected\" -> isSelected)\n  } \n)\n```\n\n----------------------------------------\n\nTITLE: Mapping StrictSignal Examples in Scala\nDESCRIPTION: Demonstrates how to map strict signals without an owner using mapLazy, returning another StrictSignal. Shows form field value access pattern.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-12-13-laminar-v17.2.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval formVar = Var(Form(...))\nval formSignal: StrictSignal[Form] = formVar.signal \nval fieldSignal: StrictSignal[FieldValue] = formSignal.mapLazy(_.field) // Still a StrictSignal!\n    \nfieldSignal.now() // FieldValue\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled Inputs in Laminar (Scala)\nDESCRIPTION: Demonstrates the implementation of a controlled input in Laminar, where the input's value is locked to an observable and updated based on user input.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_62\n\nLANGUAGE: scala\nCODE:\n```\nval zipVar = Var(\"\")\nval zipValueSignal = zipVar.signal\nval zipInputObserver = zipVar.writer\ninput(\n  placeholder := \"Enter zip code: \",\n  controlled(\n    value <-- zipValueSignal,\n    onInput.mapToValue --> zipInputObserver\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering Mutable Collections with Laminar\nDESCRIPTION: Shows how to use mutable collections like js.Array with Laminar for better performance. Demonstrates the correct pattern for updating mutable collections within Var to ensure updates are properly propagated.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nval usersArr = js.Array[User](???)\n\nval usersVar = Var[js.Array[User]](arr)\n\n// Render - same as before\ndiv(children <-- usersVar.signal.split(_.userId)(renderUser))\n\n// Incorrect – This will mutate `usersArr`, but WILL NOT cause `usersVar` to emit an update.\n// arr.update(ix, newUser)\n\n// Correct – This will mutate `usersArr`, AND will cause `usersVar` to emit an update\nusersVar.update { arr =>\n  arr.update(ix, newUser)\n  arr // return the same, now mutated, array\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Material UI Button with Reactive Properties in Laminar\nDESCRIPTION: This snippet demonstrates how to use a Material UI Button web component with Laminar's reactive state. It creates a button with customizable label and icon, bound to reactive variables and event handlers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/web-components.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport website.webcomponents.material.Button\nimport org.scalajs.dom\n\nval actionVar = Var(\"Do the thing\")\nval allowedIcons = List(\"🎉\", \"🚀\", \"🍉\")\nval iconVar = Var(initial = allowedIcons.head)\n\nval app = div(\n  p(\n    label(\"Button label: \"),\n    input(\n      value <-- actionVar.signal,\n      onInput.mapToValue --> actionVar.writer\n    )\n  ),\n  p(\n    label(\"Button icon: \"),\n    select(\n      onChange.mapToValue --> iconVar.writer,\n      value <-- iconVar.signal,\n      allowedIcons.map(icon => option(value(icon), icon))\n    )\n  ),\n  p(\n    Button(\n      _.id := \"myButton\",\n      _.label <-- actionVar.signal,\n      _.raised := true,\n      _.styles.mdcThemePrimary := \"#6200ed\",\n      _ => onClick --> (_ => dom.window.alert(\"Click\")), // standard event\n      _.onMouseOver --> (_ => println(\"MouseOver\")), // \"custom\" event\n      _.slots.icon(span(child.text <-- iconVar.signal)),\n      //_ => onMountCallback(ctx => ctx.thisNode.ref.doThing()) // doThing is not implemented, just for reference\n    )\n  ),\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern: Combining Related Signals in Laminar\nDESCRIPTION: A recommended approach for keeping related values in one place while still respecting Laminar's granular update model. This prevents redundant computation and maintains proper reactive semantics.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_103\n\nLANGUAGE: scala\nCODE:\n```\nval clsWithOpacitySignal = userSignal.map(if (_.isActive) (\"active\", 1) else (\"\", 0.5))\ndiv(\n  cls <-- clsWithOpacitySignal.map(_._1),\n  opacity <-- clsWithOpacitySignal.map(_._2)\n)\n```\n\n----------------------------------------\n\nTITLE: Transforming Observers in Laminar (Scala)\nDESCRIPTION: Demonstrates how to transform Observers using contramap and filter. The example shows how to create a specialized observer from a more general one, promoting separation of concerns.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nval pieObserver: Observer[Pie] = Observer(onNext = bakePie)\nval appleObserver: Observer[Apple] = pieObserver.contramap(apple => makeApplePie(apple))\n \ndef AppleComponent(observer: Observer[Apple]): Div = {\n  val appleStream: EventStream[Apple] = ???\n  div(\n    \"Apple Component\",\n    appleStream --> observer,\n    ???\n  )\n}\n \nval app = AppleComponent(appleObserver)\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Input Element with Modifiers in Laminar\nDESCRIPTION: Demonstrates how to create an HTML input element using Laminar's modifiers. It sets the type attribute to 'checkbox' and the defaultChecked property to true.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ninput(typ := \"checkbox\", defaultChecked := true)\n```\n\n----------------------------------------\n\nTITLE: Implementing Delayed Actions in Scala.js with Laminar\nDESCRIPTION: This example shows how to handle asynchronous operations with Laminar. It creates a button that, when clicked, displays a 'Just clicked!' message and removes it after 500ms. The snippet demonstrates the use of EventBus, EventStream.merge, and delay operations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/time.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval clickBus = new EventBus[Unit]\n\nval maybeAlertStream = EventStream.merge(\n  clickBus.events.mapTo(Some(span(\"Just clicked!\"))),\n  clickBus.events.flatMapSwitch { _ =>\n    EventStream.fromValue(None, emitOnce = true).delay(500)\n  }\n)\n\nval app = div(\n  button(onClick.mapTo(()) --> clickBus, \"Click me\"),\n  child.maybe <-- maybeAlertStream\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Using splitOne for Document Editor State Management in Laminar\nDESCRIPTION: Shows how to use splitOne to reset a complex component's state when switching between different documents, ensuring that each document editor instance maintains its own isolated state.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\ncase class Document(id: String, content: DocumentContent, ...)\n   \ndef editor(\n  documentId: Boolean,\n  initialDocument: Document,\n  documentSignal: Signal[Document]\n): HtmlElement = {\n  val documentState = Var(initialDocument)\n  ... // More complex setup here, with some internal state specific to a particular document\n  div(\n    someInput --> documentState,\n    documentSignal.map(...) --> documentState,\n    documentState --> ...\n  )\n}\n \nval inputSignal: Signal[Document] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.id)(project = editor)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Input Component in Laminar (Scala)\nDESCRIPTION: Demonstrates how to create a custom TextInput component in Laminar. This example shows the structure of a reusable component that wraps an input element.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nclass TextInput private (\n  val wrapperNode: Div,\n  val inputNode: Input\n)\n\nobject TextInput {\n  def apply(caption: String): TextInput = {\n    val inputNode = input(typ := \"text\", color := \"grey\")\n    val wrapperNode = div(caption, inputNode)\n    new TextInput(wrapperNode, inputNode)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Network Requests using FetchStream in Laminar\nDESCRIPTION: Shows different ways to make HTTP requests using Laminar's FetchStream, including handling responses and click events.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_90\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  // Make fetch request when this div element is mounted:\n  FetchStream.get(url) --> { responseText => doSomething },\n  // Make fetch request on every click:\n  onClick.flatMap(_ => FetchStream.get(url)) --> { responseText => doSomething },\n  // Same, but also get the click event:\n  onClick.flatMap(ev => FetchStream.get(url).map((ev, _))) --> {\n    case (ev, responseText) => doSomething\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using mapToValue/mapToChecked for Input Elements in Laminar (Scala)\nDESCRIPTION: Examples showing how to use the new mapToValue and mapToChecked helpers to access input element values, replacing the deprecated TypedTargetEvent concept.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nonChange.mapToValue --> valueObserver\n```\n\n----------------------------------------\n\nTITLE: New Laminar Render Method\nDESCRIPTION: New renderDetached method that allows manual management of DOM nodes for third party JS library integration. Requires manual deactivation when node is no longer needed.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-07-13-laminar-v16.0.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nrenderDetached(laminarElement, activateNow = true)\n```\n\n----------------------------------------\n\nTITLE: Optimizing conditional rendering with splitOption in Laminar\nDESCRIPTION: Demonstrates an optimized approach to conditional rendering that avoids recreating DOM elements unnecessarily. Uses Airstream's splitOption operator to efficiently handle changes in the underlying Signal.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef renderBlogLink(urlSignal: Signal[String]): HtmlElement = {\n  a(href <-- urlSignal, \"a blog\")\n}\n \ndef MaybeBlogUrl(maybeUrlSignal: Signal[Option[String]]): Signal[HtmlElement] = {\n  lazy val noBlog = i(\"no blog\")\n  \n  val maybeLinkSignal: Signal[Option[HtmlElement]] =\n    maybeUrlSignal.splitOption((_, urlSignal) => renderBlogLink(urlSignal))\n  \n  maybeLinkSignal.map(_.getOrElse(noBlog))\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Events with Throttle in Laminar (Scala)\nDESCRIPTION: Demonstrates how to use the `compose` method to apply throttling to click events in Laminar. This approach avoids the need for explicit `inContext` usage.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_58\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  onClick(_.debounce(100)) --> expensiveClickObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Interval Stream in Scala.js with Laminar\nDESCRIPTION: This snippet demonstrates how to create a periodic stream that updates every second, displaying a tick count and a random number. It uses Laminar's EventStream.periodic method to create the stream.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/time.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval tickStream = EventStream.periodic(1000)\n\nval app = div(\n  div(\n    \"Tick #: \",\n    child.text <-- tickStream.map(_.toString)\n  ),\n  div(\n    \"Random #: \",\n    child.text <-- tickStream.mapTo(scala.util.Random.nextInt() % 100)\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Using EventBus for Reactive Programming in Laminar (Scala)\nDESCRIPTION: Illustrates how to use an EventBus to create a reactive stream of events. The example maps click events to X coordinates and logs them to the console.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nval clickBus = new EventBus[dom.MouseEvent]\nval coordinateStream: EventStream[Int] = clickBus.events.map(ev => ev.screenX)\nval coordinateObserver = Observer[Int](onNext = x => dom.console.log(x))\n \nval element: Div = div(\n  onClick --> clickBus.writer,\n  \"Click me\",\n  coordinateStream --> coordinateObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Filtering User Input in Controlled Inputs (Laminar, Scala)\nDESCRIPTION: Shows how to filter user input in a controlled input, allowing only digit characters to be entered while maintaining the controlled input behavior.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_63\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  placeholder := \"Enter zip code: \",\n  controlled(\n    value <-- zipValueSignal,\n    onInput.mapToValue.map(_.filter(Character.isDigit)) --> zipValueObserver\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using maybe Method for Keys in Laminar\nDESCRIPTION: Introduced in v0.7.1, the maybe method for keys allows for a more concise syntax when working with optional values. It replaces the pattern of mapping over an option to apply a value to an attribute.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nattr.maybe(optionOfValue)\n```\n\nLANGUAGE: scala\nCODE:\n```\noptionOfValue.map(attr := _)\n```\n\n----------------------------------------\n\nTITLE: Binding Arbitrary Observables in Laminar\nDESCRIPTION: Demonstrates how to bind any observable to any observer in Laminar using the arrow syntax. The code shows various binding patterns including connecting streams to event buses and function handlers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nval eventStream: EventStream[A] = ???\nval eventBus: EventBus[A] = ???\nval observable: Observable[A] = ???\nval observer: Observer[A] = ???\ndef doSomething(value: A): Unit = ???\n \ndiv(observable --> observer)\ndiv(observable --> doSomething)\ndiv(eventStream --> eventBus.writer)\ndiv(eventStream --> eventBus) // same as above\n```\n\n----------------------------------------\n\nTITLE: Rendering SVG Elements in Laminar with HTML Context\nDESCRIPTION: Demonstrates how to render SVG elements within a predominantly HTML context by using the svg prefix for SVG-specific elements and attributes while maintaining standard event handling.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_65\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  className := \"someHtmlClassName\",\n  onClick --> ???,\n  svg.svg(\n    svg.height := \"800\",\n    svg.width := \"500\",\n    svg.polyline(\n      svg.points := \"20,20 40,25 60,40\",\n      svg.className := \"someSvgClassName\",\n      onClick --> ???,\n      children <-- ???\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Binding a Stream to Element Property in Laminar\nDESCRIPTION: This code demonstrates creating an EventBus, getting its events stream, and binding that stream to an anchor element's href property. The example shows the basic pattern of reactive property binding in Laminar.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_73\n\nLANGUAGE: scala\nCODE:\n```\nval urlBus: EventBus[String] = new EventBus\nval urlStream: EventStream[String] = urlBus.events\nval element = a(href <-- urlStream) // create the element\nrender(element) // mount the element\n```\n\n----------------------------------------\n\nTITLE: Focusing an Input Element on Mount in Scala Laminar\nDESCRIPTION: This snippet demonstrates how to use the onMountCallback hook to focus an input element whenever it's mounted in the DOM. The callback provides a MountContext that gives access to the element node.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_76\n\nLANGUAGE: scala\nCODE:\n```\ninput(onMountCallback(ctx => ctx.thisNode.ref.focus()))\n```\n\n----------------------------------------\n\nTITLE: Using mapToValue EventProcessor in Scala\nDESCRIPTION: Demonstrates the new mapToValue operator for EventProcessor, which simplifies getting an input's value in event handlers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// BEFORE\ninput(inContext { thisNode => onInput.mapTo(thisNode.ref.value) --> textObserver })\n\n// AFTER\ninput(onInput.mapToValue --> textObserver)\n```\n\n----------------------------------------\n\nTITLE: Transforming User Input with setAsValue in Laminar\nDESCRIPTION: This example shows how to transform user input using the setAsValue operator in Laminar. It filters non-digit characters from a zip code input field and updates both the display and the input field's value, demonstrating an alternative to controlled components for simple input transformations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/uncontrolled-inputs.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval zipVar = Var(\"\")\n\nval app = div(\n  p(\n    label(\"Zip code: \"),\n    input(\n      placeholder(\"12345\"),\n      maxLength(5), // HTML can help block some undesired input\n      onInput\n        .mapToValue\n        .map(_.filter(Character.isDigit))\n        .setAsValue --> zipVar\n    )\n  ),\n  p(\n    \"Your zip code: \",\n    child.text <-- zipVar\n  ),\n  button(\n    onClick.mapTo(zipVar.now()) --> (zip => dom.window.alert(zip)),\n    \"Submit\"\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Event Processors in Laminar (Scala)\nDESCRIPTION: Demonstrates how to create and use reusable event processors in Laminar. This example defines an onEnterPress processor that can be applied to various elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_57\n\nLANGUAGE: scala\nCODE:\n```\n// You can define this once for reusability\nval onEnterPress: EventProcessor[dom.KeyboardEvent, dom.KeyboardEvent] =\n  onKeyPress.filter(_.keyCode == dom.KeyCode.Enter)\n\ninput(onEnterPress --> observer)\n\ntextArea(onEnterPress.preventDefault --> observer)\n\nval changeEventStream = myInputNode.events(onEnterPress)\n```\n\n----------------------------------------\n\nTITLE: Using splitOne to Conditionally Render Different Input Elements in Laminar\nDESCRIPTION: Demonstrates how to use the splitOne operator to conditionally render either an input or textarea element based on an Editor's isMultiLine property, avoiding element recreation when only the text changes.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ncase class Editor(text: Boolean, isMultiLine: Boolean)\n   \ndef renderEditor(\n  isMultiLine: Boolean,\n  initialEditor: Editor,\n  editorSignal: Signal[Editor]\n): HtmlElement = {\n  val tag = if (isMultiLine) textArea else input\n  tag(value <-- editorSignal.map(_.text))\n}\n \nval inputSignal: Signal[Editor] = ???\n \nval outputSignal: Signal[HtmlElement] = \n  inputSignal.split(key = _.isMultiLine)(project = renderEditor)\n```\n\n----------------------------------------\n\nTITLE: Using amend with Custom Components in Laminar\nDESCRIPTION: Demonstrates the pattern of using 'amend' to add behavior to abstracted components in Laminar, showing how to bind reactive variables to input elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval nameVar = Var(\"\")\ndef TextInput(): Input = input(typ := \"text\")\n \ndiv(\n  \"Please enter your name: \",\n  TextInput().amend(onInput --> nameVar)\n)\n```\n\n----------------------------------------\n\nTITLE: Binding Observable Subscription to Element Lifecycle in Scala Laminar\nDESCRIPTION: Example of using onMountCallback to create a subscription to an Observable that will be automatically cleaned up when the element is unmounted. This demonstrates proper subscription ownership tied to element lifecycle.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_77\n\nLANGUAGE: scala\nCODE:\n```\nval observable: Observable[Int] = ???\nval onNext: Int => () = ???\ninput(onMountCallback(ctx => observable.foreach(onNext)(ctx.owner)))\n```\n\n----------------------------------------\n\nTITLE: DOM Node API Update\nDESCRIPTION: Updated DOM API method signature showing the change to accept raw dom.Node instead of Laminar nodes\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-07-13-laminar-v16.0.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nDomApi.isDescendantOf(node.ref, dom.document)\n```\n\n----------------------------------------\n\nTITLE: Reactive Element Binding Implementation in Laminar\nDESCRIPTION: This code shows how Laminar implements binding a value source to an element property under the hood. It creates a binding function that updates the HTML property when the source emits a new value.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_74\n\nLANGUAGE: scala\nCODE:\n```\nReactiveElement.bindFn(element, valueSource) { value =>\n  DomApi.setHtmlProperty(element, this, value)\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Events with Conditional Filtering in Laminar (Scala)\nDESCRIPTION: Shows how to compose click events with a boolean signal to conditionally filter events. This example prevents default behavior and only passes events when allowed.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_59\n\nLANGUAGE: scala\nCODE:\n```\nval allowClick: Signal[Boolean] = ???\n\nbutton(\n  onClick\n    .preventDefault\n    .compose(_.withCurrentValueOf(allowClick).collect { case (ev, true) => ev }) \n    --> eventObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Processors in Laminar (Scala)\nDESCRIPTION: Demonstrates the use of event processors to transform DOM events. It shows how to map click events to integer values and send them to an EventBus.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nval diffBus = new EventBus[Int]\nval incrementButton = button(\"more\", onClick.mapTo(1) --> diffBus)\nval decrementButton = button(\"less\", onClick.mapTo(-1) --> diffBus)\nval diffStream: EventStream[Int] = diffBus.events // emits 1 or -1\n```\n\n----------------------------------------\n\nTITLE: Using flatMapWithStatus for Async Request Handling in Scala\nDESCRIPTION: Demonstrates how to use the flatMapWithStatus operator to track the status of network requests, enabling loading indicators and conditional rendering based on request state.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval requestS: EventStream[Request] = ???\n\ntype Response = String // but it could be something else\n\nval responseS: EventStream[Status[Request, Response]] =\n  requestS.flatMapWithStatus { request =>\n    // returns EventStream[Response]\n    FetchStream.get(request.url, request.options)\n  }\n\nval isLoadingS: EventStream[Boolean] = responseS.map(_.isPending)\n\nval textS: EventStream[String] =\n  responseS.foldStatus(\n    resolved = _.toString,\n    pending = _ => \"Loading...\" \n  )\n\n// Example usage from Laminar:\ndiv(\n  child(img(src(\"spinner.gif\"))) <-- isLoadingS,\n  text <-- textS\n)\n\n// Or, perhaps more realistically:\ndiv(\n  child <-- responseS.splitStatus(\n    (resolved, _) => div(\"Response: \" + resolved.output.toString),\n    (pending, _) => div(img(src(\"spinner.gif\")), \"Loading ...\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Splitting Optional Stream Values in Scala\nDESCRIPTION: Shows how to use splitOption operator to handle Option values in streams with separate handling for empty case.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval modelOptionStream: EventStream[Option[Model]] = ???\nchild <-- modelOptionStream.splitOption(\n  (initialModel, modelSignal) => div(...),\n  ifEmpty = div(\"No model currently\")\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing EventStream in Scala\nDESCRIPTION: This snippet demonstrates the creation of an EventStream that emits a value of 1 and converts it to a Signal with an initial value of 0. This is used as an example to illustrate potential issues with unnecessary restarts in Airstream.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2025-03-26-laminar-v17.2.1.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nEventStream.fromValue(1).toSignal(0)\n```\n\n----------------------------------------\n\nTITLE: Using onMountUnmountCallbackWithState in Scala for Third-Party Library Integration\nDESCRIPTION: Shows how to use onMountUnmountCallbackWithState to maintain state between mount and unmount events. This is useful for integrating with third-party libraries that require setup and cleanup.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_80\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  onMountUnmountCallbackWithState[Div, State]( // need to provide type params explicitly\n    mount = ctx => doStuffAndReturnState(),\n    unmount = (thisNode, maybeState) => maybeState.foreach(cleanupState)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Managing Focus in Laminar Elements\nDESCRIPTION: Shows how to dynamically control focus on elements using Laminar's focus binder. The example demonstrates binding a boolean stream to the focus state of an input element.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nval focusStream: EventStream[Boolean]\ninput(focus <-- focusStream)\n```\n\n----------------------------------------\n\nTITLE: Event Processor Examples in Laminar (Scala)\nDESCRIPTION: Showcases various event processor methods like mapToValue, mapToChecked, preventDefault, and filter. These examples demonstrate how to handle different types of DOM events and transform them.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\ninput(onInput.mapToValue --> textObserver)\n\ninput(typ := \"checkbox\", onClick.mapToChecked --> textObserver)\n\ndiv(\"Click me\", onClick.map(getClickCoordinates) --> clickCoordinatesBus)\n\nform(onSubmit.preventDefault.map(getFormData) --> formSubmitObserver)\n\ndiv(onClick.useCapture --> captureModeClickObserver)\n\ninput(onKeyUp.filter(_.keyCode == dom.KeyCode.Enter).preventDefault --> enterPressBus)\n\ndiv(onClick.collect { case ev if ev.clientX > 100 => \"yes\" } --> yesStringBus)\n\n// @TODO[Docs] Come up with more relatable examples\n```\n\n----------------------------------------\n\nTITLE: Rendering Laminar Application on DOMContentLoaded Event in Scala\nDESCRIPTION: Demonstrates how to render a Laminar application when the DOMContentLoaded event fires. It uses the renderOnDomContentLoaded helper function to delay rendering until the DOM is fully loaded.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject App {\n  def main(args: Array[String]): Unit = {\n    lazy val appContainer = dom.document.querySelector(\"#appContainer\")\n    val appElement = div(h1(\"Hello world\"))\n    renderOnDomContentLoaded(appContainer, appElement)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Prevention and Propagation in Laminar (Scala)\nDESCRIPTION: Demonstrates the use of preventDefault, stopPropagation, and stopImmediatePropagation in Laminar. These methods correspond to native JS DOM event methods.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_52\n\nLANGUAGE: scala\nCODE:\n```\nform(onSubmit.preventDefault.map(getFormData) --> formSubmitObserver)\ndiv(onScroll.stopPropagation.filter(throttle) --> filteredScrollEventBus)\ndiv(\n  onClick.stopImmediatePropagation --> theOnlyClickObserver,\n  onClick --> ignoredObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Optimized Pattern: Sharing Observables in Laminar\nDESCRIPTION: An improved version that shares the computed observable across all instances. This reduces redundant computation and optimizes performance by creating the signal mapping only once.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_105\n\nLANGUAGE: scala\nCODE:\n```\nval renderConfigSignal: Signal[RenderConfig] = ???\nval blocks = Signal[List[DocumentBlock]]\nval renderStyleSignal = renderConfigSignal.map(_.computeStyle) \ndiv(\n  display.flex,\n  flexDirection.column,\n  children <-- blocks.split(_.blockId)((blockId, _, blockSignal) => {\n    input(\n      value <-- blockSignal.combineWithFn(renderStyleSignal)(_ formatWith _),\n      onInput --> ???\n    )\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Using distinct Operators for Signal Filtering in Scala\nDESCRIPTION: Shows various distinct operators available in Airstream 15.0.0 for filtering signal updates using different comparison methods. These operators can be used to replicate pre-15.0.0 behavior or implement custom filtering logic.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nsignal.distinct // performs `==` checks, similar to pre-15.0.0 behaviour\nsignal.distinctBy(_.id) // performs `==` checks on a certain key\nsignal.distinctByRef // performs reference equality checks\nsignal.distinctByFn((prevValue, nextValue) => isSame) // custom checks\nsignal.distinctErrors((prevErr, nextErr) => isSame) // filter errors in the error channel\nsignal.distinctTry((prevTryValue, nextTryValue) => isSame) // one comparator for both event and error channels\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of children.command in Laminar\nDESCRIPTION: Demonstrates the basic setup for using children.command with an EventBus to dynamically add children elements without re-rendering the entire list.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nval commandBus = new EventBus[ChildrenCommand]\nval commandStream = commandBus.events\ndiv(\"Hello, \", children.command <-- commandStream)\n```\n\n----------------------------------------\n\nTITLE: Handling Typed Event Targets in Laminar (Scala)\nDESCRIPTION: Demonstrates techniques for obtaining typed event targets in Laminar. It shows how to use mapToValue and inContext to access properly typed event targets.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\ninput(typ := \"text\", onChange.mapToValue --> inputStringBus)\n\ninput(inContext(thisNode => onChange.mapTo(thisNode.ref.value) --> inputStringBus))\n```\n\n----------------------------------------\n\nTITLE: Integrating Laminar Elements with Third-Party JavaScript Libraries (Scala)\nDESCRIPTION: Shows how to pass Laminar elements to external JavaScript libraries while properly managing their activation and deactivation cycles. Uses renderDetached to control element lifecycle and prevent memory leaks.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_85\n\nLANGUAGE: scala\nCODE:\n```\nval content = div(b(\"Important\"), \" message\")\nJsModalLibrary.renderModal(content.ref)\n```\n\n----------------------------------------\n\nTITLE: Using amendThis to Reduce Boilerplate in Laminar\nDESCRIPTION: Shows how to use 'amendThis' to access the element being modified without nested 'inContext' calls, comparing different approaches to handle input values.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval nameVar = Var(\"\")\ndef TextInput(): Input = input(typ := \"text\")\n\ndiv(\n  // Traditional style\n  TextInput().amend { inContext { thisNode =>\n    onInput.mapTo(thisNode.ref.value) --> nameVar\n  }}\n  // Use amendThis to reduce inContext boilerplate\n  TextInput().amendThis { thisNode =>\n    onInput.mapTo(thisNode.ref.value) --> nameVar  \n  }\n  // But for `ref.value` specifically, just do this:\n  TextInput().amend(\n    onInput.mapToValue --> nameVar\n  )\n)\n\ndiv(\n  // List[Mod[El]] is implicitly converted to Mod[El]\n  // so you can specify several modifiers like this:\n  TextInput().amendThis { thisNode => List(\n    onInput.mapTo(thisNode.ref.value) --> nameVar, // Note: `mapToValue` is easier, does not require thisNode\n    thisNode.events(onClick).delay(0) --> clickObserver  \n  )}\n)\n```\n\n----------------------------------------\n\nTITLE: Using :=> Unit Sinks in Laminar (Scala)\nDESCRIPTION: Shows how to use :=> Unit expressions as sinks for event handling in Laminar. This feature requires a special import and simplifies certain event handling patterns.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.features.unitArrows // enable this feature\ninput(\n  onClick --> println(\"hello\"),\n  onClick --> myVar.update(_.append(\"\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Event Streams with CSS Properties in Laminar\nDESCRIPTION: Demonstrates how to dynamically update CSS properties using event streams. This snippet shows the core pattern of Laminar's reactive programming model where DOM properties automatically update when streams emit new values.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval prettyColorStream: EventStream[String] = ???\nval myDiv: Div = div(color <-- prettyColorStream, \"Hello\")\n```\n\n----------------------------------------\n\nTITLE: Connecting Material UI Slider to Progressive Bar with Reactive Data Flow\nDESCRIPTION: This snippet shows how to connect a Material UI Slider to a Progress Bar using Laminar's reactive state. It demonstrates handling component initialization timing, accessing the web component's native methods, and synchronizing component states.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/web-components.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport website.webcomponents.material.{LinearProgressBar, Slider}\nimport org.scalajs.dom\nimport scala.scalajs.js\n\nval progressVar = Var(0.0)\n\nval app = div(\n  \"Select fraction: \",\n  p(\n    Slider(\n      _.pin := true,\n      _.min := 0,\n      _.max := 20,\n       _ => onMountCallback(ctx => {\n         js.timers.setTimeout(1) {\n           // This component initializes its mdcFoundation asynchronously,\n           // so we need a short delay before accessing .layout() on it.\n           // To clarify, thisNode.ref already exists on mount, but the web component's\n           // implementation of layout() depends on thisNode.ref.mdcFoundation, which is\n           // populated asynchronously for some reason so it's not available on mount.\n           dom.console.log(ctx.thisNode.ref.layout())\n         }\n       }),\n      slider => inContext { thisNode =>\n        slider.onInput.mapTo(thisNode.ref.value / 20) --> progressVar\n      }\n    )\n  ),\n  p(\"You've selected:\"),\n  div(\n    LinearProgressBar(\n      _.progress <-- progressVar.signal\n    )\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Using the new compose method for DOM events in Laminar\nDESCRIPTION: Shows how to use the new compose method to apply reactive operators to DOM events, which is more discoverable than the deprecated composeEvents approach.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  onClick.compose(_.delay(1)) --> observer,\n  onClick\n    .preventDefault\n    .map(getFoo)\n    .compose(_.filter(isGoodFoo).startWith(initialFoo)) --> observer,\n)\n```\n\n----------------------------------------\n\nTITLE: Using child.maybe for optional element rendering in Laminar\nDESCRIPTION: Shows how to use the child.maybe modifier to conditionally render elements based on an Option signal, which renders nothing when the signal emits None.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval maybeBlogLink: Signal[Option[HtmlElement]] = ???\ndiv(\n  child.maybe <-- maybeBlogLink\n)\n```\n\n----------------------------------------\n\nTITLE: Using simplified Unit arrow syntax for event handling in Laminar\nDESCRIPTION: Shows the new, more concise event handling syntax that accepts Unit expressions which are re-evaluated on every event, reducing boilerplate for common event handling patterns.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.features.unitArrows // enable this feature\ninput(\n  onClick --> println(\"hello\"),\n  onClick --> myVar.update(_.append(\"\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Forms Without Vars in Laminar\nDESCRIPTION: This snippet demonstrates how to work with form inputs without using Var state containers by directly accessing DOM element references. It creates a form with a zip code input that filters non-digit characters and submits the current input value when the form is submitted.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/examples/uncontrolled-inputs.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval inputEl = input(\n  placeholder(\"12345\"),\n  maxLength(5), // HTML can help block some undesired input\n  onInput\n    .mapToValue\n    .map(_.filter(Character.isDigit))\n    .setAsValue --> Observer.empty\n)\n\nval app = div(\n  form(\n    onSubmit\n      .preventDefault\n      .mapTo(inputEl.ref.value) --> (zip => dom.window.alert(zip)),\n    p(\n      label(\"Zip code: \"),\n      inputEl\n    ),\n    p(\n      button(typ(\"submit\"), \"Submit\")\n    )\n  )\n)\n\nrender(containerNode, app)\n```\n\n----------------------------------------\n\nTITLE: Using compose with DOM events in Laminar\nDESCRIPTION: Demonstrates different approaches to apply reactive operators to DOM events, including the improved compose method that makes reactive transformation more discoverable and intuitive.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  onClick.delay(1) --> observer, // does not compile\n  inContext(_.events(onClick).delay(1) --> observer),\n  composeEvents(onClick)(_.delay(1)) --> observer\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Hello Component with Dynamic Styling\nDESCRIPTION: Shows how to create a reusable component function that accepts streams for dynamic content and styling.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef Hello(\n  helloNameStream: EventStream[String],\n  helloColorStream: EventStream[String]\n): Div = {\n  div(\n    fontSize := \"20px\", // static CSS property\n    color <-- helloColorStream, // dynamic CSS property\n    strong(\"Hello, \"), // static child element with a grandchild text node\n    child.text <-- helloNameStream // dynamic child (text node in this case)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using element.events in Laminar (Scala)\nDESCRIPTION: Shows how to use the element.events method to create event streams from component elements. This allows for flexible composition of events without tight coupling.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_56\n\nLANGUAGE: scala\nCODE:\n```\nval textInput = TextInput(\"Full name:\")\nval changeEventStream: EventStream[dom.Event] =\n  textInput.inputNode.events(onChange)\nval changeObserver: Observer[dom.Event] = ???\n\ndiv(\"Hello\", changeEventStream --> changeObserver)\n```\n\n----------------------------------------\n\nTITLE: Using DerivedVar with Updated zoomOut Parameter in Airstream (Scala)\nDESCRIPTION: Shows the migration path for using DerivedVar.zoomOut with its updated parameter structure that now provides the parent variable's value.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nparentVar.zoom(in)((parentValue, derivedValue) => out(derivedValue))\n```\n\n----------------------------------------\n\nTITLE: Using flatMap with DOM events in Laminar\nDESCRIPTION: Demonstrates the new flatMap method for DOM events which allows creating a new observable on every DOM event, useful for scenarios like AJAX requests triggered by user input.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef makeAjaxRequest(): EventStream[Response] = ???\n\ninput(\n  onInput\n    .mapToValue\n    .flatMap(txt => makeAjaxRequest(txt)) --> observer\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating third-party DOM elements in Laminar\nDESCRIPTION: Shows how to wrap third-party DOM elements with Laminar functionality using the new foreignHtmlElement helper, allowing the addition of event listeners and dynamic property updates.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef getThirdPartyMapWidget(): dom.html.Element = ???\n\ndiv(\n  foreignHtmlElement(getThirdPartyMapWidget()),\n  // And this is how you add modifiers in the same breath:\n  foreignHtmlElement(getThirdPartyMapWidget()).amend(\n    onMountCallback {\n      thirdPartyLibraryInitMap()\n    },\n    onClick --> someObserver,\n    onResize --> someOtherObserver\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Reusing Event Processors in Laminar (Scala)\nDESCRIPTION: Illustrates how to create reusable event processors in Laminar. This example defines an onEnterKeyUp processor that can be applied to multiple elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_51\n\nLANGUAGE: scala\nCODE:\n```\nval onEnterKeyUp = onKeyUp.filter(_.keyCode == dom.KeyCode.Enter)\n// and then\ninput(onEnterKeyUp.preventDefault --> enterPressBus)\ntextArea(onEnterKeyUp.preventDefault --> enterPressBus)\n```\n\n----------------------------------------\n\nTITLE: Efficient dynamic text rendering in Laminar\nDESCRIPTION: Shows the recommended approach for rendering dynamic text using the text modifier, which efficiently updates text content without creating new DOM elements.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nval textStream: EventStream[String] = ???\ndiv(text <-- textStream)\ndiv(child.text <-- textStream) // Same thing, original name from before v17\n```\n\n----------------------------------------\n\nTITLE: Customizing text rendering with RenderableText in Laminar\nDESCRIPTION: Demonstrates how to define custom rendering for different types using RenderableText implicits. This allows for formatted display of primitive types and custom class instances.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val intRenderable0000: RenderableText[Int] = RenderableText(\"%04d\".format(_))\n\nclass Foo { ... }\nimplicit val fooRenderable: RenderableText[Foo] = RenderableText(fooToString)\n\ndiv(\n  // will render as \"true\" or \"false\" using built-in bool renderable implicit\n  true,\n  text <-- streamOfBooleans,\n  \n  // will render numbers with leading zeroes (e.g. \"0001\") because of `intRenderable0000`\n  1,\n  text <-- streamOfInts\n  \n  // will render Foo-s to string using `fooRenderable`\n  new Foo {},\n  text <-- streamOfFoos\n)\n```\n\n----------------------------------------\n\nTITLE: Uncontrolled Input with Value Transformation in Laminar (Scala)\nDESCRIPTION: Demonstrates how to handle user input transformation without using controlled inputs, using the `setAsValue` event processor to filter for digit characters.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_64\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  placeholder := \"Enter zip code: \",\n  onInput\n    .mapToValue\n    .map(_.filter(Character.isDigit))\n    .setAsValue --> zipValueObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Operator with Custom Distinction in Laminar\nDESCRIPTION: Demonstrates how to use the split operator with a custom distinction function in Laminar 15.0.0. The split operator now includes a distinctCompose parameter to control how values are compared for change detection.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nchildren <-- nodesStream.split(_.id, _.distinctByFn(customComparator))(...)\n```\n\n----------------------------------------\n\nTITLE: Using inContext for Element Self-Reference in Laminar\nDESCRIPTION: Demonstrates how to use the 'inContext' modifier to obtain a reference to the element being modified before deciding which modifiers to apply to it.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndiv(inContext(thisNode => onClick.mapTo(getCoordinates(thisNode)) --> bus))\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Event Listeners in Laminar (Scala)\nDESCRIPTION: Shows how to register multiple event listeners for the same event type on a single element, allowing for separate handling of the same events.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_61\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick --> clickBus1, onClick --> clickBus2, \"Click me\")\n```\n\n----------------------------------------\n\nTITLE: Registering DOM Event Listener in Laminar (Scala)\nDESCRIPTION: Demonstrates how to register a simple DOM event listener in Laminar using an Observer. The example shows a click event listener that logs the mouse X coordinate to the console.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nval clickObserver = Observer[dom.MouseEvent](onNext = ev => dom.console.log(ev.screenX))\nval element: Div = div(\n  onClick --> clickObserver,\n  \"Click me\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Controlled Input with Input Validation in Laminar\nDESCRIPTION: This code snippet demonstrates how to create a controlled input element in Laminar that filters user input. It shows a ZIP code input that only accepts digit characters, preventing invalid input and resetting to the last valid value.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-07-10-laminar-v-0.13.1.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  controlled(\n    value <-- stateVar.signal.map(_.zip),\n    onInput.mapToValue.filter(_.forall(Character.isDigit)) --> zipWriter\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using onMountInsert in Scala for Dynamic Child Insertion\nDESCRIPTION: Demonstrates the usage of onMountInsert for dynamically inserting children into an element. This method is useful when you need MountContext to insert children or when you want to insert children only on mount.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_83\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  \"Hello, \",\n  onMountInsert { ctx =>\n    val childStream: EventStream[Span] = makeStream(ctx.owner)    \n    child <-- childStream\n  },\n  \"!\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using CSS Keyword Helpers in Laminar\nDESCRIPTION: Shows how to use Laminar's CSS keyword helpers to set style properties with proper values through a type-safe API, improving developer experience with autocompletion support.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_68\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  fontSize.inherit, // same as `fontSize := \"inherit\"`\n  display.none, // same as `display := \"none\"`\n  flexDirection.column // same as `flexDirection := \"column\"`\n)\n```\n\n----------------------------------------\n\nTITLE: Status Tracking Types for Async Operations in Scala\nDESCRIPTION: Defines the Status sealed trait hierarchy used for tracking the state of asynchronous operations, including Pending and Resolved states that contain both input and output values.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Status[+In, +Out] { /* ... */ }\ncase class Pending[+In](input: In) extends Status[In, Nothing] { /* ... */ }\ncase class Resolved[+In, +Out](input: In, output: Out, ix: Int) extends Status[In, Out] { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Using CSS Unit and Function Helpers in Laminar\nDESCRIPTION: Demonstrates Laminar's CSS unit helpers for setting length values with proper units, including reactive binding support and calculation expressions.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_70\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  margin.px := 12,\n  marginTop.px := 12,\n  marginTop.px(12), // remember that all `:=` methods in Laminar are aliased to `apply` for convenience!\n  marginTop.calc(\"12px + 50%\"),\n  marginTop.px <-- streamOfInts,\n  marginTop.px <-- streamOfDoubles\n)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Subscription Implementation in Laminar\nDESCRIPTION: This snippet shows the implementation details of how Laminar creates a dynamic subscription between a stream and an element property. It creates a subscription that activates when the element is mounted and deactivates when unmounted.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_75\n\nLANGUAGE: scala\nCODE:\n```\nnew DynamicSubscription(element.dynamicOwner, activate = owner => Some(\n  val subscription: Subscription = urlStream.foreach { url =>\n    DomApi.setHtmlProperty(element, href, url)\n  } (owner)\n  subscription\n))\n```\n\n----------------------------------------\n\nTITLE: Applying Modifiers to Existing Elements with amend\nDESCRIPTION: Shows how to add modifiers to an already existing element using the 'amend' method, which returns the element itself allowing for method chaining.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval el = div(\"Hello\")\n \nel.amend(\n  color := \"red\",\n  span(\"a new child!\")\n)\n```\n\n----------------------------------------\n\nTITLE: Splitting Var Collections in Laminar with Airstream\nDESCRIPTION: This example demonstrates how to split a Var containing a List of Users into individual Vars that remain linked to the original collection. When the user types a new name in the input box, both the individual Var and the collection Var are updated automatically.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-08-14-laminar-v17.1.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(id: String, name: String)\nval usersVar = Var[List[User]](???)\n\ndiv(\n  usersVar.split(_.id)((userId, initial, userVar) => {\n    div(\n      s\"User ${userId}: \",\n      input(\n        value <-- userVar.signal.map(_.name),\n        onInput.mapToValue --> { newName =>\n          userVar.update(_.copy(name = newName))\n        }\n      )\n    )\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering Laminar Application on Window Load Event in Scala\nDESCRIPTION: Shows how to delay rendering a Laminar application until the window.load event fires, which ensures all resources including images and iframes are loaded. It uses windowEvents to listen for the load event.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject App {\n  def main(args: Array[String]): Unit = {\n    windowEvents(_.onLoad).foreach { _ =>\n      val appContainer = dom.document.querySelector(\"#appContainer\")\n      val appElement = div(h1(\"Hello world\"))\n      render(appContainer, appElement)\n    }(unsafeWindowOwner)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Derived Vars with Bidirectional Transformations in Scala\nDESCRIPTION: Example of creating a derived Var that maintains a bidirectional mapping between two representations of data (one-based and zero-based indices). This requires both transformation functions and an owner parameter for memory safety.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val owner: Owner // usually you get this from ctx in Laminar's onMount* methods\nval oneBasedIndex = Var(1)\nval zeroBasedIndex = oneBasedIndex.zoom(_ - 1)(_ + 1)(owner)\n\noneBasedIndex.set(10)\noneBasedIndex.now() // 10\nzeroBasedIndex.now() // 9\n\nzeroBasedIndex.set(20)\noneBasedIndex.now() // 20\nzeroBasedIndex.now() // 19\n```\n\n----------------------------------------\n\nTITLE: Parsing SVG and HTML strings in Laminar\nDESCRIPTION: Demonstrates how to use the unsafe parsing methods to convert SVG and HTML strings into DOM elements that can be incorporated into Laminar. Includes important security warnings about XSS vulnerabilities.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  foreignSvgElement(DomApi.unsafeParseSvgString(\"<svg>....</svg>\")),\n  // And similarly for HTML elements:\n  foreignHtmlElement(DomApi.unsafeParseHtmlString(\"<div onclick=\\\"alert('pwned')\\\"></div>\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing onMountBind in Scala for Dynamic Subscription Management\nDESCRIPTION: Demonstrates the use of onMountBind for managing dynamic subscriptions. This method ensures that subscriptions are properly cleaned up on unmount, preventing accumulation of multiple subscriptions.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_81\n\nLANGUAGE: scala\nCODE:\n```\nval observer: Observer[dom.MouseEvent] = ???\ndiv(\n  onMountBind(ctx => {\n    doSomething(ctx) // let's assume we need this for some reason \n    onClick --> observer\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled Inputs in Laminar (Scala)\nDESCRIPTION: Shows the new approach for creating controlled inputs in Laminar, using the controlled function to wrap value updater and input listener.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval inputState = Var(\"\")\ninput(\n  controlled(\n    value <-- inputState.signal,\n    inContext { thisNode => onInput.mapTo(thisNode.ref.value) --> inputState }\n  ),\n  // ... other mods, if any\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing onUnmountCallback and onMountUnmountCallback in Scala\nDESCRIPTION: Demonstrates the usage of onUnmountCallback and onMountUnmountCallback for handling mount and unmount events in Laminar. These callbacks allow executing code when an element is mounted or unmounted.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_79\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  onUnmountCallback(thisNode => println(\"unmounting\")),\n  onMountUnmountCallback(\n    mount = ctx => println(\"mounting\"),\n    unmount = thisNode => println(\"unmounting\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Capture Mode for Events in Laminar (Scala)\nDESCRIPTION: Shows how to use the useCapture event processor in Laminar. This enables capture mode for event listeners, which affects event priority and ordering.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick.useCapture --> captureModeClickObserver)\n```\n\n----------------------------------------\n\nTITLE: Splitting Stream by Index in Scala\nDESCRIPTION: Demonstrates usage of splitByIndex operator to render dynamic collections using index as key when no natural ID is available.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval modelsStream: EventStream[List[Model]] = ???\nchildren <-- modelsStream.splitByIndex((ix, initialModel, modelSignal) => div(...))\n```\n\n----------------------------------------\n\nTITLE: Using CSS unit helpers in Laminar\nDESCRIPTION: Shows the improved CSS styling API which provides type-safe unit helpers (px, vh, percent, etc.) for style properties, reducing the need to manually append unit strings to values.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  margin.px := 12,\n  marginTop.px := 12,\n  marginTop.px(12), // remember that all `:=` methods in Laminar are aliased to `apply` for convenience!\n  marginTop.calc(\"12px + 50%\"),\n  marginTop.px <-- streamOfInts,\n  marginTop.px <-- streamOfDoubles\n)\n```\n\n----------------------------------------\n\nTITLE: Element Reuse with Signal Binding in Scala\nDESCRIPTION: Shows how a Laminar element is saved in a variable and reused conditionally based on a boolean signal. This pattern is specifically affected by the new signal re-sync behavior in Airstream v15.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval boolSignal: Signal[Boolean] = ???\nval parentSignal: Signal[String] = ???\nval warningElement = div(\n  h1(\"The yeti is onto us!\"),\n  child.text <-- parentSignal.map(_.toUpperCase)\n)\ndiv(\n  child <-- boolSignal.map(if (_) warningElement else emptyNode)\n)\n```\n\n----------------------------------------\n\nTITLE: Using CSS Keyword Values in Reactive Streams\nDESCRIPTION: Shows how to use CSS keyword values within reactive streams, demonstrating both manual string values and referenced constants for type safety.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_69\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  // You can spell out the values manually...\n  textAlign <-- streamOfBooleans.map(\n    if (_) \"left\" else \"right\"\n  ),\n  // Or refer to defined constants:\n  textAlign <-- streamOfBooleans.map(\n    if (_) textAlign.left.value else textAlign.right.value\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Complete Modal Integration Pattern with Lifecycle Control (Scala)\nDESCRIPTION: Shows a complete pattern for integrating Laminar elements with modal dialogs from JavaScript libraries, with proper subscription activation and cleanup to prevent memory leaks.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_87\n\nLANGUAGE: scala\nCODE:\n```\nval contentRoot: DetachedRoot[Div] = renderDetached(\n  content, // Laminar element\n  activateNow = false // !!! see activation code below\n)\n\ndef openModal() {\n  JsModalLibrary.renderModal(\n    contentRoot.ref,\n    onClose = contentRoot.deactivate // !!!\n  )\n  // re-activate subscriptions every time the modal is opened\n  contentRoot.activate()\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Child Count with children.command in Laminar\nDESCRIPTION: Demonstrates how to maintain a count of children when using children.command by scanning the command stream, useful when you need to display metadata about dynamically added children.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nval commandBus = new EventBus[ChildrenCommand.Append[HtmlElement]]\nval commandStream = commandBus.events\nval countSignal = commandStream.scanLeft(initial = 0)(_ + 1)\n\ndiv(\n  \"Hello, \",\n  children.command <-- commandStream,\n  button(\n    \"Add a child\",\n    onClick.map( _ => CollectionCommand.Append(span(s\"Just another child\"))) --> commandBus),\n  div(\n    \"Number of children: \",\n    text <-- countSignal.map(_.toString)    \n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Parent-Child Signal Relationship Example in Scala\nDESCRIPTION: Demonstrates how parent and child signals interact, with the child signal deriving its value from the parent signal. This example shows the relationship that's impacted by the new re-sync behavior in Airstream v15.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval parentSignal: Signal[Foo] = ???\nval childSignal: Signal[Bar] = parentSignal.map(fooToBar)\n\nspan(\n  backgroundColor <-- childSignal.map(bar => bar.color)\n)\n```\n\n----------------------------------------\n\nTITLE: Using CSS function helpers in Laminar\nDESCRIPTION: Demonstrates the type-safe CSS function helpers like url() for appropriate style properties, enabling more readable and safer CSS styling in Laminar components.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndiv\n  // Equivalent to CSS:  background-image: url(\"https://example.com/image.png\")\n  backgroundImage.url := \"https://example.com/image.png\",\n  backgroundImage.url(\"https://example.com/image.png\"), // same\n  backgroundImage.url <-- streamOfUrls\n)\n```\n\n----------------------------------------\n\nTITLE: Using JSImportSideEffect for CSS in Scala.js with Combined Vite Plugins\nDESCRIPTION: Shows how to use both the import-side-effect and glob-resolver Vite plugins together to cleanly import CSS files in Scala.js without warnings or double-loading in production builds.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-11-02-laminar-full-stack-demo.md#2025-04-20_snippet_1\n\nLANGUAGE: Scala.js\nCODE:\n```\nJSImportSideEffect(\"@find/**/ComponentName.css\")\n```\n\n----------------------------------------\n\nTITLE: Applying Event Filters and Transformations in Scala\nDESCRIPTION: This code demonstrates the correct order of applying filters and transformations to events in Laminar v0.11.0, ensuring that preventDefault and stopPropagation are applied conditionally.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nonKeyPress.filter(_.keyCode == KeyCodes.Enter).preventDefault.mapTo(thisNode.ref.value) --> observer\n```\n\n----------------------------------------\n\nTITLE: Transforming Vars with Isomorphic Mapping in Scala\nDESCRIPTION: Demonstrates how to bidirectionally transform a Var using bimap to convert between different representations while maintaining two-way synchronization. The example shows conversion between a Foo object and its JSON representation.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-12-13-laminar-v17.2.0.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval fooVar: Var[Foo] = Var(Foo(123, \"yo\"))\nval jsonVar: Var[String] = fooVar.bimap(getThis = Foo.toJson)(getParent = Foo.fromJson)\n```\n\n----------------------------------------\n\nTITLE: Using CSS URL Function Helper in Laminar\nDESCRIPTION: Shows how to use Laminar's type-safe URL function helper for CSS properties that accept URLs, simplifying the syntax required for background images.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_71\n\nLANGUAGE: scala\nCODE:\n```\ndiv\n  // Equivalent to CSS:  background-image: url(\"https://example.com/image.png\")\n  backgroundImage := \"\"\"url(\"https://example.com/image.png\")\"\"\",\n  backgroundImage.url := \"https://example.com/image.png\",\n  backgroundImage.url(\"https://example.com/image.png\"), // same\n  backgroundImage.url <-- streamOfUrls\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering Third-Party HTML and SVG Elements in Laminar (Scala)\nDESCRIPTION: Shows how to integrate DOM elements created by external libraries into Laminar's element hierarchy using foreignHtmlElement and foreignSvgElement, including how to modify them with Laminar operations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_88\n\nLANGUAGE: scala\nCODE:\n```\n// Render in Laminar\ndiv(foreignSvgElement(myJsSvgElement))\n\n// Modify the element before rendering:\ndiv(\n  foreignHtmlElement(myJsHtmlElement).amend(\n    onClick --> ???,\n    aria.labelledBy := ???,\n    span(\"Add new child\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Traditional event handling patterns in Laminar\nDESCRIPTION: Demonstrates various existing approaches to handling events in Laminar using Observers, Vars, and function callbacks, highlighting some of the verbosity that can occur.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  onInput.mapToValue --> myVar.updater(_ :+ _),\n  onInput.mapToValue.map(_.toInt) --> intObserver,\n  onInput.mapToValue --> intObserver.contramap[Int](_.toInt),\n  onClick --> { _ => println(\"hello\") },\n  onClick.mapTo(\"hello\") --> println\n)\n```\n\n----------------------------------------\n\nTITLE: Advanced Input Box Component with Node Exposure\nDESCRIPTION: Shows an alternative component pattern that exposes internal nodes for more flexible event handling.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass InputBox private (\n  val node: Div,\n  val inputNode: Input\n)\n\nobject InputBox {\n  def apply(caption: String): InputBox = {\n    val inputNode = input(typ := \"text\")\n    val node = div(caption, inputNode)\n    new InputBox(node, inputNode)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Operator Duplicate Key Warnings\nDESCRIPTION: Examples of configuring duplicate key warning behavior globally and per-instance for split operator.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\n// Disable duplicate key warnings by default\nDuplicateKeysConfig.setDefault(DuplicateKeysConfig.noWarnings)\n\n// Disable warnings for just one split observable\nstream.split(_.id, duplicateKeys = DuplicateKeysConfig.noWarnings)(...)\n```\n\n----------------------------------------\n\nTITLE: Complex Pattern Match Split Example in Scala\nDESCRIPTION: Demonstrates splitting Observable[Seq[ADT]] for handling different item types in a collection, with separate rendering for each type.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-12-13-laminar-v17.2.0.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Item { val id: String }\ncase class Stock(ticker: String, currency: String, value: Double) {\n  override val id: String = ticker\n}\ncase class FxRate(currency1: String, currency2: String, rate: Double) {\n  override val id: String = currency1 + \"-\" + currency2 \n}\n\nval itemsSignal: Signal[Seq[Item]] = ???\nval elementsSignal: Signal[Seq[HtmlElement]] =\n  modelsSignal\n    .splitMatchSeq(_.id)\n    .handleType[Stock] { (initialStock, stockSignal) =>\n      div(\n        initialStock.id + \": \",\n        text <-- stockSignal.map(_.value),\n        \" \" + initialStock.currency\n      )\n    }\n    .handleType[FxRate] { (initialRate, rateSignal) =>\n      div(initialRate.id, \": \", text <-- rateSignal.map(_.rate))\n    }\n    .toSignal\n\nchildren <-- elementsSignal // in Laminar\n```\n\n----------------------------------------\n\nTITLE: Managing Detached Laminar Elements with Dynamic Content (Scala)\nDESCRIPTION: Demonstrates the proper way to handle Laminar elements with event handlers when passing them to external libraries, including proper lifecycle management with renderDetached and manual activation/deactivation.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_86\n\nLANGUAGE: scala\nCODE:\n```\nval content = div(\n  b(\"Important\"), \" message\",\n  button(onClick --> { _ => dom.console.log(\"click\") }, \"Log\")\n)\n\nval contentRoot: DetachedRoot[Div] = renderDetached(\n  content,\n  activateNow = true\n)\n\nJsModalLibrary.renderModal(contentRoot.ref)\n```\n\n----------------------------------------\n\nTITLE: Using Advanced Input Box Component\nDESCRIPTION: Demonstrates how to use the advanced input box component with custom event handling and stream composition.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/quick-start.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.{*, given}\nimport org.scalajs.dom\n\nval inputBox = InputBox(\"Please enter your name:\")\n\nval nameStream = inputBox.inputNode\n  .events(onInput)\n  .mapTo(inputBox.inputNode.ref.value)\n\nval colorStream = nameStream.map { name =>\n  if (name == \"Sebastien\") \"red\" else \"unset\"\n}\n\nval appDiv: Div = div(\n  h1(\"User Welcomer 9000\"),\n  div(\n    \"Please enter your name:\",\n    inputBox.node,\n  ),\n  div(\n    \"Please accept our greeting: \",\n    Hello(nameStream, colorStream)\n  )\n)\n\nrender(dom.document.querySelector(\"#appContainer\"), appDiv)\n```\n\n----------------------------------------\n\nTITLE: Using CSS Vendor Prefixes in Laminar\nDESCRIPTION: Demonstrates how to apply vendor prefixes to CSS properties in Laminar, allowing cross-browser compatibility for properties that may require prefixes.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_72\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  transition.withPrefixes(_.moz, _.ms, _.webkit) := \"all 4s ease\"\n  // and similarly for `<--`.\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing LocalStorage Var in Scala\nDESCRIPTION: Creates a persistent boolean variable backed by browser's LocalStorage with a specified key and default value. This allows state persistence across browser sessions and tabs synchronization.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-12-13-laminar-v17.2.0.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval showSidebarVar: WebStorageVar[Boolean] =\n  WebStorageVar\n    .localStorage(key = \"showSidebar\", syncOwner = None)\n    .bool(default = true)\n```\n\n----------------------------------------\n\nTITLE: Alternative Element Self-Reference Methods in Laminar\nDESCRIPTION: Shows alternative ways to obtain a reference to an element without using 'inContext', including type ascription and separate creation with amend.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n// Make sure to write out the type ascription\nval thisNode: Div = div(onClick.mapTo(getCoordinates(thisNode)) --> bus)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval thisNode = div()\nthisNode.amend(\n  thisNode.events(onClick).mapTo(getCoordinates(thisNode)) --> bus\n)\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML and SVG Elements in Laminar\nDESCRIPTION: Demonstrates how to parse HTML and SVG strings into DOM elements using Laminar's unsafe parse methods. Includes warning about XSS security risks.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_89\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  // SVG elements:\n  foreignSvgElement(DomApi.unsafeParseSvgString(\"<svg>....</svg>\")),\n  // HTML elements:\n  foreignHtmlElement(DomApi.unsafeParseHtmlString(\"<div onclick=\\\"alert('pwned')\\\"></div>\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Importing CSS in Scala.js Using JSImport with Vite Plugin\nDESCRIPTION: Demonstrates how to use the new Vite plugins to import CSS files in Scala.js, working around limitations in relative path importing and side-effect imports. Shows the syntax using JSImport with the glob-resolver plugin.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-11-02-laminar-full-stack-demo.md#2025-04-20_snippet_0\n\nLANGUAGE: Scala.js\nCODE:\n```\nJSImport(\"@find/**/ComponentName.css\")\n```\n\n----------------------------------------\n\nTITLE: Legitimate Use of flatMap with Ajax Requests in Scala\nDESCRIPTION: Demonstrates a valid use case for flatMap when dealing with asynchronous operations like AJAX requests.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_95\n\nLANGUAGE: scala\nCODE:\n```\nval responseStream = stream.flatMap(request => AjaxStream.get(request.url))\n```\n\n----------------------------------------\n\nTITLE: Simplified Controlled Input in Laminar (Scala)\nDESCRIPTION: Demonstrates a more concise way to create controlled inputs in Laminar using new features in v0.12.0.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  controlled(\n    value <-- inputState,\n    onInput.mapToValue --> inputState\n  ),\n  // ... other mods, if any\n)\n```\n\n----------------------------------------\n\nTITLE: Managing Class Names in Laminar (Scala)\nDESCRIPTION: Demonstrates how to use multiple cls modifiers on an element, showcasing Laminar's improved handling of overlapping class names.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ninput(\n  cls := \"TextInput\",\n  cls <-- streamOfClasses\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty DOM Nodes in Laminar\nDESCRIPTION: Demonstrates how to create an empty DOM node using Laminar's 'emptyNode', which returns an empty HTML comment node of type CommentNode.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval node: Node = if (foo) element else emptyNode\n```\n\n----------------------------------------\n\nTITLE: Signal Changes Streams with Shared Transactions in Scala\nDESCRIPTION: Illustrates how multiple .changes streams derived from the same parent signal can emit in the same transaction when re-syncing. This shared transaction behavior is new in Airstream v15 and affects element reuse patterns.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  parentSignal.changes.map(foo) --> fooObserver,\n  parentSignal.changes.flatMap(_ => EventStream.fromValue(bar)) --> barObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Updated approach to window and document events in Laminar\nDESCRIPTION: Demonstrates the new API for accessing window and document events, which allows more flexibility in specifying event processors.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nwindowEvents(_.onPopState) // EventStream[dom.PopStateEvent]\ndocumentEvents(_.onClick) // EventStream[dom.MouseEvent]\n```\n\n----------------------------------------\n\nTITLE: Converting Observable to Signal or Stream in Scala\nDESCRIPTION: This code demonstrates new convenience methods in Airstream v0.11.0 for refining Observables into EventStream or Signal.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nObservable#toSignal(initialIfStream) and Observable#toStreamOrSignalChanges\n```\n\n----------------------------------------\n\nTITLE: Adding Laminar Dependencies - Scala.js Build Configuration\nDESCRIPTION: SBT build configuration showing how to add Laminar and its dependencies to a Scala.js project. Includes optional Airstream dependency for version flexibility.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n\"com.raquo\" %%% \"laminar\" % \"<version>\"  // Requires recent Scala.js\n\n\"com.raquo\" %%% \"airstream\" % \"<version>\"\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Event Sources in Scala using CustomStreamSource\nDESCRIPTION: Implementation of a DOM event stream using the new CustomStreamSource functionality, which provides hooks for initialization and cleanup of event sources. This approach avoids the need to subclass EventStream directly.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef apply[Ev <: dom.Event](\n  eventTarget: dom.EventTarget,\n  eventKey: String,\n  useCapture: Boolean = false\n): EventStream[Ev] = {\n\n  CustomStreamSource[Ev]( (fireValue, fireError, getStartIndex, getIsStarted) => {\n\n    val eventHandler: js.Function1[Ev, Unit] = fireValue\n\n    CustomSource.Config(\n      onStart = () => {\n        eventTarget.addEventListener(eventKey, eventHandler, useCapture)\n      },\n      onStop = () => {\n        eventTarget.removeEventListener(eventKey, eventHandler, useCapture)\n      }\n    )\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using event processors with window and document events in Laminar\nDESCRIPTION: Shows how to use event processors with the new window and document event API, allowing for more complex event handling configurations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndocumentEvents(_.onClick.useCapture.preventDefault)\n```\n\n----------------------------------------\n\nTITLE: HTML Attribute Setting Implementation in Laminar\nDESCRIPTION: Shows the low-level implementation of how Laminar sets HTML attributes on DOM elements, demonstrating direct DOM manipulation without Virtual DOM overhead.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/virtual-dom.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n  def setHtmlAttribute[V](element: ReactiveHtmlElement.Base, attr: HtmlAttr[V], value: V): Unit = {\n    val domValue = attr.codec.encode(value)\n    if (domValue == null) { // End users should use `removeAttribute` instead. This is to support boolean attributes.\n      removeHtmlAttribute(element, attr)\n    } else {\n      element.ref.setAttribute(attr.name, domValue.toString)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Inefficient Element Creation with Signals in Scala\nDESCRIPTION: Shows an inefficient approach to updating DOM elements by recreating them on each signal emission.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_96\n\nLANGUAGE: scala\nCODE:\n```\nval userSignal: Signal[User] = ???\ndiv(\n  child <-- userSignal.map(user => span(color := user.prefColor, user.name))\n)\n```\n\n----------------------------------------\n\nTITLE: FilterWith Stream Operator Usage\nDESCRIPTION: Example of using filterWith operator to conditionally filter stream events based on a signal value.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick.compose(_.filterWith(clickEnabledVar)) --> observer)\n```\n\n----------------------------------------\n\nTITLE: Rendering SVG Elements in Laminar with SVG Context\nDESCRIPTION: Shows an alternative import pattern for SVG-heavy files, allowing direct access to SVG elements and attributes without the svg prefix while accessing HTML elements through the L prefix.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_66\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.api.L.svg.* // get svg keys without the svg prefix\nimport com.raquo.laminar.api.{*, given} // get `L` and standard implicits like `textToTextNode`\n// DO NOT IMPORT: com.raquo.laminar.api.L.{*, given}\n\nL.div(\n  L.className := \"someHtmlClassName\",\n  L.onClick --> ???,\n  svg(\n    height := \"800\",\n    width := \"500\",\n    polyline(\n      points := \"20,20 40,25 60,40\",\n      className := \"someSvgClassName\",\n      L.onClick --> ???,\n      L.children <-- ???\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Element Events with Transformations in Scala\nDESCRIPTION: Example demonstrating the new ReactiveElement.events method with EventPropTransformation, allowing event handling with additional transformations like useCapture and preventDefault.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndiv(...).events(onClick.useCapture.preventDefault)\n```\n\n----------------------------------------\n\nTITLE: Using Child Integer Receiver in Scala\nDESCRIPTION: This snippet shows the new convenience method for handling integer child nodes in Laminar v0.11.0.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nchild.int <-- observableOfInt\n```\n\n----------------------------------------\n\nTITLE: CollectSome and CollectOpt Operators\nDESCRIPTION: Usage examples of collectSome and collectOpt operators for handling Option and collection transformations.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nval stream: EventStream[Option[A]] = ???\nstream.collectSome // EventStream[A]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stream: EventStream[List[A]]\nstreamOfList.collectOpt(NonEmptyList.from) // EventStream[NonEmptyList[A]]\n// Note: NonEmptyList.from(list) returns Option[NonEmptyList[A]]\n```\n\n----------------------------------------\n\nTITLE: Rendering External SVG Images in Laminar\nDESCRIPTION: Demonstrates how to load external SVG files as images, allowing for network optimization but requiring accessibility considerations for screen readers.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_67\n\nLANGUAGE: scala\nCODE:\n```\nimg(src := \"https://example.com/image.svg\", role := \"img\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Composite Attribute Toggle in Laminar (Scala)\nDESCRIPTION: This snippet shows how to easily toggle composite attribute values in Laminar, specifically for class attributes.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncls.toggle(\"class1\") := true\n```\n\nLANGUAGE: scala\nCODE:\n```\ncls.toggle(\"class1\") <-- $bool\n```\n\n----------------------------------------\n\nTITLE: Accessing Owned Signal from Signal Observation\nDESCRIPTION: Example of how to access the OwnedSignal interface that now extends StrictSignal. The killOriginalSubscription method was moved from StrictSignal to this new subclass, and is now returned by the observe method.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nsignal.observe(owner) // Now returns an OwnedSignal\n```\n\n----------------------------------------\n\nTITLE: File Upload Handling with mapToFiles in Laminar (Scala)\nDESCRIPTION: Example showing how to use the new mapToFiles event processor to handle file uploads in a form input.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ninput(typ(\"file\"), onChange.mapToFiles --> filesObserver))\n```\n\n----------------------------------------\n\nTITLE: Using HTML Characters Directly in Scala Strings with Laminar\nDESCRIPTION: Shows how to use actual characters in Scala strings instead of HTML entities, including Laminar's non-breaking space shorthand 'nbsp' and other special characters used directly.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndiv(s\"${date}${nbsp}${time}\")\ndiv(b(\"Posts\"), \"»\", categoryName) // `»` instead of `&raquo;`\ndiv(\"Features — not bugs\") // `—` instead of `&emdash;`\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of flatMap with Signals in Scala\nDESCRIPTION: Demonstrates an incorrect approach to combining signals using flatMap, which creates unnecessary transaction boundaries and potential glitches.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_92\n\nLANGUAGE: scala\nCODE:\n```\nval intSignal: Signal[Int] = ???\nval boolSignal: Signal[Boolean] = ???\nval resultSignal: Signal[(Int, Boolean)] = (\n  for {\n    int <- intSignal\n    bool <- boolSignal\n  } yield (int, bool)\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying Sponsor Recognition in HTML\nDESCRIPTION: HTML markup for displaying gold sponsors of the Laminar project, including both individual and company sponsors with their logos, links, and descriptions.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_33\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"-sponsorsList x-alignItemsEnd\">\n  <div class=\"-sponsor x-person x-yurique\">\n    <img class=\"-avatar x-rounded\" src=\"/img/sponsors/yurique.jpg\" alt=\"\" />\n    <div class=\"-text\">\n      <div class=\"-name\"><a href=\"https://github.com/yurique\">Iurii Malchenko</a></div>\n    </div>\n  </div>\n  <div class=\"-sponsor x-company x-aurinko\">\n    <a class=\"x-noHover\" href=\"https://www.aurinko.io/\">\n      <img class=\"-logo\" src=\"/img/sponsors/aurinko-light-300px.png\" alt=\"\" />\n      <div class=\"-tagline\"><u>Aurinko</u> is an API platform for workplace addons and integrations.</div>\n    </a>\n  </div>\n  <div class=\"-sponsor x-company x-heartai\">\n    <a class=\"x-noHover\" href=\"https://www.heartai.net/\">\n      <img class=\"-logo\" src=\"/img/sponsors/heartai.svg\" alt=\"\" />\n      <div class=\"-tagline\"><u>HeartAI</u> is a data and analytics platform for digital health and clinical care.</div>\n    </a>\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Defining Real HTML Attributes and Properties in Laminar\nDESCRIPTION: Shows how to create practical HTML attributes and properties with appropriate codecs based on their expected types. These examples demonstrate proper typing for tabIndex (numeric), async (boolean), and decoding (string) attributes.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport com.raquo.laminar.codecs.*\n\nval tabIndex: HtmlProp[Int, Int] = htmlProp(\"tabIndex\", IntAsIsCodec) // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex\n\nval asyncAttr: HtmlAttr[Boolean] = htmlAttr(\"async\", BooleanAsAttrPresenceCodec) // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#async\n\nval decodingAttr: HtmlProp[String, String] = htmlProp(\"decoding\", StringAsIsCodec) // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#decoding\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Var Update Scheduling in Scala\nDESCRIPTION: This code snippet illustrates the improved transaction scheduling in Airstream v0.11.0, showing how updates to Var are now handled in a depth-first hierarchy traversal instead of linear FIFO.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nTransaction A is currently running. You schedule transactions B and C (e.g. two separate updates to a `Var`, inside a `stream.foreach`).\n```\n\n----------------------------------------\n\nTITLE: Desugared flatMap Signal Combination in Scala\nDESCRIPTION: Shows the desugared version of the for-comprehension, revealing the asymmetric nature of flatMap operations on signals.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_93\n\nLANGUAGE: scala\nCODE:\n```\nval resultSignal: Signal[(Int, Boolean)] = (\n  intSignal.flatMap { int =>\n    boolSignal.map(bool => (int, bool))\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Invalid Var Set Operation in Scala\nDESCRIPTION: This code shows an invalid operation that is no longer allowed in Airstream v0.11.0, where setting a Var with duplicate inputs is prohibited.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nVar.set(var1 -> foo, var1 -> bar)\n```\n\n----------------------------------------\n\nTITLE: Mounting Elements with Event Propagation in Laminar (Scala)\nDESCRIPTION: Demonstrates how elements are mounted in Laminar and how mount events propagate through the element hierarchy, showing element mounting, the connection between parent and child elements, and stream-based reactive updates.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_84\n\nLANGUAGE: scala\nCODE:\n```\nval container: dom.Element = dom.document.querySelector(\"#appContainer\")\nval nameStream: EventStream[String] = ???\nval titleEl = h1(\"Welcomer \", b(\"9000\")) \nval contentEl = div(\n  titleEl,\n  child <-- nameStream.map(name => span(\"Hello \", b(name)))\n)\n \nval rootNode: RootNode = render(container, contentEl)\n```\n\n----------------------------------------\n\nTITLE: Defining User Data Model and Rendering Function\nDESCRIPTION: Sets up a basic user data model and a rendering function to display user information. This naive approach will be inefficient for dynamic lists as it recreates all DOM elements on each update.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(id: String, name: String)\n \nval usersStream: EventStream[List[User]] = ???\n   \ndef renderUser(user: User): Div = {\n  div(\n    p(\"user id: \", user.id),\n    p(\"name: \", user.name)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Inefficient way to render dynamic text in Laminar\nDESCRIPTION: Demonstrates an inefficient approach to dynamic text rendering that should be avoided. This creates unnecessary DOM elements for each text update.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval textStream: EventStream[String] = ???\ndiv(child <-- textStream.map(str => span(str))) // No! Bad!\n```\n\n----------------------------------------\n\nTITLE: Modern Alternatives to inContext in Laminar\nDESCRIPTION: Shows more efficient alternatives to 'inContext' in modern Laminar, including specialized event processors and the 'compose' method for applying stream operators.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndiv(inContext(_.events(onClick).delay(10) --> observer))\n```\n\nLANGUAGE: scala\nCODE:\n```\ndiv(composeEvents(onClick)(_.delay(10)) --> observer)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick.compose(_.delay(10)) --> observer)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick(_.delay(10)) --> observer)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndiv(onClick --> observer.delay(10))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating EventStream Startup Issue in Scala with Laminar\nDESCRIPTION: This code snippet illustrates a bug fixed in Laminar v17 where multiple observers of a stream that emits events on startup would not all receive the initial event. Before v17, only the first text node would display properly.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval container = dom.document.getElementById(\"app-container\")\nval stream = EventStream.fromValue(1)\nrender(\n  container,\n  div(\n    child.text <-- stream,\n    child.text <-- stream.map(_ * 10)\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of onMountCallback for Dynamic Subscriptions in Scala\nDESCRIPTION: Illustrates an incorrect approach to using onMountCallback for dynamic subscriptions. This example shows why onMountBind is necessary to prevent multiple subscriptions on remounts.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_82\n\nLANGUAGE: scala\nCODE:\n```\nval observer: Observer[dom.MouseEvent] = ???\ndiv(\n  onMountCallback(ctx => {\n    doSomething(ctx) // let's assume we need this for some reason\n \n    // WRONG – DO NOT DO THIS!\n    ctx.thisNode.amend(onClick --> observer)\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Using Var Update Methods in Scala\nDESCRIPTION: This snippet demonstrates the changes in Var update methods in Airstream v0.11.0, where mod input functions are now evaluated only when their transaction has started executing.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nmyVar.update(mod)\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Binding in Scala with Laminar\nDESCRIPTION: Shows how Laminar implements stream binding for HTML attributes, demonstrating the connection between reactive streams and DOM updates without Virtual DOM diffing.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/virtual-dom.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  def <--(values: Observable[V]): Binder[HtmlElement] = {\n    Binder { element =>\n      ReactiveElement.bindFn(element, values) { value =>\n        DomApi.setHtmlAttribute(element, this, value)\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Using Observable of Modifiers in Laminar\nDESCRIPTION: This code demonstrates a pattern that does not work in Laminar - attempting to use an Observable[Modifier]. This approach doesn't work because Laminar's DOM updates are granular down to the property level.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_100\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  userSignal.map { user => \n    if (user.isActive) {\n      cls := \"active\" \n    } else {\n      opacity := 0.5 \n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Take and Drop Stream Operators in Scala\nDESCRIPTION: Various implementations of take and drop operators for event streams with conditional variants.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nstream.take(numEvents = 5)\nstream.takeWhile(ev => passes(ev)) // stop taking when `passes(ev)` returns `false`\nstream.takeUntil(ev => passes(ev)) // stop taking when `passes(ev)` returns `true`\n```\n\nLANGUAGE: scala\nCODE:\n```\nstream.drop(numEvents = 5)\nstream.dropWhile(ev => passes(ev)) // stop skipping when `passes(ev)` returns `false`\nstream.dropUntil(ev => passes(ev)) // stop skipping when `passes(ev)` returns `true`\n```\n\n----------------------------------------\n\nTITLE: EventStream Delay Implementation\nDESCRIPTION: Example of using EventStream.delay to create delayed actions after component mounting.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  EventStream.delay(5000) --> showBelovedMarketingPopup\n)\n```\n\n----------------------------------------\n\nTITLE: Legacy approach to window and document events in Laminar\nDESCRIPTION: Shows the previous API for accessing window and document events in Laminar, which has been updated in the new version.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nwindowEvents.onPopState // EventStream[dom.PopStateEvent]\ndocumentEvents.onClick // EventStream[dom.MouseEvent]\n```\n\n----------------------------------------\n\nTITLE: Using ReactiveElement Events in Scala\nDESCRIPTION: This snippet shows the correct usage of ReactiveElement events in Laminar v0.11.0, where stopPropagation and preventDefault options are now properly respected.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nelement.events(onClick, stopPropagation = true) --> ...\n```\n\n----------------------------------------\n\nTITLE: Incorrect Element Reuse in Laminar\nDESCRIPTION: Demonstrates the pitfall of reusing element instances in Laminar, where an element can only have one parent at a time, causing it to be moved rather than copied.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval el = span(\"hello\")\ndiv(el, div(el))\n```\n\n----------------------------------------\n\nTITLE: Implicit Integer to Node Conversion in Scala\nDESCRIPTION: This code demonstrates the new implicit conversion for integers to nodes in Laminar v0.11.0, allowing direct use of integers in DOM construction.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndiv(usersCount, \" users\")\n```\n\n----------------------------------------\n\nTITLE: Getting string values from CSS keyword setters in Laminar\nDESCRIPTION: Shows how to access the string value of CSS keyword setters through the new value property, making it easier to use these constants in reactive streams.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  // Before\n  textAlign <-- streamOfBooleans.map(\n    if (_) \"left\" else \"right\"\n  ),\n  // After – same, but you get to marvel at your IDE knowing these symbols\n  textAlign <-- streamOfBooleans.map(\n    if (_) textAlign.left.value else textAlign.right.value\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Inefficient Dynamic List Rendering in Laminar\nDESCRIPTION: Shows the inefficient way to render a dynamic list of users. This approach recreates all DOM elements whenever the stream emits a new list, regardless of what actually changed.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nval userElementsStream: EventStream[List[Div]] =\n  usersStream.map(users => users.map(renderUser))\n \ndiv(\n  children <-- userElementsStream\n)\n```\n\n----------------------------------------\n\nTITLE: Migrating Child Signal Binding in Scala\nDESCRIPTION: Example showing migration from auxiliary syntax for binding child signals to the new amend method syntax.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// Old syntax\nmyElement <-- child <-- childSignal\n\n// New syntax\nmyElement.amend(child <-- childSignal)\n```\n\n----------------------------------------\n\nTITLE: Using vendor prefixes for CSS properties in Laminar\nDESCRIPTION: Demonstrates how to apply vendor prefixes to CSS properties using the new withPrefixes method, which automatically sets the property with multiple browser-specific prefixes.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  transition.withPrefixes(_.moz, _.ms, _.webkit) := \"all 4s ease\"\n  // and similarly for `<--`.\n)\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Manual Node Amendment in Laminar\nDESCRIPTION: An educational example showing why manually updating node properties doesn't work correctly with Laminar. This approach breaks with composite attributes like 'cls' that have special semantics.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_102\n\nLANGUAGE: scala\nCODE:\n```\n// NO!!!\ndiv(\n  inContext { thisNode =>\n    userSignal --> { user =>\n      if (user.isActive) {\n        thisNode.amend(cls := \"active\", opacity := 1)\n      } else {\n        thisNode.amend(opacity := 0.5)\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Aliasing Event Property to Variable Writer in Laminar (Scala)\nDESCRIPTION: This snippet shows an alias for assigning an event property to a variable writer in Laminar.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\neventProp --> var\n```\n\n----------------------------------------\n\nTITLE: Using composeEvents in Laminar (Scala)\nDESCRIPTION: Illustrates the new composeEvents function for applying stream operators to events without using inContext.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndiv(\n  composeEvents(onClick)(_.throttle(0)) --> eventObserver\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Periodic Streams With New Semantics (Scala)\nDESCRIPTION: Shows how to use the updated EventStream.periodic with drop operator to approximate previous emitInitial=false behavior.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ndrop(1, resetOnStop = true)\n```\n\n----------------------------------------\n\nTITLE: Migrating Event Prop Configuration in Scala\nDESCRIPTION: Example showing how to migrate from the old event property configuration syntax to the new EventPropTransformation syntax for setting useCapture.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Old syntax\nonClick.config(useCapture = true)\n\n// New syntax\nonClick.useCapture\n```\n\n----------------------------------------\n\nTITLE: Installing Laminar Dependency with SBT\nDESCRIPTION: SBT dependency declaration for adding Laminar to a Scala.js project. Requires Scala.js 1.16.0 or higher.\nSOURCE: https://github.com/raquo/laminar/blob/master/README.md#2025-04-20_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n\"com.raquo\" %%% \"laminar\" % \"<version>\" // Requires Scala.js 1.16.0+\n```\n\n----------------------------------------\n\nTITLE: Using Signal Fold Methods in Scala\nDESCRIPTION: This snippet illustrates the renamed Signal fold methods in Airstream v0.11.0 for better clarity and consistency.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2020-10-12-laminar-v0.11.0.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nSignal#fold -> Signal#foldLeft, Signal#foldRecover -> Signal#foldLeftRecover\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Creating Redundant Observables in Laminar\nDESCRIPTION: An example showing inefficient code that creates multiple copies of the same Observable computation. This happens when mapping over the same signal multiple times in different contexts.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_104\n\nLANGUAGE: scala\nCODE:\n```\nval renderConfigSignal: Signal[RenderConfig] = ???\nval blocks = Signal[List[DocumentBlock]]\ndiv(\n  display.flex,\n  flexDirection.column,\n  children <-- blocks.split(_.blockId)((blockId, _, blockSignal) => {\n    input(\n      value <-- (\n        blockSignal\n          .combineWith(renderConfigSignal.map(_.computeStyle))\n          .mapN((block, style) => block.formatWith(style))\n      ),\n      onInput --> ???\n    )\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Using Generic Modifier Type in Laminar Extensions (Scala)\nDESCRIPTION: Demonstrates how to correctly reference the Modifier type with proper type constraints in extension code.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nModifier[_ <: ReactiveElement.Base]\n```\n\n----------------------------------------\n\nTITLE: Setting Unicode Bidi Property Using Strings in Laminar CSS (Scala)\nDESCRIPTION: Demonstrates how to set CSS properties that had their shorthands removed by using regular strings with the := operator.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2023-03-22-laminar-v15.0.0.md#2025-04-20_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nunicodeBidi := \"embed\"\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Tables without tbody Element\nDESCRIPTION: An example of invalid HTML table structure that browsers silently fix but causes problems with Laminar. This example shows table rows directly under the table element without the required tbody wrapper.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_106\n\nLANGUAGE: html\nCODE:\n```\n<table>\n  <tr>\n    <td>Row1 Cell1</td>\n    <td>Row1 Cell2</td>\n  </tr>\n  <tr>\n    <td>Row2 Cell1</td>\n    <td>Row2 Cell2</td>\n  </tr>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Publishing Laminar Website to GitHub Pages\nDESCRIPTION: This SBT command publishes the generated website content to GitHub Pages, making the updates live on the project's public website.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/README.md#2025-04-20_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsbt website/docusaurusPublishGhpages\n```\n\n----------------------------------------\n\nTITLE: Removing Composite Attribute Values in Laminar (Scala)\nDESCRIPTION: This code demonstrates how to remove composite attribute values in Laminar, specifically for class attributes.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncls.remove(\"class1\")\n```\n\n----------------------------------------\n\nTITLE: Handling Partial Route Matching in Waypoint\nDESCRIPTION: Shows the new partial route matching functionality in Waypoint that returns an Option result. This change affects the argsFromPage method which now wraps its result in an Option.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2021-02-03-laminar-v0.12.0.md#2025-04-20_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nroute.argsFromPage // Now returns an Option\n```\n\n----------------------------------------\n\nTITLE: Displaying Sponsorship Information with HTML\nDESCRIPTION: HTML markup used to display sponsors of the Laminar project, organized by sponsorship tiers (Diamond and Gold). The HTML includes sponsor logos, links to their websites, and brief descriptions of each sponsor.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/blog/2024-05-14-laminar-v17.0.0.md#2025-04-20_snippet_6\n\nLANGUAGE: HTML\nCODE:\n```\n<h4 class=\"x-like-h3\">DIAMOND sponsor:</h4>\n\n<div class=\"-sponsorsList x-alignItemsStart x-justifyContentCenter\">\n<div class=\"-sponsor x-diamond x-company x-heartai\">\n  <a class=\"x-noHover\" href=\"https://www.heartai.net/\">\n    <img class=\"-logo\" src=\"/img/sponsors/heartai.svg\" alt=\"\" />\n    <div class=\"-tagline\"><u>HeartAI</u> is a data and analytics platform for digital health and clinical care.</div>\n  </a>\n</div>\n</div>\n\n**GOLD sponsors**:\n\n<div class=\"-sponsorsList x-alignItemsEnd\">\n  <div class=\"-sponsor x-person x-yurique\">\n    <img class=\"-avatar x-rounded\" src=\"/img/sponsors/yurique.jpg\" alt=\"\" />\n    <div class=\"-text\">\n      <div class=\"-name\"><a href=\"https://github.com/yurique\">Iurii Malchenko</a></div>\n    </div>\n  </div>\n  <div class=\"-sponsor x-company x-aurinko\">\n    <a class=\"x-noHover\" href=\"https://www.aurinko.io/\">\n      <img class=\"-logo\" src=\"/img/sponsors/aurinko-light-250px.png\" alt=\"\" />\n      <div class=\"-tagline\"><u>Aurinko</u> is an API platform for workplace addons and integrations.</div>\n    </a>\n  </div>\n  <a class=\"-sponsor x-person x-tawasal\" href=\"https://tawasal.ae\">\n    <img class=\"-avatar\" src=\"/img/sponsors/tawasal.svg\" alt=\"\" />\n    <div class=\"-text\">\n      <div class=\"-name\">Tawasal</div>\n      <div class=\"-description\">Secure multi-purpose messenger and superapp, offering free voice, text, video conferencing and lifestyle services.</div>\n    </div>\n  </a>\n  <div class=\"-sponsor x-empty\">\n    <!-- filler for layout purposes -->\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Aliasing Observable to Variable Writer in Laminar (Scala)\nDESCRIPTION: This code demonstrates an alias for assigning an observable to a variable writer in Laminar.\nSOURCE: https://github.com/raquo/laminar/blob/master/CHANGELOG.md#2025-04-20_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobservable --> var\n```\n\n----------------------------------------\n\nTITLE: Starting Laminar Website Local Development Server\nDESCRIPTION: These commands change to the website directory and start a local development server for live previewing of the Laminar website.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/README.md#2025-04-20_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd website; npm run start\n```\n\n----------------------------------------\n\nTITLE: Generating Laminar Website Content with SBT and mdoc\nDESCRIPTION: This command uses SBT to generate the website content, including processing mdoc pages. It should be run after adding new documentation pages.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/README.md#2025-04-20_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt website/docusaurusCreateSite\n```\n\n----------------------------------------\n\nTITLE: Inefficient Input Component with Redundant State in Scala\nDESCRIPTION: Shows an anti-pattern of maintaining redundant state variables that need manual synchronization.\nSOURCE: https://github.com/raquo/laminar/blob/master/website/docs/documentation.md#2025-04-20_snippet_98\n\nLANGUAGE: scala\nCODE:\n```\ndef nameInput(userVar: Var[User]): HtmlElement = {\n  val nameVar = Var(userVar.now())\n  input(\n    value <-- nameVar,\n    onInput.mapToValue --> nameVar,\n    nameVar.signal --> { newName => \n      userVar.update(user => user.copy(name = newName)) \n    }\n  )\n}\n```"
  }
]