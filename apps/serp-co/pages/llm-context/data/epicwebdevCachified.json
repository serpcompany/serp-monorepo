[
  {
    "owner": "epicweb-dev",
    "repo": "cachified",
    "content": "TITLE: Basic Cachified Usage with LRU Cache\nDESCRIPTION: Demonstrates basic setup and usage of cachified with LRU cache implementation. Shows how to cache API calls with TTL and handle cache invalidation.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { LRUCache } from 'lru-cache';\nimport { cachified, CacheEntry, Cache, totalTtl } from '@epic-web/cachified';\n\n/* lru cache is not part of this package but a simple non-persistent cache */\nconst lruInstance = new LRUCache<string, CacheEntry>({ max: 1000 });\n\nconst lru: Cache = {\n  set(key, value) {\n    const ttl = totalTtl(value?.metadata);\n    return lruInstance.set(key, value, {\n      ttl: ttl === Infinity ? undefined : ttl,\n      start: value?.metadata?.createdTime,\n    });\n  },\n  get(key) {\n    return lruInstance.get(key);\n  },\n  delete(key) {\n    return lruInstance.delete(key);\n  },\n};\n\nfunction getUserById(userId: number) {\n  return cachified({\n    key: `user-${userId}`,\n    cache: lru,\n    async getFreshValue() {\n      /* Normally we want to either use a type-safe API or `checkValue` but\n         to keep this example simple we work with `any` */\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n    /* 5 minutes until cache gets invalid\n     * Optional, defaults to Infinity */\n    ttl: 300_000,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Stale While Revalidate Implementation\nDESCRIPTION: Example showing how to implement stale-while-revalidate caching pattern, allowing cached values to be served while updating in background.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nfunction getUserById(userId: number) {\n  return cachified({\n    ttl: 120_000 /* Two minutes */,\n    staleWhileRevalidate: 300_000 /* Five minutes */,\n\n    cache,\n    key: `user-${userId}`,\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Batch Requesting Values with @epic-web/cachified\nDESCRIPTION: Shows how to efficiently batch multiple cachified requests using the createBatch helper. This optimizes network requests by fetching only the values that are not currently in the cache and then caching them individually.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, createBatch } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nasync function getFreshValues(idsThatAreNotInCache: number[]) {\n  const res = await fetch(\n    `https://example.org/api?ids=${idsThatAreNotInCache.join(',')}`,\n  );\n  const data = await res.json();\n\n  // Validate data here...\n\n  return data;\n}\n\nfunction getUsersWithId(ids: number[]) {\n  const batch = createBatch(getFreshValues);\n\n  return Promise.all(\n    ids.map((id) =>\n      cachified({\n        getFreshValue: batch.add(\n          id,\n          /* onValue callback is optional but can be used to manipulate\n           * cache metadata based on the received value. (see section above) */\n          ({ value, ...context }) => {},\n        ),\n\n        cache,\n        key: `entry-${id}`,\n        ttl: 60_000,\n      }),\n    ),\n  );\n}\n\nconsole.log(await getUsersWithId([1, 2]));\n// > logs user objects for ID 1 & ID 2\n// Caches is completely empty. `getFreshValues` is invoked with `[1, 2]`\n// and its return values cached separately\n\n// 1 minute later\nconsole.log(await getUsersWithId([2, 3]));\n// > logs user objects for ID 2 & ID 3\n// User with ID 2 is in cache, `getFreshValues` is invoked with `[3]`\n// cachified returns with one value from cache and one fresh value\n```\n\n----------------------------------------\n\nTITLE: Force Fresh Values Implementation\nDESCRIPTION: Demonstrates how to implement forced cache refresh with fallback options when fresh value retrieval fails.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nfunction getUserById(userId: number, forceFresh?: boolean) {\n  return cachified({\n    forceFresh,\n    /* when getting a forced fresh value fails we fall back to cached value\n       as long as it's not older then 5 minutes */\n    fallbackToCache: 300_000 /* 5 minutes, defaults to Infinity */,\n\n    cache,\n    key: `user-${userId}`,\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safety with Custom Validation in @epic-web/cachified\nDESCRIPTION: Demonstrates how to ensure type-safety when retrieving cached values by implementing custom validation logic with the checkValue function. The example shows validation of user objects with specific property checks and different ways to handle invalid data.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, createCacheEntry } from '@epic-web/cachified';\n\nconst cache = new Map();\n\n/* Assume something bad happened and we have an invalid cache entry... */\ncache.set('user-1', createCacheEntry('INVALID') as any);\n\nfunction getUserById(userId: number) {\n  return cachified({\n    checkValue(value: unknown) {\n      if (!isRecord(value)) {\n        /* We can either throw to indicate a bad value */\n        throw new Error(`Expected user to be object, got ${typeof value}`);\n      }\n\n      if (typeof value.email !== 'string') {\n        /* Or return a reason/message string */\n        return `Expected user-${userId} to have an email`;\n      }\n\n      if (typeof value.username !== 'string') {\n        /* Or just say no... */\n        return false;\n      }\n\n      /* undefined, true or null are considered OK */\n    },\n\n    cache,\n    key: `user-${userId}`,\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n  });\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nconsole.log(await getUserById(1));\n// > logs the user with ID 1\n// Cache was not empty but value was invalid, `getFreshValue` got invoked and\n// and the cache was updated\n\nconsole.log(await getUserById(1));\n// > logs the exact same data as above\n// Cache was filled an valid. `getFreshValue` was not invoked\n```\n\n----------------------------------------\n\nTITLE: Soft-Purging Cache Entries with @epic-web/cachified\nDESCRIPTION: Shows how to implement soft-purging of cached data to reduce pressure on the application by allowing stale data to be used while fetching fresh data in the background. This example demonstrates controlling the stale-while-revalidate period.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, softPurge } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nfunction getUserById(userId: number) {\n  return cachified({\n    cache,\n    key: `user-${userId}`,\n    ttl: 300_000,\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n  });\n}\n\nconsole.log(await getUserById(1));\n// > logs user with ID 1\n// cache was empty, fresh value was requested and is cached for 5 minutes\n\nawait softPurge({\n  cache,\n  key: 'user-1',\n});\n// This internally sets the ttl to 0 and staleWhileRevalidate to 300_000\n\n// 10 seconds later\nconsole.log(await getUserById(1));\n// > logs the outdated, soft-purged data\n// cache has been soft-purged, the cached value got returned and a fresh value\n// is requested in the background and again cached for 5 minutes\n\n// 1 minute later\nconsole.log(await getUserById(1));\n// > logs the fresh data that got refreshed by the previous call\n\nawait softPurge({\n  cache,\n  key: 'user-1',\n  // manually overwrite how long the stale data should stay in cache\n  staleWhileRevalidate: 60_000 /* one minute from now on */,\n});\n\n// 2 minutes later\nconsole.log(await getUserById(1));\n// > logs completely fresh data\n```\n\n----------------------------------------\n\nTITLE: Using Zod for Type-Safety with @epic-web/cachified\nDESCRIPTION: Shows how to integrate schema validation libraries like Zod with cachified to enforce type safety of cached values. The example demonstrates validating a user object schema when retrieving from cache.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, createCacheEntry } from '@epic-web/cachified';\nimport z from 'zod';\n\nconst cache = new Map();\n/* Assume something bad happened and we have an invalid cache entry... */\ncache.set('user-1', createCacheEntry('INVALID') as any);\n\nfunction getUserById(userId: number) {\n  return cachified({\n    checkValue: z.object({\n      email: z.string(),\n    }),\n\n    cache,\n    key: `user-${userId}`,\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/${userId}`,\n      );\n      return response.json();\n    },\n  });\n}\n\nconsole.log(await getUserById(1));\n// > logs the user with ID 1\n// Cache was not empty but value was invalid, `getFreshValue` got invoked and\n// and the cache was updated\n\nconsole.log(await getUserById(1));\n// > logs the exact same data as above\n// Cache was filled an valid. `getFreshValue` was not invoked\n```\n\n----------------------------------------\n\nTITLE: Manual Cache Interactions with @epic-web/cachified\nDESCRIPTION: Shows how to manually interact with the cache using utilities provided by cachified. This includes creating cache entries, asserting entry validity, checking expiration, and manually removing entries from the cache.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createCacheEntry,\n  assertCacheEntry,\n  isExpired,\n  cachified,\n} from '@epic-web/cachified';\n\nconst cache = new Map();\n\n/* Manually set an entry to cache */\ncache.set(\n  'user-1',\n  createCacheEntry(\n    'someone@example.org',\n    /* Optional CacheMetadata */\n    { ttl: 300_000, swr: Infinity },\n  ),\n);\n\n/* Receive the value with cachified */\nconst value: string = await cachified({\n  cache,\n  key: 'user-1',\n  getFreshValue() {\n    throw new Error('This is not called since cache is set earlier');\n  },\n});\nconsole.log(value);\n// > logs \"someone@example.org\"\n\n/* Manually get a value from cache */\nconst entry: unknown = cache.get('user-1');\nassertCacheEntry(entry); // will throw when entry is not a valid CacheEntry\nconsole.log(entry.value);\n// > logs \"someone@example.org\"\n\n/* Manually check if an entry is expired */\nconst expired = isExpired(entry.metadata);\nconsole.log(expired);\n// > logs true, \"stale\" or false\n\n/* Manually remove an entry from cache */\ncache.delete('user-1');\n```\n\n----------------------------------------\n\nTITLE: Migrating Cached Values with @epic-web/cachified\nDESCRIPTION: Demonstrates how to migrate cached values when their format changes during the application's lifetime. This example shows transforming a simple email string into a user object structure using the migrate callback in checkValue.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, createCacheEntry } from '@epic-web/cachified';\n\nconst cache = new Map();\n\n/* Let's assume we've previously only stored emails not user objects */\ncache.set('user-1', createCacheEntry('someone@example.org'));\n\nfunction getUserById(userId: number) {\n  return cachified({\n    checkValue(value, migrate) {\n      if (typeof value === 'string') {\n        return migrate({ email: value });\n      }\n      /* other validations... */\n    },\n\n    key: 'user-1',\n    cache,\n    getFreshValue() {\n      throw new Error('This is never called');\n    },\n  });\n}\n\nconsole.log(await getUserById(1));\n// > logs { email: 'someone@example.org' }\n// Cache is filled and invalid but value can be migrated from email to user-object\n// `getFreshValue` is not invoked\n\nconsole.log(await getUserById(1));\n// > logs the exact same data as above\n// Cache is filled an valid.\n```\n\n----------------------------------------\n\nTITLE: Fine-tuning Cache Metadata Based on Fresh Values in @epic-web/cachified\nDESCRIPTION: Demonstrates how to adjust cache metadata dynamically based on the fresh values received. This example shows disabling caching when specific conditions are met, like receiving null data from an API.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nconst value: null | string = await cachified({\n  ttl: 60_000 /* Default cache of one minute... */,\n  async getFreshValue(context) {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/users/1`,\n    );\n    const data = await response.json();\n\n    if (data === null) {\n      /* On an empty result, prevent caching */\n      context.metadata.ttl = -1;\n    }\n\n    return data;\n  },\n\n  cache,\n  key: 'user-1',\n});\n```\n\n----------------------------------------\n\nTITLE: Pre-configuring @epic-web/cachified with Default Options\nDESCRIPTION: Demonstrates how to create a pre-configured version of cachified with default options using the configure function. This example shows setting up cachified with an LRU cache as the default cache implementation.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from '@epic-web/cachified';\nimport { LRUCache } from 'lru-cache';\n\n/* lruCachified now has a default cache */\nconst lruCachified = configure({\n  cache: new LRUCache<string, CacheEntry>({ max: 1000 }),\n});\n\nconst value = await lruCachified({\n  key: 'user-1',\n  getFreshValue: async () => 'ONE',\n});\n```\n\n----------------------------------------\n\nTITLE: Using verboseReporter with Cachified in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the verboseReporter with the cachified function. It sets up a cache using a Map and fetches user data from an API, while logging caching events.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cachified, verboseReporter } from '@epic-web/cachified';\n\nconst cache = new Map();\n\nawait cachified(\n  {\n    cache,\n    key: 'user-1',\n    async getFreshValue() {\n      const response = await fetch(\n        `https://jsonplaceholder.typicode.com/users/1`,\n      );\n      return response.json();\n    },\n  },\n  verboseReporter(),\n);\n```\n\n----------------------------------------\n\nTITLE: Cachified Interface Options\nDESCRIPTION: TypeScript interface defining all available configuration options for the cachified function including cache implementation, TTL, SWR, and validation.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CachifiedOptions<Value> {\n  key: string;\n  cache: Cache;\n  getFreshValue: GetFreshValue<Value>;\n  ttl?: number;\n  staleWhileRevalidate?: number;\n  swr?: number;\n  checkValue?: CheckValue<Value> | StandardSchemaV1<unknown, Value> | Schema<Value, unknown>;\n  forceFresh?: boolean;\n  fallbackToCache?: boolean | number;\n  waitUntil?: (promise: Promise<unknown>) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Cachified Package\nDESCRIPTION: NPM installation command for the @epic-web/cachified package.\nSOURCE: https://github.com/epicweb-dev/cachified/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @epic-web/cachified\n```"
  }
]