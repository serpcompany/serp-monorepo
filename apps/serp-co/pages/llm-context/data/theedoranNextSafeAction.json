[
  {
    "owner": "theedoran",
    "repo": "next-safe-action",
    "content": "TITLE: Defining a Server Action with Zod validation\nDESCRIPTION: Creating a server action with Zod validation schema to validate input data. This example shows a login action that checks credentials.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\"; // don't forget to add this!\n\nimport { z } from \"zod\";\nimport { actionClient } from \"@/lib/safe-action\";\n\n// This schema is used to validate input from client.\nconst schema = z.object({\n  username: z.string().min(3).max(10),\n  password: z.string().min(8).max(100),\n});\n\nexport const loginUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { username, password } }) => {\n    if (username === \"johndoe\" && password === \"123456\") {\n      return {\n        success: \"Successfully logged in\",\n      };\n    }\n\n    return { failure: \"Incorrect credentials\" };\n  });\n```\n\n----------------------------------------\n\nTITLE: Executing a Server Action from a Client Component\nDESCRIPTION: Example of how to call a server action directly from a client component and handle its response. The response includes validation errors and data fields.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\"; // this is a Client Component\n\nimport { loginUser } from \"./login-action\";\n\nexport default function Login() {\n  return (\n    <button\n      onClick={async () => {\n        // Typesafe action called from client.\n        const res = await loginUser({\n          username: \"johndoe\",\n          password: \"123456\",\n        });\n\n        // Result keys.\n        res?.data;\n        res?.validationErrors;\n        res?.bindArgsValidationErrors;\n        res?.serverError;\n      }}>\n      Log in\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Server Action with TypeScript Schema Validation\nDESCRIPTION: Creates a server action that validates input using Zod schema and returns a greeting message. The action is defined with type safety using actionClient.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/useaction.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nconst schema = z.object({\n  name: z.string(),\n});\n\nexport const greetUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { name } }) => {\n    return { message: `Hello ${name}!` };\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a Server Action for File Upload with Zod Validation in TypeScript\nDESCRIPTION: This server-side code defines a file upload action using next-safe-action with Zod and zod-form-data for validation. It creates a schema that expects a file input and processes the uploaded file after validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/upload-files.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { action } from \"@/lib/safe-action\";\n// highlight-next-line\nimport { zfd } from \"zod-form-data\";\n\n// highlight-start\nconst schema = zfd.formData({\n  image: zfd.file(),\n});\n// highlight-end\n\nexport const fileUploadAction = action\n  .schema(schema)\n  .action(async ({ parsedInput }) => {\n    await new Promise((res) => setTimeout(res, 1000));\n\n    // Do something useful with the file.\n    // highlight-next-line\n    console.log(\"fileUploadAction ->\", parsedInput);\n\n    return {\n      ok: true,\n    };\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Component with useAction Hook\nDESCRIPTION: Shows how to use the useAction hook in a React client component to handle form input and display results. Demonstrates state management and action execution.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/useaction.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useAction } from \"next-safe-action/hooks\";\nimport { greetUser } from \"@/app/greet-action\";\n\nexport default function Greet() {\n  const [name, setName] = useState(\"\");\n  const { execute, result } = useAction(greetUser);\n\n  return (\n    <div>\n      <input type=\"text\" onChange={(e) => setName(e.target.value)} />\n      <button\n        onClick={() => {\n          execute({ name });\n        }}>\n        Greet user\n      </button>\n      {result.data?.message ? <p>{result.data.message}</p> : null}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Stateful Server Action in TypeScript\nDESCRIPTION: Creates a stateful server action using actionClient with zod schema validation. The action tracks previous and new name inputs with a simulated delay.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/usestateaction.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\nimport { zfd } from \"zod-form-data\";\n\nconst schema = zfd.formData({\n  name: zfd.text(z.string().min(1).max(20)),\n});\n\nexport const statefulAction = actionClient\n  .metadata({ actionName: \"statefulAction\" })\n  .schema(schema)\n  .stateAction<{\n    prevName?: string;\n    newName: string;\n  }>(async ({ parsedInput, metadata }, { prevResult }) => {\n    await new Promise((res) => setTimeout(res, 1000));\n\n    return {\n      prevName: prevResult.data?.newName,\n      newName: parsedInput.name,\n    };\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance-level Middleware in next-safe-action\nDESCRIPTION: This snippet demonstrates how to create a base action client with logging middleware and an extended auth client with authorization middleware. It shows how to chain middleware functions and handle errors.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createSafeActionClient,\n  DEFAULT_SERVER_ERROR_MESSAGE,\n} from \"next-safe-action\";\nimport { cookies } from \"next/headers\";\nimport { z } from \"zod\";\nimport { getUserIdFromSessionId } from \"./db\";\n\nclass ActionError extends Error {}\n\n// Base client.\nconst actionClient = createSafeActionClient({\n  defineMetadataSchema() {\n    return z.object({\n      actionName: z.string(),\n    });\n  },\n  handleServerError(e) {\n    console.error(\"Action error:\", e.message);\n\n    if (e instanceof ActionError) {\n      return e.message;\n    }\n\n    return DEFAULT_SERVER_ERROR_MESSAGE;\n  },\n  // Define logging middleware.\n}).use(async ({ next, clientInput, metadata }) => {\n  console.log(\"LOGGING MIDDLEWARE\");\n\n  const startTime = performance.now();\n\n  // Here we await the action execution.\n  const result = await next();\n\n  const endTime = performance.now();\n\n  console.log(\"Result ->\", result);\n  console.log(\"Client input ->\", clientInput);\n  console.log(\"Metadata ->\", metadata);\n  console.log(\"Action execution took\", endTime - startTime, \"ms\");\n\n  // And then return the result of the awaited action.\n  return result;\n});\n\n// Auth client defined by extending the base one.\n// Note that the same initialization options and middleware functions of the base client\n// will also be used for this one.\nexport const authActionClient = actionClient\n  // Define authorization middleware.\n  .use(async ({ next }) => {\n    const cookieStore = await cookies();\n    const session = cookieStore.get(\"session\")?.value;\n\n    if (!session) {\n      throw new Error(\"Session not found!\");\n    }\n\n    const userId = await getUserIdFromSessionId(session);\n\n    if (!userId) {\n      throw new Error(\"Session is not valid!\");\n    }\n\n    // Return the next middleware with `userId` value in the context\n    return next({ ctx: { userId } });\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing a File Upload Form Component with next-safe-action in React\nDESCRIPTION: This client-side component creates a form for file uploads using the next-safe-action hook. It connects to the previously defined fileUploadAction and renders a file input that accepts images.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/upload-files.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useAction } from \"next-safe-action/hooks\";\nimport { fileUploadAction } from \"./file-upload-action\";\n\nexport default function FileUploadPage() {\n  // highlight-next-line\n  const { execute } = useAction(fileUploadAction);\n\n  return (\n    // highlight-start\n    <form action={execute}>\n      <input\n        type=\"file\"\n        name=\"image\"\n        placeholder=\"Image\"\n        accept=\"image/*\"\n      />\n    // highlight-end\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic UI Updates with useOptimisticAction in a React Client Component\nDESCRIPTION: This client component demonstrates how to use the useOptimisticAction hook to create an optimistic UI experience when adding new todos. It immediately updates the UI with the new todo before the server response is received, then syncs with the actual server result when available.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/useoptimisticaction.md#2025-04-16_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useOptimisticAction } from \"next-safe-action/hooks\";\nimport { addTodo, type Todo } from \"@/app/addtodo-action\";\n\ntype Props = {\n  todos: Todo[];\n};\n\nexport default function TodosBox({ todos }: Props) {\n  // highlight-start\n  const { execute, result, optimisticState } = useOptimisticAction(\n    addTodo,\n    {\n      currentState: { todos }, // gets passed from Server Component\n      updateFn: (state, newTodo) => {\n        return { \n          todos: [...state.todos, newTodo] \n        };\n      }\n    }\n  );\n  // highlight-end\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          // Here we execute the action. The input is also passed to `updateFn` as the second argument,\n          // in this case `newTodo`.\n          // highlight-next-line\n          execute({ id: crypto.randomUUID(), body: \"New Todo\", completed: false });\n        }}>\n        Add todo\n      </button>\n      {/* Optimistic state gets updated right after the `execute` call (next render), it doesn't wait for the server to respond. */}\n      <pre>Optimistic state: {optimisticState}</pre>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Callbacks in Next-Safe-Action with TypeScript/React\nDESCRIPTION: Example showing how to implement all available hook callbacks (onExecute, onSuccess, onError, onSettled) in next-safe-action. Each callback receives specific parameters related to the action's state and can be implemented as async or synchronous functions.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/hook-callbacks.md#2025-04-16_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst action = useAction(testAction, {\n  onExecute: ({ input }) => {},\n  onSuccess: ({ data, input }) => {},\n  onError: ({ error, input }) => {},\n  onSettled: ({ result, input }) => {},\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component with Stateful Form Action\nDESCRIPTION: This client component uses the useStateAction hook from next-safe-action/stateful-hooks to handle a stateful form action. It initializes the form with an initial state and binds the execute function to the form's action prop.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/form-actions.md#2025-04-16_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useStateAction } from \"next-safe-action/stateful-hooks\";\nimport { statefulFormAction } from \"./stateful-form-action\";\n\nexport default function StatefulForm() {\n  // highlight-start\n  const { execute } = useStateAction(\n    statefulFormAction,\n    {\n      initResult: { data: { newName: \"jane\" } }, // optionally pass initial state\n    }\n  );\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <form action={execute}>\n      <input type=\"text\" name=\"name\" placeholder=\"Name\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Action-level Middleware in next-safe-action\nDESCRIPTION: This example demonstrates how to use action-level middleware to restrict execution to specific user roles. It uses the authActionClient and adds a role-checking middleware for a deleteUser action.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { authActionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nconst deleteUser = authActionClient\n  .use(async ({ next, ctx }) => {\n    // `userId` comes from the context set in the previous middleware function.\n    const userRole = await getUserRole(ctx.userId);\n\n    if (userRole !== \"admin\") {\n      throw new ActionError(\"Only admins can delete users.\");\n    }\n\n    // Here we pass the same untouched context (`userId`) to the next function, since we don't need\n    // to add data to the context here.\n    return next();\n  })\n  .metadata({ actionName: \"deleteUser\" })\n  .action(async ({ ctx: { userId } }) => {\n    // Here we're sure that the user that is performing this operation is an admin.\n    await deleteUserFromDb(userId);\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Standalone Middleware in next-safe-action\nDESCRIPTION: This code demonstrates how to create standalone middleware functions using createMiddleware() and apply them to action clients. It shows both a simple middleware and one with type constraints to ensure compatibility with specific client requirements. The example also illustrates how context is extended and passed through multiple middleware.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient, createMiddleware } from \"next-safe-action\";\nimport { z } from \"zod\";\n\nexport const actionClient = createSafeActionClient({\n  defineMetadataSchema: () => z.object({\n    actionName: z.string(),\n  }),\n  handleServerError: (e) => {\n    console.error(\"Action error:\", e.message);\n    return {\n      message: e.message,\n    }\n  }\n}).use(async ({ next }) => {\n  return next({ ctx: { foo: \"bar\" } });\n});\n\n// This middleware works with any client.\n// highlight-start\nconst myMiddleware1 = createMiddleware().define(async ({ next }) => {\n  // Do something useful here...\n  return next({ ctx: { baz: \"qux\" } });\n});\n// highlight-end\n\n// This middleware works with clients that at minimum have `ctx.foo`, `metadata.actionName`\n// and `serverError.message` properties. More information below. *\n// highlight-start\nconst myMiddleware2 = createMiddleware<{\n  ctx: { foo: string }; // [1]\n  metadata: { actionName: string }; // [2]\n  serverError: { message: string } // [3]\n}>().define(async ({ next }) => {\n  // Do something useful here...\n  return next({ ctx: { john: \"doe\" } });\n});\n// highlight-end\n\n// You can use it like a regular middleware function.\nexport const actionClientWithMyMiddleware = actionClient.use(myMiddleware1).use(myMiddleware2);\n```\n\n----------------------------------------\n\nTITLE: Defining a Stateful Form Action in TypeScript with next-safe-action\nDESCRIPTION: This code creates a stateful form action using the action.schema().stateAction() method, which provides access to previous results on both client and server. The explicit type definition enables TypeScript to properly type the prevResult parameter in the action function.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/form-actions.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { action } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\nimport { zfd } from \"zod-form-data\";\n\nconst schema = zfd.formData({\n  name: zfd.text(z.string().min(1).max(20)),\n});\n\n// Note that we need to explicitly give a type to `stateAction` here, for its return object.\n// This is because TypeScript can't infer the return type of the function and then \"pass it\" to\n// the second argument of the server code function (`prevResult`). If you don't need to access `prevResult`,\n// though, you can omit the type here, since it will be inferred just like with `action` method.\nexport const statefulFormAction = action\n  .schema(schema)\n  // highlight-start\n  .stateAction<{\n    prevName?: string;\n    newName: string;\n  }>(async ({ parsedInput }, { prevResult }) => {\n    return {\n      prevName: prevResult.data?.newName,\n      newName: parsedInput.name,\n    };\n  });\n  // highlight-end\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Callbacks in Next Safe Action with TypeScript\nDESCRIPTION: This code snippet demonstrates how to use action callbacks in Next Safe Action. It shows the structure for implementing onSuccess, onError, and onSettled callbacks, along with their available parameters.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/action-utils.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nconst action = actionClient\n  .schema(z.object({ test: z.string() }))\n  .action(async () => {\n    // ...\n  }, {\n    onSuccess: async ({\n      data,\n      ctx,\n      metadata,\n      clientInput,\n      bindArgsClientInputs,\n      parsedInput,\n      bindArgsParsedInputs,\n      hasRedirected,\n      hasNotFound,\n      hasForbidden,\n      hasUnauthorized\n    }) => {},\n    onError: async ({\n      error,\n      ctx,\n      metadata,\n      clientInput,\n      bindArgsClientInputs\n    }) => {},\n    onSettled: async ({\n      result,\n      ctx,\n      metadata,\n      clientInput,\n      bindArgsClientInputs,\n      hasRedirected,\n      hasNotFound,\n      hasForbidden,\n      hasUnauthorized\n    }) => {},\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a Safe Action Client with Middleware in TypeScript\nDESCRIPTION: Sets up a safe action client with authentication middleware, defining metadata schema and error handling. The code demonstrates how to create reusable middleware and integrate it with the action client.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/types/infer-types.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\nimport { createSafeActionClient, createMiddleware } from \"next-safe-action\";\nimport { getSessionData } from \"@/services/auth\"\n\n// Here we declare a standalone auth middleware.\nexport const authMiddleware = createMiddleware<{\n  ctx: { sessionToken: string };\n  metadata: { actionName: string };\n}>().define(async ({ ctx, next }) => {\n  const { sessionId, userId } = await getSessionData(ctx.sessionToken);\n\n  return next({\n    ctx: {\n      sessionId,\n      userId,\n    },\n  });\n});\n\n// Here we declare the safe action client.\nexport const actionClient = createSafeActionClient({\n  defineMetadataSchema: () => {\n    return z.object({\n      actionName: z.string(),\n    });\n  },\n  handleServerError: (e) => {\n    console.error(\"Action error:\", e.message);\n    return {\n      errorMessage: e.message,\n    };\n  },\n})\n  .use(async ({ next }) => {\n    return next({\n      ctx: {\n        sessionToken: \"someToken\",\n      },\n    });\n  })\n  .use(authMiddleware);\n```\n\n----------------------------------------\n\nTITLE: Using Extended Context in Action with next-safe-action\nDESCRIPTION: This example demonstrates how to use the extended context (sessionId and userId) in an action that was set up by the middleware chain.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\n\nexport const testAction = actionClient\n  .action(async ({ ctx }) => {\n    // Context contains `sessionId` and `userId` thanks to the middleware.\n    const { sessionId, userId } = ctx;\n  });\n```\n\n----------------------------------------\n\nTITLE: Using a Safe Action in a Next.js Client Component\nDESCRIPTION: This snippet shows how to use the 'loginUser' safe action in a Client Component. It demonstrates calling the action directly within an onClick handler of a button.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/direct-execution.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { loginUser } from \"@/app/login-action\";\n\nexport default function Login() {\n  return (\n    <button\n      onClick={async () => {\n        // Result is scoped to this function.\n        const result = await loginUser({\n          username: \"johndoe\",\n          password: \"123456\",\n        });\n\n        // You can do something with it here.\n      }}>\n      Log in\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Action using Auth Client in next-safe-action\nDESCRIPTION: This snippet shows how to define an action using the authActionClient. It demonstrates how to use metadata, input schema, and access the userId from the middleware context.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { authActionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nconst editProfile = authActionClient\n  // We can pass the action name inside `metadata()`.\n  .metadata({ actionName: \"editProfile\" })\n  // Here we pass the input schema.\n  .schema(z.object({ newUsername: z.string() }))\n  // Here we get `userId` from the middleware defined in `authActionClient`.\n  .action(async ({ parsedInput: { newUsername }, ctx: { userId } }) => {\n    await saveNewUsernameInDb(userId, newUsername);\n\n    return {\n      updated: true,\n    };\n  });\n```\n\n----------------------------------------\n\nTITLE: Defining a Server Action with Yup validation\nDESCRIPTION: Creating a server action with Yup validation schema to validate input data. This example shows a login action that checks credentials.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\"; // don't forget to add this!\n\nimport * as y from \"yup\";\nimport { actionClient } from \"@/lib/safe-action\";\n\n// This schema is used to validate input from client.\nconst schema = y.object({\n  username: y.string().min(3).max(10).required(),\n  password: y.string().min(8).max(100).required(),\n});\n\nexport const loginUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { username, password } }) => {\n    if (username === \"johndoe\" && password === \"123456\") {\n      return {\n        success: \"Successfully logged in\",\n      };\n    }\n\n    return { failure: \"Incorrect credentials\" };\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating Stateless Actions with Next Safe Action\nDESCRIPTION: The action method finalizes the safe action definition by accepting a server code function and optional utilities. It returns a callable function for use in components.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\naction(serverCodeFn: ServerCodeFn, utils?: SafeActionUtils) => SafeActionFn\n```\n\n----------------------------------------\n\nTITLE: Using Hooks Path Type Inference Utilities in TypeScript\nDESCRIPTION: Shows how to use utility types exported from the '/hooks' path to infer return types of the useAction, useOptimisticAction, and useStateAction hooks. Demonstrates type inference with different action types.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/types/infer-types.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { testAction } from \"@/app/test-action\";\n\n// Use `InferUseActionHookReturn` to infer the return type of the `useAction` hook with a provided\n// safe action function.\n// highlight-next-line\ntype inferredTestActionHookReturn = InferUseActionHookReturn<typeof testAction>;\n/*\n{\n  execute: (input: { username: string }) => void;\n  executeAsync: (input: { username: string }) => Promise<SafeActionResult>;\n  input: { username: string };\n  result: SafeActionResult;\n  reset: () => void;\n  status: HookActionStatus;\n} & HookShorthandStatus\n*/\n\n// Use `InferUseActionHookReturn` to infer the return type of the `useOptimisticAction` hook with a provided\n// safe action function. You can pass the server state as the second generic parameter, which defaults\n// to `any`.\n// highlight-start\ntype inferredTestActionOptimisticHookReturn = InferUseOptimisticActionHookReturn<\n  typeof testAction,\n  { myServerState: { foo: string } }\n>;\n// highlight-end\n/*\n{\n  execute: (input: { username: string }) => void;\n  executeAsync: (input: { username: string }) => Promise<SafeActionResult>;\n  input: { username: string };\n  result: SafeActionResult;\n  reset: () => void;\n  status: HookActionStatus;\n  optimisticState: { myServerState: { foo: string } };\n} & HookShorthandStatus\n*/\n\n// Use `InferUseStateActionHookReturn` to infer the return type of the `useStateAction` hook with a\n// provided stateful safe action. In this case, by providing the type of `testAction` as the\n// generic parameter will, the resulting type will be `never`, because `testAction` is not defined\n// using `stateAction()` method. Supposing that we change the definition of the function to be stateful,\n// the resulting type will be:\n// highlight-next-line\ntype inferredTestActionStateHookReturn = InferUseStateActionHookReturn<typeof testAction>;\n/*\n{\n  execute: (input: { username: string }) => void;\n  input: { username: string };\n  result: SafeActionResult;\n  status: HookActionStatus;\n} & HookShorthandStatus\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining a Stateless Form Action in TypeScript with next-safe-action\nDESCRIPTION: This code defines a stateless form action using the actionClient.schema() method with zod and zod-form-data for validation. The action processes a name input from FormData and returns a new name after a simulated 1-second delay.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/form-actions.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\nimport { zfd } from \"zod-form-data\";\n\nconst schema = zfd.formData({\n  name: zfd.text(z.string().min(1).max(20)),\n});\n\nexport const statelessFormAction = actionClient\n  .schema(schema)\n  // highlight-start\n  .action(async ({ parsedInput }) => {\n    await new Promise((res) => setTimeout(res, 1000));\n\n    return {\n      newName: parsedInput.name,\n    };\n  });\n  // highlight-end\n```\n\n----------------------------------------\n\nTITLE: Creating Action Client in Next.js (v7)\nDESCRIPTION: Updated example of creating action clients in next-safe-action version 7, showing the new method-based approach with middleware chaining.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/migrations/v6-to-v7.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { cookies } from \"next/headers\";\n\n// Base client\nexport const actionClient = createSafeActionClient();\n\n// Auth client\nexport const authActionClient = actionClient.use(async ({ next, ctx }) => {\n  const session = cookies().get(\"session\")?.value;\n\n  if (!session) {\n    throw new Error(\"Session not found!\");\n  }\n\n  const userId = await getUserIdFromSessionId(session);\n\n  if (!userId) {\n    throw new Error(\"Session is not valid!\");\n  }\n\n  return next({ ctx: { userId } });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Stateful Form with useStateAction Hook\nDESCRIPTION: Creates a client-side form component using useStateAction hook to handle the stateful action. Demonstrates form setup with initial state and basic input handling.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/usestateaction.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useStateAction } from \"next-safe-action/stateful-hooks\";\nimport { statefulAction } from \"./stateful-action\";\n\nexport default function StatefulFormPage() {\n  const { execute, result, status } = useStateAction(statefulAction, {\n    initResult: { data: { newName: \"jane\" } },\n  });\n\n  return (\n    <form action={execute}>\n      <input type=\"text\" name=\"name\" placeholder=\"Name\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Server Code Function for Stateless Next Safe Actions\nDESCRIPTION: The serverCodeFn signature for stateless actions, showing the available arguments including parsed inputs, client inputs, context, and metadata.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nserverCodeFn(\n  args: { parsedInput, bindArgsParsedInputs, clientInput, bindArgsClientInputs, ctx, metadata }\n) => Promise<Data>;\n```\n\n----------------------------------------\n\nTITLE: Defining a Server Action for Todo Management in TypeScript\nDESCRIPTION: This server action creates a function to add new todos to a collection. It uses Zod for input validation and includes a delay to simulate server processing time. The action also revalidates the path to ensure UI updates after the operation completes.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/useoptimisticaction.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { action } from \"@/lib/safe-action\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  id: z.string().uuid(),\n  body: z.string().min(1),\n  completed: z.boolean(),\n});\n\nexport type Todo = z.infer<typeof schema>;\n\nlet todos: Todo[] = [];\nexport const getTodos = async () => todos;\n\nexport const addTodo = action\n  .metadata({ actionName: \"\" })\n  .schema(schema)\n  .action(async ({ parsedInput }) => {\n    await new Promise((res) => setTimeout(res, 500));\n\n    todos.push(parsedInput);\n\n    // This Next.js function revalidates the provided path.\n    // More info here: https://nextjs.org/docs/app/api-reference/functions/revalidatePath\n    revalidatePath(\"/optimistic-hook\");\n\n    return {\n      createdTodo: parsedInput,\n    };\n  });\n\n```\n\n----------------------------------------\n\nTITLE: Server Code Function for Stateful Next Safe Actions\nDESCRIPTION: The serverCodeFn signature for stateful actions, which includes the prevResult utility for accessing the previous execution result from useStateAction.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nserverCodeFn = (\n  args: { parsedInput, bindArgsParsedInputs, clientInput, bindArgsClientInputs, ctx, metadata },\n  utils: { prevResult }\n) => Promise<Data>;\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Component with Stateless Form Action\nDESCRIPTION: This client component uses the useAction hook from next-safe-action to handle a stateless form action. It binds the execute method to the form's action prop, allowing the form submission to be processed by the defined server action.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/form-actions.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useAction } from \"next-safe-action/hooks\";\nimport { statelessFormAction } from \"./stateless-form-action\";\n\nexport default function StatelessForm() {\n  // highlight-next-line\n  const { execute } = useAction(statelessFormAction);\n\n  return (\n    // highlight-next-line\n    <form action={execute}>\n      <input type=\"text\" name=\"name\" placeholder=\"Name\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validation Errors with Schema Refinements in TypeScript\nDESCRIPTION: This snippet shows how to create custom validation errors using schema refinements in Zod. It demonstrates checking if password and confirm password fields match.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/validation-errors.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\nconst schema = z\n  .object({\n    email: z.string().email(),\n    password: z.string().min(8).max(100),\n    confirmPassword: z.string().min(8).max(100),\n  })\n  .refine(({ password, confirmPassword }) => password === confirmPassword, {\n    path: [\"confirmPassword\"],\n    message: \"Passwords do not match\",\n  });\n```\n\n----------------------------------------\n\nTITLE: Defining Server Action with Bind Arguments in TypeScript\nDESCRIPTION: Creates a server action that validates both the main input argument and additional bind arguments using Zod schemas. The action accepts userId and age as bind arguments and a username as the main argument.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/bind-arguments.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  username: z.string().min(3).max(30),\n});\n\nexport const onboardUser = actionClient\n  .schema(schema)\n  // We can pass a named tuple type here, to get named parameters in the final function.\n  .bindArgsSchemas<[userId: z.ZodString, age: z.ZodNumber]>([\n    z.string().uuid(),\n    z.number().min(18).max(150),\n  ])\n  .action(\n    async ({\n      parsedInput: { username },\n      bindArgsParsedInputs: [userId, age],\n    }) => {\n      await new Promise((res) => setTimeout(res, 1000));\n\n      return {\n        message: `Welcome on board, ${username}! (age = ${age}, user id = ${userId})`,\n      };\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Defining Output Schema for Next Safe Actions\nDESCRIPTION: The outputSchema method specifies a validation schema for the action's return value. If validation fails, an ActionOutputDataValidationError is thrown that can be caught in handleServerError.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\noutputSchema(outputSchema: S) => new SafeActionClient()\n```\n\n----------------------------------------\n\nTITLE: Creating Stateful Actions with Next Safe Action\nDESCRIPTION: The stateAction method creates an action that works with the useStateAction hook, allowing access to previous results. This enables stateful server actions.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nstateAction(serverCodeFn: StateServerCodeFn, utils?: SafeActionUtils) => SafeStateActionFn\n```\n\n----------------------------------------\n\nTITLE: Using Middleware with Next Safe Action Client\nDESCRIPTION: The use method attaches middleware functions to the SafeActionClient. It returns a new instance with the added middleware that will execute after any previously defined middleware.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuse(middlewareFn: MiddlewareFn) => new SafeActionClient()\n```\n\n----------------------------------------\n\nTITLE: Extending Context in Middleware Chain with next-safe-action\nDESCRIPTION: This snippet shows how to extend the context object through multiple middleware functions. It demonstrates adding sessionId and userId to the context, which can then be used in the action.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/middleware.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nexport const actionClient = createSafeActionClient()\n  .use(async ({ next }) => {\n    const sessionId = await getSessionId();\n    return next({ ctx: { sessionId } })\n  })\n  .use(async ({ next, ctx }) => {\n    const { sessionId } = ctx; // Context contains `sessionId`\n    const userId = await getUserIdBySessionId(sessionId);\n    return next({ ctx: { userId } })\n  })\n  .use(async ({ next }) => {\n    // You can also define a middleware function that doesn't extend or modify the context.\n    return next();\n  })\n```\n\n----------------------------------------\n\nTITLE: Creating Action Client in Next.js (v6)\nDESCRIPTION: Example of creating base and auth action clients in next-safe-action version 6, demonstrating middleware implementation for session validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/migrations/v6-to-v7.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { cookies } from \"next/headers\";\n\n// Base client\nexport const baseActionClient = createSafeActionClient();\n\n// Auth client\nexport const authActionClient = createSafeActionClient({\n  async middleware(parsedInput) {\n    const session = cookies().get(\"session\")?.value;\n\n    if (!session) {\n      throw new Error(\"Session not found!\");\n    }\n\n    const userId = await getUserIdFromSessionId(session);\n\n    if (!userId) {\n      throw new Error(\"Session is not valid!\");\n    }\n\n    return { userId };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Safe Action for User Login in Next.js\nDESCRIPTION: This snippet demonstrates how to define a safe action called 'loginUser' using next-safe-action. It uses Zod for input validation and sets up a schema for username and password.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/direct-execution.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { returnValidationErrors } from \"next-safe-action\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  username: z.string().min(3).max(10),\n  password: z.string().min(8).max(100),\n});\n\nexport const loginUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { username, password } }) => {\n    // logic here...\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Handler in Next.js (v6)\nDESCRIPTION: Example of implementing an authenticated action handler using next-safe-action version 6 with Zod schema validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/migrations/v6-to-v7.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { authActionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nexport const editProfile = authActionClient(z.object({ username: z.string() }), async ({ username }, { ctx: { userId } }) => {\n  await saveNewUsernameInDb(userId, username);\n\n  return {\n    updated: true,\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Server Action with Valibot validation\nDESCRIPTION: Creating a server action with Valibot validation schema to validate input data. This example shows a login action that checks credentials.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\"; // don't forget to add this!\n\nimport * as v from \"valibot\";\nimport { actionClient } from \"@/lib/safe-action\";\n\n// This schema is used to validate input from client.\nconst schema = v.object({\n  username: v.pipe(v.string(), v.minLength(3), v.maxLength(10)),\n  password: v.pipe(v.string(), v.minLength(8), v.maxLength(100)),\n});\n\nexport const loginUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { username, password } }) => {\n    if (username === \"johndoe\" && password === \"123456\") {\n      return {\n        success: \"Successfully logged in\",\n      };\n    }\n\n    return { failure: \"Incorrect credentials\" };\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a next-safe-action client with Zod\nDESCRIPTION: TypeScript code for instantiating a safe action client using Zod as the validation library, which is the default option.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nexport const actionClient = createSafeActionClient();\n```\n\n----------------------------------------\n\nTITLE: Defining a Server Action with TypeBox validation\nDESCRIPTION: Creating a server action with TypeBox validation schema to validate input data. This example shows a login action that checks credentials.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\"; // don't forget to add this!\n\nimport { Type } from \"@sinclair/typebox\";\nimport { actionClient } from \"@/lib/safe-action\";\n\n// This schema is used to validate input from client.\nconst schema = Type.Object({\n  username: Type.String({ minLength: 3, maxLength: 10 }),\n  password: Type.String({ minLength: 8, maxLength: 100 }),\n});\n\nexport const loginUser = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { username, password } }) => {\n    if (username === \"johndoe\" && password === \"123456\") {\n      return {\n        success: \"Successfully logged in\",\n      };\n    }\n\n    return { failure: \"Incorrect credentials\" };\n  });\n```\n\n----------------------------------------\n\nTITLE: Using Root Path Type Inference Utilities in TypeScript\nDESCRIPTION: Demonstrates how to use the utility types exported from the root path of next-safe-action to infer types from various components. Shows inference for inputs, results, context, metadata, and server errors.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/types/infer-types.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  InferCtx,\n  InferMetadata,\n  InferMiddlewareFnNextCtx,\n  InferSafeActionFnInput,\n  InferSafeActionFnResult,\n  InferServerError,\n} from \"next-safe-action\";\nimport type { actionClient, authMiddleware } from \"@/lib/safe-action\";\nimport type { testAction } from \"@/app/test-action\";\n\n// Use `InferSafeActionFnInput` to infer the input types of a safe action function.\n// highlight-next-line\ntype inferredTestActionInput = InferSafeActionFnInput<typeof testAction>;\n/*\n{\n  clientInput: {\n    username: string;\n  };\n  bindArgsClientInputs: [email: string, age: number];\n  parsedInput: {\n    username: string;\n  };\n  bindArgsParsedInputs: [email: string, age: number];\n}\n*/\n\n// Use `InferSafeActionFnResult` to infer the result type of a safe action function.\n// highlight-next-line\ntype inferredTestActionResult = InferSafeActionFnResult<typeof testAction>;\n/*\n{\n  data?: {\n    successful: boolean;\n  } | undefined;\n  serverError?: string | undefined;\n  validationErrors?: {\n    _errors?: string[];\n    username?: {\n      _errors?: string[];\n    } | undefined;\n  } | undefined;\n  bindArgsValidationErrors?: [email: { _errors?: string[] }, age: { _errors?: string[] }] | undefined;\n}\n*/\n\n// Use `InferMiddlewareFnNextCtx` to infer the type of the context returned by a middleware function using\n// the `next` function.\n// highlight-next-line\ntype inferredAuthMiddlewareNextCtx = InferMiddlewareFnNextCtx<typeof authMiddleware>;\n/*\n{\n  sessionId: string;\n  userId: string;\n}\n*/\n\n// Use `InferCtx` to infer the type of the context of a safe action client, or the context passed to a\n// middleware function. Here's an example with a safe action client:\n// highlight-next-line\ntype inferredSafeActionClientCtx = InferCtx<typeof actionClient>;\n/*\n{\n  sessionToken: string;\n} & {\n  sessionId: string;\n  userId: string;\n}\n*/\n\n// Use `InferMetadata` to infer the type of the metadata of a safe action client or middleware function.\n// Here's an example with a middleware function:\n// highlight-next-line\ntype inferredMiddlewareMetadata = InferMetadata<typeof authMiddleware>;\n/*\n{\n  actionName: string;\n}\n*/\n\n// Use `InferServerError` to infer the type of the `serverError` of a safe action client, middleware function,\n// or safe action function. Here's an example with a safe action:\n// highlight-next-line\ntype inferredServerError = InferServerError<typeof testAction>;\n/*\n{\n  errorMessage: string;\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Extending Zod Schema in Next-Safe-Action with TypeScript\nDESCRIPTION: Shows how to extend a base schema with additional properties using chained schema methods. The example demonstrates adding password and age fields to an initial username schema, with proper type validation using Zod.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/extend-previous-schemas.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  username: z.string(),\n});\n\nconst myAction = actionClient\n  .schema(schema)\n  .schema(async (prevSchema) => {\n    // Here we extend the previous schema with `password` property.\n    return prevSchema.extend({ password: z.string() });\n  })\n  .schema(async (prevSchema) => {\n    // Here with `age` property.\n    return prevSchema.extend({ age: z.number().positive() });\n  })\n  // `parsedInput` will be an object with `username`, `password` and `age` properties.\n  .action(async ({ parsedInput: { username, password, age } }) => { \n    // Do something useful here...\n  });\n```\n\n----------------------------------------\n\nTITLE: Custom Error Class Implementation\nDESCRIPTION: Implements error handling with custom error class and conditional error messages.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient, DEFAULT_SERVER_ERROR_MESSAGE } from \"next-safe-action\";\n\nclass MyCustomError extends Error {}\n\nexport const actionClient = createSafeActionClient({\n  handleServerError(e) {\n    console.error(\"Action error:\", e.message);\n    if (e instanceof MyCustomError) {\n      return e.message;\n    }\n    return DEFAULT_SERVER_ERROR_MESSAGE;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Handler in Next.js (v7)\nDESCRIPTION: Updated implementation of an authenticated action handler using next-safe-action version 7, demonstrating the new method chaining syntax.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/migrations/v6-to-v7.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { authActionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\n\nexport const editProfile = authActionClient\n  .schema(z.object({ username: z.string() }))\n  .action(async ({ parsedInput: { username }, ctx: { userId } }) => {\n    await saveNewusernameInDb(userId, username)\n\n    return {\n      updated: true,\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a next-safe-action client with Valibot\nDESCRIPTION: TypeScript code for instantiating a safe action client using Valibot adapter for validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { valibotAdapter } from \"next-safe-action/adapters/valibot\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: valibotAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Bound Action in Client Component\nDESCRIPTION: Demonstrates how to bind additional arguments to a server action in a client component using the bind method, and how to use the bound action with the useAction hook from next-safe-action.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/bind-arguments.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"use client\";\n\nimport { useAction } from \"next-safe-action/hooks\";\nimport { onboardUser } from \"./onboard-action\";\n\nexport default function OnboardPage() {\n  // Here we bind `userId` and `age` to `onboardUser`.\n  // `boundOnboardUser` will have just `{ username: string }` as its argument, after this `bind` call.\n  const boundOnboardUser = onboardUser.bind(\n    null,\n    \"d3a96f0f-e509-4f2f-b7d0-cdf50f0dc772\",\n    30\n  );\n\n  const { execute, result, status, reset } = useAction(boundOnboardUser);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a next-safe-action client with Yup\nDESCRIPTION: TypeScript code for instantiating a safe action client using Yup adapter for validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { yupAdapter } from \"next-safe-action/adapters/yup\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: yupAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Using returnValidationErrors for Custom Validation in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the returnValidationErrors function to create custom validation errors within the action's server code function. It checks if an email is already registered and returns a custom validation error if so.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/validation-errors.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { returnValidationErrors } from \"next-safe-action\";\nimport { actionClient } from \"@/lib/safe-action\";\n\n// Here we're using the same schema declared above.\nconst signupAction = actionClient\n  .schema(schema)\n  .action(async ({ parsedInput: { email } }) => {\n    // Assume this is a database call.\n    if (!isEmailAvailable(email)) {\n      returnValidationErrors(schema, {\n        email: {\n          _errors: [\"Email already registered\"],\n        },\n      });\n    }\n\n    ...\n  });\n```\n\n----------------------------------------\n\nTITLE: Initializing Safe Action Client with Yup\nDESCRIPTION: Creates a safe action client instance using the Yup validation adapter.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { yupAdapter } from \"next-safe-action/adapters/yup\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: yupAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing i18n with next-safe-action in TypeScript\nDESCRIPTION: This code snippet demonstrates how to set up next-safe-action with an i18n solution. It defines an async function to fetch translations and create a schema, then uses this function in the actionClient.schema() method. This approach allows for dynamic schema creation based on translated content.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/recipes/i18n.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport { z } from \"zod\";\nimport { getTranslations } from \"my-i18n-lib\";\n\nasync function getSchema() {\n  // This is an example of a i18n setup.\n  const t = await getTranslations();\n  return mySchema(t); // this is the schema that will be used to validate and parse the input\n}\n\nexport const myAction = actionClient.schema(getSchema).action(async ({ parsedInput }) => {\n  // Do something useful here...\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Safe Action Client with TypeBox\nDESCRIPTION: Creates a safe action client instance using the TypeBox validation adapter.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { typeboxAdapter } from \"next-safe-action/adapters/typebox\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: typeboxAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Safe Action Client with Zod\nDESCRIPTION: Creates a basic safe action client instance using the default Zod validation adapter.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nexport const actionClient = createSafeActionClient();\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action via npm\nDESCRIPTION: Command to install the next-safe-action library using npm package manager. This is the first step to integrate the library into a Next.js project.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/packages/next-safe-action/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action\n```\n\n----------------------------------------\n\nTITLE: Defining a Server Action with Schema Validation in TypeScript\nDESCRIPTION: Creates a server action using the action client with schema validation. The action applies middleware, defines input validation schema using Zod, and binds argument schemas.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/types/infer-types.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { z } from \"zod\";\nimport { actionClient } from \"@/lib/safe-action\";\n\nconst testActionSchema = z.object({\n  username: z.string(),\n});\n\nconst testActionBindArgsSchemas: [email: z.ZodString, age: z.ZodNumber] = [z.string(), z.number()];\n\nexport const testAction = actionClient\n  .use(authMiddleware)\n  .schema(testActionSchema)\n  .bindArgsSchemas(testActionBindArgsSchemas)\n  .action(async () => {\n    return {\n      successful: true,\n    };\n  });\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action with Yup\nDESCRIPTION: Command to install next-safe-action with Yup validation library using npm.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action yup\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Server Component to Pass Data to Client Component in Next.js\nDESCRIPTION: This Next.js server component fetches the current todos using the getTodos function and passes them to a client component called TodosBox. This pattern allows the server to provide fresh data to the client component after revalidation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/useoptimisticaction.md#2025-04-16_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getTodos } from \"./addtodo-action\";\n\nexport default function Home() {\n  return (\n    <main>\n      {/* Here we pass current todos to the Client Component.\n      This is updated on the server every time the action is executed, since we\n      used `revalidatePath()` inside action's server code. */}\n      <TodosBox todos={getTodos()} />\n    </main>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Safe Action Client with Valibot\nDESCRIPTION: Creates a safe action client instance using the Valibot validation adapter.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { valibotAdapter } from \"next-safe-action/adapters/valibot\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: valibotAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Input Schema for Next Safe Actions\nDESCRIPTION: The schema method defines the validation schema for action input arguments. It optionally accepts a utility function to customize validation error formatting.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nschema(inputSchema: S, utils?: { handleValidationErrorsShape?: HandleValidationErrorsShapeFn } }) => new SafeActionClient()\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Error Handling\nDESCRIPTION: Implements custom server error handling with console logging and generic error message.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nexport const actionClient = createSafeActionClient({\n  handleServerError(e, utils) {\n    const { clientInput, bindArgsClientInputs, metadata, ctx } = utils;\n    console.error(\"Action error:\", e.message);\n    return \"Oh no, something went wrong!\";\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Validation Errors Format in TypeScript\nDESCRIPTION: This snippet demonstrates how to customize validation error formats using handleValidationErrorsShape and handleBindArgsValidationErrorsShape functions in next-safe-action. It uses flattenValidationErrors and flattenBindArgsValidationErrors utility functions to flatten the error structure.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/validation-errors.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"use server\";\n\nimport { actionClient } from \"@/lib/safe-action\";\nimport {\n  flattenValidationErrors,\n  flattenBindArgsValidationErrors,\n} from \"next-safe-action\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  username: z.string().min(3).max(10),\n  password: z.string().min(8).max(100),\n});\n\nconst bindArgsSchemas = [z.string().uuid()] as const;\n\nexport const loginUser = actionClient\n  .schema(schema, {\n    // Here we use the `flattenValidationErrors` function to customize the returned validation errors\n    // object to the client.\n    handleValidationErrorsShape: async (ve, utils) => flattenValidationErrors(ve).fieldErrors,\n  })\n  .bindArgsSchemas(bindArgsSchemas, {\n    // Here we use the `flattenBindArgsValidatonErrors` function to customize the returned bind args\n    // validation errors object array to the client.\n    handleBindArgsValidationErrorsShape: async (ve, utils) => flattenBindArgsValidationErrors(ve),\n  })\n  .action(async ({ parsedInput: { username, password } }) => {\n    // Your code here...\n  });\n```\n\n----------------------------------------\n\nTITLE: Progressive Enhancement with useActionState\nDESCRIPTION: Shows how to implement progressive enhancement using React's useActionState hook directly instead of useStateAction for better compatibility when JavaScript is disabled.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/execute-actions/hooks/usestateaction.md#2025-04-16_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport { useActionState } from \"react\";\nimport { testAction } from \"./action\";\n\nexport function TestForm() {\n  const [state, action, isPending] = useActionState(testAction, {});\n\n  return {\n    <form action={action}>\n      ...\n    </form>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Arguments Schemas for Next Safe Actions\nDESCRIPTION: The bindArgsSchemas method defines validation schemas for bind arguments passed to the safe action. It allows customizing the validation error format for bound arguments.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nbindArgsSchemas(bindArgsSchemas: BAS, bindArgsUtils?: { handleBindArgsValidationErrorsShape?: HandleBindArgsValidationErrorsShapeFn }) => new SafeActionClient()\n```\n\n----------------------------------------\n\nTITLE: Setting Metadata for Next Safe Actions\nDESCRIPTION: The metadata method allows specifying additional information about the safe action being executed. This metadata is accessible in middleware functions and server code functions during execution.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/instance-methods.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmetadata(data: Metadata) => new SafeActionClient()\n```\n\n----------------------------------------\n\nTITLE: Creating a next-safe-action client with TypeBox\nDESCRIPTION: TypeScript code for instantiating a safe action client using TypeBox adapter for validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { typeboxAdapter } from \"next-safe-action/adapters/typebox\";\n\nexport const actionClient = createSafeActionClient({\n  validationAdapter: typeboxAdapter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Server Error Rethrowing Configuration\nDESCRIPTION: Configures error handling to rethrow all server errors instead of returning error messages.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nclass MyCustomError extends Error {}\n\nexport const actionClient = createSafeActionClient({\n  handleServerError(e) {\n    console.error(\"Action error:\", e.message);\n    throw e;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Metadata Schema Definition\nDESCRIPTION: Defines a metadata schema for safe actions using Zod validation.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\nimport { z } from \"zod\";\n\nexport const actionClient = createSafeActionClient({\n  defineMetadataSchema() {\n    return z.object({\n      actionName: z.string(),\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Validation Errors Shape Configuration\nDESCRIPTION: Configures the default shape of validation errors to use flattened format.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/define-actions/create-the-client.mdx#2025-04-16_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSafeActionClient } from \"next-safe-action\";\n\nexport const actionClient = createSafeActionClient({\n  defaultValidationErrorsShape: \"flattened\",\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Next-Safe-Action with React Hook Form Dependencies\nDESCRIPTION: Command to install next-safe-action along with React Hook Form and its required dependencies including the adapter package.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/integrations/react-hook-form.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action react-hook-form @hookform/resolvers @next-safe-action/adapter-react-hook-form\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig.json for Monorepo TypeScript Error Resolution\nDESCRIPTION: This JSON configuration sets the 'baseUrl' compiler option in tsconfig.json to resolve a common TypeScript error in monorepo setups using next-safe-action.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/troubleshooting.md#2025-04-16_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action via npm\nDESCRIPTION: Command to install the next-safe-action library using npm package manager. This installs the library as a dependency in your Next.js project.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action with Zod\nDESCRIPTION: Command to install next-safe-action with Zod validation library using npm.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action zod\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action with Valibot\nDESCRIPTION: Command to install next-safe-action with Valibot validation library using npm.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action valibot\n```\n\n----------------------------------------\n\nTITLE: Installing next-safe-action with TypeBox\nDESCRIPTION: Command to install next-safe-action with TypeBox validation library using npm.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/getting-started.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i next-safe-action @sinclair/typebox\n```\n\n----------------------------------------\n\nTITLE: Removing Experimental Server Actions Configuration in Next.js Config\nDESCRIPTION: This diff shows the breaking change required when migrating to next-safe-action v5. You need to remove the experimental server actions flag from your Next.js configuration file as Server Actions are now stable in Next.js 14.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/migrations/v4-to-v5.md#2025-04-16_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nmodule.exports = {\n-  experimental: {\n-    serverActions: true\n-  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Library and Running Playground\nDESCRIPTION: Command to rebuild the library code and then test it in the playground app. This is essential when making changes to the library and wanting to test them.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/CONTRIBUTING.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm run build:lib && pnpm run pg\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with pnpm\nDESCRIPTION: Command to install all project dependencies using pnpm package manager in the root directory of the project.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/CONTRIBUTING.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Starting Docusaurus Development Server\nDESCRIPTION: Command to start the Docusaurus development server for the website project, allowing contributors to preview documentation changes.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/CONTRIBUTING.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npnpm run start\n```\n\n----------------------------------------\n\nTITLE: Displaying Sponsor Logo with Light/Dark Mode Support in HTML\nDESCRIPTION: HTML code snippet that displays the Arcjet sponsor logo with support for light and dark color schemes using the picture element and srcSet attribute.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/website/docs/contributing.md#2025-04-16_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"https://arcjet.com/?ref=next-safe-action\" target=\"_blank\">\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcSet=\"https://arcjet.com/logo/arcjet-dark-lockup-voyage-horizontal.svg\" />\n    <img src=\"https://arcjet.com/logo/arcjet-light-lockup-voyage-horizontal.svg\" alt=\"Arcjet Logo\" height=\"128\" width=\"auto\" />\n  </picture>\n  <br />Arcjet\n</a>\n```\n\n----------------------------------------\n\nTITLE: Creating a Conventional Commit\nDESCRIPTION: Command to create a commit using commitizen interface without bringing up the default editor. This ensures commits follow the Conventional Commits format required by the project.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/CONTRIBUTING.md#2025-04-16_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit commit --no-edit\n```\n\n----------------------------------------\n\nTITLE: Installing Website Dependencies\nDESCRIPTION: Command to install dependencies for the website project, which is not part of the monorepo packages and requires a separate installation process.\nSOURCE: https://github.com/TheEdoRan/next-safe-action/blob/main/CONTRIBUTING.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```"
  }
]