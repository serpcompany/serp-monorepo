[
  {
    "owner": "dry-rb",
    "repo": "dry-container",
    "content": "TITLE: Advanced Container Usage with Data Structures in Ruby\nDESCRIPTION: Shows comprehensive usage of dry-container including struct definitions, concurrent data stores, namespace management, and different registration options.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/index.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-container'\n\nUser = Struct.new(:name, :email)\n\ndata_store = Concurrent::Map.new.tap do |ds|\n  ds[:users] = Concurrent::Array.new\nend\n\n# Initialize container\ncontainer = Dry::Container.new\n\n# Register an item with the container to be resolved later\ncontainer.register(:data_store, data_store)\ncontainer.register(:user_repository, -> { container.resolve(:data_store)[:users] })\n\n# Resolve an item from the container\ncontainer.resolve(:user_repository) << User.new('Jack', 'jack@dry-container.com')\n# You can also resolve with []\ncontainer[:user_repository] << User.new('Jill', 'jill@dry-container.com')\n# => [\n#      #<struct User name=\"Jack\", email=\"jack@dry-container.com\">,\n#      #<struct User name=\"Jill\", email=\"jill@dry-container.com\">\n#    ]\n\n# If you wish to register an item that responds to call but don't want it to be\n# called when resolved, you can use the options hash\ncontainer.register(:proc, -> { :result }, call: false)\ncontainer.resolve(:proc)\n# => #<Proc:0x007fa75e652c98@(irb):25 (lambda)>\n\n# You can also register using a block\ncontainer.register(:item) do\n  :result\nend\ncontainer.resolve(:item)\n# => :result\n\ncontainer.register(:block, call: false) do\n  :result\nend\ncontainer.resolve(:block)\n# => #<Proc:0x007fa75e6830f0@(irb):36>\n\n# You can also register items under namespaces using the #namespace method\ncontainer.namespace('repositories') do\n  namespace('checkout') do\n    register('orders') { Concurrent::Array.new }\n  end\nend\ncontainer.resolve('repositories.checkout.orders')\n# => []\n\n# Or import a namespace\nns = Dry::Container::Namespace.new('repositories') do\n  namespace('authentication') do\n    register('users') { Concurrent::Array.new }\n  end\nend\ncontainer.import(ns)\ncontainer.resolve('repositories.authentication.users')\n# => []\n\n# Also, you can import namespaces in container class\nRepositories = Dry::Container::Namespace.new('repositories') do\n  namespace('authentication') do\n    register('users') { Concurrent::Array.new }\n  end\nend\n\nclass Container\n  extend Dry::Container::Mixin\n  import Repositories\nend\n\nContainer.resolve('repositories.authentication.users')\n# => []\n```\n\n----------------------------------------\n\nTITLE: Customizing Registry and Resolver in Dry::Container\nDESCRIPTION: This snippet shows how to customize the registry and resolver behavior in Dry::Container. It demonstrates creating a custom resolver that handles renamed keys and configuring both class-based and object-based containers to use custom registry and resolver implementations.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/registry-and-resolver.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass CustomResolver < Dry::Container::Resolver\n  RENAMED_KEYS = { 'old' => 'new' }\n\n  def call(container, key)\n    container.fetch(key.to_s) {\n      fallback_key = RENAMED_KEYS.fetch(key.to_s) {\n        raise Error, \"Missing #{ key }\"\n      }\n      container.fetch(fallback_key) {\n        raise Error, \"Missing #{ key } and #{ fallback_key }\"\n      }\n    }.call\n  end\nend\n\nclass Container\n  extend Dry::Container::Mixin\n\n  config.registry = ->(container, key, item, options) { container[key] = item }\n  config.resolver = CustomResolver\nend\n\nclass ContainerObject\n  include Dry::Container::Mixin\n\n  config.registry = ->(container, key, item, options) { container[key] = item }\n  config.resolver = CustomResolver\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Container Usage in Ruby\nDESCRIPTION: Demonstrates the basic usage of dry-container by registering and resolving a simple callable object.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/index.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-container'\n\ncontainer = Dry::Container.new\ncontainer.register(:parrot) { |a| puts a }\n\nparrot = container.resolve(:parrot)\nparrot.call(\"Hello World\")\n# Hello World\n# => nil\n```\n\n----------------------------------------\n\nTITLE: Container Mixin Usage in Ruby Classes\nDESCRIPTION: Demonstrates how to use dry-container's mixin functionality at both class and instance levels.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/index.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-container'\n\nclass Container\n  extend Dry::Container::Mixin\nend\nContainer.register(:item, :my_item)\nContainer.resolve(:item)\n# => :my_item\n\nclass ContainerObject\n  include Dry::Container::Mixin\nend\ncontainer = ContainerObject.new\ncontainer.register(:item, :my_item)\ncontainer.resolve(:item)\n# => :my_item\n```\n\n----------------------------------------\n\nTITLE: Stubbing Container Registrations in dry-container\nDESCRIPTION: Shows how to stub a registered dependency in a dry-container. The example demonstrates registering a Redis instance, enabling stubs for the container, and then stubbing the Redis registration with a test double.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/testing.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer = Dry::Container.new\ncontainer.register(:redis) { \"Redis instance\" }\n\ncontainer[:redis] # => \"Redis instance\"\n\nrequire 'dry/container/stub'\n\n# before stub you need to enable stubs for specific container\ncontainer.enable_stubs!\ncontainer.stub(:redis, \"Stubbed redis instance\")\n\ncontainer[:redis] # => \"Stubbed redis instance\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fallback Block Usage with Container.resolve in Ruby\nDESCRIPTION: Shows how to use a fallback block with Container.resolve method, similar to Hash#fetch functionality. This allows providing a default value when a key cannot be resolved.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/CHANGELOG.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer.resolve('missing_key') { :fallback } # => :fallback\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Object Decoration in Container with Ruby\nDESCRIPTION: Shows how to decorate registered objects in a container using the 'with' parameter. This example wraps a CreateUser service with a logger.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/CHANGELOG.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass CreateUser\n  def call(params)\n    # ...\n  end\nend\ncontainer.register('create_user') { CreateUser.new }\ncontainer.decorate('create_user', with: ShinyLogger.new)\n\n# Now subsequent resolutions will return a wrapped object\n\ncontainer.resolve('create_user')\n# => #<ShinyLogger @obj=#<CreateUser:0x...>]>\n```\n\n----------------------------------------\n\nTITLE: Using the 'call' option with Dry::Container in Ruby\nDESCRIPTION: This snippet demonstrates how the 'call' option affects item resolution in Dry::Container. When 'call' is set to false, the container returns the proc itself. When set to true, the container invokes the proc when the item is resolved.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/registry-and-resolver.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer = Dry::Container.new\ncontainer.register(:key_1, call: false) { \"Integer: #{rand(1000)}\" }\ncontainer.register(:key_2, call: true)  { \"Integer: #{rand(1000)}\" }\n\ncontainer.resolve(:key_1) # => <Proc:0x007f98c90454c0@dry_c.rb:23>\ncontainer.resolve(:key_1) # => <Proc:0x007f98c90454c0@dry_c.rb:23>\n\ncontainer.resolve(:key_2) # => \"Integer: 157\"\ncontainer.resolve(:key_2) # => \"Integer: 713\"\n```\n\n----------------------------------------\n\nTITLE: Using the 'memoize' option with Dry::Container in Ruby\nDESCRIPTION: This snippet demonstrates how the 'memoize' option affects item resolution in Dry::Container. When 'memoize' is set to true, the container caches the result of the first invocation and returns it for subsequent calls. When false, the container invokes the proc on each resolution.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/registry-and-resolver.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer = Dry::Container.new\ncontainer.register(:key_1, memoize: true)  { \"Integer: #{rand(1000)}\" }\ncontainer.register(:key_2, memoize: false) { \"Integer: #{rand(1000)}\" }\n\ncontainer.resolve(:key_1) # => \"Integer: 734\"\ncontainer.resolve(:key_1) # => \"Integer: 734\"\n\ncontainer.resolve(:key_2) # => \"Integer: 855\"\ncontainer.resolve(:key_2) # => \"Integer: 282\"\n```\n\n----------------------------------------\n\nTITLE: Unstubbing Individual Container Registrations in dry-container\nDESCRIPTION: Demonstrates how to revert a stubbed dependency back to its original implementation. The example shows how to register a Redis instance, stub it, and then unstub it to return to the original implementation.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/testing.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer = Dry::Container.new\ncontainer.register(:redis) { \"Redis instance\" }\ncontainer[:redis] # => \"Redis instance\"\n\nrequire 'dry/container/stub'\ncontainer.enable_stubs!\n\ncontainer.stub(:redis, \"Stubbed redis instance\")\ncontainer[:redis] # => \"Stubbed redis instance\"\n\ncontainer.unstub(:redis) # => \"Redis instance\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Container.decorate with Block Usage in Ruby\nDESCRIPTION: Illustrates how to use the decorate method with a block to transform container values. This example shows decorating a static string value.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/CHANGELOG.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer.register('key', 'value')\ncontainer.decorate('key') { |v| \"<'#{v}'>\" }\ncontainer.resolve('key') # => \"<'value'>\"\n```\n\n----------------------------------------\n\nTITLE: Clearing All Container Stubs in dry-container\nDESCRIPTION: Shows how to clear all stubs from a container at once. The example registers multiple dependencies, stubs them, and then demonstrates using the unstub method without arguments to reset all stubs simultaneously.\nSOURCE: https://github.com/dry-rb/dry-container/blob/main/docsite/source/testing.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncontainer = Dry::Container.new\ncontainer.register(:redis) { \"Redis instance\" }\ncontainer.register(:db) { \"DB instance\" }\n\nrequire 'dry/container/stub'\ncontainer.enable_stubs!\ncontainer.stub(:redis, \"Stubbed redis instance\")\ncontainer.stub(:db, \"Stubbed DB instance\")\n\ncontainer.unstub # This will unstub all previously stubbed keys\n\ncontainer[:redis] # => \"Redis instance\"\ncontainer[:db] # => \"Redis instance\"\n```"
  }
]