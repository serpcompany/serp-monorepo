[
  {
    "owner": "dry-rb",
    "repo": "dry-schema",
    "content": "TITLE: Calling a Schema in dry-schema\nDESCRIPTION: Demonstrates how to create a schema with validation rules, call it with data, and access the validation results. The schema validates email and age fields with type specifications.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/working-with-schemas.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:age).filled(:integer)\nend\n\nresult = schema.call(email: 'jane@doe.org', age: 21)\n\n# access validation output data\nresult.to_h\n# => {:email=>'jane@doe.org', :age=>21}\n\n# check if all rules passed\nresult.success?\n# => true\n\n# check if any of the rules failed\nresult.failure?\n# => false\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Schema with dry-schema in Ruby\nDESCRIPTION: Demonstrates how to define and use a user validation schema using dry-schema's Params type. The example shows validation of nested data structures, required/optional fields, and type checking with the result inspection showing validation errors.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/index.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\n\nUserSchema = Dry::Schema.Params do\n  required(:name).filled(:string)\n  required(:email).filled(:string)\n\n  required(:age).maybe(:integer)\n\n  required(:address).hash do\n    required(:street).filled(:string)\n    required(:city).filled(:string)\n    required(:zipcode).filled(:string)\n  end\nend\n\nUserSchema.(\n  name: 'Jane',\n  email: 'jane@doe.org',\n  address: { street: 'Street 1', city: 'NYC', zipcode: '1234' }\n).inspect\n\n# #<Dry::Schema::Result{:name=>\"Jane\", :email=>\"jane@doe.org\", :address=>{:street=>\"Street 1\", :city=>\"NYC\", :zipcode=>\"1234\"}} errors={:age=>[\"age is missing\"]}>\n```\n\n----------------------------------------\n\nTITLE: Using Value Macro in Dry Schema\nDESCRIPTION: Demonstrates using the value macro to define predicates that will be AND-ed automatically. Shows how to validate integer values and combine multiple types.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to `required(:age) { int? & gt?(18) }`\n  required(:age).value(:integer, gt?: 18)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to `required(:id) { str? | int? }`\n  required(:id).value([:string, :integer])\nend\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Basic Validation Schema with Dry::Schema in Ruby\nDESCRIPTION: This example demonstrates how to create a validation schema with Dry::Schema.Params that validates email and age inputs. It shows how to define required fields with type constraints and additional validation rules, then apply the schema to different inputs to see successful and failed validation results.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-schema'\n\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:age).filled(:integer, gt?: 18)\nend\n\nschema.call(email: 'jane@doe.org', age: 19)\n# #<Dry::Schema::Result{:email=>\"jane@doe.org\", :age=>19} errors={}>\n\nschema.call(\"email\" => \"\", \"age\" => \"19\")\n# #<Dry::Schema::Result{:email=>\"\", :age=>19} errors={:email=>[\"must be filled\"]}>\n```\n\n----------------------------------------\n\nTITLE: Validating JSON Data with dry-schema in Ruby\nDESCRIPTION: Example demonstrating how to create and use a JSON schema for validating email and age fields. The schema enforces that email must be a filled string and age must be an integer greater than 18. Shows error handling and output format.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/json.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.JSON do\n  required(:email).filled(:string)\n  required(:age).value(:integer, gt?: 18)\nend\n\nerrors = schema.call('email' => '', 'age' => 18).errors.to_h\n\nputs errors.inspect\n# {\n#   :email => [\"must be filled\"],\n#   :age => [\"must be greater than 18\"]\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Params Schema for HTTP Parameter Validation in Ruby\nDESCRIPTION: This snippet demonstrates how to create a basic Params schema that validates an email field as a non-empty string and an age field as an integer greater than 18. It shows how the schema handles stringified input keys and type coercion automatically.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/params.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:age).filled(:integer, gt?: 18)\nend\n\nerrors = schema.call('email' => '', 'age' => '18').errors\n\nputs errors.to_h.inspect\n# {\n#   :email => [\"must be filled\"],\n#   :age => [\"must be greater than 18\"]\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Error Messages in dry-schema\nDESCRIPTION: Demonstrates how to access and format validation error messages from the result object, including getting default errors, full errors, and localized errors.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/working-with-schemas.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nresult = schema.call(email: nil, age: 21)\n\n# get default errors\nresult.errors.to_h\n# => {:email=>['must be filled']}\n\n# get full errors\nresult.errors(full: true).to_h\n# => {:email=>['email must be filled']}\n\n# get errors in another language\nresult.errors(locale: :pl).to_h\n# => {:email=>['musi być wypełniony']}\n```\n\n----------------------------------------\n\nTITLE: Defining and Reusing Schemas in Ruby using dry-schema\nDESCRIPTION: This code snippet demonstrates how to define an AddressSchema and a UserSchema using Dry::Schema.Params, and how to incorporate the AddressSchema into the UserSchema using nested-schema syntax. It also includes an example of schema validation with error handling.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/reusing-schemas.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nAddressSchema = Dry::Schema.Params do\n  required(:street).filled(:string)\n  required(:city).filled(:string)\n  required(:zipcode).filled(:string)\nend\n\nUserSchema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:name).filled(:string)\n  required(:address).hash(AddressSchema)\nend\n\nUserSchema.(\n  email: 'jane@doe',\n  name: 'Jane',\n  address: { street: nil, city: 'NYC', zipcode: '123' }\n).errors.to_h\n\n# {:address=>{:street=>[\"must be filled\"]}}\n```\n\n----------------------------------------\n\nTITLE: Checking Presence of Errors in dry-schema\nDESCRIPTION: Shows how to check for the presence of errors at specific paths in the validation result, including errors in array elements.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/working-with-schemas.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:name).filled(:string)\n  optional(:tags).array(:str?)\nend\n\nresult = schema.call(name: \"\", tags: [\"red\", 123])\n\nresult.error?(:name)\n# => true\n\nresult.error?(:tags)\n# => true\n\nresult.error?([:tags, 0])\n# => false\n\nresult.error?([:tags, 1])\n# => true\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Hash with Dry::Schema\nDESCRIPTION: This example demonstrates how to validate a nested hash structure with multiple levels of nesting. It validates an address object with city, street, and country fields, where country itself is a nested hash with name and code fields.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:address).hash do\n    required(:city).filled(:string, min_size?: 3)\n    required(:street).filled(:string)\n    required(:country).hash do\n      required(:name).filled(:string)\n      required(:code).filled(:string)\n    end\n  end\nend\n\nerrors = schema.call({}).errors\n\nputs errors.to_h.inspect\n# { :address => [\"is missing\"] }\n\nerrors = schema.call(address: { city: 'NYC' }).errors\n\nputs errors.to_h.inspect\n# {\n#   :address => [\n#     { :street => [\"is missing\"] },\n#     { :country => [\"is missing\"] }\n#   ]\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Values with 'maybe' in Dry::Schema (Ruby)\nDESCRIPTION: This example illustrates the use of the 'maybe' macro in Dry::Schema to allow nullable values. The age field is optional and can be either nil or an integer greater than 18. It shows error handling for various input scenarios.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/optional-keys-and-values.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  optional(:age).maybe(:integer, gt?: 18)\nend\n\nerrors = schema.call(email: 'jane@doe.org', age: nil).errors\n\nputs errors.to_h.inspect\n# {}\n\nerrors = schema.call(email: 'jane@doe.org', age: 19).errors\n\nputs errors.to_h.inspect\n# {}\n\nerrors = schema.call(email: 'jane@doe.org', age: 17).errors\n\nputs errors.to_h.inspect\n# { :age => [\"must be greater than 18\"] }\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Type Validation in dry-schema Params\nDESCRIPTION: Example showing how to define a schema with basic type validation using integer type spec with an additional validation rule.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/type-specs.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nUserSchema = Dry::Schema.Params do\n  # expands to: `int? & gt?(18)`\n  required(:age).value(:integer, gt?: 18)\nend\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Nested Hash Validation\nDESCRIPTION: Shows an alternative syntax for validating nested hashes using the 'value' macro with ':hash' predicate and a block. This is equivalent to the previous example but uses a different DSL approach.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:address).value(:hash) do\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Keys in Dry::Schema (Ruby)\nDESCRIPTION: This snippet shows how to define a schema with an optional key 'age' using Dry::Schema. The age, if present, must be an integer greater than 18. It demonstrates error handling for both valid and invalid inputs.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/optional-keys-and-values.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  optional(:age).filled(:integer, gt?: 18)\nend\n\nerrors = schema.call(email: 'jane@doe.org').errors\n\nputs errors.to_h.inspect\n# {}\n\nerrors = schema.call(email: 'jane@doe.org', age: 17).errors\n\nputs errors.to_h.inspect\n# { :age => [\"must be greater than 18\"] }\n```\n\n----------------------------------------\n\nTITLE: Composing Schemas with AND Operator in Ruby using dry-schema\nDESCRIPTION: This snippet demonstrates how to use the '&' operator to compose schemas where both schemas must pass. It creates Role and Expirable schemas, then combines them in a User schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/composing-schemas.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nRole = Dry::Schema.JSON do\n  required(:id).filled(:string)\nend\n\nExpirable = Dry::Schema.JSON do\n  required(:expires_on).value(:date)\nend\n\nUser = Dry::Schema.JSON do\n  required(:name).filled(:string)\n  required(:role).hash(Role & Expirable)\nend\n\nputs User.(name: \"Jane\", role: { id: \"admin\", expires_on: \"2020-05-01\" }).errors.to_h.inspect\n# {}\n\nputs User.(name: \"Jane\", role: { id: \"\", expires_on: \"2020-05-01\" }).errors.to_h.inspect\n# {role: {id: [\"must be filled\"]}}\n\nputs User.(name: \"Jane\", role: { id: \"admin\", expires_on: \"oops\" }).errors.to_h.inspect\n# {role: {expires_on: [\"must be a date\"]}}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Types with TypeContainer in dry-schema Ruby Gem\nDESCRIPTION: This snippet shows how to create a custom TypeContainer, register a custom type, and use it in a schema definition. This approach allows using symbol-based custom types in dry-schema version 1.2 and later.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/custom-types.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nStrippedString = Types::String.constructor(&:strip)\n\nTypeContainer = Dry::Schema::TypeContainer.new\nTypeContainer.register('params.stripped_string', StrippedString)\n\nSchema = Dry::Schema.Params do\n  config.types = TypeContainer\n  required(:some_number).filled(:integer)\n  required(:my_string).filled(:stripped_string)\nend\n```\n\n----------------------------------------\n\nTITLE: Composing Schemas with OR Operator in Ruby using dry-schema\nDESCRIPTION: This snippet shows how to use the '|' operator to compose schemas where either schema must pass. It creates RoleID and RoleTitle schemas, then combines them in a User schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/composing-schemas.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nRoleID = Dry::Schema.JSON do\n  required(:id).filled(:string)\nend\n\nRoleTitle = Dry::Schema.JSON do\n  required(:title).filled(:string)\nend\n\nUser = Dry::Schema.JSON do\n  required(:name).filled(:string)\n  required(:role).hash(RoleID | RoleTitle)\nend\n\nputs User.(name: \"Jane\", role: {id: \"admin\"}).errors.to_h.inspect\n# {}\n\nputs User.(name: \"Jane\", role: {title: \"Admin\"}).errors.to_h.inspect\n\nputs User.(name: \"Jane\", role: { id: \"\"}).errors.to_h.inspect\n# {:role=>{:or=>[{:id=>[\"must be filled\"]}, {:title=>[\"is missing\"]}]}}\n\nputs User.(name: \"Jane\", role: { title: \"\"}).errors.to_h.inspect\n# {:role=>{:or=>[{:id=>[\"is missing\"]}, {:title=>[\"must be filled\"]}]}}\n```\n\n----------------------------------------\n\nTITLE: Validating Array of Hashes\nDESCRIPTION: Demonstrates validating an array of hashes using 'array(:hash)' with a block. This example validates an array of people where each person must have a name (string) and age (integer >= 18).\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:people).array(:hash) do\n    required(:name).filled(:string)\n    required(:age).filled(:integer, gteq?: 18)\n  end\nend\n\nerrors = schema.call(people: [{ name: 'Alice', age: 19 }, { name: 'Bob', age: 17 }]).errors\n\nputs errors.to_h.inspect\n# => {\n#   :people=>{\n#     1=>{\n#       :age=>[\"must be greater than or equal to 18\"]\n#     }\n#   }\n# }\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Predicates Module in Ruby for dry-schema\nDESCRIPTION: Creates a custom predicates module that includes the default Dry::Logic::Predicates and adds a custom future_date? predicate that checks if a date is in the future.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/custom-predicates.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule MyPredicates\n  include Dry::Logic::Predicates\n\n  def self.future_date?(date)\n    date > Date.today\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using the info extension to introspect schema keys and types in Ruby\nDESCRIPTION: This example demonstrates how to enable and use the :info extension in dry-schema. The code loads the extension, defines a JSON schema with various field types, and then calls the #info method to retrieve a structured representation of the schema's keys and types.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/info.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\n\nDry::Schema.load_extensions(:info)\n\nUserSchema = Dry::Schema.JSON do\n  required(:email).filled(:string)\n  optional(:age).filled(:integer)\n  optional(:address).hash do\n    required(:street).filled(:string)\n    required(:zipcode).filled(:string)\n    required(:city).filled(:string)\n  end\nend\n\nUserSchema.info\n# {\n#   :keys=> {\n#     :email=>{\n#       :required=>true,\n#       :type=>\"string\"\n#     },\n#     :age=>{\n#       :required=>false,\n#       :type=>\"integer\"\n#      },\n#     :address=>{\n#       :type=>\"hash\",\n#       :required=>false,\n#       :keys=>{\n#         :street=>{\n#           :required=>true,\n#           :type=>\"string\"\n#         },\n#         :zipcode=>{\n#           :required=>true,\n#           :type=>\"string\"\n#         },\n#         :city=>{\n#           :required=>true,\n#           :type=>\"string\"\n#         }\n#       }\n#     }\n#   }\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Maybe Macro in Dry Schema\nDESCRIPTION: Demonstrates the maybe macro for handling optional values that can be nil. Includes examples with arrays and strings.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to `required(:age) { !nil?.then(int?) }`\n  required(:age).maybe(:integer)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:list).maybe(array[:string])\n\n  # or\n\n  required(:list).maybe(:array) do\n    nil? | each(:string)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Composing Schemas with IMPLIES Operator in Ruby using dry-schema\nDESCRIPTION: This snippet demonstrates how to use the '>' operator to compose schemas where the right schema is only applied if the left schema passes. It creates RoleID and RoleTitle schemas, then combines them in a User schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/composing-schemas.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nRoleID = Dry::Schema.JSON do\n  required(:id).filled(:string)\nend\n\nRoleTitle = Dry::Schema.JSON do\n  required(:title).filled(:string)\nend\n\nUser = Dry::Schema.JSON do\n  required(:name).filled(:string)\n  required(:role).hash(RoleID > RoleTitle)\nend\n\nputs User.(name: \"Jane\", role: {id: \"admin\", title: \"Admin\"}).errors.to_h.inspect\n# {}\n\nputs User.(name: \"Jane\", role: { id: \"\"}).errors.to_h.inspect\n# {}\n\nputs User.(name: \"Jane\", role: {title: \"Admin\"}).errors.to_h.inspect\n# {}\n\nputs User.(name: \"Jane\", role: { id: \"admin\", title: \"\"}).errors.to_h.inspect\n# {:role=>{:title=>[\"must be filled\"]}}\n```\n\n----------------------------------------\n\nTITLE: Using Array Macro in Dry Schema\nDESCRIPTION: Shows how to validate arrays and their elements using the array macro, including arrays of strings and hashes.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to: `required(:tags) { array? & each { str? } } }`\n  required(:tags).array(:str?)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to: `required(:tags) { array? & each { hash { required(:name).filled(:string) } } } }`\n  required(:tags).array(:hash) do\n    required(:name).filled(:string)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Filled Macro in Dry Schema\nDESCRIPTION: Shows how to use the filled macro to validate non-nil and non-empty values for different types like integers and arrays.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to `required(:age) { int? & filled? }`\n  required(:age).filled(:integer)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to `required(:tags) { array? & filled? }`\n  required(:tags).filled(:array)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Conjunction (AND) Logic in dry-schema\nDESCRIPTION: Demonstrates how to combine multiple predicates using AND logic. The rule validates that age must be both an integer and greater than 18.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/predicate-logic.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:age) { int? & gt?(18) }\nend\n```\n\n----------------------------------------\n\nTITLE: Using Hash Macro in Dry Schema\nDESCRIPTION: Shows how to validate nested hash structures using the hash macro with required fields.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to: `required(:tags) { hash? & filled? & schema { required(:name).filled(:string) } } }`\n  required(:tags).hash do\n    required(:name).filled(:string)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Disjunction (OR) Logic in dry-schema\nDESCRIPTION: Shows how to use OR logic to validate that age can be either nil or an integer. The rule passes if either condition is true.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/predicate-logic.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:age) { nil? | int? }\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Key Maps in Dry Schema\nDESCRIPTION: This snippet demonstrates how to define a schema, access its key map, and use the key map to filter out unexpected keys from an input hash while coercing string keys to symbols.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/key-maps.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  optional(:age).filled(:integer, gt?: 18)\nend\n\nschema.key_map\n# => #<Dry::Schema::KeyMap[\"email\", \"age\"]>\n\nschema.key_map.write(\"email\" => \"jane@doe.org\", \"age\" => 21, \"something_unexpected\" => \"oops\")\n# => {:email=>\"jane@doe.org\", :age=>21}\n```\n\n----------------------------------------\n\nTITLE: Implementing Implication (THEN) Logic in dry-schema\nDESCRIPTION: Demonstrates implication logic where the second predicate is only checked if the first one is true. The rule validates that if age is filled, it must be an integer.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/predicate-logic.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:age) { filled? > int? }\nend\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Custom Types in dry-schema Ruby Gem\nDESCRIPTION: This snippet shows how to create a custom StrippedString type and use it in a schema definition. It demonstrates the traditional approach of using constants for custom types.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/custom-types.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nStrippedString = Types::String.constructor(&:strip)\n\nSchema = Dry::Schema.Params do\n  required(:some_number).filled(:integer)\n  required(:my_string).filled(StrippedString)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Exclusive Disjunction (XOR) Logic in dry-schema\nDESCRIPTION: Shows how to use XOR logic to ensure exactly one of two conditions is true. The rule validates that status must be either even OR less than 0, but not both.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/predicate-logic.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:status).value(:integer) { even? ^ lt?(0) }\nend\n```\n\n----------------------------------------\n\nTITLE: Using Symbol-based Custom Types in dry-schema Ruby Gem\nDESCRIPTION: This snippet demonstrates the desired syntax for using custom types with symbols in a schema definition. This approach is more convenient for using custom types throughout a project.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/custom-types.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nSchema = Dry::Schema.Params do\n  required(:some_number).filled(:integer)\n  required(:my_string).filled(:stripped_string)\nend\n```\n\n----------------------------------------\n\nTITLE: Converting Dry::Schema to JSON Schema in Ruby\nDESCRIPTION: This snippet demonstrates loading the json_schema extension, defining a schema with various validations, and converting it to a JSON Schema format. The example shows required and optional fields with string, integer, and enumeration validations.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/json_schema.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.load_extensions(:json_schema)\n\nUserSchema = Dry::Schema.JSON do\n  required(:email).filled(:str?, min_size?: 8)\n  optional(:favorite_color).filled(:str?, included_in?: %w[red green blue pink])\n  optional(:age).filled(:int?)\nend\n\nUserSchema.json_schema \n# {\n#   \"type\": \"object\",\n#   \"properties\": {\n#     \"email\": {\n#       \"type\": \"string\",\n#       \"minLength\": 8\n#     },\n#     \"favorite_color\": {\n#       \"type\": \"string\",\n# .     \"enum\": [\"red\", \"green\", \"blue\", \"pink\"]\n#     },\n#     \"age\": {\n#       \"type\": \"integer\"\n#     },\n#   },\n#   \"required\": [\"email\"] \n# }\n```\n\n----------------------------------------\n\nTITLE: Validating Arrays with Member Types in dry-schema\nDESCRIPTION: Demonstrates how to validate an array with specific member types using the array shortcut method and additional size validation.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/type-specs.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nUserSchema = Dry::Schema.Params do\n  # expands to: `array? & each { int? } & size?(3)`\n  required(:nums).value(array[:integer], size?: 3)\nend\n```\n\n----------------------------------------\n\nTITLE: I18n Integration with dry-schema\nDESCRIPTION: Shows how to configure dry-schema to use I18n for localized error messages and switch between different locales.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'i18n'\nrequire 'dry-schema'\n\nschema = Dry::Schema.Params do\n  config.messages.backend = :i18n\n\n  required(:email).filled(:string)\nend\n\n# return default translations\nschema.call(email: '').errors.to_h\n{ :email => [\"must be filled\"] }\n\n# return other translations (assuming you have it :))\nputs schema.call(email: '').errors(locale: :pl).to_h\n{ :email => [\"musi być wypełniony\"] }\n```\n\n----------------------------------------\n\nTITLE: Validating Optional Nested Hash with 'maybe' Macro\nDESCRIPTION: Demonstrates how to validate a nested hash that could be nil. This example uses the 'maybe' macro with ':hash' predicate and a block to define validation rules for an address field that may be null.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:address).maybe(:hash) do\n    required(:city).filled(:string, min_size?: 3)\n    required(:street).filled(:string)\n    required(:country).hash do\n      required(:name).filled(:string)\n      required(:code).filled(:string)\n    end\n  end\nend\n\nschema.(address: nil).success? # true\n```\n\n----------------------------------------\n\nTITLE: Message Lookup in dry-schema\nDESCRIPTION: Demonstrates how the message lookup system works in dry-schema, including matching by predicate, rule, argument type, and value type.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nmessages = Dry::Schema::Messages::YAML.load(%w(/path/to/our/errors.yml))\n\n# matching arg type for size? predicate\nmessages[:size?, rule: :name, arg_type: Fixnum] # => \"size must be %{num}\"\nmessages[:size?, rule: :name, arg_type: Range] # => \"size must be within %{left} - %{right}\"\n\n# matching val type for size? predicate\nmessages[:size?, rule: :name, val_type: String] # => \"length must be %{num}\"\n\n# matching predicate\nmessages[:filled?, rule: :age] # => \"must be filled\"\nmessages[:filled?, rule: :address] # => \"must be filled\"\n\n# matching predicate for a specific rule\nmessages[:filled?, rule: :email] # => \"the email is missing\"\n\n# with namespaced messages\nuser_messages = messages.namespaced(:user)\n\nuser_messages[:filled?, rule: :age] # \"cannot be blank\"\nuser_messages[:filled?, rule: :address] # \"You gotta tell us where you live\"\n```\n\n----------------------------------------\n\nTITLE: Validating Array of Primitive Values\nDESCRIPTION: Shows how to validate an array of primitive values using the 'array' macro with a predicate. This example validates that phone_numbers is an array where each element is a string.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:phone_numbers).array(:str?)\nend\n\nerrors = schema.call(phone_numbers: '').messages\n\nputs errors.to_h.inspect\n# { :phone_numbers => [\"must be an array\"] }\n\nerrors = schema.call(phone_numbers: ['123456789', 123456789]).messages\n\nputs errors.to_h.inspect\n# {\n#   :phone_numbers => {\n#     1 => [\"must be a string\"]\n#   }\n# }\n```\n\n----------------------------------------\n\nTITLE: YAML Structure for Error Messages in dry-schema\nDESCRIPTION: Example YAML file structure showing how to organize error messages with predicate matching, argument types, and rule-specific overrides.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nen:\n  dry_schema:\n    errors:\n      size?:\n        arg:\n          default: \"size must be %{num}\"\n          range: \"size must be within %{left} - %{right}\"\n\n        value:\n          string:\n            arg:\n              default: \"length must be %{num}\"\n              range: \"length must be within %{left} - %{right}\"\n\n      filled?: \"must be filled\"\n\n      included_in?: \"must be one of %{list}\"\n      excluded_from?: \"must not be one of: %{list}\"\n\n      rules:\n        email:\n          filled?: \"the email is missing\"\n\n        user:\n          filled?: \"name cannot be blank\"\n\n          rules:\n            address:\n              filled?: \"You gotta tell us where you live\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Types with dry-schema\nDESCRIPTION: Shows how to create and use custom types by extending Dry::Types with a custom string type that strips whitespace.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/type-specs.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Types\n  include Dry::Types()\n\n  StrippedString = Types::String.constructor(&:strip)\nend\n\nUserSchema = Dry::Schema.Params do\n  # expands to: `str? & min_size?(10)`\n  required(:login_time).value(StrippedString, min_size?: 10)\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling and Accessing Hints in Dry::Schema (Ruby)\nDESCRIPTION: This snippet demonstrates how to enable hints, define a schema with rules, and access hints and errors from the validation result. It shows how hints provide information about unevaluated predicates due to earlier failures.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/hints.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# enable :hints\n\nDry::Schema.load_extensions(:hints)\n\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:age).filled(:integer, gt?: 18)\nend\n\nresult = schema.call(email: 'jane@doe.org', age: '')\nresult.hints.to_h\n\n# {:age=>['must be greater than 18']}\n\nresult = schema.call(email: 'jane@doe.org', age: '')\n\nresult.errors.to_h\n# {:age=>['must be filled']}\n\nresult.hints.to_h\n# {:age=>['must be greater than 18']}\n# hints takes the same options as errors:\n\nresult.hints(full: true)\n# {:age=>['age must be greater than 18']}\n```\n\n----------------------------------------\n\nTITLE: Validating Array with Size Constraints\nDESCRIPTION: Shows how to apply array predicates like min_size? using the value and each macros. This example requires the people array to have at least one element and validates each element against a hash schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:people).value(:array, min_size?: 1).each do\n    hash do\n      required(:name).filled(:string)\n      required(:age).filled(:integer, gteq?: 18)\n    end\n  end\nend\n\nerrors = schema.call(people: []).errors\n\nputs errors.to_h.inspect\n# => {\n#   :people=>[\"size cannot be less than 1\"]\n# }\n```\n\n----------------------------------------\n\nTITLE: Integrating Dry-Schema Monads with Ruby Pattern Matching\nDESCRIPTION: Shows how to combine dry-schema's monads extension with Ruby 2.7's pattern matching feature. The example creates a class that validates input using a schema and uses pattern matching on the monad result to provide different responses based on validation outcome.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\nrequire 'dry/monads'\n\nDry::Schema.load_extensions(:monads)\n\nclass Example\n  include Dry::Monads[:result]\n\n  Schema = Dry::Schema.Params { required(:name).filled(:string, size?: 2..4) }\n\n  def call(input)\n    case schema.(input).to_monad\n    in Success(name:)\n      \"Hello #{name}\" # name is captured from result\n    in Failure(name:)\n      \"#{name} is not a valid name\"\n    end\n  end\nend\n\nrun = Example.new\n\nrun.('name' => 'Jane')   # => \"Hello Jane\"\nrun.('name' => 'Albert') # => \"Albert is not a valid name\"\n```\n\n----------------------------------------\n\nTITLE: Adding Callbacks to Dry::Schema Processor Steps in Ruby\nDESCRIPTION: This example shows how to add a 'before' callback to the value_coercer step to remove all keys with nil values before coercion is applied. The callback uses the compact method to filter out nil values from the result hash.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/processor-steps.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:name).value(:string)\n  optional(:age).value(:integer)\n\n  before(:value_coercer) do |result|\n    result.to_h.compact\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Empty Strings with Nullable Fields in Params Schema in Ruby\nDESCRIPTION: This example shows how the Params schema automatically coerces empty strings to nil for fields configured with maybe types. It demonstrates this behavior with string, integer, and array types when those fields can accept nil values.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/params.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  required(:age).maybe(:integer)\n  required(:tags).maybe(:array)\nend\n\nresult = schema.call('email' => 'jane@doe.org', 'age' => '', 'tags' => '')\n\nputs result.to_h\n# {:email=>'jane@doe.org', :age=>nil, :tags=>nil}\n```\n\n----------------------------------------\n\nTITLE: Using a Customized Dry::Schema in Ruby\nDESCRIPTION: This snippet demonstrates applying a schema with a custom processor that removes nil values. When the schema is called with input containing a nil value for age, the callback removes that key before further processing.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/processor-steps.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema.(name: \"Jane\", age: nil)\n# => #<Dry::Schema::Result{:name=>\"jane\"} errors={}>\n```\n\n----------------------------------------\n\nTITLE: Coercing Empty Strings to Empty Arrays in Params Schema in Ruby\nDESCRIPTION: This snippet demonstrates how empty strings are automatically coerced to empty arrays when the field is defined with an array type. This behavior is specific to array values in params schemas.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/params.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:tags).value(:array)\nend\n\nresult = schema.call('tags' => '')\n\nputs result.to_h\n# {:email=>'jane@doe.org', :age=>nil, :tags=>[]}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unexpected Key Validation in dry-schema Ruby\nDESCRIPTION: Demonstrates a complete example of unexpected key validation using a user schema with nested structures including address and roles. Shows how validation errors are returned for unexpected keys at different levels.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/unexpected-keys.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\n\nUserSchema = Dry::Schema.Params do\n  config.validate_keys = true\n\n  required(:name).filled(:string)\n\n  required(:address).hash do\n    required(:city).filled(:string)\n    required(:zipcode).filled(:string)\n  end\n\n  required(:roles).array(:hash) do\n    required(:name).filled(:string)\n  end\nend\n\ninput = {\n  foo: 'unexpected',\n  name: 'Jane',\n  address: { bar: 'unexpected', city: 'NYC', zipcode: '1234' },\n  roles: [{ name: 'admin' }, { name: 'editor', foo: 'unexpected' }]\n}\n\nUserSchema.(input).errors.to_h\n# {\n#  :foo=>[\"is not allowed\"],\n#  :address=>{:bar=>[\"is not allowed\"]},\n#  :roles=>{1=>{:foo=>[\"is not allowed\"]}}\n# }\n```\n\n----------------------------------------\n\nTITLE: Validating Optional Array with Nested Schema\nDESCRIPTION: Demonstrates validating an array that could be nil using array with a nested schema. This example validates that tags can be nil or an array of objects with name fields.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nnested_schema = Dry::Schema.Params do\n  required(:name).filled(:string)\nend\n\nschema = Dry::Schema.Params do\n  required(:tags).maybe(array[nested_schema])\nend\n\nschema.call(tags: nil).success? # true\nschema.call(tags: [{ name: 'Alice' }, { name: 'Bob' }]).success? # true\n```\n\n----------------------------------------\n\nTITLE: Using the Monad API with Schema Validation Results\nDESCRIPTION: Demonstrates how to use the monad API with schema validation results after loading the extension. The example shows successful and failed validations converted to Success and Failure monads, along with using fmap/or for handling both cases.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params { required(:name).filled(:string, size?: 2..4) }\n\nschema.call(name: 'Jane').to_monad # => Dry::Monads::Success(#<Dry::Schema::Result{:name=>\"Jane\"} errors={}>)\n\nschema.call(name: '').to_monad     # => Dry::Monads::Failure(#<Dry::Schema::Result{:name=>\"\"} errors={:name=>[\"must be filled\"]}>)\n\nschema.(name: \"\")\n  .to_monad\n  .fmap { |r| puts \"passed: #{r.to_h.inspect}\" }\n  .or   { |r| puts \"failed: #{r.errors.to_h.inspect}\" }\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Optional Array Validation\nDESCRIPTION: Shows another approach to validating an optional array using maybe(:array) with a block and nil? operator. This example validates that tags can be nil or an array of hash objects with name fields.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/nested-data.html.md#2025-04-12_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:tags).maybe(:array) do\n    nil? | each(:hash) do\n      required(:name).filled(:string)\n    end\n  end\nend\n\nschema.call(tags: nil).success? # true\nschema.call(tags: [{ name: 'Alice' }, { name: 'Bob' }]).success? # true\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Predicates in dry-schema\nDESCRIPTION: Demonstrates how to configure a custom predicates module as the default for a schema and use a custom predicate in a validation rule.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/custom-predicates.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nSchema = Dry::Schema.Params do\n  config.predicates = MyPredicates\n\n  required(:release_date).value(:date, :future_date?)\nend\n```\n\n----------------------------------------\n\nTITLE: Applying Filtering Rules in Ruby using dry-schema\nDESCRIPTION: This code snippet demonstrates how to use the 'filter' macro in dry-schema to validate a date format before coercion. It defines a schema that requires an email and a birthday, where the birthday must match a specific format before being coerced into a date object.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/filtering.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled\n  required(:birthday).filter(format?: /\\d{4}-\\d{2}-\\d{2}/).value(:date)\nend\n\nschema.call('email' => 'jane@doe.org', 'birthday' => '1981-1-1')\n#<Dry::Schema::Result{:email=>\"jane@doe.org\", :birthday=>\"1981-1-1\"} errors={:birthday=>[\"is in invalid format\"]}>\n\nschema.call('email' => 'jane@doe.org', 'birthday' => '1981-01-01')\n#<Dry::Schema::Result{:email=>\"jane@doe.org\", :birthday=>#<Date: 1981-01-01 ((2444606j,0s,0n),+0s,2299161j)>} errors={}>\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Type Container for Schema in Ruby\nDESCRIPTION: Shows how to set up and use a custom type container with a specialized string type that strips and downcases input values.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\ntypes = Dry::Schema::TypeContainer.new\ntypes.register(\n  'params.trimmed_string',\n  Types::String.constructor(&:strip).constructor(&:downcase)\n)\n\nDry::Schema.Params do\n  config.types = types\n\n  require(:name).value(:trimmed_string)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Base Schema Class in dry-schema\nDESCRIPTION: Shows how to create a base schema class with common configuration that can be extended by other schemas. This example configures custom message paths and sets the i18n backend.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/working-with-schemas.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass AppSchema < Dry::Schema::Params\n  define do\n    config.messages.load_paths << '/my/app/config/locales/en.yml'\n    config.messages.backend = :i18n\n\n    # define common rules, if any\n  end\nend\n\n# now you can build other schemas on top of the base one:\nclass MySchema < AppSchema\n  # define your rules\nend\n\nmy_schema = MySchema.new\n```\n\n----------------------------------------\n\nTITLE: Using Automatic Predicate Inferring with Constrained Types in Ruby\nDESCRIPTION: Demonstrates how dry-schema automatically infers validation predicates from constrained types, showing validation with a custom string type that requires minimum length.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nTypes::Name = Types::String.constrained(min_size: 1)\n\nschema = Dry::Schema.define do\n  required(:name).value(Types::Name)\nend\n\nschema.(name: '').errors.to_h # => { name: [\"size cannot be less than 1\"] }\n```\n\n----------------------------------------\n\nTITLE: Using Enumerable API with Key Maps in Dry Schema\nDESCRIPTION: This snippet shows how to use the Enumerable API methods with key maps, including iterating over keys with 'each' and finding specific keys with 'detect'.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/key-maps.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema.key_map.each { |key| puts key.inspect }\n# #<Dry::Schema::Key name=\"email\" coercer=#<Proc:0x00007feb288ff848(&:to_sym)>>\n# #<Dry::Schema::Key name=\"age\" coercer=#<Proc:0x00007feb288ff848(&:to_sym)>>\n\nschema.key_map.detect { |key| key.name.eql?(\"email\") }\n# => #<Dry::Schema::Key name=\"email\" coercer=#<Proc:0x00007feb288ff848(&:to_sym)>>\n```\n\n----------------------------------------\n\nTITLE: Defining a User Hash Schema with Types in Ruby\nDESCRIPTION: Creates a schema for validating user data with string type constraints for name and email fields, demonstrating how to use hash types with proper key and predicate inference.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nUserType = Dry::Types['hash'].schema(\n  name: 'string',\n  email: 'string'\n)\n\nDry::Schema.define do\n  require(:user).hash(UserType)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Schema with Value Macro in Ruby\nDESCRIPTION: Shows how to create a schema with nested validation using the value macro shortcut, requiring an address hash with a city field.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:address).value(:hash) do\n    required(:city).filled\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Loading Custom Error Messages in dry-schema\nDESCRIPTION: Demonstrates how to configure a schema to load custom error messages from an external YAML file.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  config.messages.load_paths << '/path/to/my/errors.yml'\nend\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Multiple Parent Schemas in Ruby\nDESCRIPTION: Shows how to create a schema that inherits from multiple parent schemas, with inheritance proceeding from left to right.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.define(parent: [parent_a, parent_b, parent_c]) do\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Setting a Message Namespace in dry-schema\nDESCRIPTION: Shows how to configure a schema with a specific namespace for error messages, allowing for more targeted messages per schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  config.messages.namespace = :user\nend\n```\n\n----------------------------------------\n\nTITLE: Equality comparison in dry-schema\nDESCRIPTION: Shows how to check if a value equals a specific number using both regular Ruby and dry-schema syntax.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/built-in-predicates.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe 'eql?' do\n  let(:schema) do\n    Dry::Schema.Params do\n      required(:sample).value(eql?: 1234)\n    end\n  end\n\n  let(:input) { {sample: 1234} }\n\n  it 'as regular ruby' do\n    assert input[:sample] == 1234\n  end\n\n  it 'with dry-schema' do\n     assert schema.call(input).success?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Changing the Top Namespace for Messages in dry-schema\nDESCRIPTION: Illustrates how to modify the default top-level namespace used for error messages in a schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  config.messages.top_namespace = :validation_schema\nend\n```\n\n----------------------------------------\n\nTITLE: Checking for nil values using dry-schema\nDESCRIPTION: Demonstrates how to validate if a value is nil using both regular Ruby and dry-schema approaches.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/built-in-predicates.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe 'nil?' do\n  let(:schema) do\n    Dry::Schema.Params do\n      required(:sample).value(:nil?)\n    end\n  end\n\n  let(:input) { {sample: nil} }\n\n  it 'as regular ruby' do\n    assert input[:sample].nil?\n  end\n\n  it 'with dry-schema' do\n    assert schema.call(input).success?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Displaying Full Error Messages in dry-schema\nDESCRIPTION: Demonstrates how to include the rule name in error messages by using the full option when retrieving errors.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/error-messages.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nschema.call(email: '').errors(full: true).to_h\n{ :email => [\"email must be filled\"] }\n```\n\n----------------------------------------\n\nTITLE: Using Schema Macro in Dry Schema\nDESCRIPTION: Demonstrates the schema macro for nested hash validation without automatic hash type checking.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to: `required(:tags) { hash? & filled? & schema { required(:name).filled(:string) } } }`\n  required(:tags).filled(:hash).schema do\n    required(:name).filled(:string)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Each Macro in Dry Schema\nDESCRIPTION: Demonstrates the each macro for array element validation without automatic array type checking.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/macros.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  # expands to: `required(:tags) { array? & each { str? } } }`\n  required(:tags).value(:array, min_size?: 2).each(:str?)\nend\n```\n\n----------------------------------------\n\nTITLE: Type checking with dry-schema\nDESCRIPTION: Demonstrates type validation using the type? predicate to ensure a value is of a specific Ruby class.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/basics/built-in-predicates.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ndescribe 'type?' do\n  let(:schema) do\n    Dry::Schema.Params do\n      required(:sample).value(type?: Integer)\n    end\n  end\n\n  let(:input) { {sample: 1234} }\n\n  it 'as regular ruby' do\n    assert input[:sample].class == Integer\n  end\n\n  it 'with dry-schema' do\n    assert schema.call(input).success?\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Rule AST in dry-schema\nDESCRIPTION: Demonstrates how to create a schema using Dry::Schema.Params and access its rule AST using the to_ast method. The AST represents predicates and their composition into complex rules.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/rule-ast.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema.Params do\n  required(:email).filled(:string)\n  optional(:age).filled(:integer, gt?: 18)\nend\n\nschema.to_ast\n# => [:set,\n#  [[:and,\n#    [[:predicate, [:key?, [[:name, :email], [:input, Undefined]]]],\n#     [:key, [:email, [:and, [[:predicate, [:str?, [[:input, Undefined]]]], [:predicate, [:filled?, [[:input, Undefined]]]]]]]]]],\n#   [:implication,\n#    [[:predicate, [:key?, [[:name, :age], [:input, Undefined]]]],\n#     [:key,\n#      [:age,\n#       [:and,\n#        [[:and, [[:predicate, [:int?, [[:input, Undefined]]]], [:predicate, [:filled?, [[:input, Undefined]]]]]],\n#         [:predicate, [:gt?, [[:num, 18], [:input, Undefined]]]]]]]]]]]]\n```\n\n----------------------------------------\n\nTITLE: Implementing AST Compiler for Documentation in Ruby\nDESCRIPTION: Provides an example of writing an AST compiler that converts the schema's rule AST into metadata for documentation purposes. The compiler visits different node types and generates human-readable descriptions of validations.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/rule-ast.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\n\nclass DocCompiler\n  def visit(node)\n    meth, rest = node\n    public_send(:\\\"visit_#{meth}\\\", rest)\n  end\n\n  def visit_set(nodes)\n    nodes.map { |node| visit(node) }.flatten(1)\n  end\n\n  def visit_and(node)\n    left, right = node\n    [visit(left), visit(right)].compact\n  end\n\n  def visit_key(node)\n    name, rest = node\n\n    predicates = visit(rest).flatten(1).reduce(:merge)\n    validations = predicates.map { |name, args| predicate_description(name, args) }.compact\n\n    { key: name, validations: validations }\n  end\n  \n  def visit_implication(node)\n    _, right = node.map(&method(:visit))\n    right.merge(optional: true)\n  end\n\n  def visit_predicate(node)\n    name, args = node\n\n    return if name.equal?(:key?)\n\n    { name => args.map(&:last).reject { |v| v.equal?(Dry::Schema::Undefined) } }\n  end\n\n  def predicate_description(name, args)\n    case name\n    when :str? then \\\"must be a string\\\"\n    when :filled? then \\\"must be filled\\\"\n    when :int? then \\\"must be an integer\\\"\n    when :gt? then \\\"must be greater than #{args[0]}\\\"\n    else\n      raise NotImplementedError, \\\"#{name} not supported yet\\\"\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using AST Compiler for Documentation Generation in Ruby\nDESCRIPTION: Demonstrates how to use the DocCompiler to convert a schema's rule AST into a list of hashes describing keys and their validations, which can be used for documentation purposes.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/rule-ast.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncompiler = DocCompiler.new\n\ncompiler.visit(schema.to_ast)\n# [\n#   {:key=>:email, :validations=>[\\\"must be filled\\\", \\\"must be a string\\\"]},\n#   {:key=>:age, :validations=>[\\\"must be filled\\\", \\\"must be an integer\\\", \\\"must be greater than 18\\\"], :optional=>true}\n# ]\n```\n\n----------------------------------------\n\nTITLE: Combining Errors and Hints in Dry::Schema (Ruby)\nDESCRIPTION: This snippet shows how to use the 'messages' method to get a combination of both errors and hints from a Dry::Schema validation result.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/hints.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nresult = schema.call(email: 'jane@doe.org', age: '')\nresult.messages.to_h\n# {:age=>[\"must be filled\", \"must be greater than 18\"]}\n```\n\n----------------------------------------\n\nTITLE: Disabling Predicate Inference by Class Name in Ruby\nDESCRIPTION: Code example showing how to disable the deprecated feature of inferring predicates from class names in dry-schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema::PredicateInferrer::Compiler.infer_predicate_by_class_name false\n```\n\n----------------------------------------\n\nTITLE: Enabling Predicate Inference by Class Name in Ruby\nDESCRIPTION: Code example showing how to explicitly enable the deprecated feature of inferring predicates from class names in dry-schema.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema::PredicateInferrer::Compiler.infer_predicate_by_class_name true\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Schema Results in Ruby\nDESCRIPTION: Demonstrates how to use Ruby's pattern matching feature with Dry::Schema::Result objects to extract validated data in a concise way.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nschema = Dry::Schema::Params { required(:name).filled }\ncase schema.('name' => 'John')\nin name:\n  name # => 'John'\nend\n```\n\n----------------------------------------\n\nTITLE: Using Before Callbacks in Schema Processing in Ruby\nDESCRIPTION: Demonstrates how to use the experimental before callback feature to modify data before a specific processing step, in this case compacting the hash before value coercion.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:name).value(:string)\n  optional(:age).value(:integer)\n\n  before(:value_coercer) do |result|\n    result.to_h.compact\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: YAML Message Configuration Example\nDESCRIPTION: Example showing how to configure custom meta-data in messages using YAML format.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nen:\n  dry_schema:\n    errors:\n      filled?:\n        text: \"cannot be blank\"\n        code: 123\n```\n\n----------------------------------------\n\nTITLE: Ruby Array Type Schema Definition\nDESCRIPTION: Example demonstrating how to define a schema with an array of hashes using dry-schema DSL.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/CHANGELOG.md#2025-04-12_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.Params do\n  required(:tags).array(:hash) do\n    required(:name).filled(:string)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Loading Extensions in Dry-Schema Ruby\nDESCRIPTION: Shows how to load extensions in the dry-schema gem using the load_extensions method.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nDry::Schema.load_extensions\n```\n\n----------------------------------------\n\nTITLE: Loading the Monads Extension in Dry::Schema\nDESCRIPTION: Shows how to require dry-schema and load the monads extension. This is the first step needed to enable monad compatibility with schema validation results.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/extensions/monads.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/schema'\n\nDry::Schema.load_extensions(:monads)\n```\n\n----------------------------------------\n\nTITLE: Configuring Key Validation in dry-schema Ruby\nDESCRIPTION: Shows how to enable key validation globally or per schema using configuration options.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/docsite/source/advanced/unexpected-keys.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# Enable it globally\nDry::Schema.config.validate_keys = true\n\n\n# or per schema\nDry::Schema.Params do\n  config.validate_keys = true\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Ruby Version Requirements\nDESCRIPTION: Version requirements for the dry-schema gem, specifying minimum supported versions for MRI Ruby and JRuby.\nSOURCE: https://github.com/dry-rb/dry-schema/blob/main/README.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n>= 3.1\n```\n\nLANGUAGE: ruby\nCODE:\n```\n>= 9.4\n```"
  }
]