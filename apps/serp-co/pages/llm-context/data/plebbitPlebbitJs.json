[
  {
    "owner": "plebbit",
    "repo": "plebbit-js",
    "content": "TITLE: Defining Plebbit Core Data Structures in JavaScript\nDESCRIPTION: Defines the core data structures and types used in the Plebbit decentralized social platform. Includes definitions for publications, comments, votes, authors, subplebbits and their associated properties.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nAddress: string // a plebbit author, subplebbit or multisub \"address\" can be a crypto domain like memes.eth, an IPNS name, an ethereum address, etc. How to resolve ENS names https://github.com/plebbit/plebbit-js/blob/master/docs/ens.md\nPublication {\n  author: Author\n  subplebbitAddress: string // all publications are directed to a subplebbit owner\n  timestamp: number // number in seconds\n  signature: Signature // sign immutable fields like author, title, content, timestamp to prevent tampering\n  protocolVersion: '1.0.0' // semantic version of the protocol https://semver.org/\n}\nComment extends Publication /* (IPFS file) */ {\n  parentCid?: string // same as postCid for top level comments, undefined for posts\n  content?: string\n  title?: string\n  link?: string\n  linkWidth?: number // author can optionally provide dimensions of image/video link which helps UI clients with infinite scrolling feeds\n  linkHeight?: number\n  linkHtmlTagName?: 'a' | 'img' | 'video' | 'audio' // author can optionally provide the HTML element to use for the link\n  spoiler?: boolean\n  flair?: Flair // arbitrary colored string added by the author or mods to describe the author or comment\n  // below are added by subplebbit owner, not author\n  previousCid?: string // each comment/post is a linked list of other comments/posts with same comment.depth and comment.parentCid, undefined if first comment in list\n  postCid?: string // helps faster loading post info for reply direct linking, undefined for posts, a post can't know its own CID\n  depth: number // 0 = post, 1 = top level reply, 2+ = nested reply\n  thumbnailUrl?: string // optionally fetched by subplebbit owner, some web pages have thumbnail urls in their meta tags https://moz.com/blog/meta-data-templates-123\n  thumbnailUrlWidth?: number // subplebbit owner can optionally provide dimensions of thumbails which helps UI clients with infinite scrolling feeds\n  thumbnailUrlHeight?: number\n}\nVote extends Publication {\n  commentCid: string\n  vote: 1 | -1 | 0 // 0 is needed to cancel a vote\n}\nCommentEdit extends Publication {\n  commentCid: string\n  content?: string\n  deleted?: boolean\n  flair?: Flair\n  spoiler?: boolean\n  reason?: string\n}\nCommentModeration extends Publication {\n  commentCid: string\n  commentModeration: {\n    flair?: Flair\n    spoiler?: boolean\n    pinned?: boolean\n    locked?: boolean\n    removed?: boolean\n    reason?: string\n    author?: {\n      flair?: Flair\n      banExpiresAt?: number\n    }  \n  }\n}\nSubplebbitEdit extends Publication {\n  subplebbitEdit: CreateSubplebbitOptions\n}\nMultisubEdit extends CreateMultisubOptions, Publication {}\nCommentUpdate /* (IPFS file) */ {\n  cid: string // cid of the comment, need it in signature to prevent attack\n  edit?: AuthorCommentEdit // most recent edit by comment author, commentUpdate.edit.content, commentUpdate.edit.deleted, commentUpdate.edit.flair override Comment instance props. Validate commentUpdate.edit.signature\n  upvoteCount: number\n  downvoteCount: number\n  replies?: Pages // only preload page 1 sorted by 'topAll', might preload more later, only provide sorting for posts (not comments) that have 100+ child comments\n  replyCount: number\n  flair?: Flair // arbitrary colored string to describe the comment, added by mods, override comment.flair (which are added by author)\n  spoiler?: boolean\n  pinned?: boolean\n  locked?: boolean\n  removed?: boolean // mod deleted a comment\n  reason?: string // reason the mod took a mod action\n  updatedAt: number // timestamp in seconds the IPNS record was updated\n  protocolVersion: '1.0.0' // semantic version of the protocol https://semver.org/\n  signature: Signature // signature of the CommentUpdate by the sub owner to protect against malicious gateway\n  author?: { // add commentUpdate.author.subplebbit to comment.author.subplebbit, override comment.author.flair with commentUpdate.author.subplebbit.flair if any\n    subplebbit: SubplebbitAuthor\n  }\n  lastReplyTimestamp?: number // needed for active sort in frontend\n  lastChildCid?: number // needed to fetch reply updates using subplebbit.postUpdates https://github.com/plebbit/plebbit-js/issues/12\n}\nAuthor {\n  address: string\n  shortAddress: string // not part of IPFS files, added to `Author` instance as convenience. Copy address, if address is a hash, remove hash prefix and trim to 12 first chars\n  previousCommentCid?: string // linked list of the author's comments\n  displayName?: string\n  wallets?: {[chainTicker: string]: Wallet}\n  avatar?: Nft\n  flair?: Flair // (added added by author originally, can be overriden by commentUpdate.subplebbit.author.flair)\n  subplebbit?: SubplebbitAuthor // (added by CommentUpdate) up to date author properties specific to the subplebbit it's in\n}\nSubplebbitAuthor {\n  banExpiresAt?: number // (added by moderator only) timestamp in second, if defined the author was banned for this comment\n  flair?: Flair // (added by moderator only) for when a mod wants to edit an author's flair\n  postScore: number // total post karma in the subplebbit\n  replyScore: number // total reply karma in the subplebbit\n  lastCommentCid: string // last comment by the author in the subplebbit, can be used with author.previousCommentCid to get a recent author comment history in all subplebbits\n  firstCommentTimestamp: number // timestamp of the first comment by the author in the subplebbit, used for account age based challenges\n}\nWallet {\n  address: string\n  timestamp: number // in seconds, allows partial blocking multiple authors using the same wallet\n  signature: Signature // type 'eip191' {domainSeparator:\"plebbit-author-wallet\",authorAddress:\"${authorAddress}\",\"{timestamp:${wallet.timestamp}\"}\n  // ...will add more stuff later, like signer or send/sign or balance\n}\nNft {\n  chainTicker: string // ticker of the chain, like eth, avax, sol, etc in lowercase\n  timestamp: number // in seconds, needed to mitigate multiple users using the same signature\n  address: string // address of the NFT contract\n  id: string // tokenId or index of the specific NFT used, must be string type, not number\n  signature: Signature // proof that author.address owns the nft\n  // how to resolve and verify NFT signatures https://github.com/plebbit/plebbit-js/blob/master/docs/nft.md\n}\nSignature {\n  signature: string // data in base64\n  publicKey: string // 32 bytes base64 string\n  type: 'ed25519' | 'eip191' // multiple versions/types to allow signing with metamask/other wallet or to change the signature fields or algorithm\n  signedPropertyNames: string[] // the fields that were signed as part of the signature e.g. ['title', 'content', 'author', etc.] client should require that certain fields be signed or reject the publication, e.g. 'content', 'author', 'timestamp' are essential\n}\nSigner {\n  privateKey?: string // 32 bytes base64 string\n  type: 'ed25519' | 'eip191' // multiple versions/types to allow signing with metamask/other wallet or to change the signature fields or algorithm https://eips.ethereum.org/EIPS/eip-191\n  publicKey?: string // 32 bytes base64 string\n  address: string // public key hash, not needed for signing\n  ipfsKey?: IpfsKey // a Key object used for importing into IpfsHttpClient https://docs.ipfs.io/reference/cli/#ipfs-key-import\n}\nSubplebbit /* (IPNS record Subplebbit.address) */ {\n  address: string // validate subplebbit address in signature to prevent a crypto domain resolving to an impersonated subplebbit\n  title?: string\n  description?: string\n  roles?: {[authorAddress: string]: SubplebbitRole} // each author address can be mapped to 1 SubplebbitRole\n  pubsubTopic?: string // the string to publish to in the pubsub, a public key of the subplebbit owner's choice\n  lastPostCid?: string // the most recent post in the linked list of posts\n  lastCommentCid?: string // the most recent comment (posts and replies included), last comment is often displayed with a list of forums\n  posts?: Pages // only preload page 1 sorted by 'hot', might preload more later, comments should include Comment + CommentUpdate data\n  statsCid?: string\n  createdAt: number\n  updatedAt: number\n  features?: SubplebbitFeatures\n  suggested?: SubplebbitSuggested\n  rules?: string[]\n  flairs?: {[key: 'post' | 'author']: Flair[]} // list of post/author flairs authors and mods can choose from\n  protocolVersion: '1.0.0' // semantic version of the protocol https://semver.org/\n  encryption: SubplebbitEncryption\n  signature: Signature // signature of the Subplebbit update by the sub owner to protect against malicious gateway\n}\nSubplebbitSuggested { // values suggested by the sub owner, the client/user can ignore them without breaking interoperability\n  primaryColor?: string\n  secondaryColor?: string\n  avatarUrl?: string\n  bannerUrl?: string\n  backgroundUrl?: string\n  language?: string\n  // TODO: menu links, wiki pages, sidebar widgets\n}\nSubplebbitFeatures { // any boolean that changes the functionality of the sub, add \"no\" in front if doesn't default to false\n  // implemented\n  noUpvotes?: boolean\n  noPostUpvotes?: boolean\n  noReplyUpvotes?: boolean\n  noDownvotes?: boolean\n  noPostDownvotes?: boolean\n  noReplyDownvotes?: boolean\n  requirePostLink?: boolean // require post.link be defined and a valid https url\n  requirePostLinkIsMedia?: boolean // require post.link be media, e.g. for imageboards\n  // not implemented\n  noVideos?: boolean\n  noSpoilers?: boolean // author can't comment.spoiler = true their own comments\n  noImages?: boolean\n  noVideoReplies?: boolean\n  noSpoilerReplies?: boolean\n  noImageReplies?: boolean\n  noPolls?: boolean\n  noCrossposts?: boolean\n  noAuthors?: boolean // no authors at all, like 4chan\n  anonymousAuthors?: boolean // authors are given anonymous ids inside threads, like 4chan\n  noNestedReplies?: boolean // no nested replies, like old school forums and 4chan\n  safeForWork?: boolean\n  authorFlairs?: boolean // authors can choose their own author flairs (otherwise only mods can)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PubSub Message Types in TypeScript\nDESCRIPTION: Defines the structure of different pubsub message types used for challenge-response communication between post authors and subplebbit owners. Includes message types for challenge requests, challenges, answers and verifications.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nPubsubMessage: {\n  type: 'CHALLENGEREQUEST' | 'CHALLENGE' | 'CHALLENGEANSWER' | 'CHALLENGEVERIFICATION'\n  challengeRequestId: Uint8Array // (byte string in cbor) // multihash of challengeRequestMessage.signature.publicKey, each challengeRequestMessage must use a new public key\n  timestamp: number // in seconds, needed because publication.timestamp is encrypted\n  signature: PubsubSignature // each challengeRequestMessage must use a new public key\n  protocolVersion: '1.0.0' // semantic version of the protocol https://semver.org/\n  userAgent: `/plebbit-js:${require('./package.json').version}/` // client name and version using this standard https://en.bitcoin.it/wiki/BIP_0014#Proposal\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Managing Plebbit Addresses with ed25519 Cryptography in JavaScript\nDESCRIPTION: This code demonstrates the complete workflow for generating Plebbit addresses using ed25519 cryptography. It includes functions for generating private keys, deriving public keys, converting to IPFS key formats, and creating Plebbit addresses from both public and private keys. The code relies on Noble ed25519, uint8arrays, libp2p-crypto, and peer-id libraries.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/addresses.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ed = require('@noble/ed25519')\nconst {fromString: uint8ArrayFromString} = require('uint8arrays/from-string')\nconst {toString: uint8ArrayToString} = require('uint8arrays/to-string')\nconst {Ed25519PublicKey, Ed25519PrivateKey} = require('libp2p-crypto/src/keys/ed25519-class')\nconst PeerId = require('peer-id')\n\nconst generatePrivateKey = async () => {\n  const privateKeyBuffer = ed.utils.randomPrivateKey()\n  const privateKeyBase64 = uint8ArrayToString(privateKeyBuffer, 'base64')\n  return privateKeyBase64\n}\n\nconst getPublicKeyFromPrivateKey = async (privateKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, 'base64')\n  const publicKeyBuffer = await ed.getPublicKey(privateKeyBuffer)\n  return uint8ArrayToString(publicKeyBuffer, 'base64')\n}\n\nconst getIpfsKeyFromPrivateKey = async (privateKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, 'base64')\n  const publicKeyBuffer = await ed.getPublicKey(privateKeyBuffer)\n\n  // ipfs ed25519 private keys format are private (32 bytes) + public (32 bytes) (64 bytes total)\n  const privateAndPublicKeyBuffer = new Uint8Array(64)\n  privateAndPublicKeyBuffer.set(privateKeyBuffer)\n  privateAndPublicKeyBuffer.set(publicKeyBuffer, 32)\n\n  const ed25519PrivateKeyInstance = new Ed25519PrivateKey(privateAndPublicKeyBuffer, publicKeyBuffer)\n  // the \"ipfs key\" adds a suffix, then the private key, then the public key, it is not the raw private key\n  return ed25519PrivateKeyInstance.bytes\n} \n\nconst getPeerIdFromPrivateKey = async (privateKeyBase64) => {\n  const ipfsKey = await getIpfsKeyFromPrivateKey(privateKeyBase64)\n  // the PeerId private key is not a raw private key, it's an \"ipfs key\"\n  const peerId = await PeerId.createFromPrivKey(ipfsKey)\n  return peerId\n}\n\nconst getPeerIdFromPublicKey = async (publicKeyBase64) => {\n  const publicKeyBuffer = uint8ArrayFromString(publicKeyBase64, 'base64')\n\n  // the PeerId public key is not a raw public key, it adds a suffix\n  const ed25519PublicKeyInstance = new Ed25519PublicKey(publicKeyBuffer)\n  const peerId = await PeerId.createFromPubKey(ed25519PublicKeyInstance.bytes)\n  return peerId\n}\n\nconst getPlebbitAddressFromPrivateKey = async (privateKeyBase64) => {\n  const peerId = await getPeerIdFromPrivateKey(privateKeyBase64)\n  return peerId.toB58String().trim()\n}\n\nconst getPlebbitAddressFromPublicKey = async (publicKeyBase64) => {\n  const peerId = await getPeerIdFromPublicKey(publicKeyBase64)\n  return peerId.toB58String().trim()\n}\n\n;(async () => {\n  // generate private key\n  const privateKey = await generatePrivateKey()\n  console.log({privateKey})\n\n  // get public key from private key\n  const publicKey = await getPublicKeyFromPrivateKey(privateKey)\n  console.log({publicKey})\n\n  // get PeerId from public key\n  const peerIdFromPublicKey = await getPeerIdFromPublicKey(publicKey)\n  console.log({peerIdFromPublicKey})\n\n  // get PeerId from private key\n  const peerIdFromPrivateKey = await getPeerIdFromPrivateKey(privateKey)\n  console.log({peerIdFromPrivateKey})\n\n  // get plebbit address from public key\n  const plebbitAddressFromPublicKey = await getPlebbitAddressFromPublicKey(publicKey)\n  console.log({plebbitAddressFromPublicKey})\n\n  // get plebbit address from private key\n  const plebbitAddressFromPrivateKey = await getPlebbitAddressFromPrivateKey(privateKey)\n  console.log({plebbitAddressFromPrivateKey})\n\n  // get ipfs key from private key\n  const ipfsKey = await getIpfsKeyFromPrivateKey(privateKey)\n  console.log({ipfsKey})\n})()\n```\n\n----------------------------------------\n\nTITLE: Defining Challenge and Encryption Types\nDESCRIPTION: Defines data structures for challenges and encryption used in the platform's security system. Includes challenge types, encrypted message format, and signature specifications.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nChallenge {\n  type: 'image/png' | 'text/plain' | 'chain/<chainTicker>' // tells the client how to display the challenge\n  challenge: string // base64 or utf8 required to complete the challenge\n  caseInsensitive?: boolean // challenge answer capitalization is ignored\n}\n\nEncrypted {\n  ciphertext: Uint8Array \n  iv: Uint8Array \n  tag: Uint8Array \n  type: 'ed25519-aes-gcm'\n}\n\nPubsubSignature {\n  signature: Uint8Array\n  publicKey: Uint8Array\n  type: 'ed25519' | 'eip191'\n  signedPropertyNames: string[]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ed25519-AES-GCM Encryption and Decryption in JavaScript\nDESCRIPTION: A comprehensive implementation of the 'ed25519-aes-gcm' encryption type for Plebbit. It uses Ed25519 for key exchange and AES-GCM for symmetric encryption with authentication. The implementation includes functions for generating keys, encrypting and decrypting messages, with added random padding to prevent linking encrypted publications by size.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/encryption.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ed = require('@noble/ed25519')\nconst {fromString: uint8ArrayFromString} = require('uint8arrays/from-string')\nconst {toString: uint8ArrayToString} = require('uint8arrays/to-string')\nconst forge = require('node-forge')\n\nconst generatePrivateKey = async () => {\n  const privateKeyBuffer = ed.utils.randomPrivateKey()\n  const privateKeyBase64 = uint8ArrayToString(privateKeyBuffer, 'base64')\n  return privateKeyBase64\n}\n\nconst getPublicKeyFromPrivateKey = async (privateKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, 'base64')\n  const publicKeyBuffer = await ed.getPublicKey(privateKeyBuffer)\n  return uint8ArrayToString(publicKeyBuffer, 'base64')\n}\n\nconst uint8ArrayToNodeForgeBuffer = (uint8Array) => {\n  const forgeBuffer = forge.util.createBuffer()\n  for (const byte of uint8Array) {\n    forgeBuffer.putByte(byte)\n  }\n  return forgeBuffer\n}\n\n// NOTE: never pass the last param 'iv', only used for testing, it must always be random\nconst encryptStringAesGcm = async (plaintext, key) => {\n  // use random 12 bytes uint8 array for iv\n  const iv = ed.utils.randomPrivateKey().slice(0, 12)\n\n  // node-forge doesn't accept uint8Array\n  const keyAsForgeBuffer = uint8ArrayToNodeForgeBuffer(key)\n  const ivAsForgeBuffer = uint8ArrayToNodeForgeBuffer(iv)\n\n  const cipher = forge.cipher.createCipher(\"AES-GCM\", keyAsForgeBuffer)\n  cipher.start({iv: ivAsForgeBuffer})\n  cipher.update(forge.util.createBuffer(plaintext, \"utf8\"))\n  cipher.finish()\n\n  return {\n    ciphertext: uint8ArrayFromString(cipher.output.toHex(), \"base16\"), // Uint8Array\n    iv, // Uint8Array\n    // AES-GCM has authentication tag https://en.wikipedia.org/wiki/Galois/Counter_Mode\n    tag: uint8ArrayFromString(cipher.mode.tag.toHex(), \"base16\") // Uint8Array\n  }\n}\n\nconst decryptStringAesGcm = async (ciphertext, key, iv, tag) => {\n  // node-forge doesn't accept uint8Array\n  const keyAsForgeBuffer = uint8ArrayToNodeForgeBuffer(key)\n  const ivAsForgeBuffer = uint8ArrayToNodeForgeBuffer(iv)\n  const tagAsForgeBuffer = uint8ArrayToNodeForgeBuffer(tag)\n\n  const cipher = forge.cipher.createDecipher(\"AES-GCM\", keyAsForgeBuffer)\n  cipher.start({iv: ivAsForgeBuffer, tag: tagAsForgeBuffer})\n  cipher.update(forge.util.createBuffer(ciphertext))\n  cipher.finish()\n  const decrypted = cipher.output.toString()\n  return decrypted\n}\n\nconst encryptEd25519AesGcm = async (plaintext, privateKeyBase64, publicKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, \"base64\")\n  const publicKeyBuffer = uint8ArrayFromString(publicKeyBase64, \"base64\")\n\n  // add random padding to prevent linking encrypted publications by sizes\n  const randomPaddingLength = Math.round(Math.random() * 5000)\n  let padding = \"\"\n  while (padding.length < randomPaddingLength) {\n    padding += \" \"\n  }\n\n  // compute the shared secret of the sender and recipient and use it as the encryption key\n  // do not publish this secret https://datatracker.ietf.org/doc/html/rfc7748#section-6.1\n  const aesGcmKey = await ed.getSharedSecret(privateKeyBuffer, publicKeyBuffer)\n  // use 16 bytes key for AES-128\n  const aesGcmKey16Bytes = aesGcmKey.slice(0, 16)\n\n  // AES GCM using 128-bit key https://en.wikipedia.org/wiki/Galois/Counter_Mode\n  const {ciphertext, iv, tag} = await encryptStringAesGcm(plaintext + padding, aesGcmKey16Bytes)\n\n  const encrypted = {\n    ciphertext, // Uint8Array\n    iv, // Uint8Array\n    // AES-GCM has authentication tag https://en.wikipedia.org/wiki/Galois/Counter_Mode\n    tag, // Uint8Array\n    type: \"ed25519-aes-gcm\"\n  }\n  return encrypted\n}\n\nconst decryptEd25519AesGcm = async (encrypted, privateKeyBase64, publicKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, \"base64\")\n  const publicKeyBuffer = uint8ArrayFromString(publicKeyBase64, \"base64\")\n\n  // compute the shared secret of the sender and recipient and use it as the encryption key\n  // do not publish this secret https://datatracker.ietf.org/doc/html/rfc7748#section-6.1\n  const aesGcmKey = await ed.getSharedSecret(privateKeyBuffer, publicKeyBuffer)\n  // use 16 bytes key for AES-128\n  const aesGcmKey16Bytes = aesGcmKey.slice(0, 16)\n\n  // AES GCM using 128-bit key https://en.wikipedia.org/wiki/Galois/Counter_Mode\n  let decrypted = await decryptStringAesGcm(encrypted.ciphertext, aesGcmKey16Bytes, encrypted.iv, encrypted.tag)\n\n  // remove padding\n  decrypted = decrypted.replace(/ *$/, \"\")\n\n  return decrypted\n}\n\n;(async () => {\n  // generate private key\n  const privateKey = await generatePrivateKey()\n  console.log({privateKey})\n\n  // get public key from private key\n  const publicKey = await getPublicKeyFromPrivateKey(privateKey)\n  console.log({publicKey})\n\n  // encrypt\n  const recipientPrivateKey = await generatePrivateKey()\n  const recipientPublicKey = await getPublicKeyFromPrivateKey(recipientPrivateKey)\n  const encrypted = await encryptEd25519AesGcm('hello', privateKey, recipientPublicKey)\n  console.log({encrypted})\n\n  // decrypt\n  const decrypted = await decryptEd25519AesGcm(encrypted, recipientPrivateKey, publicKey)\n  console.log({decrypted})\n})()\n```\n\n----------------------------------------\n\nTITLE: Initializing Native Functions in Plebbit-js\nDESCRIPTION: Demonstrates how to override default native functions in plebbit-js using custom implementations. This allows platform-specific functionality to be injected into the browser renderer, particularly useful for Electron and Android WebView environments.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/cross-platform-native-functions.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport Plebbit from '@plebbit/plebbit-js'\n\nconst nativeFunctions = {\n  fetch: async () => {},\n  listSubplebbits: async () => {},\n  // ...no need to override all native functions\n}\n\nPlebbit.setNativeFunctions(nativeFunctions)\n```\n\n----------------------------------------\n\nTITLE: Implementing Ed25519 Cryptographic Signatures in JavaScript for Plebbit\nDESCRIPTION: A comprehensive implementation of Ed25519 signature functions for Plebbit.js including key generation, signing, and verification. The code uses @noble/ed25519 for cryptographic operations, uint8arrays for string conversion, and cborg for encoding objects to buffers for signing.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/signatures.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ed = require('@noble/ed25519')\nconst {fromString: uint8ArrayFromString} = require('uint8arrays/from-string')\nconst {toString: uint8ArrayToString} = require('uint8arrays/to-string')\nconst {Ed25519PublicKey, Ed25519PrivateKey} = require('libp2p-crypto/src/keys/ed25519-class')\nconst cborg = require('cborg')\n\nconst generatePrivateKey = async () => {\n  const privateKeyBuffer = ed.utils.randomPrivateKey()\n  const privateKeyBase64 = uint8ArrayToString(privateKeyBuffer, 'base64')\n  return privateKeyBase64\n}\n\nconst getPublicKeyFromPrivateKey = async (privateKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, 'base64')\n  const publicKeyBuffer = await ed.getPublicKey(privateKeyBuffer)\n  return uint8ArrayToString(publicKeyBuffer, 'base64')\n}\n\nconst signBufferEd25519 = async (bufferToSign, privateKeyBase64) => {\n  const privateKeyBuffer = uint8ArrayFromString(privateKeyBase64, 'base64')\n  // do not use to sign strings, it doesn't encode properly in the browser\n  const signature = await ed.sign(bufferToSign, privateKeyBuffer)\n  return signature\n}\n\nconst verifyBufferEd25519 = async (bufferToSign, bufferSignature, publicKeyBase64) => {\n  const publicKeyBuffer = uint8ArrayFromString(publicKeyBase64, 'base64')\n  const isValid = await ed.verify(bufferSignature, bufferToSign, publicKeyBuffer)\n  return isValid\n}\n\nconst getBufferToSign = (objectToSign, signedPropertyNames) => {\n  const propsToSign = {}\n  for (const propertyName of signedPropertyNames) {\n    if (objectToSign[propertyName] !== undefined && objectToSign[propertyName] !== null) {\n      propsToSign[propertyName] = objectToSign[propertyName]\n    }\n  }\n  const bufferToSign = cborg.encode(propsToSign)\n  return bufferToSign\n}\n\n;(async () => {\n  // generate private key\n  const privateKey = await generatePrivateKey()\n  console.log({privateKey})\n\n  // get public key from private key\n  const publicKey = await getPublicKeyFromPrivateKey(privateKey)\n  console.log({publicKey})\n\n  // sign\n  const bufferToSign = getBufferToSign({content: 'content', author: {address: 'address'}}, ['author', 'content', 'parentCid'])\n  console.log({bufferToSign, bufferToSignUtf8: uint8ArrayToString(bufferToSign, 'utf8')})\n  console.log(JSON.stringify({content: 'content', author: {address: 'address'}, signedPropertyNames: ['author', 'content', 'parentCid']}))\n  const bufferSignature = await signBufferEd25519(bufferToSign, privateKey)\n  console.log({bufferSignature})\n\n  // verify\n  const verification = await verifyBufferEd25519(bufferToSign, bufferSignature, publicKey)\n  console.log({verification})\n})()\n```\n\n----------------------------------------\n\nTITLE: Initializing Plebbit Instance in JavaScript\nDESCRIPTION: Creates a new Plebbit instance with custom options. This example demonstrates setting IPFS gateway URLs, Kubo RPC client options, and a data path for the Plebbit database.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst Plebbit = require('@plebbit/plebbit-js')\nconst options = {\n  ipfsGatewayUrls: ['https://cloudflare-ipfs.com'],\n  kuboRpcClientsOptions: ['http://localhost:5001/api/v0'], // optional, must run an IPFS node to use localhost:5001/api/v0\n  dataPath: __dirname\n}\nconst plebbit = await Plebbit(options) // should be independent instance, not singleton\nplebbit.on('error', console.log)\n```\n\n----------------------------------------\n\nTITLE: Creating and Publishing a Comment Moderation in Plebbit-js\nDESCRIPTION: Demonstrates how to create a CommentModeration instance, handle challenges, and publish the moderation using the plebbit-js library.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst commentModeration = await plebbit.createCommentModeration(createCommentModerationOptions)\ncommentModeration.on('challenge', async (challengeMessage, _commentModeration) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  _commentModeration.publishChallengeAnswers(challengeAnswers)\n})\ncommentModeration.on('challengeverification', console.log)\nawait commentModeration.publish()\n```\n\n----------------------------------------\n\nTITLE: Handling Comment Challenge and Verification Events in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a comment, handle challenge events, publish challenge answers, and log the challenge verification result.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst comment = await plebbit.createComment(commentObject)\ncomment.on('challenge', async (challengeMessage, _comment) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  _comment.publishChallengeAnswers(challengeAnswers)\n})\ncomment.on('challengeverification', console.log)\nawait comment.publish()\n```\n\n----------------------------------------\n\nTITLE: Publication with Author Verification\nDESCRIPTION: Combines author and signature verification for publications. Includes option to override invalid author addresses and handles address validation for both domain and CID-based addresses.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Creating and Managing Subplebbits in Plebbit.js\nDESCRIPTION: Shows various ways to create and manage subplebbit instances using plebbit.createSubplebbit(), including creating new subplebbits, instantiating existing ones, and editing subplebbit information.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst Plebbit = require('@plebbit/plebbit-js')\nconst plebbitOptions = {\n  ipfsGatewayUrls: ['https://cloudflare-ipfs.com'],\n  kuboRpcClientsOptions: ['http://localhost:5001/api/v0'], // optional, must run an IPFS node to use localhost:5001/api/v0\n  dataPath: __dirname\n}\nconst plebbit = await Plebbit(plebbitOptions)\nplebbit.on('error', console.log)\n\n// create a new local subplebbit as the owner\nconst subplebbit = await plebbit.createSubplebbit()\n\n// create a new local subplebbit as the owner, already with settings\nconst subplebbit = await plebbit.createSubplebbit({title: 'Memes', description: 'Post your memes here.'})\n\n// create a new local subplebbit as the owner with a premade signer\nconst signer = await plebbit.createSigner()\nconst subplebbit = await plebbit.createSubplebbit({signer})\n// signer.address === subplebbit.address\n\n// create a new local subplebbit as the owner with a premade signer, already with settings\nconst signer = await plebbit.createSigner()\nconst subplebbit = await plebbit.createSubplebbit({signer, title: 'Memes', description: 'Post your memes here.'})\n\n// instantiate an already existing subplebbit instance\nconst subplebbitOptions = {address: '12D3KooW...',}\nconst subplebbit = await plebbit.createSubplebbit(subplebbitOptions)\n\n// edit the subplebbit info in the database\nawait subplebbit.edit({\n  title: 'Memes',\n  description: 'Post your memes here.',\n  pubsubTopic: '12D3KooW...'\n})\n\n// start publishing updates every 5 minutes\nawait subplebbit.start()\n\n// instantiate an already existing subplebbit instance and initialize any property on it\nconst subplebbit = await plebbit.createSubplebbit({\n  address: '12D3KooW...',\n  title: 'Memes',\n  posts: {\n    pages: {\n      hot: {\n        nextCid: 'Qm...', \n        comments: [{content: 'My first post', ...post}]\n      }\n    },\n    pageCids: {topAll: 'Qm...', new: 'Qm...', ...pageCids}\n  }\n})\nconsole.log(subplebbit.title) // prints 'Memes'\nconsole.log(subplebbit.posts.pages.hot.comments[0].content) // prints 'My first post'\n```\n\n----------------------------------------\n\nTITLE: Author Verification Function for Plebbit Messages\nDESCRIPTION: Verifies the authenticity of an author in CommentEdit, Vote, or Comment messages. Handles both domain-based addresses (ENS) and CID addresses, comparing them against signature public keys.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Starting a Subplebbit in JavaScript\nDESCRIPTION: This example shows how to create a subplebbit, edit its information, and start publishing updates. It demonstrates the use of createSubplebbit(), edit(), and start() methods.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nconst options = {\n  title: 'Your subplebbit title'\n}\nconst subplebbit = await plebbit.createSubplebbit(options)\n// edit the subplebbit info in the database\nawait subplebbit.edit({\n  title: 'Memes',\n  description: 'Post your memes here.',\n  pubsubTopic: '12D3KooW...'\n})\n// start publishing updates/new posts\nawait subplebbit.start()\n```\n\n----------------------------------------\n\nTITLE: Publishing a Comment with Challenge Handling in JavaScript\nDESCRIPTION: This example demonstrates how to publish a comment, handle the challenge event, and submit challenge answers. It uses the createComment() method and handles 'challenge' and 'challengeverification' events.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nconst comment = await plebbit.createComment(commentObject)\ncomment.on('challenge', async (challengeMessage) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  comment.publishChallengeAnswers(challengeAnswers)\n})\ncomment.on('challengeverification', console.log)\nawait comment.publish()\n```\n\n----------------------------------------\n\nTITLE: Handling Client State Changes for Multiple Client Types in JavaScript\nDESCRIPTION: This example demonstrates how to set up event listeners for state changes across different types of clients, including IPFS gateways, IPFS clients, pubsub clients, and chain providers.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nconst onStateChange = (state) => console.log('client state changed:', state)\nfor (const clientUrl in clients?.ipfsGateways) {\n  comment.clients?.ipfsGateways?.[clientUrl].on('statechange', onStateChange)\n}\nfor (const clientUrl in clients?.ipfsClients) {\n  comment.clients?.ipfsClients?.[clientUrl].on('statechange', onStateChange)\n}\nfor (const clientUrl in clients?.pubsubClients) {\n  comment.clients?.pubsubClients?.[clientUrl].on('statechange', onStateChange)\n}\nfor (const chainTicker in clients?.chainProviders) {\n  for (const clientUrl in clients?.chainProviders?.[chainTicker]) {\n    comment.clients?.chainProviders?.[chainTicker]?.[clientUrl].on('statechange', onStateChange)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Comment Challenge Verification and Logging CID in JavaScript\nDESCRIPTION: This snippet shows how to create a comment, handle challenge events, publish challenge answers, and log the published post CID from the challenge verification.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nconst comment = await plebbit.createComment(commentObject)\ncomment.on('challenge', async (challengeMessage) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  comment.publishChallengeAnswers(challengeAnswers)\n})\ncomment.on('challengeverification', (challengeVerification) => console.log('published post cid is', challengeVerification?.publication?.cid))\nawait comment.publish()\n```\n\n----------------------------------------\n\nTITLE: Creating a Multisub in Plebbit.js\nDESCRIPTION: Demonstrates how to create a multisub instance, edit its information, add subplebbits, and manage its lifecycle using the plebbit.createMultisub() method.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst multisubOptions = {signer}\nconst multisub = await plebbit.createMultisub(multisubOptions)\n\n// edit the multisub info in the database (only in Node and if multisub.signer is defined)\nawait multisub.edit({\n  address: 'funny-subs.eth',\n  title: 'Funny subplebbits',\n  description: 'The funniest subplebbits',\n})\n\n// add a list of subplebbits to the multisub in the database (only in Node and if multisub.signer is defined)\nconst multisubSubplebbit1 = {address: 'funny.eth', title: 'Funny things', tags: ['funny']}\nconst multisubSubplebbit2 = {address: 'even-more-funny.eth'}\nawait multisub.edit({subplebbits: [multisubSubplebbit1, multisubSubplebbit2]})\n\n// start publishing updates to your multisub (only in Node and if multisub.signer is defined)\nawait multisub.start()\n\n// stop publishing updates to your multisub\nawait multisub.stop()\n```\n\n----------------------------------------\n\nTITLE: Creating and Publishing a Comment in Plebbit-js\nDESCRIPTION: Demonstrates how to create a comment, handle challenges, and publish it using the plebbit-js library. It also shows how to initialize properties on a Comment instance.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst comment = await plebbit.createComment(createCommentOptions)\ncomment.on('challenge', async (challengeMessage) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  comment.publishChallengeAnswers(challengeAnswers)\n})\ncomment.on('challengeverification', console.log)\nawait comment.publish()\n\n// initialize any property on the Comment instance\nconst comment = await plebbit.createComment({\n  cid: 'Qm...',\n  content: 'My first post',\n  locked: true,\n  upvoteCount: 100,\n  replies: {\n    pages: {\n      topAll: {\n        nextCid: 'Qm...', \n        comments: [{content: 'My first reply', ...reply}]\n      }\n    },\n    pageCids: {new: 'Qm...', old: 'Qm...', ...pageCids}\n  }\n})\nconsole.log(comment.content) // prints 'My first post'\nconsole.log(comment.locked) // prints true\nconsole.log(comment.upvoteCount) // prints 100\nconsole.log(comment.replies.pages.topAll.comments[0].content) // prints 'My first reply'\n```\n\n----------------------------------------\n\nTITLE: Creating and Publishing a Vote in Plebbit-js\nDESCRIPTION: Shows how to create a Vote instance, handle challenges, and publish the vote using the plebbit-js library.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst vote = await plebbit.createVote(createVoteOptions)\nvote.on('challenge', async (challengeMessage, _vote) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  _vote.publishChallengeAnswers(challengeAnswers)\n})\nvote.on('challengeverification', console.log)\nawait vote.publish()\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Processing Comment Data in JavaScript\nDESCRIPTION: Fetches a comment by its CID, sets up an update listener, and retrieves related information such as the parent post and subplebbit. This demonstrates complex interactions with Plebbit comments.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst commentCid = 'Qm...'\nconst comment = await plebbit.getComment(commentCid)\nconsole.log('comment:', comment)\ncomment.on('update', updatedComment => console.log('comment with latest data', updatedComment))\nif (comment.parentCid) { // comment with no parent cid is a post\n  plebbit.getComment(comment.parentCid).then(parentPost => console.log('parent post:', parentPost))\n}\nplebbit.getSubplebbit(comment.subplebbitAddress).then(subplebbit => console.log('subplebbit:', subplebbit))\nplebbit.getComment(comment.previousCid).then(previousComment => console.log('previous comment:', previousComment))\n```\n\n----------------------------------------\n\nTITLE: Resolving ENS Names for Plebbit Addresses using JavaScript and ethers\nDESCRIPTION: This code snippet demonstrates how to resolve ENS names for author and subplebbit addresses in the Plebbit project. It uses the ethers library to interact with various blockchain networks, caches providers, and resolves ENS TXT records.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/ens.md#2025-04-16_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst ethers = require('ethers')\n\n// the user can edit these blockchains settings in the account or plebbit-js settings\nconst chainProviders = {\n  avax: {\n    url: 'https://api.avax.network/ext/bc/C/rpc',\n    chainId: 43114\n  },\n  matic: {\n    url: 'https://polygon-rpc.com',\n    chainId: 137\n  }\n}\n\n// cache the blockchain providers because only 1 should be running at the same time\nconst cachedChainProviders = {}\nconst getChainProvider = (chainTicker) => {\n  if (cachedChainProviders[chainTicker]) {\n    return cachedChainProviders[chainTicker]\n  }\n  if (chainProviders[chainTicker]) {\n    cachedChainProviders[chainTicker] = new ethers.providers.JsonRpcProvider({url: chainProviders[chainTicker].url}, chainProviders[chainTicker].chainId)\n    return cachedChainProviders[chainTicker]\n  }\n  if (chainTicker === 'eth') {\n    cachedChainProviders['eth'] = ethers.getDefaultProvider()\n    return cachedChainProviders['eth']\n  }\n  throw Error(`no chain provider settings for chain ticker '${chainTicker}'`)\n}\n\nconst resolveEnsTxtRecord = async (ensName, txtRecordName) => {\n  const chainProvider = getChainProvider('eth')\n  const resolver = await chainProvider.getResolver(ensName)\n  const txtRecordResult = await resolver.getText(txtRecordName)\n  return txtRecordResult\n}\n\nconst resolveAuthorAddress = async (authorAddress) => {\n  if (authorAddress.endsWith('.eth')) {\n    return resolveEnsTxtRecord(authorAddress, 'plebbit-author-address')\n  }\n  return authorAddress\n}\n\nconst resolveSubplebbitAddress = async (subplebbitAddress) => {\n  if (subplebbitAddress.endsWith('.eth')) {\n    return resolveEnsTxtRecord(subplebbitAddress, 'subplebbit-address')\n  }\n  return subplebbitAddress\n}\n\n;(async () => {\n  // resolve ens name (replace 'plebbit.eth' with 'john.eth' or whatever the address is)\n  // this needs to be called when verifying the comment.signature, but not the nft.signature\n  const authorAddressPublicKeyHash = await resolveAuthorAddress('plebbit.eth')\n  const subplebbitAddressPublicKeyHash = await resolveSubplebbitAddress('plebbit.eth')\n  console.log({authorAddressPublicKeyHash, subplebbitAddressPublicKeyHash})\n})()\n```\n\n----------------------------------------\n\nTITLE: Updating a Comment in JavaScript\nDESCRIPTION: This snippet shows how to update a comment and listen for updates. It demonstrates fetching a comment by CID, setting up an update event listener, and starting the update process.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nconst commentCid = 'Qm...'\nconst comment = await plebbit.getComment(commentCid)\ncomment.on('update', (updatedCommentInstance) => {\n  console.log(updatedCommentInstance)\n\n  // if you want to stop polling for new updates after only the first one\n  comment.stop()\n})\ncomment.update()\n\n// if you already fetched the comment and only want the updates\nconst commentDataFetchedEarlier = {content, author, cid, ...comment}\nconst comment = await plebbit.createComment(commentDataFetchedEarlier)\ncomment.on('update', () => {\n  console.log('the comment instance updated itself:', comment)\n})\ncomment.update()\n```\n\n----------------------------------------\n\nTITLE: Defining Types for Plebbit JS Library in JavaScript\nDESCRIPTION: This code snippet defines various types and interfaces used in the Plebbit JS library. It includes definitions for Client, ClientEvents, Clients, Comment, Subplebbit, Pages, and various statistics interfaces for IPFS and Pubsub. It also defines extended client types and the main Plebbit and PlebbitClients objects.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/clients.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nClient {\n  state: string\n}\n\nClientEvents {\n  statechange(state: string): void\n}\n\nClients {\n  ipfsGateways: {[ipfsGatewayUrl: string]: Client}\n  ipfsClients: {[ipfsClientUrl: string]: Client}\n  pubsubClients: {[pubsubClientUrl: string]: Client}\n  chainProviders: {[chainTicker: string]: {[chainProviderUrl: string]: Client}}\n}\n\nComment {\n  clients: Clients\n}\n\nSubplebbit {\n  clients: Clients\n}\n\nPages {\n  clients: {[sortType: string]: {[chainProviderUrl: string]: Client}}\n}\n\nIpfsStats {\n  totalIn: number // IPFS stats https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-stats-bw\n  totalOut: number\n  rateIn: number\n  rateOut: number\n  succeededIpfsCount: number\n  failedIpfsCount: number\n  succeededIpfsAverageTime: number\n  succeededIpfsMedianTime: number\n  succeededIpnsCount: number\n  failedIpnsCount: number\n  succeededIpnsAverageTime: number\n  succeededIpnsMedianTime: number\n}\n\nIpfsSubplebbitStats {\n  stats: IpfsStats\n  sessionStats: IpfsStats // session means in the last 1h\n}\n\nPubsubStats {\n  totalIn: number // IPFS stats https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-stats-bw\n  totalOut: number\n  rateIn: number\n  rateOut: number\n  succeededChallengeRequestMessageCount: number\n  failedChallengeRequestMessageCount: number\n  succeededChallengeRequestMessageAverageTime: number\n  succeededChallengeRequestMessageMedianTime: number\n  succeededChallengeAnswerMessageCount: number\n  failedChallengeAnswerMessageCount: number\n  succeededChallengeAnswerMessageAverageTime: number\n  succeededChallengeAnswerMessageMedianTime: number\n}\n\nPubsubSubplebbitStats {\n  stats: PubsubStats\n  sessionStats: PubsubStats // session means in the last 1h\n}\n\nIpfsClient extends Client {\n  getPeers(): Promise<Peer[]> // IPFS peers https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-swarm-peers\n  getStats(): Promise<{\n    stats: IpfsStats\n    sessionStats: IpfsStats // session means in the last 1h\n    subplebbitStats: {[subplebbitAddress: string]: IpfsSubplebbitStats}\n  }> \n}\n\nGatewayClient extends Client {\n  getStats(): Promise<{\n    stats: IpfsStats\n    sessionStats: IpfsStats // session means in the last 1h\n    subplebbitStats: {[subplebbitAddress: string]: IpfsSubplebbitStats}\n  }>\n}\n\nPubsubClient extends Client {\n  getPeers(): Promise<Peer[]> // IPFS peers https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-swarm-peers\n  getStats(): Promise<{\n    stats: PubsubStats\n    sessionStats: PubsubStats\n    subplebbitStats: {[subplebbitAddress: string]: PubsubSubplebbitStats}\n  }> \n}\n\nChainProvider extends Client {\n  // No need to implement for now since blockchain providers are usually fast and don't fail\n}\n\nPlebbitClients {\n  ipfsGateways: {[ipfsGatewayUrl: string]: GatewayClient}\n  ipfsClients: {[ipfsClientUrl: string]: IpfsClient}\n  pubsubClients: {[pubsubClientUrl: string]: PubsubClient}\n  chainProviders: {[chainTicker: string]: {[chainProviderUrl: string]: Client}}\n}\n\nPlebbit {\n  clients: PlebbitClients\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Publishing a Comment Edit in Plebbit-js\nDESCRIPTION: Shows how to create a CommentEdit instance, handle challenges, and publish the edit using the plebbit-js library.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst commentEdit = await plebbit.createCommentEdit(createCommentEditOptions)\ncommentEdit.on('challenge', async (challengeMessage, _commentEdit) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  _commentEdit.publishChallengeAnswers(challengeAnswers)\n})\ncommentEdit.on('challengeverification', console.log)\nawait commentEdit.publish()\n```\n\n----------------------------------------\n\nTITLE: Handling Post Updates and Retrieving Sorted Replies in JavaScript\nDESCRIPTION: This snippet shows how to get a post, handle its updates, and retrieve sorted replies, falling back to default sorting if necessary.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nconst post = await plebbit.getComment(commentCid)\npost.on('update', async updatedPost => {\n  let replies\n  if (updatedPost.replies?.pageCids?.new) {\n    const repliesPageSortedByNew = await updatedPost.replies.getPage(updatedPost.replies.pageCids.new)\n    replies = repliesPageSortedByNew.comments\n  }\n  else {\n    replies = updatedPost.replies.pages.topAll.comments\n  }\n  console.log(replies)\n})\n```\n\n----------------------------------------\n\nTITLE: Updating a Subplebbit in JavaScript\nDESCRIPTION: This snippet shows how to update a subplebbit and listen for updates. It creates a subplebbit instance, sets up an update event listener, and starts the update process.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst options = {\n  address: '12D3KooW...'\n}\nconst subplebbit = await plebbit.createSubplebbit(options)\nsubplebbit.on('update', (updatedSubplebbitInstance) => {\n  console.log(updatedSubplebbitInstance)\n\n  // if you want to stop polling for new updates after only the first one\n  subplebbit.stop()\n})\nsubplebbit.update()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Sorted Posts from a Subplebbit in JavaScript\nDESCRIPTION: This example demonstrates how to get a subplebbit, retrieve a page of posts sorted by top year, and log the sorted posts.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst subplebbit = await plebbit.getSubplebbit(subplebbitAddress)\nconst pageSortedByTopYear = await subplebbit.posts.getPage(subplebbit.posts.pageCids.topYear)\nconst postsSortedByTopYear = pageSortedByTopYear.comments\nconsole.log(postsSortedByTopYear)\n```\n\n----------------------------------------\n\nTITLE: Creating a Signer in Plebbit-js\nDESCRIPTION: Demonstrates how to create a Signer instance with either a random private key or a provided one using the plebbit-js library.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst newRandomSigner = await plebbit.createSigner()\nconst signerFromPrivateKey = await plebbit.createSigner({privateKey: 'AbCd...', type: 'ed25519'})\n```\n\n----------------------------------------\n\nTITLE: Fetching Subplebbit and Scrolling Posts in JavaScript\nDESCRIPTION: Retrieves a subplebbit by its address and then iterates through all its posts using the previous post CIDs. This showcases how to navigate through a subplebbit's content.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst subplebbitAddress = '12D3KooW...'\nconst subplebbit = await plebbit.getSubplebbit(subplebbitAddress)\nconsole.log(subplebbit)\n\nlet currentPostCid = subplebbit.lastPostCid\nconst scrollAllSubplebbitPosts = async () => {\n  while (currentPostCid) {\n    const post = await plebbit.getComment(currentPostCid)\n    console.log(post)\n    currentPostCid = post.previousCid\n  }\n  console.log('there are no more posts')\n}\nscrollAllSubplebbitPosts()\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Subplebbits with JSON-RPC\nDESCRIPTION: An example of how to subscribe to subplebbits updates using the subplebbitsSubscribe method. This method takes no parameters and returns a subscription ID that can be used to unsubscribe later.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"subplebbitsSubscribe\",\n  \"params\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Plebbit JSON-RPC WebSocket Client in JavaScript\nDESCRIPTION: This code snippet shows how to create a client for the Plebbit JSON-RPC WebSocket server. It includes connection handling, subscription management, and example method calls.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst WebSocketClient = require('rpc-websockets').Client // or any JSON RPC websocket compatible library\nconst webSocketClient = new WebSocketClient(`ws://localhost:${port}`)\n\n// debug raw JSON RPC messages in console (optional)\nwebSocketClient.socket.on('message', (message) => console.log('from server:', message.toString()))\n\n// wait for websocket connection  to open\nawait new Promise((resolve) => webSocketClient.on('open', resolve))\n\n// save all subscription messages (ie json rpc messages without 'id', also called json rpc 'notifications')\n// NOTE: it is possible to receive a subscription message before receiving the subscription id\nconst subscriptionsMessages = {}\nwebSocketClient.socket.on('message', (jsonMessage) => {\n  const message = JSON.parse(jsonMessage)\n  const subscriptionId = message?.params?.subscription\n  if (subscriptionId) {\n    if (!subscriptionsMessages[subscriptionId]) {\n      subscriptionsMessages[subscriptionId] = []\n    }\n    subscriptionsMessages[subscriptionId].push(message)\n    // delete the message after 1 minute to not cause memory leak\n    setTimeout(() => subscriptionsMessages[subscriptionId].shift(), 60000)\n  }\n})\n\nclass Subscription extends EventEmitter {\n  constructor(subscriptionId) {\n    super()\n    let emittingMessages = false\n    this.on('newListener', (eventName) => {\n      // emit all subscription messages received before the listener started\n      if (eventName === 'message') {\n        for (const message of subscriptionsMessages[subscriptionId] || []) {\n          this.emit('message', message)\n        }\n      }\n      // emit all new messages\n      if (!emittingMessages) {\n        emittingMessages = true\n        webSocketClient.socket.on('message', emitMessage)\n      }\n    })\n    // stop listening if listener is removed\n    this.on('removeListener', (eventName) => {\n      if (eventName === 'message' && this.listenerCount('message') === 0) {\n        emittingMessages = false\n        webSocketClient.socket.off('message', emitMessage)\n      }\n    })\n    function emitMessage(jsonMessage) {\n      const message = JSON.parse(jsonMessage)\n      if (subscriptionId === message?.params?.subscription) {\n        this.emit('message', message)\n      }\n    }\n  }\n}\n\n// get comment\nconst commentCid = 'Qm...'\nconst comment = await webSocketClient.call('getComment', [commentCid])\nconsole.log(comment)\n\n// get comment updates\nconst subscriptionId = await webSocketClient.call('commentUpdateSubscribe', [comment.cid])\nnew Subscription(subscriptionId).on('message', console.log)\n```\n\n----------------------------------------\n\nTITLE: Exemplifying JSON-RPC Request for subplebbitUpdateSubscribe in JSON\nDESCRIPTION: This snippet shows the JSON-RPC request format for subscribing to subplebbit updates using the subplebbitUpdateSubscribe method.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"subplebbitUpdateSubscribe\",\n  \"params\": [\n    \"memes.eth\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Plebbit JSON-RPC WebSocket Server in JavaScript\nDESCRIPTION: This snippet demonstrates how to set up and run a Plebbit JSON-RPC WebSocket server. It includes error handling and optional debug logging.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {PlebbitWsServer} = require('@plebbit/plebbit-js/rpc')\nconst port = 8080\nconst plebbitOptions = {ipfsHttpClientsOptions: ['http://localhost:5001/api/v0']}\nconst plebbitWebSocketServer = await PlebbitWsServer({port, plebbitOptions})\n\n// debug raw JSON RPC messages in console (optional)\nplebbitWebSocketServer.ws.on('connection', (socket, request) => {\n  console.log('connection')\n  socket.on('message', (message) => console.log(message.toString()))\n})\n\n// handle plebbit and wss errors\nplebbitWebSocketServer.on('error', console.log)\n\nconsole.log(`test server plebbit wss listening on port ${port}`)\n```\n\n----------------------------------------\n\nTITLE: Showing JSON-RPC Notification for Comment Update in JSON\nDESCRIPTION: This snippet illustrates the JSON-RPC notification format for a comment update event.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"commentUpdateNotification\",\n  \"params\": {\n    \"result\": {\n      \"cid\": \"Qm...\",\n      \"upvoteCount\": 1,\n      \"downvoteCount\": 0,\n      \"replyCount\": 0,\n      \"updatedAt\": 1689886478\n    },\n    \"event\": \"update\",\n    \"subscription\": 23784\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subplebbit and Page Verification\nDESCRIPTION: Verifies subplebbit content integrity by validating posts, signatures, and addresses. Includes page verification for checking comment hierarchies and parent relationships.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Running Tests with Debug Logging\nDESCRIPTION: Command to run tests with debug logging enabled for the plebbit-js module for troubleshooting.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=plebbit-js:* npm test\n```\n\n----------------------------------------\n\nTITLE: Using Challenge Verification in Plebbit.js\nDESCRIPTION: Demonstrates how to implement the getChallengeVerification function to handle user publication challenges, including error handling for misconfigured challenges.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/runtime/node/subplebbit/challenges/README.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst {getChallengeVerification} = require('./challenges')\n\n// NOTE: publishing challenge pubsub message and waiting for challenge answer message go inside the getChallengeAnswers callback\n// because they are sometimes skipped\nconst getChallengeAnswers = async (challenges) => {\n  // ...get challenge answers from user. e.g.:\n  // step 1. subplebbit publishes challenge pubsub message with `challenges` provided in argument of `getChallengeAnswers`\n  // step 2. subplebbit waits for challenge answer pubsub message with `challengeAnswers` and then returns `challengeAnswers`\n  return challengeAnswers\n}\n\n// NOTE: we try to get challenge verification immediately after receiving challenge request\n// because some challenges are automatic and skip the challenge message\nlet challengeVerification\ntry {\n  challengeVerification = await getChallengeVerification(challengeRequest, subplebbit, getChallengeAnswers)\n}\n// getChallengeVerification will throw if one of the getChallenge function throws, which indicates a bug with the challenge script\ncatch (e) {\n  // notify the sub owner that that one of his challenge is misconfigured via an error event\n  subplebbit.emit('error', e.message)\n\n  // notify the author that his publication wasn't published because the subplebbit is misconfigured\n  challengeVerification = {\n    challengeSuccess: false,\n    reason: `One of the subplebbit challenges is misconfigured: ${e.message}`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NFT Avatar Resolution and Verification using ethers.js\nDESCRIPTION: Comprehensive implementation for handling NFT avatars including blockchain provider management, NFT image URL resolution, and signature verification. Uses ethers.js for blockchain interaction and supports multiple chains including Ethereum, Avalanche, and Polygon. Includes functions for creating and verifying NFT signatures to prove ownership.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/nft.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ethers = require('ethers')\nconst fetch = require('isomorphic-fetch')\n\n// this setting can be edited in the account or plebbit-js settings, possible to use a local node\nconst ipfsGatewayUrl = 'https://ipfs.io'\n\n// the user can edit these blockchains settings in the account or plebbit-js settings\nconst chainProviders = {\n  avax: {\n    url: 'https://api.avax.network/ext/bc/C/rpc',\n    chainId: 43114\n  },\n  matic: {\n    url: 'https://polygon-rpc.com',\n    chainId: 137\n  }\n}\n\n// cache the blockchain providers because only 1 should be running at the same time\nconst cachedChainProviders = {}\nconst getChainProvider = (chainTicker) => {\n  if (cachedChainProviders[chainTicker]) {\n    return cachedChainProviders[chainTicker]\n  }\n  if (chainProviders[chainTicker]) {\n    cachedChainProviders[chainTicker] = new ethers.providers.JsonRpcProvider({url: chainProviders[chainTicker].url}, chainProviders[chainTicker].chainId)\n    return cachedChainProviders[chainTicker]\n  }\n  if (chainTicker === 'eth') {\n    cachedChainProviders['eth'] = ethers.getDefaultProvider()\n    return cachedChainProviders['eth']\n  }\n  throw Error(`no chain provider settings for chain ticker '${chainTicker}'`)\n}\n\nconst nftAbi = [\n  {\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\n  {\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}  \n]\n\nconst getNftImageUrl = async (nft) => {\n  const chainProvider = getChainProvider(nft.chainTicker)\n  const nftContract = new ethers.Contract(nft.address, nftAbi, chainProvider)\n  let nftUrl = await nftContract.tokenURI(nft.id)\n\n  // if the ipfs nft is json, get the image url using the ipfs gateway in account settings\n  if (nftUrl.startsWith('ipfs://')) {\n    nftUrl = `${ipfsGatewayUrl}/${nftUrl.replace('://', '/')}`\n  }\n\n  // if the ipfs file is json, it probably has an 'image' property\n  try {\n    const json = await fetch(nftUrl).then(resp => resp.json())\n    nftUrl = json.image\n\n    // if the image property is an ipfs url, get the image url using the ipfs gateway in account settings\n    if (nftUrl.startsWith('ipfs://')) {\n      nftUrl = `${ipfsGatewayUrl}/${nftUrl.replace('://', '/')}`\n    }\n  }\n  catch (e) {}\n\n  return nftUrl\n}\n\nconst createNftSignature = async (nft, authorAddress, ethersJsSigner) => {\n  let messageToSign = {}\n  // the property names must be in this order for the signature to match\n  // insert props one at a time otherwise babel/webpack will reorder\n  messageToSign.domainSeparator = 'plebbit-author-avatar'\n  messageToSign.authorAddress = authorAddress\n  messageToSign.timestamp = nft.timestamp\n  messageToSign.tokenAddress = nft.address\n  messageToSign.tokenId = String(nft.id) // must be a type string, not number\n  // use plain JSON so the user can read what he's signing\n  messageToSign = JSON.stringify(messageToSign)\n\n  // the ethers.js signer is usually gotten from metamask https://docs.ethers.io/v5/api/signer/\n  const signature = await ethersJsSigner.signMessage(messageToSign)\n  return signature\n}\n\nconst verifyNftSignature = async (nft, authorAddress) => {\n  const chainProvider = getChainProvider(nft.chainTicker)\n  const nftContract = new ethers.Contract(nft.address, nftAbi, chainProvider)\n  // get the owner of the nft at nft.id\n  const currentNftOwnerAddress = await nftContract.ownerOf(nft.id)\n  let messageThatShouldBeSigned = {}\n  // the property names must be in this order for the signature to match\n  // insert props one at a time otherwise babel/webpack will reorder\n  messageThatShouldBeSigned.domainSeparator = 'plebbit-author-avatar'\n  messageThatShouldBeSigned.authorAddress = authorAddress\n  messageThatShouldBeSigned.timestamp = nft.timestamp\n  messageThatShouldBeSigned.tokenAddress =  nft.address\n  messageThatShouldBeSigned.tokenId = String(nft.id) // must be a type string, not number\n  messageThatShouldBeSigned = JSON.stringify(messageThatShouldBeSigned)\n\n  const signatureAddress = ethers.utils.verifyMessage(messageThatShouldBeSigned, nft.signature)\n  if (currentNftOwnerAddress !== signatureAddress) {\n    throw Error(`invalid nft signature address '${signatureAddress}' does not equal '${currentNftOwnerAddress}'`)\n  }\n}\n\nconst avatarNft = {\n  chainTicker: 'eth',\n  address: '0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d', // the contract address of the nft\n  timestamp: Math.round(Date.now() / 1000),\n  id: 100 // the nft number 100 in the colletion\n}\nconst avatarNft2 = {\n  chainTicker: 'matic',\n  address: '0xf6d8e606c862143556b342149a7fe0558c220375', // the contract address of the nft\n  timestamp: Math.round(Date.now() / 1000),\n  id: 100 // the nft number 100 in the colletion\n}\nconst author = {\n  address: 'some test address...',\n  avatar: avatarNft\n}\n\n;(async () => {\n  // get the image url of an nft\n  const nftImageUrl = await getNftImageUrl(avatarNft)\n  const nftImageUrl2 = await getNftImageUrl(avatarNft2)\n  console.log({nftImageUrl, nftImageUrl2})\n\n  // this is a test private key, usually you get an ethers.js signer from metamask\n  // https://docs.ethers.io/v5/api/signer\n  const testPrivateKey = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n  const ethersJsSigner = new ethers.Wallet(Buffer.from(testPrivateKey, 'hex'))\n\n  // sign an nft\n  const signature = await createNftSignature(avatarNft, author.address, ethersJsSigner)\n  const nftWithSignature = {...avatarNft, signature}\n  console.log({nftWithSignature})\n\n  // verify nft signature\n  try {\n    await verifyNftSignature(nftWithSignature, author.address)\n  }\n  catch (e) {\n    console.log(`nft signature is not verified because our test private key doesn't own a bored ape`)\n  }\n})()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multisub Information in JavaScript\nDESCRIPTION: Fetches a multisub by its address and logs the addresses of its constituent subplebbits. This demonstrates how to interact with multisubscriptions in Plebbit.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst multisubAddress = '12D3KooW...' // or 'john.eth'\nconst multisub = await plebbit.getSubplebbit(multisubAddress)\nconst multisubSubplebbitAddresses = multisub.map(subplebbit => subplebbit.address)\nconsole.log(multisubSubplebbitAddresses)\n```\n\n----------------------------------------\n\nTITLE: Creating Subplebbit Edits in Plebbit.js\nDESCRIPTION: Illustrates how to create and publish a SubplebbitEdit instance for editing a subplebbit remotely, including handling challenges and verifications.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst createSubplebbitEditOptions = {address: 'news.eth', title: 'New title'}\nconst subplebbitEdit = await plebbit.createSubplebbitEdit(createSubplebbitEditOptions)\nsubplebbitEdit.on('challenge', async (challengeMessage, _subplebbitEdit) => {\n  const challengeAnswers = await askUserForChallengeAnswers(challengeMessage.challenges)\n  _subplebbitEdit.publishChallengeAnswers(challengeAnswers)\n})\nsubplebbitEdit.on('challengeverification', console.log)\nawait subplebbitEdit.publish()\n```\n\n----------------------------------------\n\nTITLE: Listing and Starting Subplebbits in Plebbit-js\nDESCRIPTION: Shows how to list all subplebbit addresses and start them using the plebbit-js library. This is only available for Node.js or over RPC.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// start all the subplebbits you own and have stored locally\nconst subplebbitAddresses = await plebbit.listSubplebbits()\nfor (const address of subplebbitAddresses) {\n  const subplebbit = await plebbit.createSubplebbit({address})\n  await subplebbit.start()\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching All Subplebbit Addresses in JavaScript\nDESCRIPTION: This snippet demonstrates how to retrieve all subplebbit addresses using the Plebbit API. It gets the default settings, fetches the 'all' multisub, and extracts the addresses.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/README.md#2025-04-16_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst plebbitDefaults = await plebbit.getDefaults()\nconst allMultisub = await plebbit.getMultisub(plebbitDefaults.multisubAddresses.all)\nconst allSubplebbitAddresses = allMultisub.map(subplebbit => subplebbit.address)\nconsole.log(allSubplebbitAddresses)\n```\n\n----------------------------------------\n\nTITLE: Publication Signature Verification\nDESCRIPTION: Validates the signature of a publication by encoding the message content using cborg and comparing it with the provided signature. Handles multiple message types including comments, votes, and challenges.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating JSON-RPC Request for commentUpdateSubscribe in JSON\nDESCRIPTION: This snippet shows the JSON-RPC request format for subscribing to comment updates using the commentUpdateSubscribe method.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"commentUpdateSubscribe\",\n  \"params\": [\n    \"Qm...\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON-RPC Request for publishComment in JSON\nDESCRIPTION: This snippet illustrates the JSON-RPC request format for publishing a comment using the publishComment method, including challenge answers.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"publishComment\",\n  \"params\": [{\n    \"comment\": {\n      \"title\": \"Hello\",\n      \"content\": \"World\",\n      \"author\": {\"address\": \"john.eth\"},\n      \"signature\": {\n        \"signature\": \"...\",\n        \"publicKey\": \"...\",\n        \"type\": \"ed25519\",\n        \"signedPropertyNames\": [\"title\", \"content\", \"author\"]\n      }\n    },\n    \"challengeAnswers\": [\"some answer\"]\n  }]\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Settings with JSON-RPC\nDESCRIPTION: An example of how to subscribe to settings updates using the settingsSubscribe method. This method takes no parameters and returns a subscription ID.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"settingsSubscribe\",\n  \"params\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Vote and Comment Edit Verification\nDESCRIPTION: Specific verification functions for vote and comment edit messages, building on the publication verification system with type-specific validation.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Challenge Message Verification Functions\nDESCRIPTION: Set of functions for verifying different types of challenge messages including requests, answers, and verifications using publication signature validation.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/verifying-publications.md#2025-04-16_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Type Definitions for Plebbit.js Challenge System\nDESCRIPTION: Defines the type structure for the challenge system, including challenges configuration, verification, request/response formats, and exclusion rules.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/runtime/node/subplebbit/challenges/README.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// list of challenges included with plebbit-js\nPlebbit.challenges = {[challengeName: string]: ChallengeFile}\n\n// new props \nChallengeRequestMessage {\n  encrypted: Encrypted\n  /* ChallengeRequestMessage.encrypted.ciphertext decrypts to JSON {\n    publication: Publication\n    challengeAnswers?: string[] // some challenges might be included in subplebbit.challenges and can be pre-answered\n    challengeCommentCids?: string[] // some challenges could require including comment cids in other subs, like friendly subplebbit karma challenges\n  } */\n}\nSubplebbit {\n  // challenges is public, part of the IPNS record\n  challenges: SubplebbitChallenge[]\n  // settings is private, not part of the IPNS record\n  settings: {\n    challenges: SubplebbitChallengeSettings[]\n  }\n}\n\n// public challenges types\nSubplebbitChallenge { // copy values from private subplebbit.settings and publish to subplebbit.challenges\n  exclude?: Exclude[] // copied from subplebbit.settings.challenges.exclude\n  description?: string // copied from subplebbit.settings.challenges.description\n  challenge?: string // copied from ChallengeFile.challenge\n  type?: // copied from ChallengeFile.type\n}\nSubplebbitChallengeSettings { // the private settings of the challenge (subplebbit.settings.challenges)\n  path?: string // (only if name is undefined) the path to the challenge js file, used to get the props ChallengeFile {optionInputs, type, getChallenge}\n  name?: string // (only if path is undefined) the challengeName from Plebbit.challenges to identify it\n  options?: [optionPropertyName: string]: string // the options to be used to the getChallenge function, all values must be strings for UI ease of use\n  exclude?: Exclude[] // singular because it only has to match 1 exclude, the client must know the exclude setting to configure what challengeCommentCids to send\n  description?: string // describe in the frontend what kind of challenge the user will receive when publishing\n}\nChallengeFile { // the result of the function exported by the challenge file\n  optionInputs?: OptionInput[] // the options inputs fields to display to the user\n  type: 'image/png' | 'text/plain' | 'chain/<chainTicker>'\n  challenge?: string // some challenges can be static and asked before the user publishes, like a password for example\n  description?: string // describe what the challenge does to display in the UI\n  getChallenge: GetChallengeFunction\n}\nGetChallengeFunction {\n  (challenge: SubplebbitChallengeSettings, challengeRequest: ChallengeRequestMessage, challengeIndex: number): Challenge | ChallengeResult\n}\nChallenge { // if the result of a challenge can't be optained by getChallenge(), return a challenge\n  challenge: string // e.g. '2 + 2'\n  verify: async (answer: string): ChallengeResult\n  type: 'image/png' | 'text/plain' | 'chain/<chainTicker>'\n}\nChallengeResult { // if the result of a challenge can be optained by getChallenge, return the result\n  success?: boolean\n  error?: string // the reason why the challenge failed, add it to ChallengeVerificationMessage.errors\n}\nExclude { // all conditions in Exclude are AND, for OR, use another Exclude item in the Exclude array\n  subplebbit?: ExcludeSubplebbit // exclude if author karma (from challengeRequestMessage.challengeCommentCids) in another subplebbit is greater or equal\n  postScore?: number // exclude if author post score is greater or equal\n  postReply?: number // exclude if author reply score is greater or equal\n  firstCommentTimestamp?: number // exclude if author account age is greater or equal than now - firstCommentTimestamp\n  challenges?: number[] // exclude if all challenges with indexes passed, e.g. challenges: [0, 1] excludes if challenges at index 0 AND 1 passed, plural because has to match all\n  publicationType?: ExcludePublicationType // exclude post, reply, vote, etc.\n  role?: string[] // exclude challenge if author.role.role = one of the string, singular because it only has to match 1 role\n  address?: string[] // exclude challenge if author.address = one of the string, singular because it only has to match 1 address\n  rateLimit?: number // exclude if publication per hour is lower than ratelimit\n  rateLimitChallengeSuccess?: boolean // only rate limit if the challengeVerification.challengeSuccess === rateLimitChallengeSuccess\n}\nExcludePublicationType { // singular because it only has to match 1 publication type\n  post?: boolean // exclude challenge if publication is a post\n  reply?: boolean // exclude challenge if publication is a reply\n  vote?: boolean // exclude challenge if publication is a vote\n  commentEdit?: boolean // exclude challenge if publication is a comment edit\n  commentModeration?: boolean // exclude challenge if publication is a comment moderation\n}\nExcludeSubplebbit { // singular because it only has to match 1 subplebbit\n  addresses: string[] // list of subplebbit addresses that can be used to exclude, plural because not a condition field like 'role'\n  maxCommentCids: number // maximum amount of comment cids that will be fetched to check\n  postScore?: number\n  postReply?: number\n  firstCommentTimestamp?: number // exclude if author account age is greater or equal than now - firstCommentTimestamp\n}\nOptionInput {\n  option: string // option property name, e.g. characterCount\n  label: string // option title, e.g. Character Count\n  default: string // option default value, e.g. 10\n  description?: string // e.g. Amount of characters of the captcha\n  placeholder?: string // the value to display if the input field is empty, e.g. 10\n  required?: boolean // the option is required, the challenge will throw without it\n}\n```\n\n----------------------------------------\n\nTITLE: Response from Settings Subscription Request\nDESCRIPTION: The response to a successful settingsSubscribe request, containing the subscription ID that will be used in subsequent notifications.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{ \"jsonrpc\": \"2.0\", \"result\": 23784, \"id\": 1 }\n```\n\n----------------------------------------\n\nTITLE: Response from Subplebbits Subscription Request\nDESCRIPTION: The response to a successful subplebbitsSubscribe request, containing the subscription ID that will be used in subsequent notifications.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{ \"jsonrpc\": \"2.0\", \"result\": 23784, \"id\": 1 }\n```\n\n----------------------------------------\n\nTITLE: Notification Format for Settings Change Events\nDESCRIPTION: The format of notifications sent when subscribed settings change. The notification includes the event type, subscription ID, and the updated settings object.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"settingsNotification\",\n  \"params\": {\n    \"result\": {\n      \"plebbitOptions\": {...},\n      \"challenges\": {\n        \"challenge-name\": {...}\n      }\n    },\n    \"event\": \"settingschange\",\n    \"subscription\": 23784\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests\nDESCRIPTION: Command to run all test suites, including both Node.js and browser environments.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Running Browser Tests\nDESCRIPTION: Command to run tests specifically in browser environment, including shared node-and-browser tests.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:browser\n```\n\n----------------------------------------\n\nTITLE: Illustrating JSON-RPC Response for commentUpdateSubscribe in JSON\nDESCRIPTION: This snippet demonstrates the JSON-RPC response format for a successful subscription to comment updates.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{ \"jsonrpc\": \"2.0\", \"result\": 23784, \"id\": 1 }\n```\n\n----------------------------------------\n\nTITLE: Unsubscribing from Notifications with JSON-RPC\nDESCRIPTION: An example of how to unsubscribe from notifications using the unsubscribe method. This method takes a subscription ID parameter and returns a boolean indicating success.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"unsubscribe\",\n  \"params\": [23784]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Node.js Tests\nDESCRIPTION: Command to run tests specifically in Node.js environment, including shared node-and-browser tests.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:node\n```\n\n----------------------------------------\n\nTITLE: Notification Format for Subplebbits Change Events\nDESCRIPTION: The format of notifications sent when subscribed subplebbits change. The notification includes the event type, subscription ID, and a list of the current subplebbits.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subplebbitsNotification\",\n  \"params\": {\n    \"result\": [\n      \"memes.eth\", \n      \"news.eth\"\n    ],\n    \"event\": \"subplebbitschange\",\n    \"subscription\": 23784\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Project\nDESCRIPTION: Command to build the complete project for production use.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Starting Test Server with IPFS Node\nDESCRIPTION: Command to start the test server that includes an IPFS node and test subplebbits for running integration tests.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:server\n```\n\n----------------------------------------\n\nTITLE: Compiling Browser Tests with Webpack\nDESCRIPTION: Command to compile browser tests using webpack in watch mode for continuous development.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run webpack:watch\n```\n\n----------------------------------------\n\nTITLE: Running All Build Scripts Simultaneously\nDESCRIPTION: Optional script to run all the build and watch scripts simultaneously for development efficiency.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nscripts/build-watch-all\n```\n\n----------------------------------------\n\nTITLE: Compiling TypeScript in Watch Mode\nDESCRIPTION: Command to compile TypeScript files and watch for changes during development.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build:watch\n```\n\n----------------------------------------\n\nTITLE: Creating Environment File for Tests\nDESCRIPTION: Instructions for creating a .env file with Chrome binary path configuration for browser tests.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nCHROME_BIN=/usr/bin/chromium\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for plebbit-js\nDESCRIPTION: Command to install all necessary npm dependencies for the plebbit-js project.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/docs/testing.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Response from Unsubscribe Request\nDESCRIPTION: The response to a successful unsubscribe request, confirming that the subscription has been canceled.\nSOURCE: https://github.com/plebbit/plebbit-js/blob/master/src/rpc/README.md#2025-04-16_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{ \"jsonrpc\": \"2.0\", \"result\": true, \"id\": 1 }\n```"
  }
]