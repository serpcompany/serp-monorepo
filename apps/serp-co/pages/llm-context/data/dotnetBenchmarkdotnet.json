[
  {
    "owner": "dotnet",
    "repo": "benchmarkdotnet",
    "content": "TITLE: Designing a Benchmark in C# with BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates how to create a benchmark class comparing MD5 and SHA256 hash functions using BenchmarkDotNet attributes and runner.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing System.Security.Cryptography;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\nnamespace MyBenchmarks\n{\n    public class Md5VsSha256\n    {\n        private const int N = 10000;\n        private readonly byte[] data;\n\n        private readonly SHA256 sha256 = SHA256.Create();\n        private readonly MD5 md5 = MD5.Create();\n\n        public Md5VsSha256()\n        {\n            data = new byte[N];\n            new Random(42).NextBytes(data);\n        }\n\n        [Benchmark]\n        public byte[] Sha256() => sha256.ComputeHash(data);\n\n        [Benchmark]\n        public byte[] Md5() => md5.ComputeHash(data);\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var summary = BenchmarkRunner.Run(typeof(Program).Assembly);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Benchmark Execution Pseudocode\nDESCRIPTION: Comprehensive pseudocode that explains how BenchmarkDotNet orchestrates benchmark runs, including project generation, execution across multiple launches, and results collection.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nIEnumerable<Results> Run(Benchmark benchmark)\n{\n    var toolchain = benchmark.GetToolchain();\n\n    var autoGeneratedProject = toolchain.Generate(benchmark);\n    var exe = toolchain.Build(autoGeneratedProject);\n\n    foreach (var runIndex in LaunchCount) // LaunchCount = 1 by default\n        yield return ParseResults(Process.Start(exe).Output); // calls ActualRun in a separate process\n}\n```\n\n----------------------------------------\n\nTITLE: Installing BenchmarkDotNet via NuGet in .NET\nDESCRIPTION: Command to add the BenchmarkDotNet package to a .NET project using the dotnet CLI.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/getting-started.md#2025-04-22_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\n> dotnet add package BenchmarkDotNet\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmarks for MD5 vs SHA256 in C#\nDESCRIPTION: C# code demonstrating how to create a benchmark class comparing MD5 and SHA256 hash functions using BenchmarkDotNet attributes and runner.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/getting-started.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Security.Cryptography;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\nnamespace MyBenchmarks\n{\n    public class Md5VsSha256\n    {\n        private const int N = 10000;\n        private readonly byte[] data;\n\n        private readonly SHA256 sha256 = SHA256.Create();\n        private readonly MD5 md5 = MD5.Create();\n\n        public Md5VsSha256()\n        {\n            data = new byte[N];\n            new Random(42).NextBytes(data);\n        }\n\n        [Benchmark]\n        public byte[] Sha256() => sha256.ComputeHash(data);\n\n        [Benchmark]\n        public byte[] Md5() => md5.ComputeHash(data);\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var summary = BenchmarkRunner.Run<Md5VsSha256>();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setup and Cleanup Methods in BenchmarkDotNet using C#\nDESCRIPTION: This C# code snippet demonstrates the use of [GlobalSetup] and [GlobalCleanup] attributes in BenchmarkDotNet. The [GlobalSetup] attribute is used to execute a method once before any benchmark executions, ideal for initializing resources, while the [GlobalCleanup] method is used to clean up resources afterward. These methods help manage resources efficiently during benchmarking tasks. Ensure BenchmarkDotNet library is included in your project dependencies.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroSetupCleanupGlobal.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[`[GlobalSetup]`](xref:BenchmarkDotNet.Attributes.GlobalSetupAttribute)\n  // This method executes once before the benchmarks\n\n[`[GlobalCleanup]`](xref:BenchmarkDotNet.Attributes.GlobalCleanupAttribute)\n  // This method executes once after the benchmarks\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Array Search Methods in C#\nDESCRIPTION: Compares the performance of Array.IndexOf against a manual array search implementation with various array sizes and search values. The benchmark uses parameterized arrays and values, demonstrating BenchmarkDotNet's capability to handle array parameters without including allocation costs in the measurements.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArrayParam.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroArrayParam.cs](../../../samples/BenchmarkDotNet.Samples/IntroArrayParam.cs)]\n```\n\n----------------------------------------\n\nTITLE: Running BenchmarkDotNet Benchmarks in Release Mode\nDESCRIPTION: Command to run the benchmark application in Release configuration using the dotnet CLI.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/getting-started.md#2025-04-22_snippet_2\n\nLANGUAGE: cmd\nCODE:\n```\n> dotnet run -c Release\n```\n\n----------------------------------------\n\nTITLE: Using Baseline and Params in C# with BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates how to use the Baseline attribute for relative comparison and the Params attribute for parameterized benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Sleeps\n{\n    [Benchmark]\n    public void Time50() => Thread.Sleep(50);\n\n    [Benchmark(Baseline = true)]\n    public void Time100() => Thread.Sleep(100);\n\n    [Benchmark]\n    public void Time150() => Thread.Sleep(150);\n}\n\npublic class IntroParams\n{\n    [Params(100, 200)]\n    public int A { get; set; }\n\n    [Params(10, 20)]\n    public int B { get; set; }\n\n    [Benchmark]\n    public void Benchmark()\n    {\n        Thread.Sleep(A + B + 5);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom EventPipeProfiler in BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to set up a custom EventPipeProfiler with specific providers and configurations in BenchmarkDotNet. It includes various examples of provider configurations and shows how to use them with benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroEventPipeProfilerAdvanced.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[EventPipeProfilerAdvanced.cs](../../../samples/BenchmarkDotNet.Samples/IntroEventPipeProfilerAdvanced.cs)]\n```\n\n----------------------------------------\n\nTITLE: Implementing EventPipeProfiler in C#\nDESCRIPTION: This code snippet demonstrates how to use the EventPipeProfiler attribute with different profiling options in a BenchmarkDotNet benchmark class. It includes methods for CPU sampling, GC verbose tracking, GC collection tracking, and JIT compilation logging.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroEventPipeProfiler.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[EventPipeProfiler(EventPipeProfile.CpuSampling)]\npublic class IntroEventPipeProfiler\n{\n    [Benchmark]\n    public void Sleep() => Thread.Sleep(100);\n\n    [Benchmark]\n    [EventPipeProfiler(EventPipeProfile.GcVerbose)]\n    public void AllocateArrays()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            var array = new byte[i * 100];\n        }\n    }\n\n    [Benchmark]\n    [EventPipeProfiler(EventPipeProfile.GcCollect)]\n    public void AllocateArraysAndCollect()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            var array = new byte[i * 100];\n        }\n        GC.Collect();\n    }\n\n    [Benchmark]\n    [EventPipeProfiler(EventPipeProfile.Jit)]\n    public void CallMethods()\n    {\n        MethodA();\n        MethodB();\n        MethodC();\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodA() { }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodB() { }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodC() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Jobs for Multiple Runtimes in C#\nDESCRIPTION: This snippet shows how to configure a benchmark to run on multiple .NET runtimes using SimpleJob attributes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[SimpleJob(RuntimeMoniker.Net481)]\n[SimpleJob(RuntimeMoniker.Net70)]\n[SimpleJob(RuntimeMoniker.NativeAot70)]\n[SimpleJob(RuntimeMoniker.Mono)]\npublic class Md5VsSha256\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with BenchmarkRunner in C#\nDESCRIPTION: Demonstrates how to run benchmarks for a specific class using BenchmarkRunner. This approach runs all benchmarks in the given type or assembly and is ideal for a quick start with few benchmark types.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-to-run.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar summary = BenchmarkRunner.Run<MyBenchmarkClass>();\nvar summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass));\n```\n\n----------------------------------------\n\nTITLE: Configuring Diagnosers with ManualConfig in C#\nDESCRIPTION: A sample configuration class that shows how to add various diagnosers to a benchmark using the ManualConfig approach. This demonstrates how to configure memory, inlining, ETW profiling, and threading diagnosers.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/diagnosers.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nprivate class Config : ManualConfig\n{\n    public Config()\n    {\n        AddDiagnoser(MemoryDiagnoser.Default);\n        AddDiagnoser(new InliningDiagnoser());\n        AddDiagnoser(new EtwProfiler());\n        AddDiagnoser(ThreadingDiagnoser.Default);\n        AddDiagnoser(ExceptionDiagnoser.Default);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rank Columns in BenchmarkDotNet (C#)\nDESCRIPTION: This code snippet demonstrates how to set up a benchmark with rank columns in BenchmarkDotNet. It defines two methods, Foo and Bar, each with a Factor parameter, and uses attributes to configure the benchmark and rank columns.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRankColumn.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(RuntimeMoniker.Net462, baseline: true)]\n[RankColumn, RankColumn(NumeralSystem.Roman), RankColumn(\"Rank\", NumeralSystem.Stars)]\n[MemoryDiagnoser]\npublic class IntroRankColumn\n{\n    [Params(1, 2)]\n    public int Factor { get; set; }\n\n    [Benchmark(Baseline = true)]\n    public void Foo() => Thread.Sleep(Factor * 100);\n\n    [Benchmark]\n    public void Bar() => Thread.Sleep(Factor * 200);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmarks with BenchmarkDotNet in C#\nDESCRIPTION: Example benchmark class that compares the performance of SHA256 and MD5 hash algorithms across different .NET runtimes. The benchmark is parameterized with different data sizes and includes proper setup method and measurement methods.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[SimpleJob(RuntimeMoniker.Net472, baseline: true)]\n[SimpleJob(RuntimeMoniker.NetCoreApp30)]\n[SimpleJob(RuntimeMoniker.NativeAot70)]\n[SimpleJob(RuntimeMoniker.Mono)]\n[RPlotExporter]\npublic class Md5VsSha256\n{\n    private SHA256 sha256 = SHA256.Create();\n    private MD5 md5 = MD5.Create();\n    private byte[] data;\n\n    [Params(1000, 10000)]\n    public int N;\n\n    [GlobalSetup]\n    public void Setup()\n    {\n        data = new byte[N];\n        new Random(42).NextBytes(data);\n    }\n\n    [Benchmark]\n    public byte[] Sha256() => sha256.ComputeHash(data);\n\n    [Benchmark]\n    public byte[] Md5() => md5.ComputeHash(data);\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Validator References\nDESCRIPTION: List of available validators in BenchmarkDotNet including BaselineValidator, JitOptimizationsValidator, ExecutionValidator, and ReturnValueValidator. Each validator serves a specific validation purpose before benchmark execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/validators.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `BaselineValidator.FailOnError` - it checks if more than 1 Benchmark per class has `Baseline = true` applied. This validator is mandatory.\n* `JitOptimizationsValidator.(Dont)FailOnError` - it checks whether any of the referenced assemblies is non-optimized. `DontFailOnError` version is enabled by default.\n* `ExecutionValidator.(Dont)FailOnError` - it checks if it is possible to run your benchmarks by executing each of them once. Optional.\n* `ReturnValueValidator.(Dont)FailOnError` - it checks if non-void benchmarks return equal values. Optional.\n```\n\n----------------------------------------\n\nTITLE: Adding Columns and Exporters in C# with BenchmarkDotNet\nDESCRIPTION: This snippet shows how to add additional columns to the benchmark results and specify multiple exporters for output.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[MinColumn, MaxColumn]\n[MarkdownExporter, AsciiDocExporter, HtmlExporter, CsvExporter, RPlotExporter]\npublic class Md5VsSha256\n```\n\n----------------------------------------\n\nTITLE: Using SimpleJobAttribute for Multiple Runtimes in C#\nDESCRIPTION: Demonstrates how to use SimpleJobAttribute to specify multiple runtimes for benchmarking.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Jobs;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [SimpleJob(RuntimeMoniker.Net48)]\n    [SimpleJob(RuntimeMoniker.Mono)]\n    [SimpleJob(RuntimeMoniker.NetCoreApp31)]\n    [SimpleJob(RuntimeMoniker.Net80)]\n    public class TheClassWithBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Using Object-style Configuration in C#\nDESCRIPTION: This snippet demonstrates how to configure BenchmarkDotNet benchmarks using the object-style approach with a custom Config class. It shows how to add various components like jobs, columns, exporters, loggers, diagnosers, analysers, validators, hardware counters, filters, and logical group rules to customize benchmark execution and reporting.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/configs.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Config(typeof(Config))]\npublic class MyClassWithBenchmarks\n{\n    private class Config : ManualConfig\n    {\n        public Config()\n        {\n            AddJob(new Job1(), new Job2());\n            AddColumn(new Column1(), new Column2());\n            AddColumnProvider(new ColumnProvider1(), new ColumnProvider2());\n            AddExporter(new Exporter1(), new Exporter2());\n            AddLogger(new Logger1(), new Logger2());\n            AddDiagnoser(new Diagnoser1(), new Diagnoser2());\n            AddAnalyser(new Analyser1(), new Analyser2());\n            AddValidator(new Validator2(),new Validator2());\n            AddHardwareCounters(HardwareCounter enum1, HardwareCounter enum2);\n            AddFilter(new Filter1(), new Filter2());\n            AddLogicalGroupRules(BenchmarkLogicalGroupRule enum1, BenchmarkLogicalGroupRule enum2);\n        }\n    }\n    \n    [Benchmark]\n    public void Benchmark1()\n    {\n    }\n    \n    [Benchmark]\n    public void Benchmark2()\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Multiple Runtimes with Baseline Configuration in BenchmarkDotNet\nDESCRIPTION: Example code showing how to configure BenchmarkDotNet to run the same benchmark across multiple .NET runtimes (CLR, Core, Mono) with CLR marked as the baseline for comparison ratios.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJobBaseline.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroJobBaseline.cs](../../../samples/BenchmarkDotNet.Samples/IntroJobBaseline.cs)]\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Using Fluent Style Configuration\nDESCRIPTION: Shows how to configure BenchmarkDotNet options using a fluent-style configuration approach directly in the Run method. Demonstrates using both individual and combined configuration options using the WithOptions() method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/configoptions.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Run()\n{\n    BenchmarkRunner\n        .Run<Benchmarks>(\n            ManualConfig\n                .Create(DefaultConfig.Instance)\n                .WithOptions(ConfigOptions.JoinSummary)\n                .WithOptions(ConfigOptions.DisableLogFile)\n                // or\n                .WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile));\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Benchmarks with Fluent Interface in C#\nDESCRIPTION: This snippet demonstrates how to use the fluent interface of BenchmarkDotNet to configure benchmarks. It sets up a custom config with specific job, column, and exporters without creating a new Config type.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroFluentConfigBuilder.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Exporters;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Running;\n\nnamespace BenchmarkDotNet.Samples\n{\n    public class IntroFluentConfigBuilder\n    {\n        private int[] items;\n\n        [Params(100, 200)]\n        public int Count { get; set; }\n\n        [GlobalSetup]\n        public void Setup()\n        {\n            items = new int[Count];\n            for (int i = 0; i < Count; ++i)\n                items[i] = i;\n        }\n\n        [Benchmark]\n        public int Sum()\n        {\n            int sum = 0;\n            for (int i = 0; i < Count; ++i)\n                sum += items[i];\n            return sum;\n        }\n\n        public static void Main(string[] args)\n        {\n            var config = DefaultConfig.Instance\n                .AddJob(Job.Dry)\n                .AddExporter(RPlotExporter.Default)\n                .AddColumn(StatisticColumn.OperationsPerSecond);\n\n            BenchmarkRunner.Run<IntroFluentConfigBuilder>(config);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Dead Code Elimination in C# Benchmarks\nDESCRIPTION: Improved version of the benchmark code that prevents JIT optimization by returning the calculated value, ensuring the computation is actually performed during benchmarking.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/good-practices.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ndouble Foo()\n{\n    return Math.Exp(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Using Object Style Configuration\nDESCRIPTION: Demonstrates how to configure BenchmarkDotNet options using an object-style configuration approach by creating a custom Config class that inherits from ManualConfig. Shows two methods of applying multiple configuration options using WithOptions().\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/configoptions.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Config : ManualConfig\n{\n    public Config()\n    {\n        // Using the WithOptions() factory method:\n        this.WithOptions(ConfigOptions.JoinSummary)\n            .WithOptions(ConfigOptions.DisableLogFile);\n        \n        // Or (The ConfigOptions Enum is defined as a BitField)\n        this.WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile);\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Configuration for Multiple Runtime Benchmarks\nDESCRIPTION: C# code showing how to create a custom configuration to benchmark across multiple .NET runtimes using fluent configuration API.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Environments;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Running;\n\nnamespace BenchmarkDotNet.Samples\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var config = DefaultConfig.Instance\n                .With(Job.Default.With(CoreRuntime.Core21))\n                .With(Job.Default.With(CoreRuntime.Core30))\n                .With(Job.Default.With(ClrRuntime.Net48))\n                .With(Job.Default.With(MonoRuntime.Default));\n\n            BenchmarkSwitcher\n                .FromAssembly(typeof(Program).Assembly)\n                .Run(args, config);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Custom .NET Runtime Build in C#\nDESCRIPTION: Shows how to benchmark a private build of .NET Runtime using a custom ClrRuntime configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\nBenchmarkSwitcher\n    .FromAssembly(typeof(Program).Assembly)\n    .Run(args, \n        DefaultConfig.Instance.AddJob(\n            Job.ShortRun.WithRuntime(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: \"4.0\"))));\n```\n\n----------------------------------------\n\nTITLE: XML Configuration for Disassembly Diagnoser\nDESCRIPTION: Required XML project configuration to enable proper C#/F# code correlation in the Disassembly Diagnoser output. This configuration ensures debug symbols are generated correctly.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/diagnosers.md#2025-04-22_snippet_2\n\nLANGUAGE: XML\nCODE:\n```\n<DebugType>pdbonly</DebugType>\n<DebugSymbols>true</DebugSymbols>\n```\n\n----------------------------------------\n\nTITLE: Using --join with BenchmarkSwitcher in C#\nDESCRIPTION: Code sample demonstrating how to use the join feature to combine benchmark results from different types. The sample shows two classes with benchmark methods sharing the same category.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJoin.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroJoin.cs](../../../samples/BenchmarkDotNet.Samples/IntroJoin.cs)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Jobs with Attributes in BenchmarkDotNet\nDESCRIPTION: This code demonstrates how to configure multiple benchmark jobs using various attribute styles. Each attribute creates a separate job configuration, resulting in multiple benchmark runs.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/jobs.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[DryJob]\n[MonoJob]\n[SimpleJob(RuntimeMoniker.Net90)]\n[SimpleJob(RuntimeMoniker.NetCoreApp31)]\n[LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job]\n[SimpleJob(RunStrategy.ColdStart, launchCount: 1, warmupCount: 5, iterationCount: 5, id: \"FastAndDirtyJob\")]\npublic class MyBenchmarkClass\n```\n\n----------------------------------------\n\nTITLE: Using BenchmarkSwitcher to Run Configurable Benchmarks in C#\nDESCRIPTION: Shows how to use BenchmarkSwitcher to select which benchmarks to run using command line arguments. This approach is more flexible for projects with multiple benchmark types.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-to-run.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\n```\n\n----------------------------------------\n\nTITLE: Writing Benchmarks in VB with BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates how to write benchmarks using Visual Basic syntax, including parameterization.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_6\n\nLANGUAGE: VB\nCODE:\n```\nPublic Class Sample\n    <Params(1, 2)>\n    Public Property A As Integer\n    <Params(3, 4)>\n    Public Property B As Integer\n\n    <Benchmark>\n    Public Function Benchmark() As Integer\n            return A + B\n    End Function\nEnd Class\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmark Arguments in C# with BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to use the [Arguments] attribute to specify benchmark parameters in BenchmarkDotNet. It includes a benchmark method that takes multiple arguments and showcases different ways to provide argument values.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArguments.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[DryJob]\npublic class IntroArguments\n{\n    [Benchmark]\n    [Arguments(100, 10)]\n    [Arguments(100, 20)]\n    [Arguments(200, 10, false)]\n    [Arguments(200, 20, false)]\n    public void Benchmark(int a, int b, bool addExtra5Miliseconds = true)\n    {\n        Thread.Sleep(a + b);\n        if (addExtra5Miliseconds)\n            Thread.Sleep(5);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom TagColumn in BenchmarkDotNet\nDESCRIPTION: This code snippet shows the implementation of TagColumn, a custom column type in BenchmarkDotNet. It demonstrates how to create a column that displays a tag value from benchmark objects, with support for left alignment and optional clearing of default style.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/columns.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Text;\n\nnamespace BenchmarkDotNet.Columns\n{\n    public class TagColumn : IColumn\n    {\n        private string tag;\n        private UnitType unitType;\n        private bool isLeftAligned;\n        private bool hasClearDefaultStyle;\n\n        public TagColumn(string tag, UnitType unitType = UnitType.Dimensionless, bool isLeftAligned = false, bool hasClearDefaultStyle = false)\n        {\n            this.tag = tag;\n            this.unitType = unitType;\n            this.isLeftAligned = isLeftAligned;\n            this.hasClearDefaultStyle = hasClearDefaultStyle;\n        }\n\n        public string Id => nameof(TagColumn) + \"_\" + tag;\n        public string ColumnName => tag;\n        public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) => false;\n        public string GetValue(Summary summary, BenchmarkCase benchmarkCase) => tag;\n        public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => tag;\n        public bool IsAvailable(Summary summary) => true;\n        public bool AlwaysShow => true;\n        public ColumnCategory Category => ColumnCategory.Custom;\n        public int PriorityInCategory => 0;\n        public bool IsNumeric => false;\n        public UnitType UnitType => unitType;\n        public string Legend => $\"Custom '{tag}' tag\";\n        public override string ToString() => ColumnName;\n        public bool IsLeftAligned => isLeftAligned;\n        public string Id => nameof(TagColumn) + \"_\" + tag;\n        public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => GetValue(summary, benchmarkCase);\n        public bool HasClearDefaultStyle => hasClearDefaultStyle;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RPlotExporter and CsvMeasurementsExporter in F#\nDESCRIPTION: This snippet shows how to set up a custom Config module in F# to use CsvMeasurementsExporter and RPlotExporter for generating plots of benchmark results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/exporters.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nmodule MyBenchmark\n\nopen BenchmarkDotNet.Attributes\nopen BenchmarkDotNet.Configs\nopen BenchmarkDotNet.Exporters\nopen BenchmarkDotNet.Exporters.Csv\nopen MyProjectUnderTest\n\ntype MyConfig() as this =\n    inherit ManualConfig()\n    do\n        this.Add(CsvMeasurementsExporter.Default)\n        this.Add(RPlotExporter.Default)\n\n[\n  MemoryDiagnoser; \n  Config(typeof<MyConfig>);\n  RPlotExporter\n]\ntype MyPerformanceTests() =\n\n    let someTestData = getTestDataAsList ()\n\n    [<Benchmark>]\n    member __.SomeTestCase() = \n        someTestData |> myFunctionUnderTest\n```\n\n----------------------------------------\n\nTITLE: Configuring CSV Exporter with Custom Summary Style in C#\nDESCRIPTION: This snippet demonstrates how to configure a CSV exporter with custom settings for units and formatting in C#. It sets up the exporter to use microseconds and kilobytes, and to display units only in column headers.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/exporters.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar exporter = new CsvExporter(\n    CsvSeparator.CurrentCulture,\n    new SummaryStyle(\n        cultureInfo: System.Globalization.CultureInfo.CurrentCulture,\n        printUnitsInHeader: true,\n        printUnitsInContent: false,\n        timeUnit: Perfolizer.Horology.TimeUnit.Microsecond,\n        sizeUnit: SizeUnit.KB\n    ));\n\nvar config = ManualConfig.CreateMinimumViable().AddExporter(exporter);\n```\n\n----------------------------------------\n\nTITLE: Enabling EtwProfiler with Attribute in C#\nDESCRIPTION: C# code snippet demonstrating how to enable the EtwProfiler by applying the EtwProfiler attribute to a class containing benchmarks. This is the simplest way to enable ETW profiling for all benchmarks in a class.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/etwprofiler.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Diagnostics.Windows.Configs;\n\n[EtwProfiler]\npublic class TheClassThatContainsBenchmarks { /* benchmarks go here */ }\n```\n\n----------------------------------------\n\nTITLE: Using Order Attributes with BenchmarkDotNet in C#\nDESCRIPTION: This code demonstrates how to use the [Orderer] attribute and implement IOrderer to control the execution sequence of benchmarks in BenchmarkDotNet. It includes examples of custom benchmark ordering with alphabetical and custom ordering strategies.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroOrderAttr.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroOrderAttr.cs](../../../samples/BenchmarkDotNet.Samples/IntroOrderAttr.cs)]\n```\n\n----------------------------------------\n\nTITLE: Using ArgumentsSource with Primitive Types in BenchmarkDotNet\nDESCRIPTION: Example of implementing the ArgumentsSource attribute with primitive numeric types. The benchmark method 'Pow' receives values from a custom source method 'ValuesForX' that returns an IEnumerable of integer pairs.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsSource.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroArgumentsSource.cs](../../../samples/BenchmarkDotNet.Samples/IntroArgumentsSource.cs)]\n```\n\n----------------------------------------\n\nTITLE: Applying Diagnoser Attributes in C#\nDESCRIPTION: Shows how to add diagnosers using class-level attributes in BenchmarkDotNet. These attributes can be applied to a class containing benchmark methods to enable specific diagnostics during execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/diagnosers.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[MemoryDiagnoser]\n[InliningDiagnoser]\n[TailCallDiagnoser]\n[EtwProfiler]\n[ConcurrencyVisualizerProfiler]\n[NativeMemoryProfiler]\n[ThreadingDiagnoser]\n[ExceptionDiagnoser]\n```\n\n----------------------------------------\n\nTITLE: Configuring EventPipeProfiler with Attribute in C#\nDESCRIPTION: Example of enabling EventPipeProfiler by applying the EventPipeProfiler attribute to a benchmark class. This simple configuration uses default settings for the profiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/event-pipe-profiler.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[EventPipeProfiler(enabled: true)]\npublic class IntroEventPipeProfiler\n{\n    [Benchmark]\n    public void Benchmark()\n    {\n        // Code to be benchmarked\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmark with CPU Usage Profiling in C#\nDESCRIPTION: Example of implementing a benchmark that compares MD5 and SHA256 hashing performance with CPU usage profiling enabled. The code demonstrates how to set up a benchmark class with the CPUUsageDiagnoser attribute and includes hash computation for both algorithms.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/vsprofiler.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Security.Cryptography;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\nusing Microsoft.VSDiagnostics;\n\nnamespace MyBenchmarks\n{\n    [CPUUsageDiagnoser]\n    public class Md5VsSha256\n    {\n        private const int N = 10000;\n        private readonly byte[] data;\n\n        private readonly SHA256 sha256 = SHA256.Create();\n        private readonly MD5 md5 = MD5.Create();\n\n        public Md5VsSha256()\n        {\n            data = new byte[N];\n            new Random(42).NextBytes(data);\n        }\n\n        [Benchmark]\n        public byte[] Sha256() => sha256.ComputeHash(data);\n\n        [Benchmark]\n        public byte[] Md5() => md5.ComputeHash(data);\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var summary = BenchmarkRunner.Run(typeof(Program).Assembly);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NativeMemoryProfiler in C# Benchmarks\nDESCRIPTION: Example of using NativeMemoryProfiler to measure native memory traffic in benchmarks. It adds 'Allocated native memory' and 'Native memory leak' columns to the summary table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[ShortRunJob]\n[NativeMemoryProfiler]\n[MemoryDiagnoser]\npublic class IntroNativeMemory\n{\n    [Benchmark]\n    public void BitmapWithLeaks()\n    {\n        var flag = new Bitmap(200, 100);\n        var graphics = Graphics.FromImage(flag);\n        var blackPen = new Pen(Color.Black, 3);\n        graphics.DrawLine(blackPen, 100, 100, 500, 100);\n    }\n\n    [Benchmark]\n    public void Bitmap()\n    {\n        using (var flag = new Bitmap(200, 100))\n        {\n            using (var graphics = Graphics.FromImage(flag))\n            {\n                using (var blackPen = new Pen(Color.Black, 3))\n                {\n                    graphics.DrawLine(blackPen, 100, 100, 500, 100);\n                }\n            }\n        }\n    }\n\n    private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks.\n    private int ArraySize = Size * Marshal.SizeOf(typeof(int));\n\n    [Benchmark]\n    public unsafe void AllocHGlobal()\n    {\n        IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize);\n        Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize);\n        Marshal.FreeHGlobal(unmanagedHandle);\n    }\n\n    [Benchmark]\n    public unsafe void AllocHGlobalWithLeaks()\n    {\n        IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize);\n        Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Job Configurations with Attributes in BenchmarkDotNet\nDESCRIPTION: This example shows how to merge job configurations using attributes. The GcServer attribute is applied to both the ClrJob and CoreJob, resulting in two jobs with the GcServer=true setting.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/jobs.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[ClrJob, CoreJob]\n[GcServer(true)]\npublic class MyBenchmarkClass\n```\n\n----------------------------------------\n\nTITLE: Customizing Mono Runtime Arguments for Benchmarking in C#\nDESCRIPTION: This code demonstrates how to use BenchmarkDotNet to run the same benchmark with different Mono runtime arguments. It compares method performance with inlining enabled and disabled through custom job configurations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCustomMonoArguments.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroCustomMonoArguments.cs](../../../samples/BenchmarkDotNet.Samples/IntroCustomMonoArguments.cs)]\n```\n\n----------------------------------------\n\nTITLE: Benchmark Output for Primitive Types Example in BenchmarkDotNet\nDESCRIPTION: Example output from running the benchmark with primitive numeric types. Shows how the ArgumentsSource provides multiple value pairs to the benchmark method and how the results are displayed in a table format.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsSource.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Method |  x |  y |      Mean |     Error |    StdDev |\n|------- |--- |--- |----------:|----------:|----------:|\n|    Pow |  1 |  1 |  9.360 ns | 0.0190 ns | 0.0149 ns |\n|    Pow |  2 |  2 | 40.624 ns | 0.3413 ns | 0.3192 ns |\n|    Pow |  4 |  4 | 40.537 ns | 0.0560 ns | 0.0524 ns |\n|    Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns |\n```\n\n----------------------------------------\n\nTITLE: Fluent Configuration API in BenchmarkDotNet\nDESCRIPTION: Example of using BenchmarkDotNet's fluent API to configure benchmarks programmatically instead of using attributes. This approach allows for creating custom configurations with multiple jobs, specifying runtime environments, and controlling benchmark execution parameters.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nManualConfig.CreateEmpty() // A configuration for our benchmarks\n    .AddJob(Job.Default // Adding first job\n        .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2\n        .WithPlatform(Platform.X64) // Run as x64 application\n        .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT\n        .WithGcServer(true) // Use Server GC\n    ).AddJob(Job.Default // Adding second job\n        .AsBaseline() // It will be marked as baseline\n        .WithEnvironmentVariable(\"Key\", \"Value\") // Setting an environment variable\n        .WithWarmupCount(0) // Disable warm-up stage\n    );\n```\n\n----------------------------------------\n\nTITLE: Comparing NuGet Package Versions with BenchmarkDotNet in C#\nDESCRIPTION: This code demonstrates how to use BenchmarkDotNet to compare the performance of different versions of Newtonsoft.Json for serializing an anonymous object. It sets up multiple jobs with different NuGet package versions and measures their execution time.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroNuGet.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Toolchains.InProcess.NoEmit;\nusing Newtonsoft.Json;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [Config(typeof(Config))]\n    public class IntroNuGet\n    {\n        private class Config : ManualConfig\n        {\n            public Config()\n            {\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\"));\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\"));\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\"));\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\"));\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\"));\n                Add(Job.Default.WithToolchain(InProcessNoEmitToolchain.Instance)\n                    .WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\"));\n            }\n        }\n\n        [Benchmark]\n        public string SerializeAnonymousObject()\n            => JsonConvert.SerializeObject(new { Value = 42, Text = \"abc\" });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results for Array Search Operations\nDESCRIPTION: Shows the benchmark results comparing Array.IndexOf with ManualIndexOf across different array sizes (3 and 100 elements) and search values (found at index 4 or not found at index 101). The results include execution time and memory allocation metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArrayParam.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|        Method |      array | value |      Mean |     Error |    StdDev | Allocated |\n|-------------- |----------- |------ |----------:|----------:|----------:|----------:|\n|  ArrayIndexOf | Array[100] |     4 | 15.558 ns | 0.0638 ns | 0.0597 ns |       0 B |\n| ManualIndexOf | Array[100] |     4 |  5.345 ns | 0.0668 ns | 0.0625 ns |       0 B |\n|  ArrayIndexOf |   Array[3] |     4 | 14.334 ns | 0.1758 ns | 0.1558 ns |       0 B |\n| ManualIndexOf |   Array[3] |     4 |  2.758 ns | 0.0905 ns | 0.1208 ns |       0 B |\n|  ArrayIndexOf | Array[100] |   101 | 78.359 ns | 1.8853 ns | 2.0955 ns |       0 B |\n| ManualIndexOf | Array[100] |   101 | 80.421 ns | 0.6391 ns | 0.5978 ns |       0 B |\n```\n\n----------------------------------------\n\nTITLE: Benchmarking LINQ Queries with Deferred Execution\nDESCRIPTION: This code snippet demonstrates how to properly benchmark LINQ queries that use deferred execution. It shows the correct way to use the Consumer class and the Consume extension method to ensure the query is actually executed during the benchmark.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDeferredExecution.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroDeferredExecution.cs](../../../samples/BenchmarkDotNet.Samples/IntroDeferredExecution.cs)]\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Workload Measurement Implementation\nDESCRIPTION: Pseudocode illustrating how BenchmarkDotNet collects actual measurements, filtering out outliers and continuing until workload requirements are met.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nIEnuberable<Measurement> Workload(Method method, long invokeCount, int unrollFactor)\n{\n    while (true)\n    {\n        var measurement = RunIteration(method, invokeCount, unrollFactor);\n\n        if (measurement.IsNotOutlier)\n            yield return measurement;\n\n        if (heuristic.IsWorkloadRequirementMet(measurement))\n            yield break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TailcallDiagnoser in BenchmarkDotNet\nDESCRIPTION: Configuration options for the TailcallDiagnoser attribute which tracks JIT tail call events. Options include logFailuresOnly (to track only methods that failed to get tail called) and filterByNamespace (to limit tracking to methods from the declaring type's namespace).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroTailcall.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nTailcallDiagnoser attribute\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkSwitcher in C#\nDESCRIPTION: Shows how to set up BenchmarkSwitcher to use command-line arguments for runtime selection.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args) \n        => BenchmarkSwitcher\n            .FromAssembly(typeof(Program).Assembly)\n            .Run(args); // crucial to make it work\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing BenchmarkSwitcher with Console Arguments in C#\nDESCRIPTION: This snippet demonstrates how to set up a Program class to run benchmarks using BenchmarkSwitcher, passing command-line arguments to allow for customization of benchmark execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/console-args.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args) \n        => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Command-line Arguments Support to BenchmarkRunner (C#)\nDESCRIPTION: Shows how to enable command-line argument handling in BenchmarkRunner. This allows passing configuration options directly through command line arguments when running benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Program\n{\n    public static void Main(string[] args) => BenchmarkRunner.Run(typeof(Program).Assembly, args: args); \n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Jobs in BenchmarkDotNet\nDESCRIPTION: Example of creating custom job configurations in BenchmarkDotNet using both object initialization syntax and the With() factory methods. This demonstrates how to specify various job characteristics including runtime environment, execution parameters, and accuracy settings.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/jobs.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Config(typeof(Config))]\npublic class MyBenchmarks\n{\n    private class Config : ManualConfig\n    {\n        public Config()\n        {\n            AddJob(\n                new Job(\"MySuperJob\", RunMode.Dry, EnvironmentMode.RyuJitX64)\n                {\n                    Environment = { Runtime = CoreRuntime.Core90 },\n                    Run = { LaunchCount = 5, IterationTime = TimeInterval.Millisecond * 200 },\n                    Accuracy = { MaxRelativeError = 0.01 }\n                });\n\n            // The same, using the .With() factory methods:\n            AddJob(\n                Job.Dry\n                .WithPlatform(Platform.X64)\n                .WithJit(Jit.RyuJit)\n                .WithRuntime(CoreRuntime.Core90)\n                .WithLaunchCount(5)\n                .WithIterationTime(TimeInterval.Millisecond * 200)\n                .WithMaxRelativeError(0.01)\n                .WithId(\"MySuperJob\"));\n        }\n    }\n    // Benchmarks\n}\n```\n\n----------------------------------------\n\nTITLE: Disassembly of Sum method in .NET Framework 4.7.2 with 32-bit LegacyJIT\nDESCRIPTION: Assembly code generated by the .NET Framework 4.7.2 32-bit LegacyJIT compiler for the Sum method in IntroDisassembly class. The disassembly shows how the runtime implements a loop that sums integers from 0 to 63.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassembly.md#2025-04-22_snippet_0\n\nLANGUAGE: x86asm\nCODE:\n```\n; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0\n05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum()\nIL_0000: ldc.r8 0\nIL_0009: stloc.0\n0545271c d9ee            fldz\nIL_000a: ldc.i4.0\nIL_000b: stloc.1\nIL_000c: br.s IL_0017\n0545271e 33c0            xor     eax,eax\nIL_000e: ldloc.0\nIL_000f: ldloc.1\nIL_0010: conv.r8\nIL_0011: add\nIL_0012: stloc.0\n05452720 8945fc          mov     dword ptr [ebp-4],eax\n05452723 db45fc          fild    dword ptr [ebp-4]\n05452726 dec1            faddp   st(1),st\nIL_0013: ldloc.1\nIL_0014: ldc.i4.1\nIL_0015: add\nIL_0016: stloc.1\n05452728 40              inc     eax\nIL_0017: ldloc.1\nIL_0018: ldc.i4.s 64\nIL_001a: blt.s IL_000e\n05452729 83f840          cmp     eax,40h\n0545272c 7cf2            jl      05452720\nIL_001c: ldloc.0\nIL_001d: ret\n0545272e 8be5            mov     esp,ebp\n```\n\n----------------------------------------\n\nTITLE: Defining Benchmark Parameters with Priority in C#\nDESCRIPTION: This snippet demonstrates how to use the Priority property in parameter attributes to control the order of columns in BenchmarkDotNet result tables. The priority range is from Int32.MinValue to Int32.MaxValue, with lower values appearing earlier in the column order. The default priority is 0.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParamsPriority.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroParamsPriority.cs](../../../samples/BenchmarkDotNet.Samples/IntroParamsPriority.cs)]\n```\n\n----------------------------------------\n\nTITLE: Setting Multi-Runtime Benchmark Attributes\nDESCRIPTION: C# attributes for running benchmarks across multiple .NET runtimes including CoreCLR, CLR, and Mono.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/faq.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[CoreJob, ClrJob, MonoJob]\n```\n\n----------------------------------------\n\nTITLE: Configuring XML Export in BenchmarkDotNet\nDESCRIPTION: Sample XML export configuration showing how to use BenchmarkDotNet's XML exporters with various options. The exporter can be customized with fileNameSuffix, indentXml, and excludeMeasurements properties.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroExportXml.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// This code would be in IntroExportXml.cs from the BenchmarkDotNet.Samples namespace\n```\n\n----------------------------------------\n\nTITLE: Statistical Testing Implementation\nDESCRIPTION: Demonstrates the implementation of statistical tests using Welch's t-test and Mann-Whitney U test with various threshold units and configurations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n[StatisticalTestColumn(\n    StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)]\n[StatisticalTestColumn(\n    StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)]\n[StatisticalTestColumn(\n    StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)]\n[StatisticalTestColumn(\n    StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)]\n[SimpleJob(warmupCount: 0, targetCount: 5)]\npublic class IntroStatisticalTesting\n{\n    [Benchmark] public void Sleep50() => Thread.Sleep(50);\n    [Benchmark] public void Sleep97() => Thread.Sleep(97);\n    [Benchmark] public void Sleep99() => Thread.Sleep(99);\n    [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100);\n    [Benchmark] public void Sleep101() => Thread.Sleep(101);\n    [Benchmark] public void Sleep103() => Thread.Sleep(103);\n    [Benchmark] public void Sleep150() => Thread.Sleep(150);\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Multiple Runtimes in CMD\nDESCRIPTION: Demonstrates how to run benchmarks for multiple runtimes using a single command with the --runtimes argument.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_2\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net8.0 --runtimes net8.0 netcoreapp3.1 # is going to run the benchmarks using .NET 8.0 and .NET Core 3.1\ndotnet run -c Release -f net8.0 --runtimes net8.0 net48         # is going to run the benchmarks using .NET 8.0 and .NET 4.8\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Runtimes in C#\nDESCRIPTION: Shows how to create a custom configuration to benchmark multiple runtimes using a custom config class.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Environments;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Running;\n\nnamespace BenchmarkDotNet.Samples\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var config = DefaultConfig.Instance\n                .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80))\n                .AddJob(Job.Default.WithRuntime(ClrRuntime.Net48))\n                .AddJob(Job.Default.WithRuntime(MonoRuntime.Default));\n\n            BenchmarkSwitcher\n                .FromAssembly(typeof(Program).Assembly)\n                .Run(args, config);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using HideColumns Attribute to Customize Benchmark Output Display\nDESCRIPTION: This example shows how to use the HideColumns attribute to customize which columns are displayed in benchmark results. The code demonstrates hiding specific memory-related columns (Gen0, Gen1, Gen2) while keeping the Allocated column visible.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[MemoryDiagnoser] // adds Gen0, Gen1, Gen2 and Allocated Bytes columns\n[HideColumns(Column.Gen0, Column.Gen1, Column.Gen2)] // dont display GenX columns\npublic class IntroHidingColumns\n{\n    [Benchmark]\n    public byte[] AllocateArray() => new byte[100_000];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Jobs in C# with BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates how to create a custom job configuration for more granular control over benchmark execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Config(typeof(Config))]\npublic class Md5VsSha256\n{\n    private class Config : ManualConfig\n    {\n        public Config()\n        {\n            AddJob(new Job(Job.Dry)\n            {\n                Environment = { Jit = Jit.LegacyJit, Platform = Platform.X64 },\n                Run = { LaunchCount = 3, WarmupCount = 5, IterationCount = 10 },\n                Accuracy = { MaxRelativeError = 0.01 }\n            });\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Displaying Method Execution Order in BenchmarkDotNet C#\nDESCRIPTION: This code snippet illustrates the execution order of setup and cleanup methods in BenchmarkDotNet using C#. It outlines the invocation sequence starting with GlobalSetup and ending with GlobalCleanup, with intermittent IterationSetup and IterationCleanup around each benchmark invocation. The sequence helps understand the correct timing for resource preparation and cleanup in macrobenchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroSetupCleanupIteration.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// GlobalSetup\\n\\n// IterationSetup (1)    // IterationSetup Jitting\\n// IterationCleanup (1)  // IterationCleanup Jitting\\n\\n// IterationSetup (2)    // MainWarmup1\\n// Benchmark             // MainWarmup1\\n// IterationCleanup (2)  // MainWarmup1\\n\\n// IterationSetup (3)    // MainWarmup2\\n// Benchmark             // MainWarmup2\\n// IterationCleanup (3)  // MainWarmup2\\n\\n// IterationSetup (4)    // MainTarget1\\n// Benchmark             // MainTarget1\\n// IterationCleanup (4)  // MainTarget1\\n\\n// IterationSetup (5)    // MainTarget2\\n// Benchmark             // MainTarget2\\n// IterationCleanup (5)  // MainTarget2\\n\\n// IterationSetup (6)    // MainTarget3\\n// Benchmark             // MainTarget3\\n// IterationCleanup (6)  // MainTarget3\\n\\n// GlobalCleanup\n```\n\n----------------------------------------\n\nTITLE: Implementing Sortable Parameter Columns with Priority\nDESCRIPTION: C# benchmark class demonstrating how to control the order of parameter columns in the results table by setting Priority values on parameter attributes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class IntroParamsPriority\n{\n    [Params(100)]\n    public int A { get; set; }\n\n    [Params(10, Priority = -100)]\n    public int B { get; set; }\n\n    [Benchmark]\n    public void Benchmark() => Thread.Sleep(A + B + 5);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Project Options with .NET CLI\nDESCRIPTION: Examples of using various options when creating BenchmarkDotNet projects, including specifying frameworks, creating console apps, and setting benchmark names.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_12\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark -f netstandard2.0;net472\ndotnet new benchmark --console-app\ndotnet new benchmark -b Md5VsSha256\ndotnet new benchmark -c\ndotnet new benchmark --no-restore\ndotnet new benchmark --help\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Output\nDESCRIPTION: Sample output from BenchmarkDotNet showing benchmark results in a tabular format. The results compare SHA256 and MD5 performance across different .NET runtimes with various data sizes, including mean execution time, error margins, and relative performance ratios.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\nBenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5)\nIntel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores\n  [Host]       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT\n  Net472       : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT\n  NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT\n  NativeAot70  : .NET 7.0.0-preview.4.22172.7, X64 NativeAOT\n  Mono         : Mono 6.4.0 (Visual Studio), X64\n\n\n| Method |       Runtime |     N |       Mean |     Error |    StdDev | Ratio |\n|------- |-------------- |------ |-----------:|----------:|----------:|------:|\n| Sha256 |    .NET 4.7.2 |  1000 |   7.735 us | 0.1913 us | 0.4034 us |  1.00 |\n| Sha256 | .NET Core 3.0 |  1000 |   3.989 us | 0.0796 us | 0.0745 us |  0.50 |\n| Sha256 | NativeAOT 7.0 |  1000 |   4.091 us | 0.0811 us | 0.1562 us |  0.53 |\n| Sha256 |          Mono |  1000 |  13.117 us | 0.2485 us | 0.5019 us |  1.70 |\n|        |               |       |            |           |           |       |\n|    Md5 |    .NET 4.7.2 |  1000 |   2.872 us | 0.0552 us | 0.0737 us |  1.00 |\n|    Md5 | .NET Core 3.0 |  1000 |   1.848 us | 0.0348 us | 0.0326 us |  0.64 |\n|    Md5 | NativeAOT 7.0 |  1000 |   1.817 us | 0.0359 us | 0.0427 us |  0.63 |\n|    Md5 |          Mono |  1000 |   3.574 us | 0.0678 us | 0.0753 us |  1.24 |\n|        |               |       |            |           |           |       |\n| Sha256 |    .NET 4.7.2 | 10000 |  74.509 us | 1.5787 us | 4.6052 us |  1.00 |\n| Sha256 | .NET Core 3.0 | 10000 |  36.049 us | 0.7151 us | 1.0025 us |  0.49 |\n| Sha256 | NativeAOT 7.0 | 10000 |  36.253 us | 0.7076 us | 0.7571 us |  0.49 |\n| Sha256 |          Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us |  1.58 |\n|        |               |       |            |           |           |       |\n|    Md5 |    .NET 4.7.2 | 10000 |  17.308 us | 0.3361 us | 0.4250 us |  1.00 |\n|    Md5 | .NET Core 3.0 | 10000 |  15.726 us | 0.2064 us | 0.1930 us |  0.90 |\n|    Md5 | NativeAOT 7.0 | 10000 |  15.627 us | 0.2631 us | 0.2461 us |  0.89 |\n|    Md5 |          Mono | 10000 |  30.205 us | 0.5868 us | 0.6522 us |  1.74 |\n```\n\n----------------------------------------\n\nTITLE: Configuring Project for Disassembly Diagnoser in .NET\nDESCRIPTION: Required property settings in a .csproj file to enable the Disassembly Diagnoser. These settings ensure debug symbols are available and the project can target multiple platforms.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/disassembler.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n  <PlatformTarget>AnyCPU</PlatformTarget>\n  <DebugType>pdbonly</DebugType>\n  <DebugSymbols>true</DebugSymbols>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results in Markdown\nDESCRIPTION: This code snippet shows the output of the benchmark in a markdown table format. It displays the results for different combinations of input parameters, including method name, arguments, and performance metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArguments.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|    Method | AddExtra5Miliseconds |   a |  b |     Mean |     Error |    StdDev |\n|---------- |--------------------- |---- |--- |---------:|----------:|----------:|\n| Benchmark |                False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms |\n| Benchmark |                False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms |\n| Benchmark |                False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms |\n| Benchmark |                False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms |\n| Benchmark |                 True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms |\n| Benchmark |                 True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms |\n| Benchmark |                 True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms |\n| Benchmark |                 True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms |\n```\n\n----------------------------------------\n\nTITLE: Command Line Configuration for BenchmarkSwitcher\nDESCRIPTION: Example of how to use command line arguments with BenchmarkSwitcher to configure jobs, runtimes, and filters for benchmark execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-to-run.md#2025-04-22_snippet_2\n\nLANGUAGE: log\nCODE:\n```\ndotnet run -c Release -- --job short --runtimes net472 net7.0 --filter *BenchmarkClass1*\n```\n\n----------------------------------------\n\nTITLE: Using Disassembly Diagnoser with RyuJIT in BenchmarkDotNet\nDESCRIPTION: This code sample demonstrates how to set up benchmarks with the DisassemblyDiagnoser attribute to inspect the assembly code generated by the RyuJIT compiler. It includes a class with two simple methods for comparison.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassemblyRyuJit.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroDisassemblyRyuJit.cs](../../../samples/BenchmarkDotNet.Samples/IntroDisassemblyRyuJit.cs)]\n```\n\n----------------------------------------\n\nTITLE: Using InProcessAttribute with BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to apply the InProcessAttribute to a class containing benchmarks to use the InProcessEmitToolchain, which runs benchmarks within the current process.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroInProcess.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[InProcessAttribute]\npublic class TypeWithBenchmarks\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Mono Runtimes for Benchmarking in C#\nDESCRIPTION: This snippet shows how to set up benchmarks for different Mono runtimes using BenchmarkDotNet. It demonstrates using the MonoJob attribute with custom paths, configuring AOT compilation, and defining benchmark methods.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCustomMono.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Environments;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Running;\nusing BenchmarkDotNet.Toolchains.Mono;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [Config(typeof(Config))]\n    public class IntroCustomMono\n    {\n        private class Config : ManualConfig\n        {\n            public Config()\n            {\n                Add(Job.Default\n                    .With(MonoRuntime.Default)\n                    .WithCustomBuildConfiguration(\"Debug\")\n                    .WithId(\"Mono (Default)\")\n                );\n\n                Add(Job.Default\n                    .With(MonoRuntime.Create(\"/Library/Frameworks/Mono.framework/Versions/5.0.1/bin/mono\", \"/Library/Frameworks/Mono.framework/Versions/5.0.1/lib/mono/4.5/\"))\n                    .WithCustomBuildConfiguration(\"Release\")\n                    .WithId(\"Mono 5.0.1\")\n                );\n\n                Add(Job.Default\n                    .With(MonoRuntime.Create(\"/Library/Frameworks/Mono.framework/Versions/5.4.0/bin/mono\", \"/Library/Frameworks/Mono.framework/Versions/5.4.0/lib/mono/4.5/\"))\n                    .WithCustomBuildConfiguration(\"Release\")\n                    .WithId(\"Mono 5.4.0\")\n                );\n\n                // IntroCustomMonoObjectStyleAot\n                Add(Job.Default\n                    .With(new MonoRuntime(\n                        name: \"Mono AOT\",\n                        monoBinPath: \"/Library/Frameworks/Mono.framework/Versions/5.4.0/bin/mono\",\n                        monoRuntimePath: \"/Library/Frameworks/Mono.framework/Versions/5.4.0/lib/mono/4.5/\",\n                        aotCompilerPath: \"/Library/Frameworks/Mono.framework/Versions/5.4.0/bin/mono-sgen\",\n                        aotCompilerArgs: \"--aot=static\",\n                        monoCorlibPath: \"/Library/Frameworks/Mono.framework/Versions/5.4.0/lib/mono/4.5/mscorlib.dll\"\n                    ))\n                    .WithId(\"Mono AOT\")\n                );\n            }\n        }\n\n        [Benchmark]\n        public void Foo()\n        {\n            // Benchmark code here\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            BenchmarkRunner.Run<IntroCustomMono>();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Power Plans in BenchmarkDotNet (C#)\nDESCRIPTION: This C# snippet (referenced from 'IntroPowerPlan.cs') demonstrates how to select and change Windows power plans through BenchmarkDotNet's API during benchmarking. It enables users to switch between predefined profiles (such as PowerSaver or High-Performance) or specify a plan by GUID, optimizing benchmarking conditions for reproducibility. Dependencies include the BenchmarkDotNet framework and access to the underlying Windows power management APIs. The code expects users to provide either a named plan or a GUID, with changes taking effect according to method call order. Inputs are profile names or GUID strings; the output is the activation of the requested power plan during the benchmark run.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroPowerPlan.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroPowerPlan.cs](../../../samples/BenchmarkDotNet.Samples/IntroPowerPlan.cs)]\n```\n\n----------------------------------------\n\nTITLE: Introducing Custom Tag Columns in BenchmarkDotNet in C#\nDESCRIPTION: This code snippet demonstrates how to introduce custom columns in benchmark results using BenchmarkDotNet in C#. It modifies the benchmark results to include additional columns with tags based on method names. There are no specific inputs required, as the method names are automatically processed. Expected output includes additional columns appended to the benchmark output table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroTagColumn.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroTagColumn.cs](../../../samples/BenchmarkDotNet.Samples/IntroTagColumn.cs)]\n```\n\n----------------------------------------\n\nTITLE: Implementing IComparable for Complex Parameters in C# with BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to create a complex parameter class that implements IComparable for custom ordering in BenchmarkDotNet benchmarks. It includes a benchmark method that uses this complex parameter.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroComparableComplexParam.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing System;\n\nnamespace BenchmarkDotNet.Samples\n{\n    public class IntroComparableComplexParam\n    {\n        public class ComplexParam : IComparable\n        {\n            public int A { get; set; }\n            public int B { get; set; }\n\n            public ComplexParam(int a, int b)\n            {\n                A = a;\n                B = b;\n            }\n\n            public override string ToString() => $\"A={A}, B={B}\";\n\n            public int CompareTo(object obj)\n            {\n                if (obj is ComplexParam other)\n                {\n                    return A.CompareTo(other.A);\n                }\n                return 0;\n            }\n        }\n\n        [Benchmark]\n        [ArgumentsSource(nameof(GetArguments))]\n        public int Benchmark(ComplexParam param) => param.A + param.B;\n\n        public IEnumerable<ComplexParam> GetArguments()\n        {\n            yield return new ComplexParam(1, 3);\n            yield return new ComplexParam(10, 2);\n            yield return new ComplexParam(3, 7);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Settings with Command-Line Arguments in BenchmarkDotNet\nDESCRIPTION: Example of overriding programmatically defined default settings using command-line arguments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_9\n\nLANGUAGE: log\nCODE:\n```\ndotnet run -c Release -- --warmupCount 2\n```\n\n----------------------------------------\n\nTITLE: Using DotTraceDiagnoser Attribute in C#\nDESCRIPTION: Example of using the new DotTraceDiagnoser attribute to generate dotTrace performance snapshots during benchmark runs. This requires the BenchmarkDotNet.Diagnostics.dotTrace NuGet package to be installed.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.6.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[DotTraceDiagnoser]\n```\n\n----------------------------------------\n\nTITLE: Filtering Benchmarks with Tree Format in BenchmarkDotNet\nDESCRIPTION: Example output of combining '--list tree' with '--filter' to display only benchmarks matching a specific pattern in tree format.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet\n Samples\n    IntroSetupCleanupGlobal\n      Logic\n    IntroSetupCleanupIteration\n      Benchmark\n    IntroSetupCleanupTarget\n       BenchmarkA\n       BenchmarkB\n       BenchmarkC\n       BenchmarkD\n```\n\n----------------------------------------\n\nTITLE: Configuring ColdStart Strategy in C# BenchmarkDotNet\nDESCRIPTION: This snippet shows how to set up a benchmark class using the ColdStart strategy with 50 launch counts. It demonstrates the usage of SimpleJob attribute with RunStrategy.ColdStart.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroColdStart.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(RunStrategy.ColdStart, launchCount:50)]\npublic class MyBenchmarkClass\n```\n\n----------------------------------------\n\nTITLE: Using EventPipeProfiler for Cross-Platform Profiling in C#\nDESCRIPTION: Example of how to enable the EventPipeProfiler by applying the EventPipeProfiler attribute to a benchmark class. This allows for profiling benchmarks across Windows, Linux, and macOS platforms, with the results output as a .speedscope.json file.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[EventPipeProfiler(EventPipeProfile.CpuSampling)] // <-- Enables new profiler\npublic class IntroEventPipeProfiler\n{\n    [Benchmark]\n    public void Sleep() => Thread.Sleep(2000);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Complex Types as Benchmark Arguments in C#\nDESCRIPTION: Demonstrates how to use complex objects as benchmark arguments without implementing the IParam interface. This example shows using a custom Point2D class as a benchmark parameter via the ArgumentsSource attribute.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Program\n{\n    static void Main(string[] args) => BenchmarkRunner.Run<Program>();\n\n    public IEnumerable<object> Arguments()\n    {\n        yield return new Point2D(10, 200);\n    }\n\n    [Benchmark]\n    [ArgumentsSource(nameof(Arguments))]\n    public int WithArgument(Point2D point) => point.X + point.Y;\n}\n\npublic class Point2D\n{\n    public int X, Y;\n\n    public Point2D(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    public override string ToString() => $\"[{X},{Y}]\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Runtime Targets in C#\nDESCRIPTION: Examples of configuring benchmark jobs to target different .NET runtimes using attributes or manual configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nSimpleJob(RuntimeMoniker.Net48)\nSimpleJob(RuntimeMoniker.NetCoreApp31)\nJob.Default.With(ClrRuntime.Net48)\nJob.Default.With(CoreRuntime.Core31)\n```\n\n----------------------------------------\n\nTITLE: Implementing Hardware Counter Benchmarks in C#\nDESCRIPTION: This code snippet defines a benchmark class that demonstrates the use of hardware counters in BenchmarkDotNet. It includes four methods that implement different sorting strategies (sorted/unsorted and branch/branchless) to compare their performance using hardware counters.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroHardwareCounters.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HardwareCounters(HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)]\npublic class IntroHardwareCounters\n{\n    private const int N = 32768;\n    private readonly int[] sorted, unsorted;\n\n    public IntroHardwareCounters()\n    {\n        var random = new Random(0);\n        unsorted = new int[N];\n        sorted = new int[N];\n        for (int i = 0; i < N; i++)\n            sorted[i] = unsorted[i] = random.Next(256);\n        Array.Sort(sorted);\n    }\n\n    [Benchmark]\n    public int SortedBranch()\n    {\n        int sum = 0;\n        for (int i = 0; i < N; i++)\n            if (sorted[i] >= 128)\n                sum += sorted[i];\n        return sum;\n    }\n\n    [Benchmark]\n    public int UnsortedBranch()\n    {\n        int sum = 0;\n        for (int i = 0; i < N; i++)\n            if (unsorted[i] >= 128)\n                sum += unsorted[i];\n        return sum;\n    }\n\n    [Benchmark]\n    public int SortedBranchless()\n    {\n        int sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += (sorted[i] >= 128) ? sorted[i] : 0;\n        return sum;\n    }\n\n    [Benchmark]\n    public int UnsortedBranchless()\n    {\n        int sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += (unsorted[i] >= 128) ? unsorted[i] : 0;\n        return sum;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Monitoring Run Strategy in C#\nDESCRIPTION: Demonstrates how to set up a benchmark class using the Monitoring run strategy with specific parameters for launch count, warmup count, and iteration count.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroMonitoring.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, iterationCount: 100)]\npublic class MyBenchmarkClass\n```\n\n----------------------------------------\n\nTITLE: Using ArgumentsSource with Complex Types in BenchmarkDotNet\nDESCRIPTION: Example of implementing ArgumentsSource with custom complex types. It demonstrates how to use custom classes and structs as benchmark parameters and how to override ToString() to customize the display names in benchmark results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsSource.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[DryJob]\npublic class WithNonPrimitiveArgumentsSource\n{\n    [Benchmark]\n    [ArgumentsSource(nameof(NonPrimitive))]\n    public void Simple(SomeClass someClass, SomeStruct someStruct)\n    {\n        for (int i = 0; i < someStruct.RangeEnd; i++)\n            Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\");\n    }\n\n    public IEnumerable<object[]> NonPrimitive()\n    {\n        yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) };\n        yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) };\n    }\n\n    public class SomeClass\n    {\n        public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray();\n\n        public int[] Values { get; }\n\n        public override string ToString() => $\"{Values.Length} items\";\n    }\n\n    public struct SomeStruct\n    {\n        public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd;\n\n        public int RangeEnd { get; }\n\n        public override string ToString() => $\"{RangeEnd}\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Assembly-Level Configuration for BenchmarkDotNet\nDESCRIPTION: Example of how to apply a custom default configuration at the assembly level using an assembly attribute. This is necessary when running benchmarks through VSTest since the application entry point is not called.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/vstest.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: Config(typeof(MyDefaultConfig))]\n```\n\n----------------------------------------\n\nTITLE: Listing Available Benchmarks in Tree Format\nDESCRIPTION: This example illustrates the output of the --list tree command, which presents all available benchmarks in a hierarchical tree structure.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/console-args.md#2025-04-22_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet\n Samples\n    Algo_Md5VsSha256\n      Md5\n      Sha256\n    IntroArguments\n      Benchmark\n    IntroArgumentsSource\n      SingleArgument\n      ManyArguments\n    IntroArrayParam\n      ArrayIndexOf\n      ManualIndexOf\n    IntroBasic\n      Sleep\n[...]\n```\n\n----------------------------------------\n\nTITLE: Defining Benchmark Methods with Baseline in C#\nDESCRIPTION: This code snippet demonstrates how to define benchmark methods in C# using BenchmarkDotNet, including marking one method as a baseline for comparison.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroBenchmarkBaseline.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroBenchmarkBaseline.cs](../../../samples/BenchmarkDotNet.Samples/IntroBenchmarkBaseline.cs)]\n```\n\n----------------------------------------\n\nTITLE: Enabling System WakeLock via BenchmarkDotNet Command Line\nDESCRIPTION: This command-line argument `--wakeLock System` is used with the BenchmarkDotNet runner to enable a system-level wake lock. This prevents the computer from entering sleep mode during the benchmark execution, ensuring uninterrupted runs.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroWakeLock.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n--wakeLock System\n```\n\n----------------------------------------\n\nTITLE: Memory Management in Benchmarks\nDESCRIPTION: Example showing proper memory management in benchmarks to avoid OutOfMemoryException by using OperationsPerInvoke and proper cleanup.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/faq.md#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class OOM\n{\n    private StringBuilder buffer = new StringBuilder();\n    \n    [Benchmark]\n    public void HasSideEffects()\n    {\n        // This method is growing the buffer to infinity\n        // because it's executed millions of times\n        buffer.Append('a');\n    }\n    \n    [Benchmark(OperationsPerInvoke = 16)]\n    public void HasNoSideEffects()\n    {\n        buffer.Clear();\n\n        for (int i = 0; i < 1024; i++)\n            buffer.Append('a');\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Job Parameters in BenchmarkDotNet\nDESCRIPTION: Demonstrates how to manually configure job parameters like launch count, warmup count, and iteration count using the SimpleJob attribute in BenchmarkDotNet.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/choosing-run-strategy.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(launchCount: 3, warmupCount: 10, iterationCount: 30)]\npublic class MyBenchmarkClass\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom .NET Core Runtime in C#\nDESCRIPTION: Demonstrates how to create a custom toolchain for a specific .NET Core runtime version.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class MyConfig : ManualConfig\n{\n    public MyConfig()\n    {\n        Add(Job.Default.With(\n            CsProjCoreToolchain.From(\n                new NetCoreAppSettings(\n                    targetFrameworkMoniker: \"net8.0-windows\",\n                    runtimeFrameworkVersion: \"8.0.101\",\n                    name: \".NET 8.0 Windows\"))));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RPlotExporter and CsvMeasurementsExporter in C#\nDESCRIPTION: This snippet demonstrates how to configure a custom Config class in C# to use CsvMeasurementsExporter and RPlotExporter for generating plots of benchmark results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/exporters.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Config : ManualConfig\n{\n    public Config()\n    {\n        Add(CsvMeasurementsExporter.Default);\n        Add(RPlotExporter.Default);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ExceptionDiagnoser in BenchmarkDotNet in C#\nDESCRIPTION: This code demonstrates how to configure and use the ExceptionDiagnoser in BenchmarkDotNet to track exception frequency. The sample includes a benchmark method that randomly throws exceptions with a configurable probability.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroExceptionDiagnoser.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroExceptionDiagnoser.cs](../../../samples/BenchmarkDotNet.Samples/IntroExceptionDiagnoser.cs)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Benchmarks in C#\nDESCRIPTION: This code demonstrates how to set custom environment variables for benchmark processes using BenchmarkDotNet. It shows configuration of different environment variables for different jobs, which can be used to test how different .NET Core runtime settings affect performance metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroEnvVars.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroEnvVars.cs](../../../samples/BenchmarkDotNet.Samples/IntroEnvVars.cs)]\n```\n\n----------------------------------------\n\nTITLE: Customizing Ratio Column Style in BenchmarkDotNet (C#)\nDESCRIPTION: Demonstrates how to configure a custom ratio style for benchmark results using RatioStyle.Trend. This feature allows for more intuitive presentation of performance comparisons by showing whether a benchmark is 'faster' or 'slower' than the baseline.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[Config(typeof(Config))]\npublic class IntroRatioStyle\n{\n    [Benchmark(Baseline = true)]\n    public void Baseline() => Thread.Sleep(1000);\n\n    [Benchmark]\n    public void Bar() => Thread.Sleep(150);\n\n    [Benchmark]\n    public void Foo() => Thread.Sleep(1150);\n\n    private class Config : ManualConfig\n    {\n        public Config()\n        {\n            SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Visual Studio Diagnostics Output - Markdown\nDESCRIPTION: Displays sample diagnostic output produced when using the Visual Studio DiagnosticsHub profiler with BenchmarkDotNet. No external dependencies are required for viewing, but to produce similar output users must have the Microsoft.VisualStudio.DiagnosticsHub.BenchmarkDotNetDiagnosers package installed and a suitable benchmarking project configured. The snippet demonstrates the location of the exported .diagsession file and the process of opening it in Visual Studio. Inputs are diagnostic tool runs, and outputs are profiler session files and status messages.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroVisualStudioProfiler.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n// * Diagnostic Output - VSDiagnosticsDiagnoser *\\nCollection result moved to 'C:\\\\Work\\\\BenchmarkDotNet\\\\samples\\\\BenchmarkDotNet.Samples\\\\bin\\\\Release\\\\net8.0\\\\BenchmarkDotNet.Artifacts\\\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession'.\\nSession : {d54ebddb-2d6d-404f-b1da-10acbc89635f}\\n  Stopped\\nExported diagsession file: C:\\\\Work\\\\BenchmarkDotNet\\\\samples\\\\BenchmarkDotNet.Samples\\\\bin\\\\Release\\\\net8.0\\\\BenchmarkDotNet.Artifacts\\\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession.\\nOpening diagsession in VisualStudio: 15296\n```\n\n----------------------------------------\n\nTITLE: Configuring Quick Benchmark Jobs\nDESCRIPTION: C# attributes for configuring simplified benchmark runs with reduced iterations for faster results. Shows both SimpleJob and ShortRunJob configurations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/faq.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(launchCount: 1, warmupCount: 3, iterationCount: 5, invocationCount:100, id: \"QuickJob\")]\n[ShortRunJob]\n```\n\n----------------------------------------\n\nTITLE: Displaying EventPipeProfiler Output with Trace File Location\nDESCRIPTION: This markdown output shows what to expect after running a benchmark with EventPipeProfiler. It displays the location of the exported trace file which can be analyzed using SpeedScope.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroEventPipeProfilerAdvanced.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n// * Diagnostic Output - EventPipeProfiler *\nExported 1 trace file(s). Example:\nC:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json\n```\n\n----------------------------------------\n\nTITLE: Using AotFilter Attribute to Exclude Unsupported Features in NativeAOT\nDESCRIPTION: This code snippet demonstrates how to use the AotFilter attribute to exclude benchmarks that contain features not supported by NativeAOT. The attribute includes a descriptive message explaining why the benchmark is filtered out.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[AotFilter(\"Currently not supported due to missing metadata.\")]\npublic class Xml_FromStream<T>\n```\n\n----------------------------------------\n\nTITLE: Using ParamsAllValues Attribute in C#\nDESCRIPTION: Demonstrates how to use the ParamsAllValues attribute to automatically include all possible values of an enum or boolean type in benchmark parameters. Shows implementation with both enum and nullable bool.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic class IntroParamsAllValues\n{\n    public enum CustomEnum\n    {\n        A,\n        BB,\n        CCC\n    }\n\n    [ParamsAllValues]\n    public CustomEnum E { get; set; }\n\n    [ParamsAllValues]\n    public bool? B { get; set; }\n\n    [Benchmark]\n    public void Benchmark()\n    {\n        Thread.Sleep(\n            E.ToString().Length * 100 +\n            (B == true ? 20 : B == false ? 10 : 0));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using IterationSetup with Benchmarks in C#\nDESCRIPTION: Shows how the IterationSetup attribute is used to execute setup code before each benchmark iteration. With the updated behavior, the setup method is called before each individual benchmark invocation when IterationSetup is provided.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Test\n{\n    public static void Main() => BenchmarkRunner.Run<Test>();\n\n    [IterationSetup]\n    public void MySetup() => Console.WriteLine(\"MySetup\");\n\n    [Benchmark]\n    public void MyBenchmark() => Console.WriteLine(\"MyBenchmark\");\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Configuration of EventPipeProfiler in C#\nDESCRIPTION: Example showing advanced configuration of EventPipeProfiler using custom settings. This demonstrates how to specify providers, output file format, and other profiling options.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/event-pipe-profiler.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class IntroEventPipeProfilerAdvanced\n{\n    [Benchmark]\n    public void Benchmark()\n    {\n        // Code to be benchmarked\n    }\n\n    public static void Main(string[] args)\n    {\n        BenchmarkSwitcher\n            .FromAssembly(typeof(IntroEventPipeProfilerAdvanced).Assembly)\n            .Run(args, DefaultConfig.Instance\n                .AddProfiler(new EventPipeProfiler(new EventPipeProfilerConfig()\n                {\n                    OutputFileExtension = \"speedscope.json\",\n                    ProcessName = \"dotnet\",\n                    Providers = new Dictionary<string, string>\n                    {\n                        // provider_name:keywords:level:arguments\n                        [\"Microsoft-Windows-DotNETRuntime\"] = \"0x14C14FCCBD:4:0\"\n                    }\n                })));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmark Filters in BenchmarkDotNet\nDESCRIPTION: Demonstrates how to use predefined filters and implement custom filters that inherit from IFilter in BenchmarkDotNet. The sample shows filtering benchmarks based on different criteria including names, categories, and custom attributes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroFilters.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroFilters.cs](../../../samples/BenchmarkDotNet.Samples/IntroFilters.cs)]\n```\n\n----------------------------------------\n\nTITLE: Using SimpleJob Attribute for NativeAOT in C#\nDESCRIPTION: Demonstrates how to use the SimpleJob attribute to configure NativeAOT benchmarks for a specific class.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\n[SimpleJob(RuntimeMoniker.NativeAot70)] // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app\npublic class TheTypeWithBenchmarks\n{\n   [Benchmark] // the benchmarks go here\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Build Configurations for Benchmark Comparison (C#)\nDESCRIPTION: Shows how to set up custom build configurations to benchmark different versions of a library. This allows direct comparison of performance between different package versions by creating separate jobs with distinct build configurations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar config = DefaultConfig.Instance\n  .AddJob(Job.Default.WithCustomBuildConfiguration(\"X\").WithId(\"X\").AsBaseline())\n  .AddJob(Job.Default.WithCustomBuildConfiguration(\"Y\").WithId(\"Y\"));\n```\n\n----------------------------------------\n\nTITLE: Progress Reporting Log Output Format in BenchmarkDotNet\nDESCRIPTION: Example of the progress reporting and estimated finish time feature added in PR #1909. This log output shows the remaining benchmarks to run and the estimated completion time.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n// ** Remained 5211 (99.9%) benchmark(s) to run. Estimated finish 2022-08-25 22:26 (9h 7m from now) **\n```\n\n----------------------------------------\n\nTITLE: Disassembler Entry Point for Void Methods in C#\nDESCRIPTION: A public method providing an entry point for disassembler analysis when the benchmarked method returns `void`. It conditionally executes the workload method (`$WorkloadMethodCall$`) once after loading arguments. `NoOptimization` and `NoInlining` attributes are used to prevent JIT interference.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\npublic void $DisassemblerEntryMethodName$()\n{\n    if (NotEleven == 11)\n    {\n        $LoadArguments$\n        $WorkloadMethodCall$;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ThreadingDiagnoser in C#\nDESCRIPTION: This code snippet shows the implementation of a benchmark method using ThreadingDiagnoser. It demonstrates how to measure completed work items and lock contentions in a ThreadPool operation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroThreadingDiagnoser.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroThreadingDiagnoser.cs](../../../samples/BenchmarkDotNet.Samples/IntroThreadingDiagnoser.cs)]\n```\n\n----------------------------------------\n\nTITLE: Improved CPU Brand String Format (Log)\nDESCRIPTION: Displays the improved, more concise format for CPU information introduced in BenchmarkDotNet v0.11.2+. Redundant descriptive text (like 'Eight-Core Processor') is removed, and the frequency is presented more directly, leading to clearer and shorter hardware summaries in benchmark reports.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_14\n\nLANGUAGE: log\nCODE:\n```\nAMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores\n```\n\n----------------------------------------\n\nTITLE: Running NativeAOT Benchmarks with Command Line Arguments\nDESCRIPTION: This command demonstrates how to run benchmarks targeting NativeAOT 7.0 using the command line interface. It specifies the Release configuration, .NET 7.0 framework, and explicitly selects the NativeAOT runtime for benchmarking.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_2\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net7.0 --runtimes nativeaot7.0\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement without Unrolling for Ref-Returning Methods in C#\nDESCRIPTION: Executes the benchmark workload for methods returning by reference (`ref T`), without loop unrolling. It calls the `workloadDelegate` `invokeCount` times in a loop, assigning the returned reference to an alias (`alias`) of `workloadDefaultValueHolder`. `KeepAliveWithoutBoxing` is used with the `ref alias` to ensure the workload's side effects are preserved.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        alias = workloadDelegate($PassArguments$);\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Package Comparison in C#\nDESCRIPTION: Example of how to benchmark different versions of the same NuGet package by configuring multiple jobs with different package versions. This demonstrates how to compare performance across different versions of Newtonsoft.Json.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Config(typeof(Config))]\npublic class IntroNuGet\n{\n  // Specify jobs with different versions of the same NuGet package to benchmark.\n  // The NuGet versions referenced on these jobs must be greater or equal to the\n  // same NuGet version referenced in this benchmark project.\n  // Example: This benchmark project references Newtonsoft.Json 9.0.1\n  private class Config : ManualConfig\n  {\n    public Config()\n    {\n      var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value);\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\"));\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\"));\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\"));\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\"));\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\"));\n      Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\"));\n    }\n  }\n  \n  [Benchmark]\n  public void SerializeAnonymousObject()\n    => JsonConvert.SerializeObject(\n      new { hello = \"world\", price = 1.99, now = DateTime.UtcNow });\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results to HTML\nDESCRIPTION: This snippet presents the HTML export format for BenchmarkDotNet results. It includes a basic HTML structure with CSS for table styling, displays the environment information and job configuration within `<pre>` tags, and presents the benchmark metrics (Method, Mean, Error, StdDev, P67, CacheMisses) for methods 'Foo' and 'Bar' in an HTML table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='utf-8' />\n<title>MockSummary</title>\n\n<style type=\"text/css\">\n\ttable { border-collapse: collapse; display: block; width: 100%; overflow: auto; }\n\ttd, th { padding: 6px 13px; border: 1px solid #ddd; text-align: right; }\n\ttr { background-color: #fff; border-top: 1px solid #ccc; }\n\ttr:nth-child(even) { background: #f8f8f8; }\n</style>\n</head>\n<body>\n<pre><code>\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n</code></pre>\n<pre><code>Job=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n</code></pre>\n\n<table>\n<thead><tr><th>Method</th><th>Mean</th><th>Error</th><th>StdDev</th><th>P67</th><th>CacheMisses</th>\n</tr>\n</thead><tbody><tr><td>Foo</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\n</tr><tr><td>Bar</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\n</tr></tbody></table>\n</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Configuring NativeAOT Benchmarks in C#\nDESCRIPTION: Shows how to configure NativeAOT benchmarks using C# code with custom job configurations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nvar config = DefaultConfig.Instance\n    .AddJob(Job.Default.WithRuntime(NativeAotRuntime.Net70)); // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app\n\nBenchmarkSwitcher\n    .FromAssembly(typeof(Program).Assembly)\n    .Run(args, config);\n```\n\n----------------------------------------\n\nTITLE: Attaching Debugger in BenchmarkDotNet Setup\nDESCRIPTION: Code example showing how to implement a wait loop in the benchmark setup to allow time for attaching a debugger manually.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/troubleshooting.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[GlobalSetup]\\npublic void Setup()\\n{\\n    while(!System.Diagnostics.Debugger.IsAttached)\\n        Thread.Sleep(TimeSpan.FromMilliseconds(100));\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Job Attributes in BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates how to create a custom job attribute by implementing IConfigSource. The custom attribute defines a job with specific settings that can be reused across multiple benchmark classes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/jobs.md#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly)]\npublic class MySuperJobAttribute : Attribute, IConfigSource\n{\n    protected MySuperJobAttribute()\n    {\n        var job = new Job(\"MySuperJob\", RunMode.Core);\n        job.Env.Platform = Platform.X64;\n        Config = ManualConfig.CreateEmpty().AddJob(job);\n    }\n\n    public IConfig Config { get; }\n}\n\n[MySuperJob]\npublic class MyBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Improved Disassembly Output Example - After\nDESCRIPTION: The same disassembly output after improvements. Runtime helper methods and references to method tables are now properly labeled, making the output more readable and useful for analysis.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_4\n\nLANGUAGE: x86asm\nCODE:\n```\n; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32)\n       push      rsi\n       sub       rsp,20\n       mov       rsi,rcx\n       cmp       edx,7FFFFFFF\n       jne       M00_L00 \n       call      BenchmarkDotNet.Samples.WithCallsAfter.Static() \n       mov       rcx,rsi\n       call      BenchmarkDotNet.Samples.WithCallsAfter.Instance() \n       mov       rcx,rsi\n       call      BenchmarkDotNet.Samples.WithCallsAfter.Recursive() \n       mov       rcx,rsi\n       mov       rax,[rsi]\n       mov       rax,[rax+40]\n       call      qword ptr [rax+20]\n       mov       rcx,rsi\n       mov       edx,1\n       mov       rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) \n       add       rsp,20\n       pop       rsi\n       jmp       rax\nM00_L00:\n       mov       rcx MT_System.InvalidOperationException \n       call      CORINFO_HELP_NEWSFAST \n       mov       rsi,rax\n       mov       ecx,12D\n       mov       rdx,7FF954FF83F0\n       call      CORINFO_HELP_STRCNS \n       mov       rdx,rax\n       mov       rcx,rsi\n       call      System.InvalidOperationException..ctor(System.String) \n       mov       rcx,rsi\n       call      CORINFO_HELP_THROW \n       int       3\n; Total bytes of code 134\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Outlier Handling in BenchmarkDotNet Results\nDESCRIPTION: This code snippet shows benchmark output comparing two outlier handling modes: DontRemoveOutliers and RemoveUpperOutliers. The output demonstrates how outlier removal affects the mean, error, and standard deviation measurements.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroOutliers.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Method |                 Job | OutlierMode |     Mean |       Error |      StdDev |\n------- |-------------------- |------------ |---------:|------------:|------------:|\n    Foo |  DontRemoveOutliers |  DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms |\n    Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms |   0.1931 ms |   0.1149 ms |\n\n// * Hints *\nOutliers\n  IntroOutliers.Foo: DontRemoveOutliers  -> 1 outlier  was  detected\n  IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier  was  removed\n```\n\n----------------------------------------\n\nTITLE: Handling OutOfMemoryException Demonstration in C#\nDESCRIPTION: Example of how BenchmarkDotNet handles OutOfMemoryException by providing a helpful explanation when a benchmark causes a memory overflow by allocating too much memory.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Program\n{\n    static void Main(string[] args) => BenchmarkRunner.Run<Program>();\n\n    private List<object> list = new List<object>();\n\n    [Benchmark]\n    public void AntiPattern() => list.Add(new int[int.MaxValue / 2]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Allocation Ratio Column with MemoryDiagnoser in C#\nDESCRIPTION: Example demonstrating the Allocation Ratio Column feature with a memory diagnoser. The sample compares string building using StringBuilder versus string concatenation, displaying memory allocation differences in the results table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[MemoryDiagnoser]\npublic class AllocationColumnSample\n{\n    [Benchmark(Baseline = true)]\n    [Arguments(\"test\")]\n    public string Builder(string value)\n    {\n        StringBuilder sb = new (value);\n\n        for (int i = 0; i < 10; i++)\n            sb.Append(value);\n\n        return sb.ToString();\n    }\n\n    [Benchmark]\n    [Arguments(\"test\")]\n    public string Concatenation(string value)\n    {\n        string result = value;\n\n        for (int i = 0; i < 10; i++)\n            result += value;\n\n        return result;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Table with Baseline Comparison\nDESCRIPTION: The benchmark results table showing performance metrics for the SplitJoin method across different runtimes. The CLR runtime is set as the baseline (Ratio=1.00), while .NET Core performs at 0.67x and Mono at 2.02x the baseline time.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJobBaseline.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n    Method | Runtime |     Mean |     Error |    StdDev | Ratio | RatioSD |\n---------- |-------- |---------:|----------:|----------:|------:|--------:|\n SplitJoin |     Clr | 19.42 us | 0.2447 us | 0.1910 us |  1.00 |    0.00 |\n SplitJoin |    Core | 13.00 us | 0.2183 us | 0.1935 us |  0.67 |    0.01 |\n SplitJoin |    Mono | 39.14 us | 0.7763 us | 1.3596 us |  2.02 |    0.07 |\n```\n\n----------------------------------------\n\nTITLE: Implementing Memory Randomization in C# Benchmarks\nDESCRIPTION: C# benchmark class demonstrating the memory randomization feature that allows BenchmarkDotNet to randomize memory alignment by allocating random-sized arrays between iterations and executing setup/cleanup for each iteration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class IntroMemoryRandomization\n{\n    [Params(512 * 4)]\n    public int Size;\n\n    private int[] _array;\n    private int[] _destination;\n\n    [GlobalSetup]\n    public void Setup()\n    {\n        _array = new int[Size];\n        _destination = new int[Size];\n    }\n\n    [Benchmark]\n    public void Array() => System.Array.Copy(_array, _destination, Size);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ThreadingDiagnoser in C# Benchmarks\nDESCRIPTION: Example of using ThreadingDiagnoser to measure completed work items and lock contentions in ThreadPool operations. It adds two extra columns to the summary table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n[ThreadingDiagnoser]\npublic class IntroThreadingDiagnoser\n{\n    [Benchmark]\n    public void CompleteOneWorkItem()\n    {\n        ManualResetEvent done = new ManualResetEvent(initialState: false);\n        ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done);\n        done.WaitOne();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Configurations in BenchmarkDotNet\nDESCRIPTION: This code demonstrates how to combine multiple configurations in BenchmarkDotNet using ManualConfig.Create() and AddConfig method. The sample creates two configurations with different job settings and exports, then unites them into a single configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroConfigUnion.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroConfigUnion.cs](../../../samples/BenchmarkDotNet.Samples/IntroConfigUnion.cs)]\n```\n\n----------------------------------------\n\nTITLE: Creating Jobs Based on Frozen Configurations\nDESCRIPTION: Examples of different ways to create new jobs based on frozen job configurations in BenchmarkDotNet. This shows three approaches: using the With() extension method, passing the frozen job as a constructor argument, or using the Apply() method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/jobs.md#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n            var newJob = Job.Dry.WithPlatform(Platform.X64);\n```\n\nLANGUAGE: C#\nCODE:\n```\n            var newJob = new Job(Job.Dry) { Environment = { Platform = Platform.X64 } };\n```\n\nLANGUAGE: C#\nCODE:\n```\n            var newJob = new Job() { Environment = { Platform = Platform.X64 } }.Apply(Job.Dry);\n```\n\n----------------------------------------\n\nTITLE: Applying AotFilter to Unsupported Benchmarks in C#\nDESCRIPTION: This snippet shows how to mark a benchmark method as unsupported by NativeAOT using the AotFilter attribute. This is necessary for benchmark methods that use features not compatible with NativeAOT compilation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[Benchmark]\n[AotFilter(\"Not supported by design.\")]\npublic object CreateInstanceNames() => System.Activator.CreateInstance(_assemblyName, _typeName);\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Environment Configuration Output\nDESCRIPTION: The initialization output from BenchmarkDotNet showing the benchmark environment details including OS information, processor specifications, and the configured runtimes (.NET Framework, .NET Core, and Mono).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJobBaseline.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192)\nProcessor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8\nFrequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC\n.NET Core SDK=2.0.3\n  [Host]     : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT\n  Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0\n  Core       : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT\n  Mono       : Mono 5.4.0 (Visual Studio), 64bit \n```\n\n----------------------------------------\n\nTITLE: Output Format for Joined Benchmarks in Markdown\nDESCRIPTION: Example output showing how joined benchmark results appear in a single table with data from multiple benchmark classes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJoin.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n|       Type | Method |     Mean | Error |\n|----------- |------- |---------:|------:|\n| IntroJoin1 |      A | 10.99 ms |    NA |\n| IntroJoin2 |      A | 12.50 ms |    NA |\n```\n\n----------------------------------------\n\nTITLE: Using DisassemblyDiagnoser in C# Benchmarks\nDESCRIPTION: This snippet demonstrates how to use the DisassemblyDiagnoser attribute to get assembly listings for benchmarks. It compares two methods - one using a local variable pointing to a field and another directly accessing the field.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[DisassemblyDiagnoser]\npublic class IntroDisassembly\n{\n    private int[] field = Enumerable.Range(0, 100).ToArray();\n\n    [Benchmark]\n    public int SumLocal()\n    {\n        var local = field; // we use local variable that points to the field\n\n        int sum = 0;\n        for (int i = 0; i < local.Length; i++)\n            sum += local[i];\n\n        return sum;\n    }\n\n    [Benchmark]\n    public int SumField()\n    {\n        int sum = 0;\n        for (int i = 0; i < field.Length; i++)\n            sum += field[i];\n\n        return sum;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Summarizing BenchmarkDotNet Cold Start Results in Markdown Table\nDESCRIPTION: This snippet presents a summary table of the cold start benchmark results, showing statistics like mean, error, standard deviation, minimum, maximum, and median execution times.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroColdStart.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n Method |     Mean |      Error |   StdDev |      Min |        Max |   Median |\n------- |---------:|-----------:|---------:|---------:|-----------:|---------:|\n    Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms |\n```\n\n----------------------------------------\n\nTITLE: Comparing .NET 7.0 and NativeAOT 7.0 Benchmarks\nDESCRIPTION: This benchmark output compares regular .NET 7.0 runtime with NativeAOT 7.0, showing system specifications and configuration details. The results show a slight performance advantage for NativeAOT in the Binary Trees benchmark.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22000.856/21H2)\nAMD Ryzen Threadripper PRO 3945WX 12-Cores, 1 CPU, 24 logical and 12 physical cores\n.NET SDK=7.0.100-rc.1.22423.16\n  [Host]     : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2\n  Job-KDVXET : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2\n  Job-HFRAGK : .NET 7.0.0-rc.1.22424.9, X64 NativeAOT AVX2\n```\n\n----------------------------------------\n\nTITLE: Configuring NativeAOT Toolchain with Custom NuGet Source in C#\nDESCRIPTION: This code demonstrates how to customize the NativeAOT toolchain by specifying a particular version and NuGet feed URL. It creates a configuration that uses a custom NuGet package version and feed for the NativeAOT compiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar config = DefaultConfig.Instance\n    .AddJob(Job.ShortRun\n        .WithToolchain(NativeAotToolchain.CreateBuilder()\n            .UseNuGet(\n                microsoftDotNetILCompilerVersion: \"7.0.0-*\", // the version goes here\n                nuGetFeedUrl: \"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json\") // this address might change over time\n            .DisplayName(\"NativeAOT NuGet\")\n            .TargetFrameworkMoniker(\"net7.0\")\n            .ToToolchain()));\n```\n\n----------------------------------------\n\nTITLE: Exporting Full Benchmark Summary to XML in .NET\nDESCRIPTION: This XML structure represents a full benchmark summary export, including detailed system information, benchmark cases, statistics, metrics, and measurements. It's designed for use with BenchmarkDotNet to provide comprehensive performance analysis results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Using Generic Type Arguments in BenchmarkDotNet (C#)\nDESCRIPTION: This code demonstrates how to implement benchmarks with generic type arguments in BenchmarkDotNet. The sample shows a benchmark class with a generic method that accepts different types as arguments, allowing for type-specific performance comparisons.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroGenericTypeArguments.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroGenericTypeArguments.cs](../../../samples/BenchmarkDotNet.Samples/IntroGenericTypeArguments.cs)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ref Readonly Benchmarks in C#\nDESCRIPTION: Demonstration of using 'ref readonly' in benchmark signatures. This example shows how to create a benchmark that returns a reference to a read-only value from a static array.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RefReadonlyBenchmark\n{\n    static readonly int[] array = { 1 };\n\n    [Benchmark]\n    public ref readonly int RefReadonly() => ref RefReadonlyMethod();\n\n    static ref readonly int RefReadonlyMethod() => ref array[0];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Minimum Viable Configuration with ManualConfig API (C#)\nDESCRIPTION: Demonstrates the new ManualConfig.CreateMinimumViable() method which creates a basic configuration with essential components. This simplifies the process of creating custom configurations compared to the previous approach requiring manual setup.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nIConfig before = ManualConfig.CreateEmpty()\n    .AddColumnProvider(DefaultColumnProviders.Instance)\n    .AddLogger(ConsoleLogger.Default);\n\nIConfig after = ManualConfig.CreateMinimumViable();\n```\n\n----------------------------------------\n\nTITLE: Using Response File Syntax in BenchmarkDotNet\nDESCRIPTION: Example of using the new response file support in BenchmarkDotNet, which allows passing additional arguments using the @filename syntax.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.6.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n@filename\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Log Entry Format\nDESCRIPTION: Standard log entry format for BenchmarkDotNet showing benchmark configuration, host environment details, and measurement results. Each entry includes method information, runtime settings, hardware details, and timing values.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz)\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .job.environment.affinity = 14\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp31\n  .unit = ns\n  .value = 146\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Results as JSON in .NET\nDESCRIPTION: A JSON representation of benchmark results for MockBenchmarkClass methods Foo and Bar. This format contains detailed information about the benchmark environment, statistics, memory usage, measurements, and hardware metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\"Title\":\"MockSummary\",\"HostEnvironmentInfo\":{\"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\"BenchmarkDotNetVersion\":\"0.10.x-mock\",\"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\"PhysicalProcessorCount\":1,\"PhysicalCoreCount\":4,\"LogicalCoreCount\":8,\"RuntimeVersion\":\"Clr 4.0.x.mock\",\"Architecture\":\"64mock\",\"HasAttachedDebugger\":false,\"HasRyuJit\":true,\"Configuration\":\"CONFIGURATION\",\"DotNetCliVersion\":\"1.0.x.mock\",\"ChronometerFrequency\":{\"Hertz\":2531248},\"HardwareTimerKind\":\"Tsc\"},\"Benchmarks\":[{\"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Foo\",\"MethodTitle\":\"Foo\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null},\"Measurements\":[{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":1,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":2,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":3,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":4,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":5,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":6,\"Operations\":1,\"Nanoseconds\":1}],\"Metrics\":[{\"Value\":7,\"Descriptor\":{\"Id\":\"CacheMisses\",\"DisplayName\":\"CacheMisses\",\"Legend\":\"Hardware counter 'CacheMisses' per single operation\",\"NumberFormat\":\"N0\",\"UnitType\":0,\"Unit\":null,\"TheGreaterTheBetter\":false,\"PriorityInCategory\":0}}]},{\"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Bar\",\"MethodTitle\":\"Bar\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null},\"Measurements\":[{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":1,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":2,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":3,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":4,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":5,\"Operations\":1,\"Nanoseconds\":1},{\"IterationMode\":\"Workload\",\"IterationStage\":\"Result\",\"LaunchIndex\":1,\"IterationIndex\":6,\"Operations\":1,\"Nanoseconds\":1}],\"Metrics\":[{\"Value\":7,\"Descriptor\":{\"Id\":\"CacheMisses\",\"DisplayName\":\"CacheMisses\",\"Legend\":\"Hardware counter 'CacheMisses' per single operation\",\"NumberFormat\":\"N0\",\"UnitType\":0,\"Unit\":null,\"TheGreaterTheBetter\":false,\"PriorityInCategory\":0}}]}]}\n```\n\n----------------------------------------\n\nTITLE: Running BenchmarkDotNet with JitStatsDiagnoser in .NET 7\nDESCRIPTION: This command demonstrates how to run a benchmark using BenchmarkDotNet with the new JitStatsDiagnoser. It specifies the Release configuration, targets .NET 7.0, filters for a specific benchmark method, and enables the JIT profiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.4.md#2025-04-22_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net7.0 --filter *IntroBasic.Sleep --profiler jit\n```\n\n----------------------------------------\n\nTITLE: Configuring NativeAOT Benchmarks in CMD\nDESCRIPTION: Demonstrates how to run benchmarks for NativeAOT using command-line arguments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_11\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net7.0 --runtimes nativeaot7.0\n```\n\n----------------------------------------\n\nTITLE: Using Local NativeAOT Build in BenchmarkDotNet with C#\nDESCRIPTION: This code shows how to configure BenchmarkDotNet to use a locally built version of the NativeAOT compiler. This is particularly useful for NativeAOT contributors who want to benchmark their changes to the compiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar config = DefaultConfig.Instance\n    .AddJob(Job.ShortRun\n        .WithToolchain(NativeAotToolchain.CreateBuilder()\n            .UseLocalBuild(@\"C:\\Projects\\runtime\\artifacts\\packages\\Release\\Shipping\\\")\n            .DisplayName(\"NativeAOT local build\")\n            .TargetFrameworkMoniker(\"net7.0\")\n            .ToToolchain()));\n```\n\n----------------------------------------\n\nTITLE: Configuring Iteration Parameters in BenchmarkDotNet\nDESCRIPTION: Example of customizing benchmark execution by setting the number of warmup and actual workload iterations with command-line arguments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_7\n\nLANGUAGE: log\nCODE:\n```\ndotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet IntroPercentiles Sample Implementation\nDESCRIPTION: This code snippet contains the full implementation of the IntroPercentiles sample in BenchmarkDotNet. It includes three benchmark methods demonstrating constant delays, random delays, and rare delays, along with the benchmark configuration using PercentileColumn.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroPercentiles.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroPercentiles.cs](../../../samples/BenchmarkDotNet.Samples/IntroPercentiles.cs)]\n```\n\n----------------------------------------\n\nTITLE: Installing BenchmarkDotNet Templates\nDESCRIPTION: Command to install BenchmarkDotNet templates using the .NET CLI\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_0\n\nLANGUAGE: log\nCODE:\n```\ndotnet new install BenchmarkDotNet.Templates\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results with Ratio Column in Markdown\nDESCRIPTION: This markdown table shows the output of a benchmark run, including a 'Ratio' column that compares the performance of each method to the baseline method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroBenchmarkBaseline.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|  Method |      Mean |     Error |    StdDev | Ratio |\n|-------- |----------:|----------:|----------:|------:|\n|  Time50 |  50.46 ms | 0.0779 ms | 0.0729 ms |  0.50 |\n| Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms |  1.00 |\n| Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms |  1.50 |\n```\n\n----------------------------------------\n\nTITLE: Serializing BenchmarkDotNet Test Results in JSON\nDESCRIPTION: This JSON structure represents the full, compressed output of BenchmarkDotNet test results. It includes detailed information about benchmark methods, their statistics, memory usage, measurements, and metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"Parameters\": \"\",\n  \"FullName\": \"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\n  \"HardwareIntrinsics\": \"\",\n  \"Statistics\": {\n    \"OriginalValues\": [\n      1,1,1,1,1,1\n    ],\n    \"N\": 6,\n    \"Min\": 1,\n    \"LowerFence\": 1,\n    \"Q1\": 1,\n    \"Median\": 1,\n    \"Mean\": 1,\n    \"Q3\": 1,\n    \"UpperFence\": 1,\n    \"Max\": 1,\n    \"InterquartileRange\": 0,\n    \"LowerOutliers\": [],\n    \"UpperOutliers\": [],\n    \"AllOutliers\": [],\n    \"StandardError\": 0,\n    \"Variance\": 0,\n    \"StandardDeviation\": 0,\n    \"Skewness\": \"\",\n    \"Kurtosis\": \"\",\n    \"ConfidenceInterval\": {\n      \"N\": 6,\n      \"Mean\": 1,\n      \"StandardError\": 0,\n      \"Level\": 12,\n      \"Margin\": 0,\n      \"Lower\": 1,\n      \"Upper\": 1\n    },\n    \"Percentiles\": {\n      \"P0\": 1,\n      \"P25\": 1,\n      \"P50\": 1,\n      \"P67\": 1,\n      \"P80\": 1,\n      \"P85\": 1,\n      \"P90\": 1,\n      \"P95\": 1,\n      \"P100\": 1\n    }\n  },\n  \"Memory\": {\n    \"Gen0Collections\": 0,\n    \"Gen1Collections\": 0,\n    \"Gen2Collections\": 0,\n    \"TotalOperations\": 0,\n    \"BytesAllocatedPerOperation\": null\n  },\n  \"Measurements\": [\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 1,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    },\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 2,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    },\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 3,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    },\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 4,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    },\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 5,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    },\n    {\n      \"IterationMode\": \"Workload\",\n      \"IterationStage\": \"Result\",\n      \"LaunchIndex\": 1,\n      \"IterationIndex\": 6,\n      \"Operations\": 1,\n      \"Nanoseconds\": 1\n    }\n  ],\n  \"Metrics\": [\n    {\n      \"Value\": 7,\n      \"Descriptor\": {\n        \"Id\": \"CacheMisses\",\n        \"DisplayName\": \"CacheMisses\",\n        \"Legend\": \"Hardware counter 'CacheMisses' per single operation\",\n        \"NumberFormat\": \"N0\",\n        \"UnitType\": 0,\n        \"Unit\": null,\n        \"TheGreaterTheBetter\": false,\n        \"PriorityInCategory\": 0\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Benchmark Project Using dotnet CLI\nDESCRIPTION: Command to create a new BenchmarkDotNet project using the official template package.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet new benchmark\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Warmup Stage Implementation\nDESCRIPTION: Pseudocode showing how BenchmarkDotNet performs warmup iterations to prepare the system for accurate measurement, continuing until warmup requirements are satisfied.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvoid Warmup(Method method, long invokeCount, int unrollFactor)\n{\n    while (true)\n    {\n        var measurement = RunIteration(method, invokeCount, unrollFactor);\n\n        if (heuristic.IsWarmupRequirementMet(measurement))\n            break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in Atlassian Markdown Format\nDESCRIPTION: An Atlassian-specific markdown representation of benchmark results. This format uses Atlassian's {noformat} tags and table syntax to present the benchmark data in a way that's compatible with Atlassian products like Confluence.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n{noformat}\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n{noformat}\n||Method ||Mean     ||Error    ||StdDev   ||P67      ||CacheMisses ||\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Installing BenchmarkDotNet Templates with .NET CLI\nDESCRIPTION: Command to install BenchmarkDotNet project templates using the .NET Core SDK. These templates are available for C#, F#, and VB.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_9\n\nLANGUAGE: log\nCODE:\n```\ndotnet new -i BenchmarkDotNet.Templates\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Framework Target in Project File (XML)\nDESCRIPTION: XML configuration for targeting multiple .NET frameworks in a project file. This is required when testing benchmarks across different .NET versions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks>\n```\n\n----------------------------------------\n\nTITLE: Formatting Benchmark Summary Output with Markdown - Markdown\nDESCRIPTION: These code snippets demonstrate how benchmark results appear when different SummaryStyle options are applied in BenchmarkDotNet. They show table formatting in Markdown, with the first table displaying explicit units in headers and content, and the second reflecting default settings. These outputs help users understand the effects of various summary style configurations. No dependencies are required as this is illustrative output; inputs are generated by BenchmarkDotNet based on provided configuration, and outputs are formatted tables for reports.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroSummaryStyle.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | N   | Mean [ns]     | Error [ns] | StdDev [ns] |\n|------- |---- |--------------:|-----------:|------------:|\n| Sleep  | 10  |  15,644,973.1 |   32,808.7 |    30,689.3 |\n| Sleep  | 100 | 109,440,686.7 |  236,673.8 |   221,384.8 |\n```\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | N   | Mean      | Error    | StdDev   |\n|------- |---- |----------:|---------:|---------:|\n| Sleep  | 10  |  15.65 ms | 0.039 ms | 0.034 ms |\n| Sleep  | 100 | 109.20 ms | 0.442 ms | 0.392 ms |\n```\n\n----------------------------------------\n\nTITLE: Using Priority Attributes with Arguments in BenchmarkDotNet\nDESCRIPTION: This code sample demonstrates the use of the Priority attribute to sort Argument columns in benchmark results tables. The priority is defined once for multiple Arguments while maintaining their inner order as defined in the method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsPriority.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroArgumentsPriority.cs](../../../samples/BenchmarkDotNet.Samples/IntroArgumentsPriority.cs)]\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssembly Benchmarks in C# with BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to set up and run WebAssembly benchmarks using BenchmarkDotNet. It includes a sample benchmark method and configuration for the WasmToolchain.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroWasm.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Running;\nusing BenchmarkDotNet.Toolchains.Wasm;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [Config(typeof(Config))]\n    public class IntroWasm\n    {\n        private class Config : ManualConfig\n        {\n            public Config()\n            {\n                AddJob(Job.ShortRun.WithToolchain(WasmToolchain.Instance));\n            }\n        }\n\n        [Benchmark]\n        public void Benchmark()\n        {\n            // Here you should put the code that you want to measure\n            for (int i = 0; i < 100; i++)\n            {\n                Console.WriteLine($\"Hello, World! {i}\");\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            BenchmarkRunner.Run<IntroWasm>();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available Benchmarks in Flat Format\nDESCRIPTION: This example shows the output of the --list flat command, which displays all available benchmarks in a flat list format.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/console-args.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5\nBenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256\nBenchmarkDotNet.Samples.IntroArguments.Benchmark\nBenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument\nBenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments\nBenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf\nBenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf\nBenchmarkDotNet.Samples.IntroBasic.Sleep\n[...]\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results with RatioStyle.Value\nDESCRIPTION: Sample output table showing benchmark results with the default RatioStyle.Value, which displays raw ratio values (e.g., 0.15 or 1.15) compared to the baseline.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRatioStyle.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|   Method |       Mean |   Error |  StdDev | Ratio |\n|--------- |-----------:|--------:|--------:|------:|\n| Baseline | 1,000.3 ms | 2.71 ms | 0.15 ms |  1.00 |\n|      Bar |   150.6 ms | 1.67 ms | 0.09 ms |  0.15 |\n|      Foo | 1,150.6 ms | 7.41 ms | 0.41 ms |  1.15 |\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results as Compressed JSON Object - BenchmarkDotNet - json\nDESCRIPTION: This snippet is a single-line, compact JSON export of benchmark results in the same structure as the brief version but compressed for minimal file size or easy inlining in code. All benchmarking statistics and environment metadata are present. Inputs and outputs are identical to the brief JSON; only the serialization style differs. Limitation: Less readable by humans, but more efficient for transport or storage.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"Title\":\"MockSummary\",\"HostEnvironmentInfo\":{\"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\"BenchmarkDotNetVersion\":\"0.10.x-mock\",\"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\"PhysicalProcessorCount\":1,\"PhysicalCoreCount\":4,\"LogicalCoreCount\":8,\"RuntimeVersion\":\"Clr 4.0.x.mock\",\"Architecture\":\"64mock\",\"HasAttachedDebugger\":false,\"HasRyuJit\":true,\"Configuration\":\"CONFIGURATION\",\"DotNetCliVersion\":\"1.0.x.mock\",\"ChronometerFrequency\":{\"Hertz\":2531248},\"HardwareTimerKind\":\"Tsc\"},\"Benchmarks\":[{\"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Foo\",\"MethodTitle\":\"Foo\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}},{\"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Bar\",\"MethodTitle\":\"Bar\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}}]}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Summary using XmlExporter - XML\nDESCRIPTION: This snippet provides a pretty-printed XML export of a benchmark summary as produced by BenchmarkDotNet's XmlExporter. It contains environment details, details from multiple benchmarks, full statistical summaries, and custom metric definitions. To use this output, one should have completed a benchmark run using BenchmarkDotNet with the XmlExporter enabled; the XML can be parsed with any standard XML parser or post-processed for reporting. Key data includes environment metadata, benchmark method info, statistics (mean, stdev, percentiles), and custom metrics for 'CacheMisses'. The output is suitable for both human inspection and machine processing, but large or deeply-nested reports could be less readable.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n<Summary>\\n  <Title>MockSummary</Title>\\n  <HostEnvironmentInfo>\\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\\n    <PhysicalCoreCount>4</PhysicalCoreCount>\\n    <LogicalCoreCount>8</LogicalCoreCount>\\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\\n    <Architecture>64mock</Architecture>\\n    <HasAttachedDebugger>False</HasAttachedDebugger>\\n    <HasRyuJit>True</HasRyuJit>\\n    <Configuration>CONFIGURATION</Configuration>\\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\\n    <ChronometerFrequency>\\n      <Hertz>2531248</Hertz>\\n    </ChronometerFrequency>\\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\\n  </HostEnvironmentInfo>\\n  <Benchmarks>\\n    <BenchmarkCase>\\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\\n      <Type>MockBenchmarkClass</Type>\\n      <Method>Foo</Method>\\n      <MethodTitle>Foo</MethodTitle>\\n      <Statistics>\\n        <OriginalValues>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n        </OriginalValues>\\n        <N>6</N>\\n        <Min>1</Min>\\n        <LowerFence>1</LowerFence>\\n        <Q1>1</Q1>\\n        <Median>1</Median>\\n        <Mean>1</Mean>\\n        <Q3>1</Q3>\\n        <UpperFence>1</UpperFence>\\n        <Max>1</Max>\\n        <InterquartileRange>0</InterquartileRange>\\n        <StandardError>0</StandardError>\\n        <Variance>0</Variance>\\n        <StandardDeviation>0</StandardDeviation>\\n        <Skewness>NaN</Skewness>\\n        <Kurtosis>NaN</Kurtosis>\\n        <ConfidenceInterval>\\n          <N>6</N>\\n          <Mean>1</Mean>\\n          <StandardError>0</StandardError>\\n          <Level>L999</Level>\\n          <Margin>0</Margin>\\n          <Lower>1</Lower>\\n          <Upper>1</Upper>\\n        </ConfidenceInterval>\\n        <Percentiles>\\n          <P0>1</P0>\\n          <P25>1</P25>\\n          <P50>1</P50>\\n          <P67>1</P67>\\n          <P80>1</P80>\\n          <P85>1</P85>\\n          <P90>1</P90>\\n          <P95>1</P95>\\n          <P100>1</P100>\\n        </Percentiles>\\n      </Statistics>\\n      <Metrics>\\n        <Item>\\n          <Value>7</Value>\\n          <Descriptor>\\n            <Id>CacheMisses</Id>\\n            <DisplayName>CacheMisses</DisplayName>\\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\\n            <NumberFormat>N0</NumberFormat>\\n            <UnitType>Dimensionless</UnitType>\\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\\n            <PriorityInCategory>0</PriorityInCategory>\\n          </Descriptor>\\n        </Item>\\n      </Metrics>\\n      <Memory>\\n        <Gen0Collections>0</Gen0Collections>\\n        <Gen1Collections>0</Gen1Collections>\\n        <Gen2Collections>0</Gen2Collections>\\n        <TotalOperations>0</TotalOperations>\\n        <BytesAllocatedPerOperation />\\n      </Memory>\\n    </BenchmarkCase>\\n    <BenchmarkCase>\\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\\n      <Type>MockBenchmarkClass</Type>\\n      <Method>Bar</Method>\\n      <MethodTitle>Bar</MethodTitle>\\n      <Statistics>\\n        <OriginalValues>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n          <Item>1</Item>\\n        </OriginalValues>\\n        <N>6</N>\\n        <Min>1</Min>\\n        <LowerFence>1</LowerFence>\\n        <Q1>1</Q1>\\n        <Median>1</Median>\\n        <Mean>1</Mean>\\n        <Q3>1</Q3>\\n        <UpperFence>1</UpperFence>\\n        <Max>1</Max>\\n        <InterquartileRange>0</InterquartileRange>\\n        <StandardError>0</StandardError>\\n        <Variance>0</Variance>\\n        <StandardDeviation>0</StandardDeviation>\\n        <Skewness>NaN</Skewness>\\n        <Kurtosis>NaN</Kurtosis>\\n        <ConfidenceInterval>\\n          <N>6</N>\\n          <Mean>1</Mean>\\n          <StandardError>0</StandardError>\\n          <Level>L999</Level>\\n          <Margin>0</Margin>\\n          <Lower>1</Lower>\\n          <Upper>1</Upper>\\n        </ConfidenceInterval>\\n        <Percentiles>\\n          <P0>1</P0>\\n          <P25>1</P25>\\n          <P50>1</P50>\\n          <P67>1</P67>\\n          <P80>1</P80>\\n          <P85>1</P85>\\n          <P90>1</P90>\\n          <P95>1</P95>\\n          <P100>1</P100>\\n        </Percentiles>\\n      </Statistics>\\n      <Metrics>\\n        <Item>\\n          <Value>7</Value>\\n          <Descriptor>\\n            <Id>CacheMisses</Id>\\n            <DisplayName>CacheMisses</DisplayName>\\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\\n            <NumberFormat>N0</NumberFormat>\\n            <UnitType>Dimensionless</UnitType>\\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\\n            <PriorityInCategory>0</PriorityInCategory>\\n          </Descriptor>\\n        </Item>\\n      </Metrics>\\n      <Memory>\\n        <Gen0Collections>0</Gen0Collections>\\n        <Gen1Collections>0</Gen1Collections>\\n        <Gen2Collections>0</Gen2Collections>\\n        <TotalOperations>0</TotalOperations>\\n        <BytesAllocatedPerOperation />\\n      </Memory>\\n    </BenchmarkCase>\\n  </Benchmarks>\\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Main Program with BenchmarkSwitcher for Args Support\nDESCRIPTION: C# code showing how to properly pass command line arguments to BenchmarkSwitcher to enable runtime specification via command line.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args) \n        => BenchmarkSwitcher\n            .FromAssembly(typeof(Program).Assembly)\n            .Run(args); // crucial to make it work\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Benchmark Class Name\nDESCRIPTION: Command to create a benchmark project with a custom benchmark class name\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_6\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark -b Md5VsSha256\n```\n\n----------------------------------------\n\nTITLE: Configuring Project File for BenchmarkDotNet TestAdapter\nDESCRIPTION: Example of a .csproj file showing how to configure a project for BenchmarkDotNet with VSTest. It includes the necessary NuGet packages and configuration to disable auto-generated program file when using a custom entry point.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/vstest.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n    <!-- Disable entry point generation as this project has it's own entry point -->\n    <GenerateProgramFile>false</GenerateProgramFile>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"BenchmarkDotNet.TestAdapter\" Version=\"0.13.12\" />\n    <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.8.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Implementing Large Address Aware Benchmarks in C#\nDESCRIPTION: This code snippet demonstrates how to create benchmarks for testing Large Address Aware (LAA) capabilities in .NET applications using BenchmarkDotNet. It includes methods for allocating large arrays and checking memory constraints.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroLargeAddressAware.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroLargeAddressAware.cs](../../../samples/BenchmarkDotNet.Samples/IntroLargeAddressAware.cs)]\n```\n\n----------------------------------------\n\nTITLE: Applying STAThread Attribute in BenchmarkDotNet Benchmarks (C#)\nDESCRIPTION: This C# code defines a BenchmarkDotNet benchmark class `IntroStaThread`. It includes a benchmark method `WpfTextBlockMeasure` marked with `[Benchmark]` and `[System.STAThread]`. This setup ensures that the benchmark runs within a Single-Threaded Apartment (STA), which is necessary for benchmarking certain UI components like WPF's `TextBlock`. It depends on the `BenchmarkDotNet.Attributes` namespace and relevant UI framework namespaces (e.g., WPF).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroStaThread.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Placeholder for the actual code from ../../../samples/BenchmarkDotNet.Samples/IntroStaThread.cs\n// This file would typically contain:\n// using System;\n// using BenchmarkDotNet.Attributes;\n// Possibly using System.Windows, System.Windows.Controls for WPF example\n\n// namespace BenchmarkDotNet.Samples\n// {\n//     public class IntroStaThread\n//     {\n//         [Benchmark]\n//         [System.STAThread] // The key attribute\n//         public void BenchmarkRequiringStaThread()\n//         {\n//             // Code that needs STA thread, e.g., interacting with WPF/WinForms UI elements\n//             // Example: \n//             // var textBlock = new System.Windows.Controls.TextBlock { Text = \"Hello\" };\n//             // textBlock.Measure(new System.Windows.Size(double.PositiveInfinity, double.PositiveInfinity));\n//         }\n//     }\n// }\n\n[!code-csharp[IntroStaThread.cs](../../../samples/BenchmarkDotNet.Samples/IntroStaThread.cs)]\n```\n\n----------------------------------------\n\nTITLE: Detailed Benchmark Results and Configuration in JSON (BenchmarkDotNet)\nDESCRIPTION: This JSON object contains the comprehensive, structured output generated by a BenchmarkDotNet run. It details the benchmarking engine version, host environment specifics (runtime version, OS, CPU information), definitions for each benchmark ('Foo', 'Bar'), and nested arrays containing individual iteration results with measured values and units ('ns'). It also includes 'meta' information, potentially used for report generation or defining table structures.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default01.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"engine\": {\\n    \"name\": \"BenchmarkDotNet\",\\n    \"version\": \"0.1729.0-mock\"\\n  },\\n  \"host\": {\\n    \"runtimeVersion\": \"Clr 4.0.x.mock\",\\n    \"hasAttachedDebugger\": false,\\n    \"hasRyuJit\": true,\\n    \"configuration\": \"CONFIGURATION\",\\n    \"dotNetSdkVersion\": \"1.0.x.mock\",\\n    \"chronometerFrequency\": 2531248,\\n    \"hardwareTimerKind\": \"Tsc\",\\n    \"os\": {\\n      \"display\": \"Microsoft Windows NT 10.0.x.mock\"\\n    },\\n    \"cpu\": {\\n      \"processorName\": \"MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\",\\n      \"physicalProcessorCount\": 1,\\n      \"physicalCoreCount\": 4,\\n      \"logicalCoreCount\": 8,\\n      \"nominalFrequencyHz\": 3100000000,\\n      \"maxFrequencyHz\": 3100000000\\n    }\\n  },\\n  \"nested\": [\\n    {\\n      \"benchmark\": {\\n        \"type\": \"Bench\",\\n        \"method\": \"Foo\"\\n      },\\n      \"nested\": [\\n        {\\n          \"value\": 10,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 0\\n        },\\n        {\\n          \"value\": 11,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 1\\n        },\\n        {\\n          \"value\": 12,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 2\\n        }\\n      ]\\n    },\\n    {\\n      \"benchmark\": {\\n        \"type\": \"Bench\",\\n        \"method\": \"Bar\"\\n      },\\n      \"nested\": [\\n        {\\n          \"value\": 200,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 0\\n        },\\n        {\\n          \"value\": 201,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 1\\n        },\\n        {\\n          \"value\": 202,\\n          \"unit\": \"ns\",\\n          \"iterationIndex\": 2\\n        }\\n      ]\\n    }\\n  ],\\n  \"meta\": {\\n    \"table\": {\\n      \"columnDefinitions\": [\\n        {\\n          \"selector\": \".engine\",\\n          \"cloud\": \"primary\",\\n          \"isSelfExplanatory\": true,\\n          \"isAtomic\": true\\n        },\\n        {\\n          \"selector\": \".host.os\",\\n          \"cloud\": \"primary\",\\n          \"isSelfExplanatory\": true,\\n          \"isAtomic\": true\\n        },\\n        {\\n          \"selector\": \".host.cpu\",\\n          \"cloud\": \"primary\",\\n          \"isSelfExplanatory\": true,\\n          \"isAtomic\": true\\n        },\\n        {\\n          \"selector\": \".benchmark\",\\n          \"cloud\": \"secondary\"\\n        },\\n        {\\n          \"selector\": \".job\",\\n          \"cloud\": \"secondary\",\\n          \"compressed\": true\\n        },\\n        {\\n          \"selector\": \"=center\"\\n        },\\n        {\\n          \"selector\": \"=spread\"\\n        }\\n      ]\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Rank Column Output (Markdown)\nDESCRIPTION: This snippet shows the output of the IntroRankColumn benchmark. It displays the performance results of the Foo and Bar methods with different factors, including mean execution time, error, standard deviation, and three different rank representations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRankColumn.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n Method | Factor |     Mean |    Error |    StdDev | Rank | Rank | Rank |\n------- |------- |---------:|---------:|----------:|-----:|-----:|-----:|\n    Foo |      1 | 100.8 ms | 2.250 ms | 0.1272 ms |    1 |    I |    * |\n    Foo |      2 | 200.8 ms | 4.674 ms | 0.2641 ms |    2 |   II |   ** |\n    Bar |      1 | 200.9 ms | 2.012 ms | 0.1137 ms |    2 |   II |   ** |\n    Bar |      2 | 400.7 ms | 4.509 ms | 0.2548 ms |    3 |  III |  *** |\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Mock Summary XML Configuration\nDESCRIPTION: Complete XML structure containing benchmark results including host environment information, test configurations, statistics, metrics, and detailed measurements for mock benchmark methods Foo and Bar. The file includes system specifications, runtime details, and performance metrics like cache misses.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?><Summary><Title>MockSummary</Title><HostEnvironmentInfo><BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption><BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion><OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion><ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName><PhysicalProcessorCount>1</PhysicalProcessorCount><PhysicalCoreCount>4</PhysicalCoreCount><LogicalCoreCount>8</LogicalCoreCount><RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion><Architecture>64mock</Architecture><HasAttachedDebugger>False</HasAttachedDebugger><HasRyuJit>True</HasRyuJit><Configuration>CONFIGURATION</Configuration><DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion><ChronometerFrequency><Hertz>2531248</Hertz></ChronometerFrequency><HardwareTimerKind>Tsc</HardwareTimerKind></HostEnvironmentInfo><Benchmarks><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Foo</Method><MethodTitle>Foo</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory><Measurements><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>1</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>2</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>3</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>4</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>5</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>6</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement></Measurements></BenchmarkCase><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Bar</Method><MethodTitle>Bar</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory><Measurements><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>1</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>2</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>3</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>4</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>5</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement><Measurement><IterationMode>Workload</IterationMode><IterationStage>Result</IterationStage><LaunchIndex>1</LaunchIndex><IterationIndex>6</IterationIndex><Operations>1</Operations><Nanoseconds>1</Nanoseconds></Measurement></Measurements></BenchmarkCase></Benchmarks></Summary>\n```\n\n----------------------------------------\n\nTITLE: Structuring BenchmarkDotNet Results Data in JSON\nDESCRIPTION: This JSON object represents benchmark results generated by BenchmarkDotNet. It details performance measurements for methods 'Foo' and 'Bar' across various .NET runtime environments (netCoreApp31, netCoreApp50, net50, net60, net70, net80), including JIT compiler ('ryuJit') and processor affinity. Each measurement includes the value in nanoseconds ('ns') and the iteration index. The 'meta' section defines how this data might be presented in a table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default05.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"results\": [\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"netCoreApp31\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 14\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 131,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 132,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 133,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 136,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 137,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 138,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"netCoreApp50\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 15\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 151,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 152,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 153,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 156,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 157,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 158,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net50\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 16\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 161,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 162,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 163,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 166,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 167,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 168,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net60\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 17\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 171,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 172,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 173,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 176,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 177,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 178,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net70\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 18\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 181,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 182,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 183,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 186,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 187,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 188,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net80\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 19\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 191,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 192,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 193,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 196,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 197,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 198,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".engine\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.os\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.cpu\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".benchmark\",\n          \"cloud\": \"secondary\"\n        },\n        {\n          \"selector\": \".job\",\n          \"cloud\": \"secondary\",\n          \"compressed\": true\n        },\n        {\n          \"selector\": \"=center\"\n        },\n        {\n          \"selector\": \"=spread\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results to AsciiDoc\nDESCRIPTION: This snippet demonstrates the AsciiDoc output format generated by BenchmarkDotNet. It includes system environment details (OS, CPU, .NET Core SDK, CLR), benchmark job configuration (IterationCount, LaunchCount, WarmupCount), and a results table showing metrics (Mean, Error, StdDev, P67, CacheMisses) for the benchmarked methods 'Foo' and 'Bar'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: asciidoc\nCODE:\n```\n....\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n....\n[options=\"header\"]\n|===\n|Method  |Mean      |Error     |StdDev    |P67       |CacheMisses  \n|Foo     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\n|Bar     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\n|===\n```\n\n----------------------------------------\n\nTITLE: Selecting Baseline Across Methods and Jobs\nDESCRIPTION: Shows how to mark both a method and a job as baselines simultaneously in BenchmarkDotNet, allowing for more complex baseline comparisons.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TheBaselines\n{\n    [Benchmark(Baseline = true)]\n    public void Sleep100ms() => Thread.Sleep(TimeSpan.FromMilliseconds(100));\n    \n    [Benchmark]\n    public void Sleep50ms() => Thread.Sleep(TimeSpan.FromMilliseconds(50));\n}\n\nstatic void Main(string[] args)\n    => BenchmarkSwitcher\n        .FromTypes(new[] { typeof(TheBaselines) })\n        .Run(args,\n                DefaultConfig.Instance\n                    .With(Job.Core.AsBaseline())\n                    .With(Job.Clr.WithId(\"CLR 4.7.2\")));\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results as Brief JSON Object - BenchmarkDotNet - json\nDESCRIPTION: This snippet exports benchmarking results in a structured, brief JSON format. It includes metadata about the environment and detailed statistics for each benchmarked method. Dependencies include the .NET runtime and BenchmarkDotNet configuration for JSON exporting. The input is the set of executed benchmarks; output is a JSON file suitable for analysis or importing into other tools. The limitation is that only essential summary fields are included (some deeper detail omitted for brevity).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n   \\\"Title\\\":\\\"MockSummary\\\",\\n   \\\"HostEnvironmentInfo\\\":{\\n      \\\"BenchmarkDotNetCaption\\\":\\\"BenchmarkDotNet\\\",\\n      \\\"BenchmarkDotNetVersion\\\":\\\"0.10.x-mock\\\",\\n      \\\"OsVersion\\\":\\\"Microsoft Windows NT 10.0.x.mock\\\",\\n      \\\"ProcessorName\\\":\\\"MockIntel Core i7-6700HQ CPU 2.60GHz\\\",\\n      \\\"PhysicalProcessorCount\\\":1,\\n      \\\"PhysicalCoreCount\\\":4,\\n      \\\"LogicalCoreCount\\\":8,\\n      \\\"RuntimeVersion\\\":\\\"Clr 4.0.x.mock\\\",\\n      \\\"Architecture\\\":\\\"64mock\\\",\\n      \\\"HasAttachedDebugger\\\":false,\\n      \\\"HasRyuJit\\\":true,\\n      \\\"Configuration\\\":\\\"CONFIGURATION\\\",\\n      \\\"DotNetCliVersion\\\":\\\"1.0.x.mock\\\",\\n      \\\"ChronometerFrequency\\\":{\\n         \\\"Hertz\\\":2531248\\n      },\\n      \\\"HardwareTimerKind\\\":\\\"Tsc\\\"\\n   },\\n   \\\"Benchmarks\\\":[\\n      {\\n         \\\"DisplayInfo\\\":\\\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\\\",\\n         \\\"Namespace\\\":\\\"BenchmarkDotNet.Tests.Mocks\\\",\\n         \\\"Type\\\":\\\"MockBenchmarkClass\\\",\\n         \\\"Method\\\":\\\"Foo\\\",\\n         \\\"MethodTitle\\\":\\\"Foo\\\",\\n         \\\"Parameters\\\":\\\"\\\",\\n         \\\"FullName\\\":\\\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\\\",\\n         \\\"HardwareIntrinsics\\\":\\\"\\\",\\n         \\\"Statistics\\\":{\\n            \\\"OriginalValues\\\":[\\n               1,1,1,1,1,1\\n            ],\\n            \\\"N\\\":6,\\n            \\\"Min\\\":1,\\n            \\\"LowerFence\\\":1,\\n            \\\"Q1\\\":1,\\n            \\\"Median\\\":1,\\n            \\\"Mean\\\":1,\\n            \\\"Q3\\\":1,\\n            \\\"UpperFence\\\":1,\\n            \\\"Max\\\":1,\\n            \\\"InterquartileRange\\\":0,\\n            \\\"LowerOutliers\\\":[\\n               \\n            ],\\n            \\\"UpperOutliers\\\":[\\n               \\n            ],\\n            \\\"AllOutliers\\\":[\\n               \\n            ],\\n            \\\"StandardError\\\":0,\\n            \\\"Variance\\\":0,\\n            \\\"StandardDeviation\\\":0,\\n            \\\"Skewness\\\":\\\"\\\",\\n            \\\"Kurtosis\\\":\\\"\\\",\\n            \\\"ConfidenceInterval\\\":{\\n               \\\"N\\\":6,\\n               \\\"Mean\\\":1,\\n               \\\"StandardError\\\":0,\\n               \\\"Level\\\":12,\\n               \\\"Margin\\\":0,\\n               \\\"Lower\\\":1,\\n               \\\"Upper\\\":1\\n            },\\n            \\\"Percentiles\\\":{\\n               \\\"P0\\\":1,\\n               \\\"P25\\\":1,\\n               \\\"P50\\\":1,\\n               \\\"P67\\\":1,\\n               \\\"P80\\\":1,\\n               \\\"P85\\\":1,\\n               \\\"P90\\\":1,\\n               \\\"P95\\\":1,\\n               \\\"P100\\\":1\\n            }\\n         },\\n         \\\"Memory\\\":{\\n            \\\"Gen0Collections\\\":0,\\n            \\\"Gen1Collections\\\":0,\\n            \\\"Gen2Collections\\\":0,\\n            \\\"TotalOperations\\\":0,\\n            \\\"BytesAllocatedPerOperation\\\":null\\n         }\\n      },{\\n         \\\"DisplayInfo\\\":\\\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\\\",\\n         \\\"Namespace\\\":\\\"BenchmarkDotNet.Tests.Mocks\\\",\\n         \\\"Type\\\":\\\"MockBenchmarkClass\\\",\\n         \\\"Method\\\":\\\"Bar\\\",\\n         \\\"MethodTitle\\\":\\\"Bar\\\",\\n         \\\"Parameters\\\":\\\"\\\",\\n         \\\"FullName\\\":\\\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\\\",\\n         \\\"HardwareIntrinsics\\\":\\\"\\\",\\n         \\\"Statistics\\\":{\\n            \\\"OriginalValues\\\":[\\n               1,1,1,1,1,1\\n            ],\\n            \\\"N\\\":6,\\n            \\\"Min\\\":1,\\n            \\\"LowerFence\\\":1,\\n            \\\"Q1\\\":1,\\n            \\\"Median\\\":1,\\n            \\\"Mean\\\":1,\\n            \\\"Q3\\\":1,\\n            \\\"UpperFence\\\":1,\\n            \\\"Max\\\":1,\\n            \\\"InterquartileRange\\\":0,\\n            \\\"LowerOutliers\\\":[\\n               \\n            ],\\n            \\\"UpperOutliers\\\":[\\n               \\n            ],\\n            \\\"AllOutliers\\\":[\\n               \\n            ],\\n            \\\"StandardError\\\":0,\\n            \\\"Variance\\\":0,\\n            \\\"StandardDeviation\\\":0,\\n            \\\"Skewness\\\":\\\"\\\",\\n            \\\"Kurtosis\\\":\\\"\\\",\\n            \\\"ConfidenceInterval\\\":{\\n               \\\"N\\\":6,\\n               \\\"Mean\\\":1,\\n               \\\"StandardError\\\":0,\\n               \\\"Level\\\":12,\\n               \\\"Margin\\\":0,\\n               \\\"Lower\\\":1,\\n               \\\"Upper\\\":1\\n            },\\n            \\\"Percentiles\\\":{\\n               \\\"P0\\\":1,\\n               \\\"P25\\\":1,\\n               \\\"P50\\\":1,\\n               \\\"P67\\\":1,\\n               \\\"P80\\\":1,\\n               \\\"P85\\\":1,\\n               \\\"P90\\\":1,\\n               \\\"P95\\\":1,\\n               \\\"P100\\\":1\\n            }\\n         },\\n         \\\"Memory\\\":{\\n            \\\"Gen0Collections\\\":0,\\n            \\\"Gen1Collections\\\":0,\\n            \\\"Gen2Collections\\\":0,\\n            \\\"TotalOperations\\\":0,\\n            \\\"BytesAllocatedPerOperation\\\":null\\n         }\\n      }\\n   ]\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Config for Non-Optimized Assemblies\nDESCRIPTION: C# class implementing a custom configuration to allow running benchmarks with non-optimized assemblies by disabling the default optimization validation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/faq.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AllowNonOptimized : ManualConfig\n{\n    public AllowNonOptimized()\n    {\n        Add(JitOptimizationsValidator.DontFailOnError); // ALLOW NON-OPTIMIZED DLLS\n\n        Add(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default\n        Add(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default\n        Add(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Iteration Execution Implementation\nDESCRIPTION: Pseudocode detailing how a single iteration is executed, including setup, manual loop unrolling for method invocation, timing measurement, and cleanup.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n// every iteration invokes the method (invokeCount / unrollFactor) times\nMeasurement RunIteration(Method method, long invokeCount, long unrollFactor)\n{\n    IterationSetup();\n    MemoryCleanup();\n\n    var clock = Clock.Start();\n\n    for (long i = 0; i < invokeCount / unrollFactor; i++)\n    {\n        // we perform manual loop unrolling!!\n        method(); // 1st call\n        method(); // 2nd call\n\n        method(); // (unrollFactor - 1)'th call\n        method(); // unrollFactor'th call\n    }\n\n    var clockSpan = clock.GetElapsed();\n\n    IterationCleanup();\n    MemoryCleanup();\n\n    return Measurement(clockSpan);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameterized Benchmarks in C# with BenchmarkDotNet\nDESCRIPTION: This code snippet demonstrates how to create a parameterized benchmark using the [Params] attribute in BenchmarkDotNet. It defines a Benchmark method that uses two parameters, A and B, which are marked with [Params] to specify multiple values for each parameter.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParams.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[ParamsSource(nameof(ValuesForA))] public int A { get; set; }\n\n[Params(10, 20)] public int B { get; set; }\n\npublic IEnumerable<int> ValuesForA() => new[] { 100, 200 };\n\n[Benchmark]\npublic void Benchmark()\n{\n    Thread.Sleep(A + B);\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing BenchmarkDotNet Results for Bench.Foo Method on .NET 6.0\nDESCRIPTION: This snippet displays the benchmark results for the Foo method of the Bench class, running on .NET 6.0 with CPU affinity set to 17. The results include detailed host information and three iterations of the benchmark, with execution times ranging from 171 to 173 nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 17\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net60\n  .unit = ns\n  .value = 171\n```\n\n----------------------------------------\n\nTITLE: Comparing .NET 7 and .NET Framework 4.8.1 Benchmarks in BenchmarkDotNet\nDESCRIPTION: This snippet demonstrates benchmark results comparing .NET 7 and .NET Framework 4.8.1 runtimes on Arm64 architecture. It shows runtime information, benchmark method, and performance metrics including execution time and memory allocation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22622.575)\nMicrosoft SQ1 3.0 GHz, 1 CPU, 8 logical and 8 physical cores\n.NET SDK=7.0.100-preview.6.22352.1\n  [Host]     : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD\n  Job-QJVIDT : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD\n  Job-FNNXOY : .NET Framework 4.8.1 (4.8.9032.0), Arm64 RyuJIT\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with PlainExporter in plaintext\nDESCRIPTION: This snippet uses the PlainExporter to output detailed, raw benchmarking results in plain text for the Foo and Bar methods. It contains both individual per-iteration data and a statistical summary (mean, standard error, confidence intervals, histogram), targeting users who require granular insight into benchmark execution. Suitable for logs or environments where markdown or markup formatting is not supported. Output is consistent, with each method's results presented in sequence for easy manual analysis or further tooling.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\n*** MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15) ***\n* Raw *\nWorkloadResult   1: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   2: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   3: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   4: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   5: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   6: 1 op, 1.00 ns, 1.0000 ns/op\n\n* Statistics for WorkloadResult\nMean = 1.000 ns, StdErr = 0.000 ns (0.00%), N = 6, StdDev = 0.000 ns\nMin = 1.000 ns, Q1 = 1.000 ns, Median = 1.000 ns, Q3 = 1.000 ns, Max = 1.000 ns\nIQR = 0.000 ns, LowerFence = 1.000 ns, UpperFence = 1.000 ns\nConfidenceInterval = [1.000 ns; 1.000 ns] (CI 99.9%), Margin = 0.000 ns (0.00% of Mean)\nSkewness = NaN, Kurtosis = NaN, MValue = 2\n-------------------- Histogram --------------------\n[0.500 ns ; 1.500 ns) | @@@@@@\n---------------------------------------------------\n*** MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15) ***\n* Raw *\nWorkloadResult   1: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   2: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   3: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   4: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   5: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   6: 1 op, 1.00 ns, 1.0000 ns/op\n\n* Statistics for WorkloadResult\nMean = 1.000 ns, StdErr = 0.000 ns (0.00%), N = 6, StdDev = 0.000 ns\nMin = 1.000 ns, Q1 = 1.000 ns, Median = 1.000 ns, Q3 = 1.000 ns, Max = 1.000 ns\nIQR = 0.000 ns, LowerFence = 1.000 ns, UpperFence = 1.000 ns\nConfidenceInterval = [1.000 ns; 1.000 ns] (CI 99.9%), Margin = 0.000 ns (0.00% of Mean)\n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in Plain Text Format\nDESCRIPTION: A plain text representation of benchmark results, showing detailed raw workload data and statistics for each method. This format includes all individual measurement results and comprehensive statistical analysis.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n*** MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15) ***\n* Raw *\nWorkloadResult   1: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   2: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   3: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   4: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   5: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   6: 1 op, 1.00 ns, 1.0000 ns/op\n\n* Statistics for WorkloadResult\nMean = 1.000 ns, StdErr = 0.000 ns (0.00%), N = 6, StdDev = 0.000 ns\nMin = 1.000 ns, Q1 = 1.000 ns, Median = 1.000 ns, Q3 = 1.000 ns, Max = 1.000 ns\nIQR = 0.000 ns, LowerFence = 1.000 ns, UpperFence = 1.000 ns\nConfidenceInterval = [1.000 ns; 1.000 ns] (CI 99.9%), Margin = 0.000 ns (0.00% of Mean)\nSkewness = NaN, Kurtosis = NaN, MValue = 2\n-------------------- Histogram --------------------\n[0.500 ns ; 1.500 ns) | @@@@@@\n---------------------------------------------------\n*** MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15) ***\n* Raw *\nWorkloadResult   1: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   2: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   3: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   4: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   5: 1 op, 1.00 ns, 1.0000 ns/op\nWorkloadResult   6: 1 op, 1.00 ns, 1.0000 ns/op\n\n* Statistics for WorkloadResult\nMean = 1.000 ns, StdErr = 0.000 ns (0.00%), N = 6, StdDev = 0.000 ns\nMin = 1.000 ns, Q1 = 1.000 ns, Median = 1.000 ns, Q3 = 1.000 ns, Max = 1.000 ns\nIQR = 0.000 ns, LowerFence = 1.000 ns, UpperFence = 1.000 ns\nConfidenceInterval = [1.000 ns; 1.000 ns] (CI 99.9%), Margin = 0.000 ns (0.00% of Mean)\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Runtimes for Benchmark Execution in BenchmarkDotNet\nDESCRIPTION: Example of using the '--runtimes' or '-r' argument to run benchmarks on specific .NET runtimes (.NET 4.7.2 and .NET Core 2.1).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_6\n\nLANGUAGE: log\nCODE:\n```\ndotnet run -c Release -- --runtimes net472 netcoreapp2.1\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Flags for Mono AOT LLVM (Shell)\nDESCRIPTION: Shows the necessary command-line flags to configure BenchmarkDotNet for benchmarking with the Mono AOT LLVM runtime. It requires specifying the runtime type (`monoaotllvm`), the path to the AOT compiler, the path to the custom runtime pack, and optionally the AOT compiler mode (`mini` or `llvm`, defaulting to `mini`).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n--runtimes monoaotllvm\n--aotcompilerpath <path to mono aot compiler>\n--customruntimepack <path to runtime pack>\n```\n\nLANGUAGE: bash\nCODE:\n```\n--aotcompilermode <mini|llvm>\n```\n\n----------------------------------------\n\nTITLE: Using BenchmarkCategory Attribute in BenchmarkDotNet\nDESCRIPTION: This code sample demonstrates how to use the `[BenchmarkCategory]` attribute to categorize benchmarks and filter them by categories in BenchmarkDotNet.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategories.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroCategories.cs](../../../samples/BenchmarkDotNet.Samples/IntroCategories.cs)]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Default BenchmarkDotNet Configuration\nDESCRIPTION: Example of creating a custom default configuration class for BenchmarkDotNet that can be used with VSTest integration. This configuration adds a dry job, console logger, and disables JIT optimization validation errors.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/vstest.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyDefaultConfig : ManualConfig\n{\n    public MyDefaultConfig()\n    {\n        AddJob(Job.Dry);\n        AddLogger(Loggers.ConsoleLogger.Default);\n        AddValidator(JitOptimizationsValidator.DontFailOnError);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ParamsSource for Parameterized Benchmarks in C#\nDESCRIPTION: This code snippet demonstrates how to use the ParamsSource attribute to provide multiple parameter values for benchmarking. It defines a benchmark method that takes two parameters and uses Thread.Sleep to simulate work.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParamsSource.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Running;\n\nnamespace BenchmarkDotNet.Samples\n{\n    public class IntroParamsSource\n    {\n        [ParamsSource(nameof(ValuesForA))] public int A { get; set; }\n\n        [ParamsSource(nameof(ValuesForB))] public int B { get; set; }\n\n        public IEnumerable<int> ValuesForA => new[] { 100, 200 };\n\n        public IEnumerable<int> ValuesForB => new[] { 10, 20 };\n\n        [Benchmark]\n        public void Benchmark() => Thread.Sleep(A + B);\n\n        public static void Main(string[] args) => BenchmarkRunner.Run<IntroParamsSource>();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing BenchmarkDotNet Results for Bench.Bar Method on .NET 5.0\nDESCRIPTION: This snippet presents the benchmark results for the Bar method of the Bench class, running on .NET 5.0 with CPU affinity set to 16. The results include detailed host information and three iterations of the benchmark, with execution times ranging from 166 to 168 nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 16\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net50\n  .unit = ns\n  .value = 166\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results for .NET 7.0 vs NativeAOT 7.0 Comparison\nDESCRIPTION: This results table compares the Binary Trees benchmark between .NET 7.0 and NativeAOT 7.0 runtimes, showing execution time, performance ratio, and memory allocation. NativeAOT shows a 4% performance improvement over standard .NET.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n|        Method |       Runtime |     Mean | Ratio | Allocated |\n|-------------- |-------------- |---------:|------:|----------:|\n| BinaryTrees_2 |      .NET 7.0 | 95.06 ms |  1.00 | 227.33 MB |\n| BinaryTrees_2 | NativeAOT 7.0 | 90.32 ms |  0.96 | 227.33 MB |\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Test Results in Markdown Table\nDESCRIPTION: This code snippet shows a markdown table containing benchmark results for a method with different nullable boolean parameter values. It includes columns for the method name, parameter value, mean execution time, error, and standard deviation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithAllValuesOfNullableBool.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | ?             | 114.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | False         | 214.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | True          | 314.5 ns | 5.88 ns | 8.80 ns | ^\n```\n\n----------------------------------------\n\nTITLE: Benchmark Output for Complex Types Example in BenchmarkDotNet\nDESCRIPTION: Example output from running the benchmark with custom complex types. Demonstrates how the ToString() override affects the display names in the results table, showing the custom representation of complex parameters.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsSource.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | someClass | someStruct |     Mean | Error |\n|------- |---------- |----------- |---------:|------:|\n| Simple |  10 items |         10 | 887.2 us |    NA |\n| Simple |  15 items |         15 | 963.1 us |    NA |\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Foo Iteration 1 (Custom Format)\nDESCRIPTION: Captures the result data for the second iteration (index 1) of the 'Bench.Foo' benchmark. Details include the measured value (31 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: custom\nCODE:\n```\n[Entry1]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 31\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Benchmark with Sleep Example in C#\nDESCRIPTION: A simple benchmark example that demonstrates how BenchmarkDotNet executes time-consuming operations. This sample shows a benchmark that sleeps for 1 second, benefiting from the optimization that prevents multiple executions per iteration for long-running operations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Program\n{\n    static void Main() => BenchmarkRunner.Run<Program>();\n\n    [Benchmark]\n    public void Sleep1s() => Thread.Sleep(TimeSpan.FromSeconds(1));\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with MarkdownExporter-default in markdown\nDESCRIPTION: This snippet uses the MarkdownExporter-default to render BenchmarkDotNet performance results in standard markdown, creating a readable table of statistics for the Foo and Bar benchmark methods. It summarizes method means, errors, standard deviation, and hardware-related metrics. No external dependencies are needed to parse the output, which is pre-formatted for direct inclusion in markdown documentation. Outputs are human-readable with headers and alignment suited for reports and documentation purposes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n------- |---------:|---------:|---------:|---------:|------------:|\n Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Default Settings for Console Argument Parser in C#\nDESCRIPTION: This code snippet shows how to create a global configuration with custom default Job settings that can be overwritten by console arguments. It sets a default of one warmup iteration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/console-args.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Main(string[] args)\n    => BenchmarkSwitcher\n        .FromAssembly(typeof(Program).Assembly)\n        .Run(args, GetGlobalConfig());\n\nstatic IConfig GetGlobalConfig()\n    => DefaultConfig.Instance\n        .With(Job.Default\n            .WithWarmupCount(1)\n            .AsDefault()); // the KEY to get it working\n```\n\n----------------------------------------\n\nTITLE: Implementing BenchmarkDotNet UI in Xamarin.Forms (C#)\nDESCRIPTION: This code snippet demonstrates how to create a Xamarin.Forms UI for running BenchmarkDotNet benchmarks and displaying results on mobile platforms. It includes methods for benchmark execution, result formatting, and UI updates.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroXamarin.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Configs;\nusing BenchmarkDotNet.Engines;\nusing BenchmarkDotNet.Exporters;\nusing BenchmarkDotNet.Jobs;\nusing BenchmarkDotNet.Loggers;\nusing BenchmarkDotNet.Reports;\nusing BenchmarkDotNet.Running;\nusing Xamarin.Forms;\n\nnamespace BenchmarkDotNet.Samples.Forms\n{\n    public partial class MainPage : ContentPage\n    {\n        StringBuilder log = new StringBuilder();\n        AccumulationLogger logger = new AccumulationLogger();\n\n        public MainPage()\n        {\n            InitializeComponent();\n        }\n\n        private void Button_Clicked(object sender, EventArgs e)\n        {\n            log.Clear();\n            logger.Clear();\n            LogLabel.Text = string.Empty;\n\n            var config = ManualConfig.CreateEmpty()\n                .AddLogger(logger)\n                .AddJob(Job.Dry);\n\n            var summary = BenchmarkRunner.Run<IntroXamarinForm>(config);\n\n            // use logger if you want the same output as in BenchmarkDotNet.Reports.SummaryTable\n            // summary.Table.PrintLine(logger);\n\n            // use summary.Reports if you want to access raw data or customize the view\n            foreach (var report in summary.Reports)\n            {\n                log.AppendLine($\"Benchmark: {report.BenchmarkCase.DisplayInfo}\\n\");\n\n                log.AppendLine(\"Average time:\");\n                log.AppendLine($\"{report.ResultStatistics.Mean} ns\");\n\n                log.AppendLine(\"\\nOperations per second:\");\n                log.AppendLine($\"{report.ResultStatistics.OpsPerSecond:n2}\");\n\n                log.AppendLine(\"\\nAllocation size per single operation:\");\n                log.AppendLine($\"{report.GcStats.BytesAllocatedPerOperation:n2} bytes\");\n\n                log.AppendLine();\n            }\n\n            LogLabel.Text = log.ToString();\n        }\n    }\n\n    [MemoryDiagnoser]\n    public class IntroXamarinForm\n    {\n        [Benchmark]\n        public void Sleep10() => System.Threading.Thread.Sleep(10);\n\n        [Benchmark]\n        public void Sleep20() => System.Threading.Thread.Sleep(20);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mann-Whitney U Test in C# with BenchmarkDotNet\nDESCRIPTION: This code demonstrates how to use BenchmarkDotNet to run Mann-Whitney U tests comparing performance across different .NET runtimes. It includes a sample benchmark class with two methods: one that sleeps for different durations based on the runtime, and another that sleeps for a constant duration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.3.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\n}\n\npublic class MySample\n{\n    [Benchmark]\n    public void Sleep()\n    {\n#if NETFRAMEWORK\n        Thread.Sleep(50);\n#elif NETCOREAPP2_0\n        Thread.Sleep(45);\n#elif NETCOREAPP2_1\n        Thread.Sleep(55);\n#endif\n    }\n    \n    [Benchmark]\n    public void Same() => Thread.Sleep(50);\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing BenchmarkDotNet Result Entries in Config Format\nDESCRIPTION: Structured benchmark results from BenchmarkDotNet showing performance metrics for the Bench class with its Foo and Bar methods. Each entry contains detailed information about the test environment, CPU specifications, runtime configuration, and measured values in nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: config\nCODE:\n```\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 11\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp21\n  .unit = ns\n  .value = 117\n```\n\n----------------------------------------\n\nTITLE: Reporting BenchmarkDotNet Results - JSON\nDESCRIPTION: This JSON snippet represents the structure and content of a typical BenchmarkDotNet output file, capturing benchmark results for multiple methods and their runtime performance on a specified host and job configuration. Dependencies include BenchmarkDotNet (version 0.1729.0-mock), and the report is generated when running benchmarks via BenchmarkDotNet in a .NET 7.0 environment. Main parameters specify the benchmarked type and method, job runtime, JIT compiler, and detailed measurements for each method and iteration. Inputs are not required for this output; rather, it serves as a data structure for reporting. Outputs include nested details on environment, benchmarks, and summary tables. The format is primarily for data exchange, reporting, or visualization and may be parsed by .NET tools or other applications.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default03.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"engine\": {\n    \"name\": \"BenchmarkDotNet\",\n    \"version\": \"0.1729.0-mock\"\n  },\n  \"host\": {\n    \"runtimeVersion\": \"Clr 4.0.x.mock\",\n    \"hasAttachedDebugger\": false,\n    \"hasRyuJit\": true,\n    \"configuration\": \"CONFIGURATION\",\n    \"dotNetSdkVersion\": \"1.0.x.mock\",\n    \"chronometerFrequency\": 2531248,\n    \"hardwareTimerKind\": \"Tsc\",\n    \"os\": {\n      \"display\": \"Microsoft Windows NT 10.0.x.mock\"\n    },\n    \"cpu\": {\n      \"processorName\": \"MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\",\n      \"physicalProcessorCount\": 1,\n      \"physicalCoreCount\": 4,\n      \"logicalCoreCount\": 8,\n      \"nominalFrequencyHz\": 3100000000,\n      \"maxFrequencyHz\": 3100000000\n    }\n  },\n  \"nested\": [\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net70\",\n          \"jit\": \"ryuJit\"\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 30,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 31,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 32,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 40,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 41,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 42,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".engine\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.os\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.cpu\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".benchmark\",\n          \"cloud\": \"secondary\"\n        },\n        {\n          \"selector\": \".job\",\n          \"cloud\": \"secondary\",\n          \"compressed\": true\n        },\n        {\n          \"selector\": \"=center\"\n        },\n        {\n          \"selector\": \"=spread\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement with Unrolling for Ref Readonly Methods in C#\nDESCRIPTION: Measures benchmarking overhead for methods returning `ref readonly T`, with loop unrolling. It calls the `overheadDelegate` repeatedly (`invokeCount` times), storing the result. The `@Unroll@` placeholder is expanded during code generation. `AggressiveOptimizationOption` encourages JIT optimization, and `KeepAliveWithoutBoxing` ensures the result variable is used.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        value = overheadDelegate($PassArguments$);@Unroll@\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement with Unrolling for Ref-Returning Methods in C#\nDESCRIPTION: Executes the actual benchmark workload for methods returning by reference (`ref T`), with loop unrolling. It calls the `workloadDelegate` `invokeCount` times, assigning the returned reference to an alias (`alias`) pointing to `workloadDefaultValueHolder`. The `@Unroll@` placeholder enables loop unrolling. `KeepAliveWithoutBoxing` is called with the `ref alias` to prevent dead code elimination.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        alias = workloadDelegate($PassArguments$);@Unroll@\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);\n}\n```\n\n----------------------------------------\n\nTITLE: Passing ReadOnlySpan Arguments to Benchmarks\nDESCRIPTION: Example showing how BenchmarkDotNet supports various argument passing scenarios, including passing a string that gets implicitly cast to a ReadOnlySpan<char>.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WithStringToReadOnlySpan\n{\n    [Benchmark]\n    [Arguments(\"some string\")]\n    public void AcceptsReadOnlySpan(ReadOnlySpan<char> notString)\n}\n```\n\n----------------------------------------\n\nTITLE: Command-Line Setup for WebAssembly Prerequisites on Ubuntu\nDESCRIPTION: This is a series of shell commands to install prerequisites for running WebAssembly benchmarks on Ubuntu. It includes installing Node.js, jsvu for JavaScript engines, and Emscripten for WebAssembly compilation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_18\n\nLANGUAGE: cmd\nCODE:\n```\ncurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -\nsudo apt install nodejs\n```\n\nLANGUAGE: cmd\nCODE:\n```\nnpm install jsvu -g\n```\n\nLANGUAGE: cmd\nCODE:\n```\nexport PATH=\"${HOME}/.jsvu:${PATH}\"\n```\n\nLANGUAGE: cmd\nCODE:\n```\njsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8\n```\n\nLANGUAGE: cmd\nCODE:\n```\ngit clone https://github.com/emscripten-core/emsdk.git\ncd emsdk\n./emsdk install latest\n./emsdk activate latest\nsource ./emsdk_env.sh\n```\n\nLANGUAGE: cmd\nCODE:\n```\nexport EMSDK_PATH=$EMSDK\n```\n\nLANGUAGE: cmd\nCODE:\n```\ngit clone https://github.com/dotnet/runtime\ncd runtime\n```\n\nLANGUAGE: cmd\nCODE:\n```\nsudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev\n```\n\nLANGUAGE: cmd\nCODE:\n```\n./build.sh --arch wasm --os Browser -c release\n```\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net7.0 --runtimes nativeaot7.0 --ilcPackages D:\\projects\\runtime\\artifacts\\packages\\Release\\Shipping\\\n```\n\nLANGUAGE: cmd\nCODE:\n```\ncd D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ\ncat .\\BenchmarkDotNet.Autogenerated.csproj\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks With Memory Randomization\nDESCRIPTION: Command line example showing how to run a benchmark with memory randomization enabled, which better simulates real-world performance variability.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_5\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true\n```\n\n----------------------------------------\n\nTITLE: Generic Benchmarks in BenchmarkDotNet\nDESCRIPTION: Demonstration of BenchmarkDotNet's support for generic benchmarks using GenericTypeArguments attribute to specify which types should be used as generic arguments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[GenericTypeArguments(typeof(int))]\n[GenericTypeArguments(typeof(char))]\npublic class IntroGenericTypeArguments<T>\n{\n    [Benchmark] public T Create() => Activator.CreateInstance<T>();\n}\n```\n\n----------------------------------------\n\nTITLE: Disassembly of Sum method in .NET Core 2.1.0 with 64-bit RyuJIT\nDESCRIPTION: Assembly code generated by the .NET Core 2.1.0 64-bit RyuJIT compiler for the Sum method in IntroDisassembly class. This version uses SSE/AVX instructions (vxorps, vcvtsi2sd, vaddsd) for floating-point operations, showing how modern JIT compilers leverage SIMD instructions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassembly.md#2025-04-22_snippet_1\n\nLANGUAGE: x86asm\nCODE:\n```\n; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT\n00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum()\nIL_0000: ldc.r8 0\nIL_0009: stloc.0\n00007ffa`6c621323 c4e17857c0      vxorps  xmm0,xmm0,xmm0\nIL_000a: ldc.i4.0\nIL_000b: stloc.1\nIL_000c: br.s IL_0017\n00007ffa`6c621328 33c0            xor     eax,eax\nIL_000e: ldloc.0\nIL_000f: ldloc.1\nIL_0010: conv.r8\nIL_0011: add\nIL_0012: stloc.0\n00007ffa`6c62132a c4e17057c9      vxorps  xmm1,xmm1,xmm1\n00007ffa`6c62132f c4e1732ac8      vcvtsi2sd xmm1,xmm1,eax\n00007ffa`6c621334 c4e17b58c1      vaddsd  xmm0,xmm0,xmm1\nIL_0013: ldloc.1\nIL_0014: ldc.i4.1\nIL_0015: add\nIL_0016: stloc.1\n00007ffa`6c621339 ffc0            inc     eax\nIL_0017: ldloc.1\nIL_0018: ldc.i4.s 64\nIL_001a: blt.s IL_000e\n00007ffa`6c62133b 83f840          cmp     eax,40h\n00007ffa`6c62133e 7cea            jl      00007ffa`6c62132a\nIL_001c: ldloc.0\nIL_001d: ret\n00007ffa`6c621340 c3              ret\n```\n\n----------------------------------------\n\nTITLE: Sample Benchmark Output in Markdown\nDESCRIPTION: Shows the output format of a benchmark using the Monitoring strategy, including individual result timings and a summary statistics table.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroMonitoring.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nResult       1: 1 op, 61552600.00 ns, 61.5526 ms/op\nResult       2: 1 op, 10141700.00 ns, 10.1417 ms/op\nResult       3: 1 op, 10482900.00 ns, 10.4829 ms/op\nResult       4: 1 op, 50410900.00 ns, 50.4109 ms/op\nResult       5: 1 op, 10421400.00 ns, 10.4214 ms/op\nResult       6: 1 op, 20556100.00 ns, 20.5561 ms/op\nResult       7: 1 op, 70473200.00 ns, 70.4732 ms/op\nResult       8: 1 op, 50581700.00 ns, 50.5817 ms/op\nResult       9: 1 op, 10559000.00 ns, 10.5590 ms/op\nResult      10: 1 op, 70496300.00 ns, 70.4963 ms/op\n\n| Method |     Mean |    Error |   StdDev |      Min |       Q1 |       Q3 |      Max |\n|------- |---------:|---------:|---------:|---------:|---------:|---------:|---------:|\n|    Foo | 36.57 ms | 40.03 ms | 26.47 ms | 10.14 ms | 10.48 ms | 61.55 ms | 70.50 ms |\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results as AsciiDoc Table - BenchmarkDotNet - asciidoc\nDESCRIPTION: This snippet shows a BenchmarkDotNet summary exported as an AsciiDoc table, including environment information, job configuration, and performance results per method. It requires BenchmarkDotNet to be configured with the AsciiDocExporter option and outputs human-readable, tabular data that can be embedded in AsciiDoc documentation. The input is a set of benchmark results, and the output is a formatted table for documentation or reports. Some minor limitations include static column structure and truncation of complex data structures.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: asciidoc\nCODE:\n```\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\\n.NET Core SDK 1.0.x.mock\\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\\n\\nJob=LongRun  IterationCount=100  LaunchCount=3  \\nWarmupCount=15  \\n[options=\\\"header\\\"]\\n|===\\n|Method  |Mean      |Error     |StdDev    |P67       |CacheMisses  \\n|Foo     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\\n|Bar     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\\n|===\\n\n```\n\n----------------------------------------\n\nTITLE: Holder Field for By-Ref Workload Results in C#\nDESCRIPTION: A private field used to store the result of a benchmarked method that returns by reference (`ref T`). This field acts as a target for the reference returned by the `workloadDelegate` within the workload action methods.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nprivate $WorkloadMethodReturnType$ workloadDefaultValueHolder = default($WorkloadMethodReturnType$);\n```\n\n----------------------------------------\n\nTITLE: Handling OutOfMemoryException in BenchmarkDotNet\nDESCRIPTION: Error message displayed by BenchmarkDotNet when a benchmark causes memory overflow due to side-effects like memory leaks. The message advises redesigning the benchmark using techniques like OperationsPerInvoke, IterationSetup, and IterationCleanup, or reducing invocations with ShortRunJob.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroNativeMemory.md#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nOutOfMemoryException!\nBenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.\nIf your benchmark allocates memory and keeps it alive, you are creating a memory leak.\nYou should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.\n```\n\n----------------------------------------\n\nTITLE: Defining and Executing Mono AOT Compilation Process\nDESCRIPTION: Implements the AOT compilation process that runs after the build is complete. This target determines platform-specific settings, identifies assemblies for AOT compilation, and executes the MonoAOTCompiler task to generate optimized native code for better benchmark performance.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_5\n\nLANGUAGE: XML\nCODE:\n```\n<UsingTask TaskName=\"MonoAOTCompiler\" AssemblyFile=\"$(PkgMicrosoft_NET_Runtime_MonoAOTCompiler_Task)/MonoAOTCompiler.dll\" /> \n\n  <Target Name=\"AotApp\" AfterTargets=\"Build\" DependsOnTargets=\"Publish\">\n\n   <PropertyGroup>\n      <PublishDirFullPath>$([System.IO.Path]::GetFullPath($(PublishDir)))</PublishDirFullPath>\n      <SharedLibraryType Condition=\"$([MSBuild]::IsOSPlatform('OSX'))\">Dylib</SharedLibraryType>\n      <SharedLibraryType Condition=\"$([MSBuild]::IsOSPlatform('Windows'))\">Dll</SharedLibraryType>\n      <SharedLibraryType Condition=\"'$(SharedLibraryType)' == ''\">So</SharedLibraryType>\n   </PropertyGroup>\n\n   <ItemGroup>\n     <AotInputAssemblies Include=\"$(PublishDirFullPath)\\*.dll\">\n        <AotArguments>mcpu=native</AotArguments>\n     </AotInputAssemblies>\n   </ItemGroup>\n\n\n   <MonoAOTCompiler\n        CompilerBinaryPath=\"$COMPILERBINARYPATH$\"\n        Mode=\"Normal\"\n        OutputType=\"Library\"\n        LibraryFormat=\"$(SharedLibraryType)\"\n        Assemblies=\"@(AotInputAssemblies)\"\n        UseLLVM=\"$USELLVM$\"\n        LLVMPath=\"$(MicrosoftNetCoreAppRuntimePackDir)\\runtimes\\$(RuntimeIdentifier)\\native\"\n        OutputDir=\"$(PublishDir)\"\n        UseAotDataFile=\"false\"\n        IntermediateOutputPath=\"$(IntermediateOutputPath)\">\n        <Output TaskParameter=\"CompiledAssemblies\" ItemName=\"BundleAssemblies\" />\n    </MonoAOTCompiler>\n\n   <Message Text=\"CompiledAssemblies: $(BundleAssemblies)\" Importance=\"high\"/>\n\n   </Target>\n```\n\n----------------------------------------\n\nTITLE: BenchmarkSwitcher with Console Arguments Support\nDESCRIPTION: Shows how to enable console arguments support in BenchmarkDotNet by passing command-line args to the BenchmarkSwitcher, which allows filtering and configuring benchmarks from the command line.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args) \n        => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Sample Console Application for BenchmarkDotNet Disassembler in C#\nDESCRIPTION: A sample console application that executes code to be disassembled and provides the necessary arguments for attaching the disassembler. It includes a benchmark method and helper that will be jitted, then keeps the application running to allow for disassembler attachment.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/disassembler.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Sample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var result = Benchmark(); // execute the benchmark do method gets jitted\n\n            Console.WriteLine(\n            $\"{Process.GetCurrentProcess().Id} \" +   // process Id\n                $\"\\\"{typeof(Program).FullName}\\\" \" + // full type name\n                $\"{nameof(Benchmark)} \" +            // benchmarked method name\n                $\"{bool.FalseString} \" +             // print Source\n                \"2 \" +                               // recursive depth\n                $\"{Path.GetTempFileName()}.xml\");    // result xml file path\n\n            while(true)\n            {\n                Console.WriteLine(\"Press Ctrl+C to kill the process\");\n                Console.ReadLine(); // block the exe, attach with Disassembler now\n            }\n\n            GC.KeepAlive(result);\n        }\n\n        public static IntPtr Benchmark()\n        {\n            return new IntPtr(42).Multiply(4);\n        }\n    }\n\n    public static class IntPtrHelper\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public unsafe static IntPtr Multiply(this IntPtr a, int factor)\n        {\n            return (sizeof(IntPtr) == sizeof(int))\n                ? new IntPtr((int)a * factor)\n                : new IntPtr((long)a * factor);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Cold Start Results in Markdown\nDESCRIPTION: This snippet shows the raw output of a cold start benchmark, displaying individual run results with operation counts, nanosecond durations, and seconds per operation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroColdStart.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nResult       1: 1 op, 1002034900.00 ns, 1.0020 s/op\nResult       2: 1 op, 10219700.00 ns, 10.2197 ms/op\nResult       3: 1 op, 10406200.00 ns, 10.4062 ms/op\nResult       4: 1 op, 10473900.00 ns, 10.4739 ms/op\nResult       5: 1 op, 10449400.00 ns, 10.4494 ms/op\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Runtime Benchmarks with Attributes\nDESCRIPTION: C# code demonstrating how to use SimpleJobAttribute to configure benchmarks for multiple .NET runtimes in the benchmark class.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Jobs;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [SimpleJob(RuntimeMoniker.Net48)]\n    [SimpleJob(RuntimeMoniker.Mono)]\n    [SimpleJob(RuntimeMoniker.NetCoreApp21)]\n    [SimpleJob(RuntimeMoniker.NetCoreApp30)]\n    public class TheClassWithBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Enabling EtwProfiler Programmatically in C#\nDESCRIPTION: C# code snippet showing how to enable the EtwProfiler by extending the DefaultConfig.Instance with a new instance of EtwProfiler. This approach allows for programmatic configuration of the profiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/etwprofiler.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args)\n        => BenchmarkSwitcher\n            .FromAssembly(typeof(Program).Assembly)\n            .Run(args,\n                DefaultConfig.Instance\n                    .AddDiagnoser(new EtwProfiler())); // HERE\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Statistical Test Results in Markdown\nDESCRIPTION: The output block represents statistical test results from the sample benchmarking script. The key metrics include the mean, error, standard deviation, and performance ratios as evaluated by different statistical tests such as Welch and MannWhitney. These values help in determining if a change in code impacts the performance significantly.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroStatisticalTesting.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|   Method |      Mean |     Error |    StdDev | Ratio |   Welch(1us)/p-values |    Welch(3%)/p-values | MannWhitney(1us)/p-values | MannWhitney(3%)/p-values |\n|--------- |----------:|----------:|----------:|------:|---------------------- |---------------------- |-------------------------- |------------------------- |\n|  Sleep50 |  53.13 ms | 0.5901 ms | 0.1532 ms |  0.51 | Faster: 1.0000/0.0000 | Faster: 1.0000/0.0000 |     Faster: 1.0000/0.0040 |    Faster: 1.0000/0.0040 |\n|  Sleep97 | 100.07 ms | 0.9093 ms | 0.2361 ms |  0.97 | Faster: 1.0000/0.0000 |   Same: 1.0000/0.1290 |     Faster: 1.0000/0.0040 |      Same: 1.0000/0.1111 |\n|  Sleep99 | 102.23 ms | 2.4462 ms | 0.6353 ms |  0.99 | Faster: 0.9928/0.0072 |   Same: 1.0000/0.9994 |     Faster: 0.9960/0.0079 |      Same: 1.0000/1.0000 |\n| Sleep100 | 103.34 ms | 0.8180 ms | 0.2124 ms |  1.00 |   Base: 0.5029/0.5029 |   Base: 1.0000/1.0000 |       Base: 0.7262/0.7262 |      Base: 1.0000/1.0000 |\n| Sleep101 | 103.73 ms | 2.1591 ms | 0.5607 ms |  1.00 |   Same: 0.1041/0.8969 |   Same: 0.9999/1.0000 |       Same: 0.1111/0.9246 |      Same: 1.0000/1.0000 |\n| Sleep103 | 106.21 ms | 1.2511 ms | 0.3249 ms |  1.03 | Slower: 0.0000/1.0000 |   Same: 0.9447/1.0000 |     Slower: 0.0040/1.0000 |      Same: 0.9246/1.0000 |\n| Sleep150 | 153.16 ms | 3.4929 ms | 0.9071 ms |  1.48 | Slower: 0.0000/1.0000 | Slower: 0.0000/1.0000 |     Slower: 0.0040/1.0000 |    Slower: 0.0040/1.0000 |\n\n// * Legends *\n  Mean                      : Arithmetic mean of all measurements\n  Error                     : Half of 99.9% confidence interval\n  StdDev                    : Standard deviation of all measurements\n  Ratio                     : Mean of the ratio distribution ([Current]/[Baseline])\n  Welch(1us)/p-values       : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'\n  Welch(3%)/p-values        : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'\n  MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'\n  MannWhitney(3%)/p-values  : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'\n  1 ms                      : 1 Millisecond (0.001 sec)\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results as HTML Report - BenchmarkDotNet - html\nDESCRIPTION: This snippet demonstrates exporting BenchmarkDotNet results to an HTML report. The markup contains sections for environment and job setup, styled tables for the method results, and mock data displayed for two methods. Output is suitable for sharing or presenting on the web, with dependencies on a browser for viewing and optional CSS tweaks. Inputs are provided via BenchmarkDotNet runtime; outputs are static, styled HTML files. Some limitations are a fixed table format and basic CSS.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\\n<html lang='en'>\\n<head>\\n<meta charset='utf-8' />\\n<title>MockSummary</title>\\n\\n<style type=\\\"text/css\\\">\\n\\ttable { border-collapse: collapse; display: block; width: 100%; overflow: auto; }\\n\\ttd, th { padding: 6px 13px; border: 1px solid #ddd; text-align: right; }\\n\\ttr { background-color: #fff; border-top: 1px solid #ccc; }\\n\\ttr:nth-child(even) { background: #f8f8f8; }\\n</style>\\n</head>\\n<body>\\n<pre><code>\\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\\n.NET Core SDK 1.0.x.mock\\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\\n</code></pre>\\n<pre><code>Job=LongRun  IterationCount=100  LaunchCount=3  \\nWarmupCount=15  \\n</code></pre>\\n\\n<table>\\n<thead><tr><th>Method</th><th>Mean</th><th>Error</th><th>StdDev</th><th>P67</th><th>CacheMisses</th>\\n</tr>\\n</thead><tbody><tr><td>Foo</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\\n</tr><tr><td>Bar</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\\n</tr></tbody></table>\\n</body>\\n</html>\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Properties for BenchmarkDotNet Self-Contained Executable\nDESCRIPTION: Defines the output and runtime configuration properties for the benchmark executable. This includes setting the target framework, runtime identifier, assembly name, and enabling self-contained deployment with unsafe code support.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <OutputPath>bin</OutputPath>\n    <TargetFramework>$TFM$</TargetFramework>\n    <MicrosoftNetCoreAppRuntimePackDir>$RUNTIMEPACK$</MicrosoftNetCoreAppRuntimePackDir>\n    <RuntimeIdentifier>$RUNTIMEIDENTIFIER$</RuntimeIdentifier>\n    <EnableTargetingPackDownload>false</EnableTargetingPackDownload>\n    <PublishTrimmed>false</PublishTrimmed>\n    <AssemblyName>$PROGRAMNAME$</AssemblyName>\n    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <StartupObject>BenchmarkDotNet.Autogenerated.UniqueProgramName</StartupObject>\n    <SelfContained>true</SelfContained>\n    <!-- Suppress warning for nuget package used in old (unsupported) tfm. -->\n    <SuppressTfmSupportBuildWarnings>true</SuppressTfmSupportBuildWarnings>\n  </PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Baselines with Categories in C#\nDESCRIPTION: This code snippet demonstrates how to use the [GroupBenchmarksBy] attribute and [Benchmark] attribute with Baseline property to define multiple baselines in different categories. It includes methods for both 'Fast' and 'Slow' categories with varying execution times.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategoryBaseline.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]\npublic class IntroCategoryBaseline\n{\n    [Benchmark(Baseline = true)]\n    [BenchmarkCategory(\"Fast\")]\n    public void Time50() => Thread.Sleep(50);\n\n    [Benchmark]\n    [BenchmarkCategory(\"Fast\")]\n    public void Time100() => Thread.Sleep(100);\n\n    [Benchmark(Baseline = true)]\n    [BenchmarkCategory(\"Slow\")]\n    public void Time550() => Thread.Sleep(550);\n\n    [Benchmark]\n    [BenchmarkCategory(\"Slow\")]\n    public void Time600() => Thread.Sleep(600);\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet XML Export Template Structure in XML\nDESCRIPTION: A comprehensive XML template for BenchmarkDotNet that captures benchmark results including host environment information, benchmark cases, statistics, metrics, memory usage, and detailed measurements. This structure represents the full export format of benchmark data.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_7\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks for Specific Frameworks via Command Line\nDESCRIPTION: Command line examples demonstrating how to run benchmarks for different .NET frameworks by specifying the framework with the -f parameter.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_3\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1\ndotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0\ndotnet run -c Release -f net48         # is going to run the benchmarks using .NET 4.8\nmono $pathToExe                        # is going to run the benchmarks using Mono from your PATH\n```\n\n----------------------------------------\n\nTITLE: Histogram Output With Memory Randomization\nDESCRIPTION: Output showing the performance histogram of a benchmark with memory randomization enabled, demonstrating a more varied distribution that better reflects real-world scenarios.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n-------------------- Histogram --------------------\n[108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@\n[213.537 ns ; 315.458 ns) |\n[315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@\n[446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@\n---------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Default Job Settings in BenchmarkDotNet\nDESCRIPTION: C# code example showing how to set custom default job settings programmatically with the option to override them using command-line arguments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nstatic void Main(string[] args)\n    => BenchmarkSwitcher\n        .FromAssembly(typeof(Program).Assembly)\n        .Run(args, GetGlobalConfig());\n\nstatic IConfig GetGlobalConfig()\n    => DefaultConfig.Instance\n        .With(Job.Default\n            .WithWarmupCount(1)\n            .AsDefault()); // the KEY to get it working\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results in Markdown Table\nDESCRIPTION: This markdown snippet shows the output of the benchmark results in a table format. It includes columns for Method, Categories, Mean, Error, StdDev, and Ratio, demonstrating the performance differences between the baseline and other methods in each category.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategoryBaseline.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|  Method | Categories |      Mean |     Error |    StdDev | Ratio |\n|-------- |----------- |----------:|----------:|----------:|------:|\n|  Time50 |       Fast |  50.46 ms | 0.0745 ms | 0.0697 ms |  1.00 |\n| Time100 |       Fast | 100.47 ms | 0.0955 ms | 0.0893 ms |  1.99 |\n|         |            |           |           |           |       |\n| Time550 |       Slow | 550.48 ms | 0.0525 ms | 0.0492 ms |  1.00 |\n| Time600 |       Slow | 600.45 ms | 0.0396 ms | 0.0331 ms |  1.09 |\n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in GitHub Markdown Format\nDESCRIPTION: A markdown representation of benchmark results optimized for GitHub display. This format uses GitHub-specific markdown fenced code blocks to present the benchmark data with proper syntax highlighting.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n```\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n```\n| Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n|------- |---------:|---------:|---------:|---------:|------------:|\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement without Unrolling for Ref Readonly Methods in C#\nDESCRIPTION: Measures benchmarking overhead for methods returning `ref readonly T`, without loop unrolling. It calls the `overheadDelegate` `invokeCount` times in a standard loop. `AggressiveOptimizationOption` is applied, and `KeepAliveWithoutBoxing` prevents the result from being optimized away.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        value = overheadDelegate($PassArguments$);\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Category Discoverer in BenchmarkDotNet\nDESCRIPTION: This code sample shows how to create a custom ICategoryDiscoverer implementation to override BenchmarkDotNet's default category discovery strategy. The sample defines a BenchmarkCategory enum and a CustomCategoryDiscoverer that adds 'All' to all benchmarks and uses method names to determine additional categories.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategoryDiscoverer.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroCategoryDiscoverer.cs](../../../samples/BenchmarkDotNet.Samples/IntroCategoryDiscoverer.cs)]\n```\n\n----------------------------------------\n\nTITLE: Benchmarking MockBenchmarkClass.Bar with LongRun Parameters in BenchmarkDotNet - C#\nDESCRIPTION: Benchmarks the 'Bar' method of 'MockBenchmarkClass' with extended parameters (IterationCount=100, LaunchCount=3, WarmupCount=15), recording detailed iteration execution and memory stats. Utilizes the BenchmarkDotNet framework for orchestration, collecting cache miss hardware metrics and summary statistics. This snippet is designed for validation of longer-running scenarios in the benchmarking system and outputs both timing and hardware counter information per executed operation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// MockBenchmarkClass.Bar Benchmark Data - LongRun\n{\n  \"DisplayInfo\": \"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n  \"Namespace\": \"BenchmarkDotNet.Tests.Mocks\",\n  \"Type\": \"MockBenchmarkClass\",\n  \"Method\": \"Bar\",\n  \"Statistics\": {\n    \"OriginalValues\": [1,1,1,1,1,1],\n    \"N\": 6,\n    \"Mean\": 1,\n    \"Variance\": 0,\n    \"StandardDeviation\": 0,\n    \"Min\": 1,\n    \"Max\": 1\n  },\n  \"Memory\": {\n    \"Gen0Collections\": 0,\n    \"Gen1Collections\": 0,\n    \"Gen2Collections\": 0\n  },\n  \"Measurements\": [\n    { \"IterationIndex\": 1, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 2, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 3, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 4, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 5, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 6, \"Nanoseconds\": 1 }\n  ],\n  \"Metrics\": [\n    {\n      \"Value\": 7,\n      \"Descriptor\": {\n        \"Id\": \"CacheMisses\",\n        \"DisplayName\": \"CacheMisses\",\n        \"Legend\": \"Hardware counter 'CacheMisses' per single operation\"\n      }\n    }\n  ]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Output for Multimodal Distributions\nDESCRIPTION: Displays the formatted output of running the IntroMultimodal benchmark, showing mean, error, standard deviation, median, and MValue statistics for different distribution types. The output includes warnings about multimodal distributions detected in the benchmark results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroMultimodal.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n      Method |     Mean |      Error |      StdDev |   Median | MValue |\n------------ |---------:|-----------:|------------:|---------:|-------:|\n    Unimodal | 100.5 ms |  0.0713 ms |   0.0667 ms | 100.5 ms |  2.000 |\n     Bimodal | 144.5 ms | 16.9165 ms |  49.8787 ms | 100.6 ms |  3.571 |\n    Trimodal | 182.5 ms | 27.4285 ms |  80.8734 ms | 200.5 ms |  4.651 |\n Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms |  5.882 |\n\n// * Warnings *\nMultimodalDistribution\n  IntroMultimodal.Bimodal: MainJob     -> It seems that the distribution is bimodal (mValue = 3.57)\n  IntroMultimodal.Trimodal: MainJob    -> It seems that the distribution is multimodal (mValue = 4.65)\n  IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88)\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Framework Targets in XML\nDESCRIPTION: Demonstrates how to configure a project file to target multiple .NET frameworks for benchmarking.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<TargetFrameworks>netcoreapp3.1;net8.0;net48</TargetFrameworks>\n```\n\n----------------------------------------\n\nTITLE: Sample TailcallDiagnoser Output in BenchmarkDotNet\nDESCRIPTION: Example output from the TailcallDiagnoser showing tail call information for different JIT compilers (LegacyJitX64, LegacyJitX86, RyuJitX64). The output includes caller/callee information, tail prefix status, and tail call type for a factorial implementation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroTailcall.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n// * Diagnostic Output - TailCallDiagnoser *\n--------------------\n\n--------------------\nJit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr)\n--------------------\n\n--------------------\nJit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr)\n--------------------\n\n--------------------\nJit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64)\n--------------------\nCaller: <null>.<null> - <null>\nCallee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64  (int32,int32)\nTail prefix: False\nTail call type: RecursiveLoop\n-------------------\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results in Markdown Table\nDESCRIPTION: This Markdown snippet displays benchmark results for methods 'Foo' and 'Bar' in a simple table format. It shows the method name in the first column and its corresponding measured time ('Center' value, likely milliseconds) in the second column.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=sort01.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method |  Center |\n|:-------|--------:|\n| Bar    | 20.0 ms |\n| Foo    | 10.0 ms |\n```\n\n----------------------------------------\n\nTITLE: Generating BenchmarkDotNet Summary XML\nDESCRIPTION: This XML structure represents a comprehensive summary of benchmark results for MockBenchmarkClass methods Foo and Bar. It includes host environment details, benchmark statistics, metrics, memory usage, and individual measurements for each method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <!-- Statistics details -->\n      </Statistics>\n      <Metrics>\n        <!-- Metrics details -->\n      </Metrics>\n      <Memory>\n        <!-- Memory usage details -->\n      </Memory>\n      <Measurements>\n        <!-- Individual measurements -->\n      </Measurements>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <!-- Statistics details -->\n      </Statistics>\n      <Metrics>\n        <!-- Metrics details -->\n      </Metrics>\n      <Memory>\n        <!-- Memory usage details -->\n      </Memory>\n      <Measurements>\n        <!-- Individual measurements -->\n      </Measurements>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Formatted JSON Benchmark Export in BenchmarkDotNet\nDESCRIPTION: A sample of the exported JSON output from BenchmarkDotNet showing benchmark results. The output includes host environment information, benchmark details, and detailed statistics for each benchmark method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroExportJson.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n   \"Title\":\"IntroJsonExport\",\n   \"HostEnvironmentInfo\":{\n      \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\",\n      \"BenchmarkDotNetVersion\":\"0.9.9.0\",\n      \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\",\n      \"ProcessorName\":{\n         \"IsValueCreated\":true,\n         \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\"\n      },\n      \"ProcessorCount\":8,\n      \"ClrVersion\":\"MS.NET 4.0.30319.42000\",\n      \"Architecture\":\"64-bit\",\n      \"HasAttachedDebugger\":false,\n      \"HasRyuJit\":true,\n      \"Configuration\":\"RELEASE\",\n      \"JitModules\":\"clrjit-v4.6.1586.0\",\n      \"DotNetCliVersion\":\"1.0.0-preview2-003121\",\n      \"ChronometerFrequency\":2143474,\n      \"HardwareTimerKind\":\"Tsc\"\n   },\n   \"Benchmarks\":[\n      {\n         \"ShortInfo\":\"IntroJsonExport_Sleep10\",\n         \"Namespace\":\"BenchmarkDotNet.Samples.Intro\",\n         \"Type\":\"IntroJsonExport\",\n         \"Method\":\"Sleep10\",\n         \"MethodTitle\":\"Sleep10\",\n         \"Parameters\":\"\",\n         \"Properties\":{\n            \"Mode\":\"Throughput\",\n            \"Platform\":\"Host\",\n            \"Jit\":\"Host\",\n            \"Runtime\":\"Host\",\n            \"GcMode\":\"Host\",\n            \"WarmupCount\":\"Auto\",\n            \"IterationCount\":\"Auto\",\n            \"LaunchCount\":\"Auto\",\n            \"IterationTime\":\"Auto\",\n            \"Affinity\":\"Auto\"\n         },\n         \"Statistics\":{\n            \"N\":20,\n            \"Min\":10265993.7209375,\n            \"LowerFence\":10255329.082734371,\n            \"Q1\":10337369.528437499,\n            \"Median\":10360382.6953125,\n            \"Mean\":10362283.085796878,\n            \"Q3\":10392063.158906251,\n            \"UpperFence\":10474103.60460938,\n            \"Max\":10436008.3209375,\n            \"InterquartileRange\":54693.630468752235,\n            \"Outliers\":[\n               \n            ],\n            \"StandardError\":10219.304338928456,\n            \"Variance\":2088683623.4328396,\n            \"StandardDeviation\":45702.118369205156,\n            \"Skewness\":-0.1242777170069375,\n            \"Kurtosis\":2.31980277935226,\n            \"ConfidenceInterval\":{\n               \"Mean\":10362283.085796878,\n               \"Error\":10219.304338928456,\n               \"Level\":6,\n               \"Margin\":20029.836504299772,\n               \"Lower\":10342253.249292579,\n               \"Upper\":10382312.922301177\n            },\n            \"Percentiles\":{\n               \"P0\":10265993.7209375,\n               \"P25\":10338555.905625,\n               \"P50\":10360382.6953125,\n               \"P67\":10373496.555659376,\n               \"P80\":10400703.4841875,\n               \"P85\":10417280.326718749,\n               \"P90\":10424125.595812501,\n               \"P95\":10435620.51609375,\n               \"P100\":10436008.3209375\n            }\n         }\n      },{\n         \"ShortInfo\":\"IntroJsonExport_Sleep20\",\n         \"Namespace\":\"BenchmarkDotNet.Samples.Intro\",\n         \"Type\":\"IntroJsonExport\",\n         \"Method\":\"Sleep20\",\n         \"MethodTitle\":\"Sleep20\",\n         \"Parameters\":\"\",\n         \"Properties\":{\n            \"Mode\":\"Throughput\",\n            \"Platform\":\"Host\",\n            \"Jit\":\"Host\",\n            \"Runtime\":\"Host\",\n            \"GcMode\":\"Host\",\n            \"WarmupCount\":\"Auto\",\n            \"IterationCount\":\"Auto\",\n            \"LaunchCount\":\"Auto\",\n            \"IterationTime\":\"Auto\",\n            \"Affinity\":\"Auto\"\n         },\n         \"Statistics\":{\n            \"N\":20,\n            \"Min\":20258672.37,\n            \"LowerFence\":20206333.269843742,\n            \"Q1\":20325342.761249997,\n            \"Median\":20362636.192500003,\n            \"Mean\":20360791.931687497,\n            \"Q3\":20404682.4221875,\n            \"UpperFence\":20523691.913593754,\n            \"Max\":20422396.073125,\n            \"InterquartileRange\":79339.66093750298,\n            \"Outliers\":[\n               \n            ],\n            \"StandardError\":10728.817907277158,\n            \"Variance\":2302150673.7502208,\n            \"StandardDeviation\":47980.732317777525,\n            \"Skewness\":-0.50826238372439869,\n            \"Kurtosis\":2.11050327966268,\n            \"ConfidenceInterval\":{\n               \"Mean\":20360791.931687497,\n               \"Error\":10728.817907277158,\n               \"Level\":6,\n               \"Margin\":21028.48309826323,\n               \"Lower\":20339763.448589232,\n               \"Upper\":20381820.414785761\n            },\n            \"Percentiles\":{\n               \"P0\":20258672.37,\n               \"P25\":20327638.975312497,\n               \"P50\":20362636.192500003,\n               \"P67\":20391669.3762875,\n               \"P80\":20406370.68625,\n               \"P85\":20412542.034406248,\n               \"P90\":20414412.5376875,\n               \"P95\":20416606.697718751,\n               \"P100\":20422396.073125\n            }\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: XML Benchmark Summary in Formatted Format\nDESCRIPTION: A formatted XML representation of BenchmarkDotNet benchmark results. This example includes environment information, benchmark details, and statistical measurements for two mock benchmark methods (Foo and Bar). The XML is properly indented for readability.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Displaying Environment Information with '--info' in BenchmarkDotNet\nDESCRIPTION: Example output of using the '--info' command-line argument, which prints hardware and OS information without running benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4)\nIntel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores\nFrequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC\n.NET Core SDK=3.0.100-alpha1-009642\n  [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks for Multiple Runtimes with a Single Command\nDESCRIPTION: Command line examples showing how to run benchmarks for multiple .NET runtimes in a single command using the --runtimes or -r argument.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_4\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0\ndotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48         # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8\n```\n\n----------------------------------------\n\nTITLE: Disassembler Entry Point for Value-Returning Methods in C#\nDESCRIPTION: A public method intended as an easily identifiable entry point for disassembler analysis when the benchmarked method returns a value type or reference type (not by reference). It conditionally executes the benchmark workload method (`$WorkloadMethodCall$`) once after loading arguments (`$LoadArguments$`). The `NoOptimization` and `NoInlining` flags prevent the JIT from altering the code significantly, aiding analysis. Returns the result of the workload method or a default value.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\npublic $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()\n{\n    if (NotEleven == 11)\n    {\n        $LoadArguments$\n        return $WorkloadMethodCall$;\n    }\n    \n    return default($WorkloadMethodReturnType$);\n}\n```\n\n----------------------------------------\n\nTITLE: Summarizing BenchmarkDotNet Results in Markdown Table\nDESCRIPTION: This markdown table summarizes the benchmark results for methods 'Foo' and 'Bar'. It shows the 'Center' (median or mean) execution time and 'Spread' (variability) in nanoseconds (ns) for each method when run under different job configurations (various .NET runtimes with specific CPU affinities). It provides a quick overview of performance across different environments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default05.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | Job                  |    Center |  Spread |\n|:-------|:---------------------|----------:|--------:|\n| Foo    | HostProcessAffinity0 |   2.00 ns | 0.81 ns |\n| Bar    | HostProcessAffinity0 |   7.00 ns | 0.81 ns |\n| Foo    | Squid                |  12.00 ns | 0.81 ns |\n| Bar    | Squid                |  17.00 ns | 0.81 ns |\n| Foo    | MonoAffinity2        |  22.00 ns | 0.81 ns |\n| Bar    | MonoAffinity2        |  27.00 ns | 0.81 ns |\n| Foo    | Net461Affinity3      |  32.00 ns | 0.81 ns |\n| Bar    | Net461Affinity3      |  37.00 ns | 0.81 ns |\n| Foo    | Net462Affinity4      |  42.00 ns | 0.81 ns |\n| Bar    | Net462Affinity4      |  47.00 ns | 0.81 ns |\n| Foo    | Net47Affinity5       |  52.00 ns | 0.81 ns |\n| Bar    | Net47Affinity5       |  57.00 ns | 0.81 ns |\n| Foo    | Net471Affinity6      |  62.00 ns | 0.81 ns |\n| Bar    | Net471Affinity6      |  67.00 ns | 0.81 ns |\n| Foo    | Net472Affinity7      |  72.00 ns | 0.81 ns |\n| Bar    | Net472Affinity7      |  77.00 ns | 0.81 ns |\n| Foo    | Net48Affinity8       |  82.00 ns | 0.81 ns |\n| Bar    | Net48Affinity8       |  87.00 ns | 0.81 ns |\n| Foo    | Net481Affinity9      |  92.00 ns | 0.81 ns |\n| Bar    | Net481Affinity9      |  97.00 ns | 0.81 ns |\n| Foo    | Liger                | 102.00 ns | 0.81 ns |\n| Bar    | Liger                | 107.00 ns | 0.81 ns |\n| Foo    | Rat                  | 112.00 ns | 0.81 ns |\n| Bar    | Rat                  | 117.00 ns | 0.81 ns |\n| Foo    | Skate                | 122.00 ns | 0.81 ns |\n| Bar    | Skate                | 127.00 ns | 0.81 ns |\n| Foo    | Perch                | 132.00 ns | 0.81 ns |\n| Bar    | Perch                | 137.00 ns | 0.81 ns |\n| Foo    | Roach                | 142.00 ns | 0.81 ns |\n| Bar    | Roach                | 147.00 ns | 0.81 ns |\n| Foo    | Roe                  | 152.00 ns | 0.81 ns |\n| Bar    | Roe                  | 157.00 ns | 0.81 ns |\n| Foo    | Net50Affinity16      | 162.00 ns | 0.81 ns |\n| Bar    | Net50Affinity16      | 167.00 ns | 0.81 ns |\n| Foo    | Net60Affinity17      | 172.00 ns | 0.81 ns |\n| Bar    | Net60Affinity17      | 177.00 ns | 0.81 ns |\n| Foo    | Net70Affinity18      | 182.00 ns | 0.81 ns |\n| Bar    | Net70Affinity18      | 187.00 ns | 0.81 ns |\n| Foo    | Net80Affinity19      | 192.00 ns | 0.81 ns |\n| Bar    | Net80Affinity19      | 197.00 ns | 0.81 ns |\n```\n\n----------------------------------------\n\nTITLE: Exporting Brief Benchmark Results to JSON\nDESCRIPTION: This snippet shows the 'brief' JSON export format from BenchmarkDotNet, formatted for readability. It contains essential information like the title, detailed host environment details (OS, CPU, Core Counts, Runtime, .NET CLI version, Timer), and an array of benchmark results including method info (Namespace, Type, Method name, Parameters), full name, basic statistics (N, Min, Mean, Max, StdDev, Percentiles, Confidence Interval), and memory allocation details (GC collections, BytesAllocatedPerOperation) for methods 'Foo' and 'Bar'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"Title\":\"MockSummary\",\n   \"HostEnvironmentInfo\":{\n      \"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\n      \"BenchmarkDotNetVersion\":\"0.10.x-mock\",\n      \"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\n      \"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\n      \"PhysicalProcessorCount\":1,\n      \"PhysicalCoreCount\":4,\n      \"LogicalCoreCount\":8,\n      \"RuntimeVersion\":\"Clr 4.0.x.mock\",\n      \"Architecture\":\"64mock\",\n      \"HasAttachedDebugger\":false,\n      \"HasRyuJit\":true,\n      \"Configuration\":\"CONFIGURATION\",\n      \"DotNetCliVersion\":\"1.0.x.mock\",\n      \"ChronometerFrequency\":{\n         \"Hertz\":2531248\n      },\n      \"HardwareTimerKind\":\"Tsc\"\n   },\n   \"Benchmarks\":[\n      {\n         \"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n         \"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\n         \"Type\":\"MockBenchmarkClass\",\n         \"Method\":\"Foo\",\n         \"MethodTitle\":\"Foo\",\n         \"Parameters\":\"\",\n         \"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\n         \"HardwareIntrinsics\":\"\",\n         \"Statistics\":{\n            \"OriginalValues\":[\n               1,1,1,1,1,1\n            ],\n            \"N\":6,\n            \"Min\":1,\n            \"LowerFence\":1,\n            \"Q1\":1,\n            \"Median\":1,\n            \"Mean\":1,\n            \"Q3\":1,\n            \"UpperFence\":1,\n            \"Max\":1,\n            \"InterquartileRange\":0,\n            \"LowerOutliers\":[\n               \n            ],\n            \"UpperOutliers\":[\n               \n            ],\n            \"AllOutliers\":[\n               \n            ],\n            \"StandardError\":0,\n            \"Variance\":0,\n            \"StandardDeviation\":0,\n            \"Skewness\":\"\",\n            \"Kurtosis\":\"\",\n            \"ConfidenceInterval\":{\n               \"N\":6,\n               \"Mean\":1,\n               \"StandardError\":0,\n               \"Level\":12,\n               \"Margin\":0,\n               \"Lower\":1,\n               \"Upper\":1\n            },\n            \"Percentiles\":{\n               \"P0\":1,\n               \"P25\":1,\n               \"P50\":1,\n               \"P67\":1,\n               \"P80\":1,\n               \"P85\":1,\n               \"P90\":1,\n               \"P95\":1,\n               \"P100\":1\n            }\n         },\n         \"Memory\":{\n            \"Gen0Collections\":0,\n            \"Gen1Collections\":0,\n            \"Gen2Collections\":0,\n            \"TotalOperations\":0,\n            \"BytesAllocatedPerOperation\":null\n         }\n      },{\n         \"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n         \"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\n         \"Type\":\"MockBenchmarkClass\",\n         \"Method\":\"Bar\",\n         \"MethodTitle\":\"Bar\",\n         \"Parameters\":\"\",\n         \"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\n         \"HardwareIntrinsics\":\"\",\n         \"Statistics\":{\n            \"OriginalValues\":[\n               1,1,1,1,1,1\n            ],\n            \"N\":6,\n            \"Min\":1,\n            \"LowerFence\":1,\n            \"Q1\":1,\n            \"Median\":1,\n            \"Mean\":1,\n            \"Q3\":1,\n            \"UpperFence\":1,\n            \"Max\":1,\n            \"InterquartileRange\":0,\n            \"LowerOutliers\":[\n               \n            ],\n            \"UpperOutliers\":[\n               \n            ],\n            \"AllOutliers\":[\n               \n            ],\n            \"StandardError\":0,\n            \"Variance\":0,\n            \"StandardDeviation\":0,\n            \"Skewness\":\"\",\n            \"Kurtosis\":\"\",\n            \"ConfidenceInterval\":{\n               \"N\":6,\n               \"Mean\":1,\n               \"StandardError\":0,\n               \"Level\":12,\n               \"Margin\":0,\n               \"Lower\":1,\n               \"Upper\":1\n            },\n            \"Percentiles\":{\n               \"P0\":1,\n               \"P25\":1,\n               \"P50\":1,\n               \"P67\":1,\n               \"P80\":1,\n               \"P85\":1,\n               \"P90\":1,\n               \"P95\":1,\n               \"P100\":1\n            }\n         },\n         \"Memory\":{\n            \"Gen0Collections\":0,\n            \"Gen1Collections\":0,\n            \"Gen2Collections\":0,\n            \"TotalOperations\":0,\n            \"BytesAllocatedPerOperation\":null\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement without Unrolling for Ref-Returning Methods in C#\nDESCRIPTION: Measures the overhead of the benchmarking loop and delegate invocation for methods returning by reference (`ref T`), without loop unrolling. It calls the `overheadDelegate` `invokeCount` times in a simple loop. `AggressiveOptimizationOption` encourages JIT optimization, and `KeepAliveWithoutBoxing` is used to ensure the result is considered live.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        value = overheadDelegate($PassArguments$);\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Disassembly Output with Job.Dry in C#\nDESCRIPTION: This code snippet demonstrates how to use Job.Dry in BenchmarkDotNet to obtain disassembly output without running full benchmarks. It defines a simple benchmark method and configures it to use DisassemblyDiagnoser and run only once with Job.Dry.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassemblyDry.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing BenchmarkDotNet.Attributes;\nusing BenchmarkDotNet.Diagnosers;\nusing BenchmarkDotNet.Jobs;\n\nnamespace BenchmarkDotNet.Samples\n{\n    [DisassemblyDiagnoser(printSource: true, printInstructionAddresses: true, exportDiff: true)]\n    [SimpleJob(RuntimeMoniker.Net472, baseline: true)]\n    [SimpleJob(RuntimeMoniker.Net50)]\n    [SimpleJob(RuntimeMoniker.Net60)]\n    [SimpleJob(RuntimeMoniker.Net70)]\n    [SimpleJob(RuntimeMoniker.Net80)]\n    [DryJob]\n    public class IntroDisassemblyDry\n    {\n        [Benchmark]\n        public void Foo()\n        {\n            int result = 0;\n            for (int i = 0; i < 100; i++)\n                result += i;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in Stack Overflow Markdown Format\nDESCRIPTION: A markdown representation of benchmark results optimized for Stack Overflow display. This format uses indentation for code blocks and maintains alignment for table columns to appear correctly in Stack Overflow posts.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n    BenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\n    MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n    Frequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n    .NET Core SDK 1.0.x.mock\n      [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\n    Job=LongRun  IterationCount=100  LaunchCount=3  \n    WarmupCount=15  \n\n     Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n    ------- |---------:|---------:|---------:|---------:|------------:|\n     Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n     Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Filtering Benchmarks with Flat Format in BenchmarkDotNet\nDESCRIPTION: Example output of combining '--list flat' with '--filter' to display only benchmarks matching a specific pattern in flat format.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic\nBenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark\nBenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA\nBenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB\nBenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC\nBenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD\n```\n\n----------------------------------------\n\nTITLE: Writing Benchmarks in F# with BenchmarkDotNet\nDESCRIPTION: This snippet shows how to write benchmarks using F# syntax, demonstrating parameterization and setup methods.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/overview.md#2025-04-22_snippet_5\n\nLANGUAGE: F#\nCODE:\n```\ntype StringKeyComparison () =\n    let mutable arr : string [] = [||]\n    let dict1 = ConcurrentDictionary<_,_>()\n    let dict2 = ConcurrentDictionary<_,_>(StringComparer.Ordinal)\n\n    [<Params (100, 500, 1000, 2000)>] \n    member val public DictSize = 0 with get, set\n\n    [<GlobalSetup>]\n    member self.GlobalSetupData() =\n        dict1.Clear(); dict2.Clear()\n        arr <- getStrings self.DictSize\n        arr |> Array.iter (fun x -> dict1.[x] <- true ; dict2.[x] <- true)\n\n    [<Benchmark>]\n    member self.StandardLookup () = lookup arr dict1\n\n    [<Benchmark>]\n    member self.OrdinalLookup () = lookup arr dict2\n```\n\n----------------------------------------\n\nTITLE: Disassembly of Sum method in Mono 5.12.0 with 64-bit compiler\nDESCRIPTION: Assembly code generated by Mono 5.12.0 64-bit compiler for the Sum method in IntroDisassembly class. This disassembly shows a more compact representation without IL interleaving and uses SSE instructions (xorpd, cvtsi2sd, addsd) for floating-point operations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassembly.md#2025-04-22_snippet_2\n\nLANGUAGE: x86asm\nCODE:\n```\nMono 5.12.0 (Visual Studio), 64bit\n Sum\nsub    $0x18,%rsp\nmov    %rsi,(%rsp)\nxorpd  %xmm0,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nxor    %esi,%esi\njmp    2e \nxchg   %ax,%ax\nmovsd  0x8(%rsp),%xmm0\ncvtsi2sd %esi,%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\ninc    %esi\ncmp    $0x40,%esi\njl     18 \nmovsd  0x8(%rsp),%xmm0\nmov    (%rsp),%rsi\nadd    $0x18,%rsp\nretq   \n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in Default Markdown Format\nDESCRIPTION: A markdown representation of benchmark results for MockBenchmarkClass methods Foo and Bar. This format includes system information and a table displaying method performance metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n------- |---------:|---------:|---------:|---------:|------------:|\n Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Exporting Compressed Brief Benchmark Results to JSON\nDESCRIPTION: This snippet presents the 'brief-compressed' JSON export format from BenchmarkDotNet. It is identical in content structure to the 'brief' format (including Title, HostEnvironmentInfo, and Benchmarks array with Statistics and Memory details for 'Foo' and 'Bar') but removes all non-essential whitespace (like newlines and indentation) for a more compact representation, suitable for machine processing or storage.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"Title\":\"MockSummary\",\"HostEnvironmentInfo\":{\"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\"BenchmarkDotNetVersion\":\"0.10.x-mock\",\"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\"PhysicalProcessorCount\":1,\"PhysicalCoreCount\":4,\"LogicalCoreCount\":8,\"RuntimeVersion\":\"Clr 4.0.x.mock\",\"Architecture\":\"64mock\",\"HasAttachedDebugger\":false,\"HasRyuJit\":true,\"Configuration\":\"CONFIGURATION\",\"DotNetCliVersion\":\"1.0.x.mock\",\"ChronometerFrequency\":{\"Hertz\":2531248},\"HardwareTimerKind\":\"Tsc\"},\"Benchmarks\":[{\"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Foo\",\"MethodTitle\":\"Foo\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}},{\"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Bar\",\"MethodTitle\":\"Bar\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}}]}\n```\n\n----------------------------------------\n\nTITLE: Referencing the Benchmark Code with JitStatsDiagnoser (C#)\nDESCRIPTION: This line references the C# source code file (`IntroJitStatsDiagnoser.cs`) that implements a benchmark utilizing the `JitStatsDiagnoser`. The diagnoser, likely applied via an attribute or configuration within the referenced code, enables BenchmarkDotNet to collect statistics about the Just-In-Time (JIT) compiler during the benchmark run. These statistics include the number of methods JITted, the count of tiered methods, and the memory allocated by the JIT compiler. This specific diagnoser is noted to have a restriction of being Windows-only.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJitStatsDiagnoser.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroJitStatsDiagnoser.cs](../../../samples/BenchmarkDotNet.Samples/IntroJitStatsDiagnoser.cs)]\n```\n\n----------------------------------------\n\nTITLE: Compressing Benchmark Results in XML using BenchmarkDotNet XmlExporter (brief-compressed format)\nDESCRIPTION: A compressed version of the XML output generated by BenchmarkDotNet's XmlExporter with all whitespace removed. Contains the same benchmark data as the readable format but optimized for size rather than readability.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_13\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?><Summary><Title>MockSummary</Title><HostEnvironmentInfo><BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption><BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion><OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion><ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName><PhysicalProcessorCount>1</PhysicalProcessorCount><PhysicalCoreCount>4</PhysicalCoreCount><LogicalCoreCount>8</LogicalCoreCount><RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion><Architecture>64mock</Architecture><HasAttachedDebugger>False</HasAttachedDebugger><HasRyuJit>True</HasRyuJit><Configuration>CONFIGURATION</Configuration><DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion><ChronometerFrequency><Hertz>2531248</Hertz></ChronometerFrequency><HardwareTimerKind>Tsc</HardwareTimerKind></HostEnvironmentInfo><Benchmarks><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Foo</Method><MethodTitle>Foo</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Bar</Method><MethodTitle>Bar</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase></Benchmarks></Summary>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results With HideColumns Attribute Applied\nDESCRIPTION: This table demonstrates the effect of applying the HideColumns attribute to hide Gen0, Gen1, and Gen2 columns from benchmark results. The simplified output shows only the essential metrics: Mean, Error, StdDev, and Allocated memory.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_8\n\nLANGUAGE: ini\nCODE:\n```\n|        Method |     Mean |     Error |    StdDev | Allocated |\n|-------------- |---------:|----------:|----------:|----------:|\n| AllocateArray | 3.489 us | 0.0662 us | 0.0763 us |  97.69 KB |\n```\n\n----------------------------------------\n\nTITLE: Example Disassembly Diff Output (Diff)\nDESCRIPTION: Illustrates the output format generated by the `PrettyGithubMarkdownDiffDisassemblyExporter` in BenchmarkDotNet. This diff compares the generated assembly code for two C# methods (`SumLocal` and `SumField`), highlighting differences in instructions, comments, and total code size to aid in micro-optimization and performance analysis at the assembly level. Lines starting with '-' are from the first method, and lines with '+' are from the second.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n-; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal()\n-                   var local = field; // we use local variable that points to the field\n-            ^^^^^^^^^^^^^^^^^^\n-       mov     rax,qword ptr [rcx+8]\n+; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField()\n                    int sum = 0;\n             ^^^^^^^^^^^^\n-       xor     edx,edx\n-                   for (int i = 0; i < local.Length; i++)\n+       xor     eax,eax\n+                   for (int i = 0; i < field.Length; i++)\n                  ^^^^^^^^^\n-       xor     ecx,ecx\n-                   for (int i = 0; i < local.Length; i++)\n+       xor     edx,edx\n+                   for (int i = 0; i < field.Length; i++)\n                             ^^^^^^^^^^^^^^^^ \n-       mov     r8d,dword ptr [rax+8]\n-       test    r8d,r8d\n+       mov     rcx,qword ptr [rcx+8]\n+       cmp     dword ptr [rcx+8],0\n        jle     M00_L01\n-                       sum += local[i];\n+                       sum += field[i];\n                 ^^^^^^^^^^^^^^^^ \n M00_L00:\n-       movsxd  r9,ecx\n-       add     edx,dword ptr [rax+r9*4+10h]\n-                   for (int i = 0; i < local.Length; i++)\n+       mov     r8,rcx\n+       cmp     edx,dword ptr [r8+8]\n+       jae     00007ff9`0c412c1f\n+       movsxd  r9,edx\n+       add     eax,dword ptr [r8+r9*4+10h]\n+                   for (int i = 0; i < field.Length; i++)\n                                               ^^^\n-       inc     ecx\n-       cmp     r8d,ecx\n+       inc     edx\n+       cmp     dword ptr [rcx+8],edx\n        jg      M00_L00\n                    return sum;\n             ^^^^^^^^^^^\n M00_L01:\n-       mov     eax,edx\n-; Total bytes of code 34\n+       add     rsp,28h\n+; Total bytes of code 42\n```\n\n----------------------------------------\n\nTITLE: Main Entry Point for BenchmarkDotNet\nDESCRIPTION: The main entry point for the auto-generated benchmark runner. It handles assembly resolution for .NET Framework and delegates to other methods for benchmark execution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkProgram.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Int32 Main(System.String[] args)\n{\n    // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)\n    // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event\n    // before .NET Framework tries to load it for this method\n#if NETFRAMEWORK\n    using(new DirtyAssemblyResolveHelper())\n#endif\n        return AfterAssemblyLoadingAttached(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Presenting BenchmarkDotNet Results in Console Markdown Format\nDESCRIPTION: A markdown representation of benchmark results optimized for console display. This format includes system information and a table with clear column separators for better readability in terminal environments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n| Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n|------- |---------:|---------:|---------:|---------:|------------:|\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Exporting Compressed Benchmark Summary using XmlExporter - XML\nDESCRIPTION: This snippet provides the same BenchmarkDotNet XML summary as above, but formatted without whitespace for compactness. It is well-suited for scenarios involving storage, transmission, or automated parsing where minimizing file size is important. Consumers must ensure their XML parser is robust against minified XML. All content is identical in structure to the pretty-printed report, maintaining all statistical and metadata fields as required by downstream tools or consumers.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><Summary><Title>MockSummary</Title><HostEnvironmentInfo><BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption><BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion><OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion><ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName><PhysicalProcessorCount>1</PhysicalProcessorCount><PhysicalCoreCount>4</PhysicalCoreCount><LogicalCoreCount>8</LogicalCoreCount><RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion><Architecture>64mock</Architecture><HasAttachedDebugger>False</HasAttachedDebugger><HasRyuJit>True</HasRyuJit><Configuration>CONFIGURATION</Configuration><DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion><ChronometerFrequency><Hertz>2531248</Hertz></ChronometerFrequency><HardwareTimerKind>Tsc</HardwareTimerKind></HostEnvironmentInfo><Benchmarks><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Foo</Method><MethodTitle>Foo</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Bar</Method><MethodTitle>Bar</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase></Benchmarks></Summary>\n```\n\n----------------------------------------\n\nTITLE: Building BenchmarkDotNet from Source Code\nDESCRIPTION: Shell command to build and pack BenchmarkDotNet from source code for development purposes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/nuget.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nbuild.cmd pack\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Mode in BenchmarkDotNet\nDESCRIPTION: Code example showing how to configure BenchmarkDotNet to run in debug mode using DebugInProcessConfig for same-process debugging.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/troubleshooting.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args, new DebugInProcessConfig());\n```\n\n----------------------------------------\n\nTITLE: Redirecting Runtime Pack Location for Publishing\nDESCRIPTION: Custom MSBuild target that redirects the 'dotnet publish' command to use an in-tree runtime pack. This ensures the correct runtime components are used during the publishing process for the benchmark.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_4\n\nLANGUAGE: XML\nCODE:\n```\n<Target Name=\"TrickRuntimePackLocation\" AfterTargets=\"ProcessFrameworkReferences\">\n    <ItemGroup>\n      <RuntimePack>\n        <PackageDirectory>$(MicrosoftNetCoreAppRuntimePackDir)</PackageDirectory>\n      </RuntimePack>\n    </ItemGroup>\n    <Message Text=\"Packaged ID: %(RuntimePack.PackageDirectory)\" Importance=\"high\" />\n  </Target>\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Custom CoreRun in CMD\nDESCRIPTION: Shows how to use the --coreRun argument to specify a custom CoreRun executable for benchmarking.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_10\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -- --coreRun \"C:\\Projects\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Release-x64\\shared\\Microsoft.NETCore.App\\9.9.9\\CoreRun.exe\"\n```\n\n----------------------------------------\n\nTITLE: Benchmark Execution Logic in AfterAssemblyLoadingAttached\nDESCRIPTION: Core method that initializes the host, processes command-line arguments, and executes the requested benchmark with comprehensive error handling. It supports both anonymous pipes and console hosts, and has special handling for OutOfMemoryExceptions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkProgram.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nprivate static System.Int32 AfterAssemblyLoadingAttached(System.String[] args)\n{\n    BenchmarkDotNet.Engines.IHost host; // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it\n    if (BenchmarkDotNet.Engines.AnonymousPipesHost.TryGetFileHandles(args, out System.String writeHandle, out System.String readHandle))\n        host = new BenchmarkDotNet.Engines.AnonymousPipesHost(writeHandle, readHandle);\n    else\n        host = new BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost();\n\n    // the first thing to do is to let diagnosers hook in before anything happens\n    // so all jit-related diagnosers can catch first jit compilation!\n    BenchmarkDotNet.Engines.HostExtensions.BeforeAnythingElse(host);\n\n    try\n    {\n        // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable\n        // which could cause the jitting/assembly loading to happen before we do anything\n        // we have some jitting diagnosers and we want them to catch all the informations!!\n\n        // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it\n        System.String benchmarkName = System.Linq.Enumerable.FirstOrDefault(System.Linq.Enumerable.Skip(System.Linq.Enumerable.SkipWhile(args, arg => arg != \"--benchmarkName\"), 1)) ?? \"not provided\";\n        System.Int32 id = args.Length > 0\n            ? System.Int32.Parse(args[args.Length - 1]) // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it\n            : 0; // used when re-using generated exe without BDN (typically to repro a bug)\n\n        if (args.Length == 0)\n        {\n            host.WriteLine(\"You have not specified benchmark id (an integer) so the first benchmark will be executed.\");\n        }\n\n#if NATIVEAOT\n        $NativeAotSwitch$\n#else\n        System.Type type = typeof(BenchmarkDotNet.Autogenerated.UniqueProgramName).Assembly.GetType($\"BenchmarkDotNet.Autogenerated.Runnable_{id}\");\n        type.GetMethod(\"Run\", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static).Invoke(null, new System.Object[] { host, benchmarkName });\n#endif\n        return 0;\n    }\n    catch (System.Exception oom) when (oom is System.OutOfMemoryException || oom is System.Reflection.TargetInvocationException reflection && reflection.InnerException is System.OutOfMemoryException)\n    {\n        host.WriteLine();\n        host.WriteLine(\"OutOfMemoryException!\");\n        host.WriteLine(\"BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.\");\n        host.WriteLine(\"If your benchmark allocates memory and keeps it alive, you are creating a memory leak.\");\n        host.WriteLine(\"You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.\");\n        host.WriteLine();\n        host.WriteLine(oom.ToString());\n\n        return -1;\n    }\n    catch(System.Exception ex)\n    {\n        host.WriteLine();\n        host.WriteLine(ex.ToString());\n        return -1;\n    }\n    finally\n    {\n        BenchmarkDotNet.Engines.HostExtensions.AfterAll(host);\n\n        host.Dispose();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Benchmark Setup and Execution Order in BenchmarkDotNet (C#)\nDESCRIPTION: This C# code snippet, presented as a comment, demonstrates the sequence in which BenchmarkDotNet invokes setup and benchmark methods when setup and cleanup targets are configured. No extra dependencies are required beyond BenchmarkDotNet, and the snippet clarifies the order of method calls for global setups and corresponding benchmarks (A, B, C, D) according to attribute configuration. This serves as a guide for expected runtime behavior and does not include executable code or require any input. The main limitation is that it's a non-executable illustrative comment and is intended for referential documentation only.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroSetupCleanupTarget.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// GlobalSetup A\\n\\n// Benchmark A\\n\\n// GlobalSetup B\\n\\n// Benchmark B\\n\\n// GlobalSetup B\\n\\n// Benchmark C\\n\\n// Benchmark D\n```\n\n----------------------------------------\n\nTITLE: Generating BenchmarkDotNet Summary XML\nDESCRIPTION: This XML structure represents a comprehensive summary of BenchmarkDotNet benchmark results. It includes host environment information, benchmark cases with detailed statistics, metrics, memory usage, and individual measurements.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_16\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <!-- Statistics details -->\n      </Statistics>\n      <Metrics>\n        <!-- Metrics details -->\n      </Metrics>\n      <Memory>\n        <!-- Memory usage details -->\n      </Memory>\n      <Measurements>\n        <!-- Measurement details -->\n      </Measurements>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <!-- Statistics details -->\n      </Statistics>\n      <Metrics>\n        <!-- Metrics details -->\n      </Metrics>\n      <Memory>\n        <!-- Memory usage details -->\n      </Memory>\n      <Measurements>\n        <!-- Measurement details -->\n      </Measurements>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: XML Benchmark Summary in Compressed Format\nDESCRIPTION: A minified/compressed XML representation of BenchmarkDotNet results, containing identical information to the formatted version but without whitespace. This format is more efficient for storage or transmission but less readable for humans.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_14\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?><Summary><Title>MockSummary</Title><HostEnvironmentInfo><BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption><BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion><OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion><ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName><PhysicalProcessorCount>1</PhysicalProcessorCount><PhysicalCoreCount>4</PhysicalCoreCount><LogicalCoreCount>8</LogicalCoreCount><RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion><Architecture>64mock</Architecture><HasAttachedDebugger>False</HasAttachedDebugger><HasRyuJit>True</HasRyuJit><Configuration>CONFIGURATION</Configuration><DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion><ChronometerFrequency><Hertz>2531248</Hertz></ChronometerFrequency><HardwareTimerKind>Tsc</HardwareTimerKind></HostEnvironmentInfo><Benchmarks><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Foo</Method><MethodTitle>Foo</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase><BenchmarkCase><DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo><Namespace>BenchmarkDotNet.Tests.Mocks</Namespace><Type>MockBenchmarkClass</Type><Method>Bar</Method><MethodTitle>Bar</MethodTitle><Statistics><OriginalValues><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item><Item>1</Item></OriginalValues><N>6</N><Min>1</Min><LowerFence>1</LowerFence><Q1>1</Q1><Median>1</Median><Mean>1</Mean><Q3>1</Q3><UpperFence>1</UpperFence><Max>1</Max><InterquartileRange>0</InterquartileRange><StandardError>0</StandardError><Variance>0</Variance><StandardDeviation>0</StandardDeviation><Skewness>NaN</Skewness><Kurtosis>NaN</Kurtosis><ConfidenceInterval><N>6</N><Mean>1</Mean><StandardError>0</StandardError><Level>L999</Level><Margin>0</Margin><Lower>1</Lower><Upper>1</Upper></ConfidenceInterval><Percentiles><P0>1</P0><P25>1</P25><P50>1</P50><P67>1</P67><P80>1</P80><P85>1</P85><P90>1</P90><P95>1</P95><P100>1</P100></Percentiles></Statistics><Metrics><Item><Value>7</Value><Descriptor><Id>CacheMisses</Id><DisplayName>CacheMisses</DisplayName><Legend>Hardware counter 'CacheMisses' per single operation</Legend><NumberFormat>N0</NumberFormat><UnitType>Dimensionless</UnitType><TheGreaterTheBetter>False</TheGreaterTheBetter><PriorityInCategory>0</PriorityInCategory></Descriptor></Item></Metrics><Memory><Gen0Collections>0</Gen0Collections><Gen1Collections>0</Gen1Collections><Gen2Collections>0</Gen2Collections><TotalOperations>0</TotalOperations><BytesAllocatedPerOperation /></Memory></BenchmarkCase></Benchmarks></Summary>\n```\n\n----------------------------------------\n\nTITLE: Launching Debugger in BenchmarkDotNet Setup\nDESCRIPTION: Code example demonstrating how to launch a debugger from within a benchmark's setup method using the Debugger API.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/troubleshooting.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[GlobalSetup]\\npublic void Setup()\\n{\\n    System.Diagnostics.Debugger.Launch();\\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Test Results in Markdown Table\nDESCRIPTION: This snippet shows the results of benchmark tests in a markdown-formatted table. It includes method names, parameter properties, mean execution times, error margins, and standard deviations. The table also indicates an error related to parameter type constraints.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithNotAllowedNullableTypeError.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | ?             | 114.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | 0             | 214.5 ns | 5.88 ns | 8.80 ns | ^\n\nErrors: 1\n* Type Int32 cannot be used with [ParamsAllValues], allowed types are: bool, enum types and nullable type for another allowed type.\n```\n\n----------------------------------------\n\nTITLE: Building BenchmarkDotNet Documentation Locally using CMD\nDESCRIPTION: This command demonstrates how to build the BenchmarkDotNet documentation locally using the 'docs-build' task in the project's build script.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/documentation.md#2025-04-22_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\nbuild.cmd docs-build\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Summary Table in Markdown\nDESCRIPTION: This Markdown snippet presents a summary table of benchmark results. It lists the benchmarked methods ('Foo', 'Bar'), the job configurations ('Net481LegacyJit', 'Net70RyuJit'), the central tendency of the results ('Center', likely mean or median time in nanoseconds), and the spread or variability ('Spread', likely standard deviation or error in nanoseconds). This table provides a quick overview of the performance comparison across different methods and environments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default04.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | Job             |  Center |  Spread |\n|:-------|:----------------|--------:|--------:|\n| Foo    | Net481LegacyJit | 11.0 ns | 0.81 ns |\n| Bar    | Net481LegacyJit | 21.0 ns | 0.81 ns |\n| Foo    | Net70RyuJit     | 31.0 ns | 0.81 ns |\n| Bar    | Net70RyuJit     | 41.0 ns | 0.81 ns |\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results with RatioStyle.Percentage\nDESCRIPTION: Sample output table showing benchmark results with RatioStyle.Percentage, which displays performance differences as percentages (e.g., -85% or +15%) compared to the baseline.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRatioStyle.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n|   Method |       Mean |   Error |  StdDev |    Ratio | RatioSD |\n|--------- |-----------:|--------:|--------:|---------:|--------:|\n| Baseline | 1,000.3 ms | 4.69 ms | 0.26 ms | baseline |         |\n|      Bar |   150.7 ms | 1.42 ms | 0.08 ms |     -85% |    0.1% |\n|      Foo | 1,150.3 ms | 6.13 ms | 0.34 ms |     +15% |    0.0% |\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results in Markdown Table Format\nDESCRIPTION: This markdown snippet shows the output of the parameterized benchmark in a table format. It displays the results for different combinations of A and B values, including the mean execution time, error, and standard deviation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParams.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|    Method |   A |  B |     Mean |   Error |  StdDev |\n|---------- |---- |--- |---------:|--------:|--------:|\n| Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms |\n| Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms |\n| Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms |\n| Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms |\n```\n\n----------------------------------------\n\nTITLE: Defining XML Structure for BenchmarkDotNet Export Results\nDESCRIPTION: A comprehensive XML template that represents BenchmarkDotNet benchmark results, including system information, benchmark cases, statistics, metrics, and detailed measurements. The template demonstrates the full structure of benchmark export data with mock values.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_15\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n      <Measurements>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>1</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>2</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>3</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>4</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>5</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n        <Measurement>\n          <IterationMode>Workload</IterationMode>\n          <IterationStage>Result</IterationStage>\n          <LaunchIndex>1</LaunchIndex>\n          <IterationIndex>6</IterationIndex>\n          <Operations>1</Operations>\n          <Nanoseconds>1</Nanoseconds>\n        </Measurement>\n      </Measurements>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Creating Project with Configuration\nDESCRIPTION: Command to create a benchmark project that includes a configuration class\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_7\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark -c\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Output: Grouped by Method (No Baseline)\nDESCRIPTION: Tabular output from a BenchmarkDotNet run showing performance metrics (Mean, Error, StdDev) for methods 'Base', 'Foo', and 'Bar'. Results are presented for combinations of 'Job1'/'Job2' and parameters 2/10, grouped by method. No method is designated as a baseline for comparison. The table includes columns for Method, Job, Param, Mean, Error, StdDev, Rank within the group, LogicalGroup identifier, and Baseline status.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/MarkdownExporterVerifyTests.GroupExporterTest_NoBaseline_MethodsParamsJobs_GroupByMethod.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n=== NoBaseline_MethodsParamsJobs_GroupByMethod ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  Job1   : extra output line\n  Job2   : extra output line\n\n\n Method | Job  | Param | Mean       | Error   | StdDev  | Rank | LogicalGroup                                    | Baseline |\n------- |----- |------ |-----------:|--------:|--------:|-----:|------------------------------------------------ |--------- |\n Base   | Job1 | 2     |   114.5 ns | 5.88 ns | 8.80 ns |    1 | NoBaseline_MethodsParamsJobs_GroupByMethod.Base | No       | ^\n Base   | Job2 | 2     |   214.5 ns | 5.88 ns | 8.80 ns |    2 | NoBaseline_MethodsParamsJobs_GroupByMethod.Base | No       |\n Base   | Job1 | 10    |   314.5 ns | 5.88 ns | 8.80 ns |    3 | NoBaseline_MethodsParamsJobs_GroupByMethod.Base | No       | ^\n Base   | Job2 | 10    |   414.5 ns | 5.88 ns | 8.80 ns |    4 | NoBaseline_MethodsParamsJobs_GroupByMethod.Base | No       |\n        |      |       |            |         |         |      |                                                 |          |\n Foo    | Job1 | 2     |   514.5 ns | 5.88 ns | 8.80 ns |    1 | NoBaseline_MethodsParamsJobs_GroupByMethod.Foo  | No       | ^\n Foo    | Job2 | 2     |   714.5 ns | 5.88 ns | 8.80 ns |    2 | NoBaseline_MethodsParamsJobs_GroupByMethod.Foo  | No       |\n Foo    | Job1 | 10    |   914.5 ns | 5.88 ns | 8.80 ns |    3 | NoBaseline_MethodsParamsJobs_GroupByMethod.Foo  | No       | ^\n Foo    | Job2 | 10    | 1,114.5 ns | 5.88 ns | 8.80 ns |    4 | NoBaseline_MethodsParamsJobs_GroupByMethod.Foo  | No       |\n        |      |       |            |         |         |      |                                                 |          |\n Bar    | Job1 | 2     |   614.5 ns | 5.88 ns | 8.80 ns |    1 | NoBaseline_MethodsParamsJobs_GroupByMethod.Bar  | No       | ^\n Bar    | Job2 | 2     |   814.5 ns | 5.88 ns | 8.80 ns |    2 | NoBaseline_MethodsParamsJobs_GroupByMethod.Bar  | No       |\n Bar    | Job1 | 10    | 1,014.5 ns | 5.88 ns | 8.80 ns |    3 | NoBaseline_MethodsParamsJobs_GroupByMethod.Bar  | No       | ^\n Bar    | Job2 | 10    | 1,214.5 ns | 5.88 ns | 8.80 ns |    4 | NoBaseline_MethodsParamsJobs_GroupByMethod.Bar  | No       |\n\nErrors: 0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Snap Support in BenchmarkDotNet on Ubuntu\nDESCRIPTION: Log output showing BenchmarkDotNet running with the .NET SDK installed via snap on Ubuntu, including build process and execution details.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_1\n\nLANGUAGE: log\nCODE:\n```\nadam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo\n// Validating benchmarks:\n// ***** BenchmarkRunner: Start   *****\n// ***** Found 1 benchmark(s) in total *****\n// ***** Building 1 exe(s) in Parallel: Start   *****\n// start /snap/dotnet-sdk/112/dotnet restore  /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b\n// command took 1.49s and exited with 0\n// start /snap/dotnet-sdk/112/dotnet build -c Release  --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b\n// command took 2.78s and exited with 0\n// ***** Done, took 00:00:04 (4.37 sec)   *****\n// Found 1 benchmarks:\n//   IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart)\n\n// **************************\n// Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart)\n// *** Execute ***\n// Launch: 1 / 1\n// Execute: /snap/dotnet-sdk/112/dotnet \"9a018ee4-0f33-46dd-9093-01d3bf31233b.dll\" --benchmarkName \"BenchmarkDotNet.Samples.IntroColdStart.Foo\" --job \"IterationCount=5, RunStrategy=ColdStart\" --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results\nDESCRIPTION: This JSON snippet contains performance data for different methods. It describes benchmark results for methods 'Foo' and 'Bar', detailing execution time in milliseconds for specified parameters. The nested structure tracks parameters and execution metrics through iteration indices.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=params01.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"nested\": [\n    {\n      \"parameters\": {\n        \"a\": 1,\n        \"b\": 2\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 10,\n              \"unit\": \"ms\",\n              \"iterationIndex\": 0\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"parameters\": {\n        \"a\": 10,\n        \"b\": 20\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 20,\n              \"unit\": \"ms\",\n              \"iterationIndex\": 0\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".benchmark.method\"\n        },\n        {\n          \"selector\": \".parameters\"\n        },\n        {\n          \"selector\": \"=center\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results with RatioStyle.Trend\nDESCRIPTION: Sample output table showing benchmark results with RatioStyle.Trend, which displays performance differences as \"Nx faster\" or \"Nx slower\" compared to the baseline.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRatioStyle.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|   Method |       Mean |   Error |  StdDev |        Ratio | RatioSD |\n|--------- |-----------:|--------:|--------:|-------------:|--------:|\n| Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms |     baseline |         |\n|      Bar |   150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster |   0.00x |\n|      Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower |   0.00x |\n```\n\n----------------------------------------\n\nTITLE: Runtime Performance Comparison Table for Binary Trees Benchmark\nDESCRIPTION: This table shows benchmark results comparing execution time and memory allocation between .NET 7.0 and .NET Framework 4.8.1 for a Binary Trees benchmark. The results demonstrate similar performance characteristics between the two runtimes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n|        Method |              Runtime |     Mean | Allocated |\n|-------------- |--------------------- |---------:|----------:|\n| BinaryTrees_2 |             .NET 7.0 | 193.6 ms | 227.33 MB |\n| BinaryTrees_2 | .NET Framework 4.8.1 | 192.8 ms | 228.01 MB |\n```\n\n----------------------------------------\n\nTITLE: Analyzing BenchmarkDotNet Entry Structure for Foo Method\nDESCRIPTION: Complete entry structure for the Foo method benchmark from BenchmarkDotNet. Provides detailed configuration and runtime environment information along with performance measurement values across multiple iterations on different .NET Core runtime versions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: config\nCODE:\n```\n[Entry72]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 12\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp22\n  .unit = ns\n  .value = 121\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Package Source for Nightly BenchmarkDotNet Versions\nDESCRIPTION: XML configuration to add the MyGet feed for accessing nightly versions of BenchmarkDotNet packages.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/nuget.md#2025-04-22_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<packageSources>\n  <add key=\"bdn-nightly\" value=\"https://www.myget.org/F/benchmarkdotnet/api/v3/index.json\" />\n</packageSources>\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Results Grouped by Category and Job/Parameter\nDESCRIPTION: This text block shows the output from a BenchmarkDotNet run (v0.10.x-mock). It details the performance metrics (Mean execution time, Error, Standard Deviation, Ratio relative to baseline) for several methods (A1, A2, B1, B2) under different configurations (Job1/Job2, Param=2/10). The results are grouped logically (e.g., CatA-[Param=2]-Job1) with A1 or B1 serving as the baseline within each group. Environment details (OS, CPU, .NET runtime) are provided at the top.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/MarkdownExporterVerifyTests.GroupExporterTest_NoBaseline_MethodsParamsJobs_GroupByCategory.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n=== NoBaseline_MethodsParamsJobs_GroupByCategory ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  Job1   : extra output line\n  Job2   : extra output line\n\n\n Method | Job  | Param | Mean       | Error   | StdDev  | Ratio | RatioSD | Rank | LogicalGroup         | Baseline | \n------- |----- |------ |-----------:|--------:|--------:|------:|--------:|-----:|--------------------- |--------- | \n A1     | Job1 | 2     |   114.5 ns | 5.88 ns | 8.80 ns |  1.01 |    0.11 |    1 | CatA-[Param=2]-Job1  | Yes      | ^ \n A2     | Job1 | 2     |   214.5 ns | 5.88 ns | 8.80 ns |  1.88 |    0.16 |    2 | CatA-[Param=2]-Job1  | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n A1     | Job2 | 2     |   314.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.04 |    1 | CatA-[Param=2]-Job2  | Yes      | \n A2     | Job2 | 2     |   414.5 ns | 5.88 ns | 8.80 ns |  1.32 |    0.05 |    2 | CatA-[Param=2]-Job2  | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n A1     | Job1 | 10    |   514.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.02 |    1 | CatA-[Param=10]-Job1 | Yes      | ^ \n A2     | Job1 | 10    |   614.5 ns | 5.88 ns | 8.80 ns |  1.19 |    0.03 |    2 | CatA-[Param=10]-Job1 | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n A1     | Job2 | 10    |   714.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.02 |    1 | CatA-[Param=10]-Job2 | Yes      | \n A2     | Job2 | 10    |   814.5 ns | 5.88 ns | 8.80 ns |  1.14 |    0.02 |    2 | CatA-[Param=10]-Job2 | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n B1     | Job1 | 2     |   914.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | CatB-[Param=2]-Job1  | Yes      | ^ \n B2     | Job1 | 2     | 1,014.5 ns | 5.88 ns | 8.80 ns |  1.11 |    0.01 |    2 | CatB-[Param=2]-Job1  | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n B1     | Job2 | 2     | 1,114.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | CatB-[Param=2]-Job2  | Yes      | \n B2     | Job2 | 2     | 1,214.5 ns | 5.88 ns | 8.80 ns |  1.09 |    0.01 |    2 | CatB-[Param=2]-Job2  | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n B1     | Job1 | 10    | 1,314.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | CatB-[Param=10]-Job1 | Yes      | ^ \n B2     | Job1 | 10    | 1,414.5 ns | 5.88 ns | 8.80 ns |  1.08 |    0.01 |    2 | CatB-[Param=10]-Job1 | No       | \n        |      |       |            |         |         |       |         |      |                      |          | \n B1     | Job2 | 10    | 1,514.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | CatB-[Param=10]-Job2 | Yes      | \n B2     | Job2 | 10    | 1,614.5 ns | 5.88 ns | 8.80 ns |  1.07 |    0.01 |    2 | CatB-[Param=10]-Job2 | No       | \n\nErrors: 0\n```\n\n----------------------------------------\n\nTITLE: Analyzing BenchmarkDotNet Results for Bench.Foo Method on .NET 5.0\nDESCRIPTION: This snippet shows the benchmark results for the Foo method of the Bench class, running on .NET 5.0 with CPU affinity set to 16. The results include detailed host information and three iterations of the benchmark, with execution times ranging from 161 to 163 nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 16\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net50\n  .unit = ns\n  .value = 161\n```\n\n----------------------------------------\n\nTITLE: Displaying Detailed Statistics Output in BenchmarkDotNet\nDESCRIPTION: Example of the enhanced statistical output format in BenchmarkDotNet console logs. Shows comprehensive metrics including Mean, StdError, StdDev, Min, Max, Median, IQR, fences, and confidence intervals to provide detailed performance analysis.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.8.2.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nMean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us)\nMin = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us\nIQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us\nConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%)\n```\n\n----------------------------------------\n\nTITLE: Sample XML Export Output in BenchmarkDotNet\nDESCRIPTION: Example of an XML export output file showing benchmark results. The output includes environment information, benchmark details, and statistical measurements.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroExportXml.md#2025-04-22_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>IntroXmlExport</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion>\n    <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion>\n    <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName>\n    <ProcessorCount>8</ProcessorCount>\n    <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion>\n    <Architecture>64bit</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>RELEASE</Configuration>\n    <JitModules>clrjit-v4.7.2101.1</JitModules>\n    <DotNetSdkVersion>1.0.4</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>3410220</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <Benchmark>\n      <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Samples.Intro</Namespace>\n      <Type>IntroXmlExport</Type>\n      <Method>Sleep10</Method>\n      <MethodTitle>Sleep10</MethodTitle>\n      <Statistics>\n        <N>15</N>\n        <Min>10989865.8785938</Min>\n        <LowerFence>10989836.0967969</LowerFence>\n        <Q1>10990942.6053125</Q1>\n        <Median>10991249.5870313</Median>\n        <Mean>10991270.0524583</Mean>\n        <Q3>10991680.2776563</Q3>\n        <UpperFence>10992786.7861719</UpperFence>\n        <Max>10992115.5501563</Max>\n        <InterquartileRange>737.672343749553</InterquartileRange>\n        <StandardError>148.484545262958</StandardError>\n        <Variance>330714.902729213</Variance>\n        <StandardDeviation>575.07817097262</StandardDeviation>\n        <Skewness>-0.67759778074187</Skewness>\n        <Kurtosis>3.14296703520386</Kurtosis>\n        <ConfidenceInterval>\n          <N>15</N>\n          <Mean>10991270.0524583</Mean>\n          <StandardError>148.484545262958</StandardError>\n          <Level>L999</Level>\n          <Margin>614.793505974065</Margin>\n          <Lower>10990655.2589524</Lower>\n          <Upper>10991884.8459643</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>10989865.8785938</P0>\n          <P25>10991027.3689063</P25>\n          <P50>10991249.5870313</P50>\n          <P67>10991489.490875</P67>\n          <P80>10991696.7722187</P80>\n          <P85>10991754.5031875</P85>\n          <P90>10991933.1939688</P90>\n          <P95>10992067.441125</P95>\n          <P100>10992115.5501563</P100>\n        </Percentiles>\n      </Statistics>\n    </Benchmark>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Test Results for Enum Parameter Values\nDESCRIPTION: This snippet shows the formatted output of a BenchmarkDotNet performance test. It includes system information, test configuration, and a table of results for different enum values (A, B, C) passed to a 'Benchmark' method.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithAllValuesOfEnum.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n=== WithAllValuesOfEnum ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host]     : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  DefaultJob : extra output line\n\n\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | A             | 114.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | B             | 214.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | C             | 314.5 ns | 5.88 ns | 8.80 ns | ^\n\nErrors: 0\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Actual Benchmark Run Implementation\nDESCRIPTION: Pseudocode showing the core benchmark execution process, including setup, overhead measurement, warmup, actual measurement, and optional memory diagnostics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nResult ActualRun(Method method, Job job)\n{\n    GlobalSetup();\n\n    int unrollFactor = job.Run.UnrollFactor; // 16 by default\n\n    long perfectInvocationCount = Pilot(method, unrollFactor);\n\n    WarmupStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); // EMPTY_METHOD has same return type and arguments as benchmark\n    var overhead = ActualStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor);\n\n    WarmupStage(method, perfectInvocationCount, unrollFactor);\n    var result = ActualStage(method, perfectInvocationCount);\n\n    if (MemoryDiagnoser.IsEnabled)\n        var gcStats = MeasureGcStats(method, perfectInvocationCount, unrollFactor);\n\n    GlobalCleanup(); \n\n    return (result - Median(overhead), gcStats);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Framework Targeting in .NET Project\nDESCRIPTION: XML configuration for targeting multiple .NET frameworks in a benchmark project. Specifies targeting both .NET Core 2.0 and .NET Framework 4.6 with AnyCPU platform.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/faq.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<TargetFrameworks>netcoreapp2.0;net46</TargetFrameworks>\n<PlatformTarget>AnyCPU</PlatformTarget>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Without HideColumns Attribute\nDESCRIPTION: This table shows benchmark results with all columns displayed when the HideColumns attribute is not applied. The output includes detailed memory allocation metrics such as Gen0, Gen1, Gen2, and total allocated memory.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.2.md#2025-04-22_snippet_7\n\nLANGUAGE: ini\nCODE:\n```\n|        Method |     Mean |     Error |    StdDev |    Gen0 |    Gen1 |    Gen2 | Allocated |\n|-------------- |---------:|----------:|----------:|--------:|--------:|--------:|----------:|\n| AllocateArray | 3.303 us | 0.0465 us | 0.0435 us | 31.2462 | 31.2462 | 31.2462 |  97.69 KB |\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Results Table in Markdown\nDESCRIPTION: This code snippet shows a markdown table of benchmark results. It includes the method name, parameter values, mean execution time, error, and standard deviation for each test case.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithAllValuesOfNullableEnum.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | ?             | 114.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | A             | 214.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | B             | 314.5 ns | 5.88 ns | 8.80 ns | ^\n Benchmark | C             | 414.5 ns | 5.88 ns | 8.80 ns | ^\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with MarkdownExporter-console in markdown\nDESCRIPTION: This snippet leverages MarkdownExporter-console, rendering the benchmark results in a markdown-styled table designed for console output. It preserves alignment and formatting for readability in console windows or plain command-line interfaces. This exporter provides an easily accessible presentation for stakeholders reviewing results without specialized markdown rendering tools. No dependencies or parameters are required, and the output remains compatible with basic text viewers.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n| Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n|------- |---------:|---------:|---------:|---------:|------------:|\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results in Markdown Table Format\nDESCRIPTION: Presents a summary table of benchmark results in Markdown format. This table includes the Mean, Error, StdDev, Median, Ratio, and RatioSD columns for multiple benchmark methods, demonstrating how BenchmarkDotNet handles complex scenarios with outliers.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRatioSD.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n Method |      Mean |         Error |        StdDev |    Median | Ratio | RatioSD |\n------- |----------:|--------------:|--------------:|----------:|------:|--------:|\n   Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms |  1.00 |    0.00 |\n   Slow | 200.50 ms |     0.4473 ms |     0.2959 ms | 200.42 ms |  1.80 |    0.62 |\n   Fast |  50.54 ms |     0.3435 ms |     0.2272 ms |  50.48 ms |  0.45 |    0.16 |\n```\n\n----------------------------------------\n\nTITLE: Example BenchmarkDotNet Summary Table Output with Unicode (Markdown)\nDESCRIPTION: Example markdown summary table output from a BenchmarkDotNet run with Unicode enabled. This snippet shows the Mean, Error, and Standard Deviation for a benchmark method ('Foo'), using the Unicode symbol '' for microseconds. This concise table format requires a terminal that supports Unicode.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroUnicode.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n Method |     Mean |     Error |    StdDev |\n------- |---------:|----------:|----------:|\n    Foo | 1.027 s | 0.0020 s | 0.0018 s |\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Pilot Phase Implementation\nDESCRIPTION: Pseudocode demonstrating how BenchmarkDotNet determines the optimal number of method invocations through a pilot run that doubles the invocation count until requirements are met.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nlong Pilot(Method method, int unrollFactor)\n{\n    // invokeCount is the equivalent of InnerIterationCount from xunit-performance\n    long invokeCount = minInvokeCount;\n\n    while (true)\n    {\n        var measurement = RunIteration(method, invokeCount, unrollFactor);\n\n        if (heuristic.IsPilotRequirementMet(measurement))\n            break;\n\n        invokeCount *= 2;\n    }\n\n    return invokeCount;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Benchmark Execution Template in C#\nDESCRIPTION: A template class for BenchmarkDotNet that handles benchmark execution with support for various measurement options, setup/cleanup actions, and return type handling. The class is designed to be filled with benchmark-specific details at code generation time.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// the type name must be in sync with WindowsDisassembler.BuildArguments\npublic unsafe class Runnable_$ID$ : global::$WorkloadTypeName$\n{\n    public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)\n    {\n        BenchmarkDotNet.Autogenerated.Runnable_$ID$ instance = new BenchmarkDotNet.Autogenerated.Runnable_$ID$ { $ParamsInitializer$ }; // do NOT change name \"instance\" (used in SmartParamameter)\n        $ParamsContent$\n\n        host.WriteLine();\n        foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())\n        {\n            host.WriteLine($\"// {infoLine}\");\n        }\n        BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778\n        $JobSetDefinition$;\n        job.Freeze();\n        host.WriteLine($\"// Job: {job.DisplayInfo}\");\n        host.WriteLine();\n\n        System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);\n        if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))\n            return;\n\n        BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()\n        {\n            Host = host,\n            WorkloadActionUnroll = instance.WorkloadActionUnroll,\n            WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,\n            Dummy1Action = instance.Dummy1,\n            Dummy2Action = instance.Dummy2,\n            Dummy3Action = instance.Dummy3,\n            OverheadActionNoUnroll = instance.OverheadActionNoUnroll,\n            OverheadActionUnroll = instance.OverheadActionUnroll,\n            GlobalSetupAction = instance.globalSetupAction,\n            GlobalCleanupAction = instance.globalCleanupAction,\n            IterationSetupAction = instance.iterationSetupAction,\n            IterationCleanupAction = instance.iterationCleanupAction,\n            TargetJob = job,\n            OperationsPerInvoke = $OperationsPerInvoke$,\n            MeasureExtraStats = $MeasureExtraStats$,\n            BenchmarkName = benchmarkName\n        };\n\n        using (BenchmarkDotNet.Engines.IEngine engine = new $EngineFactoryType$().CreateReadyToRun(engineParameters))\n        {\n            BenchmarkDotNet.Engines.RunResults results = engine.Run();\n\n            host.ReportResults(results); // printing costs memory, do this after runs\n\n            instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)\n        }\n    }\n\n    public delegate $OverheadMethodReturnTypeName$ OverheadDelegate($ArgumentsDefinition$);\n\n    public delegate $WorkloadMethodReturnTypeModifiers$ $WorkloadMethodReturnType$ WorkloadDelegate($ArgumentsDefinition$);\n\n    public Runnable_$ID$()\n    {\n        globalSetupAction = $GlobalSetupMethodName$;\n        globalCleanupAction = $GlobalCleanupMethodName$;\n        iterationSetupAction = $IterationSetupMethodName$;\n        iterationCleanupAction = $IterationCleanupMethodName$;\n        overheadDelegate = __Overhead;\n        workloadDelegate = $WorkloadMethodDelegate$;\n        $InitializeArgumentFields$\n    }\n\n    private System.Action globalSetupAction;\n    private System.Action globalCleanupAction;\n    private System.Action iterationSetupAction;\n    private System.Action iterationCleanupAction;\n    private BenchmarkDotNet.Autogenerated.Runnable_$ID$.OverheadDelegate overheadDelegate;\n    private BenchmarkDotNet.Autogenerated.Runnable_$ID$.WorkloadDelegate workloadDelegate;\n    $DeclareArgumentFields$\n\n    // this method is used only for the disassembly diagnoser purposes\n    // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself\n    public System.Int32 NotEleven;\n    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n    public void __TrickTheJIT__()\n    {\n        NotEleven = new System.Random(123).Next(0, 10);\n        $DisassemblerEntryMethodName$();\n    }\n\n    private System.Int32 dummyVar;\n\n    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n    private void Dummy1()\n    {\n        @DummyUnroll@\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n    private void Dummy2()\n    {\n        @DummyUnroll@\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n    private void Dummy3()\n    {\n        @DummyUnroll@\n    }\n\n    private $OverheadMethodReturnTypeName$ __Overhead($ArgumentsDefinition$) // __ is to avoid possible name conflict\n    {\n        $OverheadImplementation$\n    }\n\n#if RETURNS_CONSUMABLE_$ID$\n\n    private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void OverheadActionUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            consumer.Consume(overheadDelegate($PassArguments$));@Unroll@\n        }\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void OverheadActionNoUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            consumer.Consume(overheadDelegate($PassArguments$));\n        }\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void WorkloadActionUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        for (System.Int64  i = 0; i < invokeCount; i++)\n        {\n            consumer.Consume(workloadDelegate($PassArguments$)$ConsumeField$);@Unroll@\n        }\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void WorkloadActionNoUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            consumer.Consume(workloadDelegate($PassArguments$)$ConsumeField$);\n        }\n    }\n    \n    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\n    public $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()\n    {\n        if (NotEleven == 11)\n        {\n            $LoadArguments$\n            return $WorkloadMethodCall$;\n        }\n        \n        return default($WorkloadMethodReturnType$);\n    }\n\n#elif RETURNS_NON_CONSUMABLE_STRUCT_$ID$\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void OverheadActionUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        $OverheadMethodReturnTypeName$ result = default($OverheadMethodReturnTypeName$);\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            result = overheadDelegate($PassArguments$);@Unroll@\n        }\n        BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void OverheadActionNoUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        $OverheadMethodReturnTypeName$ result = default($OverheadMethodReturnTypeName$);\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            result = overheadDelegate($PassArguments$);\n        }\n        BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void WorkloadActionUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        $WorkloadMethodReturnType$ result = default($WorkloadMethodReturnType$);\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            result = workloadDelegate($PassArguments$);@Unroll@\n        }\n        NonGenericKeepAliveWithoutBoxing(result);\n    }\n\n    [System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\n    private void WorkloadActionNoUnroll(System.Int64 invokeCount)\n    {\n        $LoadArguments$\n        $WorkloadMethodReturnType$ result = default($WorkloadMethodReturnType$);\n        for (System.Int64 i = 0; i < invokeCount; i++)\n        {\n            result = workloadDelegate($PassArguments$);\n        }\n        NonGenericKeepAliveWithoutBoxing(result);\n    }\n\n    // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method\n```\n\n----------------------------------------\n\nTITLE: Demonstrating DocFX Note Syntax in Markdown\nDESCRIPTION: This snippet showcases the syntax for creating different types of notes (NOTE, TIP, WARNING, IMPORTANT, Caution) in DocFX flavored Markdown. It demonstrates how to format these notes within block quotes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/documentation.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n> [!NOTE]\n> note content\n> [!TIP]\n> tip content\n> [!WARNING]\n> warning content\n> [!IMPORTANT]\n> important content\n> [!Caution]\n> caution content\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Output: NoBaseline_MethodsParamsJobs_GroupByAll Results\nDESCRIPTION: This text block shows the formatted output table from a BenchmarkDotNet run. It includes environment details (CPU, OS, .NET Runtime) and performance metrics (Mean, Error, StdDev) for benchmarked methods (A1, A2, B1, B2) executed with different jobs (Job1, Job2) and parameters (Param: 2, 10). The 'LogicalGroup' column indicates the specific combination being measured, and the 'Baseline' column shows whether a method is considered a baseline for comparison (Yes/No). Ratios are calculated against the baseline within the same logical group.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/MarkdownExporterVerifyTests.GroupExporterTest_NoBaseline_MethodsParamsJobs_GroupByAll.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n=== NoBaseline_MethodsParamsJobs_GroupByAll ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  Job1   : extra output line\n  Job2   : extra output line\n\n\n Method | Job  | Param | Mean       | Error   | StdDev  | Ratio | RatioSD | Rank | LogicalGroup                                                    | Baseline |\n------- |----- |------ |-----------:|--------:|--------:|------:|--------:|-----:|---------------------------------------------------------------- |--------- |\n A1     | Job1 | 2     |   114.5 ns | 5.88 ns | 8.80 ns |  1.01 |    0.11 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A1-Job1-[Param=2]-CatA  | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A1     | Job1 | 10    |   514.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.02 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A1-Job1-[Param=10]-CatA | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A1     | Job2 | 2     |   314.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.04 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A1-Job2-[Param=2]-CatA  | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A1     | Job2 | 10    |   714.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.02 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A1-Job2-[Param=10]-CatA | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A2     | Job1 | 2     |   214.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A2-Job1-[Param=2]-CatA  | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A2     | Job1 | 10    |   614.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A2-Job1-[Param=10]-CatA | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A2     | Job2 | 2     |   414.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A2-Job2-[Param=2]-CatA  | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n A2     | Job2 | 10    |   814.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.A2-Job2-[Param=10]-CatA | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B1     | Job1 | 2     |   914.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B1-Job1-[Param=2]-CatB  | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B1     | Job1 | 10    | 1,314.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B1-Job1-[Param=10]-CatB | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B1     | Job2 | 2     | 1,114.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B1-Job2-[Param=2]-CatB  | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B1     | Job2 | 10    | 1,514.5 ns | 5.88 ns | 8.80 ns |  1.00 |    0.01 |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B1-Job2-[Param=10]-CatB | Yes      | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B2     | Job1 | 2     | 1,014.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B2-Job1-[Param=2]-CatB  | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B2     | Job1 | 10    | 1,414.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B2-Job1-[Param=10]-CatB | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B2     | Job2 | 2     | 1,214.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B2-Job2-[Param=2]-CatB  | No       | ^\n        |      |       |            |         |         |       |         |      |                                                                 |          |\n B2     | Job2 | 10    | 1,614.5 ns | 5.88 ns | 8.80 ns |     ? |       ? |    1 | NoBaseline_MethodsParamsJobs_GroupByAll.B2-Job2-[Param=10]-CatB | No       | ^\n\nErrors: 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Power Plan Options in BenchmarkDotNet\nDESCRIPTION: Example showing how to configure different power plans for benchmarks using ManualConfig. The code demonstrates setting both HighPerformance and UserPowerPlan options and comparing their performance impact on two benchmark methods.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.5.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Config(typeof(Config))]\npublic class IntroPowerPlan\n{\n    private class Config : ManualConfig\n    {\n        public Config()\n        {\n            Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance));\n            Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan));\n        }\n    }\n\n    [Benchmark]\n    public int IterationTest()\n    {\n        int j = 0;\n        for (int i = 0; i < short.MaxValue; ++i)\n            j = i;\n        return j;\n    }\n\n    [Benchmark]\n    public int SplitJoin()\n        => string.Join(\",\", new string[1000]).Split(',').Length;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with MarkdownExporter-stackoverflow in markdown\nDESCRIPTION: This snippet applies MarkdownExporter-stackoverflow's formatting, using indented blocks for preformatted content and tables, imitating Stack Overflow answer styling. It provides identical performance data for Foo and Bar benchmarks as in other exporters, maintaining structural and statistical consistency. Ready for direct pasting into Stack Overflow code answers to ensure data presentation fidelity. No markdown dependencies required since Stack Overflow supports this simple format natively.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n    BenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\n    MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n    Frequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n    .NET Core SDK 1.0.x.mock\n      [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\n    Job=LongRun  IterationCount=100  LaunchCount=3  \n    WarmupCount=15  \n\n     Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n    ------- |---------:|---------:|---------:|---------:|------------:|\n     Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n     Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Output with Parameter Type Error\nDESCRIPTION: A BenchmarkDotNet results output showing benchmark measurements along with an error message. The error indicates that Int32 cannot be used with [ParamsAllValues] attribute, as only boolean, enum types, and nullable versions of these types are allowed.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithNotAllowedTypeError.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n=== WithNotAllowedTypeError ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host]     : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  DefaultJob : extra output line\n\n\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | 0             | 114.5 ns | 5.88 ns | 8.80 ns |\n\nErrors: 1\n* Type Int32 cannot be used with [ParamsAllValues], allowed types are: bool, enum types and nullable type for another allowed type.\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Memory Diagnostics Implementation\nDESCRIPTION: Pseudocode showing how BenchmarkDotNet collects garbage collection statistics by measuring the difference between initial and final GC states after running an additional benchmark iteration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/how-it-works.md#2025-04-22_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nGcStats MeasureGcStats(Method method, long invokeCount, long unrollFacto)\n{\n    // we enable monitoring after workload actual run, for this single iteration which is executed at the end\n    // so even if we enable AppDomain monitoring in separate process\n    // it does not matter, because we have already obtained the results!\n    EnableMonitoring(); \n\n    IterationSetup();\n\n    var initialGcStats = GcStats.ReadInitial();\n\n    // we do NOT start any clock here, because the enabled monitoring might have some overhead\n    // so we just get the gc stats and ignore the timing\n    // it's last thing the process does before it dies, so also enabled monitoring is not an issue for next benchmarks\n    // because each of them is going to be executed in a new process\n\n    for (long i = 0; i < invokeCount / unrollFactor; i++)\n    {\n        // we perform manual loop unrolling!!\n        method(); // 1st call\n        method(); // 2nd call\n\n        method(); // (unrollFactor - 1)'th call\n        method(); // unrollFactor'th call\n    }\n\n    var finalGcStats = GcStats.ReadFinal();\n\n    IterationCleanup();\n\n    return finalGcStats - initialGcStats; // the result is the difference between the stats collected after and before running the extra iteration\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Generic Keep-Alive Helper Method in C#\nDESCRIPTION: A private helper method designed to prevent the JIT compiler from optimizing away code related to non-generic value types or structs, particularly relevant for types like Span<T> which cannot be generic arguments. The `NoInlining` option ensures this method call is not inlined, preserving its role in keeping the argument alive.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument\n[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\nprivate void NonGenericKeepAliveWithoutBoxing($WorkloadMethodReturnType$ _) { }\n```\n\n----------------------------------------\n\nTITLE: Including C# Sample Code Using DocFX Directive\nDESCRIPTION: This code snippet demonstrates how to include a C# sample file from the BenchmarkDotNet.Samples project using DocFX's code inclusion directive.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroTemplate.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[!code-csharp[SAMPLENAME.cs](../../../samples/BenchmarkDotNet.Samples/SAMPLENAME.cs)]\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results in HTML Format\nDESCRIPTION: Sample output of BenchmarkDotNet's HtmlExporter showing benchmark results as an HTML page. The HTML includes CSS styling for tables, system information, and benchmark results presented in a formatted table for methods 'Foo' and 'Bar'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='utf-8' />\n<title>MockSummary</title>\n\n<style type=\"text/css\">\n\ttable { border-collapse: collapse; display: block; width: 100%; overflow: auto; }\n\ttd, th { padding: 6px 13px; border: 1px solid #ddd; text-align: right; }\n\ttr { background-color: #fff; border-top: 1px solid #ccc; }\n\ttr:nth-child(even) { background: #f8f8f8; }\n</style>\n</head>\n<body>\n<pre><code>\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n</code></pre>\n<pre><code>Job=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n</code></pre>\n\n<table>\n<thead><tr><th>Method</th><th>Mean</th><th>Error</th><th>StdDev</th><th>P67</th><th>CacheMisses</th>\n</tr>\n</thead><tbody><tr><td>Foo</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\n</tr><tr><td>Bar</td><td>1.000 ns</td><td>0.000 ns</td><td>0.000 ns</td><td>1.000 ns</td><td>7</td>\n</tr></tbody></table>\n</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Defining IntroOrderManual Sample in C#\nDESCRIPTION: This code snippet defines the IntroOrderManual sample class for BenchmarkDotNet. It demonstrates how to manually order benchmark methods using the OrderAttribute.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroOrderManual.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[SimpleJob(RuntimeMoniker.Net462, baseline: true)]\n[SimpleJob(RuntimeMoniker.Net50)]\n[RPlotExporter]\n[MemoryDiagnoser]\npublic class IntroOrderManual\n{\n    [Benchmark(Baseline = true)]\n    [Order(10)]\n    public void A() => Thread.Sleep(10);\n\n    [Benchmark]\n    [Order(20)]\n    public void B() => Thread.Sleep(10);\n\n    [Benchmark]\n    [Order(30)]\n    public void C() => Thread.Sleep(10);\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with MarkdownExporter-github in markdown\nDESCRIPTION: This snippet presents benchmark results as output by MarkdownExporter-github. It wraps the result summary in a triple-backtick markdown code block, then outputs a markdown table of benchmarked methods and metrics for direct embedding into GitHub repositories or markdown documents. All data reflects the same mock results, ensuring accuracy and comparability between exporters. The snippet is self-contained and ready for use in GitHub readmes or comments.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n```\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n```\n| Method | Mean     | Error    | StdDev   | P67      | CacheMisses |\n|------- |---------:|---------:|---------:|---------:|------------:|\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Examining Auto-generated Project File for NativeAOT Benchmarks in XML\nDESCRIPTION: This snippet displays the content of an auto-generated project file (BenchmarkDotNet.Autogenerated.csproj) created by BenchmarkDotNet for NativeAOT compilation. It includes configuration settings like optimization preferences, trimming settings, and instruction set options.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_16\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <ImportDirectoryBuildProps>false</ImportDirectoryBuildProps>\n    <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net7.0</TargetFramework>\n    <RuntimeIdentifier>win-x64</RuntimeIdentifier>\n    <RuntimeFrameworkVersion></RuntimeFrameworkVersion>\n    <AssemblyName>Job-KRLVKQ</AssemblyName>\n    <AssemblyTitle>Job-KRLVKQ</AssemblyTitle>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <PlatformTarget>x64</PlatformTarget>\n    <TreatWarningsAsErrors>False</TreatWarningsAsErrors>\n    <DebugSymbols>false</DebugSymbols>\n    <UseSharedCompilation>false</UseSharedCompilation>\n    <Deterministic>true</Deterministic>\n    <RunAnalyzers>false</RunAnalyzers>\n    <IlcOptimizationPreference>Speed</IlcOptimizationPreference>\n    <TrimMode>link</TrimMode><TrimmerDefaultAction>link</TrimmerDefaultAction>\n    <IlcGenerateCompleteTypeMetadata>True</IlcGenerateCompleteTypeMetadata>\n    <IlcGenerateStackTraceData>True</IlcGenerateStackTraceData>\n    <EnsureNETCoreAppRuntime>false</EnsureNETCoreAppRuntime>\n    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>\n  </PropertyGroup>\n  <PropertyGroup>\n    <ServerGarbageCollection>false</ServerGarbageCollection>\n    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>\n  </PropertyGroup>\n  <ItemGroup>\n    <Compile Include=\"Job-KRLVKQ.notcs\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\n  </ItemGroup>\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.DotNet.ILCompiler\" Version=\"7.0.0-*\" />\n    <ProjectReference Include=\"D:\\projects\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj\" />\n  </ItemGroup>\n  <ItemGroup>\n    <RdXmlFile Include=\"bdn_generated.rd.xml\" />\n  </ItemGroup>\n  <ItemGroup>\n    <IlcArg Include=\"--instructionset:base,sse,sse2,sse3,sse4.1,sse4.2,avx,avx2,aes,bmi,bmi2,fma,lzcnt,pclmul,popcnt\" />\n  </ItemGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Warning for Deferred Execution\nDESCRIPTION: This log snippet shows the warning message that BenchmarkDotNet displays when a benchmark returns a deferred execution result. It advises users to either change the method to return a materialized result or consume the result manually.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDeferredExecution.md#2025-04-22_snippet_0\n\nLANGUAGE: log\nCODE:\n```\nBenchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that.\n```\n\n----------------------------------------\n\nTITLE: Disassembler Entry Point for Ref Readonly Methods in C#\nDESCRIPTION: A public method providing an entry point for disassembler analysis when the benchmarked method returns `ref readonly T`. It conditionally executes the workload method (`$WorkloadMethodCall$`) once, returning the readonly reference. `NoOptimization` and `NoInlining` attributes are applied. If the condition fails, it returns a readonly reference to `workloadDefaultValueHolder`.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\npublic ref readonly $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()\n{\n    if (NotEleven == 11)\n    {\n        $LoadArguments$\n        return ref $WorkloadMethodCall$;\n    }\n    \n    return ref workloadDefaultValueHolder;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Path for Mono AOT Compiler Binary (Text)\nDESCRIPTION: Shows an example file path where the Mono AOT compiler binary (`mono-sgen`) is typically generated after building the `dotnet/runtime` repository. The path shown is specific to an OSX x64 Release build and needs adjustment for different platforms or configurations. This path is intended for use with the `--aotcompilerpath` flag.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_23\n\nLANGUAGE: text\nCODE:\n```\n<runtime root>/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results in Compressed JSON Format\nDESCRIPTION: Sample output of BenchmarkDotNet's compressed JSON exporter showing the same benchmark data as the pretty-printed version but in a minified format. This format is optimized for file size while containing the same information.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"Title\":\"MockSummary\",\"HostEnvironmentInfo\":{\"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\"BenchmarkDotNetVersion\":\"0.10.x-mock\",\"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\"PhysicalProcessorCount\":1,\"PhysicalCoreCount\":4,\"LogicalCoreCount\":8,\"RuntimeVersion\":\"Clr 4.0.x.mock\",\"Architecture\":\"64mock\",\"HasAttachedDebugger\":false,\"HasRyuJit\":true,\"Configuration\":\"CONFIGURATION\",\"DotNetCliVersion\":\"1.0.x.mock\",\"ChronometerFrequency\":{\"Hertz\":2531248},\"HardwareTimerKind\":\"Tsc\"},\"Benchmarks\":[{\"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Foo\",\"MethodTitle\":\"Foo\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}},{\"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\"Type\":\"MockBenchmarkClass\",\"Method\":\"Bar\",\"MethodTitle\":\"Bar\",\"Parameters\":\"\",\"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\"HardwareIntrinsics\":\"\",\"Statistics\":{\"OriginalValues\":[1,1,1,1,1,1],\"N\":6,\"Min\":1,\"LowerFence\":1,\"Q1\":1,\"Median\":1,\"Mean\":1,\"Q3\":1,\"UpperFence\":1,\"Max\":1,\"InterquartileRange\":0,\"LowerOutliers\":[],\"UpperOutliers\":[],\"AllOutliers\":[],\"StandardError\":0,\"Variance\":0,\"StandardDeviation\":0,\"Skewness\":\"\",\"Kurtosis\":\"\",\"ConfidenceInterval\":{\"N\":6,\"Mean\":1,\"StandardError\":0,\"Level\":12,\"Margin\":0,\"Lower\":1,\"Upper\":1},\"Percentiles\":{\"P0\":1,\"P25\":1,\"P50\":1,\"P67\":1,\"P80\":1,\"P85\":1,\"P90\":1,\"P95\":1,\"P100\":1}},\"Memory\":{\"Gen0Collections\":0,\"Gen1Collections\":0,\"Gen2Collections\":0,\"TotalOperations\":0,\"BytesAllocatedPerOperation\":null}}]}\n```\n\n----------------------------------------\n\nTITLE: Parsing BenchmarkDotNet Log Entries for .NET Framework Performance Comparison\nDESCRIPTION: This code snippet represents a BenchmarkDotNet log file capturing performance metrics of Bench.Foo and Bench.Bar methods across different .NET runtimes. Each entry contains detailed execution environment information including CPU specifications, runtime versions, JIT configuration, and benchmark timing values in nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 5\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net47\n  .unit = ns\n  .value = 57\n[Entry35]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 5\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net47\n  .unit = ns\n  .value = 58\n```\n\n----------------------------------------\n\nTITLE: Detailed BenchmarkDotNet Results and Configuration in JSON\nDESCRIPTION: This JSON object provides a detailed report of the BenchmarkDotNet run. It includes engine and host environment information (OS, CPU, .NET version, frequencies), followed by a nested structure outlining each job configuration (runtime, JIT, affinity). For each job, it lists the benchmarks ('Foo', 'Bar') and their individual iteration results (value in nanoseconds and iteration index).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default05.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"engine\": {\n    \"name\": \"BenchmarkDotNet\",\n    \"version\": \"0.1729.0-mock\"\n  },\n  \"host\": {\n    \"runtimeVersion\": \"Clr 4.0.x.mock\",\n    \"hasAttachedDebugger\": false,\n    \"hasRyuJit\": true,\n    \"configuration\": \"CONFIGURATION\",\n    \"dotNetSdkVersion\": \"1.0.x.mock\",\n    \"chronometerFrequency\": 2531248,\n    \"hardwareTimerKind\": \"Tsc\",\n    \"os\": {\n      \"display\": \"Microsoft Windows NT 10.0.x.mock\"\n    },\n    \"cpu\": {\n      \"processorName\": \"MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\",\n      \"physicalProcessorCount\": 1,\n      \"physicalCoreCount\": 4,\n      \"logicalCoreCount\": 8,\n      \"nominalFrequencyHz\": 3100000000,\n      \"maxFrequencyHz\": 3100000000\n    }\n  },\n  \"nested\": [\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"hostProcess\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 0\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 1,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 2,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 3,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 6,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 7,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 8,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"notRecognized\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 1\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 11,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 12,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 13,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 16,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 17,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 18,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"mono\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 2\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 21,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 22,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 23,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 26,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 27,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 28,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net461\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 3\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 31,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 32,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 33,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 36,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 37,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 38,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net462\",\n          \"jit\": \"ryuJit\",\n          \"affinity\": 4\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 41,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 42,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 43,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 46,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n```\n\n----------------------------------------\n\nTITLE: F# Setup Command for BenchmarkDotNet\nDESCRIPTION: Command to restore dependencies for using F# with BenchmarkDotNet. This is required to download the F# compilers and related dependencies.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/miscellaneous.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet restore\n```\n\n----------------------------------------\n\nTITLE: EventPipeProfiler Output in Markdown\nDESCRIPTION: This markdown snippet shows the expected output of running a benchmark with EventPipeProfiler. It includes the path to the exported trace file, which can be analyzed using SpeedScope.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroEventPipeProfiler.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```markdown\n// * Diagnostic Output - EventPipeProfiler *\nExported 1 trace file(s). Example:\nC:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Core Project Properties for BenchmarkDotNet AOT Compilation\nDESCRIPTION: Sets up the essential project properties including paths to the original CSProj file and related Mono configuration files. These properties establish the foundation for AOT compilation configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<PropertyGroup>\n    <OriginalCSProjPath>$CSPROJPATH$</OriginalCSProjPath>\n    <MonoPropsPath>$([System.IO.Path]::ChangeExtension('$(OriginalCSProjPath)', '.Mono.props'))</MonoPropsPath>\n    <MonoTargetsPath>$([System.IO.Path]::ChangeExtension('$(OriginalCSProjPath)', '.Mono.targets'))</MonoTargetsPath>\n  </PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration for .NET Applications in JSON\nDESCRIPTION: Defines performance benchmarking configurations using JSON for .NET applications. Each configuration specifies the runtime, JIT compiler, and processor affinity, and benchmarks two methods ('Foo' and 'Bar') by measuring execution times over a series of iterations. Key parameters include 'runtime' indicating the .NET version, 'jit' for the JIT compiler type, and 'affinity' for processor binding. Outputs are execution times in nanoseconds, categorized by method and iteration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default05.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"job\": {\n    \"environment\": {\n      \"runtime\": \"net47\",\n      \"jit\": \"ryuJit\",\n      \"affinity\": 5\n    }\n  },\n  \"nested\": [\n    {\n      \"benchmark\": {\n        \"type\": \"Bench\",\n        \"method\": \"Foo\"\n      },\n      \"nested\": [\n        {\n          \"value\": 51,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 0\n        },\n        {\n          \"value\": 52,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 1\n        },\n        {\n          \"value\": 53,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 2\n        }\n      ]\n    },\n    {\n      \"benchmark\": {\n        \"type\": \"Bench\",\n        \"method\": \"Bar\"\n      },\n      \"nested\": [\n        {\n          \"value\": 56,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 0\n        },\n        {\n          \"value\": 57,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 1\n        },\n        {\n          \"value\": 58,\n          \"unit\": \"ns\",\n          \"iterationIndex\": 2\n        }\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results in AsciiDoc Format\nDESCRIPTION: Sample output of BenchmarkDotNet's AsciiDocExporter showing benchmark results in AsciiDoc format. The output includes system information and benchmark results for methods 'Foo' and 'Bar', with metrics like mean execution time, error, standard deviation, P67 percentile, and cache misses.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: asciidoc\nCODE:\n```\n############################################\nAsciiDocExporter\n############################################\n....\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n....\n[options=\"header\"]\n|===\n|Method  |Mean      |Error     |StdDev    |P67       |CacheMisses  \n|Foo     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\n|Bar     |  1.000 ns|  0.000 ns|  0.000 ns|  1.000 ns|            7\n|===\n```\n\n----------------------------------------\n\nTITLE: Improved Disassembly Output Example - Before\nDESCRIPTION: An example showing the disassembly output before improvements. The output contains raw memory addresses and unclear references to runtime helper methods and method tables.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_3\n\nLANGUAGE: x86asm\nCODE:\n```\n; MicroBenchmarks.WithCallsAfter.Benchmark(Int32)\n       push    rsi\n       sub     rsp,20h\n       mov     rsi,rcx\n       cmp     edx,7FFFFFFFh\n       jne     M00_L00\n       call    MicroBenchmarks.WithCallsAfter.Static()\n       mov     rcx,rsi\n       call    MicroBenchmarks.WithCallsAfter.Instance()\n       mov     rcx,rsi\n       call    MicroBenchmarks.WithCallsAfter.Recursive()\n       mov     rcx,rsi\n       mov     rax,qword ptr [rsi]\n       mov     rax,qword ptr [rax+40h]\n       call    qword ptr [rax+20h]\n       mov     rcx,rsi\n       mov     edx,1\n       mov     rax,7FF8F4217050h\n       add     rsp,20h\n       pop     rsi\n       jmp     rax\nM00_L00:\n       mov     rcx,offset System_Private_CoreLib+0xa31d48\n       call    coreclr!MetaDataGetDispenser+0x322a0\n       mov     rsi,rax\n       mov     ecx,0ACFAh\n       mov     rdx,7FF8F42F4680h\n       call    coreclr!MetaDataGetDispenser+0x17140\n       mov     rdx,rax\n       mov     rcx,rsi\n       call    System.InvalidOperationException..ctor(System.String)\n       mov     rcx,rsi\n       call    coreclr!coreclr_shutdown_2+0x39f0\n       int     3\n       add     byte ptr [rax],al\n       sbb     dword ptr [00007ff9`26284e30],eax\n       add     dword ptr [rax+40h],esp\n       add     byte ptr [rax],al\n       add     byte ptr [rax],al\n       add     byte ptr [rax],al\n       add     byte ptr [rax-70BC4CCh],ah\n; Total bytes of code 157\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Project Template in MSBuild Format\nDESCRIPTION: A comprehensive MSBuild project template for BenchmarkDotNet benchmark applications. It defines project properties including target framework, assembly settings, compiler options, and references. The template uses placeholders (marked with $ symbols) that are replaced when generating actual benchmark projects.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/CsProj.txt#2025-04-22_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<Project Sdk=\"$SDKNAME$\">\n\n  <PropertyGroup>\n    <ImportDirectoryBuildProps>false</ImportDirectoryBuildProps>\n    <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets>\n    <AssemblyTitle>$PROGRAMNAME$</AssemblyTitle>\n    <TargetFramework>$TFM$</TargetFramework>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <PlatformTarget>$PLATFORM$</PlatformTarget>\n    <AssemblyName>$PROGRAMNAME$</AssemblyName>\n    <OutputType>Exe</OutputType>\n    <OutputPath>bin\\$CONFIGURATIONNAME$</OutputPath>\n    <TreatWarningsAsErrors>False</TreatWarningsAsErrors>\n    <!-- Usage of System.Random can cause compilation errors if Code Analysis warnings are treated as Errors -->\n    <CodeAnalysisTreatWarningsAsErrors>false</CodeAnalysisTreatWarningsAsErrors>\n    <!-- disabled due to https://github.com/dotnet/roslyn/issues/59421 -->\n    <DebugSymbols>false</DebugSymbols>\n    <UseSharedCompilation>false</UseSharedCompilation>\n    <CodeAnalysisRuleSet></CodeAnalysisRuleSet>\n    <RunAnalyzers>false</RunAnalyzers>\n    <Deterministic>true</Deterministic>\n    <!-- needed for custom build configurations (only \"Release\" builds are optimized by default) -->\n    <Optimize Condition=\" '$(Configuration)' != 'Debug' \">true</Optimize>\n    <!-- we set LangVersion after any copied settings which might contain LangVersion copied from the benchmarks project -->\n    <LangVersion Condition=\"'$(LangVersion)' == '' Or ($([System.Char]::IsDigit('$(LangVersion)', 0)) And '$(LangVersion)' &lt; '7.3')\">latest</LangVersion>\n    <AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>\n    <!-- fix for NETSDK1150: https://docs.microsoft.com/en-us/dotnet/core/compatibility/sdk/5.0/referencing-executable-generates-error -->\n    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>\n    <!-- Suppress warning for nuget package used in old (unsupported) tfm. -->\n    <SuppressTfmSupportBuildWarnings>true</SuppressTfmSupportBuildWarnings>\n    <StartupObject>BenchmarkDotNet.Autogenerated.UniqueProgramName</StartupObject>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <Compile Include=\"$CODEFILENAME$\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"$CSPROJPATH$\" />\n  </ItemGroup>\n\n  <!-- Begin copied settings from benchmarks project -->\n  $COPIEDSETTINGS$\n  <!-- End copied settings -->\n\n  $RUNTIMESETTINGS$\n\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Build Error Log Example in BenchmarkDotNet\nDESCRIPTION: Example log output showing a build failure in BenchmarkDotNet, demonstrating how BDN reports compilation errors and provides paths to build artifacts for troubleshooting.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/troubleshooting.md#2025-04-22_snippet_0\n\nLANGUAGE: log\nCODE:\n```\n// Validating benchmarks:\\n// ***** BenchmarkRunner: Start   *****\\n// ***** Found 1 benchmark(s) in total *****\\n// ***** Building 1 exe(s) in Parallel: Start   *****\\n// start dotnet restore  /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\n// command took 0.51s and exited with 1\\n// ***** Done, took 00:00:00 (0.66 sec)   *****\\n// Found 1 benchmarks:\\n//   IntroBasic.Sleep: DefaultJob\\n\\n// Build Error: Standard output:\\n\\n Standard error:\\n C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\BenchmarkDotNet.Autogenerated.csproj(36,1): error MSB4025: The project file could not be loaded. Unexpected end of file while parsing Comment has occurred. Line 36, position 1.\\n\\n// BenchmarkDotNet has failed to build the auto-generated boilerplate code.\\n// It can be found in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\n// Please follow the troubleshooting guide: https://benchmarkdotnet.org/articles/guides/troubleshooting.html\n```\n\n----------------------------------------\n\nTITLE: Command Line Usage for Joining Benchmarks\nDESCRIPTION: Example command line syntax for joining benchmark results with the specified category filter.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroJoin.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--join --allCategories=IntroJoinA\n```\n\n----------------------------------------\n\nTITLE: Reporting Benchmark Results and Enum Flag Attribute Errors - BenchmarkDotNet - Markdown\nDESCRIPTION: This snippet displays the output from a BenchmarkDotNet run, including machine specifications, runtime details, formatted measured results, and a highlighting of an error encountered when using the [ParamsAllValues] attribute with a flags enum parameter. No code execution occurs; instead, the snippet provides structured reporting and documents framework constraints when working with enum flag types as parameters. BenchmarkDotNet must be referenced, and care should be taken to avoid using [ParamsAllValues] with flag enums to prevent similar errors.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Attributes/VerifiedFiles/ParamsAllValuesVerifyTests.BenchmarkShouldProduceSummary_WithNotAllowedFlagsEnumError.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n=== WithNotAllowedFlagsEnumError ===\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n  [Host]     : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n  DefaultJob : extra output line\n\n\n Method    | ParamProperty | Mean     | Error   | StdDev  |\n---------- |-------------- |---------:|--------:|--------:|\n Benchmark | 0             | 114.5 ns | 5.88 ns | 8.80 ns |\n\nErrors: 1\n* Unable to use TestFlagsEnum with [ParamsAllValues], because it's flags enum.\n```\n\n----------------------------------------\n\nTITLE: Including Benchmark Code and Project References\nDESCRIPTION: Specifies the code file to compile and project references needed for the benchmark. This ensures the benchmark code is included in the build while excluding unnecessary files like binaries and packages.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_3\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <Compile Include=\"$CODEFILENAME$\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"$CSPROJPATH$\" />\n  </ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Entry Format in INI-like Configuration\nDESCRIPTION: The file shows multiple benchmark entries in an INI-like format that captures benchmark results, test environment details, and execution parameters. Each entry contains information about the benchmark method, host environment (CPU, OS, runtime), and job configuration, with the result value in nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 7\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net472\n  .unit = ns\n  .value = 72\n[Entry44]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 7\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net472\n  .unit = ns\n  .value = 73\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet JSON Export Structure\nDESCRIPTION: Full JSON export format showing benchmark results including detailed statistics, memory metrics, iteration measurements and hardware counters. The export contains results for mock benchmark methods with iteration counts, nanosecond measurements and cache miss metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_en-US.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"Parameters\":\"\",\n   \"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\n   \"HardwareIntrinsics\":\"\",\n   \"Statistics\":{\n      \"OriginalValues\":[1,1,1,1,1,1],\n      \"N\":6,\n      \"Min\":1,\n      \"LowerFence\":1,\n      \"Q1\":1,\n      \"Median\":1,\n      \"Mean\":1,\n      \"Q3\":1,\n      \"UpperFence\":1,\n      \"Max\":1,\n      \"InterquartileRange\":0,\n      \"LowerOutliers\":[],\n      \"UpperOutliers\":[],\n      \"AllOutliers\":[],\n      \"StandardError\":0,\n      \"Variance\":0,\n      \"StandardDeviation\":0,\n      \"Skewness\":\"\",\n      \"Kurtosis\":\"\",\n      \"ConfidenceInterval\":{\n         \"N\":6,\n         \"Mean\":1,\n         \"StandardError\":0,\n         \"Level\":12,\n         \"Margin\":0,\n         \"Lower\":1,\n         \"Upper\":1\n      },\n      \"Percentiles\":{\n         \"P0\":1,\n         \"P25\":1,\n         \"P50\":1,\n         \"P67\":1,\n         \"P80\":1,\n         \"P85\":1,\n         \"P90\":1,\n         \"P95\":1,\n         \"P100\":1\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Output for SumLocal Method\nDESCRIPTION: Disassembly output for the SumLocal method showing the x86 assembly code generated by RyuJIT in .NET Core 2.1.16. This method uses a local variable that points to the field array.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_1\n\nLANGUAGE: x86asm\nCODE:\n```\n; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal()\n       mov       rax,[rcx+8]\n       xor       edx,edx\n       xor       ecx,ecx\n       mov       r8d,[rax+8]\n       test      r8d,r8d\n       jle       short M00_L01\nM00_L00:\n       movsxd    r9,ecx\n       add       edx,[rax+r9*4+10]\n       inc       ecx\n       cmp       r8d,ecx\n       jg        short M00_L00\nM00_L01:\n       mov       eax,edx\n       ret\n; Total bytes of code 35\n```\n\n----------------------------------------\n\nTITLE: Example BenchmarkDotNet Histogram Output with Unicode (Markdown)\nDESCRIPTION: Example markdown output from a BenchmarkDotNet run where Unicode symbols are enabled. This snippet shows detailed statistics including Mean, StdErr, StdDev, Quantiles, IQR, Confidence Interval, Skewness, Kurtosis, and a histogram, using the Unicode symbol '' for microseconds. This output format requires a terminal that supports Unicode.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroUnicode.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nMean = 1.0265 s, StdErr = 0.0005 s (0.05%); N = 15, StdDev = 0.0018 s\nMin = 1.0239 s, Q1 = 1.0248 s, Median = 1.0264 s, Q3 = 1.0280 s, Max = 1.0296 s\nIQR = 0.0033 s, LowerFence = 1.0199 s, UpperFence = 1.0329 s\nConfidenceInterval = [1.0245 s; 1.0285 s] (CI 99.9%), Margin = 0.0020 s (0.19% of Mean)\nSkewness = 0.12, Kurtosis = 1.56, MValue = 2\n-------------------- Histogram --------------------\n[1.023 s ; 1.030 s) | @@@@@@@@@@@@@@@\n---------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Creating F# and VB Benchmark Projects\nDESCRIPTION: Commands to create benchmark projects in F# and VB.NET using language specification\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_3\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark -lang F#\ndotnet new benchmark -lang VB\n```\n\n----------------------------------------\n\nTITLE: Command Line Filtering Options for Categories\nDESCRIPTION: These command-line examples show how to filter benchmarks by categories using the --allCategories and --anyCategories flags.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategories.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--allCategories=A,B\n--anyCategories=A,B\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Statistics in INI Format\nDESCRIPTION: Shows detailed statistics for the baseline benchmark, including mean, standard error, median, and other metrics. This snippet illustrates how a single outlier can significantly affect the benchmark metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroRatioSD.md#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nMean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms\nMin = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms\nIQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms\nConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean)\nSkewness = 2.28, Kurtosis = 6.57, MValue = 2\n-------------------- Histogram --------------------\n[-541.891 ms ;  743.427 ms) | @@@@@@@@@\n[ 743.427 ms ; 2027.754 ms) | \n[2027.754 ms ; 3312.082 ms) | \n[3312.082 ms ; 4458.453 ms) | \n[4458.453 ms ; 5742.780 ms) | @\n---------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Bar Iteration 0 (Custom Format)\nDESCRIPTION: Captures the result data for the first iteration (index 0) of the 'Bench.Bar' benchmark. Details include the measured value (40 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: custom\nCODE:\n```\n[Entry3]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 40\n```\n\n----------------------------------------\n\nTITLE: Analyzing BenchmarkDotNet Entry Structure for Bar Method\nDESCRIPTION: Complete entry structure for the Bar method benchmark from BenchmarkDotNet. Shows the detailed configuration and runtime environment along with performance measurement values across multiple iterations on different .NET Core runtime versions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: config\nCODE:\n```\n[Entry71]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 11\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp21\n  .unit = ns\n  .value = 118\n```\n\n----------------------------------------\n\nTITLE: Assembly Output for SumField Method\nDESCRIPTION: Disassembly output for the SumField method showing the x86 assembly code generated by RyuJIT in .NET Core 2.1.16. This method directly accesses the field array, resulting in different assembly code.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.1.md#2025-04-22_snippet_2\n\nLANGUAGE: x86asm\nCODE:\n```\n; BenchmarkDotNet.Samples.IntroDisassembly.SumField()\n       sub       rsp,28\n       xor       eax,eax\n       xor       edx,edx\n       mov       rcx,[rcx+8]\n       cmp       dword ptr [rcx+8],0\n       jle       short M00_L01\nM00_L00:\n       mov       r8,rcx\n       cmp       edx,[r8+8]\n       jae       short M00_L02\n       movsxd    r9,edx\n       add       eax,[r8+r9*4+10]\n       inc       edx\n       cmp       [rcx+8],edx\n       jg        short M00_L00\nM00_L01:\n       add       rsp,28\n       ret\nM00_L02:\n       call      CORINFO_HELP_RNGCHKFAIL\n       int       3\n; Total bytes of code 53\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom dotnet CLI Paths in C#\nDESCRIPTION: Demonstrates how to use custom dotnet CLI paths for 32-bit and 64-bit benchmarking scenarios.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class CustomPathsConfig : ManualConfig\n{\n    public CustomPathsConfig() \n    {\n        var dotnetCli32bit = NetCoreAppSettings\n            .NetCoreApp31\n            .WithCustomDotNetCliPath(@\"C:\\Program Files (x86)\\dotnet\\dotnet.exe\", \"32 bit cli\");\n\n        var dotnetCli64bit = NetCoreAppSettings\n            .NetCoreApp31\n            .WithCustomDotNetCliPath(@\"C:\\Program Files\\dotnet\\dotnet.exe\", \"64 bit cli\");\n\n        AddJob(Job.RyuJitX86.WithToolchain(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(\"32 bit cli\"));\n        AddJob(Job.RyuJitX64.WithToolchain(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(\"64 bit cli\"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Uninstalling BenchmarkDotNet Templates\nDESCRIPTION: Command to uninstall all BenchmarkDotNet templates from the system\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_1\n\nLANGUAGE: log\nCODE:\n```\ndotnet new uninstall BenchmarkDotNet.Templates\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks for Multiple Frameworks in CMD\nDESCRIPTION: Shows command-line instructions for running benchmarks on different .NET frameworks and versions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f netcoreapp3.1 # is going to run the benchmarks using .NET Core 3.1\ndotnet run -c Release -f net8.0 # is going to run the benchmarks using .NET 8.0\ndotnet run -c Release -f net48         # is going to run the benchmarks using .NET 4.8\nmono $pathToExe                        # is going to run the benchmarks using Mono from your PATH\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Bar Iteration 1 (Custom Format)\nDESCRIPTION: Captures the result data for the second iteration (index 1) of the 'Bench.Bar' benchmark. Details include the measured value (41 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: custom\nCODE:\n```\n[Entry4]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 41\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results in Pretty-Printed JSON Format\nDESCRIPTION: Sample output of BenchmarkDotNet's brief JSON exporter showing benchmark results in formatted JSON. The output includes detailed system information and comprehensive benchmark statistics for methods 'Foo' and 'Bar'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"Title\":\"MockSummary\",\n   \"HostEnvironmentInfo\":{\n      \"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\n      \"BenchmarkDotNetVersion\":\"0.10.x-mock\",\n      \"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\n      \"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\n      \"PhysicalProcessorCount\":1,\n      \"PhysicalCoreCount\":4,\n      \"LogicalCoreCount\":8,\n      \"RuntimeVersion\":\"Clr 4.0.x.mock\",\n      \"Architecture\":\"64mock\",\n      \"HasAttachedDebugger\":false,\n      \"HasRyuJit\":true,\n      \"Configuration\":\"CONFIGURATION\",\n      \"DotNetCliVersion\":\"1.0.x.mock\",\n      \"ChronometerFrequency\":{\n         \"Hertz\":2531248\n      },\n      \"HardwareTimerKind\":\"Tsc\"\n   },\n   \"Benchmarks\":[\n      {\n         \"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n         \"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\n         \"Type\":\"MockBenchmarkClass\",\n         \"Method\":\"Foo\",\n         \"MethodTitle\":\"Foo\",\n         \"Parameters\":\"\",\n         \"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Foo\",\n         \"HardwareIntrinsics\":\"\",\n         \"Statistics\":{\n            \"OriginalValues\":[\n               1,1,1,1,1,1\n            ],\n            \"N\":6,\n            \"Min\":1,\n            \"LowerFence\":1,\n            \"Q1\":1,\n            \"Median\":1,\n            \"Mean\":1,\n            \"Q3\":1,\n            \"UpperFence\":1,\n            \"Max\":1,\n            \"InterquartileRange\":0,\n            \"LowerOutliers\":[\n               \n            ],\n            \"UpperOutliers\":[\n               \n            ],\n            \"AllOutliers\":[\n               \n            ],\n            \"StandardError\":0,\n            \"Variance\":0,\n            \"StandardDeviation\":0,\n            \"Skewness\":\"\",\n            \"Kurtosis\":\"\",\n            \"ConfidenceInterval\":{\n               \"N\":6,\n               \"Mean\":1,\n               \"StandardError\":0,\n               \"Level\":12,\n               \"Margin\":0,\n               \"Lower\":1,\n               \"Upper\":1\n            },\n            \"Percentiles\":{\n               \"P0\":1,\n               \"P25\":1,\n               \"P50\":1,\n               \"P67\":1,\n               \"P80\":1,\n               \"P85\":1,\n               \"P90\":1,\n               \"P95\":1,\n               \"P100\":1\n            }\n         },\n         \"Memory\":{\n            \"Gen0Collections\":0,\n            \"Gen1Collections\":0,\n            \"Gen2Collections\":0,\n            \"TotalOperations\":0,\n            \"BytesAllocatedPerOperation\":null\n         }\n      },{\n         \"DisplayInfo\":\"MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n         \"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\n         \"Type\":\"MockBenchmarkClass\",\n         \"Method\":\"Bar\",\n         \"MethodTitle\":\"Bar\",\n         \"Parameters\":\"\",\n         \"FullName\":\"BenchmarkDotNet.Tests.Mocks.MockFactory+MockBenchmarkClass.Bar\",\n         \"HardwareIntrinsics\":\"\",\n         \"Statistics\":{\n            \"OriginalValues\":[\n               1,1,1,1,1,1\n            ],\n            \"N\":6,\n            \"Min\":1,\n            \"LowerFence\":1,\n            \"Q1\":1,\n            \"Median\":1,\n            \"Mean\":1,\n            \"Q3\":1,\n            \"UpperFence\":1,\n            \"Max\":1,\n            \"InterquartileRange\":0,\n            \"LowerOutliers\":[\n               \n            ],\n            \"UpperOutliers\":[\n               \n            ],\n            \"AllOutliers\":[\n               \n            ],\n            \"StandardError\":0,\n            \"Variance\":0,\n            \"StandardDeviation\":0,\n            \"Skewness\":\"\",\n            \"Kurtosis\":\"\",\n            \"ConfidenceInterval\":{\n               \"N\":6,\n               \"Mean\":1,\n               \"StandardError\":0,\n               \"Level\":12,\n               \"Margin\":0,\n               \"Lower\":1,\n               \"Upper\":1\n            },\n            \"Percentiles\":{\n               \"P0\":1,\n               \"P25\":1,\n               \"P50\":1,\n               \"P67\":1,\n               \"P80\":1,\n               \"P85\":1,\n               \"P90\":1,\n               \"P95\":1,\n               \"P100\":1\n            }\n         },\n         \"Memory\":{\n            \"Gen0Collections\":0,\n            \"Gen1Collections\":0,\n            \"Gen2Collections\":0,\n            \"TotalOperations\":0,\n            \"BytesAllocatedPerOperation\":null\n         }\n      }\n   ]\n}\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Foo Iteration 2 (Custom Format)\nDESCRIPTION: Captures the result data for the third iteration (index 2) of the 'Bench.Foo' benchmark. Details include the measured value (32 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: custom\nCODE:\n```\n[Entry2]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 32\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Result Entries for Foo and Bar Methods with Environment Details\nDESCRIPTION: Series of benchmark result entries from BenchmarkDotNet showing performance measurements for Foo and Bar methods across different runtime environments. Each entry contains detailed information about the host environment, CPU specifications, and execution parameters with measured values in nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_10\n\nLANGUAGE: ini\nCODE:\n```\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 131\n[Entry79]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 132\n[Entry80]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 133\n[Entry81]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 136\n[Entry82]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 137\n[Entry83]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 13\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp30\n  .unit = ns\n  .value = 138\n[Entry84]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 14\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp31\n  .unit = ns\n  .value = 141\n[Entry85]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 14\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp31\n  .unit = ns\n  .value = 142\n[Entry86]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 14\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp31\n  .unit = ns\n  .value = 143\n[Entry87]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n```\n\n----------------------------------------\n\nTITLE: Listing Available Power Plans with CMD\nDESCRIPTION: This command-line snippet shows how to display all available power plans and their GUIDs on a Windows computer using the built-in 'powercfg' utility. It is essential for users who want to identify the GUIDs of installed power plans before configuring them programmatically or manually. No additional dependencies are requiredthis command runs natively on Windows, and the output lists each plan's name and GUID.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroPowerPlan.md#2025-04-22_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\npowercfg /list\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Output in Markdown\nDESCRIPTION: This markdown table shows the benchmark results for different combinations of parameters A and B. It displays the method name, parameter values, mean execution time, error, and standard deviation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParamsSource.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|    Method |  B |   A |     Mean |   Error |  StdDev |\n|---------- |--- |---- |---------:|--------:|--------:|\n| Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms |\n| Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms |\n| Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms |\n| Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms |\n```\n\n----------------------------------------\n\nTITLE: Displaying Template Help\nDESCRIPTION: Command to display all available template options and their descriptions\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_9\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark --help\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Configuration Output in INI\nDESCRIPTION: Shows the configuration output for a BenchmarkDotNet run with custom dotnet CLI paths.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_9\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393)\nProcessor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4\nFrequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC\n.NET Core SDK=2.1.0-preview1-007074\n  [Host]     : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT\n  32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT\n  64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT\n\nJit=RyuJit  \n```\n\n----------------------------------------\n\nTITLE: Exporting Full Benchmark Results to JSON (Partial)\nDESCRIPTION: This snippet demonstrates the beginning of the 'full' JSON export format from BenchmarkDotNet. It includes the Title and HostEnvironmentInfo, similar to the 'brief' format. It then starts the 'Benchmarks' array, showing the initial details for the 'Foo' method (DisplayInfo, Namespace, Type, Method, MethodTitle). This format typically includes significantly more detailed results and measurements than the 'brief' format, although the provided example is truncated and does not show the full extent of the data.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"Title\":\"MockSummary\",\n   \"HostEnvironmentInfo\":{\n      \"BenchmarkDotNetCaption\":\"BenchmarkDotNet\",\n      \"BenchmarkDotNetVersion\":\"0.10.x-mock\",\n      \"OsVersion\":\"Microsoft Windows NT 10.0.x.mock\",\n      \"ProcessorName\":\"MockIntel Core i7-6700HQ CPU 2.60GHz\",\n      \"PhysicalProcessorCount\":1,\n      \"PhysicalCoreCount\":4,\n      \"LogicalCoreCount\":8,\n      \"RuntimeVersion\":\"Clr 4.0.x.mock\",\n      \"Architecture\":\"64mock\",\n      \"HasAttachedDebugger\":false,\n      \"HasRyuJit\":true,\n      \"Configuration\":\"CONFIGURATION\",\n      \"DotNetCliVersion\":\"1.0.x.mock\",\n      \"ChronometerFrequency\":{\n         \"Hertz\":2531248\n      },\n      \"HardwareTimerKind\":\"Tsc\"\n   },\n   \"Benchmarks\":[\n      {\n         \"DisplayInfo\":\"MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)\",\n         \"Namespace\":\"BenchmarkDotNet.Tests.Mocks\",\n         \"Type\":\"MockBenchmarkClass\",\n         \"Method\":\"Foo\",\n         \"MethodTitle\":\"Foo\",\n```\n\n----------------------------------------\n\nTITLE: Storing Benchmark Results with Metadata - BenchmarkDotNet - JSON\nDESCRIPTION: This JSON snippet represents the output from BenchmarkDotNet, detailing engine specifications, hardware environment, and measured benchmark data. It includes per-method, per-runtime results (Foo, Bar) with execution times in nanoseconds across multiple iterations, alongside extensible metadata and table schemas. Intended for automated processing or visualization, inputs are performance timing data and outputs are structured, queryable benchmark records. Requires BenchmarkDotNet and an environment with supported .NET runtimes. No code execution is performed within the file; it is for data transport and analytics only.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default02.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"engine\": {\n    \"name\": \"BenchmarkDotNet\",\n    \"version\": \"0.1729.0-mock\"\n  },\n  \"host\": {\n    \"runtimeVersion\": \"Clr 4.0.x.mock\",\n    \"hasAttachedDebugger\": false,\n    \"hasRyuJit\": true,\n    \"configuration\": \"CONFIGURATION\",\n    \"dotNetSdkVersion\": \"1.0.x.mock\",\n    \"chronometerFrequency\": 2531248,\n    \"hardwareTimerKind\": \"Tsc\",\n    \"os\": {\n      \"display\": \"Microsoft Windows NT 10.0.x.mock\"\n    },\n    \"cpu\": {\n      \"processorName\": \"MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\",\n      \"physicalProcessorCount\": 1,\n      \"physicalCoreCount\": 4,\n      \"logicalCoreCount\": 8,\n      \"nominalFrequencyHz\": 3100000000,\n      \"maxFrequencyHz\": 3100000000\n    }\n  },\n  \"nested\": [\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net481\"\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 10,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 11,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 12,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 20,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 21,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 22,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net70\"\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 30,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 31,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 32,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 40,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 41,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 42,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".engine\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.os\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.cpu\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".benchmark\",\n          \"cloud\": \"secondary\"\n        },\n        {\n          \"selector\": \".job\",\n          \"cloud\": \"secondary\",\n          \"compressed\": true\n        },\n        {\n          \"selector\": \"=center\"\n        },\n        {\n          \"selector\": \"=spread\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating BenchmarkDotNet Projects with .NET CLI\nDESCRIPTION: Commands to create new BenchmarkDotNet projects for C#, F#, and VB using the installed templates.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_11\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark\ndotnet new benchmark -lang F#\ndotnet new benchmark -lang VB\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Results in Markdown\nDESCRIPTION: This snippet shows the expected output of the benchmark in a markdown-formatted table. It displays the method name, parameter values (B and A), and performance metrics (Mean, Error, and StdDev) for the benchmark.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroParamsPriority.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|    Method |  B |   A |     Mean |   Error |  StdDev |\n|---------- |--- |---- |---------:|--------:|--------:|\n| Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms |\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAssembly Project Properties for BenchmarkDotNet in XML\nDESCRIPTION: This XML snippet defines the project structure and properties for building a BenchmarkDotNet project targeting WebAssembly. It sets up essential build parameters, references, and configurations specific to WebAssembly compilation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/WasmCsProj.txt#2025-04-22_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<Project Sdk=\"$SDKNAME$\" DefaultTargets=\"publish\">\n  <PropertyGroup>\n    <OriginalCSProjPath>$CSPROJPATH$</OriginalCSProjPath>\n    <WasmPropsPath>$([System.IO.Path]::ChangeExtension('$(OriginalCSProjPath)', '.Wasm.props'))</WasmPropsPath>\n    <WasmTargetsPath>$([System.IO.Path]::ChangeExtension('$(OriginalCSProjPath)', '.Wasm.targets'))</WasmTargetsPath>\n    <WasmDataDir>$WASMDATADIR$</WasmDataDir>\n    <WasmDataDir Condition=\"'$(WasmDataDir)' != ''\">$([MSBuild]::NormalizeDirectory($(WasmDataDir)))</WasmDataDir>\n  </PropertyGroup>\n\n  <Import Project=\"$(WasmPropsPath)\" Condition=\"Exists($(WasmPropsPath))\" />\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <OutputPath>bin</OutputPath>\n    <RuntimeConfig>Release</RuntimeConfig>\n    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>\n    <TargetFramework>$TFM$</TargetFramework>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <AppDir>$(MSBuildThisFileDirectory)\\bin\\$TFM$\\browser-wasm\\publish</AppDir>\n    <AssemblyName>$PROGRAMNAME$</AssemblyName>\n    <RuntimeIdentifier>browser-wasm</RuntimeIdentifier>\n    <SuppressTrimAnalysisWarnings>true</SuppressTrimAnalysisWarnings>\n    <RunAOTCompilation>$RUN_AOT$</RunAOTCompilation>\n    <PublishTrimmed>$(RunAOTCompilation)</PublishTrimmed>\n    <WasmGenerateRunV8Script>true</WasmGenerateRunV8Script>\n    <ErrorOnDuplicatePublishOutputFiles>false</ErrorOnDuplicatePublishOutputFiles>\n    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>\n    <EnableDefaultWasmAssembliesToBundle>false</EnableDefaultWasmAssembliesToBundle>\n    <!-- Suppress warning for nuget package used in old (unsupported) tfm. -->\n    <SuppressTfmSupportBuildWarnings>true</SuppressTfmSupportBuildWarnings>\n    <StartupObject>BenchmarkDotNet.Autogenerated.UniqueProgramName</StartupObject>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <Compile Include=\"$CODEFILENAME$\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" />\n    <!-- move this too? -->\n    <TrimmerRootDescriptor Include=\"WasmLinkerDescription.xml\" Condition=\"'$(RunAOTCompilation)' == 'true'\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"$(OriginalCSProjPath)\" />\n  </ItemGroup>\n\n  <!-- Begin copied settings from benchmarks project -->\n  $COPIEDSETTINGS$\n  <!-- End copied settings -->\n\n  <PropertyGroup>\n    <WasmBuildAppAfterThisTarget>PrepareForWasmBuild</WasmBuildAppAfterThisTarget>\n  </PropertyGroup>\n\n  <Target Name=\"PrepareForWasmBuild\" AfterTargets=\"Publish\">\n    <ItemGroup>\n      <WasmAssembliesToBundle Include=\"$(TargetDir)publish\\*.dll\" Condition=\"'$(RunAOTCompilation)' != 'true'\" />\n      <WasmAssembliesToBundle Include=\"$(TargetDir)publish\\*.dll\" Exclude=\"$(TargetDir)publish\\KernelTraceControl.dll\" Condition=\"'$(RunAOTCompilation)' == 'true'\" />\n    </ItemGroup>\n  </Target>\n\n  <Import Project=\"$(WasmTargetsPath)\" Condition=\"Exists($(WasmTargetsPath))\" />\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Listing Benchmarks with Flat Format in BenchmarkDotNet\nDESCRIPTION: Example output of using the '--list flat' command-line argument, which displays all available benchmarks in a flat list format.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5\nBenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256\nBenchmarkDotNet.Samples.IntroArguments.Benchmark\nBenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument\nBenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments\nBenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf\nBenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf\nBenchmarkDotNet.Samples.IntroBasic.Sleep\n[...]\n```\n\n----------------------------------------\n\nTITLE: Exporting Benchmark Results with MarkdownExporter-atlassian in markdown\nDESCRIPTION: This snippet displays the BenchmarkDotNet results using MarkdownExporter-atlassian, which formats output in Atlassian-compatible markdown with {noformat} blocks and pipe-based tables, suitable for documentation platforms such as Confluence. It maintains consistent benchmark data and layout as other exporters, ensuring ease of integration into wiki or documentation systems that support Atlassian markdown. The snippet's output has no code dependencies and assumes the target environment understands Atlassian markdown conventions.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n{noformat}\n\nBenchmarkDotNet v0.10.x-mock, Microsoft Windows NT 10.0.x.mock (Hyper-V)\nMockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\nFrequency: 2531248 Hz, Resolution: 395.062 ns, Timer: TSC\n.NET Core SDK 1.0.x.mock\n  [Host] : Clr 4.0.x.mock, 64mock RyuJIT-v4.6.x.mock CONFIGURATION\n\nJob=LongRun  IterationCount=100  LaunchCount=3  \nWarmupCount=15  \n\n{noformat}\n||Method ||Mean     ||Error    ||StdDev   ||P67      ||CacheMisses ||\n| Foo    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n| Bar    | 1.000 ns | 0.000 ns | 0.000 ns | 1.000 ns |           7 |\n```\n\n----------------------------------------\n\nTITLE: Representing Detailed Benchmark Results in JSON\nDESCRIPTION: This JSON object provides a detailed, structured representation of the benchmark results. It includes information about the BenchmarkDotNet engine version, the host environment (OS, CPU details, runtime info), nested structures defining jobs (like specific runtime and JIT), benchmarks (type and method), and individual iteration results with their values and units (nanoseconds). Additionally, it contains metadata ('meta') defining how the results table should be structured and displayed.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default04.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"engine\": {\n    \"name\": \"BenchmarkDotNet\",\n    \"version\": \"0.1729.0-mock\"\n  },\n  \"host\": {\n    \"runtimeVersion\": \"Clr 4.0.x.mock\",\n    \"hasAttachedDebugger\": false,\n    \"hasRyuJit\": true,\n    \"configuration\": \"CONFIGURATION\",\n    \"dotNetSdkVersion\": \"1.0.x.mock\",\n    \"chronometerFrequency\": 2531248,\n    \"hardwareTimerKind\": \"Tsc\",\n    \"os\": {\n      \"display\": \"Microsoft Windows NT 10.0.x.mock\"\n    },\n    \"cpu\": {\n      \"processorName\": \"MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\",\n      \"physicalProcessorCount\": 1,\n      \"physicalCoreCount\": 4,\n      \"logicalCoreCount\": 8,\n      \"nominalFrequencyHz\": 3100000000,\n      \"maxFrequencyHz\": 3100000000\n    }\n  },\n  \"nested\": [\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net481\",\n          \"jit\": \"legacyJit\"\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 10,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 11,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 12,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 20,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 21,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 22,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"job\": {\n        \"environment\": {\n          \"runtime\": \"net70\",\n          \"jit\": \"ryuJit\"\n        }\n      },\n      \"nested\": [\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Foo\"\n          },\n          \"nested\": [\n            {\n              \"value\": 30,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 31,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 32,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        },\n        {\n          \"benchmark\": {\n            \"type\": \"Bench\",\n            \"method\": \"Bar\"\n          },\n          \"nested\": [\n            {\n              \"value\": 40,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 0\n            },\n            {\n              \"value\": 41,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 1\n            },\n            {\n              \"value\": 42,\n              \"unit\": \"ns\",\n              \"iterationIndex\": 2\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".engine\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.os\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".host.cpu\",\n          \"cloud\": \"primary\",\n          \"isSelfExplanatory\": true,\n          \"isAtomic\": true\n        },\n        {\n          \"selector\": \".benchmark\",\n          \"cloud\": \"secondary\"\n        },\n        {\n          \"selector\": \".job\",\n          \"cloud\": \"secondary\",\n          \"compressed\": true\n        },\n        {\n          \"selector\": \"=center\"\n        },\n        {\n          \"selector\": \"=spread\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Results for Bench Methods\nDESCRIPTION: Log entries showing benchmark results for 'Foo' and 'Bar' methods from the 'Bench' class, including detailed host information, CPU specifications, runtime environment, and performance measurements in nanoseconds. The benchmarks were run with different environment configurations including NetCoreApp20 and NetCoreApp21.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 10\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp20\n  .unit = ns\n  .value = 102\n[Entry62]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 10\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = NetCoreApp20\n  .unit = ns\n  .value = 103\n```\n\n----------------------------------------\n\nTITLE: Configuring BenchmarkDotNet Job for Percentile Analysis\nDESCRIPTION: This code snippet shows how to configure a BenchmarkDotNet Job for percentile analysis. It sets the IterationCount to 5 and IterationTime to 500 milliseconds, which may not be optimal for capturing peak values in certain scenarios.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroPercentiles.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew Job\n{\n\tIterationCount = 5,\n\tIterationTime = 500\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling WakeLock via BenchmarkDotNet Command Line\nDESCRIPTION: This command-line argument `--wakeLock None` is used with the BenchmarkDotNet runner to explicitly disable any wake lock functionality during benchmark execution. This is the default behavior if no wake lock is specified.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroWakeLock.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n--wakeLock None\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Multiple CoreRun Instances in BenchmarkDotNet\nDESCRIPTION: Example of using the '--coreRun' argument to compare performance between different CoreRun instances, useful for CoreCLR/CoreFX development.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_10\n\nLANGUAGE: log\nCODE:\n```\ndotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun\nC:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root\\CoreRun.exe\nC:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root_beforeMyChanges\\CoreRun.exe\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Foo Iteration 0 (Custom Format)\nDESCRIPTION: Captures the result data for the first iteration (index 0) of the 'Bench.Foo' benchmark. Details include the measured value (30 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: custom\nCODE:\n```\n[Entry0]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 30\n```\n\n----------------------------------------\n\nTITLE: Storing BenchmarkDotNet Results as INI Entries (INI)\nDESCRIPTION: This snippet demonstrates the structure used to store multiple benchmark runs in an INI-like configuration file. Each [EntryN] section records metadata and results for a specific execution: the method being benchmarked, system and environment info, and the output value. Requires output from BenchmarkDotNet in a compatible environment, using mock data for demonstration. Key parameters include .benchmark (class.method), .benchmark.method, .benchmark.type, engine details, host details (CPU, OS, runtime), runtime (.job.environment.runtime), and the measured .value for each iteration. Expected input is auto-generated by the benchmarking tool; output is a text structure for later processing or analysis.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default02.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[Keys]\n  .benchmark\n  .benchmark.method\n  .benchmark.type\n  .engine\n  .engine.name\n  .engine.version\n  .host\n  .host.chronometerFrequency\n  .host.configuration\n  .host.cpu\n  .host.cpu.logicalCoreCount\n  .host.cpu.maxFrequencyHz\n  .host.cpu.nominalFrequencyHz\n  .host.cpu.physicalCoreCount\n  .host.cpu.physicalProcessorCount\n  .host.cpu.processorName\n  .host.dotNetSdkVersion\n  .host.hardwareTimerKind\n  .host.hasAttachedDebugger\n  .host.hasRyuJit\n  .host.os\n  .host.os.display\n  .host.runtimeVersion\n  .iterationIndex\n  .job\n  .job.environment\n  .job.environment.runtime\n  .unit\n  .value\n\n[Entry0]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 10\n[Entry1]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 11\n[Entry2]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 12\n[Entry3]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 20\n[Entry4]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 21\n[Entry5]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net481\n  .unit = ns\n  .value = 22\n[Entry6]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 30\n[Entry7]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 1\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 31\n[Entry8]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n```\n\n----------------------------------------\n\nTITLE: Configuring Project for Optimal Symbol Information with XML\nDESCRIPTION: XML configuration for a project file that enables optimal managed code symbols for ETW profiling. This configuration ensures proper symbol information is included to get the best possible managed code stack traces.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/features/etwprofiler.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<DebugType>pdbonly</DebugType>\n<DebugSymbols>true</DebugSymbols>\n```\n\n----------------------------------------\n\nTITLE: Creating C# Benchmark Project\nDESCRIPTION: Command to create a new C# benchmark project using the default template\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_2\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark\n```\n\n----------------------------------------\n\nTITLE: Defining Benchmark Result Keys (Custom Format)\nDESCRIPTION: Lists all possible keys used within BenchmarkDotNet result entries, defining the structure for recording benchmark details, host environment, job configuration, and measured values. This section acts as a schema definition for the subsequent [EntryX] blocks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: custom\nCODE:\n```\n[Keys]\n  .benchmark\n  .benchmark.method\n  .benchmark.type\n  .engine\n  .engine.name\n  .engine.version\n  .host\n  .host.chronometerFrequency\n  .host.configuration\n  .host.cpu\n  .host.cpu.logicalCoreCount\n  .host.cpu.maxFrequencyHz\n  .host.cpu.nominalFrequencyHz\n  .host.cpu.physicalCoreCount\n  .host.cpu.physicalProcessorCount\n  .host.cpu.processorName\n  .host.dotNetSdkVersion\n  .host.hardwareTimerKind\n  .host.hasAttachedDebugger\n  .host.hasRyuJit\n  .host.os\n  .host.os.display\n  .host.runtimeVersion\n  .iterationIndex\n  .job\n  .job.environment\n  .job.environment.jit\n  .job.environment.runtime\n  .unit\n  .value\n```\n\n----------------------------------------\n\nTITLE: Trimming Long Strings in BenchmarkDotNet Results\nDESCRIPTION: Example showcasing how BenchmarkDotNet now trims long string values in results instead of displaying them in full, which improves readability of benchmark results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Long\n{\n    [Params(\"text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7\")]\n    public string Text;\n\n    [Benchmark]\n    public int HashCode() => Text.GetHashCode();\n}\n```\n\n----------------------------------------\n\nTITLE: Build Log Output for NativeAOT Compilation in BenchmarkDotNet\nDESCRIPTION: This log shows the output from BenchmarkDotNet when building a NativeAOT benchmark. It includes the restore and build commands that are executed, along with their timing and exit codes.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_20\n\nLANGUAGE: log\nCODE:\n```\n// ***** Building 1 exe(s) in Parallel: Start   *****\n// start dotnet  restore -r win-x64 /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ\n// command took 2.74s and exited with 0\n// start dotnet  build -c Release -r win-x64 --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ\n// command took 3.82s and exited with 0\n```\n\n----------------------------------------\n\nTITLE: Structuring Benchmark Data and Table Configuration in JSON\nDESCRIPTION: This JSON object structures detailed benchmark results for methods 'Foo' and 'Bar'. Each benchmark has nested data containing the measured value, unit ('ms'), and iteration index. The 'meta' section provides configuration for displaying this data in a table, defining columns using JSON path selectors (`.benchmark.method`, `=center`) and specifying a descending sort policy based on the 'center' value.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=sort01.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"nested\": [\n    {\n      \"benchmark\": {\n        \"type\": \"Bench\",\n        \"method\": \"Foo\"\n      },\n      \"nested\": [\n        {\n          \"value\": 10,\n          \"unit\": \"ms\",\n          \"iterationIndex\": 0\n        }\n      ]\n    },\n    {\n      \"benchmark\": {\n        \"type\": \"Bench\",\n        \"method\": \"Bar\"\n      },\n      \"nested\": [\n        {\n          \"value\": 20,\n          \"unit\": \"ms\",\n          \"iterationIndex\": 0\n        }\n      ]\n    }\n  ],\n  \"meta\": {\n    \"table\": {\n      \"columnDefinitions\": [\n        {\n          \"selector\": \".benchmark.method\"\n        },\n        {\n          \"selector\": \"=center\"\n        }\n      ],\n      \"sortPolicies\": [\n        {\n          \"selector\": \"=center\",\n          \"direction\": \"descending\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running BenchmarkDotNet Tests for Bench Class Methods\nDESCRIPTION: This snippet shows the configuration and results of running BenchmarkDotNet tests for the Foo and Bar methods of the Bench class. It includes details about the test environment, runtime settings, and performance measurements in nanoseconds.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_3\n\nLANGUAGE: plain text\nCODE:\n```\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 4\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net462\n  .unit = ns\n  .value = 43\n```\n\n----------------------------------------\n\nTITLE: Skipping Package Restore\nDESCRIPTION: Command to create a benchmark project without automatically restoring NuGet packages\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_8\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark --no-restore\n```\n\n----------------------------------------\n\nTITLE: Recording Benchmark Result: Bench.Bar Iteration 2 (Custom Format)\nDESCRIPTION: Captures the result data for the third iteration (index 2) of the 'Bench.Bar' benchmark. Details include the measured value (42 ns), host environment (Windows, i7-6700HQ, .NET 7.0, RyuJit), and BenchmarkDotNet engine specifics (v0.1729.0-mock).\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default03.verified.txt#2025-04-22_snippet_6\n\nLANGUAGE: custom\nCODE:\n```\n[Entry5]\n  .benchmark = Bench.Bar\n  .benchmark.method = Bar\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 2\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = Net70\n  .unit = ns\n  .value = 42\n```\n\n----------------------------------------\n\nTITLE: Uninstalling BenchmarkDotNet Templates with .NET CLI\nDESCRIPTION: Command to uninstall all BenchmarkDotNet templates from the .NET Core SDK.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_10\n\nLANGUAGE: log\nCODE:\n```\ndotnet new -u BenchmarkDotNet.Templates\n```\n\n----------------------------------------\n\nTITLE: NuGet Configuration for .NET 5 Feed in XML\nDESCRIPTION: This XML snippet shows how to add the .NET 5 NuGet feed to the nuget.config file, which is required for WebAssembly benchmarks to resolve the correct dependencies.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_19\n\nLANGUAGE: xml\nCODE:\n```\n<add key=\"dotnet5\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json\" />\n```\n\n----------------------------------------\n\nTITLE: Benchmarking MockBenchmarkClass.Foo with BenchmarkDotNet - C#\nDESCRIPTION: Benchmarks the 'Foo' method in 'MockBenchmarkClass', collects per-iteration execution time and hardware metrics, and outputs statistical summaries. Requires BenchmarkDotNet setup with a test mock class, configured to collect cache miss metrics and output statistics such as mean, variance, and percentiles. Inputs are provided by the BenchmarkDotNet framework and outputs include timing data per iteration, memory metrics, and cache misses (collected via hardware counters). Method operates under the BenchmarkDotNet convention without additional parameters, and is meant for testing and validation of benchmarking pipeline.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_ru-RU.verified.txt#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// MockBenchmarkClass.Foo Benchmark Data\n{\n  \"DisplayInfo\": \"MockBenchmarkClass.Foo: WorkloadResult (default params)\",\n  \"Namespace\": \"BenchmarkDotNet.Tests.Mocks\",\n  \"Type\": \"MockBenchmarkClass\",\n  \"Method\": \"Foo\",\n  \"Statistics\": {\n    \"OriginalValues\": [1,1,1,1,1,1],\n    \"N\": 6,\n    \"Mean\": 1,\n    \"Variance\": 0,\n    \"StandardDeviation\": 0,\n    \"Min\": 1,\n    \"Max\": 1\n    // ...plus percentiles and outlier data\n  },\n  \"Memory\": {\n    \"Gen0Collections\": 0,\n    \"Gen1Collections\": 0,\n    \"Gen2Collections\": 0\n    // ...etc.\n  },\n  \"Measurements\": [\n    { \"IterationIndex\": 1, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 2, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 3, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 4, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 5, \"Nanoseconds\": 1 },\n    { \"IterationIndex\": 6, \"Nanoseconds\": 1 }\n  ],\n  \"Metrics\": [\n    {\n      \"Value\": 7,\n      \"Descriptor\": {\n        \"Id\": \"CacheMisses\",\n        \"DisplayName\": \"CacheMisses\",\n        \"Legend\": \"Hardware counter 'CacheMisses' per single operation\"\n      }\n    }\n  ]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running BenchmarkDotNet tests for a specific framework\nDESCRIPTION: Command to run tests for a specific framework target only. This example runs tests only for .NET 5.0 target framework in Release configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/running-tests.md#2025-04-22_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet test -c Release -f net5.0 BenchmarkDotNet.sln\n```\n\n----------------------------------------\n\nTITLE: Creating Class Library Project\nDESCRIPTION: Command to create a benchmark class library project instead of a console application\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_5\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark --console-app=false\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement with Unrolling for Ref Readonly Methods in C#\nDESCRIPTION: Executes the benchmark workload for methods returning `ref readonly T`, with loop unrolling. It calls `workloadDelegate` `invokeCount` times, assigning the result to an alias (`alias`) of `workloadDefaultValueHolder`. The `@Unroll@` placeholder enables unrolling. `KeepAliveWithoutBoxingReadonly` is used to keep the readonly reference alive.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        alias = workloadDelegate($PassArguments$);@Unroll@\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Path for Custom Runtime Pack (Text)\nDESCRIPTION: Shows an example directory path where the custom runtime pack is typically generated after building the `dotnet/runtime` repository. The path shown is specific to an osx-x64 Release build and needs adjustment for different platforms or configurations. This path is intended for use with the `--customruntimepack` flag.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_24\n\nLANGUAGE: text\nCODE:\n```\n<runtimeroot>artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/\n```\n\n----------------------------------------\n\nTITLE: Adding Package Reference for Mono AOT Compiler\nDESCRIPTION: Includes the Microsoft.NET.Runtime.MonoAOTCompiler.Task package reference required for AOT compilation. This package provides the necessary tools to perform Ahead-of-Time compilation for the benchmark assemblies.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/MonoAOTLLVMCsProj.txt#2025-04-22_snippet_2\n\nLANGUAGE: XML\nCODE:\n```\n<ItemGroup>\n    <PackageReference Include=\"Microsoft.NET.Runtime.MonoAOTCompiler.Task\" version=\"6.0.0-*\" GeneratePathProperty=\"true\" />\n  </ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement with Unrolling for Void Methods in C#\nDESCRIPTION: Measures benchmarking overhead for methods returning `void`, with loop unrolling. It calls the `overheadDelegate` `invokeCount` times in a loop. The `@Unroll@` placeholder is expanded during code generation. Since the method is `void`, no result needs to be stored or kept alive. `AggressiveOptimizationOption` encourages JIT optimization.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        overheadDelegate($PassArguments$);@Unroll@\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Multiple .NET Framework Versions Example\nDESCRIPTION: Command line example showing what happens when you provide multiple .NET Framework monikers. All benchmarks will use the latest .NET Framework installed on the machine.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.12.0.md#2025-04-22_snippet_5\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release -f net461 net472 net48\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement without Unrolling for Ref Readonly Methods in C#\nDESCRIPTION: Executes the benchmark workload for methods returning `ref readonly T`, without loop unrolling. It calls `workloadDelegate` `invokeCount` times, assigning the result to an alias (`alias`) of `workloadDefaultValueHolder`. `KeepAliveWithoutBoxingReadonly` ensures the readonly reference is considered used by the JIT.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        alias = workloadDelegate($PassArguments$);\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NuGet Package Source for Stable BenchmarkDotNet Versions\nDESCRIPTION: XML configuration for the standard NuGet feed to install stable versions of BenchmarkDotNet packages.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/nuget.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<packageSources>\n  <add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" />\n</packageSources>\n```\n\n----------------------------------------\n\nTITLE: Viewing CPU Details from /proc/cpuinfo (Text)\nDESCRIPTION: This text block shows the output typically found in `/proc/cpuinfo` on a Linux system. It details specifications for multiple logical processors (processor 16 through 20 shown) of an AMD Ryzen 9 7950X, including supported CPU flags (instruction sets like SSE, AVX, AVX512), cache sizes, core IDs, clock speeds, and known CPU bugs. This information is crucial for understanding hardware capabilities and potential performance characteristics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Detectors/Cpu/TestFiles/ryzen9-cpuinfo.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 16\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 4738.471\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 0\ncpu cores\t: 16\napicid\t\t: 1\ninitial apicid\t: 1\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 17\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 5599.000\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 1\ncpu cores\t: 16\napicid\t\t: 3\ninitial apicid\t: 3\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 18\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 5477.067\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 2\ncpu cores\t: 16\napicid\t\t: 5\ninitial apicid\t: 5\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 19\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 5507.543\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 3\ncpu cores\t: 16\napicid\t\t: 7\ninitial apicid\t: 7\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 20\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 4401.379\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 4\ncpu cores\t: 16\napicid\t\t: 9\ninitial apicid\t: 9\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement with Unrolling for Void Methods in C#\nDESCRIPTION: Executes the benchmark workload for methods returning `void`, with loop unrolling. It calls the `workloadDelegate` `invokeCount` times. The `@Unroll@` placeholder allows for loop unrolling during code generation. `AggressiveOptimizationOption` is applied.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        workloadDelegate($PassArguments$);@Unroll@\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement with Unrolling for Ref-Returning Methods in C#\nDESCRIPTION: This method measures the overhead of the benchmarking loop and delegate invocation for methods returning by reference (`ref T`), with loop unrolling. It calls the `overheadDelegate` repeatedly within a loop (`invokeCount` times), storing the result. The `@Unroll@` placeholder is expanded during code generation. `AggressiveOptimizationOption` encourages JIT optimization, and `KeepAliveWithoutBoxing` prevents the result from being optimized away. This specific version handles by-ref return types.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        value = overheadDelegate($PassArguments$);@Unroll@\n    }\n    BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Old CPU Brand String Format (Log)\nDESCRIPTION: Shows the previous format used by BenchmarkDotNet (before v0.11.2) to display CPU information in benchmark summary reports. This format included potentially redundant text like 'Eight-Core Processor' and specified the maximum frequency using '(Max: ...)'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_13\n\nLANGUAGE: log\nCODE:\n```\nAMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores\n```\n\n----------------------------------------\n\nTITLE: Overhead Measurement without Unrolling for Void Methods in C#\nDESCRIPTION: Measures benchmarking overhead for methods returning `void`, without loop unrolling. It calls the `overheadDelegate` `invokeCount` times in a simple loop. `AggressiveOptimizationOption` encourages JIT optimization.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void OverheadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        overheadDelegate($PassArguments$);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying CPU Information for AMD Ryzen 9 7950X\nDESCRIPTION: This snippet shows detailed CPU information output, including processor flags, bugs, cache sizes, and other hardware specifications for an AMD Ryzen 9 7950X 16-Core Processor. It includes data for two cores (0 and 31) out of the total 32 cores.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Detectors/Cpu/TestFiles/ryzen9-cpuinfo.txt#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n\nprocessor\t: 31\nvendor_id\t: AuthenticAMD\ncpu family\t: 25\nmodel\t\t: 97\nmodel name\t: AMD Ryzen 9 7950X 16-Core Processor\nstepping\t: 2\nmicrocode\t: 0xa601201\ncpu MHz\t\t: 5389.561\ncache size\t: 1024 KB\nphysical id\t: 0\nsiblings\t: 32\ncore id\t\t: 15\ncpu cores\t: 16\napicid\t\t: 31\ninitial apicid\t: 31\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 16\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good amd_lbr_v2 nopl nonstop_tsc cpuid extd_apicid aperfmperf rapl pni pclmulqdq monitor ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm cmp_legacy svm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw ibs skinit wdt tce topoext perfctr_core perfctr_nb bpext perfctr_llc mwaitx cpb cat_l3 cdp_l3 hw_pstate ssbd mba perfmon_v2 ibrs ibpb stibp ibrs_enhanced vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid cqm rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local user_shstk avx512_bf16 clzero irperf xsaveerptr rdpru wbnoinvd cppc arat npt lbrv svm_lock nrip_save tsc_scale vmcb_clean flushbyasid decodeassists pausefilter pfthreshold avic v_vmsave_vmload vgif x2avic v_spec_ctrl vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid overflow_recov succor smca fsrm flush_l1d\nbugs\t\t: sysret_ss_attrs spectre_v1 spectre_v2 spec_store_bypass srso\nbogomips\t: 8983.23\nTLB size\t: 3584 4K pages\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 48 bits physical, 48 bits virtual\npower management: ts ttp tm hwpstate cpb eff_freq_ro [13] [14]\n```\n\n----------------------------------------\n\nTITLE: Including BenchmarkDotNet Sample Code (C#)\nDESCRIPTION: This snippet indicates the inclusion of the C# source code file `IntroUnicode.cs` located in the BenchmarkDotNet samples directory. This file contains the C# code demonstrating the use of `[UnicodeConsoleLoggerAttribute]` to enable Unicode output in benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroUnicode.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroUnicode.cs](../../../samples/BenchmarkDotNet.Samples/IntroUnicode.cs)]\n```\n\n----------------------------------------\n\nTITLE: Histogram Output Without Memory Randomization\nDESCRIPTION: Output showing the performance histogram of a benchmark without memory randomization enabled, demonstrating a flat, consistent distribution.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n-------------------- Histogram --------------------\n[502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@\n---------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Listing Benchmarks with Tree Format in BenchmarkDotNet\nDESCRIPTION: Example output of using the '--list tree' command-line argument, which displays all available benchmarks in a hierarchical tree structure.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\nBenchmarkDotNet\n Samples\n    Algo_Md5VsSha256\n      Md5\n      Sha256\n    IntroArguments\n      Benchmark\n    IntroArgumentsSource\n      SingleArgument\n      ManyArguments\n    IntroArrayParam\n      ArrayIndexOf\n      ManualIndexOf\n    IntroBasic\n      Sleep\n[...]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dead Code in C# Benchmarking\nDESCRIPTION: Example of code that may be eliminated by the JIT compiler during optimization because the calculation result is not used, leading to inaccurate benchmarks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/good-practices.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Foo()\n{\n    Math.Exp(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Resolution Helper for .NET Framework\nDESCRIPTION: A helper class for resolving assembly references in .NET Framework environments. It handles cases where assembly binding redirects are missing or incorrect by attempting to load assemblies from the base directory or from a shadow copy folder for LINQPad.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkProgram.txt#2025-04-22_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n#if NETFRAMEWORK\n    internal class DirtyAssemblyResolveHelper : System.IDisposable\n    {\n        internal DirtyAssemblyResolveHelper() => System.AppDomain.CurrentDomain.AssemblyResolve += HelpTheFrameworkToResolveTheAssembly;\n\n        public void Dispose() => System.AppDomain.CurrentDomain.AssemblyResolve -= HelpTheFrameworkToResolveTheAssembly;\n\n        /// <summary>\n        /// according to https://msdn.microsoft.com/en-us/library/ff527268(v=vs.110).aspx\n        /// \"the handler is invoked whenever the runtime fails to bind to an assembly by name.\"\n        /// </summary>\n        /// <returns>not null when we find it manually, null when can't help</returns>\n        private System.Reflection.Assembly HelpTheFrameworkToResolveTheAssembly(System.Object sender, System.ResolveEventArgs args)\n        {\n#if SHADOWCOPY // used for LINQPad\n            const System.String shadowCopyFolderPath = @\"$ShadowCopyFolderPath$\";\n\n            System.String guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $\"{new System.Reflection.AssemblyName(args.Name).Name}.dll\");\n\n            return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;\n#else\n            System.Reflection.AssemblyName fullName = new System.Reflection.AssemblyName(args.Name);\n            System.String simpleName = fullName.Name;\n\n            System.String guessedPath = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, $\"{simpleName}.dll\");\n\n            if (!System.IO.File.Exists(guessedPath))\n            {\n                System.Console.WriteLine($\"// Wrong assembly binding redirects for {args.Name}.\");\n                return null; // we can't help, and we also don't call Assembly.Load which if fails comes back here, creates endless loop and causes StackOverflow\n            }\n\n            // the file is right there, but has most probably different version and there is no assembly binding redirect or there is a wrong one...\n            // so we just load it and ignore the version mismatch\n\n            // we warn the user about that, in case some Super User want to be aware of that\n            System.Console.WriteLine($\"// Wrong assembly binding redirects for {simpleName}, loading it from disk anyway.\");\n\n            return System.Reflection.Assembly.LoadFrom(guessedPath);\n#endif // SHADOWCOPY\n        }\n    }\n#endif // NETFRAMEWORK\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet OutOfMemoryException Error Message\nDESCRIPTION: The log output from BenchmarkDotNet when an OutOfMemoryException occurs, explaining why the exception happened and suggesting how to redesign the benchmark to avoid memory leaks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.0.md#2025-04-22_snippet_4\n\nLANGUAGE: log\nCODE:\n```\nOutOfMemoryException!\nBenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.\nIf your benchmark allocates memory and keeps it alive, you are creating a memory leak.\nYou should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.\n```\n\n----------------------------------------\n\nTITLE: Disassembler Entry Point for Ref-Returning Methods in C#\nDESCRIPTION: A public method serving as an entry point for disassembler analysis when the benchmarked method returns by reference (`ref T`). It conditionally calls the workload method (`$WorkloadMethodCall$`) once and returns the resulting reference. `NoOptimization` and `NoInlining` prevent JIT interference. If the condition `NotEleven == 11` is false, it returns a reference to the `workloadDefaultValueHolder` field.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]\npublic ref $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()\n{\n    if (NotEleven == 11)\n    {\n        $LoadArguments$\n        return ref $WorkloadMethodCall$;\n    }\n    \n    return ref workloadDefaultValueHolder;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Benchmark Entry0 with Mock Data\nDESCRIPTION: This snippet establishes a benchmark configuration using mock data for a method 'Foo' in INI format. It records the host configuration, CPU details, engine version, and execution results. Dependencies include proper initialization of BenchmarkDotNet and mock environment setup.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[Entry0]\n  .benchmark = Bench.Foo\n  .benchmark.method = Foo\n  .benchmark.type = Bench\n  .engine = BenchmarkDotNet v0.1729.0-mock\n  .engine.name = BenchmarkDotNet\n  .engine.version = 0.1729.0-mock\n  .host = <object>\n  .host.chronometerFrequency = 2531248\n  .host.configuration = CONFIGURATION\n  .host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n  .host.cpu.logicalCoreCount = 8\n  .host.cpu.maxFrequencyHz = 3100000000\n  .host.cpu.nominalFrequencyHz = 3100000000\n  .host.cpu.physicalCoreCount = 4\n  .host.cpu.physicalProcessorCount = 1\n  .host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n  .host.dotNetSdkVersion = 1.0.x.mock\n  .host.hardwareTimerKind = Tsc\n  .host.hasAttachedDebugger = False\n  .host.hasRyuJit = True\n  .host.os = Microsoft Windows NT 10.0.x.mock\n  .host.os.display = Microsoft Windows NT 10.0.x.mock\n  .host.runtimeVersion = Clr 4.0.x.mock\n  .iterationIndex = 0\n  .job = <object>\n  .job.environment = <object>\n  .job.environment.affinity = 0\n  .job.environment.jit = RyuJit\n  .job.environment.runtime = HostProcess\n  .unit = ns\n  .value = 1\n```\n\n----------------------------------------\n\nTITLE: Specifying Hardware Counters via Command Line (Log)\nDESCRIPTION: Demonstrates the command-line argument `--counters` used to enable specific hardware performance counters (like CacheMisses and InstructionRetired) for analysis within BenchmarkDotNet. This allows users to profile low-level CPU events during benchmarks by adding the desired counters separated by '+'.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_11\n\nLANGUAGE: log\nCODE:\n```\n--counters CacheMisses+InstructionRetired\n```\n\n----------------------------------------\n\nTITLE: Recording BenchmarkDotNet Results - Plaintext\nDESCRIPTION: This snippet demonstrates the output format of BenchmarkDotNet for a set of benchmarks, including hardware/environment descriptors and performance results. Dependencies include a working installation of BenchmarkDotNet, .NET runtimes, and compatible test hardware or mock environments. The primary parameters are method names, runtime, JIT, affinity, and the measured values in nanoseconds (ns). Inputs are not required except for correctly configured benchmarks and jobs. Outputs are structured as a list of documented entries per benchmark instance. The data is limited to methods Foo and Bar of the Bench class and may rely on mock values for demonstration/conformance testing.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 2\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 2\n.job.environment.jit = RyuJit\n.job.environment.runtime = Mono\n.unit = ns\n.value = 28\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry18]\n.benchmark = Bench.Foo\n.benchmark.method = Foo\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 0\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 31\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry19]\n.benchmark = Bench.Foo\n.benchmark.method = Foo\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 1\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 32\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry20]\n.benchmark = Bench.Foo\n.benchmark.method = Foo\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 2\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 33\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry21]\n.benchmark = Bench.Bar\n.benchmark.method = Bar\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 0\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 36\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry22]\n.benchmark = Bench.Bar\n.benchmark.method = Bar\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 1\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 37\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry23]\n.benchmark = Bench.Bar\n.benchmark.method = Bar\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 2\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 3\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net461\n.unit = ns\n.value = 38\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry24]\n.benchmark = Bench.Foo\n.benchmark.method = Foo\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 0\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 4\n.job.environment.jit = RyuJit\n.job.environment.runtime = Net462\n.unit = ns\n.value = 41\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n[Entry25]\n.benchmark = Bench.Foo\n.benchmark.method = Foo\n.benchmark.type = Bench\n.engine = BenchmarkDotNet v0.1729.0-mock\n.engine.name = BenchmarkDotNet\n.engine.version = 0.1729.0-mock\n.host = <object>\n.host.chronometerFrequency = 2531248\n.host.configuration = CONFIGURATION\n.host.cpu = MockIntel Core i7-6700HQ CPU 2.60GHz (Max: 3.10GHz), 1 CPU, 8 logical and 4 physical cores\n.host.cpu.logicalCoreCount = 8\n.host.cpu.maxFrequencyHz = 3100000000\n.host.cpu.nominalFrequencyHz = 3100000000\n.host.cpu.physicalCoreCount = 4\n.host.cpu.physicalProcessorCount = 1\n.host.cpu.processorName = MockIntel(R) Core(TM) i7-6700HQ CPU 2.60GHz\n.host.dotNetSdkVersion = 1.0.x.mock\n.host.hardwareTimerKind = Tsc\n.host.hasAttachedDebugger = False\n.host.hasRyuJit = True\n.host.os = Microsoft Windows NT 10.0.x.mock\n.host.os.display = Microsoft Windows NT 10.0.x.mock\n.host.runtimeVersion = Clr 4.0.x.mock\n.iterationIndex = 1\n.job = <object>\n.job.environment = <object>\n.job.environment.affinity = 4\n.job.environment.jit = RyuJit\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Summary Table in Markdown\nDESCRIPTION: A Markdown table summarizing the benchmark results for methods 'Foo' and 'Bar'. It shows the central tendency ('Center', likely mean or median) and statistical spread ('Spread', likely standard deviation or error) of the execution times, measured in nanoseconds ('ns'). This table provides a high-level overview of the performance comparison.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdTableTest_key=default01.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method |   Center |  Spread |\\n|:-------|---------:|--------:|\\n| Foo    |  11.0 ns | 0.81 ns |\\n| Bar    | 201.0 ns | 0.81 ns |\n```\n\n----------------------------------------\n\nTITLE: Referencing IntroBasic Sample Source Code in C#\nDESCRIPTION: This code block references the source file for the IntroBasic sample in BenchmarkDotNet. It demonstrates how to include external C# code in documentation.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroBasic.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroBasic.cs](../../../samples/BenchmarkDotNet.Samples/IntroBasic.cs)]\n```\n\n----------------------------------------\n\nTITLE: Formatting Benchmark Results in XML using BenchmarkDotNet XmlExporter (brief format)\nDESCRIPTION: A sample XML document showing the structured output of BenchmarkDotNet's XmlExporter in brief format. Contains benchmark results for MockBenchmarkClass methods including environment information, statistics, metrics, and memory usage details.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Exporters/VerifiedFiles/CommonExporterVerifyTests.Exporters_Invariant.verified.txt#2025-04-22_snippet_12\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Summary>\n  <Title>MockSummary</Title>\n  <HostEnvironmentInfo>\n    <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption>\n    <BenchmarkDotNetVersion>0.10.x-mock</BenchmarkDotNetVersion>\n    <OsVersion>Microsoft Windows NT 10.0.x.mock</OsVersion>\n    <ProcessorName>MockIntel Core i7-6700HQ CPU 2.60GHz</ProcessorName>\n    <PhysicalProcessorCount>1</PhysicalProcessorCount>\n    <PhysicalCoreCount>4</PhysicalCoreCount>\n    <LogicalCoreCount>8</LogicalCoreCount>\n    <RuntimeVersion>Clr 4.0.x.mock</RuntimeVersion>\n    <Architecture>64mock</Architecture>\n    <HasAttachedDebugger>False</HasAttachedDebugger>\n    <HasRyuJit>True</HasRyuJit>\n    <Configuration>CONFIGURATION</Configuration>\n    <DotNetSdkVersion>1.0.x.mock</DotNetSdkVersion>\n    <ChronometerFrequency>\n      <Hertz>2531248</Hertz>\n    </ChronometerFrequency>\n    <HardwareTimerKind>Tsc</HardwareTimerKind>\n  </HostEnvironmentInfo>\n  <Benchmarks>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Foo: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Foo</Method>\n      <MethodTitle>Foo</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n    </BenchmarkCase>\n    <BenchmarkCase>\n      <DisplayInfo>MockBenchmarkClass.Bar: LongRun(IterationCount=100, LaunchCount=3, WarmupCount=15)</DisplayInfo>\n      <Namespace>BenchmarkDotNet.Tests.Mocks</Namespace>\n      <Type>MockBenchmarkClass</Type>\n      <Method>Bar</Method>\n      <MethodTitle>Bar</MethodTitle>\n      <Statistics>\n        <OriginalValues>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n          <Item>1</Item>\n        </OriginalValues>\n        <N>6</N>\n        <Min>1</Min>\n        <LowerFence>1</LowerFence>\n        <Q1>1</Q1>\n        <Median>1</Median>\n        <Mean>1</Mean>\n        <Q3>1</Q3>\n        <UpperFence>1</UpperFence>\n        <Max>1</Max>\n        <InterquartileRange>0</InterquartileRange>\n        <StandardError>0</StandardError>\n        <Variance>0</Variance>\n        <StandardDeviation>0</StandardDeviation>\n        <Skewness>NaN</Skewness>\n        <Kurtosis>NaN</Kurtosis>\n        <ConfidenceInterval>\n          <N>6</N>\n          <Mean>1</Mean>\n          <StandardError>0</StandardError>\n          <Level>L999</Level>\n          <Margin>0</Margin>\n          <Lower>1</Lower>\n          <Upper>1</Upper>\n        </ConfidenceInterval>\n        <Percentiles>\n          <P0>1</P0>\n          <P25>1</P25>\n          <P50>1</P50>\n          <P67>1</P67>\n          <P80>1</P80>\n          <P85>1</P85>\n          <P90>1</P90>\n          <P95>1</P95>\n          <P100>1</P100>\n        </Percentiles>\n      </Statistics>\n      <Metrics>\n        <Item>\n          <Value>7</Value>\n          <Descriptor>\n            <Id>CacheMisses</Id>\n            <DisplayName>CacheMisses</DisplayName>\n            <Legend>Hardware counter 'CacheMisses' per single operation</Legend>\n            <NumberFormat>N0</NumberFormat>\n            <UnitType>Dimensionless</UnitType>\n            <TheGreaterTheBetter>False</TheGreaterTheBetter>\n            <PriorityInCategory>0</PriorityInCategory>\n          </Descriptor>\n        </Item>\n      </Metrics>\n      <Memory>\n        <Gen0Collections>0</Gen0Collections>\n        <Gen1Collections>0</Gen1Collections>\n        <Gen2Collections>0</Gen2Collections>\n        <TotalOperations>0</TotalOperations>\n        <BytesAllocatedPerOperation />\n      </Memory>\n    </BenchmarkCase>\n  </Benchmarks>\n</Summary>\n```\n\n----------------------------------------\n\nTITLE: Setting Target Framework\nDESCRIPTION: Command to create a benchmark project with a specific target framework\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/guides/dotnet-new-templates.md#2025-04-22_snippet_4\n\nLANGUAGE: log\nCODE:\n```\ndotnet new benchmark -f net472\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Target Frameworks in .NET 5/6 Projects\nDESCRIPTION: XML configuration showing how to specify multiple target frameworks including .NET 5, platform-specific .NET 5 (Windows), and .NET 6 in a project file.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<TargetFrameworks>net5.0;net5.0-windows10.0.19041.0;net6.0<TargetFrameworks>\n```\n\n----------------------------------------\n\nTITLE: Workload Measurement without Unrolling for Void Methods in C#\nDESCRIPTION: Executes the benchmark workload for methods returning `void`, without loop unrolling. It calls the `workloadDelegate` `invokeCount` times in a standard loop. `AggressiveOptimizationOption` encourages JIT optimizations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.MethodImpl(BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]\nprivate void WorkloadActionNoUnroll(System.Int64 invokeCount)\n{\n    $LoadArguments$\n    for (System.Int64 i = 0; i < invokeCount; i++)\n    {\n        workloadDelegate($PassArguments$);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Method-Specific Benchmark Settings with Job Attributes\nDESCRIPTION: C# code example showing how to apply different benchmark configuration attributes to individual methods rather than the entire class, allowing fine-grained control of benchmark parameters.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[Benchmark]\n[WarmupCount(1)]\npublic void SingleWarmupIteration()\n\n[Benchmark]\n[WarmupCount(9)]\npublic void NineWarmupIterations()\n```\n\n----------------------------------------\n\nTITLE: Zero Measurement Analysis Example\nDESCRIPTION: Shows the implementation of an empty benchmark method that triggers the ZeroMeasurementAnalyser, which helps identify and warn about methods with negligible execution time.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.11.2.md#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n[Benchmark]\npublic void Empty() { }\n```\n\n----------------------------------------\n\nTITLE: Holder Field for By-Ref Readonly Workload Results in C#\nDESCRIPTION: A private field used within the `RETURNS_BYREF_READONLY` conditional block to store the result of a benchmarked method returning `ref readonly T`. This field serves as the target for the reference returned by the `workloadDelegate`.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/src/BenchmarkDotNet/Templates/BenchmarkType.txt#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nprivate $WorkloadMethodReturnType$ workloadDefaultValueHolder = default($WorkloadMethodReturnType$);\n```\n\n----------------------------------------\n\nTITLE: Configuring AnyCPU Platform Target for Cross-JIT Disassembly in BenchmarkDotNet\nDESCRIPTION: XML configuration required in the project file to target AnyCPU, which allows benchmarking across different target platform architectures when comparing JIT-generated assembly.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroDisassemblyAllJits.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n  <PlatformTarget>AnyCPU</PlatformTarget>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Enabling Display WakeLock via BenchmarkDotNet Command Line\nDESCRIPTION: This command-line argument `--wakeLock Display` is used with the BenchmarkDotNet runner to enable a display wake lock. This prevents the system's display from turning off during the benchmark execution, which might be necessary for certain types of benchmarks or observations.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroWakeLock.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n--wakeLock Display\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Comparing Mono Inlining Options\nDESCRIPTION: This table shows the benchmark results comparing the performance of a sample method with Mono inlining enabled and disabled. The measurements indicate significant performance differences based on the optimization settings.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCustomMonoArguments.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Method |               Job |          Arguments |       Mean |    StdDev |\n|------- |------------------ |------------------- |-----------:|----------:|\n| Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns |\n| Sample |  Inlining enabled |  --optimize=inline |  0.0000 ns | 0.0000 ns |\n```\n\n----------------------------------------\n\nTITLE: Defining Benchmarking Keys in INI File\nDESCRIPTION: This code snippet lists configurable keys used in BenchmarkDotNet for benchmarking. These include keys for the benchmark, engine, host configuration, and job environment. Dependencies include INI file support and a compatible parsing tool.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/tests/BenchmarkDotNet.Tests/Phd/VerifiedFiles/Phd.PhdIndexTest_key=default05.verified.txt#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[Keys]\n  .benchmark\n  .benchmark.method\n  .benchmark.type\n  .engine\n  .engine.name\n  .engine.version\n  .host\n  .host.chronometerFrequency\n  .host.configuration\n  .host.cpu\n  .host.cpu.logicalCoreCount\n  .host.cpu.maxFrequencyHz\n  .host.cpu.nominalFrequencyHz\n  .host.cpu.physicalCoreCount\n  .host.cpu.physicalProcessorCount\n  .host.cpu.processorName\n  .host.dotNetSdkVersion\n  .host.hardwareTimerKind\n  .host.hasAttachedDebugger\n  .host.hasRyuJit\n  .host.os\n  .host.os.display\n  .host.runtimeVersion\n  .iterationIndex\n  .job\n  .job.environment\n  .job.environment.affinity\n  .job.environment.jit\n  .job.environment.runtime\n  .unit\n  .value\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results with Prioritized Arguments\nDESCRIPTION: Example output from running the IntroArgumentsPriority benchmark. The table shows how the arguments are displayed in the results based on their priority settings.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroArgumentsPriority.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|        Method |  b |   A | c | d |     Mean |   Error |  StdDev |\n|-------------- |--- |---- |-- |-- |---------:|--------:|--------:|\n| ManyArguments |  ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms |\n|     Benchmark |  5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms |\n|     Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms |\n|     Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms |\n```\n\n----------------------------------------\n\nTITLE: Building Mono AOT Compiler and Runtime Pack (Bash)\nDESCRIPTION: Demonstrates the shell command used within the root of the `dotnet/runtime` repository to build the necessary Mono AOT compiler (`mono-sgen`) and the runtime pack. This command targets the `mono` and `libs` subsets and builds them in the `Release` configuration.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/configs/toolchains.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh -subset mono+libs -c Release\n```\n\n----------------------------------------\n\nTITLE: Configuring InliningDiagnoser with Namespace Filtering in C#\nDESCRIPTION: This code sample demonstrates how to set up the InliningDiagnoser in BenchmarkDotNet to track inlining events from a specific namespace. It defines benchmark methods that will be analyzed for inlining optimizations performed by the JIT compiler.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroInliningDiagnoser.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[!code-csharp[IntroInliningDiagnoser.cs](../../../samples/BenchmarkDotNet.Samples/IntroInliningDiagnoser.cs)]\n```\n\n----------------------------------------\n\nTITLE: Benchmark Output with Custom Categories\nDESCRIPTION: This markdown table shows the result of running benchmarks with the custom category discoverer. It displays the benchmark methods, their assigned categories, and performance metrics.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/samples/IntroCategoryDiscoverer.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Method | Categories |     Mean | Error |\n|------- |----------- |---------:|------:|\n|    Bar |      All,B | 126.5 us |    NA |\n|    Foo |      All,F | 114.0 us |    NA |\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks Without Memory Randomization\nDESCRIPTION: Command line example showing how to run a benchmark without memory randomization, which provides consistent memory alignment and stable performance results.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/_changelog/header/v0.13.0.md#2025-04-22_snippet_3\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run -c Release --filter IntroMemoryRandomization\n```\n\n----------------------------------------\n\nTITLE: Running all BenchmarkDotNet tests in cmd\nDESCRIPTION: Command to run all tests for the BenchmarkDotNet project. This executes all test projects in Release configuration across all targeted frameworks.\nSOURCE: https://github.com/dotnet/benchmarkdotnet/blob/master/docs/articles/contributing/running-tests.md#2025-04-22_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet test -c Release BenchmarkDotNet.sln\n```"
  }
]