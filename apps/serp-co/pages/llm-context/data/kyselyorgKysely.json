[
  {
    "owner": "kysely-org",
    "repo": "kysely",
    "content": "TITLE: Using Relation Helper Functions in Kysely Queries\nDESCRIPTION: Demonstrates how to use custom relation helper functions to create cleaner, more maintainable queries for fetching related data.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .select(({ ref }) => [\n    pets(ref('person.id')).as('pets'),\n    mother(ref('person.mother_id')).as('mother')\n  ])\n  .execute()\n\nconsole.log(persons[0].pets[0].name)\nconsole.log(persons[0].mother?.first_name)\n```\n\n----------------------------------------\n\nTITLE: Migration Script Implementation\nDESCRIPTION: Complete example of a migration script that connects to PostgreSQL and runs all pending migrations with error handling and logging.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/migrations.mdx#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as path from 'path'\nimport { Pool } from 'pg'\nimport { promises as fs } from 'fs'\nimport {\n  Kysely,\n  Migrator,\n  PostgresDialect,\n  FileMigrationProvider,\n} from 'kysely'\nimport { Database } from './types'\n\nasync function migrateToLatest() {\n  const db = new Kysely<Database>({\n    dialect: new PostgresDialect({\n      pool: new Pool({\n        host: 'localhost',\n        database: 'kysely_test',\n      }),\n    }),\n  })\n\n  const migrator = new Migrator({\n    db,\n    provider: new FileMigrationProvider({\n      fs,\n      path,\n      // This needs to be an absolute path.\n      migrationFolder: path.join(__dirname, 'some/path/to/migrations'),\n    }),\n  })\n\n  const { error, results } = await migrator.migrateToLatest()\n\n  results?.forEach((it) => {\n    if (it.status === 'Success') {\n      console.log(`migration \"${it.migrationName}\" was executed successfully`)\n    } else if (it.status === 'Error') {\n      console.error(`failed to execute migration \"${it.migrationName}\"`)\n    }\n  })\n\n  if (error) {\n    console.error('failed to migrate')\n    console.error(error)\n    process.exit(1)\n  }\n\n  await db.destroy()\n}\n\nmigrateToLatest()\n```\n\n----------------------------------------\n\nTITLE: Handling Conditional Expressions in Kysely Queries\nDESCRIPTION: Shows two approaches for handling conditional expressions in Kysely queries. The first uses simple if statements, while the second uses the expression builder to create a more flexible structure for complex conditions.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0006-expressions.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Simple approach\nlet query = db\n  .selectFrom('person')\n  .selectAll('person')\n\nif (firstName) {\n  // The query builder is immutable. Remember to replace the builder\n  // with the new one.\n  query = query.where('first_name', '=', firstName)\n}\n\nif (lastName) {\n  query = query.where('last_name', '=', lastName)\n}\n\nconst persons = await query.execute()\n\n// Expression builder approach\nconst persons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .where((eb) => {\n    const filters: Expression<SqlBool>[] = []\n\n    if (firstName) {\n      filters.push(eb('first_name', '=', firstName))\n    }\n\n    if (lastName) {\n      filters.push(eb('last_name', '=', lastName))\n    }\n\n    return eb.and(filters)\n  })\n  .execute()\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Relations Query in Kysely\nDESCRIPTION: Demonstrates how to use the JSON helper functions to create a query that fetches persons with their pets and mother information nested within the result objects.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .select((eb) => [\n    // pets\n    jsonArrayFrom(\n      eb.selectFrom('pet')\n        .select(['pet.id', 'pet.name'])\n        .whereRef('pet.owner_id', '=', 'person.id')\n        .orderBy('pet.name')\n    ).as('pets'),\n\n    // mother\n    jsonObjectFrom(\n      eb.selectFrom('person as mother')\n        .select(['mother.id', 'mother.first_name'])\n        .whereRef('mother.id', '=', 'person.mother_id')\n    ).as('mother')\n  ])\n  .execute()\n\nconsole.log(persons[0].pets[0].name)\nconsole.log(persons[0].mother?.first_name)\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema Interface in TypeScript for Kysely\nDESCRIPTION: This code snippet defines a TypeScript interface for a database schema, including table definitions for 'person' and 'pet' tables. It demonstrates the use of various Kysely types like Generated, ColumnType, and JSONColumnType to accurately represent different column types and behaviors.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/getting-started/_types.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ColumnType,\n  Generated,\n  Insertable,\n  JSONColumnType,\n  Selectable,\n  Updateable,\n} from 'kysely'\n\nexport interface Database {\n  person: PersonTable\n  pet: PetTable\n}\n\nexport interface PersonTable {\n  id: Generated<number>\n\n  first_name: string\n  gender: 'man' | 'woman' | 'other'\n\n  last_name: string | null\n\n  created_at: ColumnType<Date, string | undefined, never>\n\n  metadata: JSONColumnType<{\n    login_at: string\n    ip: string | null\n    agent: string | null\n    plan: 'free' | 'premium'\n  }>\n}\n\nexport type Person = Selectable<PersonTable>\nexport type NewPerson = Insertable<PersonTable>\nexport type PersonUpdate = Updateable<PersonTable>\n\nexport interface PetTable {\n  id: Generated<number>\n  name: string\n  owner_id: number\n  species: 'dog' | 'cat'\n}\n\nexport type Pet = Selectable<PetTable>\nexport type NewPet = Insertable<PetTable>\nexport type PetUpdate = Updateable<PetTable>\n```\n\n----------------------------------------\n\nTITLE: Multiple Approaches for Uppercase Comparison in Kysely\nDESCRIPTION: Shows three different ways to write a query with an uppercase comparison in Kysely, including using sql template tag, ref, and fn function.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst lastName = 'STALLONE'\n\nconst persons = await db\n  .selectFrom('person')\n  .select(['id', 'first_name'])\n  // 1. `sql` template tag. This is the least type-safe option.\n  // You're providing the column name without any type-checking,\n  // and plugins won't affect it.\n  .where(\n    sql<string>`upper(last_name)`, '=', lastName\n  )\n  // 2. `sql` template tag with `ref`. Anything passed to `ref`\n  // gets type-checked against the accumulated query context.\n  .where(({ eb, ref }) => eb(\n    sql<string>`upper(${ref('last_name')})`, '=', lastName\n  ))\n  // 3. The `fn` function helps you avoid missing parentheses/commas\n  // errors and uses refs as 1st class arguments.\n  .where(({ eb, fn }) => eb(\n    fn<string>('upper', ['last_name']), '=', lastName\n  ))\n  .execute()\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Schema Migration Example\nDESCRIPTION: Complete example of a PostgreSQL migration creating person and pet tables with relationships and indexes.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/migrations.mdx#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, sql } from 'kysely'\n\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createTable('person')\n    .addColumn('id', 'serial', (col) => col.primaryKey())\n    .addColumn('first_name', 'varchar', (col) => col.notNull())\n    .addColumn('last_name', 'varchar')\n    .addColumn('gender', 'varchar(50)', (col) => col.notNull())\n    .addColumn('created_at', 'timestamp', (col) =>\n      col.defaultTo(sql`now()`).notNull(),\n    )\n    .execute()\n\n  await db.schema\n    .createTable('pet')\n    .addColumn('id', 'serial', (col) => col.primaryKey())\n    .addColumn('name', 'varchar', (col) => col.notNull().unique())\n    .addColumn('owner_id', 'integer', (col) =>\n      col.references('person.id').onDelete('cascade').notNull(),\n    )\n    .addColumn('species', 'varchar', (col) => col.notNull())\n    .execute()\n\n  await db.schema\n    .createIndex('pet_owner_id_index')\n    .on('pet')\n    .column('owner_id')\n    .execute()\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable('pet').execute()\n  await db.schema.dropTable('person').execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Schema-Qualified Tables in Kysely\nDESCRIPTION: Demonstrates how to query schema-qualified tables in Kysely, including joining multiple tables across schemas and using both short and fully-qualified table references.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndb.selectFrom('user.user')\n  .where('username', '=', '')\n  // You can also include the full table name\n  .where('user.user.created_at', '>', createdAt)\n  .innerJoin('user.user_permission as up', 'up.user_id', 'user.user.id')\n  .innerJoin('user.permission as p', 'p.id', 'up.permission_id')\n  .selectAll()\n```\n\n----------------------------------------\n\nTITLE: Basic Migration File Structure in TypeScript\nDESCRIPTION: Demonstrates the basic structure of a Kysely migration file with up and down functions for schema versioning.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/migrations.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely } from 'kysely'\n\nexport async function up(db: Kysely<any>): Promise<void> {\n  // Migration code\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  // Migration code\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Helper Functions in Kysely\nDESCRIPTION: Demonstrates how to create reusable and type-safe helper functions for common SQL operations like upper, lower, and concat.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Expression, sql } from 'kysely'\n\nfunction upper(expr: Expression<string>) {\n  return sql<string>`upper(${expr})`\n}\n\nfunction lower(expr: Expression<string>) {\n  return sql<string>`lower(${expr})`\n}\n\nfunction concat(...exprs: Expression<string>[]) {\n  return sql.join<string>(exprs, sql`||`)\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Nested Objects with jsonObjectFrom in Kysely\nDESCRIPTION: This code demonstrates how to use the `jsonObjectFrom` helper function to fetch nested objects (a person's favorite pet) along with the person data in a single query. The example shows database setup, query construction, and result handling.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0120-nested-object.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Kysely, PostgresDialect, Generated } from 'kysely'\nimport { jsonObjectFrom } from 'kysely/helpers'\n\n// This is your database interface. It defines the tables and their columns.\n// You can use any variable name you want, but the type is named `DB` by\n// convention in the examples. The type has to extend `Record<string, any>`.\ninterface DB {\n  person: {\n    id: Generated<number>\n    first_name: string\n    last_name: string\n    gender: 'male' | 'female' | 'other'\n    // A person can have one favorite pet.\n    favorite_pet_id: number | null\n  }\n\n  pet: {\n    id: Generated<number>\n    name: string\n    species: 'dog' | 'cat' | 'hamster' | 'goldfish' | 'turtle'\n    // One pet can have exactly one owner. The column `owner_id` is a\n    // foreign key that references the primary key `id` of the `person` table.\n    owner_id: number | null\n  }\n}\n\n// We need a pet with a specific id for our example.\nasync function insertPet(db: Kysely<DB>) {\n  await db.insertInto('pet')\n    // Use `values()` for building values for a single row.\n    .values({\n      // We need to explicitly insert the pet's id to make sure it's\n      // the same in all environments.\n      id: 1 as any,\n      name: 'Catto',\n      species: 'cat',\n      owner_id: null\n    })\n    .execute()\n}\n\n// We need a person with a reference to the pet we inserted.\nasync function insertPersonWithFavoritePet(db: Kysely<DB>) {\n  await db.insertInto('person')\n    // Use `values()` for building values for a single row.\n    .values({\n      first_name: 'Jennifer',\n      last_name: 'Aniston',\n      gender: 'female',\n      favorite_pet_id: 1\n    })\n    .execute()\n}\n\nasync function getPersonWithFavoritePet(db: Kysely<DB>) {\n  // We can use the `jsonObjectFrom` helper to fetch the favorite\n  // pet's data along with the person. The first argument is a function\n  // that returns a query and the second argument is the name of the\n  // property in the results.\n  //\n  // `jsonObjectFrom` adds a lateral join to the query and returns the\n  // joined object as a json object.\n  const result = await db\n    .selectFrom('person')\n    .select((eb) => [\n      'id',\n      jsonObjectFrom(\n        eb.selectFrom('pet')\n          // You can simply compare columns here. Kysely will automatically\n          // figure out the correct table reference even in complex nested\n          // queries with reused tables.\n          .where('pet.id', '=', 'person.favorite_pet_id')\n          .select(['id', 'name', 'species', 'owner_id']),\n      ).as('favorite_pet'),\n    ])\n    .execute()\n\n  return result[0]\n}\n\n// Setup the database and run the example.\nasync function run() {\n  const db = initializeDB();\n\n  try {\n    await db.schema\n      .dropTable('person')\n      .ifExists()\n      .execute()\n\n    await db.schema\n      .dropTable('pet')\n      .ifExists()\n      .execute()\n\n    await db.schema\n      .createTable('pet')\n      .addColumn('id', 'integer', (col) => col.primaryKey().autoIncrement())\n      .addColumn('name', 'varchar(100)', (col) => col.notNull())\n      .addColumn('species', 'varchar(50)', (col) => col.notNull())\n      .addColumn('owner_id', 'integer')\n      .execute()\n\n    await db.schema\n      .createTable('person')\n      .addColumn('id', 'integer', (col) => col.primaryKey().autoIncrement())\n      .addColumn('first_name', 'varchar(100)', (col) => col.notNull())\n      .addColumn('last_name', 'varchar(100)', (col) => col.notNull())\n      .addColumn('gender', 'varchar(50)', (col) => col.notNull())\n      .addColumn('favorite_pet_id', 'integer')\n      .addForeignKeyConstraint(\n        'favorite_pet_fk', ['favorite_pet_id'], 'pet', ['id']\n      )\n      .execute()\n\n    await insertPet(db)\n    await insertPersonWithFavoritePet(db)\n\n    const personWithFavoritePet = await getPersonWithFavoritePet(db)\n\n    // The result has the same shape as a hand-curated response to the\n    // frontend. We don't need any additional transformations:\n    console.log(personWithFavoritePet)\n  } finally {\n    await db.destroy()\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: SQLite Schema Migration Example\nDESCRIPTION: Complete example of a SQLite migration creating person and pet tables with relationships and indexes.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/migrations.mdx#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, sql } from 'kysely'\n\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createTable('person')\n    .addColumn('id', 'integer', (col) => col.primaryKey())\n    .addColumn('first_name', 'text', (col) => col.notNull())\n    .addColumn('last_name', 'text')\n    .addColumn('gender', 'text', (col) => col.notNull())\n    .addColumn('created_at', 'text', (col) =>\n      col.defaultTo(sql`CURRENT_TIMESTAMP`).notNull(),\n    )\n    .execute()\n\n  await db.schema\n    .createTable('pet')\n    .addColumn('id', 'integer', (col) => col.primaryKey())\n    .addColumn('name', 'text', (col) => col.notNull().unique())\n    .addColumn('owner_id', 'integer', (col) =>\n      col.references('person.id').onDelete('cascade').notNull(),\n    )\n    .addColumn('species', 'text', (col) => col.notNull())\n    .execute()\n\n  await db.schema\n    .createIndex('pet_owner_id_index')\n    .on('pet')\n    .column('owner_id')\n    .execute()\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable('pet').execute()\n  await db.schema.dropTable('person').execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Helper Functions in Kysely Queries\nDESCRIPTION: Shows how to use the created helper functions in various parts of a Kysely query, including where clauses, joins, and order by statements.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .innerJoin('pet', (join) => join.on(eb => eb(\n    'person.first_name', '=', lower(eb.ref('pet.name'))\n  )))\n  .select(({ ref, val }) => [\n    'first_name',\n    // If you use a helper in `select`, you need to always provide an explicit\n    // name for it using the `as` method.\n    concat(ref('person.first_name'), val(' '), ref('pet.name')).as('name_with_pet')\n  ])\n  .orderBy(({ ref }) => lower(ref('first_name')))\n  .execute()\n```\n\n----------------------------------------\n\nTITLE: Defining a Database Interface with Schema-Qualified Tables in Kysely\nDESCRIPTION: Shows how to define a TypeScript database interface in Kysely with schema-qualified table names. This approach is used when you have an enumerable set of schemas for logical grouping of tables.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Database {\n  'user.user': UserTable\n  'user.user_permission': UserPermissionTable\n  'user.permission': PermissionTable\n  pet: PetTable\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Helper Functions with ExpressionBuilder in Kysely\nDESCRIPTION: Demonstrates how to create type-safe, reusable helper functions using ExpressionBuilder. It shows an example of a function that checks for the existence of a dog with a specific name, and how to use it in queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0006-expressions.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction hasDogNamed(name: Expression<string>, ownerId: Expression<number>) {\n  // Create an expression builder without any tables in the context.\n  // This way we make no assumptions about the calling context.\n  const eb = expressionBuilder<DB>()\n\n  return eb.exists(\n    eb.selectFrom('pet')\n      .select('pet.id')\n      .where('pet.owner_id', '=', ownerId)\n      .where('pet.species', '=', 'dog')\n      .where('pet.name', '=', name)\n  )\n}\n\nconst doggoPersons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .where((eb) => hasDogNamed(eb.val('Doggo'), eb.ref('person.id')))\n  .execute()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom JSON Expression in TypeScript with Kysely\nDESCRIPTION: Creates a custom JsonValue class implementing the Expression interface to handle JSON/JSONB values in PostgreSQL with type safety. This class demonstrates how to implement the required expressionType getter and toOperationNode method.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Expression, Kysely, OperationNode, sql } from 'kysely'\n\nclass JsonValue<T> implements Expression<T> {\n  #value: T\n\n  constructor(value: T) {\n    this.#value = value\n  }\n\n  // This is a mandatory getter. You must add it and always return `undefined`.\n  // The return type must always be `T | undefined`.\n  get expressionType(): T | undefined {\n    return undefined\n  }\n\n  toOperationNode(): OperationNode {\n    const json = JSON.stringify(this.#value)\n    // Most of the time you can use the `sql` template tag to build the returned node.\n    // The `sql` template tag takes care of passing the `json` string as a parameter, alongside the sql string, to the DB.\n    return sql`CAST(${json} AS JSONB)`.toOperationNode()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex VALUES Expression Helper Function\nDESCRIPTION: Implements a helper function for creating VALUES expressions that can be used in complex queries. This function creates a virtual table with typed columns that can be joined with other tables.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction values<R extends Record<string, unknown>, A extends string>(\n  records: R[],\n  alias: A\n): AliasedRawBuilder<R, A> {\n  // Assume there's at least one record and all records\n  // have the same keys.\n  const keys = Object.keys(records[0])\n\n  // Transform the records into a list of lists such as\n  // ($1, $2, $3), ($4, $5, $6)\n  const values = sql.join(\n    records.map((r) => sql`(${sql.join(keys.map((k) => r[k]))})`) \n  )\n\n  // Create the alias `v(id, v1, v2)` that specifies the table alias\n  // AND a name for each column.\n  const wrappedAlias = sql.ref(alias)\n  const wrappedColumns = sql.join(keys.map(sql.ref))\n  const aliasSql = sql`${wrappedAlias}(${wrappedColumns})`\n\n  // Finally create a single `AliasedRawBuilder` instance of the\n  // whole thing. Note that we need to explicitly specify\n  // the alias type using `.as<A>` because we are using a\n  // raw sql snippet as the alias.\n  return sql<R>`(values ${values})`.as<A>(aliasSql)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the VALUES Helper Function in Complex Queries\nDESCRIPTION: Demonstrates how to use the VALUES helper function to create a virtual table that can be joined with other tables in a complex query. The function automatically parses column types for type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// This could come as an input from somewhere.\nconst records = [\n  {\n    id: 1,\n    v1: 'foo',\n    v2: 'bar',\n  },\n  {\n    id: 2,\n    v1: 'baz',\n    v2: 'spam',\n  },\n]\n\ndb.insertInto('t')\n  .columns(['t1', 't2'])\n  .expression(\n    // The `values` function automatically parses the column types\n    // from the records and you can refer to them through the table\n    // alias `v`. This works because Kysely is able to parse the\n    // AliasedRawBuilder<T, A> type.\n    db\n      .selectFrom(values(records, 'v'))\n      .innerJoin('j', 'v.id', 'j.vid')\n      .select(['v.v1', 'j.j2'])\n  )\n```\n\n----------------------------------------\n\nTITLE: Simplified JSON Helper Function using sql Template Tag\nDESCRIPTION: Creates a simplified json helper function using the sql template tag instead of implementing a custom class. This function provides the same functionality as the JsonValue class but with less code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, RawBuilder, sql } from 'kysely'\n\nfunction json<T>(value: T): RawBuilder<T> {\n  return sql`CAST(${JSON.stringify(value)} AS JSONB)`\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Helper Functions with ExpressionBuilder\nDESCRIPTION: Demonstrates how to create more complex helper functions using ExpressionBuilder, which can return subqueries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Expression, expressionBuilder } from 'kysely'\n\nfunction idsOfPersonsThatHaveDogNamed(name: Expression<string>) {\n  const eb = expressionBuilder<DB>()\n\n  // A subquery that returns the identifiers of all persons\n  // that have a dog named `name`.\n  return eb\n    .selectFrom('pet')\n    .select('pet.owner_id')\n    .where('pet.species', '=', 'dog')\n    .where('pet.name', '=', name)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Subqueries as Scalar Expressions in Kysely\nDESCRIPTION: Demonstrates how to use subqueries as scalar expressions in Kysely queries using $asScalar() and $notNull() methods.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .select((eb) => [\n    'id',\n    'first_name',\n    upper(\n      eb.selectFrom('pet')\n        .select('name')\n        .whereRef('person.id', '=', 'pet.owner_id')\n        .limit(1)\n        .$asScalar() // <-- This is needed\n        .$notNull()\n    ).as('pet_name')\n  ])\n```\n\n----------------------------------------\n\nTITLE: Using ExpressionBuilder for Complex Queries in Kysely\nDESCRIPTION: Demonstrates how to use ExpressionBuilder to create complex SQL queries with subqueries, function calls, and boolean expressions. It also shows how to destructure the expression builder for more concise syntax.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0006-expressions.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = await db\n  .selectFrom('person')\n  // `eb` is an instance of ExpressionBuilder<DB, 'person'>\n  .select((eb) => [\n    // Call the `upper` function on `first_name`. There's a bunch of\n    // shortcuts to functions under the `fn` object such as\n    // `eb.fn.coalesce()` that provide a cleaner syntax.\n    eb.fn('upper', ['first_name']).as('upper_first_name'),\n\n    // Select a subquery\n    eb.selectFrom('pet')\n      .select('name')\n      .whereRef('pet.owner_id', '=', 'person.id')\n      .limit(1)\n      .as('pet_name'),\n\n    // Select a boolean expression\n    eb('first_name', '=', 'Jennifer').as('is_jennifer'),\n\n    // Select a static string value\n    eb.val('Some value').as('string_value'),\n\n    // Select a literal value\n    eb.lit(42).as('literal_value'),\n  ])\n  // You can also destructure the expression builder like this\n  .where(({ and, or, eb, not, exists, selectFrom }) => or([\n    and([\n      eb('first_name', '=', firstName),\n      eb('last_name', '=', lastName)\n    ]),\n    not(exists(\n      selectFrom('pet')\n        .select('pet.id')\n        .whereRef('pet.owner_id', '=', 'person.id')\n        .where('pet.species', 'in', ['dog', 'cat'])\n    ))\n  ]))\n  .executeTakeFirstOrThrow()\n\nconsole.log(person.upper_first_name)\nconsole.log(person.pet_name)\nconsole.log(person.is_jennifer)\n```\n\n----------------------------------------\n\nTITLE: Implementing AliasedExpression with JsonValue in Kysely\nDESCRIPTION: Extends the JsonValue class to support aliasing by implementing the AliasedExpression interface. This allows the expression to be used in SELECT statements with a specified alias name, maintaining type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Expression,\n  AliasedExpression,\n  Kysely,\n  OperationNode,\n  sql,\n  AliasNode,\n  IdentifierNode,\n} from 'kysely'\n\nclass JsonValue<T> implements Expression<T> {\n  // ... Methods from the previous example ...\n\n  as<A extends string>(alias: A): AliasedJsonValue<T, A> {\n    return new AliasedJsonValue(this, alias)\n  }\n}\n\nclass AliasedJsonValue<T, A extends string> implements AliasedExpression<T, A> {\n  #expression: Expression<T>\n  #alias: A\n\n  constructor(expression: Expression<T>, alias: A) {\n    this.#expression = expression\n    this.#alias = alias\n  }\n\n  get expression(): Expression<T> {\n    return this.#expression\n  }\n\n  get alias(): A {\n    return this.#alias\n  }\n\n  toOperationNode(): AliasNode {\n    return AliasNode.create(\n      this.#expression.toOperationNode(),\n      IdentifierNode.create(this.#alias)\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom UUID Primary Key Method to CreateTableBuilder in Kysely\nDESCRIPTION: This snippet demonstrates how to extend Kysely's CreateTableBuilder class using TypeScript module augmentation to add a custom 'addIdColumn' method that creates a UUID primary key column with a default value.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module 'kysely/dist/cjs/schema/create-table-builder' {\n  interface CreateTableBuilder<TB extends string, C extends string = never> {\n    addIdColumn<CN extends string = 'id'>(\n      col?: CN\n    ): CreateTableBuilder<TB, C | CN>\n  }\n}\nCreateTableBuilder.prototype.addIdColumn = function (\n  this: CreateTableBuilder<any, any>,\n  col?: string\n) {\n  return this.addColumn(col || 'id', 'uuid', (col) =>\n    col.primaryKey().defaultTo(sql`gen_random_uuid()`)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Logging Function in Kysely\nDESCRIPTION: Demonstrates how to implement a custom logging function that handles both query and error events, including masking PII in parameters and formatting log output.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0012-logging.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = new Kysely({\n  dialect: new PostgresDialect(postgresConfig),\n  log(event) {\n    if (event.level === \"error\") {\n        console.error(\"Query failed : \", {\n          durationMs: event.queryDurationMillis,\n          error: event.error,\n          sql: event.query.sql,\n          params: event.query.parameters.map(maskPII),\n        });\n    } else { // `'query'`\n      console.log(\"Query executed : \", {\n        durationMs: event.queryDurationMillis,\n        sql: event.query.sql,\n        params: event.query.parameters.map(maskPII),\n      });\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Helper Functions for Kysely Queries\nDESCRIPTION: Defines helper functions for generating JSON arrays and objects from subqueries in Kysely, simplifying the creation of nested relation queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction jsonArrayFrom<O>(expr: Expression<O>) {\n  return sql<Simplify<O>[]>`(select coalesce(json_agg(agg), '[]') from ${expr} as agg)`\n}\n\nfunction jsonObjectFrom<O>(expr: Expression<O>) {\n  return sql<Simplify<O>>`(select to_json(obj) from ${expr} as obj)`\n}\n```\n\n----------------------------------------\n\nTITLE: Using AliasedJsonValue in Kysely SELECT Queries\nDESCRIPTION: Demonstrates how to use AliasedJsonValue in SELECT statements. The custom class allows you to alias JSON expressions in a type-safe way, with the result type correctly inferred.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DB {\n  person: {\n    address: {\n      postalCode: string\n      street: string\n    }\n  }\n}\n\nasync function test(db: Kysely<DB>) {\n  const result = await db\n    .selectFrom('person')\n    .select([new JsonValue({ someValue: 42 }).as('some_object'), 'address'])\n    .where(\n      'address',\n      '@>',\n      new JsonValue({ postalCode: '123456', street: 'Kysely avenue 42' })\n    )\n    .executeTakeFirstOrThrow()\n\n  console.log(result.some_object.someValue)\n  console.log(result.address.postalCode)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Plugins to Kysely Instance in TypeScript\nDESCRIPTION: This code snippet demonstrates how to initialize a Kysely database instance with plugins. It shows the syntax for setting up a PostgreSQL connection and adding the CamelCasePlugin to transform snake_case database identifiers to camelCase in JavaScript.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/plugins.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = new Kysely<Database>({\n  dialect: new PostgresDialect({\n    database: 'kysely_test',\n    host: 'localhost',\n  }),\n  plugins: [new CamelCasePlugin()],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Kysely Query Builder for Deno\nDESCRIPTION: Example showing how to set up Kysely query builder in a Deno environment using CDN imports. Demonstrates type definitions, database interface setup, and basic query compilation using PostgreSQL components with a dummy driver.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/runtimes/deno.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// We use jsdeliver to get Kysely from npm.\nimport {\n  DummyDriver,\n  Generated,\n  Kysely,\n  PostgresAdapter,\n  PostgresIntrospector,\n  PostgresQueryCompiler,\n} from 'https://cdn.jsdelivr.net/npm/kysely/dist/esm/index.js'\n\ninterface Person {\n  id: Generated<number>\n  first_name: string\n  last_name: string | null\n}\n\ninterface Database {\n  person: Person\n}\n\nconst db = new Kysely<Database>({\n  dialect: {\n    createAdapter() {\n      return new PostgresAdapter()\n    },\n    createDriver() {\n      // You need a driver to be able to execute queries. In this example\n      // we use the dummy driver that never does anything.\n      return new DummyDriver()\n    },\n    createIntrospector(db: Kysely<unknown>) {\n      return new PostgresIntrospector(db)\n    },\n    createQueryCompiler() {\n      return new PostgresQueryCompiler()\n    },\n  },\n})\n\nconst query = db.selectFrom('person').select('id')\nconst sql = query.compile()\n\nconsole.log(sql.sql)\n```\n\n----------------------------------------\n\nTITLE: Compiling Kysely Query\nDESCRIPTION: Demonstrates how to compile a Kysely query into SQL using the compile() method. Returns a CompiledQuery object containing the SQL string and parameters.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst compiledQuery = db\n  .selectFrom('person')\n  .select('first_name')\n  .where('id', '=', id)\n  .compile()\n\nconsole.log(compiledQuery) // { sql: 'select \"first_name\" from \"person\" where \"id\" = $1', parameters: [1], query: { ... } }\n```\n\n----------------------------------------\n\nTITLE: Using the Simplified json Helper with Aliasing\nDESCRIPTION: Shows how to use the simplified json helper function with aliasing in SELECT statements. The built-in 'as' method of RawBuilder enables proper aliasing while maintaining type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DB {\n  person: {\n    address: {\n      postalCode: string\n      street: string\n    }\n  }\n}\n\nasync function test(db: Kysely<DB>) {\n  const result = await db\n    .selectFrom('person')\n    .select([json({ someValue: 42 }).as('some_object'), 'address'])\n    .where(\n      'address',\n      '@>',\n      json({ postalCode: '123456', street: 'Kysely avenue 42' })\n    )\n    .executeTakeFirstOrThrow()\n\n  console.log(result.address.postalCode)\n  console.log(result.some_object.someValue)\n}\n```\n\n----------------------------------------\n\nTITLE: Database Interface for Multi-Tenant Schema Configuration in Kysely\nDESCRIPTION: Demonstrates how to define a TypeScript database interface for multi-tenant applications, including both tenant-specific tables and shared tables that may reside in specific schemas.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Database {\n  // Add your tenant tables without any schema:\n  user: UserTable\n  user_permission: UserPermissionTable\n\n  // Add schemas and tables you need to explicitly reference like this:\n  'public.permission': PermissionTable\n\n  // You can also have other shared tables with or without schemas here.\n  // But keep in mind that if you want to refer to them from a `withSchema`\n  // query, you need the table name with the schema name.\n  pet: PetTable\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Implementation of Conditional Select in Kysely\nDESCRIPTION: This snippet shows a simple implementation of conditional select in Kysely that works for a single condition but becomes unwieldy with multiple conditions.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0005-conditional-selects.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(id: number, withLastName: boolean) {\n  const query = db\n    .selectFrom('person')\n    .select('first_name')\n    .where('id', '=', id)\n\n  if (withLastName) {\n    // ✅ The return type is { first_name: string, last_name: string }\n    return await query.select('last_name').executeTakeFirstOrThrow()\n  }\n\n  // ✅ The return type is { first_name: string }\n  return await query.executeTakeFirstOrThrow()\n}\n```\n\n----------------------------------------\n\nTITLE: Using the ParseJSONResultsPlugin for JSON Parsing in Kysely\nDESCRIPTION: Shows how to configure the ParseJSONResultsPlugin in Kysely to parse JSON columns automatically when the database driver doesn't handle it.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = new Kysely<DB>({\n  ...\n  plugins: [new ParseJSONResultsPlugin()]\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Custom addIdColumn Method in Kysely Schema Creation\nDESCRIPTION: Example of using the custom 'addIdColumn' method to create tables with a uniform UUID primary key definition, showing how it can be used in different positions in the builder chain.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ndb.schema.createTable('person').addIdColumn().addColumn('name', 'varchar')\ndb.schema.createTable('pet').addColumn('species', 'varchar').addIdColumn()\n```\n\n----------------------------------------\n\nTITLE: LogEvent Interface Definition for Kysely\nDESCRIPTION: TypeScript interface definition for the LogEvent object that contains logging information including query details, duration, and error data.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0012-logging.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface LogEvent {\n  level: 'query' | 'error';\n  query: CompiledQuery; // this object contains the raw SQL string, parameters, and Kysely's SQL syntax tree that helped output the raw SQL string.\n  queryDurationMillis: number; // the time in milliseconds it took for the query to execute and get a response from the database.\n  error: unknown; // only present if `level` is `'error'`.\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Compiled Queries\nDESCRIPTION: Shows how to execute a compiled query using a Kysely instance with a real database driver.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#2025-04-16_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst compiledQuery = db\n  .selectFrom('person')\n  .select('first_name')\n  .where('id', '=', id)\n  .compile()\n\nconst results = await db.executeQuery(compiledQuery)\n```\n\n----------------------------------------\n\nTITLE: Using the Simplified json Helper Function\nDESCRIPTION: Demonstrates how to use the simplified json helper function in insert and select operations. Shows how the function provides the same type-safe functionality as the JsonValue class with a more concise API.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DB {\n  person: {\n    address: {\n      postalCode: string\n      street: string\n    }\n  }\n}\n\nasync function test(db: Kysely<DB>) {\n  await db\n    .insertInto('person')\n    .values({\n      address: json({\n        postalCode: '123456',\n        street: 'Kysely avenue 42',\n      }),\n    })\n    .execute()\n\n  await db\n    .selectFrom('person')\n    .selectAll()\n    .where(\n      'address',\n      '@>',\n      json({ postalCode: '123456', street: 'Kysely avenue 42' })\n    )\n    .execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Relation Helper Functions in Kysely\nDESCRIPTION: Shows how to create reusable helper functions for specific relation types (pets and mother) to simplify queries throughout the codebase.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction pets(ownerId: Expression<string>) {\n  return jsonArrayFrom(\n    db.selectFrom('pet')\n      .select(['pet.id', 'pet.name'])\n      .where('pet.owner_id', '=', ownerId)\n      .orderBy('pet.name')\n  )\n}\n\nfunction mother(motherId: Expression<string>) {\n  return jsonObjectFrom(\n    db.selectFrom('person as mother')\n      .select(['mother.id', 'mother.first_name'])\n      .where('mother.id', '=', motherId)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Nullable Expressions in Helper Functions\nDESCRIPTION: Shows how to create helper functions that can handle both nullable and non-nullable expressions using conditional types.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Expression } from 'kysely'\n\n// This function accepts both nullable and non-nullable string expressions.\nfunction toInt<T extends string | null>(expr: Expression<T>) {\n  // This returns `Expression<number | null>` if `expr` is nullable\n  // and `Expression<number>` otherwise.\n  return sql<T extends null ? (number | null) : number>`(${expr})::integer`\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Raw SQL Query\nDESCRIPTION: Shows how to compile a raw SQL query using the sql template literal tag with type inference.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Selectable, sql } from 'kysely'\n\nconst compiledQuery = sql<Selectable<Person>>`select * from person where id = ${id}`.compile(db)\n\nconsole.log(compiledQuery) // { sql: 'select * from person where id = $1', parameters: [1], query: { ... } }\n```\n\n----------------------------------------\n\nTITLE: Defining Function Signature for Conditional Select in TypeScript\nDESCRIPTION: This snippet shows the function signature for a getPerson function that conditionally includes the last name based on a boolean parameter.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0005-conditional-selects.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(id: number, withLastName: boolean) {}\n```\n\n----------------------------------------\n\nTITLE: Marking Relations as Non-Null in Kysely\nDESCRIPTION: Shows how to use the $notNull() helper to mark a relation as non-nullable when you know it always exists, improving TypeScript type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .select(({ ref }) => [\n    pets(ref('person.id')).as('pets'),\n    mother(ref('person.mother_id')).$notNull().as('mother')\n  ])\n  .execute()\n\nconsole.log(persons[0].pets[0].name)\nconsole.log(persons[0].mother.first_name)\n```\n\n----------------------------------------\n\nTITLE: Using expressionBuilder Function in Kysely\nDESCRIPTION: Shows how to use the global expressionBuilder function to create expression builders with different contexts. It demonstrates creating builders with no tables, specific tables, and inferring context from a query builder.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0006-expressions.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { expressionBuilder } from 'kysely'\n\n// `eb1` has type `ExpressionBuilder<DB, never>` which means there are no tables in the\n// context. This variant should be used most of the time in helper functions since you\n// shouldn't make assumptions about the calling context.\nconst eb1 = expressionBuilder<DB>()\n\n// `eb2` has type `ExpressionBuilder<DB, 'person'>`. You can reference `person` columns\n// directly in all expression builder methods.\nconst eb2 = expressionBuilder<DB, 'person'>()\n\n// In this one you'd have access to tables `person` and `pet` and all their columns.\nconst eb3 = expressionBuilder<DB, 'person' | 'pet'>()\n\nlet qb = query\n  .selectFrom('person')\n  .innerJoin('movie as m', 'm.director_id', 'person.id')\n\n// You can also provide a query builder instance and the context is inferred automatically.\n// Type of `eb` is `ExpressionBuilder<DB & { m: Movie }, 'person' | 'm'>`\nconst eb = expressionBuilder(qb)\n\nqb = qb.where(eb.not(eb.exists(\n  eb.selectFrom('pet')\n    .select('pet.id')\n    .whereRef('pet.name', '=', 'm.name')\n)))\n```\n\n----------------------------------------\n\nTITLE: Fixed Query Using $assertType for Type Depth Resolution\nDESCRIPTION: Modified version of the query that uses $assertType to explicitly define types for some WITH clauses, resolving the TypeScript depth error while maintaining type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0009-excessively-deep-types.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await db\n  .with('w1', (qb) => qb.selectFrom('person').select('first_name as fn1'))\n  .with('w2', (qb) => qb.selectFrom('person').select('first_name as fn2'))\n  .with('w3', (qb) => qb.selectFrom('person').select('first_name as fn3'))\n  .with('w4', (qb) => qb.selectFrom('person').select('first_name as fn4'))\n  .with('w5', (qb) => qb.selectFrom('person').select('first_name as fn5'))\n  .with('w6', (qb) => qb.selectFrom('person').select('first_name as fn6'))\n  .with('w7', (qb) => qb.selectFrom('person').select('first_name as fn7'))\n  .with('w8', (qb) => qb.selectFrom('person').select('first_name as fn8'))\n  .with('w9', (qb) => qb.selectFrom('person').select('first_name as fn9'))\n  .with('w10', (qb) => qb.selectFrom('person').select('first_name as fn10'))\n  .with('w11', (qb) => qb.selectFrom('person').select('first_name as fn11'))\n  .with('w12', (qb) =>\n    qb\n      .selectFrom('person')\n      .select('first_name as fn12')\n      .$assertType<{ fn12: string }>()\n  )\n  .with('w13', (qb) =>\n    qb\n      .selectFrom('person')\n      .select('first_name as fn13')\n      .$assertType<{ fn13: string }>()\n  )\n  .selectFrom(['w1', 'w2', 'w3', 'w4', 'w5', 'w6', 'w7', 'w8', 'w9', 'w10', 'w11', 'w12', 'w13'])\n  .selectAll()\n  .executeTakeFirstOrThrow()\n```\n\n----------------------------------------\n\nTITLE: Using Custom JsonValue Expression in Kysely Queries\nDESCRIPTION: Demonstrates usage of the custom JsonValue expression in insert and select operations. Shows how the expression can be used as a value in a type-safe way when interacting with PostgreSQL JSON data.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0010-extending-kysely.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DB {\n  person: {\n    address: {\n      postalCode: string\n      street: string\n    }\n  }\n}\n\nasync function test(db: Kysely<DB>) {\n  await db\n    .insertInto('person')\n    .values({\n      address: new JsonValue({\n        postalCode: '123456',\n        street: 'Kysely avenue 42',\n      }),\n    })\n    .execute()\n\n  await db\n    .selectFrom('person')\n    .selectAll()\n    .where(\n      'address',\n      '@>',\n      new JsonValue({ postalCode: '123456', street: 'Kysely avenue 42' })\n    )\n    .execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Selecting Relations in Kysely\nDESCRIPTION: Demonstrates how to conditionally include relations in a query using the $if helper, allowing for flexible queries based on runtime conditions.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst persons = await db\n  .selectFrom('person')\n  .selectAll('person')\n  .$if(includePets, (qb) => qb.select(\n    (eb) => pets(eb.ref('person.id')).as('pets')\n  ))\n  .$if(includeMom, (qb) => qb.select(\n    (eb) => mother(eb.ref('person.mother_id')).as('mother')\n  ))\n  .execute()\n```\n\n----------------------------------------\n\nTITLE: Generated SQL Query with Dynamic Schema in Kysely\nDESCRIPTION: Shows the SQL generated by Kysely when using the withSchema method, demonstrating how table references are qualified with the tenant schema while explicitly schema-qualified tables maintain their original schema.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md#2025-04-16_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nselect * from \"acme\".\"user\"\ninner join \"acme\".\"user_permission\" as \"up\" on \"up\".\"user_id\" = \"acme\".\"user\".\"id\"\ninner join \"public\".\"permission\" as \"p\" on \"p\".\"id\" = \"up\".\"permission_id\"\n```\n\n----------------------------------------\n\nTITLE: Raw SQL Example for Nested Relations in PostgreSQL\nDESCRIPTION: Demonstrates a raw SQL query that fetches people with their related pets and mother information nested as JSON arrays and objects.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  person.*,\n\n  -- Select person's pets as a json array\n  (\n    SELECT\n      COALESCE(JSON_AGG(pets), '[]')\n    FROM\n    (\n      SELECT\n        pet.id, pet.name\n      FROM\n        pet\n      WHERE\n        pet.owner_id = person.id\n      ORDER BY\n        pet.name\n    ) pets\n  ) pets,\n\n  -- Select person's mother as a json object\n  (\n    SELECT\n      TO_JSON(mother)\n    FROM\n    (\n      SELECT\n        mother.id, mother.first_name\n      FROM\n        person as mother\n      WHERE\n        mother.id = person.mother_id\n    ) mother\n  ) mother\nFROM\n  person\n```\n\n----------------------------------------\n\nTITLE: Configuring Tinyint Runtime Type for MySQL in Kysely\nDESCRIPTION: This snippet shows how to configure the 'mysql2' driver to map 'tinyint(1)' to a boolean. It uses the 'typeCast' pool property to define a custom type casting function for the TINY type with length 1.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0002-data-types.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, MysqlDialect } from 'kysely'\nimport { createPool } from 'mysql2'\n\nexport const db = new Kysely<Database>({\n  dialect: new MysqlDialect({\n    pool: createPool({\n      ...config,\n      // Map tinyint(1) to boolean\n      typeCast(field, next) {\n        if (field.type === 'TINY' && field.length === 1) {\n          return field.string() === '1'\n        } else {\n          return next()\n        }\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Cold Kysely Instance with DummyDriver\nDESCRIPTION: Shows how to create a Kysely instance that only builds queries without database connectivity using DummyDriver. Includes type definitions for database schema and configuration of PostgreSQL dialect components.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Generated,\n  DummyDriver,\n  Kysely,\n  PostgresAdapter,\n  PostgresIntrospector,\n  PostgresQueryCompiler,\n} from 'kysely'\n\ninterface Person {\n  id: Generated<number>\n  first_name: string\n  last_name: string | null\n}\n\ninterface Database {\n  person: Person\n}\n\nconst db = new Kysely<Database>({\n  dialect: {\n    createAdapter: () => new PostgresAdapter(),\n    createDriver: () => new DummyDriver(),\n    createIntrospector: (db) => new PostgresIntrospector(db),\n    createQueryCompiler: () => new PostgresQueryCompiler(),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Bigint Runtime Type for Postgres in Kysely\nDESCRIPTION: This snippet demonstrates how to configure the 'pg' driver to return 'bigint' as a number instead of a string. It uses the 'pg-types' package to set a custom type parser for the 'bigint' type (type id 20).\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0002-data-types.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, PostgresDialect } from 'kysely'\nimport * as pg from 'pg'\n\nconst int8TypeId = 20\n// Map int8 to number.\npg.types.setTypeParser(int8TypeId, (val) => {\n  return parseInt(val, 10)\n})\n\nexport const db = new Kysely<Database>({\n  dialect: new PostgresDialect({\n    pool: new pg.Pool(config),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Basic SQL Query Example in Kysely\nDESCRIPTION: Demonstrates a simple SQL query for selecting person data based on an uppercase last name comparison.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-reusable-helpers.md#2025-04-16_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT id, first_name\nFROM person\nWHERE upper(last_name) = $1\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Helper Functions from Kysely\nDESCRIPTION: Shows how to import the built-in JSON helper functions for PostgreSQL, MySQL, and SQLite dialects in Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0001-relations.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/postgres'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/mysql'\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/sqlite'\n```\n\n----------------------------------------\n\nTITLE: Using $if Method for Conditional Select in Kysely\nDESCRIPTION: This snippet demonstrates the recommended approach using Kysely's $if method for conditional selects, which maintains type safety and handles multiple conditions efficiently.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0005-conditional-selects.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(id: number, withLastName: boolean) {\n  // ✅ The return type is { first_name: string, last_name?: string }\n  return await db\n    .selectFrom('person')\n    .select('first_name')\n    .$if(withLastName, (qb) => qb.select('last_name'))\n    .where('id', '=', id)\n    .executeTakeFirstOrThrow()\n}\n```\n\n----------------------------------------\n\nTITLE: Per-Query Usage of DeduplicateJoinsPlugin in Kysely\nDESCRIPTION: Demonstrates how to apply the DeduplicateJoinsPlugin to a specific query using the withPlugin method. This approach allows selective application of the plugin only when needed for queries that might have duplicate joins.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0008-deduplicate-joins.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(\n  id: number,\n  withPetName: boolean,\n  withPetSpecies: boolean\n) {\n  return await db\n    .withPlugin(new DeduplicateJoinsPlugin())\n    .selectFrom('person')\n    .selectAll('person')\n    .$if(withPetName, (qb) =>\n      qb\n        .innerJoin('pet', 'pet.owner_id', 'person.id')\n        .select('pet.name as pet_name')\n    )\n    .$if(withPetSpecies, (qb) =>\n      qb\n        .innerJoin('pet', 'pet.owner_id', 'person.id')\n        .select('pet.species as pet_species')\n    )\n    .where('person.id', '=', id)\n    .executeTakeFirst()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component for Single Row Update\nDESCRIPTION: Renders an interactive playground component that displays and allows execution of the single row update example with the provided setup code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0010-single-row.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={singleRow} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Initializing Kysely Database in Browser Environment\nDESCRIPTION: Sets up a Kysely database instance with SQLite configuration for browser usage. Demonstrates type definitions, dialect configuration, and a simple query compilation example that displays results in the DOM.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/runtimes/browser.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Kysely,\n  Generated,\n  DummyDriver,\n  SqliteAdapter,\n  SqliteIntrospector,\n  SqliteQueryCompiler,\n} from 'kysely'\n\ninterface Person {\n  id: Generated<number>\n  first_name: string\n  last_name: string | null\n}\n\ninterface Database {\n  person: Person\n}\n\nconst db = new Kysely<Database>({\n  dialect: {\n    createAdapter() {\n      return new SqliteAdapter()\n    },\n    createDriver() {\n      return new DummyDriver()\n    },\n    createIntrospector(db: Kysely<unknown>) {\n      return new SqliteIntrospector(db)\n    },\n    createQueryCompiler() {\n      return new SqliteQueryCompiler()\n    },\n  },\n})\n\nwindow.addEventListener('load', () => {\n  const sql = db.selectFrom('person').select('id').compile()\n\n  const result = document.createElement('span')\n  result.id = 'result'\n  result.innerHTML = sql.sql\n\n  document.body.appendChild(result)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Schemas for Multi-Tenant Applications in Kysely\nDESCRIPTION: Shows how to use the withSchema method in Kysely for multi-tenant applications where each tenant has its own schema. This approach dynamically sets the schema for table references at runtime.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndb.withSchema(tenant)\n  .selectFrom('user')\n  .innerJoin('user_permission as up', 'up.user_id', 'user.id')\n  .innerJoin('public.permission as p', 'p.id', 'up.permission_id')\n  .selectAll()\n```\n\n----------------------------------------\n\nTITLE: Rendering Interactive Playground Component in React\nDESCRIPTION: Creates a React component that renders the Playground with the simpleWhereClause example and the example setup code. This provides an interactive demonstration of Kysely's where clause functionality.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0010-simple-where-clause.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={simpleWhereClause} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Inferring Query Result Types\nDESCRIPTION: Demonstrates type inference for both regular and compiled queries using the InferResult type helper.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferResult } from 'kysely'\n\nconst query = db\n  .selectFrom('person')\n  .select('first_name')\n  .where('id', '=', id)\n\ntype QueryReturnType = InferResult<typeof query> // { first_name: string }[]\n\nconst compiledQuery = query.compile()\n\ntype CompiledQueryReturnType = InferResult<typeof compiledQuery> // { first_name: string }[]\n```\n\n----------------------------------------\n\nTITLE: Problematic Query with Duplicate Joins in Kysely\nDESCRIPTION: Example showing a Kysely query that might produce duplicate joins when both condition parameters are true. This function retrieves a person with optional pet information, but the joins to the pet table could be duplicated.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0008-deduplicate-joins.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(\n  id: number,\n  withPetName: boolean,\n  withPetSpecies: boolean\n) {\n  return await db\n    .selectFrom('person')\n    .selectAll('person')\n    .$if(withPetName, (qb) =>\n      qb\n        .innerJoin('pet', 'pet.owner_id', 'person.id')\n        .select('pet.name as pet_name')\n    )\n    .$if(withPetSpecies, (qb) =>\n      qb\n        .innerJoin('pet', 'pet.owner_id', 'person.id')\n        .select('pet.species as pet_species')\n    )\n    .where('person.id', '=', id)\n    .executeTakeFirst()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Interactive Playground for Kysely Transaction Example in JSX\nDESCRIPTION: Renders a Playground component that displays the simpleTransaction code example with the appropriate setup code for demonstration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/transactions/0010-simple-transaction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={simpleTransaction} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Complex Query with Multiple WITH Clauses Causing TS2589 Error\nDESCRIPTION: Example of a Kysely query with 13 WITH clauses that triggers TypeScript's excessive type depth error. The query selects first_name from person table multiple times with different aliases.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0009-excessively-deep-types.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await db\n  .with('w1', (qb) => qb.selectFrom('person').select('first_name as fn1'))\n  .with('w2', (qb) => qb.selectFrom('person').select('first_name as fn2'))\n  .with('w3', (qb) => qb.selectFrom('person').select('first_name as fn3'))\n  .with('w4', (qb) => qb.selectFrom('person').select('first_name as fn4'))\n  .with('w5', (qb) => qb.selectFrom('person').select('first_name as fn5'))\n  .with('w6', (qb) => qb.selectFrom('person').select('first_name as fn6'))\n  .with('w7', (qb) => qb.selectFrom('person').select('first_name as fn7'))\n  .with('w8', (qb) => qb.selectFrom('person').select('first_name as fn8'))\n  .with('w9', (qb) => qb.selectFrom('person').select('first_name as fn9'))\n  .with('w10', (qb) => qb.selectFrom('person').select('first_name as fn10'))\n  .with('w11', (qb) => qb.selectFrom('person').select('first_name as fn11'))\n  .with('w12', (qb) => qb.selectFrom('person').select('first_name as fn12'))\n  .with('w13', (qb) => qb.selectFrom('person').select('first_name as fn13'))\n  .selectFrom(['w1', 'w2', 'w3', 'w4', 'w5', 'w6', 'w7', 'w8', 'w9', 'w10', 'w11', 'w12', 'w13'])\n  .selectAll()\n  .executeTakeFirstOrThrow()\n```\n\n----------------------------------------\n\nTITLE: Global Installation of DeduplicateJoinsPlugin in Kysely\nDESCRIPTION: Shows how to install the DeduplicateJoinsPlugin globally by providing it in the Kysely instance configuration. This approach applies the plugin to all queries run through the database instance.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0008-deduplicate-joins.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = new Kysely<Database>({\n  dialect,\n  plugins: [new DeduplicateJoinsPlugin()],\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component\nDESCRIPTION: Creates a Playground component with the multipleColumns example code and exampleSetup configuration to demonstrate how to select multiple columns in Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0030-multiple-columns.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={multipleColumns} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Creating an INSERT INTO SELECT FROM Query with Kysely\nDESCRIPTION: This snippet demonstrates how to use Kysely's expression method to create an INSERT INTO SELECT FROM query. It inserts data into the 'person2' table by selecting from the 'person' table where the first name is 'Jennifer'.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0050-insert-subquery.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Expression, Kysely, sql } from 'kysely'\n\nconst db = new Kysely<Database>()\n\nconst result = await db\n  .insertInto('person2')\n  .columns(['first_name', 'last_name', 'age'])\n  .expression((eb) => eb\n    .selectFrom('person')\n    .select(['first_name', 'last_name', 'age'])\n    .where('first_name', '=', 'Jennifer')\n  )\n  .execute()\n\nconsole.log(result)\n```\n\n----------------------------------------\n\nTITLE: Introspecting PostgreSQL Database Schema with Kysely\nDESCRIPTION: Example showing how to connect to a PostgreSQL database using Kysely and extract table metadata using the introspection API. The code creates a database connection using environment variables and retrieves a list of all tables and views.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0011-introspecting-relation-metadata.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, PostgresDialect } from 'kysely'\nimport pg from 'pg'\nconst { Pool } = pg\n\nasync function logDatabaseSchema() {\n  const db = new Kysely({\n    dialect: new PostgresDialect({\n      pool: new Pool({\n        connectionString: process.env.DATABASE_URL,\n      }),\n    }),\n  })\n\n  const tables = await db.introspection.getTables()\n  //        ^?  TableMetadata[]\n\n  console.log({ tables })\n}\n\nlogDatabaseSchema()\n```\n\n----------------------------------------\n\nTITLE: Rendering Playground Component\nDESCRIPTION: Renders the Playground component with distinct on example code and setup configuration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0080-distinct-on.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={distinctOn} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Implementation of Conditional Select in Kysely\nDESCRIPTION: This snippet demonstrates an incorrect approach to conditional selects in Kysely, where the query type doesn't change and results in the wrong return type.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0005-conditional-selects.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getPerson(id: number, withLastName: boolean) {\n  let query = db.selectFrom('person').select('first_name').where('id', '=', id)\n\n  if (withLastName) {\n    // ❌ The type of `query` doesn't change here\n    query = query.select('last_name')\n  }\n\n  // ❌ Wrong return type { first_name: string }\n  return await query.executeTakeFirstOrThrow()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Logging Levels in Kysely\nDESCRIPTION: Shows how to initialize Kysely with basic logging configuration using an array of log levels for queries and errors.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0012-logging.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = new Kysely({\n  ...\n  log: ['query', 'error']\n  ...\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Complex Values Example for Kysely\nDESCRIPTION: Import statement for the complex values example code that will be displayed in the Playground component.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0020-complex-values.mdx#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  complexValues\n} from './0020-complex-values'\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Kysely Example Server\nDESCRIPTION: Commands to install dependencies and run tests for the Kysely example server. Requires PostgreSQL running on port 5432 with default postgres user and no password.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/example/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Querying Person Data with Kysely in JavaScript\nDESCRIPTION: This code snippet demonstrates how to use Kysely to select specific fields from a 'person' table where the id is '1'. It uses the selectFrom, select, where, and executeTakeFirst methods to construct and execute the query.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/playground.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst person = await db\n  .selectFrom('person')\n  .select(['id', 'first_name'])\n  .where('id', '=', '1')\n  .executeTakeFirst()\n```\n\n----------------------------------------\n\nTITLE: Importing Single Row Update Example in Kysely\nDESCRIPTION: Imports the singleRow example code from a local file that demonstrates how to update a single row in a database table.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0010-single-row.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  singleRow\n} from './0010-single-row'\n```\n\n----------------------------------------\n\nTITLE: Fetching Nested Arrays with jsonArrayFrom in Kysely\nDESCRIPTION: This example demonstrates how to fetch a person's ID along with their associated pets as a nested array using the jsonArrayFrom helper. This approach allows fetching related data in a single query rather than making multiple database calls.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0110-nested-array.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, jsonArrayFrom } from 'kysely'\n```\n\n----------------------------------------\n\nTITLE: Importing Simple Where Clause Example in React\nDESCRIPTION: Imports the simpleWhereClause example from a local file, which likely contains a demonstration of Kysely's where clause functionality.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0010-simple-where-clause.mdx#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  simpleWhereClause\n} from './0010-simple-where-clause'\n```\n\n----------------------------------------\n\nTITLE: Implementing OR Conditions in Kysely Queries with TypeScript\nDESCRIPTION: Demonstrates two different ways to create OR expressions in Kysely SQL query builder. The example shows both using the or() method on the expression builder and the orWhere() method.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0040-or-where.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, sql } from 'kysely'\nimport { Database } from './types'\n\nexport const orWhere = async (db: Kysely<Database>) => {\n  // Method 1: using the `or` operator of the expression builder.\n  // This allows you to build complex nested expressions.\n  const people1 = await db\n    .selectFrom('person')\n    .selectAll()\n    .where(({ or, cmpr }) => {\n      return or([\n        cmpr('first_name', '=', 'Jennifer'),\n        cmpr('first_name', '=', 'Sylvester'),\n      ])\n    })\n    .execute()\n\n  console.log(people1)\n\n  // Method 2: using the `orWhere` method.\n  // This is often more readable when you just need to OR\n  // together simple expressions.\n  const people2 = await db\n    .selectFrom('person')\n    .selectAll()\n    .where('first_name', '=', 'Jennifer')\n    .orWhere('first_name', '=', 'Sylvester')\n    .execute()\n\n  console.log(people2)\n\n  // Both produce the same query:\n  // select * from \"person\" where \"first_name\" = $1 or \"first_name\" = $2\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Unordered Migrations in Kysely\nDESCRIPTION: Shows how to configure the Migrator to allow unordered migrations, useful for large teams working in parallel.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/migrations.mdx#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst migrator = new Migrator({\n  db,\n  provider: new FileMigrationProvider(...),\n  allowUnorderedMigrations: true\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground for Temporary Changes Table Example\nDESCRIPTION: This JSX snippet renders a Playground component to demonstrate the temporary changes table functionality in Kysely. It uses the imported temporaryChangesTable code and exampleSetup for configuration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/merge/0020-temporary-changes-table.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={temporaryChangesTable} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Running Kysely Development Environment\nDESCRIPTION: Commands for setting up the Kysely development environment, including installing dependencies, running Docker containers for database testing, and executing tests.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/CONTRIBUTING.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\ndocker compose up\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Importing Kysely Playground Components\nDESCRIPTION: Import statements for the Playground component and related setup code used for demonstrating complex selections in Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0050-complex-selections.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  complexSelections\n} from './0050-complex-selections'\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Strict Mode for Kysely\nDESCRIPTION: TypeScript configuration file (tsconfig.json) showing required compiler options for Kysely, specifically enabling strict mode for type safety.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/getting-started/_prerequisites.mdx#2025-04-16_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    // ...\n    \"compilerOptions\": {\n      // ...\n      \"strict\": true\n      // ...\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Query Examples\nDESCRIPTION: Code snippet showing imports for the Playground component and example setup used to demonstrate Kysely queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0050-conditional-where-calls.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  conditionalWhereCalls\n} from './0050-conditional-where-calls'\n```\n\n----------------------------------------\n\nTITLE: Playground Component Implementation\nDESCRIPTION: JSX implementation of the Playground component for demonstrating single row insertion.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0010-single-row.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={singleRow} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components in React/JSX\nDESCRIPTION: Importing the Playground and exampleSetup components from the project's component library to create an interactive code playground.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0020-where-in.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  whereIn\n} from './0020-where-in'\n```\n\n----------------------------------------\n\nTITLE: Import Statements with TypeScript\nDESCRIPTION: Import statements for the Playground component and example setup code for complex join demonstration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0030-complex-join.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  complexJoin\n} from './0030-complex-join'\n```\n\n----------------------------------------\n\nTITLE: Import Inner Join Example\nDESCRIPTION: Imports the simple inner join example code from a dedicated file.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0010-simple-inner-join.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  simpleInnerJoin\n} from './0010-simple-inner-join'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: This snippet imports necessary components for setting up an interactive code playground to demonstrate Kysely queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0070-distinct.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  distinct\n} from './0070-distinct'\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component in React\nDESCRIPTION: Renders a Playground component with the example code for the single row deletion. The component includes the example code and setup code for demonstration purposes.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/delete/0010-single-row.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={singleRow} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Components for Kysely Playground Demo\nDESCRIPTION: Imports the Playground and exampleSetup components from the project's components directory, along with the complexValues example code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0040-complex-values.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  complexValues\n} from './0040-complex-values'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Example\nDESCRIPTION: This snippet imports necessary components from the Playground module to set up an interactive code example for Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0030-object-filter.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  objectFilter\n} from './0030-object-filter'\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Simple Selects Example Playground\nDESCRIPTION: Renders a Playground component to demonstrate simple select queries with Kysely, including the example code and setup.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/cte/0010-simple-selects.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={simpleSelects} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Example\nDESCRIPTION: This snippet imports necessary components from the Playground module to set up an interactive code example for Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/merge/0020-temporary-changes-table.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  temporaryChangesTable\n} from './0020-temporary-changes-table'\n```\n\n----------------------------------------\n\nTITLE: Import Playground Components in TypeScript/JSX\nDESCRIPTION: Code snippet showing the import statements for Playground and example setup components from the project's source.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0010-single-row.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Rendering Playground Component in JSX\nDESCRIPTION: Renders the interactive playground component with source row existence example code and setup configuration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/merge/0010-source-row-existence.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={sourceRowExistence} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Demonstration\nDESCRIPTION: Imports the necessary components from the Playground to demonstrate Kysely query examples.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/cte/0010-simple-selects.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  simpleSelects\n} from './0010-simple-selects'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components in React/JSX\nDESCRIPTION: Imports the Playground component and related setup code for demonstrating Kysely examples.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0080-distinct-on.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  distinctOn\n} from './0080-distinct-on'\n```\n\n----------------------------------------\n\nTITLE: Render Playground Component\nDESCRIPTION: Renders a playground component that demonstrates the inner join functionality with example code and setup.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0010-simple-inner-join.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={simpleInnerJoin} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component with Data Modification Examples\nDESCRIPTION: JSX code that renders a Playground component to demonstrate insert, update, and delete operations in Kysely with an interactive code editor.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/cte/0020-inserts-updates-and-deletions.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={insertsUpdatesAndDeletions} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Transaction Example in JSX\nDESCRIPTION: Imports the Playground and exampleSetup components from the project's component library to display an interactive code example for Kysely transactions.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/transactions/0010-simple-transaction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  simpleTransaction\n} from './0010-simple-transaction'\n```\n\n----------------------------------------\n\nTITLE: Importing Aliased Inner Join Example in TypeScript\nDESCRIPTION: Imports the aliasedInnerJoin example code from the current directory, which will be displayed in the interactive playground component.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0020-aliased-inner-join.mdx#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  aliasedInnerJoin\n} from './0020-aliased-inner-join'\n```\n\n----------------------------------------\n\nTITLE: Component Import for Kysely Playground\nDESCRIPTION: Imports playground components and example setup for demonstrating Kysely functionality\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0020-multiple-rows.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  multipleRows\n} from './0020-multiple-rows'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: Imports the Playground and exampleSetup components from the project's component library to create an interactive code example environment.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0010-single-row.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Subquery Join Example in Kysely\nDESCRIPTION: Imports the subquery join example code that will be displayed in the Playground component.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0040-subquery-join.mdx#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  subqueryJoin\n} from './0040-subquery-join'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: Imports the Playground and exampleSetup components from the project's internal components directory to set up an interactive code playground.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0020-column-with-a-table.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components in TypeScript\nDESCRIPTION: Import statements for the Playground component and related setup code for demonstrating Kysely aliases.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0040-aliases.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  aliases\n} from './0040-aliases'\n```\n\n----------------------------------------\n\nTITLE: Playground Component Rendering\nDESCRIPTION: Renders a playground component with multiple rows example code and setup configuration\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0020-multiple-rows.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={multipleRows} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component\nDESCRIPTION: Creates a React component that renders an interactive playground for testing the column with table functionality in Kysely. It uses the imported example code and setup.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0020-column-with-a-table.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={columnWithATable} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Components for Playground in Kysely Documentation\nDESCRIPTION: Import statements for Playground component and example setup code used in the Kysely documentation site.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0090-all-columns.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  allColumns\n} from './0090-all-columns'\n```\n\n----------------------------------------\n\nTITLE: Import Single Row Example\nDESCRIPTION: Import statement for the single row insertion example code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/insert/0010-single-row.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  singleRow\n} from './0010-single-row'\n```\n\n----------------------------------------\n\nTITLE: Import Playground Components\nDESCRIPTION: Imports Playground and exampleSetup components from the project's components directory.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0010-simple-inner-join.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Column with Table Example for Kysely\nDESCRIPTION: Imports the columnWithATable example code from a dedicated example file for demonstration in the playground.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0020-column-with-a-table.mdx#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  columnWithATable\n} from './0020-column-with-a-table'\n```\n\n----------------------------------------\n\nTITLE: Importing Components for Kysely Playground Demonstration\nDESCRIPTION: Import statements for the Playground component and its setup code, used to demonstrate complex value examples in Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0020-complex-values.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Single Column Example Code\nDESCRIPTION: Imports the aSingleColumn example code that demonstrates how to select a single column using Kysely query builder.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0010-a-single-column.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  aSingleColumn\n} from './0010-a-single-column'\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Distinct Query Playground\nDESCRIPTION: This JSX code renders an interactive playground component for demonstrating distinct queries in Kysely. It uses pre-defined setup code and distinct query examples.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0070-distinct.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={distinct} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: Imports the Playground and exampleSetup components from the project's components directory, which are used to create an interactive code playground for Kysely query examples.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0030-multiple-columns.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components\nDESCRIPTION: Import statements for the Playground component and related setup code for demonstrating complex where clauses.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0060-complex-where-clause.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  complexWhereClause\n} from './0060-complex-where-clause'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components in TypeScript\nDESCRIPTION: Imports necessary components for setting up an interactive code playground with example code for source row existence operations.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/merge/0010-source-row-existence.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  sourceRowExistence\n} from './0010-source-row-existence'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground and Example Setup for Kysely in TypeScript\nDESCRIPTION: This snippet imports the necessary components for setting up a code playground and example for Kysely queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0100-all-columns-of-a-table.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  allColumnsOfATable\n} from './0100-all-columns-of-a-table'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components in TypeScript\nDESCRIPTION: Imports the Playground and exampleSetup components from the components directory, used to demonstrate code examples in an interactive environment.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0020-aliased-inner-join.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Rendering Playground Component in React/JSX\nDESCRIPTION: Rendering the interactive Playground component with the whereIn code example and setup configuration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0020-where-in.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={whereIn} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples in React\nDESCRIPTION: Sets up the imports for a React playground component to demonstrate Kysely query operations. This imports the necessary components from the project's components directory and the example code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/delete/0010-single-row.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  singleRow\n} from './0010-single-row'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground and Example Setup Components in React\nDESCRIPTION: Imports the Playground component and example setup functions from the project's components directory. These are used to create an interactive code example for demonstrating Kysely queries.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0010-simple-where-clause.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Inserts, Updates and Deletions Example for Kysely\nDESCRIPTION: Imports the code example that demonstrates insert, update, and delete operations in Kysely.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/cte/0020-inserts-updates-and-deletions.mdx#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  insertsUpdatesAndDeletions\n} from './0020-inserts-updates-and-deletions'\n```\n\n----------------------------------------\n\nTITLE: Rendering a Playground component for MySQL joins example\nDESCRIPTION: JSX code to render a Playground component that displays the MySQL joins example code and allows for interactive experimentation.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0030-my-sql-joins.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={mySqlJoins} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: Imports necessary components from the Playground module for demonstrating Kysely queries in an interactive environment.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/cte/0020-inserts-updates-and-deletions.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground components for MySQL joins example\nDESCRIPTION: Import statements for the Playground component and example code setup for the MySQL joins demonstration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/update/0030-my-sql-joins.mdx#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n\nimport {\n  mySqlJoins\n} from './0030-my-sql-joins'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components from Kysely\nDESCRIPTION: Imports for the Playground and exampleSetup components from the Kysely documentation framework, which are used to create an interactive code demo environment.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0010-a-single-column.mdx#2025-04-16_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Object Filter Playground\nDESCRIPTION: This code renders a Playground component to demonstrate the object filter functionality in Kysely. It uses the imported 'objectFilter' code and 'exampleSetup' for configuration.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0030-object-filter.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={objectFilter} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Playground Component Usage\nDESCRIPTION: JSX code showing how to implement the Playground component with complex where clause examples.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/where/0060-complex-where-clause.mdx#2025-04-16_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={complexWhereClause} setupCode={exampleSetup} />\n</div>\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Columns Example for Kysely\nDESCRIPTION: Imports the multipleColumns example code from a local file that demonstrates how to select multiple columns using Kysely query builder.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0030-multiple-columns.mdx#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  multipleColumns\n} from './0030-multiple-columns'\n```\n\n----------------------------------------\n\nTITLE: Importing Playground Components for Kysely Examples\nDESCRIPTION: Imports components for a code playground to demonstrate Kysely functionality. This includes the Playground component and example setup code.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/join/0040-subquery-join.mdx#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  Playground,\n  exampleSetup,\n} from '../../../src/components/Playground'\n```\n\n----------------------------------------\n\nTITLE: Simplify Type Helper Implementation\nDESCRIPTION: Example of a Simplify type helper that doesn't actually solve the deep type instantiation issue, as it maintains the complex underlying type structure.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0009-excessively-deep-types.md#2025-04-16_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Simplify<T> = { [K in keyof T]: T[K] } & {}\n```\n\n----------------------------------------\n\nTITLE: Rendering Kysely Playground Component\nDESCRIPTION: JSX code that renders the Playground component with the single column example code and setup configuration, creating an interactive demo for the user.\nSOURCE: https://github.com/kysely-org/kysely/blob/master/site/docs/examples/select/0010-a-single-column.mdx#2025-04-16_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<div style={{ marginBottom: '1em' }}>\n  <Playground code={aSingleColumn} setupCode={exampleSetup} />\n</div>\n```"
  }
]