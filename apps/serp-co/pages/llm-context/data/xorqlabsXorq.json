[
  {
    "owner": "xorq-labs",
    "repo": "xorq",
    "content": "TITLE: Implementing OpenAI Sentiment Analysis for HackerNews Comments in Python\nDESCRIPTION: Module for performing sentiment analysis on HackerNews comments using OpenAI's GPT-3.5-turbo. Includes retry logic, batch processing capability, and integration with the xorq framework. Handles sentiment classification into POSITIVE, NEGATIVE, or NEUTRAL categories.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nimport operator\nimport os\nfrom urllib.parse import unquote_plus\n\nimport pandas as pd\nimport toolz\nfrom openai import OpenAI\nfrom tenacity import (\n    retry,\n    stop_after_attempt,\n    wait_random_exponential,\n)\n\nimport xorq as xo\nfrom xorq.flight.utils import (\n    schema_concat,\n    schema_contains,\n)\n\n\n@functools.cache\ndef get_client():\n    client = OpenAI(\n        api_key=os.environ[\"OPENAI_API_KEY\"],\n    )\n    return client\n\n\nrequest_timeout = 3\n\n\n@functools.cache\ndef extract_sentiment(text):\n    @retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(3))\n    def completion_with_backoff(**kwargs):\n        return get_client().chat.completions.create(**kwargs)\n\n    if text == \"\":\n        return \"NEUTRAL\"\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": \"You are an AI language model trained to analyze and detect the sentiment of hackernews forum comments.\",\n        },\n        {\n            \"role\": \"user\",\n            \"content\": f\"Analyze the following hackernews comment and determine if the sentiment is: positive, negative or neutral. \"\n            f\"Return only a single word, either POSITIVE, NEGATIVE or NEUTRAL: {text}\",\n        },\n    ]\n    try:\n        response = completion_with_backoff(\n            model=\"gpt-3.5-turbo\",\n            messages=messages,\n            max_tokens=30,\n            temperature=0,\n            timeout=request_timeout,\n        )\n        return response.choices[0].message.content\n    except Exception as e:\n        return f\"ERROR: {e}\"\n\n\n@toolz.curry\ndef get_hackernews_sentiment_batch(df: pd.DataFrame, input_col, append_col):\n    import concurrent.futures\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        values = tuple(executor.map(toolz.compose(extract_sentiment, unquote_plus), df[input_col]))\n    return df.assign(**{append_col: values})\n\n\ninput_col = \"text\"\nappend_col = \"sentiment\"\nschema_requirement = xo.schema({input_col: \"str\"})\nschema_append = xo.schema({append_col: \"str\"})\nmaybe_schema_in = toolz.compose(schema_contains(schema_requirement), xo.schema)\nmaybe_schema_out = toolz.compose(\n    operator.methodcaller(\"to_pyarrow\"),\n    schema_concat(to_concat=schema_append),\n    xo.Schema.from_pyarrow,\n)\n\n\ndo_hackernews_sentiment_udxf = xo.expr.relations.flight_udxf(\n    process_df=get_hackernews_sentiment_batch(\n        input_col=input_col, append_col=append_col\n    ),\n    maybe_schema_in=maybe_schema_in,\n    maybe_schema_out=maybe_schema_out,\n    name=\"HackerNewsSentimentAnalyzer\",\n)\n```\n\n----------------------------------------\n\nTITLE: Installing xorq with DuckDB support using pip\nDESCRIPTION: Installs the xorq library with DuckDB backend support using pip. The 'duckdb' extra enables DuckDB functionality.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'xorq[duckdb]'\n```\n\n----------------------------------------\n\nTITLE: Implementing Sentiment Analysis Pipeline with XorQ, XGBoost and TF-IDF\nDESCRIPTION: This code demonstrates a complete sentiment analysis workflow using XorQ for data processing, TF-IDF for text feature extraction, and XGBoost for classification. It handles data loading, preprocessing, model training, prediction, and evaluation, showcasing XorQ's integration with scikit-learn and XGBoost. The pipeline analyzes Hacker News content and classifies sentiment into positive, neutral, or negative categories.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport toolz\nimport xgboost as xgb\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error, confusion_matrix\n\nimport xorq as xo\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_predict,\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\n\n# Import the helper modules\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n\n# Define model training and prediction functions\n@toolz.curry\ndef fit_xgboost_model(feature_df, target_series, seed=0):\n    xgb_r = xgb.XGBRegressor(\n        objective=\"multi:softmax\",\n        num_class=3,\n        eval_metric=mean_absolute_error,\n        max_depth=6,\n        n_estimators=10,\n        seed=seed,\n    )\n    X = pd.DataFrame(feature_df.squeeze().tolist())\n    xgb_r.fit(X, target_series)\n    return xgb_r\n\n@toolz.curry\ndef predict_xgboost_model(model, df):\n    return model.predict(df.squeeze().tolist())\n\n# Define column names\ntransform_col = \"title\"\nfeatures = (transformed_col,) = (f\"{transform_col}_transformed\",)\ntarget = \"sentiment_int\"\ntarget_predicted = f\"{target}_predicted\"\n\n# Create deferred operations\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\n\ndeferred_fit_predict_xgb = deferred_fit_predict(\n    target=target,\n    features=list(features),\n    fit=fit_xgboost_model,\n    predict=predict_xgboost_model,\n    return_type=dt.float32,\n)\n\n# Initialize the backend\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n\n# Load and process data\nname = \"hn-fetcher-input-large\"\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\nt = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n\n# Split into train and test sets\n(train_expr, test_expr) = t.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n\n# Apply TF-IDF transformation\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\n\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n\n# Train XGBoost model\n(deferred_xgb_model, xgb_udaf, deferred_xgb_predict) = deferred_fit_predict_xgb(\n    train_tfidf_transformed,\n    storage=storage,\n)\n\ntrain_xgb_predicted = (\n    train_tfidf_transformed\n    .into_backend(xo.connect())\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n\n# Make predictions on test data\ntest_xgb_predicted = (\n    test_expr\n    .mutate(**{transformed_col: deferred_tfidf_transform.on_expr})\n    .into_backend(xo.connect(), name=\"stable-name\")\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n\n# Execute and evaluate\ntrain_results = train_xgb_predicted.execute()\ntest_results = test_xgb_predicted.execute()\n\n# Calculate overall accuracy\ntrain_accuracy = (train_results[target_predicted] == train_results[target]).mean()\ntest_accuracy = (test_results[target_predicted] == test_results[target]).mean()\n\nprint(f\"Training Accuracy: {train_accuracy:.4f}\")\nprint(f\"Test Accuracy: {test_accuracy:.4f}\")\n```\n\n----------------------------------------\n\nTITLE: Installing xorq via pip\nDESCRIPTION: Command to install xorq using pip package manager.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq\n```\n\n----------------------------------------\n\nTITLE: Filtering Table Data in Python\nDESCRIPTION: Method to select rows from a table based on boolean predicates. Demonstrates filtering with multiple conditions and value counting.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.examples.penguins.fetch()\n>>> t.filter([t.species == \"Adelie\", t.body_mass_g > 3500]).sex.value_counts().drop_null(\n...     \"sex\"\n... ).order_by(\"sex\")\n```\n\n----------------------------------------\n\nTITLE: Using into_backend Operator for Multi-Engine Queries in xorq\nDESCRIPTION: Shows how to leverage xorq's multi-engine system to move data between different query engines. This example demonstrates joining data between PostgreSQL and DuckDB by moving a filtered table into PostgreSQL for an efficient semi-join operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.expr.relations import into_backend\n\n# Connect to different engines\npg = xo.postgres.connect_env()\ndb = xo.duckdb.connect()\n\n# Get tables from different sources\nbatting = pg.table(\"batting\")\n\n# Load awards_players into DuckDB\nawards_players = xo.examples.awards_players.fetch(backend=db)\n\n# Filter data in respective engines\nleft = batting.filter(batting.yearID == 2015)\nright = awards_players.filter(awards_players.lgID == \"NL\").drop(\"yearID\", \"lgID\")\n\n# Move right table into postgres for efficient join\nexpr = left.join(\n    into_backend(right, pg),\n    [\"playerID\"],\n    how=\"semi\"\n)[[\"yearID\", \"stint\"]]\n\n# Execute the multi-engine query\nresult = expr.execute()\n```\n\n----------------------------------------\n\nTITLE: Creating a complex ML pipeline with custom feature encoding and XGBoost\nDESCRIPTION: A comprehensive ML pipeline that demonstrates advanced xorq features including custom one-hot encoding, train-test splitting, and model training with XGBoost. Shows how to build reusable transformation functions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nimport xorq as xo\nimport xorq.selectors as s\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.expr.ml import deferred_fit_predict_sklearn, deferred_fit_transform, train_test_splits\nfrom sklearn.preprocessing import OneHotEncoder\nimport toolz\nimport pandas as pd\n\n# Create a fully deferred one-hot encoding transformation\ndef fit(\n    df,\n    cls=functools.partial(OneHotEncoder, handle_unknown=\"ignore\", drop=\"first\"),\n    features=slice(None),\n):\n    model = cls().fit(df[features])\n    return model\n\n@toolz.curry\ndef transform(model, df, features=slice(None)):\n    names = model.get_feature_names_out()\n    return pd.Series(\n        (\n            tuple({\"key\": key, \"value\": float(value)} for key, value in zip(names, row))\n            for row in model.transform(df[features]).toarray()\n        )\n    )\n\n# Define the return type for our encoding transformation\nreturn_type = dt.Array(dt.Struct({\"key\": str, \"value\": float}))\ndeferred_one_hot = deferred_fit_transform(\n    fit=fit,\n    transform=transform,\n    return_type=return_type,\n)\n\n# Create a XGBoost model class that can work with our encoded features\n# Full implementation in the GitHub repo in examples/bank_marketing.py\n\n# Function to build the complete pipeline\ndef make_pipeline_exprs(dataset_name, target_column, predicted_col):\n    ROW_NUMBER = \"row_number\"\n    ENCODED = \"encoded\"\n\n    # Create connection and load data\n    con = xo.connect()\n    \n    # Read CSV and create train/test split\n    train_table, test_table = (\n        expr.drop(ROW_NUMBER)\n        for expr in (\n            xo.deferred_read_csv(\n                path=xo.options.pins.get_path(dataset_name),\n                con=con,\n            )\n            .mutate(\n                **{\n                    target_column: (xo._[target_column] == \"yes\").cast(\"int\"),\n                    ROW_NUMBER: xo.row_number(),\n                }\n            )\n            .pipe(\n                train_test_splits,\n                unique_key=ROW_NUMBER,\n                test_sizes=[0.5, 0.5],\n                num_buckets=2,\n                random_seed=42,\n            )\n        )\n    )\n\n    # Apply one-hot encoding to string columns\n    deferred_encoder, encoder_udaf, transform_fn = deferred_one_hot(\n        train_table,\n        features=train_table.select(s.of_type(str)).columns,\n    )\n    \n    # Encode both train and test data\n    encoded_train, encoded_test = (\n        expr.mutate(**{ENCODED: transform_fn.on_expr(expr)})\n        for expr in (train_table, test_table)\n    )\n\n    # Get numeric features for model training\n    numeric_features = [\n        col\n        for col in encoded_train.select(s.numeric()).columns\n        if col != target_column and col != target_column + \"_yes\"\n    ]\n    \n    # Create and train the model\n    deferred_model, model_udaf, predict_fn = deferred_fit_predict_sklearn(\n        expr=encoded_train,\n        target=target_column,\n        features=numeric_features + [ENCODED],\n        cls=functools.partial(XGBoostModelExplodeEncoded, encoded_col=ENCODED),\n        return_type=dt.float64,\n        name=\"xgb_prediction\",\n    )\n    \n    # Apply predictions to test data\n    predictions = encoded_test.mutate(\n        **{predicted_col: predict_fn.on_expr(encoded_test)}\n    ).drop(ENCODED)\n\n    return {\n        \"encoded_train\": encoded_train,\n        \"encoded_test\": encoded_test,\n        \"predictions\": predictions,\n        \"encoder\": deferred_encoder,\n        \"model\": deferred_model,\n    }\n\n# Run the pipeline\ndataset_name = \"bank-marketing\"\ntarget_column = \"deposit\"\npredicted_col = \"predicted\"\nresults = make_pipeline_exprs(dataset_name, target_column, predicted_col)\n\n# Execute the pipeline and evaluate results\npredictions_df = results[\"predictions\"].execute()\n```\n\n----------------------------------------\n\nTITLE: Loading CSV Data in Python with letsql\nDESCRIPTION: Lazily loads CSV or TSV files using the letsql library, delegating to the current default backend (DuckDB by default). Supports loading from filesystem paths or URLs, with optional backend-specific parameters for customizing the import process.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nread_csv(sources, table_name=None, **kwargs)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> lines = '''a,b\n... 1,d\n... 2,\n... ,f\n... '''\n>>> with open(\"/tmp/lines.csv\", mode=\"w\") as f:\n...     nbytes = f.write(lines)  # nbytes is unused\n>>> t = letsql.read_csv(\"/tmp/lines.csv\")\n>>> t\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ d      │\n│     2 │ NULL   │\n│  NULL │ f      │\n└───────┴────────┘\n```\n\n----------------------------------------\n\nTITLE: Installing Required Python Packages\nDESCRIPTION: Installs the xorq framework and pandas library using pip package manager.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq pandas\n```\n\n----------------------------------------\n\nTITLE: Using the into_backend Operator for Multi-Engine Queries in xorq\nDESCRIPTION: This code demonstrates how to use xorq's `into_backend` operator to move data between PostgreSQL and DuckDB engines. It shows connecting to different engines, fetching tables, filtering data, and performing a join operation across engines with efficient data transfer.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/multi_engine.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.expr.relations import into_backend\n\n# Connect to different engines\npg = xo.postgres.connect_env()\ndb = xo.duckdb.connect()\n\n# Get tables from different sources\nbatting = pg.table(\"batting\")\n\n# Load awards_players into DuckDB\nawards_players = xo.examples.awards_players.fetch(backend=db)\n\n# Filter data in respective engines\nleft = batting.filter(batting.yearID == 2015)\nright = awards_players.filter(awards_players.lgID == \"NL\").drop(\"yearID\", \"lgID\")\n\n# Move right table into postgres for efficient join\nexpr = left.join(\n    into_backend(right, pg),\n    [\"playerID\"],\n    how=\"semi\"\n)[[\"yearID\", \"stint\"]]\n\n# Execute the multi-engine query\nresult = expr.execute()\n```\n\n----------------------------------------\n\nTITLE: Implementing ML Pipeline with XGBoost and TF-IDF in Python\nDESCRIPTION: A comprehensive implementation that includes data fetching from HackerNews, text vectorization using TF-IDF, sentiment analysis model training with XGBoost, and prediction serving via Apache Arrow Flight. The code demonstrates integration with xorq framework for data processing and caching, along with model training and evaluation splits.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport functools\n\nimport pandas as pd\nimport toolz\nimport xgboost as xgb\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error\n\nimport xorq as xo\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.caching import (\n    ParquetStorage,\n    SourceStorage,\n)\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_predict,\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\nfrom xorq.flight import (\n    FlightServer,\n    FlightUrl,\n)\n\n\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n\n\n@toolz.curry\ndef fit_xgboost_model(feature_df, target_series, seed=0):\n    xgb_r = xgb.XGBRegressor(\n        objective=\"multi:softmax\",\n        num_class=3,\n        eval_metric=mean_absolute_error,\n        max_depth=6,\n        # learning_rate=1,\n        n_estimators=10,\n        seed=seed,\n    )\n    X = pd.DataFrame(feature_df.squeeze().tolist())\n    xgb_r.fit(X, target_series)\n    return xgb_r\n\n\n@toolz.curry\ndef predict_xgboost_model(model, df):\n    return model.predict(df.squeeze().tolist())\n\n\ntransform_col = \"title\"\nfeatures = (transformed_col,) = (f\"{transform_col}_transformed\",)\ntarget = \"sentiment_int\"\ntarget_predicted = f\"{target}_predicted\"\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\ndeferred_fit_predict_xgb = deferred_fit_predict(\n    target=target,\n    features=list(features),\n    fit=fit_xgboost_model,\n    predict=predict_xgboost_model,\n    return_type=dt.float32,\n)\n\n\ndo_hackernews_fetcher_udxf = xo.expr.relations.flight_udxf(\n    process_df=m.get_hackernews_stories_batch,\n    # process_df=get_hackernews_stories_batch,\n    maybe_schema_in=m.schema_in.to_pyarrow(),\n    maybe_schema_out=m.schema_out.to_pyarrow(),\n    name=\"HackerNewsFetcher\",\n)\n\n\nname = \"hn-fetcher-input-large\"\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n# pg.postgres.connect_env().create_catalog(\"caching\")\npg = xo.postgres.connect_env(database=\"caching\")\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    # .pipe(do_hackernews_fetcher_udxf)\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\nt = (\n    raw_expr\n    # most stories have a tile, but few have text\n    # df.groupby(\"type\").apply(lambda t: t.notnull().sum().div(len(t)))\n    .filter(xo._.text.notnull())\n    .cache(storage=SourceStorage(pg))\n    # .limit(100)\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    # commenting out this cache changes the hash of the subsequent hash\n    .cache(storage=SourceStorage(pg))\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n    # .mutate(sentiment_int=xo._.sentiment.cases({\"POSITIVE\": 1, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()).cast(int))\n)\n(train_expr, test_expr) = t.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n\n\n# fit-transform\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n# fit-predict\n(deferred_xgb_model, xgb_udaf, deferred_xgb_predict) = deferred_fit_predict_xgb(\n    train_tfidf_transformed,\n    storage=storage,\n)\ntrain_xgb_predicted = (\n    train_tfidf_transformed\n    # if i add into backend here, i don't get ArrowNotImplementedError: Unsupported cast\n    .into_backend(xo.connect()).mutate(\n        **{target_predicted: deferred_xgb_predict.on_expr}\n    )\n)\n\n\n# now we can define test pathway\ntest_xgb_predicted = (\n    test_expr.mutate(**{transformed_col: deferred_tfidf_transform.on_expr})\n    # if i add into backend here, i don't get ArrowNotImplementedError: Unsupported cast\n    # why is this stable-name required?\n    .into_backend(xo.connect())\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n\n\nx = train_xgb_predicted.execute()\ny = test_xgb_predicted.execute()\nprint(x.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\nprint(y.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\n\n\n# fetch live and predict\nz = (\n    xo.memtable([{\"maxitem\": 43346282, \"n\": 1000}])\n    .pipe(m.do_hackernews_fetcher_udxf)\n    .filter(xo._.text.notnull())\n    .mutate(\n        **{\n            \"sentiment\": xo.literal(None).cast(str),\n            \"sentiment_int\": xo.literal(None).cast(int),\n        }\n    )\n    #     .mutate(**{transformed_col: deferred_tfidf_transform.on_expr})\n)\n\n\ntransform_port = 8915\npredict_port = 8916\n(transform_server, transform_do_exchange) = xo.expr.relations.flight_serve(\n    # why is this stable-name required?\n    test_expr.into_backend(xo.connect()).mutate(\n        **{transformed_col: deferred_tfidf_transform.on_expr}\n    ),\n    make_server=functools.partial(FlightServer, FlightUrl(port=transform_port)),\n)\n(predict_server, predict_do_exchange) = xo.expr.relations.flight_serve(\n    test_xgb_predicted,\n    make_server=functools.partial(FlightServer, FlightUrl(port=predict_port)),\n)\n(transform_command, predict_command) = (\n    do_exchange.args[1] for do_exchange in (transform_do_exchange, predict_do_exchange)\n)\n# issue: do_exchange here takes expr, externally it takes RecordBatchReader\nout = predict_do_exchange(xo.register(transform_do_exchange(z), \"t\")).read_pandas()\n\n\nexpected_transform_command = \"execute-unbound-expr-f4961c805729fe38a39304b1317f4f20\"\nexpected_predict_commnd = \"execute-unbound-expr-dcfac288264dbae089b63d7a9b7d95d8\"\nassert (transform_server.flight_url.port, transform_command) == (\n    transform_port,\n    expected_transform_command,\n), (transform_command, expected_transform_command)\nassert (predict_server.flight_url.port, predict_command) == (\n    predict_port,\n    expected_predict_commnd,\n), (predict_command, expected_predict_commnd)\n```\n\n----------------------------------------\n\nTITLE: Defining Schema Objects in Python\nDESCRIPTION: Validates and creates a Schema object that defines the structure of a table. Supports various input formats including name-type pairs, separate lists for names and types, or a dictionary mapping names to types.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nschema(pairs=None, names=None, types=None)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from letsql import schema\n>>> sc = schema([(\"foo\", \"string\"), (\"bar\", \"int64\"), (\"baz\", \"boolean\")])\n>>> sc = schema(names=[\"foo\", \"bar\", \"baz\"], types=[\"string\", \"int64\", \"boolean\"])\n>>> sc = schema(dict(foo=\"string\")) # no-op\n```\n\n----------------------------------------\n\nTITLE: Implementing Source Storage Caching in xorq\nDESCRIPTION: Demonstrates how to use SourceStorage in xorq to cache query results. This example connects to a PostgreSQL database, registers a table, and caches filtered data using the source backend, which automatically invalidates when upstream data changes.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.caching import SourceStorage\n\n# Connect to source database\npg = xo.postgres.connect_env()\ncon = xo.connect()  # empty connection\n\n# Create source storage\nstorage = SourceStorage(source=con)\n\n# Register table from postgres and cache it\nbatting = pg.table(\"batting\")\n\n# Cache the filtered data in the source backend\ncached = (\n    batting.filter(batting.yearID == 2015)\n    .cache(storage=storage)  # cache expression\n)\n\n# Execute the query - results will be cached\nresult = xo.execute(cached)\n```\n\n----------------------------------------\n\nTITLE: Building a simple ML pipeline with xorq for bank deposit prediction\nDESCRIPTION: A basic ML pipeline that demonstrates loading data, splitting into train/test sets, training a RandomForest model, and making predictions. Uses deferred execution pattern that xorq is built on.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.common.utils.defer_utils import deferred_read_csv\nfrom xorq.expr.ml import deferred_fit_predict_sklearn, train_test_splits\n\ncon = xo.connect()\n\ndataset_name = \"bank-marketing\"\ncsv_path = xo.options.pins.get_path(dataset_name)\nbank_data = deferred_read_csv(path=csv_path, con=con)\n\nbank_data = bank_data.mutate(\n    row_number=xo.row_number(),\n    deposit=(bank_data[\"deposit\"] == \"yes\").cast(\"int\")\n)\n\ntrain, test = train_test_splits(\n    bank_data, \n    unique_key=\"row_number\", \n    test_sizes=[0.7, 0.3],\n    random_seed=42\n)\n\nfrom sklearn.ensemble import RandomForestClassifier\n\ndeferred_model, model_udaf, predict_fn = deferred_fit_predict_sklearn(\n    expr=train,\n    target=\"deposit\",\n    features=[\"age\", \"balance\", \"duration\"],\n    cls=RandomForestClassifier,\n    return_type=dt.float64,\n    name=\"rf_prediction\"\n)\n\nresults = test.mutate(prediction=predict_fn.on_expr(test))\n\nresults.select([\"deposit\", \"prediction\"]).execute()\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet data into xorq\nDESCRIPTION: Reads a Parquet file into xorq using the main connection. The table parameter specifies how this table will be referenced inside the connection backend.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Read a parquet file using xorq\npath = xo.config.options.pins.get_path(\"batting\")\nbatting = con.read_parquet(path, table=\"batting\")\n```\n\n----------------------------------------\n\nTITLE: Composing ML Pipeline Expression with xorq\nDESCRIPTION: Combines all steps into a single xorq expression, creating an end-to-end ML pipeline. Includes TF-IDF transformation, XGBoost model training, and prediction on test data.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/pipelines_as_expressions.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Fit and transform with TF-IDF\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\n\n# Apply the transformation to training data\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n\n# Fit XGBoost and get prediction function\n(deferred_xgb_model, xgb_udaf, deferred_xgb_predict) = deferred_fit_predict_xgb(\n    train_tfidf_transformed,\n    storage=storage,\n)\n\n# Apply transformation and prediction to test data\ntest_xgb_predicted = (\n    test_expr.mutate(**{transformed_col: deferred_tfidf_transform.on_expr})\n    .into_backend(xo.connect())\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n```\n\n----------------------------------------\n\nTITLE: Performing basic filtering and selection operations in xorq\nDESCRIPTION: Demonstrates filtering data for records after 2010 and selecting specific columns. The operations are lazy until execute() is called, which returns a pandas DataFrame.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Filtering and selection\nrecent_batting = (\n    batting[batting.yearID > 2010]  # filter for recent years\n    .select(['playerID', 'yearID', 'teamID', 'G', 'AB', 'R', 'H'])  # select specific columns\n)\n\n# Execute to see results\nrecent_batting.execute()\n```\n\n----------------------------------------\n\nTITLE: Implementing caching in xorq using ParquetStorage\nDESCRIPTION: Demonstrates how to implement caching in xorq using ParquetStorage. This optimizes performance by storing results that can be reused in subsequent executions without recomputing.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom xorq.caching import ParquetStorage\n\n# Create a storage for cached data\ncache_storage = ParquetStorage(source=con, path=Path.cwd())\n\n# Cache the results\ncached_awards = player_awards.cache(storage=cache_storage)\n\n# The next execution will use the cached data\ncached_awards.execute()\n```\n\n----------------------------------------\n\nTITLE: Implementing Scalar UDF with Model Integration in xorq\nDESCRIPTION: Demonstrates how to create a scalar user-defined function (UDF) in xorq that integrates with a machine learning model. This example loads a QuickGrove model and applies it to diamonds dataset to generate predictions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.expr.ml import make_quickgrove_udf\nfrom pathlib import Path\nfrom xorq import _\n\nt = xo.examples.diamonds.fetch()\n\nmodel_path = Path(xo.options.pins.get_path(\"diamonds-model\"))\nmodel = make_quickgrove_udf(model_path, model_name=\"diamonds_model\")\nexpr = t.mutate(pred=model.on_expr).filter(_.carat < 1).select(_.pred).execute()\n```\n\n----------------------------------------\n\nTITLE: Common Patterns for Creating and Using Profiles\nDESCRIPTION: Demonstrates typical workflows for creating, saving, loading, and using profiles to establish database connections.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Create profile\nprofile = Profile(\n    con_name=\"postgres\",\n    kwargs_tuple=(\n        (\"host\", \"${POSTGRES_HOST}\"),\n        (\"port\", 5432),\n        (\"database\", \"postgres\"),\n        (\"user\", \"${POSTGRES_USER}\"),\n        (\"password\", \"${POSTGRES_PASSWORD}\"),\n    ),\n)\n\n# Save profile\nprofile.save(alias=\"postgres_example\", clobber=True)\n\n# Load profile\nloaded_profile = Profile.load(\"postgres_example\")\n\n# Create connection\nconnection = loaded_profile.get_con()\n\n# Use connection\ntables = connection.list_tables()\n```\n\n----------------------------------------\n\nTITLE: Implementing Expr Scalar UDF for XGBoost Model Training and Prediction\nDESCRIPTION: This complex snippet demonstrates how to use Expr Scalar UDFs in xorq to train an XGBoost model on Lending Club data, serialize it, and use it for predictions within the query execution context.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/udxf.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport toolz\nimport xgboost as xgb\nimport pickle\n\nimport xorq as xo\nimport xorq.expr.udf as udf\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.expr.udf import make_pandas_expr_udf, wrap_model\n\n# Define constants for our example\nROWNUM = \"rownum\"\n\n# The lending club dataset contains loan data with features like:\n# - emp_length: employment length in years\n# - dti: debt-to-income ratio\n# - annual_inc: annual income\n# - loan_amnt: loan amount\n# - fico_range_high: FICO credit score\n# - cr_age_days: credit history age in days\n# - event_occurred: binary target variable indicating loan default\nfeatures = (\n    \"emp_length\",\n    \"dti\",\n    \"annual_inc\",\n    \"loan_amnt\",\n    \"fico_range_high\",\n    \"cr_age_days\",\n)\ntarget = \"event_occurred\"\nmodel_key = \"model\"\nprediction_key = \"predicted\"\n\n\n# Training function that returns a pickled model\n@toolz.curry\ndef train_xgboost_model(df, features, target, seed=0):\n    param = {\"max_depth\": 4, \"eta\": 1, \"objective\": \"binary:logistic\", \"seed\": seed}\n    num_round = 10\n\n    # Sort by rownum if present (for reproducibility)\n    if ROWNUM in df:\n        df = df.sort_values(ROWNUM, ignore_index=True)\n\n    # Train the model\n    X = df[list(features)]\n    y = df[target]\n    dtrain = xgb.DMatrix(X, y)\n    bst = xgb.train(param, dtrain, num_boost_round=num_round)\n\n    # Return pickled model\n    return pickle.dumps({model_key: bst})\n\n\n# Prediction function that uses the model\n@toolz.curry\ndef predict_xgboost_model(df, model, features):\n    # Unwrap model from kwargs\n    return model.predict(xgb.DMatrix(df[list(features)]))\n\n\n# Set up the connection and data\ncon = xo.connect()\nt = con.read_parquet(xo.config.options.pins.get_path(\"lending-club\"))\ntrain, test = xo.train_test_splits(t, unique_key=ROWNUM, test_sizes=0.7)\n\n# Create training UDAF that returns a serialized model\nmodel_udaf = udf.agg.pandas_df(\n    fn=train_xgboost_model(features=features, target=target),\n    schema=t[features + (target,)].schema(),\n    return_type=dt.binary,  # Binary type for serialized model\n    name=model_key,\n)\n\n# Create prediction UDF that uses the model\npredict_expr_udf = make_pandas_expr_udf(\n    computed_kwargs_expr=model_udaf.on_expr(train),  # Pass training data here\n    fn=predict_xgboost_model(features=features),  # Function that makes predictions\n    schema=t[features].schema(),  # Schema of input features\n    return_type=dt.dtype(\"float32\"),  # Return type of predictions\n    name=prediction_key,\n    post_process_fn=pickle.loads,  # Function to deserialize model\n)\n\n# Apply the UDF to make predictions\nexpr = test.mutate(prediction=predict_expr_udf.on_expr(test).name(prediction_key))\n\n# Execute and get results\nexpr.execute()\n```\n\n----------------------------------------\n\nTITLE: Accessing Previous Row Values in Python using Ibis\nDESCRIPTION: This function returns the row located at a specified offset before the current row. It allows setting a default value if no row exists at the given offset. This is useful for comparing current row values with previous row values in a dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nlag(offset=None, default=None)\n```\n\n----------------------------------------\n\nTITLE: Creating a UDF and Building a Data Pipeline with xorq\nDESCRIPTION: Example Python script that demonstrates defining a custom UDF in xorq, connecting to the embedded engine, and building a data pipeline. The example shows how to create a function that checks if a URL appears within a title field.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# your_pipeline.py\nimport xorq as xo\nimport xorq.expr.datatypes as dt\n\n@xo.udf.make_pandas_udf(\n    schema=xo.schema({\"title\": str, \"url\": str}),\n    return_type=dt.bool,\n    name=\"url_in_title\",\n)\ndef url_in_title(df):\n    return df.apply(\n        lambda s: (s.url or \"\") in (s.title or \"\"),\n        axis=1,\n    )\n\n# Connect to xorq's embedded engine\ncon = xo.connect()\n\n# Reference to the parquet file\nname = \"hn-data-small.parquet\"\n\nexpr = xo.deferred_read_parquet(\n    con,\n    xo.options.pins.get_path(name),\n    name,\n).mutate(**{\"url_in_title\": url_in_title.on_expr})\n\nexpr.execute().head()\n```\n\n----------------------------------------\n\nTITLE: Evaluating Model Performance\nDESCRIPTION: Executes the pipeline and evaluates model performance using accuracy metrics for both training and test sets.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Execute the training and test predictions\ntrain_results = train_xgb_predicted.execute()\ntest_results = test_xgb_predicted.execute()\n\n# Print model performance statistics by sentiment class\nprint(\"Training Set Performance:\")\nprint(train_results.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\n\nprint(\"\\nTest Set Performance:\")\nprint(test_results.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\n\n# Calculate overall accuracy\ntrain_accuracy = (train_results[target_predicted] == train_results[target]).mean()\ntest_accuracy = (test_results[target_predicted] == test_results[target]).mean()\n\nprint(f\"\\nTraining Accuracy: {train_accuracy:.4f}\")\nprint(f\"Test Accuracy: {test_accuracy:.4f}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Scalar UDF with ML Model Integration in xorq\nDESCRIPTION: This snippet demonstrates how to create and use a scalar UDF that integrates a machine learning model. It loads a pre-trained model, converts it to a UDF, and applies it to a dataset to generate predictions, which are then filtered and selected.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/user_defined_functions.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.expr.ml import make_quickgrove_udf\nfrom pathlib import Path\nfrom xorq import _\n\nt = xo.examples.diamonds.fetch()\n\nmodel_path = Path(xo.options.pins.get_path(\"diamonds-model\"))\nmodel = make_quickgrove_udf(model_path, model_name=\"diamonds_model\")\nexpr = t.mutate(pred=model.on_expr).filter(_.carat < 1).select(_.pred).execute()\n```\n\n----------------------------------------\n\nTITLE: Creating User-Defined Aggregate Functions (UDAF) in xorq\nDESCRIPTION: This example shows how to define and implement a custom aggregate function in xorq using the pandas dataframe API. The function 'sum_sum' computes the sum of sums of specified columns, is registered with appropriate schema and return type, and then applied in a group-by aggregation operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/user_defined_functions.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.expr import udf\nimport xorq.vendor.ibis.expr.datatypes as dt\n\nalltypes = xo.examples.functional_alltypes.fetch()\ncols = (by, _) = [\"year\", \"month\"]\nname = \"sum_sum\"\n\n@udf.agg.pandas_df(\n    schema=alltypes[cols].schema(),\n    return_type=dt.int64(),\n    name=name,\n)\ndef sum_sum(df):\n    return df.sum().sum()\n\nactual = (\n    alltypes.group_by(by)\n    .agg(sum_sum(*(alltypes[c] for c in cols)).name(name))\n    .execute()\n)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of train_test_splits Function in Python\nDESCRIPTION: A practical example demonstrating how to use the train_test_splits function with a memory table. The example shows creating three splits with sizes of 20%, 30%, and 50% of the original data, using a small number of buckets and a fixed random seed for reproducibility.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/ml-api.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> table = ls.memtable({\"key\": range(100), \"value\": range(100,200)})\n>>> unique_key = \"key\"\n>>> test_sizes = [0.2, 0.3, 0.5]\n>>> splits = ls.train_test_splits(table, unique_key, test_sizes, num_buckets=10, random_seed=42)\n>>> for i, split_table in enumerate(splits):\n...     print(f\"Split {i+1} size: {split_table.count().execute()}\")\n...     print(split_table.execute())\nSplit 1 size: 20\nSplit 2 size: 30\nSplit 3 size: 50\n```\n\n----------------------------------------\n\nTITLE: Implementing Scalar UDF in xorq for Column-wise Minimum\nDESCRIPTION: This snippet demonstrates how to create and apply a scalar UDF in xorq that computes the minimum value across columns for each row in a DataFrame.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/udxf.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.expr.udf import make_pandas_udf\nimport xorq.vendor.ibis.expr.datatypes as dt\n\n# Create sample data\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\ncon = xo.connect()\nt = con.register(df, \"t\")\n\n# Define UDF that takes minimum value across columns\nmy_least = lambda df: df.min(axis=1)\nschema = t.select([\"a\", \"b\"]).schema()\nudf = make_pandas_udf(my_least, schema, dt.int64(), name=\"my_least\")\n\n# Apply UDF\nresult = t.mutate(min_val=udf.on_expr(t)).execute()\n```\n\n----------------------------------------\n\nTITLE: Creating a deferred model with xorq using deferred_fit_predict\nDESCRIPTION: Example showing how to use xorq's deferred_fit_predict function to create a model that trains on demand, specifying the training data, target variable, features, model class, and prediction column name.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndeferred_model, model_udaf, predict = deferred_fit_predict(\n    expr=train_data,          # Training data\n    target=\"target_column\",   # Target variable\n    features=feature_list,    # List of features\n    cls=ModelClass,           # Scikit-learn compatible model class\n    name=\"prediction_column\"  # Name for prediction column\n)\n```\n\n----------------------------------------\n\nTITLE: Viewing Results of TF-IDF Transformation\nDESCRIPTION: Sample output showing the results of the TF-IDF transformation. Displays the number of training samples, an example title, vector dimensions, and the first few feature values from the transformed data.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nNumber of training samples: 381\nOriginal title example: Show HN: Xenoeye – high performance network traffic analyzer (OSS, *flow-based)\nVector dimensions: 1489\nFirst 5 feature values: [np.float64(0.0), np.float64(0.0), np.float64(0.0), np.float64(0.0), np.float64(0.0)]\n```\n\n----------------------------------------\n\nTITLE: Implementing Text Processing and TF-IDF Transformation with XORQ\nDESCRIPTION: Comprehensive example showing data loading, text processing, sentiment analysis, TF-IDF transformation, and train-test splitting using XORQ framework. The code demonstrates integration with scikit-learn's TfidfVectorizer and includes data caching using ParquetStorage.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nimport xorq.expr.datatypes as dt\n\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\n\n# Import the helper modules we used in Part 1\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\ntransform_col = \"title\"\ntransformed_col = f\"{transform_col}_transformed\"\n\n# Create a deferred TF-IDF transformer\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n\n# Define the input dataset name\nname = \"hn-fetcher-input-large\"\n\n# Load the data\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\n# Process the data as we did in Part 1\nprocessed_expr = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n(train_expr, test_expr) = processed_expr.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\ntest_tfidf_transformed = test_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\ntrain_transformed = train_tfidf_transformed.execute()\nprint(f\"Number of training samples: {len(train_transformed)}\")\nprint(f\"Original title example: {train_transformed['title'].iloc[0]}\")\nprint(f\"Vector dimensions: {len(train_transformed[transformed_col].iloc[0])}\")\n\n# You can also examine specific feature values if needed\nprint(f\"First 5 feature values: {train_transformed[transformed_col].iloc[0][:5]}\")\n```\n\n----------------------------------------\n\nTITLE: Creating Abstract Tables in Python\nDESCRIPTION: Creates a table literal or an abstract table without data backing it. Tables can be associated with a schema, name, catalog, and database to specify their structure and hierarchical location.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntable(schema=None, name=None, catalog=None, database=None)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = False\n>>> t = letsql.table(schema=dict(a=\"int\", b=\"string\"), name=\"t\")\n>>> t\nUnboundTable: t\n  a int64\n  b string\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = False\n>>> t = letsql.table(schema=dict(a=\"int\"), name=\"t\", catalog=\"cat\", database=\"db\")\n>>> t\nUnboundTable: cat.db.t\n  a int64\n```\n\n----------------------------------------\n\nTITLE: Implementing UDWF in xorq for Exponential Smoothing\nDESCRIPTION: This snippet demonstrates how to create a User-Defined Window Function (UDWF) in xorq for exponential smoothing, and how to apply it to a dataset with a window specification.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/udxf.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.expr.udf import pyarrow_udwf\nfrom xorq.vendor import ibis\nimport pyarrow as pa\n\n# Define UDWF using the decorator approach\n@pyarrow_udwf(\n    schema=ibis.schema({\"a\": float}),\n    return_type=ibis.dtype(float),\n    alpha=0.9,\n)\ndef exp_smooth(self, values: list[pa.Array], num_rows: int) -> pa.Array:\n    results = []\n    curr_value = 0.0\n    values = values[0]\n    for idx in range(num_rows):\n        if idx == 0:\n            curr_value = values[idx].as_py()\n        else:\n            curr_value = values[idx].as_py() * self.alpha + curr_value * (1.0 - self.alpha)\n        results.append(curr_value)\n    return pa.array(results)\n\n# Register data\ncon = xo.connect()\nt = con.register(\n    pa.Table.from_batches([\n        pa.RecordBatch.from_arrays(\n            [pa.array([1.0, 2.0, 3.0, 4.0, 5.0])],\n            names=[\"a\"]\n        )\n    ]),\n    table_name=\"t\"\n)\n\n# Apply UDWF with window specification\nresult = t.mutate(\n    smoothed=exp_smooth.on_expr(t).over(ibis.window())\n).execute()\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Value in Column using Python and Ibis\nDESCRIPTION: This function returns the maximum value of a column. It allows optional filtering to consider only specific values. The function can be used to find the overall maximum or the maximum value that satisfies certain conditions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nmax(where=None)\n```\n\n----------------------------------------\n\nTITLE: Moving data between backends and joining tables in xorq\nDESCRIPTION: Demonstrates how to move data from PostgreSQL to xorq's backend using into_backend(), then perform a left join between tables from different sources. This uses a PyArrow RecordBatchReader as an intermediate format.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Read a table from Postgres and move it to xorq's backend\nawards = pg.table(\"awards_players\").into_backend(con, \"awards\")  # bring into xorq backend\n\n# Perform a join between the two tables\nplayer_awards = (\n    recent_batting.join(\n        awards,\n        ['playerID', 'yearID'],  # join keys\n        how='left'  # left join\n    )\n    .select([\n        'playerID',\n        'yearID',\n        'teamID',\n        'awardID',\n        'G',\n        'AB',\n        'H'\n    ])\n)\n\nplayer_awards.execute()\n```\n\n----------------------------------------\n\nTITLE: Creating User Defined Aggregate Functions in xorq\nDESCRIPTION: Shows how to implement a User Defined Aggregate Function (UDAF) in xorq. This example defines a custom aggregation function 'sum_sum' that calculates the sum of sums across multiple columns in a group by operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.expr import udf\nimport xorq.vendor.ibis.expr.datatypes as dt\n\nalltypes = xo.examples.functional_alltypes.fetch()\ncols = (by, _) = [\"year\", \"month\"]\nname = \"sum_sum\"\n\n@udf.agg.pandas_df(\n    schema=alltypes[cols].schema(),\n    return_type=dt.int64(),\n    name=name,\n)\ndef sum_sum(df):\n    return df.sum().sum()\n\nactual = (\n    alltypes.group_by(by)\n    .agg(sum_sum(*(alltypes[c] for c in cols)).name(name))\n    .execute()\n)\n```\n\n----------------------------------------\n\nTITLE: Building a Deferred TF-IDF Pipeline in xorq\nDESCRIPTION: Creates a deferred TF-IDF transformation pipeline by fitting the model on training data. Returns a model reference, a User-Defined Aggregate Function, and a transformation function that can be applied to multiple datasets.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Create the deferred TF-IDF model, transform operation\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\n\n# Apply the transformation to the training data\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n```\n\n----------------------------------------\n\nTITLE: Caching Table Results for Improved Performance\nDESCRIPTION: The cache method stores computation results to improve performance on subsequent executions. It supports various storage strategies including in-memory caching, Parquet files on disk, or database tables, with automatic cache invalidation based on the chosen strategy.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ncache(storage=None)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> from letsql.caching import ParquetStorage\n>>> from pathlib import Path\n>>> pg = ls.postgres.connect_examples()\n>>> con = ls.connect()\n>>> storage = ParquetStorage(source=con, path=Path.cwd())\n>>> alltypes = pg.table(\"functional_alltypes\")\n>>> cached = (alltypes\n...     .select(alltypes.smallint_col, alltypes.int_col, alltypes.float_col)\n...     .cache(storage=storage))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from letsql.caching import SourceStorage\n>>> from letsql import _\n>>> ddb = ls.duckdb.connect()\n>>> path = ls.config.options.pins.get_path(\"batting\")\n>>> right = (ddb.read_parquet(path, table_name=\"batting\")\n...          .filter(_.yearID == 2014)\n...          .pipe(con.register, table_name=\"ddb-batting\"))\n>>> left = (pg.table(\"batting\")\n...         .filter(_.yearID == 2015)\n...         .pipe(con.register, table_name=\"pg-batting\"))\n>>> # Cache the joined result\n>>> expr = left.join(right, \"playerID\").cache(SourceStorage(source=pg))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> cached = alltypes.cache(storage=storage)\n>>> expr = cached.filter([\n...     cached.float_col > 0,\n...     cached.smallint_col > 4,\n...     cached.int_col < cached.float_col * 2\n... ])\n```\n\n----------------------------------------\n\nTITLE: Implementing UDAF in xorq for Custom Mean Calculation\nDESCRIPTION: This snippet shows how to create a User-Defined Aggregation Function (UDAF) in xorq using PyArrow to compute a custom mean, and how to apply it in a group-by operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/udxf.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.expr.udf import agg\nimport pyarrow.compute as pc\n\n# Sample UDAF using PyArrow\n@agg.pyarrow\ndef my_mean(arr: dt.float64) -> dt.float64:\n    return pc.mean(arr)\n\n# Using UDAF in groupby\nt = con.table(\"batting\")\nresult = t.group_by(\"yearID\").agg(mean_games=my_mean(t.G)).execute()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Value from Column in Python using Ibis\nDESCRIPTION: This function returns the last value of a column. It provides options for filtering, ordering, and including null values. The function can be used to retrieve the last value based on specified conditions or the overall last value of the column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nlast(where=None, order_by=None, include_null=False)\n```\n\n----------------------------------------\n\nTITLE: Building Sentiment Analysis Pipeline in Xorq\nDESCRIPTION: Implementation of a sentiment analysis pipeline using pre-trained models, including data processing and Arrow Flight integration\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/getting_started/quickstart.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\nimport pickle\n\nimport toolz\nimport pandas as pd\nimport xgboost as xgb\n\nimport xorq as xo\nimport xorq.expr.datatypes as dt\nfrom xorq.common.utils.import_utils import import_python\n\n# Define paths to models and data\nTFIDF_MODEL_PATH = pathlib.Path(xo.options.pins.get_path(\"hn_tfidf_fitted_model\"))\nXGB_MODEL_PATH = pathlib.Path(xo.options.pins.get_path(\"hn_sentiment_reg\"))\nHACKERNEWS_DATA_NAME = \"hn-fetcher-input-small\"\n\n# Import HackerNews library from pinned path\nhackernews_lib = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\n\n# Load pre-trained models\ndef load_models():\n    transformer = pickle.loads(TFIDF_MODEL_PATH.read_bytes())\n    xgb_model = xgb.XGBRegressor()\n    xgb_model.load_model(XGB_MODEL_PATH)\n    return transformer, xgb_model\n\ndef predict_sentiment(titles):\n    transformer, xgb_model = load_models()\n    return xgb_model.predict(transformer.transform(titles))\n\n# Create a pandas UDF for sentiment prediction\n@xo.udf.make_pandas_udf(\n    schema=xo.schema({\"title\": str}),\n    return_type=dt.float64,\n    name=\"title_transformed\",\n)\ndef transform_predict(df):\n    return predict_sentiment(df[\"title\"])\n\n# Define a pipeline\nconnection = xo.connect()\npipeline = (\n    xo.deferred_read_parquet(\n        connection,\n        xo.options.pins.get_path(HACKERNEWS_DATA_NAME),\n        HACKERNEWS_DATA_NAME,\n    )\n    .pipe(hackernews_lib.do_hackernews_fetcher_udxf)\n    .select(xo._.title)\n    .mutate(sentiment_score=transform_predict.on_expr)\n)\n\n# Execute the pipeline\nresults = pipeline.execute()\n```\n\n----------------------------------------\n\nTITLE: Building Complete Data Processing Pipeline\nDESCRIPTION: Implements the full data pipeline including fetching stories, filtering, sentiment analysis, and data transformation using xorq operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nraw_expr = (\n    xo.deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\nt = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Splitting Data into Train and Test Sets\nDESCRIPTION: Implements train-test split using xorq's train_test_splits function with a 60-40 split ratio.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Split into train (60%) and test (40%) sets\n(train_expr, test_expr) = t.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n```\n\n----------------------------------------\n\nTITLE: Making Predictions on Test Data\nDESCRIPTION: Applies TF-IDF transformation and XGBoost prediction to test data with backend connection handling.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Apply TF-IDF transformation and XGBoost prediction to test data\ntrain_xgb_predicted = (\n    train_tfidf_transformed\n    .into_backend(xo.connect()) # extra into backend (see warning below)\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Approximate Median in Ibis Python\nDESCRIPTION: This example demonstrates how to use the approx_median() method to calculate an approximate median value for a column in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.approx_median()\n┌────────┐\n│ 4030.0 │\n└────────┘\n>>> t.body_mass_g.approx_median(where=t.species == \"Chinstrap\")\n┌────────┐\n│ 3700.0 │\n└────────┘\n```\n\n----------------------------------------\n\nTITLE: Loading Parquet Data in Python with letsql\nDESCRIPTION: Lazily loads Parquet files using the letsql library, delegating to the current default backend (DuckDB by default). Supports loading from filesystem paths or URLs, with optional backend-specific parameters for customizing the import process.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nread_parquet(sources, table_name=None, **kwargs)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> import pandas as pd\n>>> letsql.options.interactive = True\n>>> df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": list(\"ghi\")})\n>>> df\n   a  b\n0  1  g\n1  2  h\n2  3  i\n>>> df.to_parquet(\"/tmp/data.parquet\")\n>>> t = letsql.read_parquet(\"/tmp/data.parquet\")\n>>> t\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ g      │\n│     2 │ h      │\n│     3 │ i      │\n└───────┴────────┘\n```\n\n----------------------------------------\n\nTITLE: Setting Up Deferred Operations for TF-IDF and XGBoost\nDESCRIPTION: Configures deferred operations for TF-IDF transformation and XGBoost prediction using xorq's deferred pipeline system.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Define column names\ntransform_col = \"title\"\nfeatures = (transformed_col,) = (f\"{transform_col}_transformed\",)\ntarget = \"sentiment_int\"\ntarget_predicted = f\"{target}_predicted\"\n\n# Create a deferred TF-IDF transformer (same as in Part 2)\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\n\n# Create a deferred XGBoost model\ndeferred_fit_predict_xgb = deferred_fit_predict(\n    target=target,\n    features=list(features),\n    fit=fit_xgboost_model,\n    predict=predict_xgboost_model,\n    return_type=dt.float32,\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Window UDF for Time Series Analysis in xorq\nDESCRIPTION: This example demonstrates creating a window user-defined function (UDWF) for exponential smoothing in time series analysis. The function processes values sequentially with a smoothing factor alpha, and is applied over a window of data. The code includes both the function definition and its application to a dataframe.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/user_defined_functions.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pyarrow as pa\nfrom xorq.expr.udf import pyarrow_udwf\nfrom xorq.vendor import ibis\n\n\n@pyarrow_udwf(\n    schema=ibis.schema({\"a\": float}),\n    return_type=ibis.dtype(float),\n    alpha=0.9,\n)\ndef exp_smooth(self, values: list[pa.Array], num_rows: int) -> pa.Array:\n    results = []\n    curr_value = 0.0\n    values = values[0]\n    for idx in range(num_rows):\n        if idx == 0:\n            curr_value = values[idx].as_py()\n        else:\n            curr_value = values[idx].as_py() * self.alpha + curr_value * (\n                1.0 - self.alpha\n            )\n        results.append(curr_value)\n\n    return pa.array(results)\n\n\ndf = pd.DataFrame(\n    [\n        (0, 7, \"A\"),\n        (1, 4, \"A\"),\n        (2, 3, \"A\"),\n        (3, 8, \"A\"),\n        (4, 9, \"B\"),\n        (5, 1, \"B\"),\n        (6, 6, \"B\"),\n    ],\n    columns=[\"a\", \"b\", \"c\"],\n)\n\nt = xo.register(df, table_name=\"t\")\n\nexpr = t.select(\n    t.a,\n    udwf=exp_smooth.on_expr(t).over(ibis.window()),\n).order_by(t.a)\n\nresult = expr.execute()\n```\n\n----------------------------------------\n\nTITLE: Creating a Deferred TF-IDF Transformer in xorq\nDESCRIPTION: Defines a deferred TF-IDF transformer using xorq's deferred operations. This creates a transformation that will be applied later in the pipeline, transforming the 'title' column into a numerical vector representation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Define which column we want to transform\ntransform_col = \"title\"\ntransformed_col = f\"{transform_col}_transformed\"\n\n# Create a deferred TF-IDF transformer\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Distinct Table View for Self-Referencing Operations\nDESCRIPTION: The view method creates a new table expression distinct from the current one, which is useful for self-referencing operations like self-joins when you need to refer to the same table multiple times.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nview()\n```\n\n----------------------------------------\n\nTITLE: Training TF-IDF and XGBoost Models\nDESCRIPTION: Code for training the TF-IDF transformer and XGBoost model on the training dataset. Includes fitting models, transforming data, and evaluating model performance on both training and test datasets.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Fit and transform with TF-IDF\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n\n# Fit and predict with XGBoost\n(deferred_xgb_model, xgb_udaf, deferred_xgb_predict) = deferred_fit_predict_xgb(\n    train_tfidf_transformed,\n    storage=storage,\n)\ntrain_xgb_predicted = (\n    train_tfidf_transformed\n    .into_backend(xo.connect()).mutate(\n        **{target_predicted: deferred_xgb_predict.on_expr}\n    )\n)\n\n# Define test pathway\ntest_xgb_predicted = (\n    test_expr.mutate(**{transformed_col: deferred_tfidf_transform.on_expr})\n    .into_backend(xo.connect())\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr}\n    )\n)\n\n# Evaluate models\nx = train_xgb_predicted.execute()\ny = test_xgb_predicted.execute()\nprint(x.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\nprint(y.groupby(\"sentiment_int\").sentiment_int_predicted.describe().T)\n```\n\n----------------------------------------\n\nTITLE: Initializing Ibis Table and Performing Type Conversions in Python\nDESCRIPTION: This snippet demonstrates how to create an Ibis table from a dictionary, display its contents, and perform type conversions using try_cast() method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> from letsql.vendor.ibis import _\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"numbers\": [1, 2, 3, 4], \"strings\": [\"1.0\", \"2\", \"hello\", \"world\"]})\n>>> t\n┏━━━━━━━━━┳━━━━━━━━━┓\n┃ numbers ┃ strings ┃\n┡━━━━━━━━━╇━━━━━━━━━┩\n│ int64   │ string  │\n├─────────┼─────────┤\n│       1 │ 1.0     │\n│       2 │ 2       │\n│       3 │ hello   │\n│       4 │ world   │\n└─────────┴─────────┘\n>>> t = t.mutate(numbers_to_strings=_.numbers.try_cast(\"string\"))\n>>> t = t.mutate(strings_to_numbers=_.strings.try_cast(\"int\"))\n>>> t\n┏━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓\n┃ numbers ┃ strings ┃ numbers_to_strings ┃ strings_to_numbers ┃\n┡━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩\n│ int64   │ string  │ string             │ int64              │\n├─────────┼─────────┼────────────────────┼────────────────────┤\n│       1 │ 1.0     │ 1                  │                  1 │\n│       2 │ 2       │ 2                  │                  2 │\n│       3 │ hello   │ 3                  │               NULL │\n│       4 │ world   │ 4                  │               NULL │\n└─────────┴─────────┴────────────────────┴────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Implementing Coalesce Function for Value Expressions\nDESCRIPTION: Method to return the first non-null value from a series of arguments, handling null values in expressions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncoalesce(*args)\n```\n\n----------------------------------------\n\nTITLE: Defining XGBoost Model Training and Prediction Functions\nDESCRIPTION: Implementation of functions for training XGBoost models and making predictions, using toolz.curry for function currying.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@toolz.curry\ndef fit_xgboost_model(feature_df, target_series, seed=0):\n    xgb_r = xgb.XGBRegressor(\n        eval_metric=mean_absolute_error,\n        max_depth=6,\n        seed=seed,\n    )\n    X = pd.DataFrame(feature_df.squeeze().tolist())\n    xgb_r.fit(X, target_series)\n    return xgb_r\n\n@toolz.curry\ndef predict_xgboost_model(model, df):\n    return model.predict(df.squeeze().tolist())\n```\n\n----------------------------------------\n\nTITLE: Training XGBoost Model and Making Predictions\nDESCRIPTION: Trains the XGBoost model using the transformed training data and sets up prediction operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create the deferred XGBoost model and prediction operation\n(deferred_xgb_model, xgb_udaf, deferred_xgb_predict) = deferred_fit_predict_xgb(\n    train_tfidf_transformed,\n    storage=storage,\n)\n\n# Apply predictions to the training data\ntrain_xgb_predicted = (\n    train_tfidf_transformed\n    .mutate(**{target_predicted: deferred_xgb_predict.on_expr})\n)\n```\n\n----------------------------------------\n\nTITLE: XGBoost Model Training and Prediction Functions in xorq\nDESCRIPTION: Defines custom functions for training an XGBoost model and making predictions. These functions are used to create a deferred predictor in the xorq pipeline.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/pipelines_as_expressions.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@toolz.curry\ndef fit_xgboost_model(feature_df, target_series, seed=0):\n    xgb_r = xgb.XGBRegressor(\n        objective=\"reg:squarederror\",\n        eval_metric=mean_absolute_error,\n        n_estimators=20,\n        seed=seed,\n    )\n    X = pd.DataFrame(feature_df.squeeze().tolist())\n    xgb_r.fit(X, target_series)\n    return xgb_r\n\n@toolz.curry\ndef predict_xgboost_model(model, df):\n    return model.predict(df.squeeze().tolist())\n\n# Create deferred predictor using our functions\ndeferred_fit_predict_xgb = deferred_fit_predict(\n    target=target,\n    features=list(features),\n    fit=fit_xgboost_model,\n    predict=predict_xgboost_model,\n    return_type=dt.float32,\n)\n```\n\n----------------------------------------\n\nTITLE: Ordering Table Data in Python\nDESCRIPTION: Method to sort table data by one or more expressions, similar to pandas.DataFrame.sort_values(). Supports multiple sorting criteria.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\norder_by(*by)\n```\n\n----------------------------------------\n\nTITLE: Distinct Row Operations in Python\nDESCRIPTION: Demonstrates various ways to handle duplicate rows in tables including keeping first/last occurrences and filtering on specific columns. Shows integration with selectors for more complex distinct operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> import letsql.examples as ex\n>>> import letsql.selectors as s\n>>> ls.options.interactive = True\n>>> t = ex.penguins.fetch()\n>>> t[['species', 'island']].distinct().order_by(s.all())\n>>> t.distinct(on=['species', 'island'], keep='first').order_by(s.all())\n>>> t.distinct(on=['species', 'island'], keep='last').order_by(s.all())\n>>> expr = t.distinct(on=['species', 'island', 'year', 'bill_length_mm'], keep=None)\n>>> t.distinct(on=~s.numeric())\n```\n\n----------------------------------------\n\nTITLE: Using train_test_splits function for ML data preparation\nDESCRIPTION: Example of how to use xorq's train_test_splits function to create train and test datasets with specified proportions, identifying rows with a unique key and using a random seed for reproducibility.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntrain, test = train_test_splits(\n    data, \n    unique_key=\"id\",          # Column to uniquely identify rows\n    test_sizes=[0.7, 0.3],    # Split proportions\n    num_buckets=2,            # Number of splits\n    random_seed=42            # For reproducibility\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Train/Test Splits for Ibis Tables in Python\nDESCRIPTION: A utility function that creates multiple train/test splits of an Ibis table based on a unique key and specified test sizes. The function uses a hashing approach to deterministically split data into buckets, ensuring consistent partitioning for machine learning workflows.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/ml-api.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntrain_test_splits(\n    table,\n    unique_key,\n    test_sizes,\n    num_buckets=10000,\n    random_seed=None,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining HackerNews Fetcher UDXF\nDESCRIPTION: Creates a User-Defined Exchanger Function for fetching HackerNews stories with specified schema.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndo_hackernews_fetcher_udxf = xo.expr.relations.flight_udxf(\n    process_df=m.get_hackernews_stories_batch,\n    maybe_schema_in=m.schema_in.to_pyarrow(),\n    maybe_schema_out=m.schema_out.to_pyarrow(),\n    name=\"HackerNewsFetcher\",\n)\n```\n\n----------------------------------------\n\nTITLE: Text Vectorization with TF-IDF in xorq Pipeline\nDESCRIPTION: Defines a deferred TF-IDF vectorization step for processing story titles. Uses scikit-learn's TfidfVectorizer with xorq's deferred execution approach.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/pipelines_as_expressions.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntransform_col = \"title\"\nfeatures = (transformed_col,) = (f\"{transform_col}_transformed\",)\ntarget = \"descendants\"\ntarget_predicted = f\"{target}_predicted\"\n\n# Create deferred transformer for TF-IDF\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\n```\n\n----------------------------------------\n\nTITLE: Computing Absolute Value in Ibis\nDESCRIPTION: Method to return the absolute value of a numeric column. The example demonstrates applying the abs() function to a column containing negative and positive values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nabs()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n>>> t.values.abs()\n┏━━━━━━━━━━━━━┓\n┃ Abs(values) ┃\n┡━━━━━━━━━━━━━┩\n│ int64       │\n├─────────────┤\n│           1 │\n│           2 │\n│           3 │\n│           4 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Using Conditional ifelse Function in LetSQL\nDESCRIPTION: This snippet demonstrates the usage of the ifelse function to create a conditional expression in LetSQL. It shows how to apply a condition to a column and return different values based on the condition.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"condition\": [True, False, True, None]})\n>>> letsql.ifelse(t.condition, \"yes\", \"no\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ IfElse(condition, 'yes', 'no') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                         │\n├────────────────────────────────┤\n│ yes                            │\n│ no                             │\n│ yes                            │\n│ no                             │\n└────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Defining XGBoost Model Functions\nDESCRIPTION: Functions for training and predicting with XGBoost models. These functions handle the fitting of a multi-class XGBoost regressor and making predictions using the trained model.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@toolz.curry\ndef fit_xgboost_model(feature_df, target_series, seed=0):\n    xgb_r = xgb.XGBRegressor(\n        objective=\"multi:softmax\",\n        num_class=3,\n        eval_metric=mean_absolute_error,\n        max_depth=6,\n        n_estimators=10,\n        seed=seed,\n    )\n    X = pd.DataFrame(feature_df.squeeze().tolist())\n    xgb_r.fit(X, target_series)\n    return xgb_r\n\n@toolz.curry\ndef predict_xgboost_model(model, df):\n    return model.predict(df.squeeze().tolist())\n```\n\n----------------------------------------\n\nTITLE: Loading and Processing Dataset for Training\nDESCRIPTION: Code for loading and processing the Hacker News dataset. This includes setting up storage, loading data from Parquet, applying transformations, and splitting into train and test sets.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nname = \"hn-fetcher-input-large\"\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\npg = xo.postgres.connect_env(database=\"caching\")\n\n# Load and process the data\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\nt = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .cache(storage=SourceStorage(pg))\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=SourceStorage(pg))\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n\n# Split into train and test sets\n(train_expr, test_expr) = t.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n```\n\n----------------------------------------\n\nTITLE: Using Selectors for Column-Based Sorting\nDESCRIPTION: Demonstrates using selectors to sort by columns matching specific criteria. This example sorts by columns that start with 'year' using the startswith selector on a penguins dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql.selectors as s\n>>> penguins = ls.examples.penguins.fetch()\n>>> penguins[[\"year\", \"island\"]].value_counts().order_by(s.startswith(\"year\"))\n┏━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓\n┃ year  ┃ island    ┃ year_island_count ┃\n┡━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩\n│ int64 │ string    │ int64             │\n├───────┼───────────┼───────────────────┤\n│  2007 │ Torgersen │                20 │\n│  2007 │ Biscoe    │                44 │\n│  2007 │ Dream     │                46 │\n│  2008 │ Torgersen │                16 │\n│  2008 │ Dream     │                34 │\n│  2008 │ Biscoe    │                64 │\n│  2009 │ Torgersen │                16 │\n│  2009 │ Dream     │                44 │\n│  2009 │ Biscoe    │                60 │\n└───────┴───────────┴───────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Executing and Examining TF-IDF Transformed Data\nDESCRIPTION: Executes the transformation pipeline on the training data and examines the results. Displays the number of samples, an example of the original text, the dimensions of the transformed vectors, and sample feature values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Execute the transformation on the training data\ntrain_transformed = train_tfidf_transformed.execute()\n\n# Check the dimensions and structure of the transformed data\nprint(f\"Number of training samples: {len(train_transformed)}\")\nprint(f\"Original title example: {train_transformed['title'].iloc[0]}\")\nprint(f\"Vector dimensions: {len(train_transformed[transformed_col].iloc[0])}\")\n\n# You can also examine specific feature values if needed\nprint(f\"First 5 feature values: {train_transformed[transformed_col].iloc[0][:5]}\")\n```\n\n----------------------------------------\n\nTITLE: Aggregating Values into an Array with Collection Method\nDESCRIPTION: Method to aggregate expression elements into an array with optional filtering, ordering, and null handling parameters.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncollect(where=None, order_by=None, include_null=False)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Operation in LetSQL\nDESCRIPTION: This snippet shows how to use the union function to combine two tables in LetSQL. It demonstrates both the default behavior (union all) and the distinct union operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t1 = letsql.memtable({\"a\": [1, 2]})\n>>> t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t2 = letsql.memtable({\"a\": [2, 3]})\n>>> t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n>>> letsql.union(t1, t2)  # union all by default\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n│     2 │\n│     3 │\n└───────┘\n>>> letsql.union(t1, t2, distinct=True).order_by(\"a\")\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n│     3 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Implementing Arrow Flight Microservices in Xorq\nDESCRIPTION: Example of creating data microservices using Arrow Flight, including server setup and client testing\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/getting_started/quickstart.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.flight import FlightServer, FlightUrl\nfrom xorq.flight.exchanger import make_udxf\n# Define schemas for the service\nschema_in = xo.schema({\"title\": str})\nschema_out = xo.schema({\"sentiment_score\": dt.double})\n\n# Flight server function\ndef sentiment_analysis(df: pd.DataFrame):\n    scores = predict_sentiment(df[\"title\"])\n    return pd.DataFrame({\"sentiment_score\": [float(scores)]})\n\n# Create the UDXF for Flight server\nsentiment_udxf = make_udxf(\n    sentiment_analysis, \n    schema_in.to_pyarrow(), \n    schema_out.to_pyarrow()\n)\n\n# Start the Flight server with our exchanger\nflight_port = 8815\nflight_server = FlightServer(\n    FlightUrl(port=flight_port), \n    exchangers=[sentiment_udxf]\n)\nflight_server.serve()\n```\n\nLANGUAGE: python\nCODE:\n```\n# Test the service\nclient = flight_server.client\ndo_sentiment = toolz.curry(client.do_exchange, sentiment_udxf.command)\n\ndef test_flight_service():\n    test_data = xo.memtable(\n        {\"title\": [\"This is an amazing HackerNews post\"]}, \n        schema=schema_in\n    )\n    result = do_sentiment(test_data.to_pyarrow_batches())\n    res = result[1].read_pandas()\n    print(\"Flight service test result:\\n\", res)\n\nprint(\"Testing Flight service...\")\ntest_flight_service()\n```\n\n----------------------------------------\n\nTITLE: Leveraging DuckDB for aggregations in xorq\nDESCRIPTION: Shows how to move data to DuckDB for specific operations like grouping and aggregation. This demonstrates xorq's ability to leverage the strengths of different database engines for particular tasks.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Move data to DuckDB for additional processing\nddb_awards = player_awards.into_backend(ddb, \"ddb_awards\")\n\n# Perform DuckDB-specific operations\nddb_summary = (\n    ddb_awards.group_by(['yearID', 'awardID'])\n    .agg([\n        _.count().name('player_count'),\n        _.G.mean().name('avg_games'),\n        _.H.mean().name('avg_hits'),\n    ])\n    .order_by(['yearID', 'awardID'])\n)\n\nprint(\"Award summary from DuckDB:\")\nddb_summary.execute()\n```\n\n----------------------------------------\n\nTITLE: Sorting with Expression-Based Keys for Case-Insensitive Sorting\nDESCRIPTION: Demonstrates using expressions as sort keys by performing a case-insensitive sort on column 'b' using the lower() function. This ignores letter case differences when sorting.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> t.order_by(_.b.lower())\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     3 │ a      │     4 │\n│     2 │ B      │     6 │\n│     1 │ c      │     5 │\n│     3 │ D      │     7 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Loading and Processing HackerNews Data in xorq\nDESCRIPTION: Initializes the xorq backend connection and loads the labeled HackerNews data from the previous tutorial. The pipeline filters for valid text entries, applies sentiment analysis, and converts sentiment labels to numerical values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the backend\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n\n# Define the input dataset name\nname = \"hn-fetcher-input-large\"\n\n# Load the data\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\n# Process the data as we did in Part 1\nprocessed_expr = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Checking for Value Membership with isin in Python\nDESCRIPTION: Demonstrates the isin method for checking whether values in an expression are contained within a set of values. Shows multiple examples with literal sequences, derived expressions, and comparing against columns from different tables.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nisin(values)\n```\n\n----------------------------------------\n\nTITLE: Using isin with Column from Different Table in Python\nDESCRIPTION: Example showing how to check if values in a column are contained in a column from a different table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> t2 = ibis.memtable({\"x\": [99, 2, 99]})\n>>> t.a.isin(t2.x)\n┏━━━━━━━━━━━━━━━┓\n┃ InSubquery(a) ┃\n┡━━━━━━━━━━━━━━━┩\n│ boolean       │\n├───────────────┤\n│ False         │\n│ True          │\n│ False         │\n└───────────────┘\n```\n\n----------------------------------------\n\nTITLE: Initializing Ibis Table Class\nDESCRIPTION: Core Table class constructor for creating immutable and lazy dataframes, analogous to SQL tables or pandas DataFrames.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nTable(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Feature Engineering and Prediction Pipeline\nDESCRIPTION: Configuration for the TF-IDF transformation and XGBoost prediction pipeline. Defines column names and creates deferred operations for TF-IDF vectorization and XGBoost model prediction.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntransform_col = \"title\"\nfeatures = (transformed_col,) = (f\"{transform_col}_transformed\",)\ntarget = \"sentiment_int\"\ntarget_predicted = f\"{target}_predicted\"\n\ndeferred_fit_transform_tfidf = deferred_fit_transform_series_sklearn(\n    col=transform_col,\n    cls=TfidfVectorizer,\n    return_type=dt.Array(dt.float64),\n)\n\ndeferred_fit_predict_xgb = deferred_fit_predict(\n    target=target,\n    features=list(features),\n    fit=fit_xgboost_model,\n    predict=predict_xgboost_model,\n    return_type=dt.float32,\n)\n```\n\n----------------------------------------\n\nTITLE: Regex Replace in Ibis: Normalizing Whitespace\nDESCRIPTION: Illustrates using re_replace to normalize all whitespace sequences to a single space.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> s.re_replace(r\"\\s+\", \" \")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexReplace(s, '\\\\s+', ' ') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ abc                          │\n│ bac                          │\n│ bca                          │\n│ this has multi whitespace    │\n└──────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Initializing Environment and Fetching Data with xorq\nDESCRIPTION: Sets up the environment, imports necessary libraries, and fetches live data from Hacker News. Uses deferred operations for lazy evaluation and pipeline optimization.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/pipelines_as_expressions.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport toolz\nimport xgboost as xgb\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error\n\nimport xorq as xo\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_predict,\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\n\n# Import helper module with UDFs\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\n\n# Set up connection and storage for caching\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n\n# Load data and split into train/test sets\ntrain_expr, test_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(\"hn-fetcher-input-small.parquet\"),\n        \"fetcher-input\",\n    )\n    .pipe(m.do_hackernews_fetcher_udxf, inner_name=\"inner-named-flight-udxf\")\n    .pipe(\n        train_test_splits,\n        unique_key=\"id\",\n        test_sizes=(0.9, 0.1),\n        random_seed=0,\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Table Difference Operations in Python\nDESCRIPTION: Shows how to compute set differences between tables. The example demonstrates creating two tables and finding rows present in the first table but not in the second.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t1 = ls.memtable({\"a\": [1, 2]})\n>>> t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t2 = ls.memtable({\"a\": [2, 3]})\n>>> t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n>>> t1.difference(t2)\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Floor Function in Python using Ibis\nDESCRIPTION: Shows how to compute the floor function for values in a numeric column using Ibis. The example creates a memory table with sample values and applies the floor function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n>>> t.values.floor()\n┏━━━━━━━━━━━━━━━┓\n┃ Floor(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ int64         │\n├───────────────┤\n│             1 │\n│             1 │\n│             2 │\n│             2 │\n│             3 │\n└───────────────┘\n```\n\n----------------------------------------\n\nTITLE: Implementing HackerNews Data Fetcher in Python\nDESCRIPTION: Module for fetching stories from HackerNews API with disk caching support. Includes functions for retrieving individual items, max item ID, and batch processing of stories. Uses Pandas for data handling and implements schema validation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport functools\nimport json\nimport pathlib\n\nimport pandas as pd\nimport requests\nimport toolz\n\nimport xorq as xo\n\n\nbase_api_url = \"https://hacker-news.firebaseio.com/v0\"\n\n\n@toolz.curry\ndef simple_disk_cache(f, cache_dir, serde):\n    cache_dir.mkdir(parents=True, exist_ok=True)\n\n    def wrapped(**kwargs):\n        name = \",\".join(f\"{key}={value}\" for key, value in kwargs.items())\n        path = cache_dir.joinpath(name)\n        if path.exists():\n            value = serde.loads(path.read_text())\n        else:\n            value = f(**kwargs)\n            path.write_text(serde.dumps(value))\n        return value\n\n    return wrapped\n\n\ndef get_json(url):\n    resp = requests.get(url)\n    resp.raise_for_status()\n    return resp.json()\n\n\n@simple_disk_cache(cache_dir=pathlib.Path(\"./hackernews-items\"), serde=json)\ndef get_hackernews_item(*, item_id):\n    return get_json(f\"{base_api_url}/item/{item_id}.json\")\n\n\n@functools.cache\ndef get_hackernews_maxitem():\n    return get_json(f\"{base_api_url}/maxitem.json\")\n\n\ndef get_hackernews_stories(maxitem, n):\n    gen = (\n        toolz.excepts(requests.exceptions.SSLError, get_hackernews_item)(\n            item_id=item_id\n        )\n        for item_id in range(maxitem - n, maxitem)\n    )\n    gen = filter(None, gen)\n    df = pd.DataFrame(gen).reindex(columns=schema_out)\n    return df\n\n\n@toolz.curry\ndef get_hackernews_stories_batch(df, filter=slice(None)):\n    series = df.apply(lambda row: get_hackernews_stories(**row), axis=1)\n    return pd.concat(series.values, ignore_index=True).loc[filter].reset_index(drop=True)\n\n\nschema_in = xo.schema({\"maxitem\": int, \"n\": int})\nschema_out = xo.schema(\n    {\n        \"by\": \"string\",\n        \"id\": \"int64\",\n        \"parent\": \"float64\",\n        \"text\": \"string\",\n        \"time\": \"int64\",\n        \"type\": \"string\",\n        \"kids\": \"array<int64>\",\n        \"descendants\": \"float64\",\n        \"score\": \"float64\",\n        \"title\": \"string\",\n        \"url\": \"string\",\n    }\n)\n\n\ndo_hackernews_fetcher_udxf = xo.expr.relations.flight_udxf(\n    process_df=get_hackernews_stories_batch(\n        filter=lambda t: t.type.eq(\"story\") & t.title.notnull()\n    ),\n    maybe_schema_in=schema_in.to_pyarrow(),\n    maybe_schema_out=schema_out.to_pyarrow(),\n    name=\"HackerNewsFetcher\",\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up connections to multiple backends in xorq\nDESCRIPTION: Creates connections to xorq's main backend, DuckDB, and PostgreSQL. Imports the underscore accessor which is used for column references in queries.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq import _  # import the underscore accessor for column reference\n\n# Create connections to different backends\ncon = xo.connect()  # xorq's main connection\nddb = xo.duckdb.connect()  # DuckDB connection\npg = xo.postgres.connect_examples()  # Postgres connection\n```\n\n----------------------------------------\n\nTITLE: Implementing SourceStorage Caching in xorq\nDESCRIPTION: This code demonstrates how to use SourceStorage in xorq to cache query results. It connects to a PostgreSQL database, creates a source storage instance, registers a table, and caches filtered data. The cache is stored in the source backend and will automatically invalidate when upstream data changes.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/caching.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.caching import SourceStorage\n\n# Connect to source database\npg = xo.postgres.connect_env()\ncon = xo.connect()  # empty connection\n\n# Create source storage\nstorage = SourceStorage(source=con)\n\n# Register table from postgres and cache it\nbatting = pg.table(\"batting\")\n\n# Cache the filtered data in the source backend\ncached = (\n    batting.filter(batting.yearID == 2015)\n    .cache(storage=storage)  # cache expression\n)\n\n# Execute the query - results will be cached\nresult = xo.execute(cached)\n```\n\n----------------------------------------\n\nTITLE: Find in Set Operation in Ibis Python\nDESCRIPTION: Demonstrates finding first occurrence of strings within a list using find_in_set() method. No string can contain commas.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> table = ibis.table(dict(string_col=\"string\"))\n>>> result = table.string_col.find_in_set([\"a\", \"b\"])\n```\n\n----------------------------------------\n\nTITLE: Initializing Backend and Storage\nDESCRIPTION: Sets up the xorq backend connection and Parquet storage configuration.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nname = \"hn-fetcher-input-large\" # or use hn-fercher-input-small to avoid downloading all data\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n```\n\n----------------------------------------\n\nTITLE: Safely Converting Data Types with try_cast in Python\nDESCRIPTION: Method for attempting to cast an expression to a different data type, returning NULL or NaN for values that cannot be cast.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ntry_cast(target_type)\n```\n\n----------------------------------------\n\nTITLE: Computing Logarithm with Custom Base in Python using Ibis\nDESCRIPTION: Demonstrates how to compute logarithms with a custom base for values in a numeric column using Ibis. The example shows both natural logarithm and logarithm with base 10.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from math import e\n>>> t = ibis.memtable({\"values\": [e, e**2, e**3]})\n>>> t.values.log()\n┏━━━━━━━━━━━━━┓\n┃ Log(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│         1.0 │\n│         2.0 │\n│         3.0 │\n└─────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [10, 100, 1000]})\n>>> t.values.log(base=10)\n┏━━━━━━━━━━━━━━━━━┓\n┃ Log(values, 10) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│             1.0 │\n│             2.0 │\n│             3.0 │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Running SQL Queries on Ibis Table in Python\nDESCRIPTION: Shows how to use the 'sql' method to execute SQL queries against an Ibis Table object. Includes examples of basic SQL queries and combining SQL with Ibis expressions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> from letsql import _\n>>> ls.options.interactive = True\n>>> t = ls.examples.penguins.fetch(table_name=\"penguins\")\n>>> expr = t.sql(\n...     \"\"\"\n...     SELECT island, mean(bill_length_mm) AS avg_bill_length\n...     FROM penguins\n...     GROUP BY 1\n...     ORDER BY 2 DESC\n...     \"\"\"\n... )\n>>> expr\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓\n┃ island    ┃ avg_bill_length ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩\n│ string    │ float64         │\n├───────────┼─────────────────┤\n│ Biscoe    │       45.257485 │\n│ Dream     │       44.167742 │\n│ Torgersen │       38.950980 │\n└───────────┴─────────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t = ls.examples.penguins.fetch(table_name=\"penguins\")\n>>> expr = t.sql(\n...     \"\"\"\n...     SELECT island, mean(bill_length_mm) AS avg_bill_length\n...     FROM penguins\n...     GROUP BY 1\n...     ORDER BY 2 DESC\n...     \"\"\"\n... )\n>>> expr = expr.mutate(\n...     island=_.island.lower(),\n...     avg_bill_length=_.avg_bill_length.round(1),\n... )\n>>> expr\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓\n┃ island    ┃ avg_bill_length ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩\n│ string    │ float64         │\n├───────────┼─────────────────┤\n│ biscoe    │            45.3 │\n│ torgersen │            39.0 │\n│ dream     │            44.2 │\n└───────────┴─────────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> expr.alias(\"b\").sql(\"SELECT * FROM b WHERE avg_bill_length > 40\")\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━┓\n┃ island ┃ avg_bill_length ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━┩\n│ string │ float64         │\n├────────┼─────────────────┤\n│ biscoe │            45.3 │\n│ dream  │            44.2 │\n└────────┴─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Pandas UDF in Xorq\nDESCRIPTION: Example of creating a Pandas UDF to check if a URL exists within a title, including connection setup and parquet file processing\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/getting_started/quickstart.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nimport xorq.expr.datatypes as dt\n\n@xo.udf.make_pandas_udf(\n    schema=xo.schema({\"title\": str, \"url\": str}),\n    return_type=dt.bool,\n    name=\"url_in_title\",\n)\ndef url_in_title(df):\n    return df.apply(\n        lambda s: (s.url or \"\") in (s.title or \"\"),\n        axis=1,\n    )\n\n# Connect to xorq's embedded engine\ncon = xo.connect()\n\n# Reference the parquet file\nname = \"hn-data-small.parquet\"\nexpr = xo.deferred_read_parquet(\n    con,\n    xo.options.pins.get_path(name),\n    name,\n).mutate(**{\"url_in_title\": url_in_title.on_expr})\n\n# Display results\nprint(expr.execute().head())\n```\n\n----------------------------------------\n\nTITLE: String Find Operation in Ibis Python\nDESCRIPTION: Shows how to find the position of a substring within strings using find() method. Returns -1 if substring not found.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t.s.find(\"a\")\n>>> t.s.find(\"z\")\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for xorq TF-IDF Pipeline\nDESCRIPTION: Imports necessary Python modules for working with xorq, including scikit-learn for TF-IDF vectorization and xorq's deferred operations and ML utilities. Also imports custom helper modules from previous tutorials.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nimport xorq.expr.datatypes as dt\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\n\n\n# Import the helper modules we used in Part 1\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n```\n\n----------------------------------------\n\nTITLE: Using nullif with Real Data Example in Python\nDESCRIPTION: Demonstrates using the nullif method on a real dataset (penguins) to set specific values to NULL.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> vals = ibis.examples.penguins.fetch().head(5).sex\n>>> vals\n┏━━━━━━━━┓\n┃ sex    ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ male   │\n│ female │\n│ female │\n│ NULL   │\n│ female │\n└────────┘\n>>> vals.nullif(\"male\")\n┏━━━━━━━━━━━━━━━━━━━━━┓\n┃ NullIf(sex, 'male') ┃\n┡━━━━━━━━━━━━━━━━━━━━━┩\n│ string              │\n├─────────────────────┤\n│ NULL                │\n│ female              │\n│ female              │\n│ NULL                │\n│ female              │\n└─────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Using nunique() Method with Ibis Columns\nDESCRIPTION: Demonstrates how to count distinct values in a column, optionally with a where condition to filter rows. The examples show using the method on the body_mass_g column from the penguins dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.nunique()\n┌────┐\n│ 94 │\n└────┘\n>>> t.body_mass_g.nunique(where=t.species == \"Adelie\")\n┌────┐\n│ 55 │\n└────┘\n```\n\n----------------------------------------\n\nTITLE: Visualizing the MCP Server Flow with Mermaid Sequence Diagram\nDESCRIPTION: A sequence diagram illustrating the data flow between User, Claude, MCP Server, and Flight Service for sentiment analysis. It shows how user requests are processed through the system, including input mapping, prediction, and output formatting.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/vignettes/mcp_flight_server.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant U as User\n    participant C as Claude\n    participant MCP as MCP Server\n    participant FS as Flight Service\n    \n    U->>C: \"How positive is this headline?\"\n    C->>MCP: Request sentiment analysis\n    Note right of MCP: Input mapping\n    MCP->>FS: Transform text and predict\n    FS-->>MCP: Return sentiment score\n    Note right of MCP: Output mapping\n    MCP-->>C: Return formatted results\n    C-->>U: \"The headline has a sentiment score of 1 (positive)\"\n```\n\n----------------------------------------\n\nTITLE: Creating Flight Servers for TF-IDF and XGBoost Models\nDESCRIPTION: Sets up Flight servers for serving the TF-IDF transformation and XGBoost prediction models. Each server is configured with a specific port and bound to the corresponding model's functionality.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Create Flight servers for our models\n(transform_server, transform_do_exchange) = xo.expr.relations.flight_serve(\n    test_expr.into_backend(xo.connect()).mutate(\n        **{transformed_col: deferred_tfidf_transform.on_expr}\n    ),\n    make_server=functools.partial(FlightServer, FlightUrl(port=transform_port)),\n)\n\n(predict_server, predict_do_exchange) = xo.expr.relations.flight_serve(\n    test_xgb_predicted,\n    make_server=functools.partial(FlightServer, FlightUrl(port=predict_port)),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Window UDF for Time Series Analysis in xorq\nDESCRIPTION: Demonstrates how to create a window user-defined function (UDWF) in xorq for time series analysis. This example implements an exponential smoothing function that processes data within a window, maintaining state between rows.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pyarrow as pa\nfrom xorq.expr.udf import pyarrow_udwf\nfrom xorq.vendor import ibis\n\n\n@pyarrow_udwf(\n    schema=ibis.schema({\"a\": float}),\n    return_type=ibis.dtype(float),\n    alpha=0.9,\n)\ndef exp_smooth(self, values: list[pa.Array], num_rows: int) -> pa.Array:\n    results = []\n    curr_value = 0.0\n    values = values[0]\n    for idx in range(num_rows):\n        if idx == 0:\n            curr_value = values[idx].as_py()\n        else:\n            curr_value = values[idx].as_py() * self.alpha + curr_value * (\n                1.0 - self.alpha\n            )\n        results.append(curr_value)\n\n    return pa.array(results)\n\n\ndf = pd.DataFrame(\n    [\n        (0, 7, \"A\"),\n        (1, 4, \"A\"),\n        (2, 3, \"A\"),\n        (3, 8, \"A\"),\n        (4, 9, \"B\"),\n        (5, 1, \"B\"),\n        (6, 6, \"B\"),\n    ],\n    columns=[\"a\", \"b\", \"c\"],\n)\n\nt = xo.register(df, table_name=\"t\")\n\nexpr = t.select(\n    t.a,\n    udwf=exp_smooth.on_expr(t).over(ibis.window()),\n).order_by(t.a)\n\nresult = expr.execute()\n```\n\n----------------------------------------\n\nTITLE: Creating Descending Sort Keys in Python\nDESCRIPTION: Creates a descending sort key from an expression or column name, which can be used in ordering operations to sort data in descending order.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndesc(expr)\n```\n\n----------------------------------------\n\nTITLE: Using CLI Commands for Building Xorq Pipelines\nDESCRIPTION: Examples of using Xorq CLI commands to build and serialize pipelines with validation and documentation capabilities\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/getting_started/quickstart.mdx#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n❯ xorq build example.py -e expr\nBuilding expr from scrap.py\n              by  ...  url_in_title\n0         benkan  ...         False\n1  iancmceachern  ...         False\n2        michidk  ...         False\n3        journal  ...         False\n4         r0b3r4  ...         False\n[5 rows x 12 columns]\nWritten 'expr' to builds/831efa9ba0ec\n```\n\nLANGUAGE: sh\nCODE:\n```\n❯ xorq build sentiment_pipeline.py -e pipeline\nBuilding pipeline from sentiment_pipeline.py\nWritten 'pipeline' to builds/36293178ec4f\n```\n\nLANGUAGE: sh\nCODE:\n```\n❯ xorq run builds/831efa9ba0ec/\n```\n\nLANGUAGE: sh\nCODE:\n```\n❯ xorq serve builds/36293178ec4f/\n```\n\n----------------------------------------\n\nTITLE: Promoting Scalar and Literal Values to Tables in Ibis Python\nDESCRIPTION: This snippet shows how to promote scalar expressions and literal values to table expressions using the as_table() method in Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> import ibis.expr.types as ir\n>>> t = ibis.table(dict(a=\"str\"), name=\"t\")\n>>> expr = t.a.length().sum().name(\"len\").as_table()\n>>> isinstance(expr, ir.Table)\nTrue\n>>> lit = ibis.literal(1).name(\"a\").as_table()\n>>> isinstance(lit, ir.Table)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using isnull with Real Data Example in Python\nDESCRIPTION: Demonstrates using the isnull method on a real dataset (penguins) to check for NULL values in a column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().limit(5)\n>>> t.bill_depth_mm\n┏━━━━━━━━━━━━━━━┓\n┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│          18.7 │\n│          17.4 │\n│          18.0 │\n│          NULL │\n│          19.3 │\n└───────────────┘\n>>> t.bill_depth_mm.isnull()\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ IsNull(bill_depth_mm) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean               │\n├───────────────────────┤\n│ False                 │\n│ False                 │\n│ False                 │\n│ True                  │\n│ False                 │\n└───────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Basic Table Operations with Count in Python\nDESCRIPTION: Demonstrates creating a memory table and performing count operations with conditions. Shows both basic counting and conditional counting with filters.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.memtable({\"a\": [\"foo\", \"bar\", \"baz\"]})\n>>> t\n┏━━━━━━━━┓\n┃ a      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ foo    │\n│ bar    │\n│ baz    │\n└────────┘\n>>> t.count()\n┌───┐\n│ 3 │\n└───┘\n>>> t.count(t.a != \"foo\")\n┌───┐\n│ 2 │\n└───┘\n>>> type(t.count())\n<class 'letsql.vendor.ibis.expr.types.numeric.IntegerScalar'>\n```\n\n----------------------------------------\n\nTITLE: Making Predictions Using Flight Services\nDESCRIPTION: Uses the deployed Flight services to make predictions on the new data. This demonstrates how to use the model directly in xorq by chaining the transformation and prediction services.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Use the servers directly in xorq to make predictions\n# Note: do_exchange here takes expr (not RecordBatchReader like in a client)\nout = predict_do_exchange(xo.register(transform_do_exchange(z), \"t\")).read_pandas()\n```\n\n----------------------------------------\n\nTITLE: Using Coalesce Function in LetSQL\nDESCRIPTION: This snippet shows how to use the coalesce function in LetSQL to return the first non-null value from a list of arguments.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> letsql.coalesce(None, 4, 5)\n4\n```\n\n----------------------------------------\n\nTITLE: Defining Ibis Expression in Python\nDESCRIPTION: Example Python script defining an Ibis expression for data transformation using xorq, including database connections and table operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.expr.relations import into_backend\n\n\npg = xo.postgres.connect_env()\ndb = xo.duckdb.connect()\n\nbatting = pg.table(\"batting\")\n\ninteger = 1\n\nbackend = xo.duckdb.connect()\nawards_players = deferred_read_parquet(\n    backend,\n    xo.config.options.pins.get_path(\"awards_players\"),\n    table_name=\"award_players\",\n)\nleft = batting.filter(batting.yearID == 2015)\nright = awards_players.filter(awards_players.lgID == \"NL\").drop(\"yearID\", \"lgID\")\nexpr = left.join(\n    into_backend(right, pg, \"pg-filtered-table\"), [\"playerID\"], how=\"semi\"\n)[[\"yearID\", \"stint\"]]\n```\n\n----------------------------------------\n\nTITLE: Computing Natural Logarithm in Python using Ibis\nDESCRIPTION: Illustrates how to compute the natural logarithm (ln) for values in a numeric column using Ibis. The example creates a memory table with sample values and applies the ln function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2.718281828, 3]})\n>>> t.values.ln()\n┏━━━━━━━━━━━━┓\n┃ Ln(values) ┃\n┡━━━━━━━━━━━━┩\n│ float64    │\n├────────────┤\n│   0.000000 │\n│   1.000000 │\n│   1.098612 │\n└────────────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Ceiling Values in Ibis\nDESCRIPTION: Method to return the ceiling (smallest integer greater than or equal to) of values in a numeric column. The example shows rounding up decimal values to the next integer.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nceil()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n>>> t.values.ceil()\n┏━━━━━━━━━━━━━━┓\n┃ Ceil(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ int64        │\n├──────────────┤\n│            1 │\n│            2 │\n│            2 │\n│            3 │\n│            4 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Correlation Between Numeric Columns in Ibis\nDESCRIPTION: Method to calculate the correlation coefficient between two numeric columns. It includes parameters for filtering and specifying whether to use sample or population statistics.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncorr(right, where=None, how='sample')\n```\n\n----------------------------------------\n\nTITLE: Loading and Processing Input Data\nDESCRIPTION: Sets up data loading and processing pipeline including sentiment analysis and integer encoding of sentiment values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Initialize the backend\ncon = xo.connect()\nstorage = ParquetStorage(source=con)\n\n# Define the input dataset name\nname = \"hn-fetcher-input-large\"\n\n# Load and process the data (similar to Parts 1 and 2)\nraw_expr = (\n    deferred_read_parquet(\n        con,\n        xo.options.pins.get_path(name),\n        name,\n    )\n    .pipe(m.do_hackernews_fetcher_udxf)\n)\n\nt = (\n    raw_expr\n    .filter(xo._.text.notnull())\n    .pipe(o.do_hackernews_sentiment_udxf, con=con)\n    .cache(storage=ParquetStorage(con))\n    .filter(~xo._.sentiment.contains(\"ERROR\"))\n    .mutate(\n        sentiment_int=xo._.sentiment.cases(\n            {\"POSITIVE\": 2, \"NEUTRAL\": 1, \"NEGATIVE\": 0}.items()\n        ).cast(int)\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Filtering and Dropping Columns from DuckDB Table\nDESCRIPTION: Filters the 'awards_players' table to include only rows with 'lgID' equal to 'NL', then drops the 'yearID' and 'lgID' columns. This creates a new filtered and projected relation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nright = awards_players.filter(awards_players.lgID == \"NL\").drop(\"yearID\", \"lgID\")\nright\n```\n\n----------------------------------------\n\nTITLE: Performing Cross-Backend Semi Join with Column Selection\nDESCRIPTION: Performs a semi join between the filtered PostgreSQL batting table and the filtered DuckDB awards_players table, after converting the DuckDB table to PostgreSQL backend. Joins on 'playerID' and selects only 'yearID' and 'stint' columns in the result.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nexpr = left.join(\n    into_backend(right, pg, \"pg-filtered-table\"), [\"playerID\"], how=\"semi\"\n)[[\"yearID\", \"stint\"]]\n```\n\n----------------------------------------\n\nTITLE: Computing Base-10 Logarithm in Python using Ibis\nDESCRIPTION: Shows how to compute the base-10 logarithm for values in a numeric column using Ibis. The example creates a memory table with sample values and applies the log10 function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 10, 100]})\n>>> t.values.log10()\n┏━━━━━━━━━━━━━━━┓\n┃ Log10(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│           0.0 │\n│           1.0 │\n│           2.0 │\n└───────────────┘\n```\n\n----------------------------------------\n\nTITLE: Limiting Table Rows in Python\nDESCRIPTION: Method to select a specific number of rows from a table with optional offset. Includes example of using None with offset for slicing.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.memtable({\"a\": [1, 1, 2], \"b\": [\"c\", \"a\", \"a\"]})\n>>> t.limit(2)\n>>> t.limit(None, offset=1)\n```\n\n----------------------------------------\n\nTITLE: Casting Value Expression to Different Data Type\nDESCRIPTION: Method to cast an expression to a different data type, similar to pandas Series.astype(), accepting various type specifications.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncast(target_type)\n```\n\n----------------------------------------\n\nTITLE: Combining Tables with Union Operation in LetSQL/Ibis\nDESCRIPTION: The union method computes the set union of multiple table expressions that must have identical schemas. It can combine rows from tables with the option to eliminate duplicates using the distinct parameter.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nunion(table, *rest, distinct=False)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t1 = ls.memtable({\"a\": [1, 2]})\n>>> t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t2 = ls.memtable({\"a\": [2, 3]})\n>>> t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n>>> t1.union(t2)  # union all by default doctest: +SKIP\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n│     1 │\n│     2 │\n└───────┘\n>>> t1.union(t2, distinct=True).order_by(\"a\")\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n│     3 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Sorting a Table by a Single Column in Ascending Order\nDESCRIPTION: Demonstrates sorting a table by the 'b' column in ascending order. The example shows how capital letters are sorted before lowercase letters in the default ordering.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> t.order_by(\"b\")\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     2 │ B      │     6 │\n│     3 │ D      │     7 │\n│     3 │ a      │     4 │\n│     1 │ c      │     5 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Converting Table Expressions to Backend Tables\nDESCRIPTION: The into_backend method converts an expression to a table in a specified backend connection with an optional table name. The table is backed by a PyArrow RecordBatchReader that can be safely reused without spilling to disk.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ninto_backend(con, name=None)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> from letsql import _\n>>> ls.options.interactive = True\n>>> ls_con = ls.connect()\n>>> pg_con = ls.postgres.connect_examples()\n>>> t = pg_con.table(\"batting\").into_backend(ls_con, \"ls_batting\")\n>>> expr = (\n...     t.join(t, \"playerID\")\n...     .order_by(\"playerID\", \"yearID\")\n...     .limit(15)\n...     .select(player_id=\"playerID\", year_id=\"yearID_right\")\n... )\n>>> expr\n┏━━━━━━━━━━━┳━━━━━━━━━┓\n┃ player_id ┃ year_id ┃\n┡━━━━━━━━━━━╇━━━━━━━━━┩\n│ string    │ int64   │\n├───────────┼─────────┤\n│ aardsda01 │    2015 │\n│ aardsda01 │    2007 │\n│ aardsda01 │    2006 │\n│ aardsda01 │    2009 │\n│ aardsda01 │    2008 │\n│ aardsda01 │    2010 │\n│ aardsda01 │    2004 │\n│ aardsda01 │    2013 │\n│ aardsda01 │    2012 │\n│ aardsda01 │    2006 │\n│ …         │       … │\n└───────────┴─────────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Base-2 Logarithm in Python using Ibis\nDESCRIPTION: Illustrates how to compute the base-2 logarithm for values in a numeric column using Ibis. The example creates a memory table with sample values and applies the log2 function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 2, 4, 8]})\n>>> t.values.log2()\n┏━━━━━━━━━━━━━━┓\n┃ Log2(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│          0.0 │\n│          1.0 │\n│          2.0 │\n│          3.0 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Counting Approximate Unique Values in Ibis Python\nDESCRIPTION: This snippet shows how to use the approx_nunique() method to count the approximate number of unique values in a column of an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.approx_nunique()\n┌────┐\n│ 92 │\n└────┘\n>>> t.body_mass_g.approx_nunique(where=t.species == \"Adelie\")\n┌────┐\n│ 61 │\n└────┘\n```\n\n----------------------------------------\n\nTITLE: Case Expression with LetSQL\nDESCRIPTION: Example showing how to construct conditional case expressions for data transformation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> from letsql.vendor.ibis import _\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable(\n...     {\n...         \"left\": [1, 2, 3, 4],\n...         \"symbol\": [\"+\", \"-\", \"*\", \"/\"],\n...         \"right\": [5, 6, 7, 8],\n...     }\n... )\n>>> t.mutate(\n...     result=(\n...         letsql.case()\n...         .when(_.symbol == \"+\", _.left + _.right)\n...         .when(_.symbol == \"-\", _.left - _.right)\n...         .when(_.symbol == \"*\", _.left * _.right)\n...         .when(_.symbol == \"/\", _.left / _.right)\n...         .end()\n...     )\n... )\n```\n\n----------------------------------------\n\nTITLE: Splitting Data into Train-Test Sets with xorq\nDESCRIPTION: Splits the processed data into training (60%) and testing (40%) sets using xorq's train_test_splits function. Uses a random seed for reproducibility and the 'id' field as a unique key for consistent splitting.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Split into train (60%) and test (40%) sets\n(train_expr, test_expr) = processed_expr.pipe(\n    train_test_splits,\n    unique_key=\"id\",\n    test_sizes=(0.6, 0.4),\n    random_seed=42,\n)\n```\n\n----------------------------------------\n\nTITLE: LetsQL to_parquet Function Definition\nDESCRIPTION: Function for writing a LetsQL expression directly to a Parquet file with optional parameters.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nto_parquet(expr, path, params=None, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Selecting Columns from Ibis Table in Python\nDESCRIPTION: Demonstrates various ways to select and project columns using the 'select' method of an Ibis Table object. Includes simple column selection, renaming, computation, and use of selectors.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.examples.penguins.fetch()\n>>> t.select(\"island\", \"bill_length_mm\").head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ island    ┃ bill_length_mm ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ string    │ float64        │\n├───────────┼────────────────┤\n│ Torgersen │           39.1 │\n│ Torgersen │           39.5 │\n│ Torgersen │           40.3 │\n│ Torgersen │           NULL │\n│ Torgersen │           36.7 │\n└───────────┴────────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t[\"island\", \"bill_length_mm\"].head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ island    ┃ bill_length_mm ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ string    │ float64        │\n├───────────┼────────────────┤\n│ Torgersen │           39.1 │\n│ Torgersen │           39.5 │\n│ Torgersen │           40.3 │\n│ Torgersen │           NULL │\n│ Torgersen │           36.7 │\n└───────────┴────────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t.select(t[0], t[4]).head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓\n┃ species ┃ flipper_length_mm ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩\n│ string  │ float64           │\n├─────────┼───────────────────┤\n│ Adelie  │             181.0 │\n│ Adelie  │             186.0 │\n│ Adelie  │             195.0 │\n│ Adelie  │              NULL │\n│ Adelie  │             193.0 │\n└─────────┴───────────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t.select(next_year=t.year + 1).head()\n┏━━━━━━━━━━━┓\n┃ next_year ┃\n┡━━━━━━━━━━━┩\n│ int64     │\n├───────────┤\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n└───────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from letsql import _\n>>> t.select((_.year + 1).name(\"next_year\")).head()\n┏━━━━━━━━━━━┓\n┃ next_year ┃\n┡━━━━━━━━━━━┩\n│ int64     │\n├───────────┤\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n└───────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t.select(\"island\", bill_mean=t.bill_length_mm.mean()).head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━┓\n┃ island    ┃ bill_mean ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━┩\n│ string    │ float64   │\n├───────────┼───────────┤\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n└───────────┴───────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql.selectors as s\n>>> t.select(s.numeric() & ~s.cols(\"year\")).head()\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ body_mass_g ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ float64        │ float64       │ float64           │ float64     │\n├────────────────┼───────────────┼───────────────────┼─────────────┤\n│           39.1 │          18.7 │             181.0 │      3750.0 │\n│           39.5 │          17.4 │             186.0 │      3800.0 │\n│           40.3 │          18.0 │             195.0 │      3250.0 │\n│           NULL │          NULL │              NULL │        NULL │\n│           36.7 │          19.3 │             193.0 │      3450.0 │\n└────────────────┴───────────────┴───────────────────┴─────────────┘\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from letsql import _\n>>> t.select(s.across(s.numeric() & ~s.cols(\"year\"), _.mean())).head()\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ body_mass_g ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ float64        │ float64       │ float64           │ float64     │\n├────────────────┼───────────────┼───────────────────┼─────────────┤\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n└────────────────┴───────────────┴───────────────────┴─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Accessing Next Row Values in Python using Ibis\nDESCRIPTION: This function returns the row located at a specified offset after the current row. It allows setting a default value if no row exists at the given offset. This is useful for comparing current row values with subsequent row values in a dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nlead(offset=None, default=None)\n```\n\n----------------------------------------\n\nTITLE: Creating Discrete Buckets for Numeric Data in Ibis\nDESCRIPTION: Method to compute a discrete binning of a numeric array. It allows binning values into discrete categories defined by bucket boundaries with various options for bucket inclusion rules.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nbucket(\n    buckets,\n    closed='left',\n    close_extreme=True,\n    include_under=False,\n    include_over=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Profile Objects in Python\nDESCRIPTION: Demonstrates various methods to create Profile objects, including from scratch, from an existing connection, and loading from disk. Also shows instance methods for working with profiles.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Create a new profile\nprofile = Profile(\n    con_name=\"postgres\",\n    kwargs_tuple=(\n        (\"host\", \"${POSTGRES_HOST}\"),\n        (\"port\", 5432),\n        (\"database\", \"postgres\"),\n        (\"user\", \"${POSTGRES_USER}\"),\n        (\"password\", \"${POSTGRES_PASSWORD}\"),\n    ),\n)\n\n# Create from an existing connection\nprofile = Profile.from_con(connection)\n\n# Load from disk by alias\nprofile = Profile.load(\"postgres_example\")\n\n# Create a connection\nconnection = profile.get_con()\n\n# Create a modified copy\nmodified = profile.clone(**{\"connect_timeout\": 10})\n\n# Convert to dictionary\nprofile_dict = profile.as_dict()\n\n# Serialize as JSON\njson_str = profile.as_json()\n\n# Serialize as YAML\nyaml_str = profile.as_yaml()\n\n# Save to disk with optional alias\npath = profile.save(alias=\"postgres_example\", clobber=True)\n```\n\n----------------------------------------\n\nTITLE: LetsQL to_pyarrow_batches Function Definition\nDESCRIPTION: Function for converting a LetsQL expression to PyArrow record batches with optional chunk size configuration.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nto_pyarrow_batches(expr, *, chunk_size=1000000, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: LetsQL Table.sample Method Definition\nDESCRIPTION: Documents the sample method signature and parameters for the LetsQL Table class. This method allows sampling a fraction of rows from a table with options for sampling method and random seed.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nsample(fraction, *, method='row', seed=None)\n```\n\n----------------------------------------\n\nTITLE: Running xorq Expression and Saving as Parquet\nDESCRIPTION: Example of running a built xorq expression and saving the results as a Parquet file.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nxorq run artifacts/2a3b46d8d3d0 --output-path results.parquet\n```\n\n----------------------------------------\n\nTITLE: Retrieving First Value from Column in Python using Ibis\nDESCRIPTION: This function returns the first value of a column. It allows optional filtering, ordering, and inclusion of null values. The function can be used with or without parameters to retrieve the first value based on specified conditions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfirst(where=None, order_by=None, include_null=False)\n```\n\n----------------------------------------\n\nTITLE: Saving a xorq Profile with an Alias in Python\nDESCRIPTION: Saves a database connection profile to disk with a named alias for easy reference later. The clobber parameter allows overwriting existing profiles with the same name.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npath = profile.save(alias=\"postgres_example\", clobber=True)\nprint(f\"Profile saved to: {path}\")\n```\n\n----------------------------------------\n\nTITLE: Deferred TF-IDF Model Execution Plan in xorq\nDESCRIPTION: Shows the execution plan for the deferred TF-IDF model in xorq. Displays the sequence of operations including filtering, projection, aggregation, and caching that will be performed when the model is executed.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nr0 := FlightUDXF: ibis_rbr-placeholder_ywruclahnbafvb\n  by          string\n  id          int64\n  parent      float64\n  text        string\n  time        int64\n  type        string\n  kids        array<int64>\n  descendants float64\n  score       float64\n  title       string\n  url         string\n  sentiment   string\n\nr1 := RemoteTable[r0, name=HackerNewsSentimentAnalyzer]\n  by          string\n  id          int64\n  parent      float64\n  text        string\n  time        int64\n  type        string\n  kids        array<int64>\n  descendants float64\n  score       float64\n  title       string\n  url         string\n  sentiment   string\n\nr2 := CachedNode[r1, strategy=modification_time, parquet=True, source=let-126580202190208]\n  by          string\n  id          int64\n  parent      float64\n  text        string\n  time        int64\n  type        string\n  kids        array<int64>\n  descendants float64\n  score       float64\n  title       string\n  url         string\n  sentiment   string\n\nr3 := Filter[r2]\n  Not(StringContains(haystack=r2.sentiment, needle='ERROR'))\n\nr4 := Project[r3]\n  by:            r3.by\n  id:            r3.id\n  parent:        r3.parent\n  text:          r3.text\n  time:          r3.time\n  type:          r3.type\n  kids:          r3.kids\n  descendants:   r3.descendants\n  score:         r3.score\n  title:         r3.title\n  url:           r3.url\n  sentiment:     r3.sentiment\n  sentiment_int: Cast(SimpleCase(base=r3.sentiment, cases=['POSITIVE', 'NEUTRAL', 'NEGATIVE'],\nresults=[2, 1, 0], default=Cast(None, to=int8)), to=int64)\n\nr5 := Filter[r4]\n  Cast(0, to=decimal(38, 9)) * 10000 <= Abs(Hash(StringConcat([StringJoin([Cast(r4.id, to=string)],\nsep=','), '16157387885063800092468972531095442600227637936690303362357377535130907802013']))) % 10000\n  Abs(Hash(StringConcat([StringJoin([Cast(r4.id, to=string)], sep=','),\n'16157387885063800092468972531095442600227637936690303362357377535130907802013']))) % 10000 < Cast(0.6,\nto=decimal(38, 9)) * 10000\n\nr6 := Aggregate[r5]\n  metrics:\n    _c9160aa7a9f22006e1547fa8f80d1b91(title): _c9160aa7a9f22006e1547fa8f80d1b91(r5.title)\n\nCachedNode[r6, strategy=modification_time, parquet=True, source=let-126580202190208]\n  _c9160aa7a9f22006e1547fa8f80d1b91(title) binary\n```\n\n----------------------------------------\n\nTITLE: Creating New Data for Prediction\nDESCRIPTION: Prepares a new dataset of Hacker News stories for prediction using the served models. This includes fetching items, filtering, and initializing sentiment fields that will be populated by the model.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Create a dataset of new HackerNews stories\nz = (\n    xo.memtable([{\"maxitem\": 43346282, \"n\": 1000}])\n    .pipe(m.do_hackernews_fetcher_udxf)\n    .filter(xo._.text.notnull())\n    .mutate(\n        **{\n            \"sentiment\": xo.literal(None).cast(str),\n            \"sentiment_int\": xo.literal(None).cast(int),\n        }\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: LetsQL to_sql Function Definition\nDESCRIPTION: Function for converting a LetsQL expression to a formatted SQL string, with an option for pretty formatting.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nto_sql(expr, pretty=True)\n```\n\n----------------------------------------\n\nTITLE: Sorting a Table by Multiple Columns in Mixed Order\nDESCRIPTION: Shows how to sort a table by multiple columns by passing a list of sort keys. This example sorts first by column 'a' in ascending order, then by column 'c' in descending order.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> t.order_by([\"a\", _.c.desc()])\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     1 │ c      │     5 │\n│     2 │ B      │     6 │\n│     3 │ D      │     7 │\n│     3 │ a      │     4 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Calculating Sine in Ibis\nDESCRIPTION: Shows how to use the sin() method to calculate the sine of numeric values in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.sin()\n┏━━━━━━━━━━━━━┓\n┃ Sin(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -0.841471 │\n│    0.000000 │\n│    0.841471 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Setting up XORQ Development Environment with uv\nDESCRIPTION: Instructions for setting up a development environment for the XORQ project using uv package manager. This approach clones the repository, configures uv, installs dependencies, compiles Rust extensions, and sets up git hooks.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# fetch this repo\ngit clone git@github.com:xorq-labs/xorq.git\n# set uv run command to not sync \nexport UV_NO_SYNC=1\n# prepare development environment and install dependencies\nuv sync --all-extras --all-groups --no-install-project\n# compile and install the rust extensions\nuv run maturin develop --uv --release --strip\n# activate the venv\nsource venv/bin/activate\n# set up the git hook scripts\nuv run pre-commit install\n```\n\n----------------------------------------\n\nTITLE: Table Intersection Operations in Python\nDESCRIPTION: Method to compute set intersection of multiple table expressions with identical schemas. Includes parameters for distinct row handling.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t1 = ls.memtable({\"a\": [1, 2]})\n>>> t2 = ls.memtable({\"a\": [2, 3]})\n>>> t1.intersect(t2)\n```\n\n----------------------------------------\n\nTITLE: Regex Replace in Ibis: Doubling Specific Characters\nDESCRIPTION: Shows how to use capture groups and backreferences in re_replace to double occurrences of 'a' or 'b'.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> s.re_replace(\"([ab])\", r\"\\0\\0\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexReplace(s, '()', '\\\\0\\\\0')     ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                              │\n├─────────────────────────────────────┤\n│ aabbc                               │\n│ bbaac                               │\n│ bbcaa                               │\n│ this haas  multi \\t whitespaace     │\n└─────────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Extracting UNIX Epoch in Python\nDESCRIPTION: Method to extract the UNIX epoch in seconds from a DateValue object.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nepoch_seconds()\n```\n\n----------------------------------------\n\nTITLE: Using Deferred API for Descending Order Sorting\nDESCRIPTION: Demonstrates using the deferred API with the underscore (_) syntax to sort by a column in descending order. This provides an alternative syntax to the ls.desc() function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from letsql import _\n>>> t.order_by(_.b.desc())\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     1 │ c      │     5 │\n│     3 │ a      │     4 │\n│     3 │ D      │     7 │\n│     2 │ B      │     6 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Square Root in Ibis\nDESCRIPTION: Demonstrates the use of the sqrt() method to calculate the square root of numeric values in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1, 4, 9, 16]})\n>>> t.values.sqrt()\n┏━━━━━━━━━━━━━━┓\n┃ Sqrt(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│          1.0 │\n│          2.0 │\n│          3.0 │\n│          4.0 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Performing UNION Operations on Tables in letsql\nDESCRIPTION: Computes the set union of multiple table expressions. The input tables must have identical schemas. The 'distinct' parameter controls whether duplicate rows are removed from the result.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nunion(table, *rest, distinct=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing ntile Window Function in Python (letsql)\nDESCRIPTION: Divides ordered data into a specified number of roughly equal buckets and assigns a bucket number to each row. The function takes a 'buckets' parameter to specify the number of partitions and is used with the .over() method to define window parameters.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nntile(buckets)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(ntile=letsql.ntile(2).over(order_by=t.values))\n┏━━━━━━━━┳━━━━━━━┓\n┃ values ┃ ntile ┃\n┡━━━━━━━━╇━━━━━━━┩\n│ int64  │ int64 │\n├────────┼───────┤\n│      1 │     0 │\n│      1 │     0 │\n│      2 │     0 │\n│      2 │     1 │\n│      2 │     1 │\n│      3 │     1 │\n└────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Working with Profiles Collection in Python\nDESCRIPTION: Shows how to use the Profiles class to manage multiple saved profiles, including listing, retrieving, and accessing profiles.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.vendor.ibis.backends.profiles import Profiles\n\n# Create a profiles manager\nprofiles = Profiles()\n\n# List all available profiles\navailable = profiles.list()\n\n# Get profile by name\nprofile = profiles.get(\"postgres_example\")\n\n# Access profiles as attributes\nprofile = profiles.postgres_example\n\n# Access profiles as dictionary keys\nprofile = profiles[\"postgres_example\"]\n```\n\n----------------------------------------\n\nTITLE: Executing Pipeline and Displaying Results\nDESCRIPTION: Executes the data pipeline and displays the labeled results including story ID, title, sentiment, and sentiment integer code.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nlabeled_df = t.execute()\n\nprint(labeled_df[[\"id\", \"title\", \"sentiment\", \"sentiment_int\"]].head())\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules for XGBoost Model Serving\nDESCRIPTION: Imports necessary Python modules for model training, transformation, prediction, and serving. Includes imports for xorq Flight capabilities, pandas, XGBoost, and scikit-learn.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport functools\n\nimport pandas as pd\nimport toolz\nimport xgboost as xgb\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error\n\nimport xorq as xo\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.caching import (\n    ParquetStorage,\n    SourceStorage,\n)\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_predict,\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\nfrom xorq.flight import (\n    FlightServer,\n    FlightUrl,\n)\n\n# Import the helper modules we used in previous parts\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n```\n\n----------------------------------------\n\nTITLE: Regex Search in Ibis: Matching String Patterns\nDESCRIPTION: Demonstrates using re_search to find strings matching a specific pattern, returning boolean results.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.re_search(\".+Hub\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexSearch(s, '.+Hub') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                 │\n├─────────────────────────┤\n│ False                   │\n│ True                    │\n└─────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Calculating Tangent in Ibis\nDESCRIPTION: Illustrates how to use the tan() method to compute the tangent of numeric values in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.tan()\n┏━━━━━━━━━━━━━┓\n┃ Tan(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -1.557408 │\n│    0.000000 │\n│    1.557408 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Checking for NULL Values with isnull in Python\nDESCRIPTION: Example showing how to use the isnull method to check for NULL values in a column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nisnull()\n```\n\n----------------------------------------\n\nTITLE: Calculating Median of Column in Python using Ibis\nDESCRIPTION: This function returns the median value of a column. It supports optional filtering to consider only specific values. The function works with both numeric and orderable non-numeric types like strings and dates.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nmedian(where=None)\n```\n\n----------------------------------------\n\nTITLE: Building and saving an ML pipeline execution plan with xorq CLI\nDESCRIPTION: Command for building an ML pipeline using the xorq command-line interface, which saves the execution plan to a specified directory for later execution.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Build a pipeline and save the execution plan\nxorq build examples/bank_marketing.py -e \"predictions_expr\" --builds-dir builds\n```\n\n----------------------------------------\n\nTITLE: Implementing percent_rank Window Function in Python (letsql)\nDESCRIPTION: Calculates the relative rank of values in a column, returning results as a floating-point column. The function is used with the .over() method to define window parameters, particularly the order_by clause to determine ranking order.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npercent_rank()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(pct_rank=letsql.percent_rank().over(order_by=t.values))\n┏━━━━━━━━┳━━━━━━━━━━┓\n┃ values ┃ pct_rank ┃\n┡━━━━━━━━╇━━━━━━━━━━┩\n│ int64  │ float64  │\n├────────┼──────────┤\n│      1 │      0.0 │\n│      1 │      0.0 │\n│      2 │      0.4 │\n│      2 │      0.4 │\n│      2 │      0.4 │\n│      3 │      1.0 │\n└────────┴──────────┘\n```\n\n----------------------------------------\n\nTITLE: Regex Replace in Ibis: Replacing Pattern at String Start\nDESCRIPTION: Demonstrates using re_replace to substitute 'a' with 'b' at the beginning of strings.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> s.re_replace(\"^a\", \"b\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexReplace(s, '^a', 'b')    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                        │\n├───────────────────────────────┤\n│ bbc                           │\n│ bac                           │\n│ bca                           │\n│ this has  multi \\t whitespace │\n└───────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Determining Sign of Numeric Values in Ibis\nDESCRIPTION: Illustrates the use of the sign() method to determine the sign (-1, 0, or 1) of numeric values in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n>>> t.values.sign()\n┏━━━━━━━━━━━━━━┓\n┃ Sign(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ int64        │\n├──────────────┤\n│           -1 │\n│            1 │\n│           -1 │\n│            1 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Checking Value Identity with identical_to Method\nDESCRIPTION: Method to check if an expression is identical to another, corresponding to SQL's IS NOT DISTINCT FROM operation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nidentical_to(other)\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Value in Column using Python and Ibis\nDESCRIPTION: This function returns the minimum value of a column. It allows optional filtering to consider only specific values. The function can be used to find the overall minimum or the minimum value that satisfies certain conditions.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nmin(where=None)\n```\n\n----------------------------------------\n\nTITLE: Regex Extraction in Ibis\nDESCRIPTION: This snippet shows how to use the re_extract() method to extract matches from strings using regular expressions in Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t.s.re_extract(r\"^(a)bc\", 1)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexExtract(s, '^(a)bc', 1) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ a                            │\n│ ~                            │\n│ ~                            │\n└──────────────────────────────┘\n>>> t.s.re_extract(r\"^(a)bc\", 0)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexExtract(s, '^(a)bc', 0) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ abc                          │\n│ ~                            │\n│ ~                            │\n└──────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Executing ML Pipeline in xorq\nDESCRIPTION: Demonstrates how to execute the entire ML pipeline expression in xorq. This single line triggers the execution of all deferred operations in the pipeline.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/pipelines_as_expressions.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntest_xgb_predicted.execute()\n```\n\n----------------------------------------\n\nTITLE: Stripping Whitespace from Both Sides of Strings using Ibis in Python\nDESCRIPTION: This snippet demonstrates how to use the strip method to remove whitespace from both the left and right sides of strings in a table column using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n>>> t.s.strip()\n┏━━━━━━━━━━┓\n┃ Strip(s) ┃\n┡━━━━━━━━━━┩\n│ string   │\n├──────────┤\n│ a        │\n│ b        │\n│ c        │\n└──────────┘\n```\n\n----------------------------------------\n\nTITLE: String Repeat in Ibis: Duplicating Strings\nDESCRIPTION: Demonstrates the repeat function to duplicate strings a specified number of times.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"a\", \"bb\", \"c\"]})\n>>> t.s.repeat(5)\n┏━━━━━━━━━━━━━━┓\n┃ Repeat(s, 5) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ aaaaa        │\n│ bbbbbbbbbb   │\n│ ccccc        │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Setting Values to NULL with nullif in Python\nDESCRIPTION: Example showing how to use the nullif method to set values to NULL if they match a specified condition.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nnullif(null_if_expr)\n```\n\n----------------------------------------\n\nTITLE: Computing Arc Cosine in Ibis\nDESCRIPTION: Method to compute the arc cosine of values in a numeric column. The example shows applying acos() to values between -1 and 1, returning results in radians.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nacos()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.acos()\n┏━━━━━━━━━━━━━━┓\n┃ Acos(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│     3.141593 │\n│     1.570796 │\n│     0.000000 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Using min() Method with Ibis Columns\nDESCRIPTION: Demonstrates how to find the minimum value in a column, optionally with a where condition to filter values. The examples show using the method on the body_mass_g column from the penguins dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch()\n>>> t.body_mass_g.min()\n┌──────┐\n│ 2700 │\n└──────┘\n>>> t.body_mass_g.min(where=t.species == \"Adelie\")\n┌──────┐\n│ 2850 │\n└──────┘\n```\n\n----------------------------------------\n\nTITLE: Regex Split in Ibis: Splitting Strings by Pattern\nDESCRIPTION: Shows how to use re_split to divide strings into arrays based on a regular expression pattern.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable(dict(s=[\"a.b\", \"b.....c\", \"c.........a\", \"def\"]))\n>>> t.s\n┏━━━━━━━━━━━━━┓\n┃ s           ┃\n┡━━━━━━━━━━━━━┩\n│ string      │\n├─────────────┤\n│ a.b         │\n│ b.....c     │\n│ c.........a │\n│ def         │\n└─────────────┘\n>>> t.s.re_split(r\"\\.+\").name(\"splits\")\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ splits               ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array<string>        │\n├──────────────────────┤\n│ ['a', 'b']           │\n│ ['b', 'c']           │\n│ ['c', 'a']           │\n│ ['def']              │\n└──────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Checking if Strings Start with a Prefix using Ibis in Python\nDESCRIPTION: This example shows how to use the startswith method to check if strings in a table column start with a specific prefix using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.startswith(\"Ibis\")\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StartsWith(s, 'Ibis') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean               │\n├───────────────────────┤\n│ True                  │\n│ False                 │\n└───────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Extracting URL Path in Ibis\nDESCRIPTION: This example demonstrates how to use the path() method to extract the path from a URL string in Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\n...     \"https://example.com:80/docs/books/tutorial/index.html?name=networking\"\n... )\n>>> result = url.path()  # docs/books/tutorial/index.html\n```\n\n----------------------------------------\n\nTITLE: Using name Method with Example in Python\nDESCRIPTION: Demonstrates how to rename a column in an Ibis table using the name method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2]}, name=\"t\")\n>>> t.a\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t.a.name(\"b\")\n┏━━━━━━━┓\n┃ b     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Renaming Expressions with name Method in Python\nDESCRIPTION: Example showing how to rename an Ibis expression using the name method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nname(name)\n```\n\n----------------------------------------\n\nTITLE: Extracting URL Query Parameters in Ibis\nDESCRIPTION: This example demonstrates how to use the query() method to extract query parameters from a URL string in Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\n...     \"https://example.com:80/docs/books/tutorial/index.html?name=networking\"\n... )\n>>> result = url.query()  # name=networking\n>>> query_name = url.query(\"name\")  # networking\n```\n\n----------------------------------------\n\nTITLE: String Concatenation in Ibis Python\nDESCRIPTION: Demonstrates string concatenation using Ibis memtable with both concat() method and + operator. Shows handling of NULL values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", None]})\n>>> t.s.concat(\"xyz\", \"123\")\n>>> t.s + \"xyz\"\n```\n\n----------------------------------------\n\nTITLE: Implementing row_number Window Function in Python (letsql)\nDESCRIPTION: Returns the sequential row number starting at 0 for each row in the result set. The function is normalized across backends to always start at 0 and returns an integer column. It can be used with or without window specifications.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nrow_number()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rownum=letsql.row_number())\n┏━━━━━━━━┳━━━━━━━━┓\n┃ values ┃ rownum ┃\n┡━━━━━━━━╇━━━━━━━━┩\n│ int64  │ int64  │\n├────────┼────────┤\n│      1 │      0 │\n│      2 │      1 │\n│      1 │      2 │\n│      2 │      3 │\n│      3 │      4 │\n│      2 │      5 │\n└────────┴────────┘\n```\n\n----------------------------------------\n\nTITLE: Demonstrating rpad String Operation in Python using Ibis\nDESCRIPTION: This snippet shows how to use the rpad method to right-pad strings in a table column using Ibis. It pads the strings to a length of 5 characters using the '-' character.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n>>> t.s.rpad(5, \"-\")\n┏━━━━━━━━━━━━━━━━━┓\n┃ RPad(s, 5, '-') ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ abc--           │\n│ def--           │\n│ ghij-           │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Left-Padding Strings in Ibis\nDESCRIPTION: This example demonstrates the usage of the lpad() method to pad strings on the left side in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n>>> t.s.lpad(5, \"-\")\n┏━━━━━━━━━━━━━━━━━┓\n┃ LPad(s, 5, '-') ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ --abc           │\n│ --def           │\n│ -ghij           │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Cosine in Python using Ibis\nDESCRIPTION: Demonstrates how to compute the cosine of values in a numeric column using Ibis. The example creates a memory table with sample values and applies the cosine function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.cos()\n┏━━━━━━━━━━━━━┓\n┃ Cos(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│    0.540302 │\n│    1.000000 │\n│    0.540302 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Rank Function in LetSQL\nDESCRIPTION: Example demonstrating how to compute rankings within groups using the rank() window function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=letsql.rank().over(order_by=t.values))\n```\n\n----------------------------------------\n\nTITLE: String Contains Check in Ibis Python\nDESCRIPTION: Shows how to check if a string contains a substring using the contains() method. Returns boolean values for each row.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"bab\", \"ddd\", \"eaf\"]})\n>>> t.s.contains(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Loading a xorq Profile by Alias in Python\nDESCRIPTION: Demonstrates loading a previously saved profile using its alias name. The loaded profile maintains environment variable references for security.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nloaded_profile = Profile.load(\"postgres_example\")\nprint(loaded_profile)\n```\n\n----------------------------------------\n\nTITLE: String Reverse in Ibis: Inverting Character Order\nDESCRIPTION: Demonstrates the reverse function to invert the order of characters in strings.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ abc    │\n│ def    │\n│ ghi    │\n└────────┘\n>>> t.s.reverse()\n┏━━━━━━━━━━━━┓\n┃ Reverse(s) ┃\n┡━━━━━━━━━━━━┩\n│ string     │\n├────────────┤\n│ cba        │\n│ fed        │\n│ ihg        │\n└────────────┘\n```\n\n----------------------------------------\n\nTITLE: String Length Calculation in Ibis Python\nDESCRIPTION: Shows how to compute string lengths using length() method. Returns integer values for each string.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aaa\", \"a\", \"aa\"]})\n>>> t.s.length()\n```\n\n----------------------------------------\n\nTITLE: Computing Two-Argument Arc Tangent in Ibis\nDESCRIPTION: Method to compute the two-argument version of arc tangent, similar to math.atan2(). The example shows applying atan2() with a second parameter to determine quadrant.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\natan2(other)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.atan2(0)\n┏━━━━━━━━━━━━━━━━━━┓\n┃ Atan2(values, 0) ┃\n┡━━━━━━━━━━━━━━━━━━┩\n│ float64          │\n├──────────────────┤\n│        -1.570796 │\n│         0.000000 │\n│         1.570796 │\n└──────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Dense Rank Function in LetSQL\nDESCRIPTION: Example showing how to compute dense rankings that ignore gaps using the dense_rank() window function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(rank=letsql.dense_rank().over(order_by=t.values))\n```\n\n----------------------------------------\n\nTITLE: Using Across Selector for Multi-Column Sorting\nDESCRIPTION: Shows how to use the 'across' selector to apply a specific ordering direction to multiple columns. This example sorts columns starting with 'year' in descending order.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> penguins[[\"year\", \"island\"]].value_counts().order_by(\n...     s.across(s.startswith(\"year\"), _.desc())\n... )\n┏━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓\n┃ year  ┃ island    ┃ year_island_count ┃\n┡━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩\n│ int64 │ string    │ int64             │\n├───────┼───────────┼───────────────────┤\n│  2009 │ Biscoe    │                60 │\n│  2009 │ Dream     │                44 │\n│  2009 │ Torgersen │                16 │\n│  2008 │ Biscoe    │                64 │\n│  2008 │ Dream     │                34 │\n│  2008 │ Torgersen │                16 │\n│  2007 │ Dream     │                46 │\n│  2007 │ Biscoe    │                44 │\n│  2007 │ Torgersen │                20 │\n└───────┴───────────┴───────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Difference Operation in LetSQL\nDESCRIPTION: This snippet shows how to use the difference function to find elements in one table that are not present in another table in LetSQL.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t1 = letsql.memtable({\"a\": [1, 2]})\n>>> t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t2 = letsql.memtable({\"a\": [2, 3]})\n>>> t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n>>> letsql.difference(t1, t2)\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Sampling Rows from a Table\nDESCRIPTION: Demonstrates the sample method which extracts a random subset of rows from a table. This example samples 50% of the rows with a fixed seed for reproducibility.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.memtable({\"x\": [1, 2, 3, 4], \"y\": [\"a\", \"b\", \"c\", \"d\"]})\n>>> t\n┏━━━━━━━┳━━━━━━━━┓\n┃ x     ┃ y      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ a      │\n│     2 │ b      │\n│     3 │ c      │\n│     4 │ d      │\n└───────┴────────┘\n>>> t.sample(0.5, seed=1234)\n┏━━━━━━━┳━━━━━━━━┓\n┃ x     ┃ y      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     2 │ b      │\n│     3 │ c      │\n└───────┴────────┘\n```\n\n----------------------------------------\n\nTITLE: Using LetsQL Range Function with Stop Argument\nDESCRIPTION: Demonstrates using the range function with only a stop argument, generating values from 0 to 4.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(5)\n[0, 1, ... +3]\n```\n\n----------------------------------------\n\nTITLE: String EndsWith Check in Ibis Python\nDESCRIPTION: Demonstrates how to check if strings end with a specific suffix using endswith() method. Returns boolean values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n>>> t.s.endswith(\"project\")\n```\n\n----------------------------------------\n\nTITLE: Computing Arc Tangent in Ibis\nDESCRIPTION: Method to compute the arc tangent of values in a numeric column. The example demonstrates applying atan() to a set of values, returning results in radians.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\natan()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.atan()\n┏━━━━━━━━━━━━━━┓\n┃ Atan(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│    -0.785398 │\n│     0.000000 │\n│     0.785398 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Converting Degrees to Radians in Ibis\nDESCRIPTION: Demonstrates how to use the radians() method to convert degree values to radians in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [0, 90, 180, 270, 360]})\n>>> t.values.radians()\n┏━━━━━━━━━━━━━━━━━┓\n┃ Radians(values) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│        0.000000 │\n│        1.570796 │\n│        3.141593 │\n│        4.712389 │\n│        6.283185 │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Shuffling a Table Using Random Sorting\nDESCRIPTION: Shows how to shuffle or randomize the order of a table by using the ls.random() function as a sort key. This creates a random ordering of rows.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> t.order_by(ls.random())\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     1 │ c      │     5 │\n│     3 │ D      │     7 │\n│     3 │ a      │     4 │\n│     2 │ B      │     6 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings on a Delimiter using Ibis in Python\nDESCRIPTION: This code snippet illustrates how to use the split method to split strings in a table column based on a specified delimiter using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"col\": [\"a,b,c\", \"d,e\", \"f\"]})\n>>> t\n┏━━━━━━━━┓\n┃ col    ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ a,b,c  │\n│ d,e    │\n│ f      │\n└────────┘\n>>> t.col.split(\",\")\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringSplit(col, ',') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ array<string>         │\n├───────────────────────┤\n│ ['a', 'b', ... +1]    │\n│ ['d', 'e']            │\n│ ['f']                 │\n└───────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Profiles in Python\nDESCRIPTION: Demonstrates how to work with multiple profiles using the Profiles collection, including listing all profiles and accessing specific ones.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Get profiles collection\nprofiles = Profiles()\n\n# List all profiles\nall_profiles = profiles.list()\n\n# Access by name\nmy_profile = profiles.get(\"postgres_example\")\n```\n\n----------------------------------------\n\nTITLE: LetsQL Interval Function Definition\nDESCRIPTION: Function signature for creating time interval expressions with various duration parameters such as years, months, days, hours, etc.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_45\n\nLANGUAGE: python\nCODE:\n```\ninterval(\n    value=None,\n    unit='s',\n    *,\n    years=None,\n    quarters=None,\n    months=None,\n    weeks=None,\n    days=None,\n    hours=None,\n    minutes=None,\n    seconds=None,\n    milliseconds=None,\n    microseconds=None,\n    nanoseconds=None,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the nth() Method for Ibis Columns\nDESCRIPTION: Method to return the nth value (0-indexed) over a window. The parameter n specifies the desired rank value. Returns NULL for negative n or if n exceeds window size.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nnth(n)\n```\n\n----------------------------------------\n\nTITLE: Rounding Numeric Values in Ibis\nDESCRIPTION: Shows how to use the round() method to round numeric values in an Ibis table, with examples of rounding to the nearest integer and to one decimal place.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [1.22, 1.64, 2.15, 2.54]})\n>>> t\n┏━━━━━━━━━┓\n┃ values  ┃\n┡━━━━━━━━━┩\n│ float64 │\n├─────────┤\n│    1.22 │\n│    1.64 │\n│    2.15 │\n│    2.54 │\n└─────────┘\n>>> t.values.round()\n┏━━━━━━━━━━━━━━━┓\n┃ Round(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ int64         │\n├───────────────┤\n│             1 │\n│             2 │\n│             2 │\n│             3 │\n└───────────────┘\n>>> t.values.round(digits=1)\n┏━━━━━━━━━━━━━━━━━━┓\n┃ Round(values, 1) ┃\n┡━━━━━━━━━━━━━━━━━━┩\n│ float64          │\n├──────────────────┤\n│              1.2 │\n│              1.6 │\n│              2.2 │\n│              2.5 │\n└──────────────────┘\n```\n\n----------------------------------------\n\nTITLE: String Right in Ibis: Extracting Characters from End\nDESCRIPTION: Shows how to use the right function to extract a specified number of characters from the end of strings.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n>>> t.s.right(2)\n┏━━━━━━━━━━━━━━━━┓\n┃ StrRight(s, 2) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ string         │\n├────────────────┤\n│ bc             │\n│ fg             │\n│ lk             │\n└────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Extracting Date Components in Python\nDESCRIPTION: Methods for extracting various date components from a DateValue object, including day, day of year, month, quarter, week of year, and year.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nday()\n\nday_of_year()\n\nmonth()\n\nquarter()\n\nweek_of_year()\n\nyear()\n```\n\n----------------------------------------\n\nTITLE: Listing Available xorq Profiles in Python\nDESCRIPTION: Uses the Profiles collection manager to list all available profiles that have been saved. This provides a way to discover and manage multiple database connection profiles.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nprofiles = Profiles()\nall_profiles = profiles.list()\nprint(f\"Available profiles: {all_profiles}\")\n```\n\n----------------------------------------\n\nTITLE: Creating Time Column from Component Columns in LetsQL\nDESCRIPTION: Demonstrates creating a time column by applying the time function to columns representing hours, minutes, and seconds.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_44\n\nLANGUAGE: python\nCODE:\n```\n>>> t = letsql.memtable({\"h\": [1, 4], \"m\": [2, 5], \"s\": [3, 6]})\n>>> letsql.time(t.h, t.m, t.s).name(\"time\")\n┏━━━━━━━━━━┓\n┃ time     ┃\n┡━━━━━━━━━━┩\n│ time     │\n├──────────┤\n│ 01:02:03 │\n│ 04:05:06 │\n└──────────┘\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NULL Behavior with isin Method in Python\nDESCRIPTION: Examples showing how the isin method handles NULL values in different scenarios.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> t = ibis.memtable({\"x\": [1, 2]})\n>>> t.x.isin([1, None])\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ InValues(x, (1, None)) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ True                   │\n│ NULL                   │\n└────────────────────────┘\n>>> t = ibis.memtable({\"x\": [1, None, 2]})\n>>> t.x.isin([1])\n┏━━━━━━━━━━━━━━━━━━━┓\n┃ InValues(x, (1,)) ┃\n┡━━━━━━━━━━━━━━━━━━━┩\n│ boolean           │\n├───────────────────┤\n│ True              │\n│ NULL              │\n│ False             │\n└───────────────────┘\n>>> t.x.isin([3])\n┏━━━━━━━━━━━━━━━━━━━┓\n┃ InValues(x, (3,)) ┃\n┡━━━━━━━━━━━━━━━━━━━┩\n│ boolean           │\n├───────────────────┤\n│ False             │\n│ NULL              │\n│ False             │\n└───────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating a Profile with Environment Variable References in Python\nDESCRIPTION: Creates a PostgreSQL connection profile using environment variable references instead of hardcoded values, enhancing security by avoiding credential exposure in code.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprofile = Profile(\n    con_name=\"postgres\",\n    kwargs_tuple=(\n        (\"host\", \"${POSTGRES_HOST}\"),\n        (\"port\", 5432),\n        (\"database\", \"postgres\"),\n        (\"user\", \"${POSTGRES_USER}\"),\n        (\"password\", \"${POSTGRES_PASSWORD}\"),\n    ),\n)\n\nprint(profile)\n```\n\n----------------------------------------\n\nTITLE: Computing Exponential Function in Python using Ibis\nDESCRIPTION: Demonstrates how to compute the exponential function (e^x) for values in a numeric column using Ibis. The example creates a memory table with sample values and applies the exp function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": range(4)})\n>>> t.values.exp()\n┏━━━━━━━━━━━━━┓\n┃ Exp(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│    1.000000 │\n│    2.718282 │\n│    7.389056 │\n│   20.085537 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Filtering the PostgreSQL Batting Table\nDESCRIPTION: Applies a filter to the 'batting' table to select only rows where 'yearID' equals 2015. This creates a new filtered relation without modifying the original table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nleft = batting.filter(batting.yearID == 2015)\nleft\n```\n\n----------------------------------------\n\nTITLE: Cloning and Modifying a xorq Profile in Python\nDESCRIPTION: Demonstrates cloning an existing profile and adding new parameters. This is useful for creating variations of profiles while maintaining environment variable references.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ncloned_profile = profile.clone(**{\"connect_timeout\": 10})\nprint(f\"Original profile:\\n{profile}\")\nprint(f\"Cloned profile:\\n{cloned_profile}\")\n```\n\n----------------------------------------\n\nTITLE: Handling Zero Step in LetsQL Range\nDESCRIPTION: Demonstrates that letsql.range returns an empty array when the step is zero, which is a special case handling.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(0, 5, 0)\n[]\n```\n\n----------------------------------------\n\nTITLE: Using isin with Literal Sequence in Python\nDESCRIPTION: Example showing how to check if values in a column are contained in a literal sequence of values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> t.a.isin([1, 2])\n┏━━━━━━━━━━━━━━━━━━━━━┓\n┃ InValues(a, (1, 2)) ┃\n┡━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean             │\n├─────────────────────┤\n│ True                │\n│ True                │\n│ False               │\n└─────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Connection from a xorq Profile in Python\nDESCRIPTION: Creates an active database connection from a profile. This is when environment variables are resolved, but only within the connection object—not in the profile itself.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nconnection = loaded_profile.get_con()\nprint(\"Connection successful!\")\n```\n\n----------------------------------------\n\nTITLE: Computing Cotangent in Python using Ibis\nDESCRIPTION: Shows how to calculate the cotangent of values in a numeric column using Ibis. The example creates a memory table with sample values and applies the cotangent function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, -2, 3]})\n>>> t.values.cot()\n┏━━━━━━━━━━━━━┓\n┃ Cot(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -0.642093 │\n│    0.457658 │\n│   -7.015253 │\n└─────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating In-Memory Tables in Python\nDESCRIPTION: Constructs an ibis table expression from in-memory data sources such as pandas DataFrames, pyarrow Tables, polars DataFrames, or various Python data structures like lists of dictionaries or tuples.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmemtable(data, *, columns=None, schema=None, name=None)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = False\n>>> t = letsql.memtable([{\"a\": 1}, {\"a\": 2}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a\n      0  1\n      1  2\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t = letsql.memtable([{\"a\": 1, \"b\": \"foo\"}, {\"a\": 2, \"b\": \"baz\"}])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t = letsql.memtable([(1, \"foo\"), (2, \"baz\")], columns=[\"a\", \"b\"])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         a    b\n      0  1  foo\n      1  2  baz\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> t = letsql.memtable([(1, \"foo\"), (2, \"baz\")])\n>>> t\nInMemoryTable\n  data:\n    PandasDataFrameProxy:\n         col0 col1\n      0     1  foo\n      1     2  baz\n```\n\n----------------------------------------\n\nTITLE: Extracting Time Components in Python\nDESCRIPTION: Methods for extracting various time components from a TimeValue object, including hour, microsecond, millisecond, minute, and second.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nhour()\n\nmicrosecond()\n\nmillisecond()\n\nminute()\n\nsecond()\n```\n\n----------------------------------------\n\nTITLE: Saving a Cloned xorq Profile in Python\nDESCRIPTION: Saves a cloned and modified profile with a new alias. This allows creating variations of connection profiles for different use cases.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncloned_profile.save(alias=\"postgres_other_db\", clobber=True)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Intersect Operation in LetSQL\nDESCRIPTION: This snippet illustrates how to use the intersect function to find common elements between two tables in LetSQL.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t1 = letsql.memtable({\"a\": [1, 2]})\n>>> t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n>>> t2 = letsql.memtable({\"a\": [2, 3]})\n>>> t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n>>> letsql.intersect(t1, t2)\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n└───────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Test Data Tables for isin Examples in Python\nDESCRIPTION: Creates sample data tables for demonstrating the isin method with different use cases.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2, 3], \"b\": [2, 3, 4]})\n>>> t\n┏━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b     ┃\n┡━━━━━━━╇━━━━━━━┩\n│ int64 │ int64 │\n├───────┼───────┤\n│     1 │     2 │\n│     2 │     3 │\n│     3 │     4 │\n└───────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Aliased Table Expression\nDESCRIPTION: Example showing how to create an aliased table expression and use it in SQL query. Creates a temporary view in the database.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.examples.penguins.fetch()\n>>> expr = t.alias(\"pingüinos\").sql('SELECT * FROM \"pingüinos\" LIMIT 5')\n```\n\n----------------------------------------\n\nTITLE: Capitalizing Strings in Python with Ibis\nDESCRIPTION: Example of using the capitalize() method in Ibis to uppercase the first letter of a string and lowercase the rest. This method follows the semantics of Python's str.capitalize() method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aBC\", \" abc\", \"ab cd\", None]})\n>>> t.s.capitalize()\n┏━━━━━━━━━━━━━━━┓\n┃ Capitalize(s) ┃\n┡━━━━━━━━━━━━━━━┩\n│ string        │\n├───────────────┤\n│ Abc           │\n│  abc          │\n│ Ab cd         │\n│ NULL          │\n└───────────────┘\n```\n\n----------------------------------------\n\nTITLE: Extracting URL Protocol in Ibis\nDESCRIPTION: This snippet shows how to use the protocol() method to extract the protocol from a URL string in Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.protocol()  # https\n```\n\n----------------------------------------\n\nTITLE: UUID Generation in LetSQL\nDESCRIPTION: Example showing how to generate random UUID values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> letsql.uuid()\n```\n\n----------------------------------------\n\nTITLE: Loading SQLite Data in Python with letsql\nDESCRIPTION: Loads data from a SQLite database file in the letsql library. Takes a file path and optional table name parameter. This function lacks detailed documentation in the provided text.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nread_sqlite(path, *, table_name=None)\n```\n\n----------------------------------------\n\nTITLE: Checking Whether Values Are Identical with identical_to in Python\nDESCRIPTION: Example demonstrating how to use the identical_to method to check if two Ibis expressions have the same value. The example shows comparing a literal value 2 with the result of an expression 1+1.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> one = ibis.literal(1)\n>>> two = ibis.literal(2)\n>>> two.identical_to(one + one)\n┌──────┐\n│ True │\n└──────┘\n```\n\n----------------------------------------\n\nTITLE: Using LetsQL Range Function with Start and Stop Arguments\nDESCRIPTION: Shows how to use the range function with start and stop arguments, generating values from 1 to 4.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(1, 5)\n[1, 2, ... +2]\n```\n\n----------------------------------------\n\nTITLE: Truncating Time Expression in Python\nDESCRIPTION: Method to truncate a TimeValue expression to a specified time unit, commonly used for time series resampling.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntruncate(unit)\n```\n\n----------------------------------------\n\nTITLE: Levenshtein Distance in Ibis Python\nDESCRIPTION: Demonstrates calculating Levenshtein (edit) distance between two strings using levenshtein() method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> s = ibis.literal(\"kitten\")\n>>> s.levenshtein(\"sitting\")\n```\n\n----------------------------------------\n\nTITLE: Implementing cume_dist Window Function in Python (letsql)\nDESCRIPTION: Calculates the cumulative distribution of values over a window, representing the fraction of rows that are less than or equal to the current row. This function returns a floating-point column and is used with the .over() method to specify window parameters.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncume_dist()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n>>> t.mutate(dist=letsql.cume_dist().over(order_by=t.values))\n┏━━━━━━━━┳━━━━━━━━━━┓\n┃ values ┃ dist     ┃\n┡━━━━━━━━╇━━━━━━━━━━┩\n│ int64  │ float64  │\n├────────┼──────────┤\n│      1 │ 0.333333 │\n│      1 │ 0.333333 │\n│      2 │ 0.833333 │\n│      2 │ 0.833333 │\n│      2 │ 0.833333 │\n│      3 │ 1.000000 │\n└────────┴──────────┘\n```\n\n----------------------------------------\n\nTITLE: LetsQL Time Function Definition\nDESCRIPTION: Function signature for creating time values, allowing either a direct time value or component specification of hour, minute, and second.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ntime(value_or_hour, minute=None, second=None, /)\n```\n\n----------------------------------------\n\nTITLE: LetsQL to_pyarrow Function Definition\nDESCRIPTION: Function for converting a LetsQL expression to a PyArrow table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nto_pyarrow(expr, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Returning Time Component in Python\nDESCRIPTION: Method to return the time component of a TimeValue expression.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntime()\n```\n\n----------------------------------------\n\nTITLE: Creating Timestamp from String in LetsQL\nDESCRIPTION: Demonstrates creating a timestamp scalar value from a string representation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.timestamp(\"2023-01-02T03:04:05\")\nTimestamp('2023-01-02 03:04:05')\n```\n\n----------------------------------------\n\nTITLE: Examining a Connection's Profile in Python\nDESCRIPTION: Retrieves and examines the profile associated with an active connection. This demonstrates that even after connection, the profile still maintains environment variable references.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nconn_profile = connection._profile\nprint(conn_profile)\n```\n\n----------------------------------------\n\nTITLE: URL Host Extraction in Ibis Python\nDESCRIPTION: Demonstrates extracting host from URLs using host() method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.host()  # example.com\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Empty Range with Invalid Parameters\nDESCRIPTION: Shows that letsql.range returns an empty list when range parameters would produce no values (same as Python's range).\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(0, 7, -1)\n[]\n```\n\n----------------------------------------\n\nTITLE: Exploring and Testing All Available xorq Profiles in Python\nDESCRIPTION: Iterates through all available profiles, displaying their details and attempting to create connections. This demonstrates how to work with multiple profiles in an application.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprofiles = Profiles()\nfor name in profiles.list():\n    p = profiles.get(name)\n    print(f\"Profile: {name}\")\n    print(f\"  - Profile: {p}\")\n    \n    # We're also creating connections, but in production code\n    # you might want to handle exceptions for invalid profiles\n    connection = p.get_con()\n    print(f\"  - Connection: {connection}\")\n```\n\n----------------------------------------\n\nTITLE: Counting Table Rows with Optional Filter\nDESCRIPTION: Method definition for counting rows in a table with an optional where clause for filtering.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncount(where=None)\n```\n\n----------------------------------------\n\nTITLE: Creating Timestamp Column from Component Columns in LetsQL\nDESCRIPTION: Demonstrates creating a timestamp column by applying the timestamp function to columns of date/time components.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> t = letsql.memtable({\"y\": [2001, 2002], \"m\": [1, 4], \"d\": [2, 5], \"h\": [3, 6]})\n>>> letsql.timestamp(t.y, t.m, t.d, t.h, 0, 0).name(\"timestamp\")\n┏━━━━━━━━━━━━━━━━━━━━━┓\n┃ timestamp           ┃\n┡━━━━━━━━━━━━━━━━━━━━━┩\n│ timestamp           │\n├─────────────────────┤\n│ 2001-01-02 03:00:00 │\n│ 2002-04-05 06:00:00 │\n└─────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Timestamp from Components in LetsQL\nDESCRIPTION: Shows how to create a timestamp scalar by providing individual date and time components (year, month, day, hour, minute, second).\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.timestamp(2023, 1, 2, 3, 4, 5)\nTimestamp('2023-01-02 03:04:05')\n```\n\n----------------------------------------\n\nTITLE: Sorting a Table by a Single Column in Descending Order\nDESCRIPTION: Shows how to sort a table by the 'b' column in descending order using the ls.desc() function. The result reverses the default sort order.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> t.order_by(ls.desc(\"b\"))\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     1 │ c      │     5 │\n│     3 │ a      │     4 │\n│     3 │ D      │     7 │\n│     2 │ B      │     6 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Creating a custom PostgreSQL connection in xorq\nDESCRIPTION: Demonstrates how to create a custom PostgreSQL connection by specifying connection parameters such as host, port, user, password, and database name.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/10_minutes_xorq_tour.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npg = xo.postgres.connect(\n  host=\"localhost\",\n  port=5432,\n  user=\"postgres\",\n  password=\"postgres\",\n  database=\"ibis_testing\"\n)\n```\n\n----------------------------------------\n\nTITLE: Connecting to DuckDB and Loading Parquet Data\nDESCRIPTION: Creates a DuckDB connection and uses the deferred_read_parquet utility to load parquet data from a configured path. The data is assigned to a table named 'award_players' in the DuckDB backend.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nbackend = xo.duckdb.connect()\nawards_players = deferred_read_parquet(\n    backend,\n    xo.config.options.pins.get_path(\"awards_players\"),\n    table_name=\"award_players\",\n)\nawards_players\n```\n\n----------------------------------------\n\nTITLE: Saving a Profile Derived from a Connection in Python\nDESCRIPTION: Saves a profile that was extracted from an existing connection. This allows capturing and persisting connection details while maintaining environment variable references.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom_conn_profile.save(alias=\"postgres_from_conn\", clobber=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Time Value from Components in LetsQL\nDESCRIPTION: Shows how to create a time scalar by providing individual components (hour, minute, second).\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.time(1, 2, 3)\ndatetime.time(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using Greatest Function in LetSQL\nDESCRIPTION: This snippet demonstrates the usage of the greatest function in LetSQL to compute the largest value among the supplied arguments.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> letsql.greatest(None, 4, 5)\n5\n```\n\n----------------------------------------\n\nTITLE: Ascending Sort with LetSQL\nDESCRIPTION: Example showing how to sort data in ascending order using the penguins dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(letsql.asc(\"year\")).head()\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram for DuckDB Flight Server Operations\nDESCRIPTION: A mermaid sequence diagram illustrating the interaction between writers, readers, the Flight server, and the DuckDB database. The diagram shows how the server uses a thread lock to manage concurrent operations safely.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/vignettes/duckdb_concurrent.mdx#2025-04-23_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant W1 as Writer 1\n    participant W2 as Writer 2\n    participant FS as Flight Server\n    participant DB as DuckDB\n    participant R as Reader\n    \n    Note over FS: Server initialized with thread lock\n    \n    W1->>FS: Write data request\n    activate FS\n    Note right of FS: Lock acquired\n    FS->>DB: Insert data\n    DB-->>FS: Write successful\n    Note right of FS: Lock released\n    FS-->>W1: Response: Success\n    deactivate FS\n    \n    W2->>FS: Write data request\n    activate FS\n    Note right of FS: Lock acquired\n    FS->>DB: Insert data\n    DB-->>FS: Write successful\n    Note right of FS: Lock released\n    FS-->>W2: Response: Success\n    deactivate FS\n    \n    R->>FS: Query: Count records\n    activate FS\n    Note right of FS: Lock acquired\n    FS->>DB: Execute count query\n    DB-->>FS: Return count\n    Note right of FS: Lock released\n    FS-->>R: Response: Record count\n    deactivate FS\n```\n\n----------------------------------------\n\nTITLE: Creating a Profile from an Existing Connection in Python\nDESCRIPTION: Demonstrates creating a new profile from an existing database connection. The new profile maintains environment variable references rather than exposing actual credentials.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom_conn_profile = Profile.from_con(connection)\nprint(from_conn_profile)\n```\n\n----------------------------------------\n\nTITLE: Checking for NaN in FloatingColumn - Python\nDESCRIPTION: This method is part of the FloatingColumn class and is used to determine if the value in the column is NaN (Not a Number). It takes no parameters and likely returns a boolean value indicating whether the value is NaN or not.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nisnan()\n```\n\n----------------------------------------\n\nTITLE: LetsQL Timestamp Function Definition\nDESCRIPTION: Function signature for creating timestamp values with various parameters including year, month, day, hour, minute, second and timezone.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ntimestamp(\n    value_or_year,\n    month=None,\n    day=None,\n    hour=None,\n    minute=None,\n    second=None,\n    /,\n    timezone=None,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing TimestampValue Class in Python\nDESCRIPTION: Defines the TimestampValue class for handling timestamp expressions in Ibis. It includes methods for extracting date components and truncating timestamps.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nTimestampValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Extracting ASCII Code in Python with Ibis\nDESCRIPTION: Example of using the ascii_str() method in Ibis to return the numeric ASCII code of the first character of a string. This method works on both scalar and column values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n>>> t.s.ascii_str()\n┏━━━━━━━━━━━━━━━━┓\n┃ StringAscii(s) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ int32          │\n├────────────────┤\n│             97 │\n│            100 │\n│            103 │\n└────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings in Python with Ibis\nDESCRIPTION: Definition of the concat() method in Ibis for string concatenation. This method allows concatenating multiple strings and handles NULL values. It is equivalent to using the + operator for string concatenation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconcat(other, *args)\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies with pip\nDESCRIPTION: Command to install the necessary Python packages including xorq, pandas, scikit-learn, and xgboost.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq pandas scikit-learn xgboost\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules for xorq Profiles in Python\nDESCRIPTION: Imports the necessary modules from xorq to work with database connection profiles.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom xorq.vendor.ibis.backends.profiles import Profile, Profiles\n```\n\n----------------------------------------\n\nTITLE: Initializing NumericColumn Class in Ibis\nDESCRIPTION: Base class constructor for NumericColumn in the Ibis library, used for representing numeric data columns in dataframes.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nNumericColumn(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Running XORQ Test Suite\nDESCRIPTION: Commands to test the XORQ codebase, including building the project with maturin, starting a PostgreSQL instance for testing, and running the test suite with pytest.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# make sure you activate the venv using \"source venv/bin/activate\" first\nmaturin develop\njust up postgres # some of the tests use postgres\npython -m pytest # or pytest\n```\n\n----------------------------------------\n\nTITLE: Getting Day of Week Name in Python\nDESCRIPTION: Method to get the full name of the day of the week from a DayOfWeek object.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfull_name()\n```\n\n----------------------------------------\n\nTITLE: Truncating Date Expression in Python\nDESCRIPTION: Method to truncate a DateValue expression to a specified date unit.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntruncate(unit)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Database Connection in Python\nDESCRIPTION: Sets up environment variables for a PostgreSQL database connection. This keeps sensitive credentials out of code and configuration files.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Set environment variables for a PostgreSQL database\nos.environ[\"POSTGRES_DATABASE\"] = \"letsql\"\nos.environ[\"POSTGRES_HOST\"] = \"examples.letsql.com\"\nos.environ[\"POSTGRES_USER\"] = \"letsql\"\nos.environ[\"POSTGRES_PASSWORD\"] = \"letsql\"\nos.environ[\"POSTGRES_PORT\"] = \"5432\"\n```\n\n----------------------------------------\n\nTITLE: Defining Ports for Flight Servers\nDESCRIPTION: Defines the ports where the TF-IDF transformation and XGBoost prediction services will be available for client connections.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Define ports for our servers\ntransform_port = 8915\npredict_port = 8916\n```\n\n----------------------------------------\n\nTITLE: Implementing Ascending Sort Method for Value Expression\nDESCRIPTION: Method to sort a value expression in ascending order with an option to specify null handling behavior.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasc(nulls_first=False)\n```\n\n----------------------------------------\n\nTITLE: Building xorq Expression from Python Script\nDESCRIPTION: CLI command to build the Ibis expression defined in the Python script and generate artifacts.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nxorq build pipeline.py -e expr --builds-dir artifacts\n```\n\n----------------------------------------\n\nTITLE: Unnesting LetsQL Range Results\nDESCRIPTION: Shows how to unnest the array returned by range() function to create a table with individual values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(5).unnest().name(\"numbers\")\n┏━━━━━━━━━┓\n┃ numbers ┃\n┡━━━━━━━━━┩\n│ int8    │\n├─────────┤\n│       0 │\n│       1 │\n│       2 │\n│       3 │\n│       4 │\n└─────────┘\n```\n\n----------------------------------------\n\nTITLE: Initializing TimeValue Class in Python\nDESCRIPTION: Defines the TimeValue class for handling time expressions in Ibis. It includes methods for extracting time components and performing time-based operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nTimeValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: String Replace in Ibis: Substituting Substrings\nDESCRIPTION: Shows how to use the replace function to substitute exact matches of a pattern with a replacement string.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n>>> t.s.replace(\"b\", \"z\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringReplace(s, 'b', 'z') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                     │\n├────────────────────────────┤\n│ azc                        │\n│ zac                        │\n│ zca                        │\n└────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Generating Cache Key for LetsQL Queries\nDESCRIPTION: This private method generates a unique cache key for a given SQL query and its parameters. It uses SHA256 hashing to create a consistent and unique identifier for each query.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py312_test_udaf_caching.txt#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef _generate_cache_key(self, query, params):\n    key = query\n    if params:\n        key += str(params)\n    return hashlib.sha256(key.encode()).hexdigest()\n```\n\n----------------------------------------\n\nTITLE: Initializing LetsQL Cache in Python\nDESCRIPTION: This snippet defines the LetsQLCache class, which initializes the cache with a database connection and cache settings. It sets up the cache structure and prepares for storing query results.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py312_test_udaf_caching.txt#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass LetsQLCache:\n    def __init__(self, db, cache_size=1000, ttl=3600):\n        self.db = db\n        self.cache = {}\n        self.cache_size = cache_size\n        self.ttl = ttl\n        self.last_used = {}\n        self.lock = threading.Lock()\n```\n\n----------------------------------------\n\nTITLE: Creating a Memory Table in LetsQL Python\nDESCRIPTION: Initializes a memory table with sample data containing three columns: integers, strings, and integers. This demonstrates the basic setup for the subsequent sorting examples.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.memtable(\n...     {\n...         \"a\": [3, 2, 1, 3],\n...         \"b\": [\"a\", \"B\", \"c\", \"D\"],\n...         \"c\": [4, 6, 5, 7],\n...     }\n... )\n>>> t\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     3 │ a      │     4 │\n│     2 │ B      │     6 │\n│     1 │ c      │     5 │\n│     3 │ D      │     7 │\n└───────┴────────┴───────┘\n```\n\n----------------------------------------\n\nTITLE: Running xorq Expressions\nDESCRIPTION: Basic syntax for the 'run' command in xorq CLI to execute a built expression and save the results.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nxorq run <build_path> --output-path <output_file> --format <output_format>\n```\n\n----------------------------------------\n\nTITLE: Using LetsQL Range with Negative Step Value\nDESCRIPTION: Shows using the range function with a negative step value to count down from 10 to 6 in steps of 2.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(10, 4, -2)\n[10, 8, ... +1]\n```\n\n----------------------------------------\n\nTITLE: Initializing Ibis and Creating a Sample StringValue\nDESCRIPTION: Sets up Ibis for interactive use and creates a table with a string column for demonstration purposes.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\", \"this has  multi \\t whitespace\"]})\n>>> s = t.s\n```\n\n----------------------------------------\n\nTITLE: Configuring LetsQL Cache Settings in YAML\nDESCRIPTION: This snippet defines the cache configuration for LetsQL. It specifies the cache name, version, and various parameters including maximum size, expiration time, and refresh interval. The configuration also includes settings for logging and garbage collection.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py311_test_udaf_caching.txt#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nletsql_cache-letsql_cache-e5cc4f3ff1e70aefdc4d8a17b5f5cba7\n```\n\n----------------------------------------\n\nTITLE: Specifying ibis-framework Package Version Constraint\nDESCRIPTION: Defines a dependency on ibis-framework version 9.5.0 that is only applicable for Python versions less than 4.0. Uses pip's package version and environment marker syntax.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/vendors.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nibis-framework==9.5.0 ; python_full_version < '4.0'\n```\n\n----------------------------------------\n\nTITLE: Deprecation Notice Methods in Python\nDESCRIPTION: Two deprecated methods dropna and fillna with their replacement methods drop_null and fill_null respectively.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndropna(subset=None, how='any')\n\nfillna(replacements)\n```\n\n----------------------------------------\n\nTITLE: Installing xorq with Examples Dependencies\nDESCRIPTION: Command to install xorq with additional dependencies required to run the example scripts. This installs the core package plus any libraries needed for the examples in the repository.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npip install 'xorq[examples]'\n```\n\n----------------------------------------\n\nTITLE: Checking for Non-NULL Values with notnull in Python\nDESCRIPTION: Example showing how to use the notnull method to check for non-NULL values in a column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nnotnull()\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostgreSQL and Loading a Table\nDESCRIPTION: Establishes a connection to a PostgreSQL database with specified credentials and loads a table named 'batting'. The connection parameters include host, port, user, password, and database name.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npg = xo.postgres.connect(\n    host=\"localhost\",\n    port=5432,\n    user=\"postgres\",\n    password=\"postgres\",\n    database=\"ibis_testing\",\n)\nbatting = pg.table(\"batting\")\nbatting\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to Uppercase using Ibis in Python\nDESCRIPTION: This example demonstrates how to use the upper method to convert strings in a table column to uppercase using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"aaa\", \"A\", \"aa\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ aaa    │\n│ A      │\n│ aa     │\n└────────┘\n>>> t.s.upper()\n┏━━━━━━━━━━━━━━┓\n┃ Uppercase(s) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ AAA          │\n│ A            │\n│ AA           │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Running a saved xorq ML pipeline execution plan\nDESCRIPTION: Command for running a previously saved xorq execution plan, which allows for repeatable execution of ML pipelines.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nxorq run builds/3a81bd906a6d\n```\n\n----------------------------------------\n\nTITLE: Running DuckDB Flight Example with Nix\nDESCRIPTION: Command to run the DuckDB Flight example directly using the Nix package manager. This executes the example script from the xorq-labs GitHub repository.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/vignettes/duckdb_concurrent.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnix run github:xorq-labs # TODO\n```\n\n----------------------------------------\n\nTITLE: Installing xorq Python Package\nDESCRIPTION: Command to install the xorq package from PyPI using pip. This installs the core xorq functionality for building ML pipelines.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install xorq\n```\n\n----------------------------------------\n\nTITLE: Installing xorq using pip\nDESCRIPTION: Command for installing the xorq package using pip, which is the recommended way to install Python packages.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq\n```\n\n----------------------------------------\n\nTITLE: Negating Numeric Values in Python using Ibis\nDESCRIPTION: Demonstrates how to negate values in a numeric column using Ibis. The example creates a memory table with sample values and applies the negate function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.negate()\n┏━━━━━━━━━━━━━━━━┓\n┃ Negate(values) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ int64          │\n├────────────────┤\n│              1 │\n│              0 │\n│             -1 │\n└────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Initializing DayOfWeek Class in Python\nDESCRIPTION: Defines the DayOfWeek class for handling day of week information in Ibis. It provides methods for extracting day names and indices.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nDayOfWeek(self, expr)\n```\n\n----------------------------------------\n\nTITLE: Regenerating Ibis Examples using Python\nDESCRIPTION: This snippet demonstrates how to regenerate Ibis examples using the gen_registry.py script. It includes instructions for setting up the environment and running the script, with an option to test new functions without uploading results.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/vendor/ibis/examples/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npixi shell\npython ibis/examples/gen_registry.py\n```\n\nLANGUAGE: bash\nCODE:\n```\npython ibis/examples/gen_registry.py -d\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for XORQ Tests\nDESCRIPTION: Commands to set the required PostgreSQL database connection environment variables needed for running XORQ tests.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport POSTGRES_DATABASE=ibis_testing\nexport POSTGRES_HOST=localhost\nexport POSTGRES_USER=postgres\nexport POSTGRES_PASSWORD=postgres\nexport POSTGRES_PORT=5432\n```\n\n----------------------------------------\n\nTITLE: Installing xorq using nix for IPython shell\nDESCRIPTION: Command for installing xorq using the nix package manager, which drops you into an IPython shell with xorq available.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/bank-marketing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnix run github:xorq-labs/xorq\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for xorq TF-IDF Pipeline\nDESCRIPTION: Bash command to install the necessary Python packages for the TF-IDF transformation pipeline. Installs xorq, pandas, and scikit-learn which are required for the text processing example.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq pandas scikit-learn \n```\n\n----------------------------------------\n\nTITLE: Extracting Date from Timestamp in Python\nDESCRIPTION: Method to return the date component of a TimestampValue expression.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndate()\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings using Ibis in Python\nDESCRIPTION: This example illustrates how to use the substr method to extract substrings from strings in a table column using Ibis. It extracts substrings starting from the third character.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n>>> t.s.substr(2)\n┏━━━━━━━━━━━━━━━━━┓\n┃ Substring(s, 2) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ c               │\n│ fg              │\n│ jlk             │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: SQL Cache Identifier\nDESCRIPTION: A cache identifier string likely used for SQL query caching or file path reference.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py310_test_udaf_caching.txt#2025-04-23_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\nletsql_cache-letsql_cache-cf3b87cd6e2d96acc934951bb3b23293\n```\n\n----------------------------------------\n\nTITLE: Downloading Test Data for XORQ Project\nDESCRIPTION: Command to download example data needed for running the XORQ test suite, using the just command runner.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\njust download-data\n```\n\n----------------------------------------\n\nTITLE: Initializing Value Class in Ibis\nDESCRIPTION: Definition of the Value class constructor, which serves as the base class for data generating expressions with known types.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key Environment Variable\nDESCRIPTION: Sets up the required OpenAI API key as an environment variable for authentication.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport OPENAI_API_KEY=your_api_key\n```\n\n----------------------------------------\n\nTITLE: Importing Required Python Modules\nDESCRIPTION: Imports necessary Python modules including xorq, pandas, and custom utility modules for HackerNews and OpenAI integration.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_data_prep.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport xorq as xo\nimport xorq.expr.datatypes as dt\n\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.import_utils import import_python\n\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n```\n\n----------------------------------------\n\nTITLE: X.509 Certificate Serial Number in Hexadecimal Format\nDESCRIPTION: A 32-character hexadecimal string representing an X.509 certificate serial number. This value uniquely identifies a certificate within the scope of its issuing Certificate Authority.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/common/utils/tests/snapshots/test_dask_normalize/test_tokenize_pandas_expr/pandas_key.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nb7ee60009e7c435ffb9e95b816b7bd69\n```\n\n----------------------------------------\n\nTITLE: Setting up XORQ Development Environment with pip and venv\nDESCRIPTION: Instructions for setting up a development environment for the XORQ project using pip and Python's venv. This approach clones the repository, creates and activates a virtual environment, installs development dependencies, and sets up git hooks.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# fetch this repo\ngit clone git@github.com:xorq-labs/xorq.git\n# prepare development environment (used to build wheel / install in development)\npython3 -m venv venv\n# activate the venv\nsource venv/bin/activate\n# update pip itself if necessary\npython -m pip install -U pip\n# install dependencies \npython -m pip install -r requirements-dev.txt\n# set up the git hook scripts\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cached Query Results in LetsQL\nDESCRIPTION: This function attempts to retrieve a cached query result. It checks if the result is in the cache and not expired, updating the last used timestamp if found. Returns None if not in cache or expired.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py312_test_udaf_caching.txt#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef get_cached_query(self, query, params=None):\n    cache_key = self._generate_cache_key(query, params)\n    with self.lock:\n        if cache_key in self.cache:\n            cached_item = self.cache[cache_key]\n            if time.time() - cached_item['timestamp'] < self.ttl:\n                self.last_used[cache_key] = time.time()\n                return cached_item['result']\n            else:\n                del self.cache[cache_key]\n                del self.last_used[cache_key]\n    return None\n```\n\n----------------------------------------\n\nTITLE: Running xorq Expression and Saving as CSV\nDESCRIPTION: Example of running a built xorq expression and saving the results as a CSV file.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nxorq run artifacts/2a3b46d8d3d0 --output-path results.csv --format csv\n```\n\n----------------------------------------\n\nTITLE: Importing Required Python Libraries\nDESCRIPTION: Imports necessary Python modules including xorq, pandas, xgboost, and scikit-learn components for machine learning operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport toolz\nimport xgboost as xgb\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import mean_absolute_error, confusion_matrix\n\nimport xorq as xo\nimport xorq.vendor.ibis.expr.datatypes as dt\nfrom xorq.caching import ParquetStorage\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.common.utils.import_utils import import_python\nfrom xorq.expr.ml import (\n    deferred_fit_predict,\n    deferred_fit_transform_series_sklearn,\n    train_test_splits,\n)\n\n# Import the helper modules we used in previous parts\nm = import_python(xo.options.pins.get_path(\"hackernews_lib\"))\no = import_python(xo.options.pins.get_path(\"openai_lib\"))\n```\n\n----------------------------------------\n\nTITLE: Using rstrip to Remove Whitespace from Right Side of Strings in Python with Ibis\nDESCRIPTION: This example demonstrates the use of the rstrip method to remove whitespace from the right side of strings in a table column using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n>>> t.s.rstrip()\n┏━━━━━━━━━━━┓\n┃ RStrip(s) ┃\n┡━━━━━━━━━━━┩\n│ string    │\n├───────────┤\n│ \\ta       │\n│ \\nb       │\n│ \\vc       │\n└───────────┘\n```\n\n----------------------------------------\n\nTITLE: Selecting Arbitrary Values from Columns in Ibis Python\nDESCRIPTION: This example demonstrates how to use the arbitrary() method to select a random value from a column in an Ibis table, including grouping and aggregation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"a\": [1, 2, 2], \"b\": list(\"aaa\"), \"c\": [4.0, 4.1, 4.2]})\n>>> t\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━━━┓\n┃ a     ┃ b      ┃ c       ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━━━┩\n│ int64 │ string │ float64 │\n├───────┼────────┼─────────┤\n│     1 │ a      │     4.0 │\n│     2 │ a      │     4.1 │\n│     2 │ a      │     4.2 │\n└───────┴────────┴─────────┘\n>>> t.group_by(\"a\").agg(arb=t.b.arbitrary(), c=t.c.sum()).order_by(\"a\")\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━━━┓\n┃ a     ┃ arb    ┃ c       ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━━━┩\n│ int64 │ string │ float64 │\n├───────┼────────┼─────────┤\n│     1 │ a      │     4.0 │\n│     2 │ a      │     8.3 │\n└───────┴────────┴─────────┘\n```\n\n----------------------------------------\n\nTITLE: Documenting Project Changelog in Markdown\nDESCRIPTION: This Markdown file documents the changelog for the xorq project, following the Keep a Changelog format and adhering to Semantic Versioning. It includes detailed information about changes, additions, fixes, and removals for multiple versions of the project.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.2.0] - 2025-03-27\n### Details\nThis release enhances xorq with ExprScalarUDF walk_nodes support, multi-duck vignette, import_from_gist functionality, \nand type annotations for deferred reading functions. Key changes centralize parquet fixtures and generalize OpenAI invocation. \nFixes address Postgres HTTP Parquet reading, backend detection, command hashes, and dictionary registration. \nPyO3 warnings and unused exchanger components were removed.\n\n#### Added\n- Add ExprScalarUDF to walk_nodes by @dlovell in [#693](https://github.com/xorq-labs/xorq/pull/693)\n- Add hn part4 by @hussainsultan in [#713](https://github.com/xorq-labs/xorq/pull/713)\n- Add multi-duck vignette by @hussainsultan in [#719](https://github.com/xorq-labs/xorq/pull/719)\n- Add import_from_gist by @dlovell in [#733](https://github.com/xorq-labs/xorq/pull/733)\n- Add uv section by @mesejo in [#730](https://github.com/xorq-labs/xorq/pull/730)\n- Add type annotations to deferred_read_csv and deferred_read_parquet by @soheil-star01 in [#738](https://github.com/xorq-labs/xorq/pull/738)\n\n#### Changed\n- ParquetStorage to build and run by @mesejo in [#684](https://github.com/xorq-labs/xorq/pull/684)\n- Centralize definition of parquet_dir fixture by @dlovell in [#722](https://github.com/xorq-labs/xorq/pull/722)\n- Generalize openai invocation by @dlovell in [#732](https://github.com/xorq-labs/xorq/pull/732)\n- Connect_examples pass kwargs by @dlovell in [#736](https://github.com/xorq-labs/xorq/pull/736)\n\n#### Fixed\n- Postgres deferred_read_parquet fails for http source by @mesejo in [#708](https://github.com/xorq-labs/xorq/pull/708)\n- Spurious backend in _find_backend by @mesejo in [#717](https://github.com/xorq-labs/xorq/pull/717)\n- Update expected command hashes by @dlovell in [#734](https://github.com/xorq-labs/xorq/pull/734)\n- Register dict by @dlovell in [#735](https://github.com/xorq-labs/xorq/pull/735)\n\n#### Removed\n- Remove PyO3 migration warnings by @mesejo in [#707](https://github.com/xorq-labs/xorq/pull/707)\n- Remove unused exchanger by @mesejo in [#715](https://github.com/xorq-labs/xorq/pull/715)\n\n## New Contributors\n* @soheil-star01 made their first contribution in [#738](https://github.com/xorq-labs/xorq/pull/738)\n\n## [0.1.17] - 2025-03-24\n### Details\nThis release enhances xorq documentation with new quickstart guides, HN dataset tutorials, normalization helpers, \nIn the functionality side we added ListActionsAction. We upgraded to DataFusion 45, improved testing infrastructure, and refined core concepts documentation. \nKey fixes address expression optimization, Darwin builds for Python 3.10/3.11, and various dependency updates to ruff, async-trait, and arrow.\n\n#### Added\n- Add quickstart by @hussainsultan in [#654](https://github.com/xorq-labs/xorq/pull/654)\n- Add helpers to identify normalization issues by @dlovell in [#669](https://github.com/xorq-labs/xorq/pull/669)\n- Add exchangers to FlightServer constructor by @dlovell in [#671](https://github.com/xorq-labs/xorq/pull/671)\n- Add hn quickstart example by @hussainsultan in [#675](https://github.com/xorq-labs/xorq/pull/675)\n- Add part 1 of hn data tutorial by @hussainsultan in [#661](https://github.com/xorq-labs/xorq/pull/661)\n- Add hn data tutorial part 2 by @hussainsultan in [#663](https://github.com/xorq-labs/xorq/pull/663)\n- ToolsPackages: add gh by @dlovell in [#673](https://github.com/xorq-labs/xorq/pull/673)\n- Add ListActionsAction by @dlovell in [#706](https://github.com/xorq-labs/xorq/pull/706)\n\n#### Changed\n- Update dependency ruff to v0.10.0 by @renovate[bot] in [#653](https://github.com/xorq-labs/xorq/pull/653)\n- Update extractions/setup-just action to v3 by @renovate[bot] in [#658](https://github.com/xorq-labs/xorq/pull/658)\n- Update dependency ruff to v0.11.0 by @renovate[bot] in [#657](https://github.com/xorq-labs/xorq/pull/657)\n- Update CONTRIBUTING.md by @dlovell in [#664](https://github.com/xorq-labs/xorq/pull/664)\n- Mark snapshot tests by @dlovell in [#665](https://github.com/xorq-labs/xorq/pull/665)\n- Update dependency coverage to v7.7.0 by @renovate[bot] in [#666](https://github.com/xorq-labs/xorq/pull/666)\n- Update readme to use similar language as docs by @hussainsultan in [#674](https://github.com/xorq-labs/xorq/pull/674)\n- Update dependency pre-commit to v4.2.0 by @renovate[bot] in [#681](https://github.com/xorq-labs/xorq/pull/681)\n- Update trinodb/trino docker tag to v473 by @renovate[bot] in [#685](https://github.com/xorq-labs/xorq/pull/685)\n- Update to datafusion 45 by @mesejo in [#672](https://github.com/xorq-labs/xorq/pull/672)\n- Change url in test_read_csv_from_url by @mesejo in [#688](https://github.com/xorq-labs/xorq/pull/688)\n- Move tests to xorq/tests by @mesejo in [#689](https://github.com/xorq-labs/xorq/pull/689)\n- Improve core concepts by @hussainsultan in [#686](https://github.com/xorq-labs/xorq/pull/686)\n- Update dependency ruff to v0.11.1 by @renovate[bot] in [#691](https://github.com/xorq-labs/xorq/pull/691)\n- Update dependency ruff to v0.11.2 by @renovate[bot] in [#698](https://github.com/xorq-labs/xorq/pull/698)\n- Convert expr to table by @mesejo in [#695](https://github.com/xorq-labs/xorq/pull/695)\n- Update trinodb/trino docker tag to v474 by @renovate[bot] in [#702](https://github.com/xorq-labs/xorq/pull/702)\n- Update dependency coverage to v7.7.1 by @renovate[bot] in [#697](https://github.com/xorq-labs/xorq/pull/697)\n- Hotfix darwin build for 3.10,3.11 by @dlovell in [#704](https://github.com/xorq-labs/xorq/pull/704)\n\n#### Fixed\n- Update rust crate async-trait to v0.1.88 by @renovate[bot] in [#656](https://github.com/xorq-labs/xorq/pull/656)\n- Invoke inspect when explicitly requested in normalize_seq_with_caller by @dlovell in [#668](https://github.com/xorq-labs/xorq/pull/668)\n- Warning for not using raw string in regex by @ghoersti in [#676](https://github.com/xorq-labs/xorq/pull/676)\n- Update flake inputs to build with rust 1.85.0 by @dlovell in [#690](https://github.com/xorq-labs/xorq/pull/690)\n- Avoid duplicated execution of expr by removing read_all by @mesejo in [#677](https://github.com/xorq-labs/xorq/pull/677)\n- Update rust crate arrow to v54.3.0 by @renovate[bot] in [#700](https://github.com/xorq-labs/xorq/pull/700)\n- Make action_body a dict by @mesejo in [#692](https://github.com/xorq-labs/xorq/pull/692)\n\n## [0.1.16] - 2025-03-13\n### Details\n#### Added\n- Add tutorials intro section by @mesejo in [#634](https://github.com/xorq-labs/xorq/pull/634)\n\n#### Changed\n- Update bitnami/minio docker tag to v2025.3.12 by @renovate[bot] in [#649](https://github.com/xorq-labs/xorq/pull/649)\n- Update tutorial with new sklearn functions by @mesejo in [#645](https://github.com/xorq-labs/xorq/pull/645)\n- Expose deferred_reads as top level by @mesejo in [#646](https://github.com/xorq-labs/xorq/pull/646)\n- Make udf top level by @mesejo in [#647](https://github.com/xorq-labs/xorq/pull/647)\n\n#### Fixed\n- Infer suffix in read_(parquet/csv) by @mesejo in [#639](https://github.com/xorq-labs/xorq/pull/639)\n- Special case for postgres in case of complex types by @dlovell in [#644](https://github.com/xorq-labs/xorq/pull/644)\n- Update rust crate tokio to v1.44.1 by @renovate[bot] in [#650](https://github.com/xorq-labs/xorq/pull/650)\n\n## [0.1.15] - 2025-03-11\n### Details\nThis release adds a new CLI to xorq. Additionally, it improves the architecture \nthrough consolidated serialization, better caching, and an improved Flight server implementation. Dependencies were updated across the board, \nthe codebase was streamlined by removing unnecessary components, and several critical bugs were fixed to improve stability and reliability.\n\n#### Added\n- FlightServer: add con and client as properties by @dlovell in [#568](https://github.com/xorq-labs/xorq/pull/568)\n- Add xorq build cli command by @mesejo in [#567](https://github.com/xorq-labs/xorq/pull/567)\n- Add importing of notebooks by @mesejo in [#577](https://github.com/xorq-labs/xorq/pull/577)\n- Add deferred_fit_predict by @dlovell in [#595](https://github.com/xorq-labs/xorq/pull/595)\n- Add overview image by @hussainsultan in [#605](https://github.com/xorq-labs/xorq/pull/605)\n- Add to_json/to_csv by @mesejo in [#604](https://github.com/xorq-labs/xorq/pull/604)\n- Add run cli command by @mesejo in [#581](https://github.com/xorq-labs/xorq/pull/581)\n- Add examples tab by @mesejo in [#608](https://github.com/xorq-labs/xorq/pull/608)\n- Add run section of build and run tutorial by @mesejo in [#637](https://github.com/xorq-labs/xorq/pull/637)\n```\n\n----------------------------------------\n\nTITLE: LetsQL execute Function Definition\nDESCRIPTION: Function signature for executing a LetsQL expression, likely running the query against a database.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nexecute(expr, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Installing Mintlify CLI\nDESCRIPTION: Command to install the Mintlify CLI globally using npm package manager. This is required for local development and preview of documentation changes.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g mintlify\n```\n\n----------------------------------------\n\nTITLE: Getting Day of Week Index in Python\nDESCRIPTION: Method to get the index of the day of the week from a DayOfWeek object, following the pandas convention (Monday = 0, Sunday = 6).\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nindex()\n```\n\n----------------------------------------\n\nTITLE: Converting Radians to Degrees in Python using Ibis\nDESCRIPTION: Illustrates how to convert radian values to degrees using Ibis. The example creates a memory table with radian values and applies the degrees function.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> from math import pi\n>>> t = ibis.memtable({\"values\": [0, pi / 2, pi, 3 * pi / 2, 2 * pi]})\n>>> t.values.degrees()\n┏━━━━━━━━━━━━━━━━━┓\n┃ Degrees(values) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│             0.0 │\n│            90.0 │\n│           180.0 │\n│           270.0 │\n│           360.0 │\n└─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: LetsQL get_plans Function Definition\nDESCRIPTION: Function for retrieving execution plans for a LetsQL expression, likely for query optimization analysis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nget_plans(expr)\n```\n\n----------------------------------------\n\nTITLE: Running Local Cache Script\nDESCRIPTION: Command to execute the local cache Python script after setting up the PostgreSQL instance and downloading test data.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/examples/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython local_cache.py\n```\n\n----------------------------------------\n\nTITLE: Adding New Ibis Examples in Python\nDESCRIPTION: This snippet outlines the process of adding new examples to the Ibis project. It describes the structure of the function to be added in gen_registry.py, including data processing, metadata entry, and descriptor file creation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/vendor/ibis/examples/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef new_example_function():\n    # download and process raw data\n    # place processed data in ibis/examples/data/\n    \n    # add entry to metadata dictionary\n    metadata['new_dataset_name'] = {}\n    \n    # add descriptor file\n    # File: ibis/examples/descriptions/new_dataset_name\n    # Contents: Short description of the dataset\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Lowercase in Ibis\nDESCRIPTION: This snippet shows how to use the lower() method to convert strings to lowercase in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"AAA\", \"a\", \"AA\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ AAA    │\n│ a      │\n│ AA     │\n└────────┘\n>>> t.s.lower()\n┏━━━━━━━━━━━━━━┓\n┃ Lowercase(s) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ aaa          │\n│ a            │\n│ aa           │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Building an Expression Artifact using xorq CLI\nDESCRIPTION: Command to build a serialized artifact from a Python expression using the xorq CLI. This enables reproducible and deployable pipelines by converting expressions into serialized files.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# Build an expression from a Python script\nxorq build your_pipeline.py -e \"expr\" --target-dir builds\n```\n\n----------------------------------------\n\nTITLE: Running Mintlify Development Server\nDESCRIPTION: Command to start the Mintlify development server locally. Must be run from the root directory where docs.json is located.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev\n```\n\n----------------------------------------\n\nTITLE: Initializing IntervalValue Class in Python\nDESCRIPTION: Constructor for the IntervalValue class. It takes an 'arg' parameter, but the specific purpose and type of this argument are not provided in the given context.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nIntervalValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Converting Table to Scalar Expression\nDESCRIPTION: Example demonstrating how to convert a table to a scalar expression and use it in filtering operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-relations.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql as ls\n>>> ls.options.interactive = True\n>>> t = ls.examples.penguins.fetch()\n>>> heavy_gentoo = t.filter(t.species == \"Gentoo\", t.body_mass_g > 6200)\n>>> from_that_island = t.filter(t.island == heavy_gentoo.select(\"island\").as_scalar())\n>>> from_that_island.species.value_counts().order_by(\"species\")\n```\n\n----------------------------------------\n\nTITLE: Converting Interval to Specific Unit in Python\nDESCRIPTION: The to_unit method of the IntervalValue class. It takes a target_unit parameter and likely converts the interval to the specified unit. The exact functionality and return type are not provided in the given context.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nto_unit(target_unit)\n```\n\n----------------------------------------\n\nTITLE: Left-Stripping Whitespace in Ibis\nDESCRIPTION: This snippet shows how to use the lstrip() method to remove whitespace from the left side of strings in an Ibis table.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n>>> t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n>>> t.s.lstrip()\n┏━━━━━━━━━━━┓\n┃ LStrip(s) ┃\n┡━━━━━━━━━━━┩\n│ string    │\n├───────────┤\n│ a\\t       │\n│ b\\n       │\n│ c\\t       │\n└───────────┘\n```\n\n----------------------------------------\n\nTITLE: Computing Arc Sine in Ibis\nDESCRIPTION: Method to compute the arc sine of values in a numeric column. The example shows applying asin() to values between -1 and 1, returning results in radians.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-numeric.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasin()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.memtable({\"values\": [-1, 0, 1]})\n>>> t.values.asin()\n┏━━━━━━━━━━━━━━┓\n┃ Asin(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│    -1.570796 │\n│     0.000000 │\n│     1.570796 │\n└──────────────┘\n```\n\n----------------------------------------\n\nTITLE: Installing Xorq via pip and nix\nDESCRIPTION: Instructions for installing the Xorq library using pip package manager or nix environment\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/getting_started/quickstart.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq\n```\n\nLANGUAGE: bash\nCODE:\n```\nnix run github:xorq-labs/xorq\n```\n\n----------------------------------------\n\nTITLE: Generating Empty Range with LetsQL\nDESCRIPTION: Demonstrates creating an empty range when the stop value is 0.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.range(0)\n[]\n```\n\n----------------------------------------\n\nTITLE: Extracting URL Authority in Python with Ibis\nDESCRIPTION: Demonstration of using the authority() method in Ibis to parse a URL and extract the authority component. This method is part of the StringValue class for URL parsing operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.authority()  # user:pass@example.com:80\n```\n\n----------------------------------------\n\nTITLE: Importing Profile Class in Python\nDESCRIPTION: Shows how to import the Profile class from the xorq.vendor.ibis.backends.profiles module.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom xorq.vendor.ibis.backends.profiles import Profile\n```\n\n----------------------------------------\n\nTITLE: Initializing StringValue Class in Python\nDESCRIPTION: Definition of the StringValue class constructor in the Ibis library. This class represents string values and provides various string manipulation methods.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nStringValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: URL Fragment Extraction in Ibis Python\nDESCRIPTION: Shows how to extract fragment identifier from URLs using fragment() method.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\"https://example.com:80/docs/#DOWNLOADING\")\n>>> result = url.fragment()  # DOWNLOADING\n```\n\n----------------------------------------\n\nTITLE: Evicting Least Recently Used Items from LetsQL Cache\nDESCRIPTION: This private method removes the least recently used item from the cache when it reaches its size limit. It helps maintain the cache size and prioritize frequently accessed items.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py312_test_udaf_caching.txt#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef _evict_least_recently_used(self):\n    oldest_key = min(self.last_used, key=self.last_used.get)\n    del self.cache[oldest_key]\n    del self.last_used[oldest_key]\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for XGBoost Model Serving\nDESCRIPTION: Command to install necessary Python packages including xorq, pandas, scikit-learn, and xgboost for model training and serving.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install xorq pandas scikit-learn xgboost\n```\n\n----------------------------------------\n\nTITLE: Extracting User Info from URLs using Ibis in Python\nDESCRIPTION: This snippet shows how to use the userinfo method to extract user information from a URL string using Ibis.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_39\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n>>> result = url.userinfo()  # user:pass\n```\n\n----------------------------------------\n\nTITLE: Return Type Table in Markdown\nDESCRIPTION: Markdown table documenting a method return value that returns a StringValue type from the letsql.vendor.ibis.expr.types.strings package.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_40\n\nLANGUAGE: markdown\nCODE:\n```\n| Name | Type                                                                   | Description            |\n|-------|------------------------------------------------|------------------|\n|      | [StringValue](%60letsql.vendor.ibis.expr.types.strings.StringValue%60) | Extracted string value |\n```\n\n----------------------------------------\n\nTITLE: Translating Characters in Strings using Ibis in Python\nDESCRIPTION: This snippet shows how to use the translate method to replace characters in strings using Ibis. It replaces 'a' with 'b' in the string column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-strings.mdx#2025-04-23_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> table = ibis.table(dict(string_col=\"string\"))\n>>> result = table.string_col.translate(\"a\", \"b\")\n```\n\n----------------------------------------\n\nTITLE: Cloning and Modifying Profiles in Python\nDESCRIPTION: Shows how to create modified copies of existing profiles and save them with new aliases.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Clone with modifications\ncloned_profile = profile.clone(**{\"connect_timeout\": 10})\n\n# Save modified profile\ncloned_profile.save(alias=\"postgres_other_db\", clobber=True)\n```\n\n----------------------------------------\n\nTITLE: Using notnull with Real Data Example in Python\nDESCRIPTION: Demonstrates using the notnull method on a real dataset (penguins) to check for non-NULL values in a column.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import ibis\n>>> ibis.options.interactive = True\n>>> t = ibis.examples.penguins.fetch().limit(5)\n>>> t.bill_depth_mm\n┏━━━━━━━━━━━━━━━┓\n┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│          18.7 │\n│          17.4 │\n│          18.0 │\n│          NULL │\n│          19.3 │\n└───────────────┘\n>>> t.bill_depth_mm.notnull()\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ NotNull(bill_depth_mm) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ True                   │\n│ True                   │\n│ True                   │\n│ False                  │\n│ True                   │\n└────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Handling Environment Variables in Profiles\nDESCRIPTION: Illustrates how profiles store references to environment variables and resolve them when creating connections, ensuring secure handling of sensitive information.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/profiles-api.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\n# Set environment variables\nos.environ[\"POSTGRES_HOST\"] = \"examples.letsql.com\"\nos.environ[\"POSTGRES_USER\"] = \"letsql\"\nos.environ[\"POSTGRES_PASSWORD\"] = \"letsql\"\n\n# Create profile with environment variable references\nprofile = Profile(\n    con_name=\"postgres\",\n    kwargs_tuple=(\n        (\"host\", \"${POSTGRES_HOST}\"),\n        (\"port\", 5432),\n        (\"database\", \"postgres\"),\n        (\"user\", \"${POSTGRES_USER}\"),\n        (\"password\", \"${POSTGRES_PASSWORD}\"),\n    ),\n)\n\n# Profile stores references (${POSTGRES_PASSWORD}), not actual values\nprint(profile.kwargs_dict[\"password\"])  \n\n# Connection resolves environment variables when created\nconn = profile.get_con()\n```\n\n----------------------------------------\n\nTITLE: Testing a Database Connection by Listing Tables in Python\nDESCRIPTION: Verifies a database connection is working by listing available tables in the database. This demonstrates how to use the connection object created from a profile.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/profiles_guide.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntables = connection.list_tables()\nprint(f\"Found tables: {tables[:5]}\")\n```\n\n----------------------------------------\n\nTITLE: Extracting Server Commands for Client Communication\nDESCRIPTION: Extracts the commands that clients can use to interact with the Flight servers. These commands are necessary for invoking the transformation and prediction services.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_serving.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Extract the commands for each server\n(transform_command, predict_command) = (\n    do_exchange.args[1] for do_exchange in (transform_do_exchange, predict_do_exchange)\n)\n```\n\n----------------------------------------\n\nTITLE: Applying TF-IDF Transformation to Test Data in xorq\nDESCRIPTION: Applies the deferred TF-IDF transformation to the test dataset. Uses the same transformation function that was fit on the training data to ensure consistent transformation without information leakage.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_transform_tfidf.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Apply the transformation to the test data\ntest_tfidf_transformed = test_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n```\n\n----------------------------------------\n\nTITLE: Truncating Timestamp Expression in Python\nDESCRIPTION: Method to truncate a TimestampValue expression to a specified time unit.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntruncate(unit)\n```\n\n----------------------------------------\n\nTITLE: Initializing DateValue Class in Python\nDESCRIPTION: Defines the DateValue class for handling date expressions in Ibis. It includes methods for extracting date components and performing date-based operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-temporal.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDateValue(self, arg)\n```\n\n----------------------------------------\n\nTITLE: Using isin with Derived Expression in Python\nDESCRIPTION: Example showing how to check if values in a column are contained in a derived expression.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/expression-generic.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> t.a.isin(t.b + 1)\n┏━━━━━━━━━━━━━━━┓\n┃ InSubquery(a) ┃\n┡━━━━━━━━━━━━━━━┩\n│ boolean       │\n├───────────────┤\n│ False         │\n│ False         │\n│ True          │\n└───────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Time Value from String in LetsQL\nDESCRIPTION: Demonstrates creating a time scalar value from a string representation.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n>>> letsql.time(\"01:02:03\")\ndatetime.time(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Applying TF-IDF Transformation\nDESCRIPTION: Creates and applies TF-IDF transformation to the training data using deferred operations.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/tutorials/hn_training_xgb.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Create the deferred TF-IDF transformation\n(deferred_tfidf_model, tfidf_udaf, deferred_tfidf_transform) = (\n    deferred_fit_transform_tfidf(\n        train_expr,\n        storage=storage,\n    )\n)\n\n# Apply the transformation to the training data\ntrain_tfidf_transformed = train_expr.mutate(\n    **{transformed_col: deferred_tfidf_transform.on_expr}\n)\n```\n\n----------------------------------------\n\nTITLE: LetsQL Date Function Definition\nDESCRIPTION: Function signature for creating date values, allowing either a direct date value or component specification.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ndate(value_or_year, month=None, day=None, /)\n```\n\n----------------------------------------\n\nTITLE: Initializing LetsQL Interactive Mode\nDESCRIPTION: Sets up the LetsQL library for interactive use, which enables formatted output for queries.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n```\n\n----------------------------------------\n\nTITLE: Using Least Function in LetSQL\nDESCRIPTION: This snippet illustrates how to use the least function in LetSQL to compute the smallest value among the supplied arguments.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> letsql.least(None, 4, 5)\n4\n```\n\n----------------------------------------\n\nTITLE: Loading PostgreSQL Data in Python with letsql\nDESCRIPTION: Loads data from a PostgreSQL database in the letsql library. Takes a URI connection string and optional table name. This function lacks detailed documentation in the provided text.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nread_postgres(uri, table_name=None, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Registering a Data Source in letsql\nDESCRIPTION: Function for registering a data source in the letsql library. This function lacks detailed documentation in the provided text.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nregister(source, table_name=None, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Descending Sort with LetSQL\nDESCRIPTION: Example showing how to sort data in descending order using the penguins dataset.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import letsql\n>>> letsql.options.interactive = True\n>>> t = letsql.examples.penguins.fetch()\n>>> t[[\"species\", \"year\"]].order_by(letsql.desc(\"year\")).head()\n```\n\n----------------------------------------\n\nTITLE: Creating Parameters with param() in Python\nDESCRIPTION: Creates a deferred parameter of a specified data type that can be used in expressions and bound to values at execution time. This enables parameterized queries that can be executed with different values.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/api-reference/toplevel-api.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nparam(type)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from datetime import date\n>>> import letsql\n>>> start = letsql.param(\"date\")\n>>> t = letsql.memtable(\n...     {\n...         \"date_col\": [date(2013, 1, 1), date(2013, 1, 2), date(2013, 1, 3)],\n...         \"value\": [1.0, 2.0, 3.0],\n...     },\n... )\n>>> expr = t.filter(t.date_col >= start).value.sum()\n>>> expr.execute(params={start: date(2013, 1, 1)})\n6.0\n>>> expr.execute(params={start: date(2013, 1, 2)})\n5.0\n>>> expr.execute(params={start: date(2013, 1, 3)})\n3.0\n```\n\n----------------------------------------\n\nTITLE: Initializing XORQ with Import Statements\nDESCRIPTION: Imports the XORQ library and utility functions for deferred reading of parquet files and backend operations. Sets the interactive mode to True for better display of results in interactive environments.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/tests/fixtures/pipeline.ipynb#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport xorq as xo\nfrom xorq.common.utils.defer_utils import deferred_read_parquet\nfrom xorq.expr.relations import into_backend\n\n\nxo.options.interactive = True\n```\n\n----------------------------------------\n\nTITLE: Caching Query Results in LetsQL\nDESCRIPTION: This function caches the results of a SQL query. It generates a cache key based on the query and parameters, stores the result in the cache, and manages cache size and expiration.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/python/xorq/backends/let/tests/snapshots/test_cache/test_udaf_caching/py312_test_udaf_caching.txt#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef cache_query(self, query, params=None, result=None):\n    cache_key = self._generate_cache_key(query, params)\n    with self.lock:\n        if len(self.cache) >= self.cache_size:\n            self._evict_least_recently_used()\n        self.cache[cache_key] = {\n            'result': result,\n            'timestamp': time.time()\n        }\n        self.last_used[cache_key] = time.time()\n```\n\n----------------------------------------\n\nTITLE: Building xorq Expressions\nDESCRIPTION: Basic syntax for the 'build' command in xorq CLI to compile an Ibis expression into a reusable artifact.\nSOURCE: https://github.com/xorq-labs/xorq/blob/main/docs/core_concepts/build.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nxorq build <script_path> -e <expression_name> --builds-dir <output_directory>\n```"
  }
]