[
  {
    "owner": "dashbitco",
    "repo": "flow",
    "content": "TITLE: Counting Words in Parallel with Flow - Elixir\nDESCRIPTION: This snippet demonstrates how to leverage the Flow library to implement a parallel word count from a text file in Elixir. It chains several Flow operations—including from_enumerable, flat_map, partition, and reduce—to split text into words, group them efficiently, and tally occurrences in parallel. The result is collected as a list of word-count tuples. Dependencies: Elixir, Flow library, and the input file specified in the File.stream!/1 function.\nSOURCE: https://github.com/dashbitco/flow/blob/master/README.md#_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nFile.stream!(\"path/to/some/file\")\n|> Flow.from_enumerable()\n|> Flow.flat_map(&String.split(&1, \" \"))\n|> Flow.partition()\n|> Flow.reduce(fn -> %{} end, fn word, acc ->\n  Map.update(acc, word, 1, & &1 + 1)\nend)\n|> Enum.to_list()\n```\n\n----------------------------------------\n\nTITLE: Declaring Flow as a Dependency in mix.exs - Elixir\nDESCRIPTION: This snippet shows how to add the Flow library to an Elixir project by including it in the deps function within your mix.exs file. It defines Flow as a tuple with the package name and version constraint, making it available for use after running mix deps.get. Required for integrating Flow-based parallel processing into your application. Prerequisites: Elixir v1.7+, Erlang/OTP 22+.\nSOURCE: https://github.com/dashbitco/flow/blob/master/README.md#_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndef deps do\n  [{:flow, \"~> 1.0\"}]\nend\n```\n\n----------------------------------------\n\nTITLE: Safely Executing Flow Pipelines in Livebook - Elixir\nDESCRIPTION: This snippet illustrates executing a parallel Flow pipeline in an Elixir Livebook session without linking spawned processes. By using Flow.stream/2 with link: false, it prevents failures in the pipeline from affecting the Livebook runtime. The example takes a small enumerable, doubles each element, and gathers the results as a list. Dependencies include Flow and Livebook as the execution environment.\nSOURCE: https://github.com/dashbitco/flow/blob/master/README.md#_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nFlow.from_enumerable([1, 2, 3])\n|> Flow.map(& &1 * 2)\n|> Flow.stream(link: false)\n|> Enum.to_list()\n```\n\n----------------------------------------\n\nTITLE: Migrating map_state/2 to on_trigger/2 - Elixir\nDESCRIPTION: This snippet demonstrates how to update legacy Flow pipelines using map_state/2 to the new on_trigger/2 function. It provides a direct migration path by returning a tuple where the first element is the emitted data and the second is the new state. This pattern is required for compatibility with Flow v0.14.0 and later, where state-manipulating functions were consolidated for conceptual simplicity.\nSOURCE: https://github.com/dashbitco/flow/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n|> Flow.map_state(fn acc -> do_something(acc) end)\n```\n\n----------------------------------------\n\nTITLE: Maintaining State with on_trigger/2 after map_state/2 Deprecation - Elixir\nDESCRIPTION: This example shows a Flow pipeline using on_trigger/2 with {emit, acc} to maintain the accumulator across trigger events. It is a direct replacement for legacy patterns involving map_state/2 and each_state/2 with the :keep strategy, ensuring backward compatibility during migration. The state is not reset between triggers.\nSOURCE: https://github.com/dashbitco/flow/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n|> Flow.on_trigger(fn acc -> {do_something(acc), acc} end)\n```\n\n----------------------------------------\n\nTITLE: Enabling Process Exit Trapping for Flow Computation - Elixir\nDESCRIPTION: This snippet sets the process flag :trap_exit to true before starting a Flow computation in Elixir, ensuring that the parent process can handle unexpected exits from linked Flow processes. This is particularly useful in Livebook or other interactive environments where untrapped exits could terminate the entire session. No parameters or outputs—simply modifies process behavior prior to Flow execution.\nSOURCE: https://github.com/dashbitco/flow/blob/master/README.md#_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nProcess.flag(:trap_exit, true)\n```\n\n----------------------------------------\n\nTITLE: Using on_trigger/2 for State Emission and Accumulation Control - Elixir\nDESCRIPTION: This snippet uses Flow's on_trigger/2 to explicitly specify both the emitted data and the resulting accumulator for each trigger event within a reducing partition. It replaces the map_state/2/each_state/2 pattern from previous Flow versions. The tuple returned by the function must follow the {emitted_data, new_accumulator} format, allowing advanced customization of window and session behavior.\nSOURCE: https://github.com/dashbitco/flow/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n|> Flow.on_trigger(fn acc -> {do_something(acc), []} end)\n```"
  }
]