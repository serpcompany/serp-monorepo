[
  {
    "owner": "msgpack",
    "repo": "msgpack-javascript",
    "content": "TITLE: Encoding and Decoding MessagePack Data in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to encode and decode data using the `@msgpack/msgpack` library. It imports the necessary functions, creates an object, encodes it into a Uint8Array, and then decodes it back, asserting that the decoded object is strictly equal to the original object.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { deepStrictEqual } from \"assert\";\nimport { encode, decode } from \"@msgpack/msgpack\";\n\nconst object = {\n  nil: null,\n  integer: 1,\n  float: Math.PI,\n  string: \"Hello, world!\",\n  binary: Uint8Array.from([1, 2, 3]),\n  array: [10, 20, 30],\n  map: { foo: \"bar\" },\n  timestampExt: new Date(),\n};\n\nconst encoded: Uint8Array = encode(object);\n\ndeepStrictEqual(decode(encoded), object);\n```\n\n----------------------------------------\n\nTITLE: Decoding MessagePack Data to Object in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to decode a `Uint8Array` containing MessagePack-encoded data into a JavaScript object using the `decode` function from the `@msgpack/msgpack` library. The decoded object is then logged to the console.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { decode } from \"@msgpack/msgpack\";\n\nconst encoded: Uint8Array;\nconst object = decode(encoded);\nconsole.log(object);\n```\n\n----------------------------------------\n\nTITLE: Encoding Data to Uint8Array in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to encode a JavaScript object into a `Uint8Array` using the `encode` function from the `@msgpack/msgpack` library. The encoded data is then logged to the console.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { encode } from \"@msgpack/msgpack\";\n\nconst encoded: Uint8Array = encode({ foo: \"bar\" });\nconsole.log(encoded);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Decoding with `decodeAsync` in TypeScript\nDESCRIPTION: This snippet demonstrates how to use `decodeAsync` to decode a stream of MessagePack data asynchronously, typically obtained from a `fetch` request. It checks the `Content-Type` header for `application/x-msgpack` and decodes the response body if the content type matches.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { decodeAsync } from \"@msgpack/msgpack\";\n\nconst MSGPACK_TYPE = \"application/x-msgpack\";\n\nconst response = await fetch(url);\nconst contentType = response.headers.get(\"Content-Type\");\nif (contentType && contentType.startsWith(MSGPACK_TYPE) && response.body != null) {\n  const object = await decodeAsync(response.body);\n  // do something with object\n} else { /* handle errors */ }\n```\n\n----------------------------------------\n\nTITLE: Reusing Encoder and Decoder Instances in TypeScript\nDESCRIPTION: This example demonstrates how to create and reuse `Encoder` and `Decoder` instances for improved performance.  It encodes an object using the encoder and then decodes the encoded data using the decoder. Reusing these instances avoids repeated allocation and initialization costs.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deepStrictEqual } from \"assert\";\nimport { Encoder, Decoder } from \"@msgpack/msgpack\";\n\nconst encoder = new Encoder();\nconst decoder = new Decoder();\n\nconst encoded: Uint8Array = encoder.encode(object);\ndeepStrictEqual(decoder.decode(encoded), object);\n```\n\n----------------------------------------\n\nTITLE: Decoding Multiple MessagePack Objects with Generator in TypeScript\nDESCRIPTION: This TypeScript code snippet illustrates how to decode multiple MessagePack-encoded objects from a single `Uint8Array` using the `decodeMulti` function.  The decoded objects are iterated over using a `for...of` loop, and each object is logged to the console. `decodeMulti` returns a generator.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { decode } from \"@msgpack/msgpack\";\n\nconst encoded: Uint8Array;\n\nfor (const object of decodeMulti(encoded)) {\n  console.log(object);\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding a Blob (TypeScript)\nDESCRIPTION: Asynchronously decodes a Blob containing MessagePack data. It uses either Blob#stream() (recommended for large objects) or Blob#arrayBuffer() to read the Blob's content and then decodes it using decodeAsync or decode respectively.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nasync function decodeFromBlob(blob: Blob): unknown {\n  if (blob.stream) {\n    // Blob#stream(): ReadableStream<Uint8Array> (recommended)\n    return await decodeAsync(blob.stream());\n  } else {\n    // Blob#arrayBuffer(): Promise<ArrayBuffer> (if stream() is not available)\n    return decode(await blob.arrayBuffer());\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Extension Types in TypeScript\nDESCRIPTION: This snippet illustrates how to register custom extension types with an `ExtensionCodec` to handle specific JavaScript types like `Set` and `Map`. It defines the encoding and decoding logic for these types and registers them with the codec.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { encode, decode, ExtensionCodec } from \"@msgpack/msgpack\";\n\nconst extensionCodec = new ExtensionCodec();\n\n// Set<T>\nconst SET_EXT_TYPE = 0 // Any in 0-127\nextensionCodec.register({\n  type: SET_EXT_TYPE,\n  encode: (object: unknown): Uint8Array | null => {\n    if (object instanceof Set) {\n      return encode([...object], { extensionCodec });\n    } else {\n      return null;\n    }\n  },\n  decode: (data: Uint8Array) => {\n    const array = decode(data, { extensionCodec }) as Array<unknown>;\n    return new Set(array);\n  },\n});\n\n// Map<K, V>\nconst MAP_EXT_TYPE = 1; // Any in 0-127\nextensionCodec.register({\n  type: MAP_EXT_TYPE,\n  encode: (object: unknown): Uint8Array => {\n    if (object instanceof Map) {\n      return encode([...object], { extensionCodec });\n    } else {\n      return null;\n    }\n  },\n  decode: (data: Uint8Array) => {\n    const array = decode(data, { extensionCodec }) as Array<[unknown, unknown]>;\n    return new Map(array);\n  },\n});\n\nconst encoded = encode([new Set<any>(), new Map<any, any>()], { extensionCodec });\nconst decoded = decode(encoded, { extensionCodec });\n```\n\n----------------------------------------\n\nTITLE: Decoding Multi Stream with `decodeMultiStream` in TypeScript\nDESCRIPTION: This snippet illustrates how to use `decodeMultiStream` to decode a stream containing multiple independent MessagePack-encoded items. It asynchronously iterates through the stream and logs each decoded item. It functions similarly to `decodeArrayStream` but handles a stream of multiple MessagePack-encoded values rather than an array of encoded values.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { decodeMultiStream } from \"@msgpack/msgpack\";\n\nconst stream: AsyncIterator<Uint8Array>;\n\n// in an async function:\nfor await (const item of decodeMultiStream(stream)) {\n  console.log(item);\n}\n```\n\n----------------------------------------\n\nTITLE: Temporal Module as Timestamp Extensions in TypeScript\nDESCRIPTION: This snippet demonstrates how to map the `@std-proposal/temporal` `Instant` type to the MessagePack timestamp extension. It defines custom encoding and decoding logic to convert `Instant` instances to and from the timestamp format.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Instant } from \"@std-proposal/temporal\";\nimport { deepStrictEqual } from \"assert\";\nimport {\n  encode,\n  decode,\n  ExtensionCodec,\n  EXT_TIMESTAMP,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n} from \"@msgpack/msgpack\";\n\n// to define a custom codec\nconst extensionCodec = new ExtensionCodec();\nextensionCodec.register({\n  type: EXT_TIMESTAMP, // override the default behavior!\n  encode(input: unknown): Uint8Array | null {\n    if (input instanceof Instant) {\n      const sec = input.seconds;\n      const nsec = Number(input.nanoseconds - BigInt(sec) * BigInt(1e9));\n      return encodeTimeSpecToTimestamp({ sec, nsec });\n    } else {\n      return null;\n    }\n  },\n  decode(data: Uint8Array): Instant {\n    const timeSpec = decodeTimestampToTimeSpec(data);\n    const sec = BigInt(timeSpec.sec);\n    const nsec = BigInt(timeSpec.nsec);\n    return Instant.fromEpochNanoseconds(sec * BigInt(1e9) + nsec);\n  },\n});\n\n// to use it\nconst instant = Instant.fromEpochMilliseconds(Date.now());\nconst encoded = encode(instant, { extensionCodec });\nconst decoded = decode(encoded, { extensionCodec });\ndeepStrictEqual(decoded, instant);\n```\n\n----------------------------------------\n\nTITLE: Handling BigInt with Custom ExtensionCodec in TypeScript\nDESCRIPTION: This snippet shows how to handle `BigInt` values using a custom `ExtensionCodec`. It encodes `BigInt` values as either numbers (if within the safe integer range) or strings (otherwise) and decodes them back to `BigInt` values.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deepStrictEqual } from \"assert\";\nimport { encode, decode, ExtensionCodec } from \"@msgpack/msgpack\";\n\n// to define a custom codec:\nconst BIGINT_EXT_TYPE = 0; // Any in 0-127\nconst extensionCodec = new ExtensionCodec();\nextensionCodec.register({\n  type: BIGINT_EXT_TYPE,\n  encode(input: unknown): Uint8Array | null {\n    if (typeof input === \"bigint\") {\n      if (input <= Number.MAX_SAFE_INTEGER && input >= Number.MIN_SAFE_INTEGER) {\n        return encode(Number(input));\n      } else {\n        return encode(String(input));\n      }\n    } else {\n      return null;\n    }\n  },\n  decode(data: Uint8Array): bigint {\n    const val = decode(data);\n    if (!(typeof val === \"string\" || typeof val === \"number\")) {\n      throw new DecodeError(`unexpected BigInt source: ${val} (${typeof val})`);\n    }\n    return BigInt(val);\n  },\n});\n\n// to use it:\nconst value = BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1);\nconst encoded: = encode(value, { extensionCodec });\ndeepStrictEqual(decode(encoded, { extensionCodec }), value);\n```\n\n----------------------------------------\n\nTITLE: Decoding Array Stream with `decodeArrayStream` in TypeScript\nDESCRIPTION: This example showcases the usage of `decodeArrayStream` to process a stream containing an array of MessagePack-encoded items.  It iterates through the stream asynchronously and logs each decoded item.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { decodeArrayStream } from \"@msgpack/msgpack\";\n\nconst stream: AsyncIterator<Uint8Array>;\n\n// in an async function:\nfor await (const item of decodeArrayStream(stream)) {\n  console.log(item);\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Extension Type for Float32Array (TypeScript)\nDESCRIPTION: Defines a custom extension type for handling Float32Array efficiently. The encode function returns a function that aligns the buffer for better performance. The decode function reconstructs the Float32Array from the padded buffer.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst extensionCodec = new ExtensionCodec();\n\nconst EXT_TYPE_FLOAT32ARRAY = 0; // Any in 0-127\nextensionCodec.register({\n  type: EXT_TYPE_FLOAT32ARRAY,\n  encode: (object: unknown) => {\n    if (object instanceof Float32Array) {\n      return (pos: number) => {\n        const bpe = Float32Array.BYTES_PER_ELEMENT;\n        const padding = 1 + ((bpe - ((pos + 1) % bpe)) % bpe);\n        const data = new Uint8Array(object.buffer);\n        const result = new Uint8Array(padding + data.length);\n        result[0] = padding;\n        result.set(data, padding);\n        return result;\n      };\n    }\n    return null;\n  },\n  decode: (data: Uint8Array) => {\n    const padding = data[0]!;\n    const bpe = Float32Array.BYTES_PER_ELEMENT;\n    const offset = data.byteOffset + padding;\n    const length = data.byteLength - padding;\n    return new Float32Array(data.buffer, offset, length / bpe);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using ExtensionCodec with Context in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of an `ExtensionCodec` with a custom context object. The context can be used to track encoded or decoded objects, enabling more complex serialization and deserialization scenarios.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { encode, decode, ExtensionCodec } from \"@msgpack/msgpack\";\n\nclass MyContext {\n  track(object: any) { /*...*/ }\n}\n\nclass MyType { /* ... */ }\n\nconst extensionCodec = new ExtensionCodec<MyContext>();\n\n// MyType\nconst MYTYPE_EXT_TYPE = 0 // Any in 0-127\nextensionCodec.register({\n  type: MYTYPE_EXT_TYPE,\n  encode: (object, context) => {\n    if (object instanceof MyType) {\n      context.track(object); // <-- like this\n      return encode(object.toJSON(), { extensionCodec, context });\n    } else {\n      return null;\n    }\n  },\n  decode: (data, extType, context) => {\n    const decoded = decode(data, { extensionCodec, context });\n    const my = new MyType(decoded);\n    context.track(my); // <-- and like this\n    return my;\n  },\n});\n\n// and later\nimport { encode, decode } from \"@msgpack/msgpack\";\n\nconst context = new MyContext();\n\nconst encoded = = encode({myType: new MyType<any>()}, { extensionCodec, context });\nconst decoded = decode(encoded, { extensionCodec, context });\n```\n\n----------------------------------------\n\nTITLE: Converting Uint8Array to NodeJS Buffer in TypeScript\nDESCRIPTION: This TypeScript code demonstrates converting a `Uint8Array` to a NodeJS `Buffer` without copying the underlying `ArrayBuffer`. It uses `Buffer.from(arrayBuffer, offset, length)` to create a `Buffer` that refers to the same memory as the `Uint8Array`.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { encode } from \"@msgpack/msgpack\";\n\nconst encoded: Uint8Array = encode({ foo: \"bar\" });\n\n// `buffer` refers the same ArrayBuffer as `encoded`.\nconst buffer: Buffer = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);\nconsole.log(buffer);\n```\n\n----------------------------------------\n\nTITLE: CDN Usage (HTML)\nDESCRIPTION: Demonstrates how to include the MessagePack library in an HTML file using a CDN. This loads the library into the global scope as `MessagePack`.\nSOURCE: https://github.com/msgpack/msgpack-javascript/blob/main/README.md#_snippet_15\n\nLANGUAGE: html\nCODE:\n```\n<script crossorigin src=\"https://unpkg.com/@msgpack/msgpack\"></script>\n```"
  }
]