[
  {
    "owner": "facebook",
    "repo": "lexical",
    "content": "TITLE: Setting Up Lexical Editor with Plugins\nDESCRIPTION: Basic setup of a Lexical editor with initial configuration and essential plugins. The LexicalComposer is the root component that provides context to all plugins.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst initialConfig = {\n  namespace: 'MyEditor',\n  theme,\n  onError,\n};\n\n<LexicalComposer initialConfig={initialConfig}>\n  <PlainTextPlugin\n    contentEditable={<ContentEditable />}\n    placeholder={<div>Enter some text...</div>}\n  />\n  <HistoryPlugin />\n  <OnChangePlugin onChange={onChange} />\n  ...\n</LexicalComposer>;\n```\n\n----------------------------------------\n\nTITLE: Implementing EditorRefPlugin\nDESCRIPTION: Implementation of the EditorRefPlugin, which provides a ref to the editor instance that can be accessed outside of the LexicalComposer component, allowing interaction with the editor from other parts of the application.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nconst editorRef = useRef(null);\n<EditorRefPlugin editorRef={editorRef} />;\n```\n\n----------------------------------------\n\nTITLE: Building a basic plain text editor with Lexical in React\nDESCRIPTION: Complete example of implementing a plain text editor using Lexical and @lexical/react components. The code demonstrates the composition of Lexical plugins, state management, and custom plugin creation.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-react/README.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {$getRoot, $getSelection} from 'lexical';\nimport {useEffect} from 'react';\n\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {OnChangePlugin} from '@lexical/react/LexicalOnChangePlugin';\nimport {useLexicalComposerContext} from '@lexical/react/LexicalComposerContext';\n\nconst theme = {\n  // Theme styling goes here\n  ...\n}\n\n// When the editor changes, you can get notified via the\n// LexicalOnChangePlugin!\nfunction onChange(editorState) {\n  editorState.read(() => {\n    // Read the contents of the EditorState here.\n    const root = $getRoot();\n    const selection = $getSelection();\n\n    console.log(root, selection);\n  });\n}\n\n// Lexical React plugins are React components, which makes them\n// highly composable. Furthermore, you can lazy load plugins if\n// desired, so you don't pay the cost for plugins until you\n// actually use them.\nfunction MyCustomAutoFocusPlugin() {\n  const [editor] = useLexicalComposerContext();\n\n  \n\nuseEffect(() => {\n    // Focus the editor when the effect fires!\n    editor.focus();\n  }, [editor]);\n\n  return null;\n}\n\n// Catch any errors that occur during Lexical updates and log them\n// or throw them as needed. If you don't throw them, Lexical will\n// try to recover gracefully without losing user data.\nfunction onError(error) {\n  throw error;\n}\n\nfunction Editor() {\n  const initialConfig = {\n    namespace: 'MyEditor',\n    theme,\n    onError,\n  };\n\nreturn (\n    <LexicalComposer initialConfig={initialConfig}>\n      <PlainTextPlugin\n        contentEditable={\n          <ContentEditable\n            aria-placeholder={'Enter some text...'}\n            placeholder={<div>Enter some text...</div>}\n          />\n        }\n      />\n      <OnChangePlugin onChange={onChange} />\n      <HistoryPlugin />\n      <MyCustomAutoFocusPlugin />\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Unregistering a Lexical Editor Update Listener\nDESCRIPTION: This snippet demonstrates how to register an update listener to a Lexical editor instance and properly unregister it later. The listener receives the editorState object whenever an update occurs in the editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/intro.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst unregisterListener = editor.registerUpdateListener(({editorState}) => {\n  // An update has occurred!\n  console.log(editorState);\n});\n\n// Ensure we remove the listener later!\nunregisterListener();\n```\n\n----------------------------------------\n\nTITLE: Basic React Text Editor Implementation\nDESCRIPTION: Complete example of implementing a basic plain text editor using Lexical with React, including plugins for history management, change detection, and auto-focus functionality\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {$getRoot, $getSelection} from 'lexical';\nimport {useEffect} from 'react';\n\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {OnChangePlugin} from '@lexical/react/LexicalOnChangePlugin';\nimport {useLexicalComposerContext} from '@lexical/react/LexicalComposerContext';\nimport {LexicalErrorBoundary} from '@lexical/react/LexicalErrorBoundary';\n\nconst theme = {\n  // Theme styling goes here\n  // ...\n}\n\n// When the editor changes, you can get notified via the\n// LexicalOnChangePlugin!\nfunction onChange(editorState) {\n  editorState.read(() => {\n    // Read the contents of the EditorState here.\n    const root = $getRoot();\n    const selection = $getSelection();\n\n    console.log(root, selection);\n  });\n}\n\n// Lexical React plugins are React components, which makes them\n// highly composable. Furthermore, you can lazy load plugins if\n// desired, so you don't pay the cost for plugins until you\n// actually use them.\nfunction MyCustomAutoFocusPlugin() {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    // Focus the editor when the effect fires!\n    editor.focus();\n  }, [editor]);\n\n  return null;\n}\n\n// Catch any errors that occur during Lexical updates and log them\n// or throw them as needed. If you don't throw them, Lexical will\n// try to recover gracefully without losing user data.\nfunction onError(error) {\n  console.error(error);\n}\n\nfunction Editor() {\n  const initialConfig = {\n    namespace: 'MyEditor',\n    theme,\n    onError,\n  };\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <PlainTextPlugin\n        contentEditable={\n          <ContentEditable\n            aria-placeholder={'Enter some text...'}\n            placeholder={<div>Enter some text...</div>}\n          />\n        }\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n      <OnChangePlugin onChange={onChange} />\n      <HistoryPlugin />\n      <MyCustomAutoFocusPlugin />\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Editor State Saving in React with Lexical\nDESCRIPTION: An example of how to use the custom OnChange plugin to save the Lexical editor state in a React component. It demonstrates serializing the editor state to JSON for storage or transmission.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/react.md#2025-04-13_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nfunction MyOnChangePlugin({ onChange }) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    return editor.registerUpdateListener(({editorState}) => {\n      onChange(editorState);\n    });\n  }, [editor, onChange]);\n  return null;\n}\n\nfunction Editor() {\n  // ...\n\n  const [editorState, setEditorState] = useState();\n  function onChange(editorState) {\n    // Call toJSON on the EditorState object, which produces a serialization safe string\n    const editorStateJSON = editorState.toJSON();\n    // However, we still have a JavaScript object, so we need to convert it to an actual string with JSON.stringify\n    setEditorState(JSON.stringify(editorStateJSON));\n  }\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      {/*...*/}\n      <MyOnChangePlugin onChange={onChange}/>\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical State to JSON\nDESCRIPTION: Shows how to serialize Lexical editor state to JSON format.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst editorState = editor.getEditorState();\nconst json = editorState.toJSON();\n\n// Alternative stringified version\nconst jsonString = JSON.stringify(editorState);\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Rich Text Editor with Lexical and React\nDESCRIPTION: Example of setting up a basic rich text editor using Lexical and React components. It includes error handling, theming, and essential plugins like RichTextPlugin, HistoryPlugin, and AutoFocusPlugin.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/react.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {$getRoot, $getSelection} from 'lexical';\nimport {useEffect} from 'react';\n\nimport {AutoFocusPlugin} from '@lexical/react/LexicalAutoFocusPlugin';\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {RichTextPlugin} from '@lexical/react/LexicalRichTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {LexicalErrorBoundary} from '@lexical/react/LexicalErrorBoundary';\n\nconst theme = {\n  // Theme styling goes here\n  //...\n}\n\n// Catch any errors that occur during Lexical updates and log them\n// or throw them as needed. If you don't throw them, Lexical will\n// try to recover gracefully without losing user data.\nfunction onError(error) {\n  console.error(error);\n}\n\nfunction Editor() {\n  const initialConfig = {\n    namespace: 'MyEditor',\n    theme,\n    onError,\n  };\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <RichTextPlugin\n        contentEditable={\n          <ContentEditable\n            aria-placeholder={'Enter some text...'}\n            placeholder={<div>Enter some text...</div>}\n          />\n        }\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n      <HistoryPlugin />\n      <AutoFocusPlugin />\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Nodes in Lexical Configuration\nDESCRIPTION: This snippet shows how to register custom nodes in the initialConfig object when using Lexical. Custom nodes must be registered before they can be used in plugins.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/create_plugin.md#2025-04-13_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst initialConfig = {\n  namespace: 'MyEditor',\n  nodes: [MyLexicalNode],\n};\n```\n\n----------------------------------------\n\nTITLE: Transform with Precondition to Prevent Infinite Loops\nDESCRIPTION: Example showing how to implement a transform with a proper precondition check. This prevents the transform from running multiple times unnecessarily by checking the current state before applying changes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// When a TextNode changes (marked as dirty) make it bold\neditor.registerNodeTransform(TextNode, textNode => {\n  // Important: Check current format state\n  if (!textNode.hasFormat('bold')) {\n    textNode.toggleFormat('bold');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Setting Selection in Lexical (JavaScript)\nDESCRIPTION: Shows how to create new selections (RangeSelection and NodeSelection) and set them as the current selection in Lexical. Also demonstrates node selection methods and clearing the selection.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/selection.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$setSelection, $createRangeSelection, $createNodeSelection} from 'lexical';\n\neditor.update(() => {\n  // Set a range selection\n  const rangeSelection = $createRangeSelection();\n  $setSelection(rangeSelection);\n\n  // You can also indirectly create a range selection, by calling some of the selection\n  // methods on Lexical nodes.\n  const someNode = $getNodeByKey(someKey);\n\n  // On element nodes, this will create a RangeSelection with type \"element\",\n  // referencing an offset relating to the child within the element.\n  // On text nodes, this will create a RangeSelection with type \"text\",\n  // referencing the text character offset.\n  someNode.select();\n  someNode.selectPrevious();\n  someNode.selectNext();\n\n  // You can use this on any node.\n  someNode.selectStart();\n  someNode.selectEnd();\n\n  // Set a node selection\n  const nodeSelection = $createNodeSelection();\n  // Add a node key to the selection.\n  nodeSelection.add(someKey);\n  $setSelection(nodeSelection);\n\n  // You can also clear selection by setting it to `null`.\n  $setSelection(null);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Lexical Editor Instance with Configuration\nDESCRIPTION: Demonstrates how to initialize a Lexical editor with a basic configuration object that includes namespace, theme, and error handling settings.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/quick-start.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createEditor} from 'lexical';\n\nconst config = {\n  namespace: 'MyEditor',\n  theme: {\n    ...\n  },\n  onError: console.error\n};\n\nconst editor = createEditor(config);\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical and React Dependencies\nDESCRIPTION: Command to install the required npm packages for Lexical and React integration.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/react.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save lexical @lexical/react\n```\n\n----------------------------------------\n\nTITLE: Initializing and Persisting Lexical Editor State\nDESCRIPTION: Example showing how to initialize a Lexical editor with state loaded from a backend and then persist changes. Demonstrates the basic pattern of loading and saving editor state.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// Get editor initial state (e.g. loaded from backend)\nconst loadContent = async () => {\n  // 'empty' editor\n  const value = '{\"root\":{\"children\":[{\"children\":[],\"direction\":null,\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":null,\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}';\n\n  return value;\n}\n\nconst initialEditorState = await loadContent();\nconst editor = createEditor(...);\nregisterRichText(editor, initialEditorState);\n\n...\n\n// Handler to store content (e.g. when user submits a form)\nconst onSubmit = () => {\n  await saveContent(JSON.stringify(editor.getEditorState()));\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning Lexical Editor State with Custom Selection\nDESCRIPTION: Example showing how to clone editor state with a custom selection, useful when setting editor state without forcing focus by passing null as the selection value.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_8\n\nLANGUAGE: js\nCODE:\n```\n// Passing `null` as a selection value to prevent focusing the editor\neditor.setEditorState(editorState.clone(null));\n```\n\n----------------------------------------\n\nTITLE: Updating Lexical Editor Content with Node Manipulation\nDESCRIPTION: Demonstrates how to use editor.update() to modify the editor content by creating and appending paragraph and text nodes to the editor root. This showcases Lexical's node-based content model.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical/README.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$getRoot, $getSelection} from 'lexical';\nimport {$createParagraphNode} from 'lexical/PargraphNode';\n\n// Inside the `editor.update` you can use special $ prefixed helper functions.\n// These functions cannot be used outside the closure, and will error if you try.\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\n// outside of a React function component).\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Lexical Editor Instance\nDESCRIPTION: Demonstrates how to create a new Lexical editor instance with configuration options including namespace and theme settings.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createEditor} from 'lexical';\n\nconst config = {\n  namespace: 'MyEditor',\n  theme: {\n    ...\n  },\n};\n\nconst editor = createEditor(config);\n```\n\n----------------------------------------\n\nTITLE: ElementNode Utility Functions\nDESCRIPTION: Utility functions for creating and type checking custom ElementNodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport function $createCustomParagraphNode(): CustomParagraph {\n  return new CustomParagraph();\n}\n\nexport function $isCustomParagraphNode(node: LexicalNode | null | undefined): node is CustomParagraph  {\n  return node instanceof CustomParagraph;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Lexical Editor State\nDESCRIPTION: Shows how to convert an editor state to JSON string and parse it back, enabling serialization and persistence of editor content.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical/README.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst stringifiedEditorState = JSON.stringify(editor.getEditorState().toJSON());\n\nconst newEditorState = editor.parseEditorState(stringifiedEditorState);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Lexical Commands\nDESCRIPTION: Example of using createCommand() to define a custom typed command, dispatch it with a payload, and register a listener with priority to handle it.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/commands.md#2025-04-13_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst HELLO_WORLD_COMMAND: LexicalCommand<string> = createCommand();\n\neditor.dispatchCommand(HELLO_WORLD_COMMAND, 'Hello World!');\n\neditor.registerCommand(\n  HELLO_WORLD_COMMAND,\n  (payload: string) => {\n    console.log(payload); // Hello World!\n    return false;\n  },\n  LowPriority,\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing MarkdownShortcutPlugin\nDESCRIPTION: Implementation of the MarkdownShortcutPlugin, which adds support for Markdown-style shortcuts for creating headings, lists, code blocks, quotes, links, and applying inline formatting.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n<MarkdownShortcutPlugin />\n```\n\n----------------------------------------\n\nTITLE: Configuring Node Replacements in Lexical\nDESCRIPTION: Shows how to configure node replacements in the editor config to override default Lexical nodes with custom implementations. Includes options for replacement transformation and class association.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/node-replacement.md#2025-04-13_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst editorConfig = {\n    ...\n    nodes=[\n        // Don't forget to register your custom node separately!\n        CustomParagraphNode,\n        {\n            replace: ParagraphNode,\n            with: (node: ParagraphNode) => {\n                return new CustomParagraphNode();\n            },\n            withKlass: CustomParagraphNode,\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Theme Configuration\nDESCRIPTION: Shows a complete theme configuration object that includes styling for all supported Lexical editor features including headings, lists, code highlighting, and text formatting.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/theming.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst exampleTheme = {\n  ltr: 'ltr',\n  rtl: 'rtl',\n  paragraph: 'editor-paragraph',\n  quote: 'editor-quote',\n  heading: {\n    h1: 'editor-heading-h1',\n    h2: 'editor-heading-h2',\n    h3: 'editor-heading-h3',\n    h4: 'editor-heading-h4',\n    h5: 'editor-heading-h5',\n    h6: 'editor-heading-h6',\n  },\n  list: {\n    nested: {\n      listitem: 'editor-nested-listitem',\n    },\n    ol: 'editor-list-ol',\n    ul: 'editor-list-ul',\n    listitem: 'editor-listItem',\n    listitemChecked: 'editor-listItemChecked',\n    listitemUnchecked: 'editor-listItemUnchecked',\n  },\n  hashtag: 'editor-hashtag',\n  image: 'editor-image',\n  link: 'editor-link',\n  text: {\n    bold: 'editor-textBold',\n    code: 'editor-textCode',\n    italic: 'editor-textItalic',\n    strikethrough: 'editor-textStrikethrough',\n    subscript: 'editor-textSubscript',\n    superscript: 'editor-textSuperscript',\n    underline: 'editor-textUnderline',\n    underlineStrikethrough: 'editor-textUnderlineStrikethrough',\n  },\n  code: 'editor-code',\n  codeHighlight: {\n    atrule: 'editor-tokenAttr',\n    attr: 'editor-tokenAttr',\n    boolean: 'editor-tokenProperty',\n    builtin: 'editor-tokenSelector',\n    cdata: 'editor-tokenComment',\n    char: 'editor-tokenSelector',\n    class: 'editor-tokenFunction',\n    'class-name': 'editor-tokenFunction',\n    comment: 'editor-tokenComment',\n    constant: 'editor-tokenProperty',\n    deleted: 'editor-tokenProperty',\n    doctype: 'editor-tokenComment',\n    entity: 'editor-tokenOperator',\n    function: 'editor-tokenFunction',\n    important: 'editor-tokenVariable',\n    inserted: 'editor-tokenSelector',\n    keyword: 'editor-tokenAttr',\n    namespace: 'editor-tokenVariable',\n    number: 'editor-tokenProperty',\n    operator: 'editor-tokenOperator',\n    prolog: 'editor-tokenComment',\n    property: 'editor-tokenProperty',\n    punctuation: 'editor-tokenPunctuation',\n    regex: 'editor-tokenVariable',\n    selector: 'editor-tokenSelector',\n    string: 'editor-tokenSelector',\n    symbol: 'editor-tokenProperty',\n    tag: 'editor-tokenProperty',\n    url: 'editor-tokenOperator',\n    variable: 'editor-tokenVariable',\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Lexical Editor State with editor.update()\nDESCRIPTION: Example demonstrating how to modify the editor state using the editor.update() method, which provides access to special $ prefixed helper functions for manipulating nodes within the editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport {$getRoot, $getSelection} from 'lexical';\nimport {$createParagraphNode} from 'lexical';\n\n// Inside the `editor.update` you can use special $ prefixed helper functions.\n// These functions cannot be used outside the closure, and will error if you try.\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\n// outside of a React function component).\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n```\n\n----------------------------------------\n\nTITLE: RegisterLexicalTextEntity TypeScript Definition\nDESCRIPTION: TypeScript definition for the registerLexicalTextEntity utility, which creates a specialized transform for handling text entities like hashtags or mentions. This function handles the creation and destruction of nodes based on text content.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nregisterLexicalTextEntity<N: TextNode>(\n  editor: LexicalEditor,\n  getMatch: (text: string) => null | EntityMatch,\n  targetNode: Class<N>,\n  createNode: (textNode: TextNode) => N,\n): Array<() => void>;\n```\n\n----------------------------------------\n\nTITLE: Registering Lexical Command Listeners\nDESCRIPTION: Examples of registering command listeners with proper cleanup. Shows the basic pattern of returning the cleanup function and using useEffect for automatic cleanup in React components.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/commands.md#2025-04-13_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst removeListener = editor.registerCommand(\n  COMMAND,\n  (payload) => boolean, // Return true to stop propagation.\n  priority,\n);\n// ...\nremoveListener(); // Cleans up the listener.\n```\n\nLANGUAGE: jsx\nCODE:\n```\nuseEffect(() => {\n  return editor.registerCommand(\n    TOGGLE_LINK_COMMAND,\n    (payload) => {\n      const url: string | null = payload;\n      setLink(url);\n      return true;\n    },\n    COMMAND_PRIORITY_EDITOR,\n  );\n}, [editor]);\n```\n\nLANGUAGE: js\nCODE:\n```\neditor.registerCommand(\n  KEY_TAB_COMMAND,\n  (payload) => {\n    const event: KeyboardEvent = payload;\n    event.preventDefault();\n    return editor.dispatchCommand(\n      event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND,\n    );\n  },\n  COMMAND_PRIORITY_EDITOR,\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Properties in JavaScript\nDESCRIPTION: Example showing how to properly implement node properties with getter/setter methods and required static methods in a custom Lexical node.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport type {NodeKey} from 'lexical';\n\nclass MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  constructor(foo: string, key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  setFoo(foo: string) {\n    // getWritable() creates a clone of the node\n    // if needed, to ensure we don't try and mutate\n    // a stale version of this node.\n    const self = this.getWritable();\n    self.__foo = foo;\n  }\n\n  getFoo(): string {\n    // getLatest() ensures we are getting the most\n    // up-to-date value from the EditorState.\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Lexical Content to HTML String\nDESCRIPTION: This code snippet shows how to convert Lexical content to an HTML string. It uses the $generateHtmlFromNodes function, which can optionally take a selection object to export only a specific part of the editor's contents.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// When converting to HTML you can pass in a selection object to narrow it\n// down to a certain part of the editor's contents.\nconst htmlString = $generateHtmlFromNodes(editor, selection | null);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Twitter Embed Plugin for Lexical\nDESCRIPTION: This example shows a complete implementation of a TwitterPlugin that registers a command for inserting tweet nodes into the editor. It demonstrates command registration, node creation, and error checking for node registration.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/create_plugin.md#2025-04-13_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport const INSERT_TWEET_COMMAND: LexicalCommand<string> = createCommand();\n\nexport default function TwitterPlugin(): JSX.Element | null {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    if (!editor.hasNodes([TweetNode])) {\n      throw new Error('TwitterPlugin: TweetNode not registered on editor (initialConfig.nodes)');\n    }\n\n    return editor.registerCommand<string>(\n      INSERT_TWEET_COMMAND,\n      (payload) => {\n        const tweetNode = $createTweetNode(payload);\n        $insertNodeToNearestRoot(tweetNode);\n\n        return true;\n      },\n      COMMAND_PRIORITY_EDITOR,\n    );\n  }, [editor]);\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Basic TextNode Transform in JavaScript\nDESCRIPTION: Example of registering a node transform that changes the text content from 'blue' to 'green'. This demonstrates the basic syntax for creating a transform that responds to text content changes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeTransform = editor.registerNodeTransform(TextNode, (textNode) => {\n  if (textNode.getTextContent() === 'blue') {\n    textNode.setTextContent('green');\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Lexical Editor with Extended TextNode\nDESCRIPTION: JavaScript configuration for a Lexical editor that overrides the base TextNode with an ExtendedTextNode to handle additional styling properties.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst initialConfig: InitialConfigType = {\n    namespace: 'editor',\n    theme: editorThemeClasses,\n    onError: (error: any) => console.log(error),\n    nodes: [\n      ExtendedTextNode,\n      {\n        replace: TextNode,\n        with: (node: TextNode) => new ExtendedTextNode(node.__text),\n        withKlass: ExtendedTextNode,\n      },\n      ListNode,\n      ListItemNode,\n    ]\n  };\n```\n\n----------------------------------------\n\nTITLE: Implementing ListPlugin\nDESCRIPTION: Implementation of the ListPlugin, which adds support for both ordered and unordered lists in the Lexical editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<ListPlugin />\n```\n\n----------------------------------------\n\nTITLE: Implementing VideoNode Decorator in TypeScript\nDESCRIPTION: Creates a custom DecoratorNode implementation for handling video content in Lexical. Includes core node methods like clone, createDOM, updateDOM, and decorate along with helper functions for node creation and type checking.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport class VideoNode extends DecoratorNode<ReactNode> {\n  __id: string;\n\n  static getType(): string {\n    return 'video';\n  }\n\n  static clone(node: VideoNode): VideoNode {\n    return new VideoNode(node.__id, node.__key);\n  }\n\n  constructor(id: string, key?: NodeKey) {\n    super(key);\n    this.__id = id;\n  }\n\n  createDOM(): HTMLElement {\n    return document.createElement('div');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  decorate(): ReactNode {\n    return <VideoPlayer videoID={this.__id} />;\n  }\n}\n\nexport function $createVideoNode(id: string): VideoNode {\n  return new VideoNode(id);\n}\n\nexport function $isVideoNode(\n  node: LexicalNode | null | undefined,\n): node is VideoNode {\n  return node instanceof VideoNode;\n}\n```\n\n----------------------------------------\n\nTITLE: HeadingNode JSON Export/Import Implementation\nDESCRIPTION: Example of implementing exportJSON and importJSON methods for a custom HeadingNode.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SerializedHeadingNode = Spread<\n  {\n    tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  },\n  SerializedElementNode\n>;\n\nexportJSON(): SerializedHeadingNode {\n  return {\n    ...super.exportJSON(),\n    tag: this.getTag(),\n  };\n}\n\nstatic importJSON(serializedNode: SerializedHeadingNode): HeadingNode {\n  return $createHeadingNode().updateFromJSON(serializedNode);\n}\n\nupdateFromJSON(\n  serializedNode: LexicalUpdateJSON<SerializedHeadingNode>,\n): this {\n  return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Update Tags with $addUpdateTag() in Lexical\nDESCRIPTION: Shows how to add tags to a Lexical editor update using the $addUpdateTag() function within an update callback. This allows tagging updates from inside the update function.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {HISTORY_PUSH_TAG} from 'lexical';\n\neditor.update(() => {\n  $addUpdateTag(HISTORY_PUSH_TAG);\n  // Your update code\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom EmojiNode Extending TextNode in TypeScript\nDESCRIPTION: This code defines a custom EmojiNode class that extends Lexical's TextNode. It includes methods for cloning, DOM creation, and JSON import/export.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/creating-plugin.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class EmojiNode extends TextNode {\n  __unifiedID: string;\n\n  static getType(): string {\n    return 'emoji';\n  }\n\n  static clone(node: EmojiNode): EmojiNode {\n    return new EmojiNode(node.__unifiedID, node.__key);\n  }\n\n  constructor(unifiedID: string, key?: NodeKey) {\n    const unicodeEmoji = /*...*/;\n    super(unicodeEmoji, key);\n\n    this.__unifiedID = unifiedID.toLowerCase();\n  }\n\n  createDOM(_config: EditorConfig): HTMLElement {\n    const dom = document.createElement('span');\n    dom.className = 'emoji-node';\n    dom.style.backgroundImage = `url('${BASE_EMOJI_URI}/${this.__unifiedID}.png')`;\n    dom.innerText = this.__text;\n\n    return dom;\n  }\n\n  static importJSON(serializedNode: SerializedEmojiNode): EmojiNode {\n    return $createEmojiNode(serializedNode.unifiedID).updateFromJSON(serializedNode);\n  }\n\n  exportJSON(): SerializedEmojiNode {\n    return {\n      ...super.exportJSON(),\n      unifiedID: this.__unifiedID,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical State to HTML\nDESCRIPTION: Demonstrates how to generate HTML from Lexical editor state using the $generateHtmlFromNodes utility.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$generateHtmlFromNodes} from '@lexical/html';\n\nconst htmlString = $generateHtmlFromNodes(editor, selection | null);\n```\n\n----------------------------------------\n\nTITLE: Updating Lexical Editor Content\nDESCRIPTION: Demonstrates how to update editor content by creating and appending new paragraph and text nodes within an editor update callback.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$getRoot, $getSelection, $createParagraphNode} from 'lexical';\n\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Lexical Editor Root Element\nDESCRIPTION: Shows how to associate a Lexical editor instance with a DOM element to enable editing functionality.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst contentEditableElement = document.getElementById('editor');\n\neditor.setRootElement(contentEditableElement);\n```\n\n----------------------------------------\n\nTITLE: Full Document Traversal Example - TypeScript\nDESCRIPTION: Demonstrates complete document traversal using CaretRange, showing entry and exit points for nested elements.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst carets = [...$getCaretRange(\n  // Start with the arrow pointing towards the first child of root\n  $getChildCaret($getRoot(), 'next'),\n  // End when the arrow points away from root\n  $getSiblingCaret($getRoot(), 'next'),\n)];\nexpect(carets).toEqual([\n  $getChildCaret(paragraphA, 'next'),   // enter Paragraph A\n  $getSiblingCaret(textA1, 'next'),\n  $getChildCaret(linkA2, 'next'),       // enter Link A2\n  $getSiblingCaret(textA3, 'next'),\n  $getSiblingCaret(linkA2, 'next'),     // leave Link A2\n  $getSiblingCaret(textA4, 'next'),\n  $getSiblingCaret(paragraphA, 'next'), // leave Paragraph A\n  $getChildCaret(paragraphB, 'next'),   // enter Paragraph B\n  $getSiblingCaret(textB1, 'next'),\n  $getSiblingCaret(paragraphB, 'next'), // leave Paragraph B\n  $getChildCaret(paragraphC, 'next'),   // enter Paragraph C\n  $getSiblingCaret(paragraphC, 'next'), // leave Paragraph C\n]);\n```\n\n----------------------------------------\n\nTITLE: Implementing List Commands with Lexical Editor\nDESCRIPTION: Example showing how to register and handle list commands in a Lexical editor. The first part demonstrates registering the INSERT_UNORDERED_LIST_COMMAND to create bullet lists, while the second part shows how to dispatch the command from a button click event.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-list/README.md#2025-04-13_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// MyListPlugin.ts\n\neditor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList(editor, 'bullet');\n    return true;\n}, COMMAND_PRIORITY_LOW);\n\n// MyInsertListToolbarButton.ts\n\nfunction onButtonClick(e: MouseEvent) {\n    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Editor Content Programmatically\nDESCRIPTION: Shows how to modify editor content programmatically using editor.update() with a callback function that uses special $ prefixed helper functions to manipulate nodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/quick-start.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$getRoot, $getSelection, $createParagraphNode, $createTextNode} from 'lexical';\n\n// Inside the `editor.update` you can use special $ prefixed helper functions.\n// These functions cannot be used outside the closure, and will error if you try.\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\n// outside of a React function component).\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Update Listener in Lexical Editor\nDESCRIPTION: Example showing how to register and unregister an update listener on a Lexical editor instance to monitor editor state changes.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst unregisterListener = editor.registerUpdateListener(({editorState}) => {\n  // An update has occurred!\n  console.log(editorState);\n});\n\n// Ensure we remove the listener later!\nunregisterListener();\n```\n\n----------------------------------------\n\nTITLE: Implementing LinkPlugin\nDESCRIPTION: Implementation of the LinkPlugin, which adds support for hyperlinks and the $toggleLink command that allows toggling link formatting for selected text.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<LinkPlugin />\n```\n\n----------------------------------------\n\nTITLE: Implementing Text Content Listener in Lexical Editor\nDESCRIPTION: Shows how to register a text content listener that gets notified when the editor's text content changes between updates.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeTextContentListener = editor.registerTextContentListener(\n  (textContent) => {\n    // The latest text content of the editor!\n    console.log(textContent);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveTextContentListener();\n```\n\n----------------------------------------\n\nTITLE: Managing Lexical Editor State\nDESCRIPTION: Example of serializing and deserializing Lexical editor state to/from JSON format.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst stringifiedEditorState = JSON.stringify(editor.getEditorState().toJSON());\n\nconst newEditorState = editor.parseEditorState(stringifiedEditorState);\n```\n\n----------------------------------------\n\nTITLE: Implementing RichTextPlugin\nDESCRIPTION: Implementation of the RichTextPlugin, which adds rich text editing features including text formatting (bold, italic, etc.), indentation, and enhanced copy/paste support.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<RichTextPlugin\n  contentEditable={\n    <ContentEditable\n      aria-placeholder={'Enter some text...'}\n      placeholder={<div>Enter some text...</div>}\n    />\n  }\n  ErrorBoundary={LexicalErrorBoundary}\n/>\n```\n\n----------------------------------------\n\nTITLE: Implementing Collaborative Lexical Editor in React\nDESCRIPTION: Complete implementation of a collaborative rich text editor using Lexical with React and Yjs integration. Includes configuration for WebSocket provider and collaboration plugin setup.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/collaboration/react.md#2025-04-13_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport {$getRoot, $createParagraphNode, $createTextNode} from 'lexical';\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {LexicalErrorBoundary} from '@lexical/react/LexicalErrorBoundary';\nimport {RichTextPlugin} from '@lexical/react/LexicalRichTextPlugin';\nimport {CollaborationPlugin} from '@lexical/react/LexicalCollaborationPlugin';\nimport * as Y from 'yjs';\nimport {$initialEditorState} from './initialEditorState';\nimport {WebsocketProvider} from 'y-websocket';\n\nfunction Editor() {\n  const initialConfig = {\n    editorState: null,\n    namespace: 'Demo',\n    nodes: [],\n    onError: (error: Error) => {\n      throw error;\n    },\n    theme: {},\n  };\n\n  const providerFactory = useCallback(\n    (id: string, yjsDocMap: Map<string, Y.Doc>) => {\n      const doc = getDocFromMap(id, yjsDocMap);\n\n      return new WebsocketProvider('ws://localhost:1234', id, doc, {\n        connect: false,\n      });\n    }, [],\n  );\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <RichTextPlugin\n        contentEditable={<ContentEditable className=\"editor-input\" />}\n        placeholder={<div className=\"editor-placeholder\">Enter some rich text...</div>}\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n      <CollaborationPlugin\n        id=\"lexical/react-rich-collab\"\n        providerFactory={providerFactory}\n        initialEditorState={$initialEditorState}\n        shouldBootstrap={true}\n      />\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Lexical Editor State from JSON\nDESCRIPTION: Example showing how to replace the current editor state with a new state parsed from a JSON string using setEditorState method.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst editorState = editor.parseEditorState(editorStateJSONString);\neditor.setEditorState(editorState);\n```\n\n----------------------------------------\n\nTITLE: Implementing Undo/Redo Buttons in React JSX\nDESCRIPTION: Example implementation of undo/redo functionality in a toolbar using Lexical commands. Shows how to dispatch undo and redo commands through button click handlers.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-history/README.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport {UNDO_COMMAND, REDO_COMMAND} from 'lexical';\n\n<Toolbar>\n  <Button onClick={() => editor.dispatchCommand(UNDO_COMMAND)}>Undo</Button>\n  <Button onClick={() => editor.dispatchCommand(REDO_COMMAND)}>Redo</Button>\n</Toolbar>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Node Transform for Emoji Conversion in TypeScript\nDESCRIPTION: This snippet defines a textNodeTransform function that converts text-based smileys to EmojiNodes, and a registerEmoji function to register the transform with the editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/creating-plugin.md#2025-04-13_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {LexicalEditor, TextNode} from 'lexical';\n\nimport {$createEmojiNode} from './EmojiNode';\nimport findEmoji from './findEmoji';\n\nfunction textNodeTransform(node: TextNode): void {\n  if (!node.isSimpleText() || node.hasFormat('code')) {\n    return;\n  }\n\n  const text = node.getTextContent();\n\n  const emojiMatch = findEmoji(text);\n  if (emojiMatch === null) {\n    return;\n  }\n\n  let targetNode;\n  if (emojiMatch.position === 0) {\n    [targetNode] = node.splitText(\n      emojiMatch.position + emojiMatch.shortcode.length,\n    );\n  } else {\n    [, targetNode] = node.splitText(\n      emojiMatch.position,\n      emojiMatch.position + emojiMatch.shortcode.length,\n    );\n  }\n\n  const emojiNode = $createEmojiNode(emojiMatch.unifiedID);\n  targetNode.replace(emojiNode);\n}\n\nexport function registerEmoji(editor: LexicalEditor): () => void {\n  return editor.registerNodeTransform(TextNode, textNodeTransform);\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Selection in Lexical (JavaScript)\nDESCRIPTION: Demonstrates how to get the current selection in Lexical using $getSelection() in different contexts such as editor updates, reads, and command listeners.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/selection.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$getSelection, SELECTION_CHANGE_COMMAND} from 'lexical';\n\neditor.update(() => {\n  const selection = $getSelection();\n});\n\neditorState.read(() => {\n  const selection = $getSelection();\n});\n\n// SELECTION_CHANGE_COMMAND fires when selection changes within a Lexical editor.\neditor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n  const selection = $getSelection();\n});\n```\n\n----------------------------------------\n\nTITLE: Updating SerializedTextNode with Backwards Compatibility\nDESCRIPTION: Example of how to add a new field to SerializedTextNode while maintaining backwards compatibility by making the new field optional.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n    // Our new field we've added\n    newField?: string,\n  },\n  SerializedLexicalNode\n>;\n```\n\n----------------------------------------\n\nTITLE: Implementing OnChangePlugin\nDESCRIPTION: Implementation of the OnChangePlugin, which triggers the onChange callback whenever the Lexical editor state is updated. It provides options to control when the callback is triggered.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<OnChangePlugin onChange={onChange} />\n```\n\n----------------------------------------\n\nTITLE: Implementing HistoryPlugin\nDESCRIPTION: Implementation of the HistoryPlugin, which adds support for history stack management and undo/redo commands in the Lexical editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<HistoryPlugin />\n```\n\n----------------------------------------\n\nTITLE: Implementing PlainTextPlugin\nDESCRIPTION: Implementation of the PlainTextPlugin, which adds core features for plain text editing including typing, deletion, and copy/paste functionality.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<PlainTextPlugin\n  contentEditable={\n    <ContentEditable\n      aria-placeholder={'Enter some text...'}\n      placeholder={<div>Enter some text...</div>}\n    />\n  }\n  ErrorBoundary={LexicalErrorBoundary}\n/>\n```\n\n----------------------------------------\n\nTITLE: Configuring Lexical Editor with Custom Emoji Plugin in TypeScript\nDESCRIPTION: This code demonstrates how to configure a Lexical editor instance with the custom EmojiNode and register the emoji plugin.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/creating-plugin.md#2025-04-13_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {createEditor} from 'lexical';\nimport {mergeRegister} from '@lexical/utils';\n/* ... */\n\nimport {EmojiNode} from './emoji-plugin/EmojiNode';\nimport {registerEmoji} from './emoji-plugin/EmojiPlugin';\n\nconst initialConfig = {\n  /* ... */\n  // Register our newly created node\n  nodes: [EmojiNode, /* ... */],\n};\n\nconst editor = createEditor(config);\n\nconst editorRef = document.getElementById('lexical-editor');\neditor.setRootElement(editorRef);\n\n// Registering Plugins\nmergeRegister(\n  /* ... */\n  registerEmoji(editor), // Our plugin\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Lexical Generic Keydown Listener in JavaScript\nDESCRIPTION: Demonstrates how to register a generic keydown event listener in Lexical using the KEY_DOWN_COMMAND. This allows for handling all keydown events, with the option to prevent further command execution.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport {KEY_DOWN_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_DOWN_COMMAND, (event: KeyboardEvent) => {\n  // Handle event here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n```\n\n----------------------------------------\n\nTITLE: Implementing AutoLinkPlugin with URL Matching\nDESCRIPTION: Implementation of the AutoLinkPlugin with a custom URL matcher that automatically converts URL-like text into clickable links. Supports custom link attributes and multiple matchers.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nconst URL_MATCHER =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/;\n\nconst MATCHERS = [\n  (text) => {\n    const match = URL_MATCHER.exec(text);\n    if (match === null) {\n      return null;\n    }\n    const fullMatch = match[0];\n    return {\n      index: match.index,\n      length: fullMatch.length,\n      text: fullMatch,\n      url: fullMatch.startsWith('http') ? fullMatch : `https://${fullMatch}`,\n      // attributes: { rel: 'noreferrer', target: '_blank' }, // Optional link attributes\n    };\n  },\n];\n\n...\n\n<AutoLinkPlugin matchers={MATCHERS} />\n```\n\n----------------------------------------\n\nTITLE: Custom TextNode Implementation\nDESCRIPTION: Complete example of extending TextNode with color property and DOM handling.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nexport class ColoredNode extends TextNode {\n  __color: string;\n\n  constructor(text: string, color: string, key?: NodeKey): void {\n    super(text, key);\n    this.__color = color;\n  }\n\n  static getType(): string {\n    return 'colored';\n  }\n\n  static clone(node: ColoredNode): ColoredNode {\n    return new ColoredNode(node.__text, node.__color, node.__key);\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = super.createDOM(config);\n    element.style.color = this.__color;\n    return element;\n  }\n\n  updateDOM(\n    prevNode: this,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    const isUpdated = super.updateDOM(prevNode, dom, config);\n    if (prevNode.__color !== this.__color) {\n      dom.style.color = this.__color;\n    }\n    return isUpdated;\n  }\n}\n\nexport function $createColoredNode(text: string, color: string): ColoredNode {\n  return new ColoredNode(text, color);\n}\n\nexport function $isColoredNode(node: LexicalNode | null | undefined): node is ColoredNode {\n  return node instanceof ColoredNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExtendedTextNode for Rich Text Handling\nDESCRIPTION: Complete implementation of an ExtendedTextNode class that overrides the base TextNode to handle serialization and deserialization of HTML/CSS styling properties.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  $applyNodeReplacement,\n  $isTextNode,\n  DOMConversion,\n  DOMConversionMap,\n  DOMConversionOutput,\n  NodeKey,\n  TextNode,\n  SerializedTextNode,\n  LexicalNode\n} from 'lexical';\n\nexport class ExtendedTextNode extends TextNode {\n  constructor(text: string, key?: NodeKey) {\n    super(text, key);\n  }\n\n  static getType(): string {\n    return 'extended-text';\n  }\n\n  static clone(node: ExtendedTextNode): ExtendedTextNode {\n    return new ExtendedTextNode(node.__text, node.__key);\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    const importers = TextNode.importDOM();\n    return {\n      ...importers,\n      code: () => ({\n        conversion: patchStyleConversion(importers?.code),\n        priority: 1\n      }),\n      em: () => ({\n        conversion: patchStyleConversion(importers?.em),\n        priority: 1\n      }),\n      span: () => ({\n        conversion: patchStyleConversion(importers?.span),\n        priority: 1\n      }),\n      strong: () => ({\n        conversion: patchStyleConversion(importers?.strong),\n        priority: 1\n      }),\n      sub: () => ({\n        conversion: patchStyleConversion(importers?.sub),\n        priority: 1\n      }),\n      sup: () => ({\n        conversion: patchStyleConversion(importers?.sup),\n        priority: 1\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedTextNode): TextNode {\n    return $createExtendedTextNode().updateFromJSON(serializedNode);\n  }\n\n  isSimpleText() {\n    return this.__type === 'extended-text' && this.__mode === 0;\n  }\n\n  // no need to add exportJSON here, since we are not adding any new properties\n}\n\nexport function $createExtendedTextNode(text: string = ''): ExtendedTextNode {\n  return $applyNodeReplacement(new ExtendedTextNode(text));\n}\n\nexport function $isExtendedTextNode(node: LexicalNode | null | undefined): node is ExtendedTextNode {\n\treturn node instanceof ExtendedTextNode;\n}\n\nfunction patchStyleConversion(\n  originalDOMConverter?: (node: HTMLElement) => DOMConversion | null\n): (node: HTMLElement) => DOMConversionOutput | null {\n  return (node) => {\n    const original = originalDOMConverter?.(node);\n    if (!original) {\n      return null;\n    }\n    const originalOutput = original.conversion(node);\n\n    if (!originalOutput) {\n      return originalOutput;\n    }\n\n    const backgroundColor = node.style.backgroundColor;\n    const color = node.style.color;\n    const fontFamily = node.style.fontFamily;\n    const fontWeight = node.style.fontWeight;\n    const fontSize = node.style.fontSize;\n    const textDecoration = node.style.textDecoration;\n\n    return {\n      ...originalOutput,\n      forChild: (lexicalNode, parent) => {\n        const originalForChild = originalOutput?.forChild ?? ((x) => x);\n        const result = originalForChild(lexicalNode, parent);\n        if ($isTextNode(result)) {\n          const style = [\n            backgroundColor ? `background-color: ${backgroundColor}` : null,\n            color ? `color: ${color}` : null,\n            fontFamily ? `font-family: ${fontFamily}` : null,\n            fontWeight ? `font-weight: ${fontWeight}` : null,\n            fontSize ? `font-size: ${fontSize}` : null,\n            textDecoration ? `text-decoration: ${textDecoration}` : null,\n          ]\n            .filter((value) => value != null)\n            .join('; ');\n          if (style.length) {\n            return result.setStyle(style);\n          }\n        }\n        return result;\n      }\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Update Tags through editor.update() Options in Lexical\nDESCRIPTION: Demonstrates how to add single or multiple update tags to a Lexical editor update using the 'tag' option in the editor.update() method. Tags help identify update types and control behavior.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {HISTORY_PUSH_TAG, PASTE_TAG} from 'lexical';\n\neditor.update(() => {\n  // Your update code\n}, {\n  tag: HISTORY_PUSH_TAG // Single tag\n});\n\neditor.update(() => {\n  // Your update code\n}, {\n  tag: [HISTORY_PUSH_TAG, PASTE_TAG] // Multiple tags\n});\n```\n\n----------------------------------------\n\nTITLE: Checking for Update Tags with $hasUpdateTag() in Lexical\nDESCRIPTION: Demonstrates how to check if an update has a specific tag using the $hasUpdateTag() function within the same update. This allows conditional logic based on present tags.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {HISTORIC_TAG} from 'lexical';\n\neditor.update(() => {\n  $addUpdateTag(HISTORIC_TAG);\n  console.log($hasUpdateTag(HISTORIC_TAG)); // true\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutation Listener in Lexical Editor\nDESCRIPTION: Demonstrates how to track node mutations (created, destroyed, updated) using a mutation listener. Useful for handling UI state related to specific node types.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeMutationListener = editor.registerMutationListener(\n  MyCustomNode,\n  (mutatedNodes, { updateTags, dirtyLeaves, prevEditorState }) => {\n    // mutatedNodes is a Map where each key is the NodeKey, and the value is the state of mutation.\n    for (let [nodeKey, mutation] of mutatedNodes) {\n      console.log(nodeKey, mutation)\n    }\n  },\n  {skipInitialization: false}\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveMutationListener();\n```\n\n----------------------------------------\n\nTITLE: Managing Editor State in React with LexicalComposer\nDESCRIPTION: React implementation example showing how to load initial editor state and save content using the LexicalComposer and LexicalOnChangePlugin components.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst initialEditorState = await loadContent();\nconst editorStateRef = useRef(undefined);\n\n<LexicalComposer initialConfig={{\n  editorState: initialEditorState\n}}>\n  <LexicalRichTextPlugin />\n  <LexicalOnChangePlugin onChange={(editorState) => {\n    editorStateRef.current = editorState;\n  }} />\n  <Button label=\"Save\" onPress={() => {\n    if (editorStateRef.current) {\n      saveContent(JSON.stringify(editorStateRef.current))\n    }\n  }} />\n</LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Update Tag Constants in Lexical\nDESCRIPTION: Demonstrates the recommended practice of using Lexical's built-in tag constants for type safety. Shows usage in various contexts including update options and listener checks.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  HISTORIC_TAG,\n  HISTORY_PUSH_TAG,\n  COLLABORATION_TAG,\n} from 'lexical';\n\neditor.update(() => {\n  // Using constants ensures type safety and prevents typos\n  $addUpdateTag(HISTORIC_TAG);\n  \n  // These constants can be used in update options\n  editor.update(() => {\n    // Your update code\n  }, {\n    tag: HISTORY_PUSH_TAG\n  });\n  \n  // And in listener checks\n  editor.registerUpdateListener(({tags}) => {\n    if (tags.has(COLLABORATION_TAG)) {\n      // Handle collaborative updates\n    }\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing EditorState from Yjs Document in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a headless collaborative editor that converts a Yjs document state to Lexical JSON. It sets up bi-directional synchronization between Yjs and the editor, using a no-op provider for testing or offline scenarios.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/collaboration/faq.md#2025-04-13_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {Binding, Provider} from '@lexical/yjs';\nimport type {\n  Klass,\n  LexicalEditor,\n  LexicalNode,\n  LexicalNodeReplacement,\n  SerializedEditorState,\n  SerializedLexicalNode,\n} from 'lexical';\n\nimport {createHeadlessEditor} from '@lexical/headless';\nimport {\n  createBinding,\n  syncLexicalUpdateToYjs,\n  syncYjsChangesToLexical,\n} from '@lexical/yjs';\nimport {type YEvent, applyUpdate, Doc, Transaction} from 'yjs';\n\nexport default function headlessConvertYDocStateToLexicalJSON(\n  nodes: ReadonlyArray<Klass<LexicalNode> | LexicalNodeReplacement>,\n  yDocState: Uint8Array,\n): SerializedEditorState<SerializedLexicalNode> {\n  return withHeadlessCollaborationEditor(nodes, (editor, binding) => {\n    applyUpdate(binding.doc, yDocState, {isUpdateRemote: true});\n    editor.update(() => {}, {discrete: true});\n\n    return editor.getEditorState().toJSON();\n  });\n}\n\nfunction withHeadlessCollaborationEditor<T>(\n  nodes: ReadonlyArray<Klass<LexicalNode> | LexicalNodeReplacement>,\n  callback: (editor: LexicalEditor, binding: Binding, provider: Provider) => T,\n): T {\n  const editor = createHeadlessEditor({\n    nodes,\n  });\n\n  const id = 'main';\n  const doc = new Doc();\n  const docMap = new Map([[id, doc]]);\n  const provider = createNoOpProvider();\n  const binding = createBinding(editor, provider, id, doc, docMap);\n\n  const unsubscribe = registerCollaborationListeners(editor, provider, binding);\n\n  const res = callback(editor, binding, provider);\n\n  unsubscribe();\n\n  return res;\n}\n\nfunction registerCollaborationListeners(\n  editor: LexicalEditor,\n  provider: Provider,\n  binding: Binding,\n): () => void {\n  const unsubscribeUpdateListener = editor.registerUpdateListener(\n    ({\n      dirtyElements,\n      dirtyLeaves,\n      editorState,\n      normalizedNodes,\n      prevEditorState,\n      tags,\n    }) => {\n      if (tags.has('skip-collab') === false) {\n        syncLexicalUpdateToYjs(\n          binding,\n          provider,\n          prevEditorState,\n          editorState,\n          dirtyElements,\n          dirtyLeaves,\n          normalizedNodes,\n          tags,\n        );\n      }\n    },\n  );\n\n  const observer = (events: Array<YEvent<any>>, transaction: Transaction) => {\n    if (transaction.origin !== binding) {\n      syncYjsChangesToLexical(binding, provider, events, false);\n    }\n  };\n\n  binding.root.getSharedType().observeDeep(observer);\n\n  return () => {\n    unsubscribeUpdateListener();\n    binding.root.getSharedType().unobserveDeep(observer);\n  };\n}\n\nfunction createNoOpProvider(): Provider {\n  const emptyFunction = () => {};\n\n  return {\n    awareness: {\n      getLocalState: () => null,\n      getStates: () => new Map(),\n      off: emptyFunction,\n      on: emptyFunction,\n      setLocalState: emptyFunction,\n    },\n    connect: emptyFunction,\n    disconnect: emptyFunction,\n    off: emptyFunction,\n    on: emptyFunction,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TablePlugin\nDESCRIPTION: Implementation of the TablePlugin, which adds support for creating and manipulating tables within the Lexical editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n<TablePlugin />\n```\n\n----------------------------------------\n\nTITLE: React Implementation with Theme\nDESCRIPTION: Shows how to integrate the theme configuration within a React component using LexicalComposer and related plugins.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/theming.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {exampleTheme} from './exampleTheme';\nimport {LexicalErrorBoundary} from '@lexical/react/LexicalErrorBoundary';\n\nconst initialConfig = {namespace: 'MyEditor', theme: exampleTheme};\n\nexport default function Editor() {\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <PlainTextPlugin\n        contentEditable={\n          <ContentEditable\n            aria-placeholder={'Enter some text...'}\n            placeholder={<div className=\"editor-placeholder\">Enter some text...</div>}\n          />\n        }\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n    </LexicalComposer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Example of Using $functions within Lexical Provider Methods\nDESCRIPTION: Examples showing how $functions can be called within editor update, read, and other designated provider methods.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nfunction validUsesEditorOrState(editor) {\n  editor.update(() => $getRoot());\n  editor.getLatestState().read(() => $getRoot());\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Event Handler Attachment using Mutation Listener in Lexical\nDESCRIPTION: Shows how to attach event handlers directly to specific DOM nodes using a mutation listener. Includes handling for node creation and updates while maintaining a WeakSet to track registered elements.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/dom-events.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst registeredElements: WeakSet<HTMLElement> = new WeakSet();\nconst removeMutationListener = editor.registerMutationListener(nodeType, (mutations) => {\n    editor.getEditorState().read(() => {\n        for (const [key, mutation] of mutations) {\n            const element: null | HTMLElement = editor.getElementByKey(key);\n            if (\n                // Updated might be a move, so that might mean a new DOM element\n                // is created. In this case, we need to add an event listener too.\n                (mutation === 'created' || mutation === 'updated') &&\n                element !== null &&\n                !registeredElements.has(element)\n            ) {\n                registeredElements.add(element);\n                element.addEventListener('click', (event: Event) => {\n                    alert('Nice!');\n                });\n            }\n        }\n    });\n});\n\n// teardown the listener - return this from your useEffect callback if you're using React.\nremoveMutationListener();\n```\n\n----------------------------------------\n\nTITLE: Using Update Tags in Lexical Listeners\nDESCRIPTION: Shows how to access and check for update tags in update and mutation listeners. This pattern allows responding to specific types of updates based on their tags.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {HISTORIC_TAG} from 'lexical';\n\neditor.registerUpdateListener(({tags}) => {\n  if (tags.has(HISTORIC_TAG)) {\n    // Handle updates with historic tag\n  }\n});\n\neditor.registerMutationListener(MyNode, (mutations) => {\n  // updateTags contains tags from the current update\n  if (mutations.updateTags.has(HISTORIC_TAG)) {\n    // Handle mutations with historic tag\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using Discrete Updates for Synchronous Reconciliation\nDESCRIPTION: Examples demonstrating how to use the discrete option to force immediate state commitment when manipulating editor state in contexts like server-side processing.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_7\n\nLANGUAGE: js\nCODE:\n```\neditor.update(() => {\n  // manipulate the state...\n});\n\nsaveToDatabase(editor.getEditorState().toJSON());\n```\n\nLANGUAGE: js\nCODE:\n```\neditor.update(() => {\n  // manipulate the state...\n}, {discrete: true});\n\nsaveToDatabase(editor.getEditorState().toJSON());\n```\n\n----------------------------------------\n\nTITLE: Converting HTML to Lexical Nodes (Browser)\nDESCRIPTION: Shows how to convert HTML string to Lexical nodes using the browser's DOMParser and $generateNodesFromDOM utility.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {$generateNodesFromDOM} from '@lexical/html';\n\neditor.update(() => {\n  const parser = new DOMParser();\n  const dom = parser.parseFromString(htmlString, textHtmlMimeType);\n\n  const nodes = $generateNodesFromDOM(editor, dom);\n\n  $getRoot().select();\n\n  $insertNodes(nodes);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Editable Listener in Lexical Editor\nDESCRIPTION: Shows how to monitor changes in the editor's editable mode using an editable listener.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeEditableListener = editor.registerEditableListener(\n  (editable) => {\n    // The editor's mode is passed in!\n    console.log(editable);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveEditableListener();\n```\n\n----------------------------------------\n\nTITLE: Registering Lexical Editor Update Listener\nDESCRIPTION: Shows how to register an update listener to react to editor state changes and read updated content.\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Associating Editor with DOM Element\nDESCRIPTION: Shows how to connect a Lexical editor instance with a content editable element in the DOM, which is required for the editor to render content.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/quick-start.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst contentEditableElement = document.getElementById('editor');\n\neditor.setRootElement(contentEditableElement);\n```\n\n----------------------------------------\n\nTITLE: Adding Markdown Shortcuts with React Plugin\nDESCRIPTION: Demonstrates how to add markdown shortcut support using the MarkdownShortcutPlugin React component with the default TRANSFORMERS.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/README.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { TRANSFORMERS } from '@lexical/markdown';\nimport {MarkdownShortcutPlugin} from '@lexical/react/LexicalMarkdownShortcutPlugin';\n\n<LexicalComposer>\n  <MarkdownShortcutPlugin transformers={TRANSFORMERS} />\n</LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Dispatching Lexical Commands\nDESCRIPTION: Examples of dispatching commands from Lexical's event system and plugins. Shows dispatching key commands with event payloads and format commands with string payloads.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/commands.md#2025-04-13_snippet_1\n\nLANGUAGE: js\nCODE:\n```\neditor.dispatchCommand(command, payload);\n```\n\nLANGUAGE: js\nCODE:\n```\neditor.dispatchCommand(KEY_ARROW_LEFT_COMMAND, event);\n// ...\neditor.dispatchCommand(FORMAT_TEXT_COMMAND, 'italic');\n```\n\nLANGUAGE: js\nCODE:\n```\nconst formatBulletList = () => {\n  editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND);\n};\n```\n\nLANGUAGE: js\nCODE:\n```\neditor.registerCommand(\n  INSERT_UNORDERED_LIST_COMMAND,\n  () => {\n    insertList(editor, 'ul');\n    return true;\n  },\n  COMMAND_PRIORITY_LOW,\n);\n```\n\n----------------------------------------\n\nTITLE: Complete Custom Node Implementation\nDESCRIPTION: Extended example showing a complete custom node implementation with clone and type methods.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nclass MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  static getType(): string {\n    return 'custom-node';\n  }\n\n  static clone(node: MyCustomNode): MyCustomNode {\n    // If any state needs to be set after construction, it should be\n    // done by overriding the `afterCloneFrom` instance method.\n    return new MyCustomNode(node.__foo, node.__key);\n  }\n\n  constructor(foo: string, key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  setFoo(foo: string) {\n    const self = this.getWritable();\n    self.__foo = foo;\n  }\n\n  getFoo(): string {\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SelectionAlwaysOnDisplay\nDESCRIPTION: Implementation of the SelectionAlwaysOnDisplay plugin, which ensures that the text selection remains visible even when the editor loses focus, overriding the default browser behavior.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\n<SelectionAlwaysOnDisplay />\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom OnChange Plugin for Lexical Editor\nDESCRIPTION: A custom React plugin that listens for editor state changes and calls a provided onChange function. This plugin can be used to save or process the editor state on each update.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/react.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nfunction MyOnChangePlugin({ onChange }) {\n  // Access the editor through the LexicalComposerContext\n  const [editor] = useLexicalComposerContext();\n  // Wrap our listener in useEffect to handle the teardown and avoid stale references.\n  useEffect(() => {\n    // most listeners return a teardown function that can be called to clean them up.\n    return editor.registerUpdateListener(({editorState}) => {\n      // call onChange here to pass the latest state up to the parent.\n      onChange(editorState);\n    });\n  }, [editor, onChange]);\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Editor Instance in a Lexical Plugin\nDESCRIPTION: This snippet demonstrates how to access the Lexical editor instance within a custom plugin component using the useLexicalComposerContext hook.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/create_plugin.md#2025-04-13_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n//MyLexicalPlugin.js\n\nexport function MyLexicalPlugin(props) {\n    const [editor] = useLexicalComposerContext();\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Lexical Editor Instance with Configuration\nDESCRIPTION: Shows how to create a Lexical editor instance with a basic configuration object that includes a namespace and a theme.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical/README.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createEditor} from 'lexical';\n\nconst config = {\n  namespace: 'MyEditor',\n  theme: {\n    ...\n  },\n};\n\nconst editor = createEditor(config);\n```\n\n----------------------------------------\n\nTITLE: Implementing Node State in Lexical\nDESCRIPTION: Demonstrates how to create and use state in Lexical nodes using the createState function. Shows basic implementation for storing and retrieving color values on text nodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/node-replacement.md#2025-04-13_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst colorState = createState('color', {\n  parse: (value: unknown) => (typeof value === 'string' ? value : undefined),\n});\n\n// USAGE\nconst textNode = $createTextNode();\n$setState(textNode, colorState, 'blue');\nconst textColor = $getState(textNode, colorState) // -> \"blue\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping Command Dispatch to Prevent Focus Changes (JavaScript)\nDESCRIPTION: Shows how to wrap a command dispatch in an editor update to prevent focus changes using the SKIP_DOM_SELECTION_TAG.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/selection.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// NOTE: If you are already in a command listener or editor.update,\n//       do *not* nest a second editor.update! Nested updates have\n//       confusing semantics (dispatchCommand will re-use the\n//       current update without nesting)\neditor.update(() => {\n  $addUpdateTag(SKIP_DOM_SELECTION_TAG);\n  editor.dispatchCommand(/* … */);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Listener in Lexical Editor\nDESCRIPTION: Demonstrates how to register and use an update listener to monitor editor state changes. The listener provides access to the latest EditorState and allows reading its contents.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeUpdateListener = editor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n\n// Do not forget to unregister the listener when no longer needed!\nremoveUpdateListener();\n```\n\n----------------------------------------\n\nTITLE: Associating a Lexical Editor with a DOM Element\nDESCRIPTION: Demonstrates how to connect a Lexical editor instance to a content editable element in the DOM. This is required to render the editor on the page.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical/README.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst contentEditableElement = document.getElementById('editor');\n\neditor.setRootElement(contentEditableElement);\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Nodes in Lexical Configuration\nDESCRIPTION: Example of registering custom nodes in the Lexical editor configuration. Many plugins require specific node types to be registered to function properly.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst initialConfig = {\n  namespace: 'MyEditor',\n  theme,\n  nodes: [ListNode, ListItemNode], // Pass the references to the nodes here\n  onError,\n};\n```\n\n----------------------------------------\n\nTITLE: Preventing Focus Changes in Lexical Updates (JavaScript)\nDESCRIPTION: Demonstrates how to prevent Lexical from changing focus when making updates or dispatching commands, using the SKIP_DOM_SELECTION_TAG update tag.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/selection.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Call this from an editor.update or command listener\n$addUpdateTag(SKIP_DOM_SELECTION_TAG);\n```\n\n----------------------------------------\n\nTITLE: Adding a Lexical Plugin to LexicalComposer in React\nDESCRIPTION: This snippet demonstrates the basic structure for adding a custom Lexical plugin as a child of the LexicalComposer component.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/create_plugin.md#2025-04-13_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n <LexicalComposer>\n    <MyLexicalPlugin>\n </LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Registering Update Listener for Editor State Changes\nDESCRIPTION: Demonstrates how to register a listener that gets triggered whenever the editor state changes, allowing applications to react to content updates.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/quick-start.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Editor State\nDESCRIPTION: Demonstrates how to convert an editor state to JSON for persistence and how to parse a stringified state back into a usable editor state object.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/quick-start.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst stringifiedEditorState = JSON.stringify(editor.getEditorState().toJSON());\n\nconst newEditorState = editor.parseEditorState(stringifiedEditorState);\n```\n\n----------------------------------------\n\nTITLE: Caret Range Traversal Implementation - TypeScript\nDESCRIPTION: Shows how to implement depth-first traversal using CaretRange with configurable start and end points.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction $iterCaretsDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>,\n  endCaret?: NodeCaret<D>,\n): Iterable<NodeCaret<D>> {\n  return $getCaretRange(\n    startCaret,\n    // Use the root as the default end caret, but you might choose\n    // to use startCaret.getParentCaret('root') for example\n    endCaret || $getSiblingCaret($getRoot(), startCaret.direction)\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Passing initialConfig to LexicalComposer with Custom Nodes\nDESCRIPTION: This snippet demonstrates how to pass the initialConfig object with registered custom nodes to the LexicalComposer component.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/create_plugin.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n <LexicalComposer initialConfig={initialConfig}>\n    <MyLexicalPlugin>\n </LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Multiple TextNode Transforms Showing Sequential Execution\nDESCRIPTION: Example demonstrating how multiple transforms on the same node type execute sequentially and can depend on each other's results. The first transform depends on the result of the second transform.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Plugin 1\neditor.registerNodeTransform(TextNode, textNode => {\n  // This transform runs twice but does nothing the first time because it doesn't meet the preconditions\n  if (textNode.getTextContent() === 'modified') {\n    textNode.setTextContent('re-modified');\n  }\n})\n// Plugin 2\neditor.registerNodeTransform(TextNode, textNode => {\n  // This transform runs only once\n  if (textNode.getTextContent() === 'original') {\n    textNode.setTextContent('modified');\n  }\n})\n// App\neditor.addListener('update', ({editorState}) => {\n  const text = editorState.read($textContent);\n  // text === 're-modified'\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Lexical Key Command Listener in JavaScript\nDESCRIPTION: Shows how to register a command listener for specific key events in Lexical, using the KEY_ENTER_COMMAND as an example. This approach allows for custom handling of keyboard inputs.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport {KEY_ENTER_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_ENTER_COMMAND, (event: KeyboardEvent) => {\n  // Handle enter key presses here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n```\n\n----------------------------------------\n\nTITLE: Iterating Siblings with NodeCaret in TypeScript\nDESCRIPTION: Function that demonstrates how to iterate through all siblings using the NodeCaret API. The function implements an Iterable that yields SiblingCaret instances by traversing adjacent carets.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Note that NodeCaret<D> already implements Iterable<NodeCaret<D>> in this\n// way, so this function is not very useful. You can just use startCaret as\n// the iterable.\nfunction *$iterSiblings<D extends CaretDirection>(\n  startCaret: NodeCaret<D>\n): Iterable<SiblingCaret<LexicalNode, D>> {\n  // Note that we start at the adjacent caret. The start caret\n  // points away from the origin node, so we do not want to\n  // trick ourselves into thinking that that origin is included.\n  for (\n    let caret = startCaret.getAdjacentCaret();\n    caret !== null;\n    caret = caret.getAdjacentCaret()\n  ) {\n    yield caret;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Transform on Parent Node When Adding Child\nDESCRIPTION: Example of a transform on a ParagraphNode that triggers when a child TextNode is added to it. This demonstrates how parent nodes can be marked dirty by operations on their children.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerNodeTransform(ParagraphNode, paragraph => {\n // Triggers\n});\neditor.update(() => {\n  const paragraph = $getRoot().getFirstChild();\n  paragraph.append($createTextNode('foo');\n});\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Using Update Listener Instead of Transform\nDESCRIPTION: An example of an anti-pattern that should be avoided - using an update listener followed by an editor update instead of a transform. This approach triggers additional renders and can interfere with plugins like HistoryPlugin.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerUpdateListener(() => {\n  editor.update(() => {\n    // Don't do this\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Registering an Update Listener in Lexical\nDESCRIPTION: Example showing how to register an update listener to react to editor state changes. The listener receives the latest editor state after each update is reconciled.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_6\n\nLANGUAGE: js\nCODE:\n```\neditor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Registering a Lexical Editor Update Listener\nDESCRIPTION: Shows how to subscribe to editor updates using registerUpdateListener, which allows reacting to changes in the editor state. The listener provides access to the latest EditorState.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical/README.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining SerializedExtendedTextNode Type in TypeScript\nDESCRIPTION: Examples of safe and unsafe ways to extend SerializedTextNode type, demonstrating the importance of optional properties for backwards compatibility.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SerializedExtendedTextNode = Spread<\n  // UNSAFE. This property is not optional\n  { newProperty: string },\n  SerializedTextNode\n>;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SerializedExtendedTextNode = Spread<\n  // SAFE. This property is not optional\n  { newProperty?: string },\n  SerializedTextNode\n>;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst serializedNode: SerializedTextNode = { /* ... */ };\nconst newNode: TextNode = $createExtendedTextNode();\n// This passes the type check, but would fail at runtime if the updateFromJSON method required newProperty\nnewNode.updateFromJSON(serializedNode);\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator Listener in Lexical Editor\nDESCRIPTION: Demonstrates how to track changes in the editor's decorator object, which contains DecoratorNode mappings.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeDecoratorListener = editor.registerDecoratorListener(\n  (decorators) => {\n    // The editor's decorators object is passed in!\n    console.log(decorators);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveDecoratorListener();\n```\n\n----------------------------------------\n\nTITLE: Converting HTML to Lexical Nodes (Headless)\nDESCRIPTION: Demonstrates HTML to Lexical node conversion in a headless environment using JSDOM.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createHeadlessEditor} from '@lexical/headless';\nimport {$generateNodesFromDOM} from '@lexical/html';\n\nconst editorNodes = []\nconst editor = createHeadlessEditor({ ...config, nodes: editorNodes });\n\neditor.update(() => {\n  const dom = new JSDOM(htmlString);\n\n  const nodes = $generateNodesFromDOM(editor, dom.window.document);\n\n  $getRoot().select();\n\n  const selection = $getSelection();\n  selection.insertNodes(nodes);\n});\n```\n\n----------------------------------------\n\nTITLE: Changing Lexical Editor Mode Imperatively\nDESCRIPTION: Changes the edit mode of an existing Lexical editor instance programmatically. This can be called at any time to switch between edit mode and read mode.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/read-only.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\neditor.setEditable(true);\n```\n\n----------------------------------------\n\nTITLE: Converting Between Markdown and Lexical Content\nDESCRIPTION: Demonstrates how to import markdown into Lexical and export Lexical content as markdown using the $convertFromMarkdownString and $convertToMarkdownString functions with TRANSFORMERS.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/README.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  TRANSFORMERS,\n} from '@lexical/markdown';\n\neditor.update(() => {\n  const markdown = $convertToMarkdownString(TRANSFORMERS);\n  ...\n});\n\neditor.update(() => {\n  $convertFromMarkdownString(markdown, TRANSFORMERS);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Basic Headless Lexical Editor\nDESCRIPTION: Example showing how to create a headless Lexical editor instance and use it to build a simple document with a paragraph containing text.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-headless/README.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { createHeadlessEditor } = require('@lexical/headless');\n\nconst editor = createHeadlessEditor({\n  nodes: [],\n  onError: () => {},\n});\n\neditor.update(() => {\n  $getRoot().append(\n    $createParagraphNode().append(\n      $createTextNode('Hello world')\n    )\n  )\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Root Listener in Lexical Editor\nDESCRIPTION: Shows how to monitor changes to the editor's root DOM element using a root listener. Useful for managing event listeners on the root element.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeRootListener = editor.registerRootListener(\n  (rootElement, prevRootElement) => {\n   //add listeners to the new root element\n   //remove listeners from the old root element\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveRootListener();\n```\n\n----------------------------------------\n\nTITLE: Using NodeEventPlugin with React in Lexical\nDESCRIPTION: Demonstrates the usage of NodeEventPlugin, a React-specific solution for handling node events in Lexical that simplifies the implementation of direct event handlers.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/dom-events.md#2025-04-13_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<LexicalComposer>\n    <NodeEventPlugin\n        nodeType={LinkNode}\n        eventType={'click'}\n        eventListener={(e: Event) => {\n            alert('Nice!');\n        }}\n    />\n</LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Implementing TableOfContentsPlugin\nDESCRIPTION: Implementation of the TableOfContentsPlugin, which dynamically generates a table of contents from headings in the editor. It tracks heading changes and supports lazy loading, providing data through a callback function.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\n<TableOfContentsPlugin>\n  {(tableOfContentsArray) => {\n    return (\n      <MyCustomTableOfContentsPlugin tableOfContents={tableOfContentsArray} />\n    );\n  }}\n</TableOfContentsPlugin>\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Delegation with Root Listener in Lexical\nDESCRIPTION: Demonstrates how to set up event delegation by attaching event listeners to the editor's root element. Includes proper cleanup handling to prevent memory leaks.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/dom-events.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction myListener(event) {\n    // You may want to filter on the event target here\n    // to only include clicks on certain types of DOM Nodes.\n    alert('Nice!');\n}\n\nconst removeRootListener = editor.registerRootListener((rootElement, prevRootElement) => {\n    // add the listener to the current root element\n    rootElement.addEventListener('click', myListener);\n    // remove the listener from the old root element - make sure the ref to myListener\n    // is stable so the removal works and you avoid a memory leak.\n    prevRootElement.removeEventListener('click', myListener);\n});\n\n// teardown the listener - return this from your useEffect callback if you're using React.\nremoveRootListener();\n```\n\n----------------------------------------\n\nTITLE: Depth First Caret Traversal Implementation - TypeScript\nDESCRIPTION: Implementation of depth-first traversal using NodeCaret. Handles both ElementNode and SiblingCaret cases recursively.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfunction *$iterCaretsDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>\n): Iterable<NodeCaret<D>> {\n  function step(prevCaret: NodeCaret<D>): null | NodeCaret<D> {\n    // Get the adjacent SiblingCaret\n    const nextCaret = prevCaret.getAdjacentCaret();\n    return (\n      // If there is a sibling, try and get a ChildCaret from it\n      (nextCaret && nextCaret.getChildCaret()) ||\n      // Return the sibling if there is one\n      nextCaret ||\n      // Return a SiblingCaret of the parent, if there is one\n      prevCaret.getParentCaret('root')\n    );\n  }\n  for (\n    let caret = step(startCaret);\n    caret !== null;\n    caret = step(caret)\n  ) {\n    yield caret;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom ElementNode Extension Example\nDESCRIPTION: Example demonstrating how to extend ElementNode with DOM creation and update methods.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/nodes.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {ElementNode, LexicalNode} from 'lexical';\n\nexport class CustomParagraph extends ElementNode {\n  static getType(): string {\n    return 'custom-paragraph';\n  }\n\n  static clone(node: CustomParagraph): CustomParagraph {\n    return new CustomParagraph(node.__key);\n  }\n\n  createDOM(): HTMLElement {\n    // Define the DOM element here\n    const dom = document.createElement('p');\n    return dom;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    // Returning false tells Lexical that this node does not need its\n    // DOM element replacing with a new copy from createDOM.\n    return false;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Theme Configuration in JavaScript\nDESCRIPTION: Demonstrates the basic structure of a Lexical theme object with essential text direction and paragraph styling properties.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/theming.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst exampleTheme = {\n  ltr: 'ltr',\n  rtl: 'rtl',\n  paragraph: 'editor-paragraph',\n};\n```\n\n----------------------------------------\n\nTITLE: Defining EmojiMatch Type and findEmoji Function in TypeScript\nDESCRIPTION: This snippet defines the EmojiMatch type and the findEmoji function signature for locating emoji shortcodes in text.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/creating-plugin.md#2025-04-13_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// findEmoji.ts\nexport type EmojiMatch = Readonly<{position: number, shortcode: string, unifiedID: string}>;\n\nexport default function findEmoji(text: string): EmojiMatch | null;\n```\n\n----------------------------------------\n\nTITLE: Registering History Function Declaration in JavaScript\nDESCRIPTION: Function signature for registerHistory method that manages undo/redo history stack. Takes editor instance, external history state, and delay as parameters. Returns an unregister callback for cleanup.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-history/README.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction registerHistory(\n  editor: LexicalEditor,\n  externalHistoryState: HistoryState,\n  delay: number,\n): () => void\n```\n\n----------------------------------------\n\nTITLE: Node Selection Implementation - TypeScript\nDESCRIPTION: Implementation for selecting all nodes between two carets using depth-first traversal while tracking visited nodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction *$iterNodesDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>,\n  endCaret: NodeCaret<D> = $getChildCaret($getRoot(), startCaret.direction),\n): Iterable<LexicalNode> {\n  const seen = new Set<NodeKey>();\n  for (const caret of $getCaretRange(startCaret, endCaret)) {\n    const {origin} = caret;\n    if ($isChildCaret(caret)) {\n      seen.add(origin.getKey());\n    } else if (!$isElementNode(origin) || seen.has(origin.getKey())) {\n      // If the origin is an element and we have not seen it as a ChildCaret\n      // then it was not entirely in the CaretRange\n      yield origin;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ClearEditorPlugin\nDESCRIPTION: Implementation of the ClearEditorPlugin, which adds support for the clearEditor command to clear all content from the editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n<ClearEditorPlugin />\n```\n\n----------------------------------------\n\nTITLE: Clearing Lexical Editor Contents in JavaScript\nDESCRIPTION: Demonstrates how to clear the contents of a Lexical editor by calling the clear() method on the root node within an update callback.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\neditor.update(() => {\n  $getRoot().clear();\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Custom Update Tags in Lexical\nDESCRIPTION: Shows how to define and use custom update tags in Lexical. Creating constants for custom tags helps maintain consistency and type safety across your application.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/updates.md#2025-04-13_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Define your custom tags as constants\nconst MY_FEATURE_TAG = 'my-custom-feature';\nconst MY_UPDATE_TAG = 'my-custom-update';\n\neditor.update(() => {\n  $addUpdateTag(MY_FEATURE_TAG);\n}, {\n  tag: MY_UPDATE_TAG\n});\n\n// Listen for updates with specific tags\neditor.registerUpdateListener(({tags}) => {\n  if (tags.has(MY_FEATURE_TAG)) {\n    // Handle updates from your custom feature\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Basic Theme\nDESCRIPTION: Shows the corresponding CSS styles for the basic theme configuration, including text alignment and editor placeholder styling.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/theming.md#2025-04-13_snippet_1\n\nLANGUAGE: css\nCODE:\n```\n.ltr {\n  text-align: left;\n}\n\n.rtl {\n  text-align: right;\n}\n\n.editor-placeholder {\n  color: #999;\n  overflow: hidden;\n  position: absolute;\n  top: 15px;\n  left: 15px;\n  user-select: none;\n  pointer-events: none;\n}\n\n.editor-paragraph {\n  margin: 0 0 15px 0;\n  position: relative;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TabIndentationPlugin\nDESCRIPTION: Implementation of the TabIndentationPlugin, which adds support for tab-based indentation when used with the RichTextPlugin.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n<TabIndentationPlugin />\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML String to DOM in Browser Environment\nDESCRIPTION: This snippet demonstrates how to parse an HTML string into a DOM instance using the native DOMParser API in a browser environment. This is a prerequisite step for importing HTML into Lexical.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// In the browser you can use the native DOMParser API to parse the HTML string.\nconst parser = new DOMParser();\nconst dom = parser.parseFromString(htmlString, textHtmlMimeType);\n```\n\n----------------------------------------\n\nTITLE: Node Transform TypeScript Syntax Definition\nDESCRIPTION: The TypeScript type signature for the registerNodeTransform method. It shows the expected parameters and return type for registering a transform on a specific node type.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/transforms.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\neditor.registerNodeTransform<T: LexicalNode>(Class<T>, T): () => void\n```\n\n----------------------------------------\n\nTITLE: Handling Waterfall Updates in Lexical Editor\nDESCRIPTION: Shows an example of waterfall updates pattern and its potential performance implications. This pattern should be avoided in favor of Node Transforms for better performance.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/listeners.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\neditor.registerUpdateListener(({editorState}) => {\n  // Read the editorState and maybe get some value.\n  editorState.read(() => {\n    // ...\n  });\n\n  // Then schedule another update.\n  editor.update(() => {\n    // ...\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining SerializedTextNode Type in TypeScript\nDESCRIPTION: Definition of the SerializedTextNode type, demonstrating how to use the Spread utility to extend the base SerializedLexicalNode type with additional properties.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {Spread} from 'lexical';\n\n// Spread is a Typescript utility that allows us to spread the properties\n// over the base SerializedLexicalNode type.\nexport type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n  },\n  SerializedLexicalNode\n>;\n```\n\n----------------------------------------\n\nTITLE: CodeNode DOM Import Example\nDESCRIPTION: Example showing how to implement importDOM for a CodeNode to handle GitHub code tables.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclass CodeNode extends ElementNode {\n...  \nstatic importDOM(): DOMConversionMap | null {\n  return {\n    ...\n    table: (node: Node) => {\n      if (isGitHubCodeTable(node as HTMLTableElement)) {\n        return {\n          conversion: convertTableElement,\n          priority: 3,\n        };\n      }\n      return null;\n    },\n    ...\n  };\n}\n...  \n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Synchronous Lexical Updates in JavaScript\nDESCRIPTION: Shows the synchronous equivalent of the async test structure using the 'discrete' option. This forces immediate reconciliation after each update, useful for ensuring update completion in tests.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\neditor.update(updateA, {discrete: true});\neditor.update(updateB, {discrete: true});\n```\n\n----------------------------------------\n\nTITLE: Registering an Edit Mode Change Listener in Lexical\nDESCRIPTION: Sets up a listener that will be called whenever the edit mode of the editor changes. The listener function receives a boolean indicating the new edit mode state. The function returns a cleanup function that should be called when the listener is no longer needed.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/read-only.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst removeEditableListener = editor.registerEditableListener(\n  (isEditable) => {\n    // The editor's mode is passed in!\n    console.log(isEditable);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveEditableListener();\n```\n\n----------------------------------------\n\nTITLE: HTML Example with Nested Formatting\nDESCRIPTION: HTML example showing how text formatting creates nested structures that complicate state management in rich text editing.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<p>Why did the JavaScript developer go to the bar? <b>Because he couldn't handle his <i>Promise</i>s</b></p>\n```\n\n----------------------------------------\n\nTITLE: Defining HTMLConfig Type for Lexical Import/Export in TypeScript\nDESCRIPTION: This TypeScript code defines the HTMLConfig type used in Lexical for configuring HTML import and export behavior. It includes optional properties for export (DOMExportOutputMap) and import (DOMConversionMap) configurations.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ntype HTMLConfig = {\n  export?: DOMExportOutputMap;  // Optional map defining how nodes are exported to HTML.\n  import?: DOMConversionMap;     // Optional record defining how HTML is converted into nodes.\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Prefixed Node States in Lexical\nDESCRIPTION: Shows how to properly namespace state keys to avoid collisions when creating plugins. Includes examples of both individual states and grouped states using TypeScript types.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/node-replacement.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst color = createState('awesome-lexical-color', /** your parse fn */)\nconst bgColor = createState('awesome-lexical-bg-color', /** your parse fn */)\n\n// Or you can add all your state inside an object:\ntype AwesomeLexical = {\n  color?: string;\n  bgColor?: string;\n  padding?: number\n}\nconst awesomeLexical = createState('awesome-lexical', /** your parse fn which returns AwesomeLexical type */)\n```\n\n----------------------------------------\n\nTITLE: Vanilla JavaScript Implementation\nDESCRIPTION: Demonstrates how to apply the theme configuration using vanilla JavaScript with the createEditor function.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/getting-started/theming.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {createEditor} from 'lexical';\n\nconst editor = createEditor({\n  namespace: 'MyEditor',\n  theme: exampleTheme,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Edit Mode in LexicalComposer with React\nDESCRIPTION: Configures the edit mode for a Lexical editor when using the React integration. This is done through the initialConfig property of the LexicalComposer component.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/read-only.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<LexicalComposer initialConfig={{editable: true}}>\n  ...\n</LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lexical Test Structure with Async Updates in JavaScript\nDESCRIPTION: Illustrates the structure of Lexical tests using async/await syntax. This approach ensures that updates are processed sequentially, mimicking the microtask queue behavior of the editor.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nawait editor.update(updateA);\nawait editor.update(updateB);\n```\n\n----------------------------------------\n\nTITLE: Checking Current Edit Mode in Lexical\nDESCRIPTION: Retrieves the current edit mode status of a Lexical editor. Returns a boolean indicating whether the editor is in edit mode (true) or read mode (false).\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/read-only.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst isEditable = editor.isEditable(); // Returns true or false\n```\n\n----------------------------------------\n\nTITLE: Release Notes v0.7.1 to v0.6.2\nDESCRIPTION: A detailed changelog documenting the evolution of the Lexical project across multiple versions, including breaking changes, new features, bug fixes, and improvements to the codebase.\nSOURCE: https://github.com/facebook/lexical/blob/main/CHANGELOG.md#2025-04-13_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.7.1 (2022-12-11)\n\nContains several small bug fixes from the Lexical 0.7.0 release.\n- Fix paste for LexicalLinkPlugin (#3528) Dominic Gannaway\n- RTL fix for checkbox (#3529) shiva-Aluri\n- Add demos section to the navbar (#3507) akmarzhan1\n- Fix lexical-offset (#3526) Dominic Gannaway\n- Add missing Flow type for indentation plugin (#3527) John Flockton\n- Docs: fix \"node\" type in \"Node Overrides\" example code (#3525) Chris Montrois\n- Fix small Flow error (#3523) John Flockton\n```\n\n----------------------------------------\n\nTITLE: Creating a Lexical Editor with Specified Edit Mode\nDESCRIPTION: Creates a new Lexical editor instance with the editable property set. This determines whether the editor starts in edit mode (true) or read mode (false).\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/read-only.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst editor = createEditor({\n  editable: true,\n  ...\n})\n```\n\n----------------------------------------\n\nTITLE: Illustrating Lexical's Current API Structure with $ Functions in JavaScript\nDESCRIPTION: Demonstrates the current API structure of Lexical using $ prefixed functions. This approach leverages lexical scope for EditorState manipulation, improving clarity and reducing parameter passing.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\neditor.update(() => ...);\neditor.registerNodeTransform(FooNode, () => ...);\neditor.getEditorState().read(...);\n```\n\n----------------------------------------\n\nTITLE: Registering Markdown Shortcuts Manually\nDESCRIPTION: Shows how to register markdown shortcuts manually without using the React plugin by using the registerMarkdownShortcuts function.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/README.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  registerMarkdownShortcuts,\n  TRANSFORMERS,\n} from '@lexical/markdown';\n\nconst editor = createEditor(...);\nregisterMarkdownShortcuts(editor, TRANSFORMERS);\n```\n\n----------------------------------------\n\nTITLE: Importing Lexical React Components\nDESCRIPTION: Basic imports for Lexical React components used to set up the editor with plugins.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {OnChangePlugin} from '@lexical/react/LexicalOnChangePlugin';\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Lexical Collaboration\nDESCRIPTION: Command to install the minimum required dependencies for setting up Lexical collaboration with React and Yjs.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/collaboration/react.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i -S @lexical/react @lexical/yjs lexical react react-dom y-websocket yjs\n```\n\n----------------------------------------\n\nTITLE: Child Node Traversal Example - TypeScript\nDESCRIPTION: Shows how adjacent nodes relate to first/last children using $getChildCaret. Demonstrates both forward and backward traversal through child nodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst carets = [...$getChildCaret($getRoot(), 'next')];\n\n// next starts at the first child\nexpect(carets).toEqual([\n  $getSiblingCaret(paragraphA, 'next'),\n  $getSiblingCaret(paragraphB, 'next'),\n  $getSiblingCaret(paragraphC, 'next'),\n]);\n\n// previous starts at the last child\nconst prevCarets = [...$getChildCaret($getRoot(), 'previous')];\nexpect(prevCarets).toEqual([\n  $getSiblingCaret(paragraphC, 'previous'),\n  $getSiblingCaret(paragraphB, 'previous'),\n  $getSiblingCaret(paragraphA, 'previous'),\n]);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lexical's Old API Structure in JavaScript\nDESCRIPTION: Shows the previous API structure of Lexical before the introduction of $ prefixed functions. This snippet illustrates how editor updates and text transforms were handled using callback parameters.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/faq.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Mid 2020 API\neditor.update((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\neditor.addTextTransform((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Editor with Markdown Content in React\nDESCRIPTION: Shows how to initialize a Lexical editor with markdown content using the LexicalComposer and RichTextPlugin components in React.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/README.md#2025-04-13_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<LexicalComposer initialConfig={{\n  editorState: () => $convertFromMarkdownString(markdown, TRANSFORMERS)\n}}>\n  <RichTextPlugin />\n</LexicalComposer>\n```\n\n----------------------------------------\n\nTITLE: Advanced ESLint Configuration for Lexical with Custom Rules\nDESCRIPTION: Extended configuration that customizes the pattern-matching behavior of the Lexical ESLint plugin, showing default implementations for reference.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n{\n  \"plugins\": [\n    // ...\n    \"@lexical\"\n  ],\n  \"rules\": {\n    // ...\n    \"@lexical/rules-of-lexical\": [\n      \"error\",\n      {\n        \"isDollarFunction\": [\"^\\\\$[a-z_]\"],\n        \"isIgnoredFunction\": [],\n        \"isLexicalProvider\": [\n          \"parseEditorState\",\n          \"read\",\n          \"registerCommand\",\n          \"registerNodeTransform\",\n          \"update\"\n        ],\n        \"isSafeDollarFunction\": [\"^\\\\$is\"]\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting WebSocket Server for Yjs\nDESCRIPTION: Command to start a WebSocket server for Yjs collaboration with persistence enabled.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/collaboration/react.md#2025-04-13_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ HOST=localhost PORT=1234 YPERSISTENCE=./yjs-wss-db npx y-websocket\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical with npm\nDESCRIPTION: Command to install the core Lexical package and React bindings via npm\nSOURCE: https://github.com/facebook/lexical/blob/main/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save lexical @lexical/react\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical Editor State to Markdown in a Server Environment\nDESCRIPTION: Example demonstrating how to use the headless editor in a server context to convert a Lexical editor state to Markdown format, using the @lexical/markdown transformers.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-headless/README.md#2025-04-13_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst { createHeadlessEditor } = require('@lexical/headless');\nconst { $convertToMarkdownString, TRANSFORMERS } = require('@lexical/markdown');\n\napp.get('article/:id/markdown', async (req, res) => {\n  const editor = createHeadlessEditor({\n    nodes: [],\n    onError: () => {},\n  });\n\n  const articleEditorStateJSON = await loadArticleBody(req.query.id);\n  editor.setEditorState(editor.parseEditorState(articleEditorStateJSON));\n\n  editor.update(() => {\n    const markdown = $convertToMarkdownString(TRANSFORMERS);\n    res.send(markdown);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Extending Recommended ESLint Configuration for Lexical\nDESCRIPTION: ESLint configuration that extends the recommended configuration provided by the Lexical plugin.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n{\n  \"extends\": [\n    // ...\n    \"plugin:@lexical/recommended\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Formatting Examples for Rich Text\nDESCRIPTION: Examples of different HTML formats that produce the same visual output, demonstrating why HTML alone can be too flexible for reliable text editing.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/editor-state.md#2025-04-13_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<i><b>Lexical</b></i>\n<i><b>Lex<b><b>ical</b></i>\n<b><i>Lexical</i></b>\n```\n\n----------------------------------------\n\nTITLE: Implementing CheckListPlugin\nDESCRIPTION: Implementation of the CheckListPlugin, which adds support for checklists with toggleable check/uncheck marks. Requires additional CSS for proper rendering.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/plugins.md#2025-04-13_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<CheckListPlugin />\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical and @lexical/react packages\nDESCRIPTION: Command to install the required npm packages for implementing a Lexical editor in React applications.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-react/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save lexical @lexical/react\n```\n\n----------------------------------------\n\nTITLE: Sibling Node Direction Example - TypeScript\nDESCRIPTION: Illustrates how iteration direction works with $getSiblingCaret, showing both forward and backward traversal from a middle node.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst carets = [...$getSiblingCaret(paragraphB, 'next')];\nexpect(carets).toEqual([\n  $getSiblingCaret(paragraphC, 'next'),\n]);\n\nconst prevCarets = [...$getSiblingCaret(paragraphB, 'previous')];\nexpect(prevCarets).toEqual([\n  $getSiblingCaret(paragraphA, 'previous'),\n]);\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running Tests for Lexical\nDESCRIPTION: Commands for installing project dependencies, starting the development server, and running e2e tests. The local server must be running for e2e tests to work.\nSOURCE: https://github.com/facebook/lexical/blob/main/CONTRIBUTING.md#2025-04-13_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run test-e2e-chromium\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Building Static Website Content\nDESCRIPTION: Generates static website content in the build directory for deployment to any static hosting service.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/README.md#2025-04-13_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical Table Package\nDESCRIPTION: Command to install the necessary npm packages for using tables in Lexical. Requires both @lexical/table for table functionality and @lexical/react for React integration.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-table/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lexical/table @lexical/react\n```\n\n----------------------------------------\n\nTITLE: Demonstrating No-Op with NodeCaret in TypeScript\nDESCRIPTION: Example showing a no-op operation with NodeCaret where a text node is inserted and immediately removed, leaving the origin unaffected except for being marked dirty.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// The origin is unaffected (other than being marked dirty)\ncaret.insert($createTextNode('no-op')).remove();\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Launches a local development server that opens a browser window and supports live reloading of changes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/README.md#2025-04-13_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Safari Development Environment Setup\nDESCRIPTION: Commands for setting up Safari extension development environment including Xcode configuration and build processes. Includes commands for production builds and App Store uploads.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-devtools/README.md#2025-04-13_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install Xcode\n\n# Environment setup\nsudo xcode-select -s /Applications/Xcode.app\nxcodebuild --install\nsudo xcodebuild -license\nxcodebuild -runFirstLaunch\n\n# Normal operation\nnpm run dev:safari\n\n# Build & upload to Apple Connect\nBUILD_VERSION=0 npm run safari:archive \nPASSWORD=\"XXX\" npm run safari:upload\n```\n\n----------------------------------------\n\nTITLE: Generating Lexical Nodes from DOM and Initializing Editor\nDESCRIPTION: This snippet illustrates the process of generating Lexical nodes from a DOM instance and then using those nodes to initialize a Lexical editor or insert them at a specific selection. It uses the $generateNodesFromDOM function to convert DOM to Lexical nodes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst nodes = $generateNodesFromDOM(editor, dom);\n\n// Once you have the lexical nodes you can initialize an editor instance with the parsed nodes.\nconst editor = createEditor({ ...config, nodes });\n\n// Or insert them at a selection.\n$insertNodes(nodes);\n```\n\n----------------------------------------\n\nTITLE: Lexical v0.6.0 Changelog\nDESCRIPTION: Release notes documenting the changes, improvements and bug fixes in version 0.6.0 of the Lexical text editor, including mandatory ErrorBoundary in RichTextPlugin, enhanced selection handling, and improved drag & drop functionality.\nSOURCE: https://github.com/facebook/lexical/blob/main/CHANGELOG.md#2025-04-13_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.6.0 (2022-10-31)\n\n- [0.6] Make RichTextPlugin ErrorBoundary mandatory (#3295) Gerard Rovira\n- Optional decorator nodes selection with keyboard navigation (#3292) Ruslan Piliuta\n- Keep selection if state was not cloned (#3294) Maksim Horbachevsky\n- Preserve selection for pending state (#3293) Maksim Horbachevsky\n- Handle quotes in increment-version changelog (#3291) Gerard Rovira\n```\n\n----------------------------------------\n\nTITLE: Configuring List Theming in Lexical Editor\nDESCRIPTION: Example TypeScript configuration for styling lists in Lexical editor. The code shows the structure of the theme object that can be passed to the editor config to customize the appearance of different list types, list items, and nested lists.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-list/README.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  list?: {\n    // Applies to all lists of type \"bullet\"\n    ul?: EditorThemeClassName;\n    // Used to apply specific styling to nested levels of bullet lists\n    // e.g., [ 'bullet-list-level-one', 'bullet-list-level-two' ]\n    ulDepth?: Array<EditorThemeClassName>;\n    // Applies to all lists of type \"number\"\n    ol?: EditorThemeClassName;\n    // Used to apply specific styling to nested levels of number lists\n    // e.g., [ 'number-list-level-one', 'number-list-level-two' ]\n    olDepth?: Array<EditorThemeClassName>;\n    // Applies to all list items\n    listitem?: EditorThemeClassName;\n    // Applies to all list items with checked property set to \"true\"\n    listitemChecked?: EditorThemeClassName;\n    // Applies to all list items with checked property set to \"false\"\n    listitemUnchecked?: EditorThemeClassName;\n    // Applies only to list and list items that are not at the top level.\n    nested?: {\n      list?: EditorThemeClassName;\n      listitem?: EditorThemeClassName;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Lexical ESLint Plugin in TypeScript\nDESCRIPTION: Initial TypeScript file for the Lexical ESLint plugin. It exports a plugin object with metadata and an empty rules object, serving as a starting point for the ESLint plugin implementation.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/maintainers-guide.md#2025-04-13_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {name, version} from '../package.json';\n\nconst plugin = {\n  meta: {name, version},\n  rules: {},\n};\n\nexport default plugin;\n```\n\n----------------------------------------\n\nTITLE: Running Lexical Example Locally with npm\nDESCRIPTION: Command to install dependencies and run the Lexical example locally using npm. This sets up the development environment for the vanilla JavaScript Lexical example.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/vanilla-js/README.md#2025-04-13_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Markdown Version History Entry v0.8.0\nDESCRIPTION: Changelog entry for version 0.8.0 released on 2023-02-09, documenting breaking changes including removal of list functions and refactoring of ContentEditable types.\nSOURCE: https://github.com/facebook/lexical/blob/main/CHANGELOG.md#2025-04-13_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.8.0 (2023-02-09)\n\nThis release includes some breaking changes, including:\n    - Remove of `indentList` and `outdentList` from `@lexical/list`.\n    - Refactor of the `LexicalContentEditable` types from `@lexical/react` to make them more accurate with `HTMLDivElement` attributes.\n```\n\n----------------------------------------\n\nTITLE: Sibling Node Traversal Example - TypeScript\nDESCRIPTION: Demonstrates basic sibling node traversal using $getSiblingCaret on the root node. Shows that root nodes do not have siblings.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/traversals.md#2025-04-13_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst carets = [...$getSiblingCaret($getRoot(), 'next')];\nexpect(carets).toEqual([]);\n```\n\n----------------------------------------\n\nTITLE: Running E2E Tests in Lexical Playground\nDESCRIPTION: Commands to start the development server and run end-to-end tests in a specific browser (Chromium, Firefox, or WebKit) using Playwright.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/testing.md#2025-04-13_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start &\nnpm run test-e2e-chromium # or -firefox, -webkit\n```\n\n----------------------------------------\n\nTITLE: Creating a New Svelte Project with npm\nDESCRIPTION: Commands to create a new Svelte project using npm. It shows how to create a project in the current directory or in a new directory.\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-sveltekit-vanilla-js/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Parsing HTML String to DOM in Headless Environment\nDESCRIPTION: This code shows how to parse an HTML string into a DOM instance using JSDom in a headless environment. This is an alternative to the browser-based parsing method when working in a Node.js context.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md#2025-04-13_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// In a headless environment you can use a package such as JSDom to parse the HTML string.\nconst dom = new JSDOM(htmlString);\n```\n\n----------------------------------------\n\nTITLE: Markdown Version History Entry v0.8.1\nDESCRIPTION: Changelog entry for version 0.8.1 released on 2023-02-22, containing various bug fixes and improvements including CSS cache cloning, Chinese character support, and autocapitalization fixes.\nSOURCE: https://github.com/facebook/lexical/blob/main/CHANGELOG.md#2025-04-13_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.8.1 (2023-02-22)\n\n- Clone objects from the CSS cache before mutating them (#3945) Brian Birtles\n- added docsfeature-button in lexical playground issue#3918 (#3935) Mohan Sai Potla\n- fix: change from  to  (#3942) Asim Kattum Thazha\n- Added Chinese character support for native webkit (#3846) Annabelle Almås\n- Fix autocapitalization (#3881) Gerard Rovira\n```\n\n----------------------------------------\n\nTITLE: Autofix Result for Exported Functions\nDESCRIPTION: The corrected code for exported functions, showing how the ESLint rule creates a deprecated alias to maintain backward compatibility.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nexport function $exportedInvalidFunction() {\n  return $getRoot();\n}\n/** @deprecated renamed to {@link $exportedInvalidFunction} by @lexical/eslint-plugin rules-of-lexical */\nexport const exportedInvalidFunction = $exportedInvalidFunction;\n```\n\n----------------------------------------\n\nTITLE: Creating Package.json for Lexical ESLint Plugin\nDESCRIPTION: Example of an initial package.json file for a new Lexical package (lexical-eslint-plugin). It includes basic metadata, version information, and repository details.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/maintainers-guide.md#2025-04-13_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"@lexical/eslint-plugin\",\n  \"description\": \"\",\n  \"keywords\": [\n    \"lexical\",\n    \"editor\"\n  ],\n  \"version\": \"0.14.3\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/facebook/lexical.git\",\n    \"directory\": \"packages/lexical-eslint-plugin\"\n  },\n  \"main\": \"LexicalEslintPlugin.js\",\n  \"types\": \"index.d.ts\",\n  \"bugs\": {\n    \"url\": \"https://github.com/facebook/lexical/issues\"\n  },\n  \"homepage\": \"https://github.com/facebook/lexical#readme\"\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Example with Autofix for Exported Functions\nDESCRIPTION: Example showing how exported functions using $functions are handled by the autofix, requiring special treatment to maintain compatibility.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nexport function exportedInvalidFunction() {\n  return $getRoot();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating useMemo Cache Effect in React 19\nDESCRIPTION: Code reference showing how useMemo caches values across StrictMode re-renders in React 19, affecting editor instance creation.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/faq.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// @refresh reset\n```\n\n----------------------------------------\n\nTITLE: Autofix Result for Name Conflict Resolution\nDESCRIPTION: The corrected code when there's a naming conflict, showing how the ESLint rule adds a suffix to avoid conflicts.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nimport {$getRoot} from 'lexical';\nfunction InvalidComponent() {\n  const [editor] = useLexicalComposerContext();\n  const $getRoot_ = useCallback(() => $getRoot(), []);\n  return (<button onClick={() => editor.update(() => $getRoot_())} />);\n}\n```\n\n----------------------------------------\n\nTITLE: Autofix Result for Renaming Functions\nDESCRIPTION: The corrected code after ESLint autofix, showing both functions properly prefixed with $.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nfunction $invalidFunction() {\n  return $getRoot();\n}\nfunction $callsInvalidFunction() {\n  return $invalidFunction();\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing DOM for Headless HTML Export in Lexical\nDESCRIPTION: This snippet demonstrates how to set up a headless browser environment using JSDom for HTML export in Lexical. It initializes the global window and document objects, which may be necessary for certain operations.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// In a headless mode, you need to initialize a headless browser implementation such as JSDom.\nconst dom = new JSDOM();\n// @ts-expect-error\nglobal.window = dom.window;\nglobal.document = dom.window.document;\n// You may also need to polyfill DocumentFragment or navigator in certain cases.\n```\n\n----------------------------------------\n\nTITLE: Valid Example of $function Convention in Lexical\nDESCRIPTION: Example of correctly named $function that can call other $functions, following Lexical's function naming convention.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nfunction $namedCorrectly() {\n  return $getRoot();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the Emoji Plugin Example\nDESCRIPTION: Command line instructions for installing dependencies and running the development server for the emoji plugin example.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/vanilla-js-plugin/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Valid Example of Using $functions in Class Methods\nDESCRIPTION: Example showing that $functions can be used within class methods, specifically within a CustomNode class extending ElementNode.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nclass CustomNode extends ElementNode {\n  appendText(string) {\n    this.appendChild($createTextNode(string));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom ESLint Configuration for Lexical\nDESCRIPTION: Manual ESLint configuration for the Lexical plugin, allowing more fine-grained control over rule settings.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n{\n  \"plugins\": [\n    // ...\n    \"@lexical\"\n  ],\n  \"rules\": {\n    // ...\n    \"@lexical/rules-of-lexical\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Focus Changes in Older Lexical Versions (JavaScript)\nDESCRIPTION: Demonstrates how to prevent focus changes in older versions of Lexical by temporarily setting the editor as not editable during updates or command dispatches.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/selection.md#2025-04-13_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// NOTE: This code should be *outside* of your update or command listener, e.g.\n//       directly in the DOM event listener\nconst prevEditable = editor.isEditable();\neditor.setEditable(false);\neditor.update(\n  () => {\n    // run your update code or editor.dispatchCommand in here\n  }, {\n    onUpdate: () => {\n      editor.setEditable(prevEditable);\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Running Lexical Collaboration Example Locally\nDESCRIPTION: Command to install dependencies and run the Lexical collaboration mode example in a local development environment.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/react-rich-collab/README.md#2025-04-13_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm i && npm run dev:local\n```\n\n----------------------------------------\n\nTITLE: Installing @lexical/headless Package via npm\nDESCRIPTION: Command to install the @lexical/headless package as a dependency in your project using npm.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-headless/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @lexical/headless\n```\n\n----------------------------------------\n\nTITLE: Lexical v0.16.1 Changelog Entry\nDESCRIPTION: Markdown formatted changelog entry listing all changes, bug fixes and improvements made in Lexical v0.16.1 release.\nSOURCE: https://github.com/facebook/lexical/blob/main/CHANGELOG.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.16.1 (2024-07-01)\n\n- lexical-playgroundlexical-poll Bug Fix Fixes undefined context inside Poll add option (#6361) Roman Lyubimov\n- (docs) Add existing history page to navigation (#6359) Oliver Lassen\n- Lexical Fix broken sync due to deprecation of ReactDOMComet to ReactDOM (#6358) Sahejkm\n- lexical-html Bug Fix Preserve text alignment of nested block elements, when converting HTML to Lexical Nodes (#6340) Zigopis Nikolaos\n- Replace await with async in lexical-headlessREADME.md (#6343) Kibaek Kim\n- Bug Fix Fix selection when hitting shiftarrowdown into a table. (#6274) Serey Roth\n- Update feature request template (#6316) Sherry\n- Add impact description to bug report issue template (#6317) Sherry\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Lexical Rich Text Example\nDESCRIPTION: Command to install dependencies and run the development server for the Lexical rich text example.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/react-rich/README.md#2025-04-13_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Importing the @lexical/text Package\nDESCRIPTION: The code snippet shows the package name for importing text utilities in the Lexical editor framework.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-text/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/text`\n```\n\n----------------------------------------\n\nTITLE: Referencing Lexical Plain Text Package in Markdown\nDESCRIPTION: This code snippet demonstrates how to reference the @lexical/plain-text package in a markdown document. It's used to introduce the package and its purpose.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-plain-text/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/plain-text`\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical Offset Package Reference\nDESCRIPTION: Package reference for @lexical/offset showing the package name and its purpose for selection offset helpers in Lexical.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-offset/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/offset`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Issues with Flat Version Property\nDESCRIPTION: Examples showing how using a flat version property can lead to problems with subclassing and versioning in node hierarchies.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/concepts/serialization.md#2025-04-13_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nclass TextNode {\n  exportJSON() {\n    return { /* ... */, version: 1 };\n  }\n}\nclass ExtendedTextNode extends TextNode {\n  exportJSON() {\n    return { ...super.exportJSON() };\n  }\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nclass TextNode {\n  exportJSON() {\n    return { /* ... */, version: 2 };\n  }\n}\nclass ExtendedTextNode extends TextNode {\n  exportJSON() {\n    // The super's layout has changed, but the version information is lost\n    return { ...super.exportJSON(), version: 1 };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing @lexical/rich-text Package in Markdown\nDESCRIPTION: A reference to the @lexical/rich-text package name in markdown format. This is the core package being described that provides basic text editing functionality and rich text features for Lexical.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-rich-text/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/rich-text`\n```\n\n----------------------------------------\n\nTITLE: Installing @lexical/mark Package for Lexical Editor\nDESCRIPTION: Package reference for @lexical/mark, which contains utilities for marking content in the Lexical editor framework.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-mark/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/mark`\n\n[![See API Documentation](https://lexical.dev/img/see-api-documentation.svg)](https://lexical.dev/docs/api/modules/lexical_mark)\n\nThis package contains helpers and nodes for wrapping content in marks for Lexical.\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Lexical DevTools\nDESCRIPTION: Terminal commands for installing dependencies and starting the Lexical Developer Tools development server.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-devtools/SOURCE_CODE_REVIEW.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Displaying Lexical Utils Package Name in Markdown\nDESCRIPTION: This code snippet shows how to format the package name @lexical/utils in Markdown, using backticks for inline code formatting.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-utils/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`@lexical/utils`\n```\n\n----------------------------------------\n\nTITLE: Referencing Alternative Package in Markdown\nDESCRIPTION: A markdown link referencing the @lexical/plain-text package as an alternative for users who don't need rich text functionality. This links to the documentation page for the plain-text package.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-rich-text/README.md#2025-04-13_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[@lexical/plain-text](https://lexical.dev/docs/packages/lexical-plain-text)\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive React Button in MDX\nDESCRIPTION: This code snippet demonstrates how to embed a React button component in an MDX blog post. The button triggers a JavaScript alert with the message 'button clicked!' when clicked, showcasing the interactive capabilities of MDX.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/blog/2021-08-01-mdx-blog-post.mdx#2025-04-13_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n----------------------------------------\n\nTITLE: Displaying Lexical Overflow Package Header in Markdown\nDESCRIPTION: A markdown header showing the @lexical/overflow package name with a link to its API documentation on lexical.dev, along with a brief description of the package's purpose.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-overflow/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/overflow`\n\n[![See API Documentation](https://lexical.dev/img/see-api-documentation.svg)](https://lexical.dev/docs/api/modules/lexical_overflow)\n\nThis package contains selection overflow helpers and nodes for Lexical.\n```\n\n----------------------------------------\n\nTITLE: Importing Lexical DevTools Core Package\nDESCRIPTION: Package import reference for the Lexical DevTools Core library. This package contains debugging and development tools for the Lexical editor framework.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-devtools-core/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/devtools-core`\n```\n\n----------------------------------------\n\nTITLE: Running Lexical Table Plugin Example Locally\nDESCRIPTION: Command to install dependencies and start the development server for the Lexical Table Plugin example.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/react-table/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Rendering Markdown Link in React\nDESCRIPTION: This snippet demonstrates how to create a styled link using JSX and Markdown within a React component. It includes custom CSS classes for styling and uses a template literal for the link text.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/react/index.md#2025-04-13_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<a\n    class=\"whitespace-nowrap rounded-md bg-blue-500 px-6 py-2 text-sm font-bold text-white transition-opacity hover:text-white hover:no-underline hover:opacity-90\"\n    href=\"/docs/getting-started/react\">\n{`Getting Started Guide`}\n</a>\n```\n\n----------------------------------------\n\nTITLE: Displaying Package Name in Markdown\nDESCRIPTION: This snippet shows how to display the package name @lexical/code in a Markdown file using backticks for inline code formatting.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-code/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `@lexical/code`\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Gallery Page Component in JSX\nDESCRIPTION: This code snippet imports required components and renders the GalleryPage component. It uses JSX syntax to structure the page content.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/src/pages/gallery.md#2025-04-13_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { FBInternOnly } from 'docusaurus-plugin-internaldocs-fb/internal';\nimport GalleryPage from '@site/src/components/Gallery/GalleryPage';\n\n# Gallery\n<GalleryPage/>\n```\n\n----------------------------------------\n\nTITLE: Local Development Setup Commands\nDESCRIPTION: Basic command for starting local development of the Lexical DevTools extension using WXT framework. Includes hot reload instructions.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-devtools/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run dev\n# In browser: Alt+R to force reload extension\n```\n\n----------------------------------------\n\nTITLE: Invalid Example with Name Conflict Resolution\nDESCRIPTION: Example showing how the ESLint rule handles renaming when there's already a variable with the suggested name in scope.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_11\n\nLANGUAGE: js\nCODE:\n```\nimport {$getRoot} from 'lexical';\nfunction InvalidComponent() {\n  const [editor] = useLexicalComposerContext();\n  const getRoot = useCallback(() => $getRoot(), []);\n  return (<button onClick={() => editor.update(() => getRoot())} />);\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Lexical Rich Text Package in Markdown\nDESCRIPTION: This code snippet shows how to reference the @lexical/rich-text package in a markdown document. It's used to suggest an alternative package for more advanced text editing features.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-plain-text/README.md#2025-04-13_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[@lexical/rich-text](https://lexical.dev/docs/packages/lexical-rich-text)\n```\n\n----------------------------------------\n\nTITLE: Package Import Reference for @lexical/file\nDESCRIPTION: Reference to the @lexical/file package, which provides file import/export functionality for the Lexical editor framework.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-file/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`@lexical/file`\n```\n\n----------------------------------------\n\nTITLE: Installing Website Dependencies\nDESCRIPTION: Installs all required npm dependencies using yarn package manager.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Installing Astro Basics Template using NPM\nDESCRIPTION: Command to create a new Astro project using the basics template via npm create\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-astro-react/README.md#2025-04-13_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm create astro@latest -- --template basics\n```\n\n----------------------------------------\n\nTITLE: Building Svelte Project for Production\nDESCRIPTION: Command to create a production version of the Svelte app. This builds the app for deployment.\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-sveltekit-vanilla-js/README.md#2025-04-13_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Invalid Example with Autofix for Renaming Functions\nDESCRIPTION: Example of improperly named functions accessing $functions, showing how the ESLint rule would automatically fix by adding $ prefix.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nfunction invalidFunction() {\n  return $getRoot();\n}\nfunction $callsInvalidFunction() {\n  return invalidFunction();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical ESLint Plugin with npm\nDESCRIPTION: Command for installing the @lexical/eslint-plugin package as a development dependency using npm.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-eslint-plugin/README.md#2025-04-13_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @lexical/eslint-plugin --save-dev\n```\n\n----------------------------------------\n\nTITLE: Starting Svelte Development Server\nDESCRIPTION: Commands to start the Svelte development server. It includes an option to open the app in a new browser tab automatically.\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-sveltekit-vanilla-js/README.md#2025-04-13_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Defining Blog Post Front Matter in Markdown\nDESCRIPTION: This snippet shows the front matter of a blog post, including metadata such as slug, title, authors, and tags. It's used to provide essential information about the post.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/blog/2019-05-29-long-blog-post.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nslug: long-blog-post\ntitle: Long Blog Post\nauthors: endi\ntags: [hello, docusaurus]\n---\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Jest in Lexical\nDESCRIPTION: Command to run unit tests for the core Lexical package using Jest. These tests focus on the API functionality.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/testing.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test-unit\n```\n\n----------------------------------------\n\nTITLE: Implementing Truncation in Markdown Blog Posts\nDESCRIPTION: This snippet demonstrates how to use an HTML comment to truncate a blog post in list views. It's placed after the summary and before the main content.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/blog/2019-05-29-long-blog-post.md#2025-04-13_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n<!--truncate-->\n```\n\n----------------------------------------\n\nTITLE: Installing and Running React Plain Text Lexical Example\nDESCRIPTION: Command to install dependencies and run the development server for the React Plain Text Lexical example.\nSOURCE: https://github.com/facebook/lexical/blob/main/examples/react-plain-text/README.md#2025-04-13_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i && npm run dev\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Lexical ESLint Plugin in TypeScript\nDESCRIPTION: Unit test for the Lexical ESLint plugin. It verifies that the plugin exports an object with 'meta' and 'rules' properties, ensuring the basic structure of the plugin is correct.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/maintainers-guide.md#2025-04-13_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport plugin from '@lexical/eslint-plugin';\n\ndescribe('LexicalEslintPlugin', () => {\n  it('exports a plugin with meta and rules', () => {\n    expect(Object.keys(plugin).sort()).toMatchObject(['meta', 'rules']);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Running Next.js Development Server\nDESCRIPTION: Commands to start the Next.js development server using different package managers. This allows developers to run the project locally for development and testing.\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-nextjs/README.md#2025-04-13_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n# or\nbun dev\n```\n\n----------------------------------------\n\nTITLE: Displaying Markdown Link for API Documentation\nDESCRIPTION: This snippet shows a markdown-formatted link to the API documentation for the @lexical/yjs package. It uses an image as the link text, pointing to the Lexical documentation website.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-yjs/README.md#2025-04-13_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[![See API Documentation](https://lexical.dev/img/see-api-documentation.svg)](https://lexical.dev/docs/api/modules/lexical_yjs)\n```\n\n----------------------------------------\n\nTITLE: Deploying Website Using SSH\nDESCRIPTION: Deploys the website using SSH authentication method to GitHub Pages.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/README.md#2025-04-13_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Deploying Website Without SSH\nDESCRIPTION: Deploys the website using GitHub username authentication to GitHub Pages.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/README.md#2025-04-13_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Astro Project Directory Structure\nDESCRIPTION: Overview of the default directory structure and key files in an Astro project, showing the organization of components, layouts, pages, and static assets\nSOURCE: https://github.com/facebook/lexical/blob/main/scripts/__tests__/integration/fixtures/lexical-esm-astro-react/README.md#2025-04-13_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n/\n├── public/\n│   └── favicon.svg\n├── src/\n│   ├── components/\n│   │   └── Card.astro\n│   ├── layouts/\n│   │   └── Layout.astro\n│   └── pages/\n│       └── index.astro\n└── package.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Docusaurus Blog Post Front Matter in YAML\nDESCRIPTION: YAML front matter configuration for a Docusaurus blog post that specifies the slug, title, author details (name, title, GitHub URL, and avatar), and associated tags.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/blog/2019-05-28-first-blog-post.md#2025-04-13_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nslug: first-blog-post\ntitle: First Blog Post\nauthors:\n  name: Gao Wei\n  title: Docusaurus Core Team\n  url: https://github.com/wgao19\n  image_url: https://github.com/wgao19.png\ntags: [hola, docusaurus]\n---\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering ErrorCodePage Component in JSX\nDESCRIPTION: This code snippet imports necessary components and renders the ErrorCodePage component within an OssOnly wrapper. It's likely part of a documentation page for Lexical error codes.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/error.md#2025-04-13_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { OssOnly } from 'docusaurus-plugin-internaldocs-fb/internal';\nimport ErrorCodePage from '@site/src/components/ErrorCodePage';\n\n# Error Code\n<OssOnly>\n<ErrorCodePage/>\n</OssOnly>\n```\n\n----------------------------------------\n\nTITLE: Installing Playwright Browsers for E2E Testing\nDESCRIPTION: Command to install the necessary browser engines (Chromium, Firefox, WebKit) for Playwright end-to-end testing.\nSOURCE: https://github.com/facebook/lexical/blob/main/packages/lexical-website/docs/testing.md#2025-04-13_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx playwright install\n```"
  }
]