[
  {
    "owner": "seperman",
    "repo": "deepdiff",
    "content": "TITLE: Importing DeepDiff Modules in Python\nDESCRIPTION: This snippet demonstrates how to import the core modules of the DeepDiff library.  It shows how to import the main modules DeepDiff, DeepSearch, DeepHash, Delta, and extract, each providing different functionalities for comparing and manipulating Python objects.  No external dependencies are required for the base imports.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff  # For Deep Difference of 2 objects\n>>> from deepdiff import grep, DeepSearch  # For finding if item exists in an object\n>>> from deepdiff import DeepHash  # For hashing objects based on their contents\n>>> from deepdiff import Delta  # For creating delta of objects that can be applied later to other objects.\n>>> from deepdiff import extract  # For extracting a path from an object\n```\n\n----------------------------------------\n\nTITLE: Install DeepDiff via pip\nDESCRIPTION: This snippet provides instructions on how to install the DeepDiff package and its command-line interface using pip. The first command installs the core library. The second installs CLI functionality. The third command installs optional optimization dependencies, which can boost performance. Requires pip to be installed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install deepdiff\n```\n\n----------------------------------------\n\nTITLE: Comparing Identical Objects - Python\nDESCRIPTION: This snippet demonstrates comparing two identical dictionaries using `DeepDiff`. The expected output is an empty dictionary, indicating that no differences were found between the two objects. It tests for equality.  The dictionaries are first assigned and then compared using DeepDiff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = t1\n>>> print(DeepDiff(t1, t2))\n{}\n```\n\n----------------------------------------\n\nTITLE: Detecting Type Changes - Python\nDESCRIPTION: This snippet compares two dictionaries where the type of a value has changed.  It shows how `DeepDiff` detects type changes in the values of a dictionary. The first dictionary contains integer values while the second contains a string. The output uses `pprint` to display the 'type_changes' detected by DeepDiff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = {1:1, 2:\"2\", 3:3}\n>>> pprint(DeepDiff(t1, t2), indent=2)\n{ 'type_changes': { 'root[2]': { 'new_type': <class 'str'>,\n                                     'new_value': '2',\n                                     'old_type': <class 'int'>,\n                                     'old_value': 2}}}\n```\n\n----------------------------------------\n\nTITLE: List Difference Detection - Python\nDESCRIPTION: This snippet uses `DeepDiff` to compare dictionaries containing lists and identify changes in those lists. It demonstrates how `DeepDiff` reports the removed iterable items and the corresponding indices.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3, 4]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2]}}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint (ddiff, indent = 2)\n{'iterable_item_removed': {\"root[4]['b'][2]\": 3, \"root[4]['b'][3]\": 4}}\n```\n\n----------------------------------------\n\nTITLE: List Difference With Ignore Order\nDESCRIPTION: Demonstrates how using ignore_order=True ignores both the order and duplicates in lists, resulting in empty differences when comparing lists with the same elements in different orders.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nt1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3]}}\nt2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 3, 2, 3]}}\nddiff = DeepDiff(t1, t2, ignore_order=True)\nprint (ddiff)\n```\n\n----------------------------------------\n\nTITLE: String Difference Detection with Multiple Line Changes - Python\nDESCRIPTION: This snippet shows a detailed string difference using `DeepDiff` where the string has multi-line differences. It demonstrates the full diff output, showing additions, removals, and context using the standard diff format.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> print (ddiff['values_changed'][\"root[4]['b']\"][\"diff\"])\n--- \n+++ \n@@ -1,5 +1,4 @@\n-world!\n-Goodbye!\n+world\n 1\n 2\n End\n```\n\n----------------------------------------\n\nTITLE: Dynamic Ignore Order with ignore_order_func\nDESCRIPTION: Shows how to use ignore_order_func to selectively ignore order for specific paths in the data structure, allowing fine-grained control over which iterables should be compared with order sensitivity.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nt1 = {\"set\": [1,2,3], \"list\": [1,2,3]}\nt2 = {\"set\": [3,2,1], \"list\": [3,2,1]}\nddiff = DeepDiff(t1, t2, ignore_order_func=lambda level: \"set\" in level.path())\nprint (ddiff)\n```\n\n----------------------------------------\n\nTITLE: Path Change with Verbose Level 2 and ignore_order - Python\nDESCRIPTION: This snippet uses `DeepDiff` with `ignore_order=True` and `verbose_level=2` to analyze changes in a list. The snippet highlights how the position of elements is changed and demonstrates new_path in output when `ignore_order=True` which is helpful when comparing lists.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = [1, 3]\n>>> t2 = [3, 2]\n>>>\n>>>\n>>> diff = DeepDiff(t1, t2, ignore_order=True, verbose_level=2)\n>>> pprint(diff)\n{'values_changed': {'root[0]': {'new_path': 'root[1]',\n                                    'new_value': 2,\n                                    'old_value': 1}}}\n```\n\n----------------------------------------\n\nTITLE: DeepDiff with Custom Item Comparison Function - Python\nDESCRIPTION: This snippet defines a user-provided compare_func for matching dictionary items by 'id' field, which is passed to DeepDiff as iterable_compare_func, making the comparison order-insensitive by logical key. Requires deepdiff and deepdiff.helper.CannotCompare. Inputs are the same as before; output is a minimized diff where only actual content differences are reported, not order changes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\nfrom deepdiff.helper import CannotCompare\ndef compare_func(x, y, level=None):\n    try:\n        return x['id'] == y['id']\n    except Exception:\n        raise CannotCompare() from None\n\ndiff = DeepDiff(t1, t2, iterable_compare_func=compare_func)\n# Only reports content diffs for logically matched items\n```\n\n----------------------------------------\n\nTITLE: Serializing DeepDiff Result using to_json() Method Python\nDESCRIPTION: This snippet provides the correct method for serializing a DeepDiff result object into a JSON string using the built-in `to_json()` method, which handles the necessary type conversions for serialization.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndiff.to_json()\n```\n\n----------------------------------------\n\nTITLE: Custom Object Difference Detection - Python\nDESCRIPTION: This snippet demonstrates comparing custom objects. It defines a class `ClassA` and then compares instances of this class using `DeepDiff`. It detects the value changes in the objects' attributes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> class ClassA(object):\n...     a = 1\n...     def __init__(self, b):\n...         self.b = b\n...\n>>> t1 = ClassA(1)\n>>> t2 = ClassA(2)\n>>>\n>>> pprint(DeepDiff(t1, t2))\n{'values_changed': {'root.b': {'new_value': 2, 'old_value': 1}}}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Order Based on Path Content\nDESCRIPTION: Example demonstrating how to create a custom ignore_order_func that examines the path to determine which collections should ignore order, in this case ignoring order only for paths containing 'a'.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nt1 = {'a': [1, 2], 'b': [3, 4]}\nt2 = {'a': [2, 1], 'b': [4, 3]}\nDeepDiff(t1, t2, ignore_order=True)\n\ndef ignore_order_func(level):\n    return 'a' in level.path()\n\nDeepDiff(t1, t2, ignore_order=True, ignore_order_func=ignore_order_func)\n```\n\n----------------------------------------\n\nTITLE: Attribute Added Detection - Python\nDESCRIPTION: This snippet shows how `DeepDiff` detects the addition of a new attribute to an object. It adds an attribute `c` to `t2` and then compares it with `t1`, demonstrating the detection of the added attribute and the change in `b`.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> t2.c = \"new attribute\"\n>>> pprint(DeepDiff(t1, t2))\n{'attribute_added': [root.c],\n 'values_changed': {'root.b': {'new_value': 2, 'old_value': 1}}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Lists Ignoring Order with Cutoff Parameters in DeepDiff Python\nDESCRIPTION: This snippet shows how to use `ignore_order=True` along with `cutoff_distance_for_pairs` and `cutoff_intersection_for_pairs` to achieve a more precise diff when comparing lists where items might be reordered or have minor differences, allowing DeepDiff to find better pairings.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npprint(DeepDiff(t1, t2, ignore_order=True, cutoff_distance_for_pairs=1, cutoff_intersection_for_pairs=1))\n```\n\n----------------------------------------\n\nTITLE: Detecting List Item Removal with Tree View in DeepDiff (Python)\nDESCRIPTION: Example using DeepDiff's 'tree' view to find items removed from a list nested within a dictionary. It shows accessing the removed item node, traversing up the tree (`.up`) to parent nodes, retrieving the path as a string (`.path()`) or list (`.path(output_format='list')`), and accessing the original list segments (`.t1`, `.t2`) at different levels.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3, 4]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2]}}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> ddiff\n{'iterable_item_removed': [<root[4]['b'][2] t1:3, t2:not present>, <root[4]['b'][3] t1:4, t2:not present>]}\n>>> # Note that the iterable_item_removed is a set. In this case it has 2 items in it.\n>>> # One way to get one item from the set is to convert it to a list\n>>> # And then get the first item of the list:\n>>> removed = list(ddiff['iterable_item_removed'])[0]\n>>> removed\n<root[4]['b'][2] t1:3, t2:not present>\n>>>\n>>> parent = removed.up\n>>> parent\n<root[4]['b'] t1:[1, 2, 3, 4], t2:[1, 2]>\n>>> parent.path()  # gives you the string representation of the path\n\"root[4]['b']\"\n>>> parent.path(output_format='list')  # gives you the list of keys and attributes that make up the path\n[4, 'b']\n>>> parent.t1\n[1, 2, 3, 4]\n>>> parent.t2\n[1, 2]\n>>> parent.up\n<root[4] t1:{'a': 'hello...}, t2:{'a': 'hello...}>\n>>> parent.up.up\n<root t1:{1: 1, 2: 2,...}, t2:{1: 1, 2: 2,...}>\n>>> parent.up.up.t1\n{1: 1, 2: 2, 3: 3, 4: {'a': 'hello', 'b': [1, 2, 3, 4]}}\n>>> parent.up.up.t1 == t1  # It is holding the original t1 that we passed to DeepDiff\nTrue\n```\n\n----------------------------------------\n\nTITLE: Implementing a Distance-Based Difference Operator with Preventing Default Diffing in Python\nDESCRIPTION: This class extends BaseOperator to compare objects based on their Euclidean distance (L2 distance) and prevent further diffing if the distance exceeds a threshold. It requires the math library for distance calculation. The _l2_distance method computes the Euclidean distance between two coordinate points. give_up_diffing calculates this distance and reports it as a custom result if it exceeds the threshold, then blocks further diffing.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nimport math\n\nfrom typing import List\nfrom deepdiff import DeepDiff\nfrom deepdiff.operator import BaseOperator\n\nclass L2DistanceDifferWithPreventDefault(BaseOperator):\n    def __init__(self, regex_paths: List[str], distance_threshold: float):\n        super().__init__(regex_paths)\n        self.distance_threshold = distance_threshold\n    def _l2_distance(self, c1, c2):\n        return math.sqrt(\n            (c1[\"x\"] - c2[\"x\"]) ** 2 + (c1[\"y\"] - c2[\"y\"]) ** 2\n        )\n    def give_up_diffing(self, level, diff_instance):\n        l2_distance = self._l2_distance(level.t1, level.t2)\n        if l2_distance > self.distance_threshold:\n            diff_instance.custom_report_result('distance_too_far', level, {\n                \"l2_distance\": l2_distance\n            })\n        return True\n```\n\n----------------------------------------\n\nTITLE: Handling List Additions/Changes with Tree View in DeepDiff (Python)\nDESCRIPTION: Demonstrates using DeepDiff's 'tree' view to detect both added items and changed values within nested lists. It showcases traversing up (`.up`) and down (`.down`) the tree structure from a detected change node and retrieving the path to nodes using `.path()` (string) or `.path(output_format='list')` (list).\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 3, 2, 3]}}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> pprint(ddiff, indent = 2)\n{ 'iterable_item_added': [<root[4]['b'][3] t1:not present, t2:3>],\n  'values_changed': [<root[4]['b'][1] t1:2, t2:3>, <root[4]['b'][2] t1:3, t2:2>]}\n>>>\n>>> # Note that iterable_item_added is a set with one item.\n>>> # So in order to get that one item from it, we can do:\n>>>\n>>> (added,) = ddiff['iterable_item_added']\n>>> added\n<root[4]['b'][3] t1:not present, t2:3>\n>>> added.up.up\n<root[4] t1:{'a': 'hello...}, t2:{'a': 'hello...}>\n>>> added.up.up.path()\n'root[4]'\n>>> added.up.up.path(output_format='list')  # gives you the list of keys and attributes that make up the path\n[4]\n>>> added.up.up.down\n<root[4]['b'] t1:[1, 2, 3], t2:[1, 3, 2, 3]>\n>>>\n>>> # going up twice and then down twice gives you the same node in the tree:\n>>> added.up.up.down.down == added\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using Default Text View in DeepDiff (Python)\nDESCRIPTION: Demonstrates the default 'text' view of DeepDiff when comparing two dictionaries. Differences, such as added and removed items, are returned in a dictionary where values are sets of strings representing the paths to the changes (e.g., 'root[5]'). This view is obtained by default or by explicitly setting `view='text'`.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from decimal import Decimal\n>>> from deepdiff import DeepDiff\n>>> t1 = {1:1, 3:3, 4:4}\n>>> t2 = {1:1, 3:3, 5:5, 6:6}\n>>> ddiff = DeepDiff(t1, t2)\n>>> print(ddiff)\n{'dictionary_item_added': [root[5], root[6]], 'dictionary_item_removed': [root[4]]}\n```\n\n----------------------------------------\n\nTITLE: Working with DeepDiff Tree View and path() Method Python\nDESCRIPTION: This snippet shows how to use the 'tree' view of a DeepDiff result to navigate the diff structure. It demonstrates accessing a parent node using `.up` and using the node's `path()` method to get the path string or a list representation.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nt1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3, 4]}}\nt2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2]}}\nddiff = DeepDiff(t1, t2, view='tree')\nddiff\nremoved = list(ddiff['iterable_item_removed'])[0]\nremoved\nparent = removed.up\nparent\nparent.path()\nparent.path(output_format='list')\n```\n\n----------------------------------------\n\nTITLE: Reporting List Repetitions with Tree View in DeepDiff (Python)\nDESCRIPTION: Illustrates using DeepDiff's 'tree' view with `ignore_order=True` and `report_repetition=True` options to compare lists while disregarding order but tracking changes in item counts (repetitions). It shows how to access the detailed repetition report (`.repetition`) from a `repetition_change` node and demonstrates that `verbose_level` only affects the string representation, not the underlying data accessible via attributes like `.t1`, `.t2`, and `.repetition`.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = [1, 3, 1, 4]\n>>> t2 = [4, 4, 1]\n>>> ddiff = DeepDiff(t1, t2, ignore_order=True, report_repetition=True, view='tree')\n>>> pprint(ddiff, indent=2)\n{ 'iterable_item_removed': [<root[1] t1:3, t2:not present>],\n  'repetition_change': [<root[3] {'repetition': {'old_repeat': 1,...}>, <root[0] {'repetition': {'old_repeat': 2,...}>]}\n>>>\n>>> # repetition_change is a set with 2 items.\n>>> # in order to get those 2 items, we can do the following.\n>>> # or we can convert the set to list and get the list items.\n>>> # or we can iterate through the set items\n>>>\n>>> (repeat1, repeat2) = ddiff['repetition_change']\n>>> repeat1  # the default verbosity is set to 1.\n<root[3] {'repetition': {'old_repeat': 1,...}>\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> # The actual data regarding the repetitions can be found in the repetition attribute:\n>>> repeat1.repetition\n{'old_repeat': 1, 'new_repeat': 2, 'old_indexes': [3], 'new_indexes': [0, 1]}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> # If you change the verbosity, you will see less:\n>>> ddiff = DeepDiff(t1, t2, ignore_order=True, report_repetition=True, view='tree', verbose_level=0)\n>>> ddiff\n{'repetition_change': [<root[3]>, <root[0]>], 'iterable_item_removed': [<root[1]>]}\n>>> (repeat1, repeat2) = ddiff['repetition_change']\n>>> repeat1\n<root[0]>\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> # But the verbosity level does not change the actual report object.\n>>> # It only changes the textual representaion of the object. We get the actual object here:\n>>> repeat1.repetition\n{'old_repeat': 1, 'new_repeat': 2, 'old_indexes': [3], 'new_indexes': [0, 1]}\n>>> repeat1.t1\n4\n>>> repeat1.t2\n4\n>>> repeat1.up\n<root>\n```\n\n----------------------------------------\n\nTITLE: Calculating Deep Distance Using DeepDiff in Python\nDESCRIPTION: This snippet demonstrates how to use the DeepDiff library in Python to compute the Deep Distance between two objects. Deep Distance is a floating-point value between 0 and 1 indicating the degree of difference, where 0 means no difference and 1 means completely different. The code examples show how to pass get_deep_distance=True to DeepDiff to include this metric in the diff result under the 'deep_distance' key. The snippets cover comparisons of numeric values, lists, and nested iterables, illustrating how the metric reflects varying degrees of similarity. Requires installing the 'deepdiff' Python package.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deep_distance.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> DeepDiff(10.0, 10.1, get_deep_distance=True)\n{'values_changed': {'root': {'new_value': 10.1, 'old_value': 10.0}}, 'deep_distance': 0.0014925373134328302}\n>>> DeepDiff(10.0, 100.1, get_deep_distance=True)\n{'values_changed': {'root': {'new_value': 100.1, 'old_value': 10.0}}, 'deep_distance': 0.24550408719346048}\n>>> DeepDiff(10.0, 1000.1, get_deep_distance=True)\n{'values_changed': {'root': {'new_value': 1000.1, 'old_value': 10.0}}, 'deep_distance': 0.29405999405999406}\n>>> DeepDiff([1], [1], get_deep_distance=True)\n{}\n>>> DeepDiff([1], [1, 2], get_deep_distance=True)\n{'iterable_item_added': {'root[1]': 2}, 'deep_distance': 0.2}\n>>> DeepDiff([1], [1, 2, 3], get_deep_distance=True)\n{'iterable_item_added': {'root[1]': 2, 'root[2]': 3}, 'deep_distance': 0.3333333333333333}\n>>> DeepDiff([[2, 1]], [[1, 2, 3]], ignore_order=True, get_deep_distance=True)\n{'iterable_item_added': {'root[0][2]': 3}, 'deep_distance': 0.1111111111111111}\n```\n\n----------------------------------------\n\nTITLE: Identifying Type Changes with DeepDiff in Python\nDESCRIPTION: This snippet demonstrates the default behavior of DeepDiff when comparing objects with different types but potentially similar values or structure, specifically showing how a list changing to a string is reported as a type change.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":\"world\\n\\n\\nEnd\"}}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint (ddiff, indent = 2)\n{ 'type_changes': { \"root[4]['b']\": { 'new_type': <class 'str'>,\n                                          'new_value': 'world\\n\\n\\nEnd',\n                                          'old_type': <class 'list'>,\n                                          'old_value': [1, 2, 3]}}}\n```\n\n----------------------------------------\n\nTITLE: Serializing DeepDiff Delta Objects to Flat Rows Using Python\nDESCRIPTION: Demonstrates serializing DeepDiff delta objects to a list of flat row named tuples via `Delta.to_flat_rows()` for easy relational database storage or flat processing. The example shows creating diffs and deltas from dictionaries, converting delta to flat rows, and printing the result. It notes that nested dictionaries with single keys are flattened, and when re-applying the delta from flat rows, a `force=True` option may be needed. Code depends on DeepDiff and pprint modules.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pprint import pprint\n>>> from deepdiff import DeepDiff, Delta\n>>> t1 = {\"key1\": \"value1\"}\n>>> t2 = {\"field2\": {\"key2\": \"value2\"}}\n>>> diff = DeepDiff(t1, t2, verbose_level=2)\n>>> pprint(diff, indent=2)\n{ 'dictionary_item_added': {\"root['field2']\": {'key2': 'value2'}},\n  'dictionary_item_removed': {\"root['key1']\": 'value1'}}\n>>> delta = Delta(diff, bidirectional=True)\n>>> flat_rows = delta.to_flat_rows()\n>>> pprint(flat_rows, indent=2)\n[ FlatDeltaRow(path=['field2', 'key2'], action='dictionary_item_added', value='value2'),\n  FlatDeltaRow(path=['key1'], action='dictionary_item_removed', value='value1')]\n```\n\n----------------------------------------\n\nTITLE: Basic List Difference Without Ignore Order\nDESCRIPTION: Example showing how DeepDiff compares lists by default (ignore_order=False), where it detects both value changes and added items when comparing nested lists with different ordering.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nt1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3]}}\nt2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 3, 2, 3]}}\nddiff = DeepDiff(t1, t2)\npprint (ddiff, indent = 2)\n```\n\n----------------------------------------\n\nTITLE: Controlling Diff Granularity to Improve Deep Distance Calculation Using DeepDiff in Python\nDESCRIPTION: This code snippet illustrates the impact of diff granularity on Deep Distance calculation by comparing two deeply nested Python objects using DeepDiff. It demonstrates how the cutoff_intersection_for_pairs parameter controls the level of pass calculations and, consequently, the granularity of the diff. Two diffs are shown: one with the default cutoff_intersection_for_pairs (0.3), resulting in a less granular diff and higher distance value, and another with cutoff_intersection_for_pairs=1, which forces more exhaustive comparisons producing a more detailed diff and a more accurate (lower) Deep Distance value. The snippet displays how to retrieve diff stats like pass and diff counts to understand computational detail. Requires the 'deepdiff' package and 'pprint' for output formatting.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deep_distance.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pprint import pprint\n>>> t1 = [\n...     {\n...         \"key3\": [[[[[[[[[[1, 2, 4, 5]]], [[[8, 7, 3, 5]]]]]]]]]],\n...         \"key4\": [7, 8]\n...     },\n...     {\n...         \"key5\": \"val5\",\n...         \"key6\": \"val6\"\n...     }\n... ]\n>>>\n>>> t2 = [\n...     {\n...         \"key5\": \"CHANGE\",\n...         \"key6\": \"val6\"\n...     },\n...     {\n...         \"key3\": [[[[[[[[[[1, 3, 5, 4]]], [[[8, 8, 1, 5]]]]]]]]]],\n...         \"key4\": [7, 8]\n...     }\n... ]\n\n>>> diff1=DeepDiff(t1, t2, ignore_order=True, cache_size=5000, get_deep_distance=True)\n>>> pprint(diff1)\n{'deep_distance': 0.36363636363636365,\n 'values_changed': {'root[0]': {'new_value': {'key5': 'CHANGE', 'key6': 'val6'},\n                                'old_value': {'key3': [[[[[[[[[[1, 2, 4, 5]]],\n                                                             [[[8,\n                                                                7,\n                                                                3,\n                                                                5]]]]]]]]]],\n                                              'key4': [7, 8]}},\n                    'root[1]': {'new_value': {'key3': [[[[[[[[[[1, 3, 5, 4]]],\n                                                             [[[8,\n                                                                8,\n                                                                1,\n                                                                5]]]]]]]]]],\n                                              'key4': [7, 8]},\n                                'old_value': {'key5': 'val5', 'key6': 'val6'}}}}\n>>> diff1.get_stats()\n{'PASSES COUNT': 0, 'DIFF COUNT': 5, 'DISTANCE CACHE HIT COUNT': 0, 'MAX PASS LIMIT REACHED': False, 'MAX DIFF LIMIT REACHED': False}\n\n>>> diff2=DeepDiff(t1, t2, ignore_order=True, cache_size=5000, cutoff_intersection_for_pairs=1, get_deep_distance=True)\n>>> from pprint import pprint\n>>> pprint(diff2)\n{'deep_distance': 0.06060606060606061,\n 'iterable_item_removed': {\"root[0]['key3'][0][0][0][0][0][0][1][0][0][1]\": 7},\n 'values_changed': {\"root[0]['key3'][0][0][0][0][0][0][0][0][0][1]\": {'new_value': 3,\n                                                                      'old_value': 2},\n                    \"root[0]['key3'][0][0][0][0][0][0][1][0][0][2]\": {'new_value': 1,\n                                                                      'old_value': 3},\n                    \"root[1]['key5']\": {'new_value': 'CHANGE',\n                                        'old_value': 'val5'}}}\n>>> diff2.get_stats()\n{'PASSES COUNT': 110, 'DIFF COUNT': 306, 'DISTANCE CACHE HIT COUNT': 0, 'MAX PASS LIMIT REACHED': False, 'MAX DIFF LIMIT REACHED': False}\n```\n\n----------------------------------------\n\nTITLE: Ignoring String Type Changes with DeepDiff in Python\nDESCRIPTION: This example illustrates the `ignore_string_type_changes` parameter. When set to `True`, it treats string type variations like `bytes` vs `str` as identical, suppressing the `type_changes` report for such cases.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> DeepDiff(b'hello', 'hello', ignore_string_type_changes=True)\n{}\n>>> DeepDiff(b'hello', 'hello')\n{'type_changes': {'root': {'old_type': <class 'bytes'>, 'new_type': <class 'str'>, 'old_value': b'hello', 'new_value': 'hello'}}}\n```\n\n----------------------------------------\n\nTITLE: Detecting Added/Removed Items - Python\nDESCRIPTION: This snippet shows how `DeepDiff` detects items that have been added or removed from a dictionary. `DeepDiff` will identify items present in one dictionary but missing in the other.  The output displays which dictionary items were added and removed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 3:3, 4:4}\n>>> t2 = {1:1, 3:3, 5:5, 6:6}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint (ddiff)\n{'dictionary_item_added': [root[5], root[6]],\n 'dictionary_item_removed': [root[4]]}\n```\n\n----------------------------------------\n\nTITLE: Comparing Decimals with Significant Digits using DeepDiff (Tree View)\nDESCRIPTION: This snippet demonstrates comparing Decimal objects using DeepDiff and specifying the number of significant digits for comparison.  It showcases how DeepDiff can ignore differences beyond a certain level of precision.  Requires the `Decimal` class from the `decimal` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = Decimal('1.52')\n>>> t2 = Decimal('1.57')\n>>> DeepDiff(t1, t2, significant_digits=0, view='tree')\n{}\n>>> ddiff = DeepDiff(t1, t2, significant_digits=1, view='tree')\n>>> ddiff\n{'values_changed': [<root t1:Decimal('1.52'), t2:Decimal('1.57')>]}\n>>> (change1,) = ddiff['values_changed']\n>>> change1\n<root t1:Decimal('1.52'), t2:Decimal('1.57')>\n>>> change1.t1\nDecimal('1.52')\n>>> change1.t2\nDecimal('1.57')\n>>> change1.path()\n'root'\n```\n\n----------------------------------------\n\nTITLE: Handling Timezones in Datetime Comparison with DeepDiff (Python)\nDESCRIPTION: Illustrates how the `default_timezone` parameter in DeepDiff affects the comparison of timezone-aware Python `datetime` objects. By default, DeepDiff converts datetimes to UTC. Setting `default_timezone` (e.g., 'America/New_York') forces conversion to that specific timezone before comparison, altering the reported `new_value` and `old_value` in the diff result. Requires `deepdiff`, `pytz`, and `datetime` modules.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> import pytz\n>>> from datetime import date, datetime, time, timezone\n>>> dt_utc = datetime(2025, 2, 3, 12, 0, 0, tzinfo=pytz.utc)  # UTC timezone\n>>> dt_utc2 = datetime(2025, 2, 3, 11, 0, 0, tzinfo=pytz.utc)  # UTC timezone\n>>> dt_ny = dt_utc.astimezone(pytz.timezone('America/New_York'))\n>>> dt_ny2 = dt_utc2.astimezone(pytz.timezone('America/New_York'))\n>>> diff = DeepDiff(dt_ny, dt_ny2)\n>>> diff\n{'values_changed': {'root': {'new_value': datetime.datetime(2025, 2, 3, 11, 0, tzinfo=datetime.timezone.utc), 'old_value': datetime.datetime(2025, 2, 3, 12, 0, tzinfo=datetime.timezone.utc)}}}\n>>> diff2 = DeepDiff(dt_ny, dt_ny2, default_timezone=pytz.timezone('America/New_York'))\n>>> diff2\n{'values_changed': {'root': {'new_value': datetime.datetime(2025, 2, 3, 6, 0, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>), 'old_value': datetime.datetime(2025, 2, 3, 7, 0, tzinfo=<DstTzInfo 'America/New_York' EST-1 day, 19:00:00 STD>)}}}\n```\n\n----------------------------------------\n\nTITLE: Generating Human-Readable Output for Set Differences with DeepDiff's pretty()\nDESCRIPTION: This example demonstrates using the `pretty()` method to obtain a human-readable description of set differences found by DeepDiff. The output clearly indicates which items were added or removed.  Requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n\nPretty method. Regardless of what view was used, you can use the \"pretty()\" method to get a human readable output.\n>>> print(DeepDiff(t1, t2).pretty())\nItem root[3] added to set.\nItem root[4] removed from set.\nItem root[1] removed from set.\n```\n\n----------------------------------------\n\nTITLE: Including Specific Paths in DeepDiff Comparison in Python\nDESCRIPTION: Illustrates how to limit the `DeepDiff` comparison to only specified parts of Python objects using the `include_paths` parameter. A single path can be passed as a string (e.g., `\"root['for life']\"`). Multiple paths require a list or set. Root keys can use shorthand (e.g., `\"for life\"` instead of `\"root['for life']\"`), as shown in the second example.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {\"for life\": \"vegan\", \"ingredients\": [\"no meat\", \"no eggs\", \"no dairy\"]}\n>>> t2 = {\"for life\": \"vegan\", \"ingredients\": [\"veggies\", \"tofu\", \"soy sauce\"]}\n>>> print (DeepDiff(t1, t2, include_paths=\"root['for life']\"))  # one item pass it as a string\n{}\n>>> print (DeepDiff(t1, t2, include_paths=[\"for life\", \"ingredients2\"]))  # multiple items pass as a list or a set and you don't need to pass the full path when dealing with root keys. So instead of \"root['for life']\" you can pass \"for life\"\n{}\n```\n\n----------------------------------------\n\nTITLE: Comparing Sets with DeepDiff (Text View)\nDESCRIPTION: This example demonstrates how to compare two sets using DeepDiff and display the differences in the default text view. It shows which items have been added or removed from the sets. Requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n\nText view (default)\n>>> DeepDiff(t1, t2)  # same as view='text'\n{'set_item_removed': [root[4], root[1]], 'set_item_added': [root[3]]}\n```\n\n----------------------------------------\n\nTITLE: NamedTuple Difference Detection - Python\nDESCRIPTION: This snippet uses `DeepDiff` to compare namedtuples. It demonstrates how `DeepDiff` can compare the attributes of a namedtuple and detect changes in their values.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> t1 = Point(x=11, y=22)\n>>> t2 = Point(x=11, y=23)\n>>> pprint (DeepDiff(t1, t2))\n{'values_changed': {'root.y': {'new_value': 23, 'old_value': 22}}}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Numeric Type Changes with DeepDiff in Python\nDESCRIPTION: This snippet demonstrates using `ignore_numeric_type_changes=True` to ignore type differences between numeric types, such as `Decimal` and `float`, when their values are equivalent, preventing a `type_changes` report.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from decimal import Decimal\n>>> from deepdiff import DeepDiff\n>>> \n>>> t1 = Decimal('10.01')\n>>> t2 = 10.01\n>>> \n>>> DeepDiff(t1, t2)\n{'type_changes': {'root': {'old_type': <class 'decimal.Decimal'>, 'new_type': <class 'float'>, 'old_value': Decimal('10.01'), 'new_value': 10.01}}}\n>>> DeepDiff(t1, t2, ignore_numeric_type_changes=True)\n{}\n```\n\n----------------------------------------\n\nTITLE: Comparing Datetimes with Different Timezones in DeepDiff Python\nDESCRIPTION: This snippet demonstrates how DeepDiff handles datetime comparisons. DeepDiff converts datetimes to UTC for comparison. It shows that DeepDiff considers a naive datetime (assumed UTC) and a UTC-aware datetime representing the same point in time as equal, unlike Python's standard `==` comparison.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nfrom datetime import datetime, timezone\nfrom pytz import timezone\nd1 = datetime(2020, 8, 31, 13, 14, 1)\nd2 = datetime(2020, 8, 31, 13, 14, 1, tzinfo=timezone.utc)\nd1 == d2\nDeepDiff(d1, d2)\n\nd3 = d2.astimezone(timezone('America/New_York'))\nDeepDiff(d1, d3)\nd1 == d3\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying DeepDiff Delta from Flat Dictionaries (Python)\nDESCRIPTION: Demonstrates using `DeepDiff` to find differences between two lists (`t3`, `t4`), converting the result to a `Delta` object, generating a list of flat dictionaries via `delta.to_flat_dicts()`, initializing a new `Delta` (`delta2`) from these flat dictionaries, and verifying that applying the original delta to `t3` yields `t4`. Requires the `deepdiff` library (`DeepDiff`, `Delta`). The preceding dictionary structure illustrates the format of the `flat_dicts` generated by `delta.to_flat_dicts()`.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> from deepdiff import DeepDiff, Delta\n>>> t3 = [\"A\", \"B\"]\n>>> t4 = [\"A\", \"B\", \"C\", \"D\"]\n>>> diff = DeepDiff(t3, t4, verbose_level=2)\n>>> delta = Delta(diff, bidirectional=True)\n>>> flat_dicts = delta.to_flat_dicts()\n>>>\n>>> delta2 = Delta(flat_dict_list=flat_dicts)\n>>> t3 + delta == t4\nTrue\n```\n\n----------------------------------------\n\nTITLE: Attempting to Serialize DeepDiff Result with Standard json.dumps Python\nDESCRIPTION: This snippet demonstrates the common `TypeError: Object of type type is not JSON serializable` encountered when attempting to serialize a DeepDiff result directly using Python's standard `json.dumps`. DeepDiff results can contain non-standard types that are not JSON serializable by default.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndiff=DeepDiff(1, \"a\")\ndiff\njson.dumps(diff)\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Paths from DeepDiff Comparison in Python\nDESCRIPTION: Illustrates how to use the `exclude_paths` parameter with `DeepDiff` to ignore differences within specified parts of Python dictionaries. Shows that a single path can be passed as a string (e.g., `\"root['ingredients']\"`), while multiple paths require a list or set (e.g., `[\"root['ingredients']\", \"root['ingredients2']\"]`). The example demonstrates excluding the 'ingredients' key, resulting in an empty diff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {\"for life\": \"vegan\", \"ingredients\": [\"no meat\", \"no eggs\", \"no dairy\"]}\n>>> t2 = {\"for life\": \"vegan\", \"ingredients\": [\"veggies\", \"tofu\", \"soy sauce\"]}\n>>> print (DeepDiff(t1, t2, exclude_paths=\"root['ingredients']\"))  # one item pass it as a string\n{}\n>>> print (DeepDiff(t1, t2, exclude_paths=[\"root['ingredients']\", \"root['ingredients2']\"]))  # multiple items pass as a list or a set.\n{}\n```\n\n----------------------------------------\n\nTITLE: Applying PrefixOrSuffixOperator in DeepDiff - Python\nDESCRIPTION: This snippet applies the built-in PrefixOrSuffixOperator via the custom_operators parameter in DeepDiff, causing strings that are prefixes or suffixes of each other to not be considered different. Requires deepdiff and deepdiff.operator.PrefixOrSuffixOperator. Useful for domain-specific equivalence of strings (e.g., when variations are expected). Inputs: dictionaries with string list values; output: reduced diff on string differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\nfrom deepdiff.operator import PrefixOrSuffixOperator\nt1 = {\"key1\": [\"foo\", \"bar's food\", \"jack\", \"joe\"]}\nt2 = {\"key1\": [\"foo\", \"bar\", \"jill\", \"joe'car\"]}\ndiff_custom = DeepDiff(t1, t2, custom_operators=[PrefixOrSuffixOperator()])\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Custom Objects)\nDESCRIPTION: This example demonstrates using `ignore_type_in_groups` with custom object types. By specifying `[(Taco, Burrito)]`, DeepDiff ignores type differences between instances of these custom classes when comparing lists containing them.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> class Burrito:\n...     bread = 'flour'\n...     def __init__(self):\n...         self.spicy = True\n... \n>>>\n>>> class Taco:\n...     bread = 'flour'\n...     def __init__(self):\n...         self.spicy = True\n... \n>>>\n>>> burrito = Burrito()\n>>> taco = Taco()\n>>>\n>>> burritos = [burrito]\n>>> tacos = [taco]\n>>>\n>>> DeepDiff(burritos, tacos, ignore_type_in_groups=[(Taco, Burrito)], ignore_order=True)\n{}\n```\n\n----------------------------------------\n\nTITLE: Comparing Objects with Custom Type Grouping in DeepDiff (Python)\nDESCRIPTION: This snippet demonstrates comparing instances of user-defined classes using DeepDiff with the ignore_type_in_groups and ignore_type_subclasses options. It shows how to alter DeepDiff's type comparison logic by defining groups of types to be treated as equivalent and controlling whether subclasses are included. Required dependencies are DeepDiff and user-defined classes (ClassA, ClassB, ClassC). The inputs are class instances, and outputs show structural or type differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nclass ClassB:\n    def __init__(self, x):\n        self.x = x\n\nclass ClassC(ClassB):\n    pass\n\nobj_a = ClassA(1, 2)\nobj_c = ClassC(3)\n\nDeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=True)\n# Output: {'type_changes': {'root': {'old_type': <class '__main__.ClassA'>, 'new_type': <class '__main__.ClassC'>, 'old_value': <__main__.ClassA object at ...>, 'new_value': <__main__.ClassC object at ...>}}}\n\nDeepDiff(obj_a, obj_c, ignore_type_in_groups=[(ClassA, ClassB)], ignore_type_subclasses=False)\n# Output: {'values_changed': {'root.x': {'new_value': 3, 'old_value': 1}}, 'attribute_removed': [root.y]}\n```\n\n----------------------------------------\n\nTITLE: Group By with Tree View - Python\nDESCRIPTION: This snippet provides example of how the structure is affected by `group_by` and shows the result with tree view. It shows the structure changes using tree view after applying group_by\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> diff = DeepDiff(t1, t2, group_by='id', view='tree')\n>>> diff\n{'values_changed': [<root['BB']['last_name'] t1:'Blue', t2:'Brown'>]}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> diff['values_changed'][0]\n<root['BB']['last_name'] t1:'Blue', t2:'Brown'>\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> diff['values_changed'][0].up\n<root['BB'] t1:{'name': 'Ja...}, t2:{'name': 'Ja...}>\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> diff['values_changed'][0].up.up\n<root t1:{'AA': {'nam...}, t2:{'AA': {'nam...}>\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> diff['values_changed'][0].up.up.t1\n{'AA': {'name': 'Joe', 'last_name': 'Nobody'}, 'BB': {'name': 'James', 'last_name': 'Blue'}, 'CC': {'name': 'Mike', 'last_name': 'Apple'}}\n```\n\n----------------------------------------\n\nTITLE: Using zip_ordered_iterables with DeepDiff in Python\nDESCRIPTION: Demonstrates how the `zip_ordered_iterables` parameter affects the comparison of ordered iterables (like lists) in DeepDiff. By default (`False`), DeepDiff finds minimal changes. Setting it to `True` pairs items based on their order of appearance, potentially leading to more reported changes but faster comparison when `ignore_order=False`. The example uses `pprint` for formatted output.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/optimizations.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> from pprint import pprint\n>>> from deepdiff import DeepDiff\n>>> t1 = [\"a\", \"b\", \"d\", \"e\"]\n>>> t2 = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n>>> DeepDiff(t1, t2)\n{'iterable_item_added': {'root[2]': 'c'}}\n\n>>> diff=DeepDiff(t1, t2, zip_ordered_iterables=True)\n>>> pprint(diff)\n{'iterable_item_added': {'root[4]': 'e'},\n 'values_changed': {'root[2]': {'new_value': 'c', 'old_value': 'd'},\n                    'root[3]': {'new_value': 'd', 'old_value': 'e'}}}\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Types from DeepDiff Comparison in Python\nDESCRIPTION: This snippet demonstrates how to use the `exclude_types` parameter to prevent DeepDiff from reporting differences involving objects of specified types. Here, `logging.Logger` instances are ignored, resulting in an empty diff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> l1 = logging.getLogger(\"test\")\n>>> l2 = logging.getLogger(\"test2\")\n>>> t1 = {\"log\": l1, 2: 1337}\n>>> t2 = {\"log\": l2, 2: 1337}\n>>> print(DeepDiff(t1, t2, exclude_types={logging.Logger}))\n{}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Operator by Subclassing BaseOperatorPlus - Python\nDESCRIPTION: This snippet shows a complete user-defined custom operator that treats any strings matching a GUID pattern as equivalent, regardless of actual GUID value. Implements match, give_up_diffing, and normalization for hashing. Requires Python's re and typing modules, deepdiff, and deepdiff.operator.BaseOperatorPlus. Inputs: dicts containing GUID strings; output: DeepDiff sees values as equivalent wherever the pattern matches. Useful for ignoring value differences that are syntactic and not semantic.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport re\nfrom typing import Any\nfrom deepdiff import DeepDiff\nfrom deepdiff.operator import BaseOperatorPlus\n\nclass RemoveGUIDsOperator(BaseOperatorPlus):\n    _pattern = r\"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}\"\n    _substitute = \"guid\"\n\n    def match(self, level) -> bool:\n        return isinstance(level.t1, str) and isinstance(level.t2, str)\n\n    @classmethod\n    def _remove_pattern(cls, t: str):\n        return re.sub(cls._pattern, cls._substitute, t)\n\n    def give_up_diffing(self, level, diff_instance):\n        t1 = self._remove_pattern(level.t1)\n        t2 = self._remove_pattern(level.t2)\n        return t1 == t2\n\n    def normalize_value_for_hashing(self, parent: Any, obj: Any) -> Any:\n        if isinstance(obj, str):\n            return self._remove_pattern(obj)\n        return obj\n\noperator = RemoveGUIDsOperator()\nd1 = { ... }\nd2 = { ... }\ndiff1 = DeepDiff(d1, d2, custom_operators=[operator], log_stacktrace=True)\ndiff2 = DeepDiff(d1, d2, ignore_order=True, custom_operators=[operator], log_stacktrace=True)\n```\n\n----------------------------------------\n\nTITLE: Comparing Grouped and Sorted Lists with DeepDiff (Python)\nDESCRIPTION: Demonstrates using DeepDiff to compare two lists of dictionaries (`t1`, `t2`) by first grouping items based on the 'id' key (`group_by='id'`) and then sorting items within each group by the 'name' key (`group_by_sort_key='name'`). The output highlights the differences found after applying this grouping and sorting logic, such as removed items and changed values. Requires the `deepdiff` library and `pprint` for formatted output.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody', 'int_id': 2},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Blue', 'int_id': 20},\n...     {'id': 'BB', 'name': 'Jimmy', 'last_name': 'Red', 'int_id': 3},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple', 'int_id': 4},\n... ]\n>>>\n>>> t2 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody', 'int_id': 2},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Brown', 'int_id': 20},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple', 'int_id': 4},\n... ]\n>>>\n>>> diff = DeepDiff(t1, t2, group_by='id', group_by_sort_key='name')\n>>>\n>>> pprint(diff)\n{'iterable_item_removed': {\"root['BB'][1]\": {'int_id': 3,\n                                             'last_name': 'Red',\n                                             'name': 'Jimmy'}},\n 'values_changed': {\"root['BB'][0]['last_name']\": {'new_value': 'Brown',\n                                                   'old_value': 'Blue'}}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Floats with Significant Digits in DeepDiff (Python)\nDESCRIPTION: Illustrates comparing lists of floating-point numbers using DeepDiff and the 'significant_digits' parameter. Shows how setting 'significant_digits=3' ignores small differences, while the default behavior (or fewer significant digits) detects them. Also includes an example comparing large numbers in scientific notation.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pprint import pprint\n>>> from deepdiff import DeepDiff\n>>> t1 = [ 1.1129, 1.3359 ]\n>>> t2 = [ 1.113, 1.3362 ]\n>>> pprint(DeepDiff(t1, t2, significant_digits=3))\n{}\n>>> pprint(DeepDiff(t1, t2))\n{'values_changed': {'root[0]': {'new_value': 1.113, 'old_value': 1.1129},\n                    'root[1]': {'new_value': 1.3362, 'old_value': 1.3359}}}\n>>> pprint(DeepDiff(1.23*10**20, 1.24*10**20, significant_digits=1))\n{'values_changed': {'root': {'new_value': 1.24e+20, 'old_value': 1.23e+20}}}\n```\n\n----------------------------------------\n\nTITLE: Restrict DeepDiff Comparison to Specific Paths using Custom Operator\nDESCRIPTION: This snippet defines a custom operator to limit diffing to specific paths within objects. It initializes with include_paths, matches all levels, but signals to give up diffing if the current level's path is not among the included paths. This setup enables focused comparison on designated parts of complex objects.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nclass MyOperator:\n    def __init__(self, include_paths):\n        self.include_paths = include_paths\n    def match(self, level) -> bool:\n        return True\n    def give_up_diffing(self, level, diff_instance) -> bool:\n        return level.path() not in self.include_paths\n\nt1 = {'a': [10, 11], 'b': [20, 21], 'c': [30, 31]}\nt2 = {'a': [10, 22], 'b': [20, 33], 'c': [30, 44]}\n\nDeepDiff(t1, t2, custom_operators=[\n    MyOperator(include_paths=\"root['a'][1]\")\n])\n```\n\n----------------------------------------\n\nTITLE: Using the force Parameter in Delta\nDESCRIPTION: Shows how to use the force parameter to apply a delta to objects with different structures than the original objects used to create the delta.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff, Delta\nt1 = {\n    'x': {\n        'y': [1, 2, 3]\n    },\n    'q': {\n        'r': 'abc',\n    }\n}\n\nt2 = {\n    'x': {\n        'y': [1, 2, 3, 4]\n    },\n    'q': {\n        'r': 'abc',\n        't': 0.5,\n    }\n}\n\ndiff = DeepDiff(t1, t2)\ndiff\n# {'dictionary_item_added': [root['q']['t']], 'iterable_item_added': {\"root['x']['y'][3]\": 4}}\ndelta = Delta(diff)\n{} + delta\n```\n\n----------------------------------------\n\nTITLE: Truncating Datetime Objects Before DeepDiff Comparison (Python)\nDESCRIPTION: This snippet explains how using the truncate_datetime option in DeepDiff allows dictionary values representing datetime objects to be truncated to a given unit ('minute' in this example) before they are compared. The dependency is DeepDiff, and inputs are dicts with datetime values. The comparison is insensitive to granular differences below the truncation level.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nimport datetime\nfrom deepdiff import DeepDiff\nd1 = {'a': datetime.datetime(2020, 5, 17, 22, 15, 34, 913070)}\nd2 = {'a': datetime.datetime(2020, 5, 17, 22, 15, 39, 296583)}\nDeepDiff(d1, d2, truncate_datetime='minute')\n# Output: {}\n```\n\n----------------------------------------\n\nTITLE: Comparing Strings with Case Sensitivity Control in DeepDiff (Python)\nDESCRIPTION: This snippet shows how to compare string objects with DeepDiff using the ignore_string_case flag. By toggling this Boolean option, string comparisons can be made case-sensitive or case-insensitive. The dependency is DeepDiff, and the primary parameters are the strings and ignore_string_case flag. Inputs are two strings; output depends on their case equivalence.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff(t1='Hello', t2='heLLO')\n# Output: {'values_changed': {'root': {'new_value': 'heLLO', 'old_value': 'Hello'}}}\nDeepDiff(t1='Hello', t2='heLLO', ignore_string_case=True)\n# Output: {}\n```\n\n----------------------------------------\n\nTITLE: Generating Human-Readable Output with DeepDiff's pretty() Method\nDESCRIPTION: This snippet illustrates how to use the `pretty()` method of DeepDiff to generate human-readable output of the differences between two objects.  It requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n>>> print(DeepDiff(t1, t2).pretty())\nItem root[3] added to set.\nItem root[4] removed from set.\nItem root[1] removed from set.\n```\n\n----------------------------------------\n\nTITLE: Early Termination of Diffing Process Once First Difference is Detected\nDESCRIPTION: This example illustrates an operator that signals to stop diffing after the first detected difference. The give_up_diffing method checks if any differences have been recorded in the diff_instance and returns True to halt further comparison. Used to optimize performance when only the presence of differences is needed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass MyOperator:\n    def match(self, level) -> bool:\n        return True\n    def give_up_diffing(self, level, diff_instance) -> bool:\n        return any(diff_instance.tree.values())\n\nt1 = [[1, 2], [3, 4], [5, 6]]\nt2 = [[1, 3], [3, 5], [5, 7]]\n\nDeepDiff(t1, t2, custom_operators=[\n    MyOperator()\n])\n```\n\n----------------------------------------\n\nTITLE: Excluding Paths Using Regular Expressions in DeepDiff Python\nDESCRIPTION: Illustrates excluding parts of nested Python objects from `DeepDiff` comparison based on regular expressions using the `exclude_regex_paths` parameter. Requires the `re` module. Examples show passing a raw regex string (e.g., `r\"root\\[\\d+\\]\\['b'\\]\"`) or a pre-compiled regex object (`re.compile(...)`) to exclude specific keys ('b') within list elements, resulting in an empty diff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import re\n>>> t1 = [{'a': 1, 'b': 2}, {'c': 4, 'b': 5}]\n>>> t2 = [{'a': 1, 'b': 3}, {'c': 4, 'b': 5}]\n>>> print(DeepDiff(t1, t2, exclude_regex_paths=r\"root\\[\\d+\\]\\['b'\\]\"))\n{}\n>>> exclude_path = re.compile(r\"root\\[\\d+\\]\\['b'\\]\")\n>>> print(DeepDiff(t1, t2, exclude_regex_paths=[exclude_path]))\n{}\n```\n\n----------------------------------------\n\nTITLE: DeepHash Core Functionality and Parameters Documentation in Python\nDESCRIPTION: This snippet details the purpose, dependencies, and core parameters of the DeepHash class in Python. It explains how DeepHash deterministically serializes objects into strings, applies hashing (default SHA256), and allows customization via parameters such as apply_hash, exclude_types, include_paths, and others. It also discusses optional features like encoding handling, type exclusions, case sensitivity, and number formatting, which influence hash consistency and applicability for unhashable or complex objects.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> from deepdiff import DeepHash\n\n# Parameters for DeepHash\nobj : any object, The object to be hashed based on its content.\napply_hash: Boolean, default = True\n    # Use to serialize object into string and then hash; set False to see string representation.\nexclude_types: list, default = None\n    # Types to exclude from hashing.\nexclude_paths: list, default = None\n    # Paths to exclude from hash report.\ninclude_paths: list, default = None\n    # Specific paths to include.\nexclude_regex_paths: list, default = None\n    # Regex paths to exclude.\n\n# Call example (not literal code, parameters are explained for usage)\n# hash_result = DeepHash(obj, apply_hash=True, exclude_types=[type], ...)\n```\n\n----------------------------------------\n\nTITLE: Using get_stats Method to Analyze DeepDiff Performance\nDESCRIPTION: Example of how to use the get_stats method to analyze the performance statistics of a DeepDiff operation, showing diff count, passes count, and cache hit information.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/optimizations.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> diff=DeepDiff(1, 2)\n>>> diff\n{'values_changed': {'root': {'new_value': 2, 'old_value': 1}}}\n>>> diff.get_stats()\n{'PASSES COUNT': 0, 'DIFF COUNT': 1, 'DISTANCE CACHE HIT COUNT': 0, 'MAX PASS LIMIT REACHED': False, 'MAX DIFF LIMIT REACHED': False}\n>>> diff=DeepDiff([[1,2]], [[2,3,1]])\n>>> diff.get_stats()\n{'PASSES COUNT': 0, 'DIFF COUNT': 8, 'DISTANCE CACHE HIT COUNT': 0, 'MAX PASS LIMIT REACHED': False, 'MAX DIFF LIMIT REACHED': False}\n>>> diff=DeepDiff([[1,2]], [[2,3,1]], ignore_order=True)\n>>> diff.get_stats()\n{'PASSES COUNT': 3, 'DIFF COUNT': 6, 'DISTANCE CACHE HIT COUNT': 0, 'MAX PASS LIMIT REACHED': False, 'MAX DIFF LIMIT REACHED': False}\n```\n\n----------------------------------------\n\nTITLE: Resolving UnicodeDecodeError with DeepDiff encodings Parameter (Python)\nDESCRIPTION: This snippet shows how to successfully diff lists containing bytes with encoding issues by providing a list of potential character encodings via the `encodings` parameter. DeepDiff iterates through the list, finds a compatible encoding (latin-1 in this case), and proceeds with the comparison.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/other.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\n```\n\nLANGUAGE: Python\nCODE:\n```\nitem = b\"\\xbc cup of flour\"\n```\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff([b'foo'], [item], encodings=['utf-8', 'latin-1'], ignore_order=True)\n```\n\n----------------------------------------\n\nTITLE: String Difference Detection - Python\nDESCRIPTION: This snippet demonstrates comparing two dictionaries that have string differences in their values. It showcases how `DeepDiff` captures the differences in the values of strings and shows how to print a diff for those differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":\"world\"}}\n>>> t2 = {1:1, 2:4, 3:3, 4:{\"a\":\"hello\", \"b\":\"world!\"}}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint (ddiff, indent = 2)\n{ 'values_changed': { 'root[2]': {'new_value': 4, 'old_value': 2},\n                          \"root[4]['b']\": { 'new_value': 'world!',\n                                            'old_value': 'world'}}}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Iterable Compare Func\nDESCRIPTION: This code snippet introduces how to define a custom comparison function, `compare_func`, to guide DeepDiff in comparing items based on specific criteria (in this case, the `id` field of dictionary items).  It imports `DeepDiff` and `CannotCompare`. The comparison function takes three parameters: `x`, `y`, and `level`.  The output shows the result of `DeepDiff` using the custom function, demonstrating how to customize the comparison logic. This relies on `deepdiff.helper.CannotCompare` to handle comparison failures.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from deepdiff.helper import CannotCompare\n>>>\n>>> t1 = [\n...     {\n...         'id': 1,\n...         'value': [1]\n...     },\n...     {\n...         'id': 2,\n...         'value': [7, 8, 1]\n...     },\n...     {\n...         'id': 3,\n...         'value': [7, 8],\n...     },\n... ]\n>>>\n>>> t2 = [\n...     {\n...         'id': 2,\n...         'value': [7, 8]\n...     },\n...     {\n...         'id': 3,\n...         'value': [7, 8, 1],\n...     },\n...     {\n...         'id': 1,\n...         'value': [1]\n...     },\n... ]\n>>>\n>>> DeepDiff(t1, t2, ignore_order=True)\n{'values_changed': {\"root[2]['id']\": {'new_value': 2, 'old_value': 3}, \"root[1]['id']\": {'new_value': 3, 'old_value': 2}}}\n```\n\nLANGUAGE: Python\nCODE:\n```\n>>> def compare_func(x, y, level=None):\n...     try:\n...         return x['id'] == y['id']\n...     except Exception:\n...         raise CannotCompare() from None\n...\n>>> DeepDiff(t1, t2, ignore_order=True, iterable_compare_func=compare_func)\n{'iterable_item_added': {\"root[2]['value'][2]\": 1}, 'iterable_item_removed': {\"root[1]['value'][2]\": 1}}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of DeepHash with a Dictionary Object in Python\nDESCRIPTION: This snippet demonstrates creating a dictionary object and hashing it with DeepHash. It shows that direct Python hash functions fail on unhashable objects like dictionaries, but DeepHash can produce a deterministic hash mapping for all contained objects, ensuring consistent fingerprinting of complex structures.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> from deepdiff import DeepHash\n>>> obj = {1: 2, 'a': 'b'}\n>>> DeepHash(obj)\n{1: 'hash1', 'a': 'hash2', ...}\n```\n\n----------------------------------------\n\nTITLE: Excluding Paths with Regex Wildcards (Single String) in DeepDiff Python\nDESCRIPTION: Demonstrates using `exclude_regex_paths` in `DeepDiff` with a single regex string (no list needed when only one pattern is provided) containing a wildcard (`.`). The example uses the regex `\"\\[\\'foo.\\'\\]\"` to exclude keys matching `foo.` (like `foo1`, `foo2`) within nested structures. Note that `DeepDiff` uses `re.search`, so anchor regexes with `^` for start-of-path matching if needed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {'a': [1, 2, [3, {'foo1': 'bar'}]]}\n>>> t2 = {'a': [1, 2, [3, {'foo2': 'bar'}]]}\n>>> DeepDiff(t1, t2, exclude_regex_paths=\"\\['foo.'\\]\")  # since it is one item in exclude_regex_paths, you don't have to put it in a list or a set.\n{}\n```\n\n----------------------------------------\n\nTITLE: Bypassing Encoding Errors with DeepDiff ignore_encoding_errors Parameter (Python)\nDESCRIPTION: Demonstrates using the `ignore_encoding_errors=True` parameter to prevent `UnicodeDecodeError`. This allows the diff to complete without specifying encodings, but at the cost of potentially reduced accuracy as characters causing errors may be ignored during hashing.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/other.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\n```\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff([b'foo'], [b\"\\xbc cup of flour\"], ignore_encoding_errors=True, ignore_order=True)\n```\n\n----------------------------------------\n\nTITLE: Applying Patch to YAML File with deep patch Command Line\nDESCRIPTION: Demonstrates how to use the `deep patch` command to apply a previously created delta file (`patch1.pickle`) to a target file (`another.yaml`). The `--backup` flag creates a backup, and `--raise-errors` ensures strict patching.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndeep patch --backup another.yaml patch1.pickle --raise-errors\n```\n\n----------------------------------------\n\nTITLE: Detecting Value Changes - Python\nDESCRIPTION: This snippet demonstrates how `DeepDiff` detects changes in the values of a dictionary. The keys are the same in both dictionaries, but the value of one of the keys has been modified. The `verbose_level=0` parameter is used to display only the changed values.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = {1:1, 2:4, 3:3}\n>>> pprint(DeepDiff(t1, t2, verbose_level=0), indent=2)\n{'values_changed': {'root[2]': {'new_value': 4, 'old_value': 2}}}\n```\n\n----------------------------------------\n\nTITLE: Extracting Value by Path with deep extract Command Line\nDESCRIPTION: Shows how to use the `deep extract` command to retrieve a specific value from a file (`t1.csv`) by providing its structural path (`root[2]['first_name']`).\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ deep extract \"root[2]['first_name']\" t1.csv\n'James'\n```\n\n----------------------------------------\n\nTITLE: Using Delta without always_include_values in Python\nDESCRIPTION: Shows how the Delta object by default may omit values when type changes occur if the conversion is straightforward. This demonstrates the default behavior where only type information is retained.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff, Delta\ndiff = DeepDiff(t1=[1, 2], t2=[1, '2'])\ndiff\n{'type_changes': {'root[1]': {'old_type': <class 'int'>, 'new_type': <class 'str'>, 'old_value': 2, 'new_value': '2'}}}\ndelta=Delta(diff)\ndelta\n<Delta: {'type_changes': {'root[1]': {'old_type': <class 'int'>, 'new_type': <class 'str'>}}}>\n```\n\n----------------------------------------\n\nTITLE: Creating Patch Delta File with deep diff Command Line\nDESCRIPTION: Illustrates the process of generating a patch file (delta) using the `deep diff` command. It shows how to use `--create-patch` and `--report-repetition` flags with `--ignore-order` to create a machine-readable delta output.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndeep diff t1.csv t2.csv --ignore-order --report-repetition --create-patch\n=}values_changed}root[2]['zip']}    new_valueJ_sss.% \n```\n\n----------------------------------------\n\nTITLE: Searching List Items with DeepDiff Grep in Python\nDESCRIPTION: Shows how to search for a substring within elements of a list using the grep function. The example stores the search term in 'item', pipes the list 'obj' into grep, and prints the matching item paths. It highlights basic usage with default parameters, returning indices where matches occur.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/search_doc.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> obj = [\"long somewhere\", \"string\", 0, \"somewhere great!\"]\n>>> item = \"somewhere\"\n>>> ds = obj | grep(item)\n>>> print(ds)\n{'matched_values': {'root[3]', 'root[0]'}}\n```\n\n----------------------------------------\n\nTITLE: Using Delta with always_include_values and bidirectional parameters in Python\nDESCRIPTION: Shows how combining always_include_values=True with bidirectional=True preserves both old and new values in the Delta object, enabling both addition and subtraction operations with the delta.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndelta=Delta(diff, always_include_values=True, bidirectional=True)\ndelta.diff\n{'type_changes': {'root[1]': {'old_type': <class 'int'>, 'new_type': <class 'str'>, 'old_value': 2, 'new_value': '2'}}}\n```\n\n----------------------------------------\n\nTITLE: Handling Numeric Type Changes in DeepHash\nDESCRIPTION: Examples of using ignore_numeric_type_changes parameter to treat different numeric types (int, float, Decimal) as equivalent when calculating hashes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> obj1 = {4:10}\n>>> obj2 = {4.0: Decimal(10.0)}\n>>> DeepHash(obj1)[4] == DeepHash(obj2)[4.0]\nFalse\n\n>>> DeepHash(obj1, ignore_numeric_type_changes=True)[4] == DeepHash(obj2, ignore_numeric_type_changes=True)[4.0]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Filtering Object Comparison Based on Subclass Attributes in Python\nDESCRIPTION: This example demonstrates a custom operator that compares objects only if they are subclasses of a specific type and their list attributes are not equal as sets. It requires defining a subclass, creating instances with different and similar list contents, and implementing a method to skip diffing when list sets match. It helps optimize diffing by skipping unnecessary comparisons for certain subclasses.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nclass CustomClass:\n    def __init__(self, d: dict, l: list):\n        self.dict = d\n        self.dict['list'] = l\n\ncustom1 = CustomClass(d=dict(a=1, b=2), l=[1, 2, 3])\ncustom2 = CustomClass(d=dict(c=3, d=4), l=[1, 2, 3, 2])\ncustom3 = CustomClass(d=dict(a=1, b=2), l=[1, 2, 3, 4])\n\nclass ListMatchOperator(BaseOperator):\n    def give_up_diffing(self, level, diff_instance):\n        if set(level.t1.dict['list']) == set(level.t2.dict['list']):\n            return True\n\nDeepDiff(custom1, custom2, custom_operators=[\n    ListMatchOperator(types=[CustomClass])\n])\n\nDeepDiff(custom2, custom3, custom_operators=[\n    ListMatchOperator(types=[CustomClass])\n])\n```\n\n----------------------------------------\n\nTITLE: DeepDiff Iterable Compare Function with Level-Aware Matching - Python\nDESCRIPTION: This code demonstrates a level-aware custom comparison for DeepDiff by using the level.path() marker. The compare_func2 only triggers on a specific path (e.g., 'root[\\'path2\\']'), providing fine-grained control over where custom logic applies. Inputs are nested dictionaries; requires deepdiff and deepdiff.helper.CannotCompare as well as the correct tree structure. Output: Only relevant differences reported for the targeted substructure.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef compare_func2(x, y, level):\n    if (not isinstance(x, dict) or not isinstance(y, dict)):\n        raise CannotCompare\n    if(level.path() == \"root['path2']\"):\n        if (x[\"id\"] == y[\"id\"]):\n            return True\n        return False\ndiff = DeepDiff(t1, t2, iterable_compare_func=compare_func2)\n```\n\n----------------------------------------\n\nTITLE: Getting Help for deep extract Command Line\nDESCRIPTION: Demonstrates how to access the help documentation and list available options for the `deep extract` command using the command line.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ deep extract\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ deep extract --help\nUsage: deep extract [OPTIONS] PATH_INSIDE PATH\n\n  Deep Extract Commandline\n\n  Extract an item from a file based on the path that is passed. It can read\n  csv, tsv, json, yaml, and toml files.\n\nOptions:\n  --help  Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Numbers Dict)\nDESCRIPTION: This example demonstrates ignoring type changes between numeric types (`int` and `float`) within a dictionary using `ignore_type_in_groups=DeepDiff.numbers`. This achieves the same result as `ignore_numeric_type_changes=True` for these specific types.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from pprint import pprint\n>>> t1 = {1: 1, 2: 2.22}\n>>> t2 = {1: 1.0, 2: 2.22}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint(ddiff, indent=2)\n{ 'type_changes': { 'root[1]': { 'new_type': <class 'float'>,\n                                     'new_value': 1.0,\n                                     'old_type': <class 'int'>,\n                                     'old_value': 1}}}\n>>> ddiff = DeepDiff(t1, t2, ignore_type_in_groups=DeepDiff.numbers)\n>>> pprint(ddiff, indent=2)\n{}\n```\n\n----------------------------------------\n\nTITLE: Using Regular Expressions for Matching with DeepDiff Grep in Python\nDESCRIPTION: Demonstrates enabling regular expression matching by setting 'use_regexp=True'. The example searches for keys matching a regex pattern within nested data, returning all keys and paths that satisfy the pattern. This expands grep's capability to pattern-based rather than substring-based matching.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/search_doc.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> obj = [\"something here\", {\"long\": \"somewhere\", \"someone\": 2, 0: 0, \"somewhere\": \"around\"}]\n>>> ds = obj | grep(\"some.*\", use_regexp=True)\n>>> print(ds)\n{ 'matched_paths': [\"root[1]['someone']\", \"root[1]['somewhere']\"],\n  'matched_values': ['root[0]', \"root[1]['long']\"]}\n```\n\n----------------------------------------\n\nTITLE: Custom Type Groups with Classes\nDESCRIPTION: Shows how to create custom type groups for user-defined classes to ensure they produce the same hash regardless of class differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> class Burrito:\n...     bread = 'flour'\n...     def __init__(self):\n...         self.spicy = True\n...\n>>>\n>>> class Taco:\n...     bread = 'flour'\n...     def __init__(self):\n...         self.spicy = True\n...\n>>>\n>>> burrito = Burrito()\n>>> taco = Taco()\n>>>\n>>> burritos = [burrito]\n>>> tacos = [taco]\n>>>\n>>> d1 = DeepHash(burritos, ignore_type_in_groups=[(Taco, Burrito)])\n>>> d2 = DeepHash(tacos, ignore_type_in_groups=[(Taco, Burrito)])\n>>> d1[burrito] == d2[taco]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Progress Logger in DeepDiff (Python)\nDESCRIPTION: This snippet describes how to set a custom logging function via the progress_logger parameter to control the log message level, such as changing from info to warning. It demonstrates usage with the logger.warning function, ensuring thread safety, for progress reporting during deep diff calculations.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/stats.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff(t1, t2, log_frequency_in_sec=1, progress_logger=logger.warning)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Delta Objects in Python\nDESCRIPTION: An example of creating a Delta object from a DeepDiff result and applying it to a list. Shows how the mutate parameter affects whether the original object is modified.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nt1 = [1, 2, [3, 5, 6]]\nt2 = [2, 3, [3, 6, 8]]\n\ndiff = DeepDiff(t1, t2, ignore_order=True, report_repetition=True)\ndiff\n# {'values_changed': {'root[0]': {'new_value': 3, 'old_value': 1}, 'root[2][1]': {'new_value': 8, 'old_value': 5}}}\ndelta = Delta(diff)\ndelta\n# <Delta: {'values_changed': {'root[0]': {'new_value': 3}, 'root[2][1]': {'new_value': 8}}}>\n\nt3 = [\"a\", 2, [3, \"b\", \"c\"]]\nt3 + delta\n# [3, 2, [3, 8, 'c']]\n\nt3\n# ['a', 2, [3, 'b', 'c']]\n\ndelta2 = Delta(diff, mutate=True)\nt3 + delta2\n# [3, 2, [3, 8, 'c']]\nt3\n# [3, 2, [3, 8, 'c']]\n```\n\n----------------------------------------\n\nTITLE: Number Format Notation in DeepHash\nDESCRIPTION: Shows how the number_format_notation parameter affects hash calculation, allowing control over whether fixed-point or scientific notation is used.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> t1=10002\n>>> t2=10004\n>>> t1_hash = DeepHash(t1, significant_digits=3, number_format_notation=\"f\")\n>>> t2_hash = DeepHash(t2, significant_digits=3, number_format_notation=\"f\")\n>>>\n>>> t1_hash[t1] == t2_hash[t2]\nFalse\n>>>\n>>>\n>>> # Now we use the scientific notation\n... t1_hash = DeepHash(t1, significant_digits=3, number_format_notation=\"e\")\n>>> t2_hash = DeepHash(t2, significant_digits=3, number_format_notation=\"e\")\n>>>\n>>> t1_hash[t1] == t2_hash[t2]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using Error Handling with Delta in Python\nDESCRIPTION: Shows how to use the raise_errors parameter to control error behavior when applying a Delta to incompatible objects. When False, it logs errors; when True, it raises exceptions.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff, Delta\nt1 = [1, 2, [3, 5, 6]]\nt2 = [2, 3, [3, 6, 8]]\ndiff = DeepDiff(t1, t2, ignore_order=True, report_repetition=True)\ndelta = Delta(diff, raise_errors=False)\n\n# Apply delta to incompatible object\nt3 = [1, 2, 3, 5]\nt4 = t3 + delta\n# Unable to get the item at root[2][1]\n\nt4\n# [3, 2, 3, 5]\n\n# With raise_errors=True\ndelta2 = Delta(diff, raise_errors=True)\nt3 + delta2\n# Raises DeltaError: Unable to get the item at root[2][1]\n```\n\n----------------------------------------\n\nTITLE: Group By Basic Example - Python\nDESCRIPTION: This snippet demonstrates the use of the `group_by` parameter in `DeepDiff`. It showcases how to group a list of dictionaries by a specific key (in this case, 'id') so that each dictionary is keyed by its 'id' value for comparison. The focus is to show how the structure is changed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody'},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Blue'},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple'},\n... ]\n>>>\n>>> t2 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody'},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Brown'},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple'},\n... ]\n>>>\n>>> DeepDiff(t1, t2)\n{'values_changed': {\"root[1]['last_name']\": {'new_value': 'Brown', 'old_value': 'Blue'}}}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> DeepDiff(t1, t2, group_by='id')\n{'values_changed': {\"root['BB']['last_name']\": {'new_value': 'Brown', 'old_value': 'Blue'}}}\n```\n\n----------------------------------------\n\nTITLE: Serializing DeepDiff Objects to JSON with Custom Type Handling in Python\nDESCRIPTION: Illustrates usage of DeepDiff's `to_json()` method to safely serialize difference objects to JSON strings. It supports a `default_mapping` parameter to handle custom or non-serializable Python object types by specifying conversion functions. The method passes additional keyword arguments to Python's `json.dumps()` allowing customization. Inputs are DeepDiff objects created from user data; outputs are JSON strings representing the diff results. Prerequisite: DeepDiff library.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> class A:\n...     pass\n... \n>>> class B:\n...     pass\n... \n>>> t1 = A()\n>>> t2 = B()\n>>> ddiff = DeepDiff(t1, t2)\n>>> ddiff.to_json()\nTypeError: We do not know how to convert <__main__.A object at 0x10648> of type <class '__main__.A'> for json serialization. Please pass the default_mapping parameter with proper mapping of the object to a basic python type.\n\n>>> default_mapping = {A: lambda x: 'obj A', B: lambda x: 'obj B'}\n>>> ddiff.to_json(default_mapping=default_mapping)\n'{\"type_changes\": {\"root\": {\"old_type\": \"A\", \"new_type\": \"B\", \"old_value\": \"obj A\", \"new_value\": \"obj B\"}}}'\n\n>>> t1 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": [1, 2, 3]}}\n>>> t2 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": \"world\\n\\n\\nEnd\"}}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> ddiff.to_json()\n'{\"type_changes\": {\"root[4][\\'b\\']\": {\"old_type\": \"list\", \"new_type\": \"str\", \"old_value\": [1, 2, 3], \"new_value\": \"world\\\\n\\\\n\\\\nEnd\"}}}'\n```\n\n----------------------------------------\n\nTITLE: Using force parameter with Delta object in Python\nDESCRIPTION: Demonstrates using the Delta object with force=True to apply differences even when original paths don't exist. This creates missing intermediate structures automatically, though it may not preserve the original data types.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndelta = Delta(diff, force=True)\n{} + delta\n{'x': {'y': {3: 4}}, 'q': {'t': 0.5}}\n```\n\n----------------------------------------\n\nTITLE: Searching File Content with deep grep Command Line\nDESCRIPTION: Shows how to use the `deep grep` command to search for a specific value ('james') within a file (`t1.csv`), ignoring case (`--ignore-case`). It outputs the path to the matched item within the file's structure.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ deep grep --ignore-case james t1.csv\n{'matched_values': [\"root[2]['first_name']\"]}\n```\n\n----------------------------------------\n\nTITLE: Saving Patch Delta to File with deep diff Command Line\nDESCRIPTION: Shows how to redirect the output of the `deep diff` command when creating a patch delta (`--create-patch`) to a file (`patch1.pickle`). This file contains the machine-readable delta used by the `deep patch` command.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndeep diff t1.csv t2.csv --ignore-order --report-repetition --create-patch > patch1.pickle\n```\n\n----------------------------------------\n\nTITLE: Converting DeepDiff Object to Dictionary Using Python\nDESCRIPTION: Demonstrates the usage of the DeepDiff `to_dict()` method to convert difference objects into standard Python dictionaries. It shows how to compare nested structures and illustrates overriding the view parameter to customize output format. Requires the DeepDiff library and proper initialization of DeepDiff objects with the compared dictionaries. Input: two Python dictionaries; Output: a Python dictionary representing the diff results.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": [1, 2, 3]}}\n>>> t2 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": \"world\\n\\n\\nEnd\"}}\n>>> ddiff = DeepDiff(t1, t2)\n>>> ddiff.to_dict()\n{'type_changes': {\"root[4]['b']\": {'old_type': <class 'list'>, 'new_type': <class 'str'>, 'old_value': [1, 2, 3], 'new_value': 'world\\n\\n\\nEnd'}}}\n\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> ddiff.to_dict(view_override='text')\n{'type_changes': {\"root[4]['b']\": {'old_type': <class 'list'>, 'new_type': <class 'str'>, 'old_value': [1, 2, 3], 'new_value': 'world\\n\\n\\nEnd'}}}\n```\n\n----------------------------------------\n\nTITLE: Using threshold_to_diff_deeper with DeepDiff in Python\nDESCRIPTION: Illustrates the effect of the `threshold_to_diff_deeper` parameter when comparing dictionaries in DeepDiff. Setting it to 0 forces DeepDiff to report individual key additions/removals even with minimal key intersection. Using a non-zero threshold (default 0.33) causes DeepDiff to report the entire dictionary as changed ('values_changed') if the ratio of intersecting keys is below the threshold.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/optimizations.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1 = {\"veggie\": \"carrots\"}\n>>> t2 = {\"meat\": \"carrots\"}\n>>>\n>>> DeepDiff(t1, t2, threshold_to_diff_deeper=0)\n{'dictionary_item_added': [\"root['meat']\"], 'dictionary_item_removed': [\"root['veggie']\"]}\n>>> DeepDiff(t1, t2, threshold_to_diff_deeper=0.33)\n{'values_changed': {'root': {'new_value': {'meat': 'carrots'}, 'old_value': {'veggie': 'carrots'}}}}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of DeepHash\nDESCRIPTION: Shows the basic usage pattern of DeepHash to calculate hash values for objects, including how to extract the hash for the main object.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> hashes = DeepHash(obj)\n>>> hashes[obj]\n34150898645750099477987229399128149852\n\n>>> hashes = DeepHash(obj)[obj]\n```\n\n----------------------------------------\n\nTITLE: Comparing Decimals with Significant Digits in DeepDiff (Python)\nDESCRIPTION: Demonstrates using the 'significant_digits' parameter in DeepDiff to compare Python Decimal objects with varying levels of precision after the decimal point. A value of 0 ignores differences after the decimal, while 1 considers the first decimal place.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from decimal import Decimal\n>>> from deepdiff import DeepDiff\n>>> t1 = Decimal('1.52')\n>>> t2 = Decimal('1.57')\n>>> DeepDiff(t1, t2, significant_digits=0)\n{}\n>>> DeepDiff(t1, t2, significant_digits=1)\n{'values_changed': {'root': {'new_value': Decimal('1.57'), 'old_value': Decimal('1.52')}}}\n```\n\n----------------------------------------\n\nTITLE: Using DeepHash with Deep Copy\nDESCRIPTION: Demonstrates that DeepHash produces the same hash for deep copies of objects, showing the hash consistency based on content rather than identity.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from copy import deepcopy\n>>> obj2 = deepcopy(obj)\n>>> DeepHash(obj2)[obj2]\n34150898645750099477987229399128149852\n```\n\n----------------------------------------\n\nTITLE: Controlling Diff Granularity with threshold_to_diff_deeper in DeepDiff Python\nDESCRIPTION: This snippet illustrates how the `threshold_to_diff_deeper` parameter affects the granularity of the diff report for nested dictionaries. A lower threshold provides more detailed differences (item added/removed), while a higher threshold might report the entire container as changed if the overall difference exceeds the threshold.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nt1 = {\"veggie\": \"carrots\"}\nt2 = {\"meat\": \"carrots\"}\n\nDeepDiff(t1, t2, threshold_to_diff_deeper=0)\nDeepDiff(t1, t2, threshold_to_diff_deeper=0.33)\n```\n\n----------------------------------------\n\nTITLE: Case-Insensitive String Hashing\nDESCRIPTION: Shows how to use ignore_string_case to make string hashing case-insensitive, allowing different-cased strings to produce the same hash.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepHash\n>>> DeepHash('hello')['hello'] == DeepHash('heLLO')['heLLO']\nFalse\n>>> DeepHash('hello', ignore_string_case=True)['hello'] == DeepHash('heLLO', ignore_string_case=True)['heLLO']\nTrue\n```\n\n----------------------------------------\n\nTITLE: Custom Number to String Conversion\nDESCRIPTION: Demonstrates how to define a custom number_to_string_func to perform specialized number processing before hash calculation, such as treating ranges of numbers as equivalent.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepHash\n>>> from deepdiff.helper import number_to_string\n>>> def custom_number_to_string(number, *args, **kwargs):\n...     number = 100 if number < 100 else number\n...     return number_to_string(number, *args, **kwargs)\n...\n>>> t1 = [10, 12, 100000]\n>>> t2 = [50, 63, 100021]\n>>> t1_hash = DeepHash(t1, significant_digits=3, number_format_notation=\"e\", number_to_string_func=custom_number_to_string)\n>>> t2_hash = DeepHash(t2, significant_digits=3, number_format_notation=\"e\", number_to_string_func=custom_number_to_string)\n>>> t1_hash[t1] == t2_hash[t2]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Example YAML File Before Patching\nDESCRIPTION: Displays the content of a sample YAML file (`another.yaml`) that will be used as the target for applying a patch created by the `deep diff` command. The patch is intended to change a 'zip' value.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n---\n-\n    first_name: Joe\n    last_name: Nobody\n    zip: 90011\n-\n    first_name: Jack\n    last_name: Doit\n    zip: 22222\n-\n    first_name: Sara\n    last_name: Stanley\n    zip: 11111\n```\n\n----------------------------------------\n\nTITLE: Set Difference Detection - Python\nDESCRIPTION: This snippet demonstrates comparing sets using `DeepDiff`. It showcases how `DeepDiff` identifies items that have been added and removed from the sets.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1, 2, 8}\n>>> t2 = {1, 2, 3, 5}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint(ddiff)\n{'set_item_added': [root[3], root[5]], 'set_item_removed': [root[8]]}\n```\n\n----------------------------------------\n\nTITLE: List with Dictionary Difference - Python\nDESCRIPTION: This snippet demonstrates comparing dictionaries that contain lists of dictionaries and identifies changes within the nested dictionaries.  It shows how `DeepDiff` detects changes inside the list of dictionaries, for instance an item's value change.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, {1:1, 2:2}]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, {1:3}]}}\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint (ddiff, indent = 2)\n{ 'dictionary_item_removed': [root[4]['b'][2][2]],\n  'values_changed': {\"root[4]['b'][2][1]\": {'new_value': 3, 'old_value': 1}}}\n```\n\n----------------------------------------\n\nTITLE: Extract Command Line Help\nDESCRIPTION: This displays the help information for the `deep extract` command-line tool.  This command is part of the command-line interface ('deepdiff[cli]'). Uses the `--help` flag to show usage instructions. No input is required; the output is help text.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ deep extract --help\n```\n\n----------------------------------------\n\nTITLE: Grep Command Line Help\nDESCRIPTION: This demonstrates displaying help information for the `deep grep` command-line tool using the `--help` flag. Requires installation of 'deepdiff[cli]'. No input required; output is the help information.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ deep grep --help\n```\n\n----------------------------------------\n\nTITLE: Instantiating DeepDiff with Default Comparison - Python\nDESCRIPTION: This snippet calls DeepDiff on two lists of dictionaries without specifying a custom comparison function, resulting in element-wise comparison by position. Requires the deepdiff module. Inputs are two lists (t1 and t2); output is a dictionary highlighting values changed and item additions/removals. Handles complex, nested lists of dictionaries.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\nt1 = [\n    {'id': 1, 'value': [1]},\n    {'id': 2, 'value': [7, 8, 1]},\n    {'id': 3, 'value': [7, 8]},\n]\nt2 = [\n    {'id': 2, 'value': [7, 8]},\n    {'id': 3, 'value': [7, 8, 1]},\n    {'id': 1, 'value': [1]},\n]\ndeepdiff_result = DeepDiff(t1, t2)\n# Outputs diff with values changed and iterable item added/removed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating UnicodeDecodeError in DeepDiff with Bytes (Python)\nDESCRIPTION: This snippet illustrates a `UnicodeDecodeError` that occurs when DeepDiff attempts to diff lists containing bytes with non-UTF-8 characters while `ignore_order` is True. Hashing required for unordered comparison involves string conversion, which fails with the default encoding.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/other.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\n```\n\nLANGUAGE: Python\nCODE:\n```\nitem = b\"\\xbc cup of flour\"\n```\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff([b'foo'], [item], ignore_order=True)\n```\n\n----------------------------------------\n\nTITLE: Importing DeepDiff and pprint - Python\nDESCRIPTION: This snippet imports the necessary modules: `DeepDiff` from the `deepdiff` library and `pprint` from the `pprint` library. `DeepDiff` is used for comparing objects and `pprint` is used to pretty-print the output for better readability.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from pprint import pprint\n```\n\n----------------------------------------\n\nTITLE: Initializing DeepDiff Grep Search in Python\nDESCRIPTION: Demonstrates how to import the grep function from the DeepDiff library along with the pprint module for pretty-printing. These imports are prerequisites for running the example searches shown.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/search_doc.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import grep\n>>> from pprint import pprint\n```\n\n----------------------------------------\n\nTITLE: Diffing Lists Containing Dictionaries with Tree View (Python)\nDESCRIPTION: Example using DeepDiff's 'tree' view to compare complex nested structures involving lists that contain dictionaries. It shows how changes deep within the structure, such as a removed dictionary item (`dictionary_item_removed`) and a changed value (`values_changed`) inside a dictionary within a list, are reported with precise paths.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, {1:1, 2:2}]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, {1:3}]}}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> pprint (ddiff, indent = 2)\n{ 'dictionary_item_removed': [<root[4]['b'][2][2] t1:2, t2:not present>],\n  'values_changed': [<root[4]['b'][2][1] t1:1, t2:3>]}\n```\n\n----------------------------------------\n\nTITLE: Excluding Objects via exclude_obj_callback in DeepDiff (Python)\nDESCRIPTION: This example illustrates defining a custom function for exclude_obj_callback to dynamically exclude objects from comparison results based on their path or type. DeepDiff invokes the callback for each object and path pair to determine exclusion. The dependency is DeepDiff, and the key parameters are input dicts and the callback function. The result is an empty diff if excluded properties match the callback logic.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\ndef exclude_obj_callback(obj, path):\n    return True if \"skip\" in path or isinstance(obj, int) else False\n\nt1 = {\"x\": 10, \"y\": \"b\", \"z\": \"c\", \"skip_1\": 0}\nt2 = {\"x\": 12, \"y\": \"b\", \"z\": \"c\", \"skip_2\": 0}\nDeepDiff(t1, t2, exclude_obj_callback=exclude_obj_callback)\n# Output: {}\n```\n\n----------------------------------------\n\nTITLE: Strict Object Exclusion with exclude_obj_callback_strict in DeepDiff (Python)\nDESCRIPTION: This snippet demonstrates using exclude_obj_callback_strict, which excludes elements from the diff only if the callback returns True for both elements. The callback checks for integers greater than 10. DeepDiff is required, and the main parameters are two dicts and the strict callback. Outputs vary based on callback matching.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ndef exclude_obj_callback_strict(obj, path):\n    return True if isinstance(obj, int) and obj > 10 else False\n\nt1 = {\"x\": 10, \"y\": \"b\", \"z\": \"c\"}\nt2 = {\"x\": 12, \"y\": \"b\", \"z\": \"c\"}\nDeepDiff(t1, t2, exclude_obj_callback=exclude_obj_callback_strict)\n# Output: {}\nDeepDiff(t1, t2, exclude_obj_callback_strict=exclude_obj_callback_strict)\n# Output: {'values_changed': {\"root['x']\": {'new_value': 12, 'old_value': 10}}}\n```\n\n----------------------------------------\n\nTITLE: Added/Removed Items with Verbose Level 2 - Python\nDESCRIPTION: This snippet demonstrates the use of `verbose_level=2` with `DeepDiff` to show the values of added and removed items.  This provides more detailed information about the changes, including the values of added and removed items. This is helpful for a more complete analysis of the differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 3:3, 4:4}\n>>> t2 = {1:1, 3:3, 5:5, 6:6}\n>>> ddiff = DeepDiff(t1, t2, verbose_level=2)\n>>> pprint(ddiff, indent=2)\n{ 'dictionary_item_added': {'root[5]': 5, 'root[6]': 6},\n  'dictionary_item_removed': {'root[4]': 4}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Class Attributes with DeepDiff (Tree View)\nDESCRIPTION: This snippet demonstrates how to use DeepDiff to compare two instances of a class and view the differences in a tree structure.  It showcases how attribute changes are identified and displayed, including when an attribute is added in one object but not present in the other. Requires the `DeepDiff` class and `ClassA` to be defined.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = ClassA(1)\n>>> t2 = ClassA(2)\n>>>\n>>> print(DeepDiff(t1, t2, view='tree'))\n{'values_changed': [<root.b t1:1, t2:2>]}\n```\n\n----------------------------------------\n\nTITLE: Including Parent Paths Implicitly Includes Children in DeepDiff Python\nDESCRIPTION: Demonstrates that when a path is specified in `include_paths` for `DeepDiff`, all its child elements are automatically included in the comparison as well. The example shows including the root key `\"foo\"` results in the comparison of its nested key `\"foo['bar']\"`, reporting the value change.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {\n...     \"foo\": {\"bar\": \"potato\"},\n...     \"ingredients\": [\"no meat\", \"no eggs\", \"no dairy\"]\n... }\n>>> t2 = {\n...     \"foo\": {\"bar\": \"banana\"},\n...     \"ingredients\": [\"bread\", \"cheese\"]\n... }\n>>> DeepDiff(t1, t2, include_paths=\"foo\")\n{'values_changed': {\"root['foo']['bar']\": {'new_value': 'banana', 'old_value': 'potato'}}}\n```\n\n----------------------------------------\n\nTITLE: Detecting Added Object Attributes with DeepDiff (Tree View)\nDESCRIPTION: This example shows how DeepDiff identifies when an attribute is added to one object but is missing from another when using the tree view. It requires `DeepDiff` class and the `ClassA` to be defined, along with the `pprint` function from the `pprint` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> t2.c = \"new attribute\"\n>>> pprint(DeepDiff(t1, t2, view='tree'))\n{'attribute_added': [<root.c t1:not present, t2:'new attribute'>],\n     'values_changed': [<root.b t1:1, t2:2>]}\n```\n\n----------------------------------------\n\nTITLE: Comparing Sets with DeepDiff (Tree View)\nDESCRIPTION: This snippet demonstrates comparing two sets using DeepDiff and visualizing the differences in a tree view. It allows for traversing the tree to understand the context of each difference. Requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n\nTree view\n>>> tree = DeepDiff(t1, t2, view='tree')\n>>> tree\n{'set_item_removed': [<root: t1:4, t2:not present>, <root: t1:1, t2:not present>], 'set_item_added': [<root: t1:not present, t2:3>]}\n>>> tree['set_item_added'][0]\n<root: t1:not present, t2:3>\n>>> tree['set_item_added'][0].t2\n3\n```\n\n----------------------------------------\n\nTITLE: Including Objects via include_obj_callback in DeepDiff (Python)\nDESCRIPTION: This snippet shows how to use include_obj_callback to include only specific objects in the comparison results, based on their path or type. The callback determines inclusion, allowing higher control over which properties are diffed. DeepDiff is the dependency; inputs are dicts and the callback function. Only fields passing the callback are shown in the diff.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\ndef include_obj_callback(obj, path):\n    return True if \"include\" in path or isinstance(obj, int) else False\n\nt1 = {\"x\": 10, \"y\": \"b\", \"z\": \"c\", \"include_me\": \"a\"}\nt2 = {\"x\": 10, \"y\": \"b\", \"z\": \"c\", \"include_me\": \"b\"}\nDeepDiff(t1, t2, include_obj_callback=include_obj_callback)\n# Output: {'values_changed': {\"root['include_me']\": {'new_value': \"b\", 'old_value': \"a\"}}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Sets with Tree View in DeepDiff (Python)\nDESCRIPTION: Demonstrates comparing Python sets using DeepDiff's 'tree' view. It shows how added (`set_item_added`) and removed (`set_item_removed`) elements are identified. The example also illustrates accessing the original sets (`t1`, `t2`) by traversing up (`item.up`) from a change node.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1, 2, 8}\n>>> t2 = {1, 2, 3, 5}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> print(ddiff)\n{'set_item_removed': [<root: t1:8, t2:not present>], 'set_item_added': [<root: t1:not present, t2:3>, <root: t1:not present, t2:5>]}\n>>> # grabbing one item from set_item_removed set which has one item only\n>>> (item,) = ddiff['set_item_removed']\n>>> item.up\n<root t1:{8, 1, 2}, t2:{1, 2, 3, 5}>\n>>> item.up.t1 == t1\nTrue\n```\n\n----------------------------------------\n\nTITLE: Handling Value Changes with Tree View in DeepDiff (Python)\nDESCRIPTION: Shows how to use the 'tree' view (`view='tree'`) in DeepDiff to identify changed values between two dictionaries. It demonstrates the effect of `verbose_level` on the output representation and how to access the specific changed items (`changed.t1`, `changed.t2`) and traverse up to the parent node (`changed.up`) from a change object.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from pprint import pprint\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = {1:1, 2:4, 3:3}\n>>> ddiff_verbose0 = DeepDiff(t1, t2, verbose_level=0, view='tree')\n>>> ddiff_verbose0\n{'values_changed': [<root[2]>]}\n>>>\n>>> ddiff_verbose1 = DeepDiff(t1, t2, verbose_level=1, view='tree')\n>>> ddiff_verbose1\n{'values_changed': [<root[2] t1:2, t2:4>]}\n>>> set_of_values_changed = ddiff_verbose1['values_changed']\n>>> # since set_of_values_changed includes only one item in a set\n>>> # in order to get that one item we can:\n>>> (changed,) = set_of_values_changed\n>>> changed  # Another way to get this is to do: changed=list(set_of_values_changed)[0]\n<root[2] t1:2, t2:4>\n>>> changed.t1\n2\n>>> changed.t2\n4\n>>> # You can traverse through the tree, get to the parents!\n>>> changed.up\n<root t1:{1: 1, 2: 2,...}, t2:{1: 1, 2: 4,...}>\n```\n\n----------------------------------------\n\nTITLE: Explanation of DeepHash Return Values and Usage\nDESCRIPTION: This snippet explains that DeepHash returns a dictionary mapping objects (by ID) to their hashes, allowing nested structures to be hashed recursively. When needing only the hash of a specific object, index the result with the object itself (e.g., DeepHash(obj)[obj]). It highlights that DeepHash handles unhashable objects by serializing them deterministically, making it suitable for hashing complex data types like sets or dictionaries.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> DeepHash(obj)\n{'id1': 'hash1', 'id2': 'hash2', ...}\n# To get the hash of the object itself:\nhash_value = DeepHash(obj)[obj]\n```\n\n----------------------------------------\n\nTITLE: Searching Nested Data Structures with Verbose Output in Python\nDESCRIPTION: Illustrates searching within nested lists and dictionaries for a substring using grep with verbose_level=2. This setting returns both the paths and values for matched items. The example shows how matches can occur at multiple nested levels and types, returning comprehensive match details.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/search_doc.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> obj = [\"something somewhere\", {\"long\": \"somewhere\", \"string\": 2, 0: 0, \"somewhere\": \"around\"}]\n>>> item = \"somewhere\"\n>>> ds = obj | grep(item, verbose_level=2)\n>>> pprint(ds, indent=2)\n{ 'matched_paths': {\"root[1]['somewhere']\": 'around'},\n  'matched_values': { 'root[0]': 'something somewhere',\n                      \"root[1]['long']\": 'somewhere'}}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Mixed Types by Value)\nDESCRIPTION: This advanced example shows passing actual values, rather than just types, to `ignore_type_in_groups`. DeepDiff extracts the types from these values to define groups (e.g., `int` and `float` from `(1, 1.0)`). It also demonstrates ignoring type changes between `None`, `str`, and `bytes`.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> import datetime\n>>> \n>>> t1 = [1, 2, 3, 'a', None]\n>>> t2 = [1.0, 2.0, 3.3, b'a', 'hello']\n>>> DeepDiff(t1, t2, ignore_type_in_groups=[(1, 1.0), (None, str, bytes)])\n{'values_changed': {'root[2]': {'new_value': 3.3, 'old_value': 3}}}\n```\n\n----------------------------------------\n\nTITLE: Using Mathematical Epsilon for Tolerance in DeepDiff (Python)\nDESCRIPTION: Demonstrates the 'math_epsilon' parameter in DeepDiff for comparing numbers within a specified tolerance using Python's math.isclose() logic. In the example, Decimal values that differ by less than the provided epsilon (0.01) are considered equal.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from decimal import Decimal\n>>> from deepdiff import DeepDiff\n>>> d1 = {\"a\": Decimal(\"7.175\")}\n>>> d2 = {\"a\": Decimal(\"7.174\")}\n>>> DeepDiff(d1, d2, math_epsilon=0.01)\n{}\n```\n\n----------------------------------------\n\nTITLE: Serializing DeepDiff Delta Objects to Flat Dictionaries Using Python\nDESCRIPTION: Illustrates converting DeepDiff delta objects into a list of flat dictionaries with `Delta.to_flat_dicts()` for relational storage. Outputs include comprehensive metadata fields with values, actions, and paths. Uses a special string 'unknown___' to indicate unknown or None values. Examples include dictionary diff and iterable diff cases. Requires DeepDiff library and pprint for displaying results.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from pprint import pprint\n>>> from deepdiff import DeepDiff, Delta\n>>> t1 = {\"key1\": \"value1\"}\n>>> t2 = {\"field2\": {\"key2\": \"value2\"}}\n>>> diff = DeepDiff(t1, t2, verbose_level=2)\n>>> pprint(diff, indent=2)\n{ 'dictionary_item_added': {\"root['field2']\": {'key2': 'value2'}},\n  'dictionary_item_removed': {\"root['key1']\": 'value1'}}\n>>> delta = Delta(diff, bidirectional=True)\n>>> flat_dicts = delta.to_flat_dicts()\n>>> pprint(flat_dicts, indent=2)\n[ { 'action': 'dictionary_item_added',\n    'new_path': None,\n    'old_type': 'unknown___',\n    'old_value': 'unknown___',\n    'path': ['field2', 'key2'],\n    't1_from_index': None,\n    't1_to_index': None,\n    't2_from_index': None,\n    't2_to_index': None,\n    'type': 'unknown___',\n    'value': 'value2'},\n  { 'action': 'dictionary_item_removed',\n    'new_path': None,\n    'old_type': 'unknown___',\n    'old_value': 'unknown___',\n    'path': ['key1'],\n    't1_from_index': None,\n    't1_to_index': None,\n    't2_from_index': None,\n    't2_to_index': None,\n    'type': 'unknown___',\n    'value': 'value1'}]\n\n>>> t3 = [\"A\", \"B\"]\n>>> t4 = [\"A\", \"B\", \"C\", \"D\"]\n>>> diff = DeepDiff(t3, t4, verbose_level=2)\n>>> pprint(diff, indent=2)\n{'iterable_item_added': {'root[2]': 'C', 'root[3]': 'D'}}\n>>> delta = Delta(diff, bidirectional=True)\n>>> flat_dicts = delta.to_flat_dicts()\n>>> pprint(flat_dicts, indent=2)\n```\n\n----------------------------------------\n\nTITLE: Using exclude_obj_callback for Custom Filtering\nDESCRIPTION: Demonstrates how to use a callback function to exclude specific objects from hash calculation based on custom criteria.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> dic1 = {\"x\": 1, \"y\": 2, \"z\": 3}\n>>> t1 = [dic1]\n>>> t1_hash = DeepHash(t1, exclude_obj_callback=exclude_obj_callback)\n>>>\n>>> dic2 = {\"z\": 3}\n>>> t2 = [dic2]\n>>> t2_hash = DeepHash(t2, exclude_obj_callback=exclude_obj_callback)\n>>>\n>>> t1_hash[t1] == t2_hash[t2]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Visualizing Tree View Structure (Text)\nDESCRIPTION: A textual diagram illustrating the structure of nodes within DeepDiff's Tree View. It depicts parent and child nodes corresponding to the compared objects (t1, t2) at different levels, along with the 'up' and 'down' relationships used for traversing the difference tree. Key attributes like `t1`, `t2`, `path()`, `additional`, and `repetition` are also associated with the nodes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n+---------------------------------------------------------------+\n|                                                               |\n|    parent(t1)              parent node            parent(t2)  |----level\n|      +                          ^                     +       |\n+------|--------------------------|---------------------|-------+\n       |                      |   | up                  |\n       | Child                |   |                     | ChildRelationship\n       | Relationship         |   |                     |\n       |                 down |   |                     |\n+------|----------------------|-------------------------|-------+\n|      v                      v                         v       |\n|    child(t1)              child node               child(t2)  |----level\n|                                                               |\n+---------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Comparing Enum Values with use_enum_value Option in DeepDiff (Python)\nDESCRIPTION: This snippet presents usage of the use_enum_value flag in DeepDiff to compare enum objects by their raw value rather than their type. Dependencies are DeepDiff and the Python enum module; input is a string and an enum value. With use_enum_value=True, no diff is reported if values are logically equivalent, regardless of types.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum\nfrom deepdiff import DeepDiff\n\nclass MyEnum2(str, Enum):\n    book = \"book\"\n    cake = \"cake\"\n\nDeepDiff(\"book\", MyEnum2.book)\n# Output: {'type_changes': {'root': {'old_type': <class 'str'>, 'new_type': <enum 'MyEnum2'>, 'old_value': 'book', 'new_value': <MyEnum2.book: 'book'>}}}\nDeepDiff(\"book\", MyEnum2.book, use_enum_value=True)\n# Output: {}\n```\n\n----------------------------------------\n\nTITLE: Group By 2D Example - Python\nDESCRIPTION: This snippet illustrates how to use `group_by` with a list of dictionaries to perform a 2D group by, grouping based on two keys, effectively creating a nested grouping structure. The result is displayed using pprint for better readability.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from pprint import pprint\n>>> from deepdiff import DeepDiff\n>>>\n>>> t1 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody'},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Blue'},\n...     {'id': 'BB', 'name': 'Jimmy', 'last_name': 'Red'},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple'},\n... ]\n>>>\n>>> t2 = [\n...     {'id': 'AA', 'name': 'Joe', 'last_name': 'Nobody'},\n...     {'id': 'BB', 'name': 'James', 'last_name': 'Brown'},\n...     {'id': 'CC', 'name': 'Mike', 'last_name': 'Apple'},\n... ]\n>>>\n>>> diff = DeepDiff(t1, t2, group_by=['id', 'name'])\n>>> pprint(diff)\n{'dictionary_item_removed': [root['BB']['Jimmy']],\n 'values_changed': {\"root['BB']['James']['last_name']\": {'new_value': 'Brown',\n                                                             'old_value': 'Blue'}}}\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies for DeepDiff Development\nDESCRIPTION: A comprehensive list of Python packages and their specific versions required for developing and testing the DeepDiff project. Includes references to other requirement files, testing tools, serialization libraries, data manipulation packages, and build utilities.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/requirements-dev.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r requirements.txt\n-r requirements-cli.txt\nbump2version==1.0.1\njsonpickle==4.0.1\ncoverage==7.6.10\nipdb==0.13.13\nnumpy==2.2.2\npytest==8.3.4\npytest-cov==6.0.0\npython-dotenv==1.0.1\nflake8==7.1.1\npython-dateutil==2.9.0.post0\norjson==3.10.15\nwheel==0.45.1\ntomli==2.2.1\ntomli-w==1.2.0\npydantic==2.10.6\npytest-benchmark==5.1.0\npandas==2.2.3\npolars==1.21.0\nsetuptools==75.8.0\ntypes-setuptools==75.8.0\n```\n\n----------------------------------------\n\nTITLE: Comparing Numbers Using Log Scale in DeepDiff (Python)\nDESCRIPTION: Shows how to use the 'use_log_scale' and 'log_scale_similarity_threshold' parameters in DeepDiff to compare numbers based on their logarithmic difference. This approach ignores differences based on relative magnitude rather than absolute precision. Increasing the threshold ignores larger relative differences.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n\n>>> t1 = {'foo': 110, 'bar': 306}\n>>> t2 = {'foo': 140, 'bar': 298}\n>>>\n>>> DeepDiff(t1, t2)\n{'values_changed': {\"root['foo']\": {'new_value': 140, 'old_value': 110}, \"root['bar']\": {'new_value': 298, 'old_value': 306}}}\n\n>>> DeepDiff(t1, t2, use_log_scale=True, log_scale_similarity_threshold=0.01)\n{'values_changed': {\"root['foo']\": {'new_value': 140, 'old_value': 110}, \"root['bar']\": {'new_value': 298, 'old_value': 306}}}\n\n>>> DeepDiff(t1, t2, use_log_scale=True, log_scale_similarity_threshold=0.1)\n{'values_changed': {\"root['foo']\": {'new_value': 140, 'old_value': 110}}}\n\n>>> DeepDiff(t1, t2, use_log_scale=True, log_scale_similarity_threshold=0.3)\n{}\n```\n\n----------------------------------------\n\nTITLE: Using a Callable Prefix with DeepDiff's pretty() Method\nDESCRIPTION: This snippet shows how to use a callable function as a prefix for each line of DeepDiff's `pretty()` output. The function receives keyword arguments, including the `DeepDiff` object itself, allowing for dynamic prefix generation. It requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n>>> def callback(**kwargs):\n...     \"\"\"Helper function using a hidden variable on the diff that tracks which count prints next\"\"\"\n...     kwargs['diff']._diff_count = 1 + getattr(kwargs['diff'], '_diff_count', 0)\n...     return f\"Diff #{kwargs['diff']._diff_count}: \"\n...\n>>> print(DeepDiff(t1, t2).pretty(prefix=callback))\nDiff #1: Item root[3] added to set.\nDiff #2: Item root[4] removed from set.\nDiff #3: Item root[1] removed from set.\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Datetime and String)\nDESCRIPTION: This snippet demonstrates using `ignore_type_in_groups` to ignore type changes between `datetime.datetime` objects and `str` types. When comparing a list containing a datetime object to one with a string, the type change is ignored, but a value difference might still be reported if values aren't equivalent.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> now = datetime.datetime(2020, 5, 5)\n>>> t1 = [1, 2, 3, 'a', now]\n>>> t2 = [1, 2, 3, 'a', 'now']\n>>> DeepDiff(t1, t2, ignore_type_in_groups=[(str, bytes, datetime.datetime)])\n{'values_changed': {'root[4]': {'new_value': 'now', 'old_value': datetime.datetime(2020, 5, 5, 0, 0)}}}\n```\n\n----------------------------------------\n\nTITLE: Handling Subclasses with ignore_type_subclasses\nDESCRIPTION: Demonstrates how to use ignore_type_subclasses to treat objects of parent and child classes as equivalent for hashing purposes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepHash\n>>>\n>>> class ClassB:\n...     def __init__(self, x):\n...         self.x = x\n...     def __repr__(self):\n...         return \"obj b\"\n...\n>>>\n>>> class ClassC(ClassB):\n...     def __repr__(self):\n...         return \"obj c\"\n...\n>>> obj_b = ClassB(1)\n>>> obj_c = ClassC(1)\n>>>\n>>> # Since these 2 objects are from 2 different classes, the hashes are different by default.\n... # ignore_type_in_groups is set to [(ClassB, )] which means to ignore any type conversion between\n... # objects of classB and itself which does not make sense but it illustrates a better point when\n... # ignore_type_subclasses is set to be True.\n... hashes_b = DeepHash(obj_b, ignore_type_in_groups=[(ClassB, )])\n>>> hashes_c = DeepHash(obj_c, ignore_type_in_groups=[(ClassB, )])\n>>> hashes_b[obj_b] != hashes_c[obj_c]\nTrue\n>>>\n>>> # Hashes of these 2 objects will be the same when ignore_type_subclasses is set to True\n... hashes_b = DeepHash(obj_b, ignore_type_in_groups=[(ClassB, )], ignore_type_subclasses=True)\n>>> hashes_c = DeepHash(obj_c, ignore_type_in_groups=[(ClassB, )], ignore_type_subclasses=True)\n>>> hashes_b[obj_b] == hashes_c[obj_c]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Strict Object Inclusion with include_obj_callback_strict in DeepDiff (Python)\nDESCRIPTION: This code demonstrates using include_obj_callback_strict to include objects in diffs only if the callback returns True for both elements. The provided callback checks if an integer is greater than 10. Inputs are two dicts and the callback. Under different settings, fields may or may not appear in the result based on the callback logic.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\ndef include_obj_callback_strict(obj, path):\n    return True if isinstance(obj, int) and obj > 10 else False\n\nt1 = {\"x\": 10, \"y\": \"b\", \"z\": \"c\"}\nt1 = {\"x\": 12, \"y\": \"b\", \"z\": \"c\"}\nDeepDiff(t1, t2, include_obj_callback=include_obj_callback_strict)\n# Output: {'values_changed': {\"root['x']\": {'new_value': 12, 'old_value': 10}}}\nDeepDiff(t1, t2, include_obj_callback_strict=include_obj_callback_strict)\n# Output: {}\n```\n\n----------------------------------------\n\nTITLE: Comparing Lists Without Ignoring Order in DeepDiff Python\nDESCRIPTION: This snippet demonstrates the default behavior of DeepDiff when comparing lists. Without `ignore_order=True`, DeepDiff compares elements at the same index, which can result in a detailed but potentially misleading diff report if items are merely reordered or only slightly changed.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nfrom pprint import pprint\nt1 = [\n    {\n        \"key\": \"some/pathto/customers/foo/\",\n        \"flags\": 0,\n        \"value\": \"\"\n    },\n    {\n        \"key\": \"some/pathto/customers/foo/account_number\",\n        \"flags\": 0,\n        \"value\": \"somevalue1\"\n    }\n]\n\nt2 = [\n    {\n        \"key\": \"some/pathto/customers/foo/account_number\",\n        \"flags\": 0,\n        \"value\": \"somevalue2\"\n    },\n    {\n        \"key\": \"some/pathto/customers/foo/\",\n        \"flags\": 0,\n        \"value\": \"new\"\n    }\n]\n\npprint(DeepDiff(t1, t2))\n```\n\n----------------------------------------\n\nTITLE: Reporting Type Changes with verbose_level=0 in DeepDiff in Python\nDESCRIPTION: This example shows how setting `verbose_level=0` when using DeepDiff suppresses the reporting of `new_value` and `old_value` within `type_changes`, only indicating the type change itself.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = {1:1, 2:\"2\", 3:3}\n>>> pprint(DeepDiff(t1, t2, verbose_level=0), indent=2)\n{ 'type_changes': { 'root[2]': { 'new_type': <class 'str'>,\n                                     'old_type': <class 'int'>}}}\n```\n\n----------------------------------------\n\nTITLE: Using Type Groups with DeepHash\nDESCRIPTION: Demonstrates how to use predefined type groups like strings and numbers or create custom type groups to ignore type differences between specified classes.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> ignore_type_in_groups = [DeepDiff.strings, DeepDiff.numbers]\n```\n\n----------------------------------------\n\nTITLE: Excluding Root Keys Using Shorthand in DeepDiff Python\nDESCRIPTION: Demonstrates a simplified syntax for excluding root-level keys with the `exclude_paths` parameter in `DeepDiff`. Instead of specifying the full path like `\"root['key']\"`, just the key name (e.g., `\"ingredients\"`) can be used. This shorthand applies whether passing a single path as a string or multiple paths in a list or set.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/exclude_paths.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {\"for life\": \"vegan\", \"ingredients\": [\"no meat\", \"no eggs\", \"no dairy\"]}\n>>> t2 = {\"for life\": \"vegan\", \"ingredients\": [\"veggies\", \"tofu\", \"soy sauce\"]}\n>>> print (DeepDiff(t1, t2, exclude_paths=\"ingredients\"))  # one item pass it as a string\n{}\n>>> print (DeepDiff(t1, t2, exclude_paths=[\"ingredients\", \"ingredients2\"]))  # multiple items pass as a list or a set.\n{}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Number-to-String Conversion in DeepDiff (Python)\nDESCRIPTION: Shows how to provide a custom function to the 'number_to_string_func' parameter in DeepDiff. This allows for specialized number preprocessing before comparison. The example function modifies numbers less than 100 before passing them to the default 'number_to_string' helper, changing the diff result.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from deepdiff.helper import number_to_string\n>>> def custom_number_to_string(number, *args, **kwargs):\n...     number = 100 if number < 100 else number\n...     return number_to_string(number, *args, **kwargs)\n...\n>>> t1 = [10, 12, 100000]\n>>> t2 = [50, 63, 100021]\n>>> DeepDiff(t1, t2, significant_digits=3, number_format_notation=\"e\")\n{'values_changed': {'root[0]': {'new_value': 50, 'old_value': 10}, 'root[1]': {'new_value': 63, 'old_value': 12}}}\n>>> \n>>> DeepDiff(t1, t2, significant_digits=3, number_format_notation=\"e\",\n...          number_to_string_func=custom_number_to_string)\n{}\n```\n\n----------------------------------------\n\nTITLE: Numeric Type Changes Ignored with String Values in DeepDiff in Python\nDESCRIPTION: This example clarifies that `ignore_numeric_type_changes=True` only applies to comparisons between numeric types. Comparing a numeric type (`Decimal`) with a string representation of a number still results in a `type_changes` report.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = Decimal('10.01')\n>>> t2 = \"10.01\"\n>>> \n>>> DeepDiff(t1, t2, ignore_numeric_type_changes=True)\n{'type_changes': {'root': {'old_type': <class 'decimal.Decimal'>, 'new_type': <class 'str'>, 'old_value': Decimal('10.01'), 'new_value': '10.01'}}}\n```\n\n----------------------------------------\n\nTITLE: DeepDiff Inaccuracy When Ignoring Encoding Errors on Similar Bytes (Python)\nDESCRIPTION: Illustrates a drawback of `ignore_encoding_errors=True`. When comparing byte strings that differ only by a character causing a decoding error, ignoring the error can lead DeepDiff to incorrectly identify the strings as equal, particularly when `ignore_order=True` relies on hashing.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/other.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\n```\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff([b\" cup of flour\"], [b\"\\xbc cup of flour\"], ignore_encoding_errors=True, ignore_order=True)\n```\n\n----------------------------------------\n\nTITLE: Using Delta with always_include_values parameter in Python\nDESCRIPTION: Demonstrates how setting always_include_values=True forces the Delta object to include the new values in the difference report, which is useful when you need to ensure the values are preserved.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndelta=Delta(diff, always_include_values=True)\ndelta.diff\n{'type_changes': {'root[1]': {'old_type': <class 'int'>, 'new_type': <class 'str'>, 'new_value': '2'}}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Iterables with DeepDiff and High Cutoff\nDESCRIPTION: This snippet illustrates how DeepDiff behaves with a `cutoff_intersection_for_pairs` of 0.7 (the default).  Again using lists `t1` and `t2`, the comparison now pairs items more closely due to the higher cutoff, producing a different set of results.  The key parameter is `cutoff_intersection_for_pairs`, influencing the granularity of item pairing during the comparison.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n>>> t1 = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> t2 = [5.0, 3.01, 1.2, 2.01, 4.0]\n>>>\n>>> DeepDiff(t1, t2, ignore_order=True, cutoff_intersection_for_pairs=0.7)\n{'values_changed': {'root[2]': {'new_value': 3.01, 'old_value': 3.0}, 'root[0]': {'new_value': 1.2, 'old_value': 1.0}, 'root[1]': {'new_value': 2.01, 'old_value': 2.0}}}\n```\n\n----------------------------------------\n\nTITLE: Comparing Iterables with DeepDiff\nDESCRIPTION: This code demonstrates the use of DeepDiff to compare two lists, `t1` and `t2`, with `ignore_order` set to `True` and `cutoff_intersection_for_pairs` set to 0.1.  The output reveals the differences between the lists, showcasing changes in values and items added or removed. The `cutoff_intersection_for_pairs` parameter affects how the items in the iterables are paired for comparison; a low value prevents detailed item-by-item comparisons.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n>>> t1 = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> t2 = [5.0, 3.01, 1.2, 2.01, 4.0]\n>>>\n>>> DeepDiff(t1, t2, ignore_order=True, cutoff_intersection_for_pairs=0.1)\n{'values_changed': {'root[1]': {'new_value': 3.01, 'old_value': 2.0}, 'root[2]': {'new_value': 1.2, 'old_value': 3.0}}, 'iterable_item_added': {'root[3]': 2.01}, 'iterable_item_removed': {'root[0]': 1.0}}\n```\n\n----------------------------------------\n\nTITLE: Cutoff Distance For Pairs Example\nDESCRIPTION: Shows how the cutoff_distance_for_pairs parameter affects which items are considered for pairing when using ignore_order=True, with a lower threshold making pairing more restrictive.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nt1 = [[1.0]]\nt2 = [[20.0]]\nDeepDiff(t1, t2, ignore_order=True, cutoff_distance_for_pairs=0.3)\nDeepDiff(t1, t2, ignore_order=True, cutoff_distance_for_pairs=0.1)\nDeepDiff(1.0, 20.0, get_deep_distance=True)\n```\n\n----------------------------------------\n\nTITLE: Using the bidirectional Parameter for Verification in Delta\nDESCRIPTION: Example of using the bidirectional parameter to verify that the object being modified has the expected original values. This helps ensure symmetry when applying deltas.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff, Delta\nt1 = [1]\nt2 = [2]\nt3 = [3]\n\ndiff = DeepDiff(t1, t2)\n\ndelta2 = Delta(diff, raise_errors=False, bidirectional=True)\nt4 = delta2 + t3\n# Expected the old value for root[0] to be 1 but it is 3. Error found on: while checking the symmetry of the delta.\nt4\n# [2]\n```\n\n----------------------------------------\n\nTITLE: Comparing Floats with Significant Digits using DeepDiff (Tree View)\nDESCRIPTION: This example demonstrates comparing floating-point numbers using DeepDiff with specified significant digits. It shows how DeepDiff can be used to ignore small differences in floats.  Requires `DeepDiff` to be imported.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = [ 1.1129, 1.3359 ]\n>>> t2 = [ 1.113, 1.3362 ]\n>>> ddiff = DeepDiff(t1, t2, significant_digits=3, view='tree')\n>>> ddiff\n{}\n>>> ddiff = DeepDiff(t1, t2, view='tree')\n>>> pprint(ddiff, indent=2)\n{ 'values_changed': [<root[0] t1:1.1129, t2:1.113>, <root[1] t1:1.3359, t2:1.3362>]}\n>>> ddiff = DeepDiff(1.23*10**20, 1.24*10**20, significant_digits=1, view='tree')\n>>> ddiff\n{'values_changed': [<root t1:1.23e+20, t2:1.24e+20>]}\n```\n\n----------------------------------------\n\nTITLE: Working with Delta and Numpy Arrays in Python\nDESCRIPTION: Demonstrates how to create a Delta object from differences between Numpy arrays and properly apply it. Note that Delta must be on the left side of the addition operator with Numpy arrays.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/delta.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff, Delta\nimport numpy as np\nt1 = np.array([1, 2, 3, 5])\nt2 = np.array([2, 2, 7, 5])\ndiff = DeepDiff(t1, t2)\ndiff\n# {'values_changed': {'root[0]': {'new_value': 2, 'old_value': 1}, 'root[2]': {'new_value': 7, 'old_value': 3}}}\ndelta = Delta(diff)\n\n# This won't work due to numpy's operator overriding\n# t1 + delta\n# Will raise DeltaNumpyOperatorOverrideError\n\n# Correct way to apply delta to numpy array\ndelta + t1\n# array([2, 2, 7, 5])\ndelta + t2 == t2\n# array([ True,  True,  True,  True])\n```\n\n----------------------------------------\n\nTITLE: Reporting Repetitions with report_repetition\nDESCRIPTION: Demonstrates how to detect and report changes in the number of repetitions of elements when using ignore_order=True with the report_repetition parameter.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import DeepDiff\nfrom pprint import pprint\nt1 = [1, 3, 1, 4]\nt2 = [4, 4, 1]\nddiff = DeepDiff(t1, t2, ignore_order=True, report_repetition=True)\npprint(ddiff, indent=2)\n```\n\n----------------------------------------\n\nTITLE: Retrieving DeepDiff Statistics Using get_stats() (Python)\nDESCRIPTION: This snippet demonstrates how to compute statistics on a diff object using the get_stats() method. It includes an example with two nested lists, applying ignore_order, cache size, and cutoff intersection options. The output shows various metrics like DIFF COUNT, PASSES COUNT, and cache hits, useful for analyzing diff performance and results.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/stats.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\npprint(diff.get_stats())\n```\n\n----------------------------------------\n\nTITLE: Comparing Named Tuples with Tree View in DeepDiff (Python)\nDESCRIPTION: Shows how DeepDiff's 'tree' view handles comparisons between `collections.namedtuple` instances. Differences in the named tuple's field values (e.g., 'y') are reported under 'values_changed', indicating the path using dot notation (`root.y`).\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> t1 = Point(x=11, y=22)\n>>> t2 = Point(x=11, y=23)\n>>> print(DeepDiff(t1, t2, view='tree'))\n{'values_changed': [<root.y t1:22, t2:23>]}\n```\n\n----------------------------------------\n\nTITLE: Using Scientific Notation for Significant Digits in DeepDiff (Python)\nDESCRIPTION: Demonstrates how to use the 'number_format_notation' parameter set to 'e' (exponent/scientific notation) in conjunction with 'significant_digits' in DeepDiff. This changes the comparison logic to consider significant digits within the scientific representation of numbers.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> DeepDiff(1024, 1020, significant_digits=2, number_format_notation=\"f\")  # default is \"f\"\n{'values_changed': {'root': {'new_value': 1020, 'old_value': 1024}}}\n>>> DeepDiff(1024, 1020, significant_digits=2, number_format_notation=\"e\")\n{}\n```\n\n----------------------------------------\n\nTITLE: Setting up Custom Object Comparison with Tree View (Python)\nDESCRIPTION: Provides the setup code for comparing custom Python class instances using DeepDiff, intended to be used with the 'tree' view. Defines a sample class `ClassA` with a class attribute `a` and an instance attribute `b`. The actual comparison using DeepDiff is not shown but implied.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> class ClassA(object):\n...     a = 1\n...     def __init__(self, b):\n...         self.b = b\n...\n```\n\n----------------------------------------\n\nTITLE: Installing Optimized Libraries for DeepDiff\nDESCRIPTION: Instructions for installing DeepDiff with the optimization extras package which includes orjson for improved JSON serialization performance.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/optimizations.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \"deepdiff[optimize]\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Frequency in DeepDiff (Python)\nDESCRIPTION: This snippet outlines how to set the log_frequency_in_sec parameter to control how often the DeepDiff process logs progress. A value of 0 disables logging, while higher values enable periodic logs. An example shows how to invoke DeepDiff with logging enabled every second, including the expected log output.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/stats.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff(t1, t2, log_frequency_in_sec=1)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Enum)\nDESCRIPTION: This snippet shows how `ignore_type_in_groups` can be used to ignore type changes between specific groups of types. By providing `[(Enum, str)]`, DeepDiff ignores the type difference between an Enum member and a string with the same value.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from enum import Enum\n>>> class MyEnum1(Enum):\n...     book = \"book\"\n...     cake = \"cake\"\n... \n>>> DeepDiff(\"book\", MyEnum1.book)\n{'type_changes': {'root': {'old_type': <class 'str'>, 'new_type': <enum 'MyEnum1'>, 'old_value': 'book', 'new_value': <MyEnum1.book: 'book'>}}}\n>>> DeepDiff(\"book\", MyEnum1.book, ignore_type_in_groups=[(Enum, str)])\n{}\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing DeepDiff Objects with jsonpickle in Python\nDESCRIPTION: Shows how to use `to_json_pickle()` and `from_json_pickle()` methods to serialize the entire DeepDiff object including all metadata using the jsonpickle library. This method preserves full object fidelity but is unsafe with untrusted input and requires installing jsonpickle package. Example illustrates creating a diff, serializing to JSON pickle string, deserializing back, and verifying equality of the original and restored objects.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/serialization.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1: 1, 2: 2, 3: 3}\n>>> t2 = {1: 1, 2: \"2\", 3: 3}\n>>> ddiff = DeepDiff(t1, t2)\n>>> jsoned = ddiff.to_json_pickle()\n>>> jsoned\n'{\"type_changes\": {\"root[2]\": {\"new_type\": {\"py/type\": \"builtins.str\"}, \"new_value\": \"2\", \"old_type\": {\"py/type\": \"builtins.int\"}, \"old_value\": 2}}}'\n>>> ddiff_new = DeepDiff.from_json_pickle(jsoned)\n>>> ddiff == ddiff_new\nTrue\n```\n\n----------------------------------------\n\nTITLE: Verbose DeepDiff with Custom Comparison and Verbose Output - Python\nDESCRIPTION: Building on the previous example, this snippet enables verbose diff output using verbose_level=2, providing additional detail about item movement and matching. Requires deepdiff and a user-defined comparison function as above. Helps in debugging which items are matched and how they are repositioned.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndiff_verbose = DeepDiff(t1, t2, iterable_compare_func=compare_func, verbose_level=2)\n# Includes keys like iterative_item_moved for visualizing item path changes\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Changes in Groups with DeepDiff in Python (Numbers List)\nDESCRIPTION: Similar to the dictionary example, this snippet shows using `ignore_type_in_groups=DeepDiff.numbers` to ignore type changes between `int` and `float` elements within a list, demonstrating its application to sequential data structures.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_types_or_values.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from pprint import pprint\n>>> t1 = [1, 2, 3]\n>>> t2 = [1.0, 2.0, 3.0]\n>>> ddiff = DeepDiff(t1, t2)\n>>> pprint(ddiff, indent=2)\n{ 'type_changes': { 'root[0]': { 'new_type': <class 'float'>,\n                                     'new_value': 1.0,\n                                     'old_type': <class 'int'>,\n                                     'old_value': 1},\n                        'root[1]': { 'new_type': <class 'float'>,\n                                     'new_value': 2.0,\n                                     'old_type': <class 'int'>,\n                                     'old_value': 2},\n                        'root[2]': { 'new_type': <class 'float'>,\n                                     'new_value': 3.0,\n                                     'old_type': <class 'int'>,\n                                     'old_value': 3}}}\n>>> ddiff = DeepDiff(t1, t2, ignore_type_in_groups=DeepDiff.numbers)\n>>> pprint(ddiff, indent=2)\n{}\n```\n\n----------------------------------------\n\nTITLE: Adding a Prefix to DeepDiff's pretty() Output\nDESCRIPTION: This example demonstrates how to add a prefix to each line of the output generated by DeepDiff's `pretty()` method. This is particularly useful for logging.  It requires the `DeepDiff` class to be imported from the `deepdiff` module.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/view.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> t1={1,2,4}\n>>> t2={2,3}\n>>> print(DeepDiff(t1, t2).pretty(prefix='Diff: '))\nDiff: Item root[3] added to set.\nDiff: Item root[4] removed from set.\nDiff: Item root[1] removed from set.\n```\n\n----------------------------------------\n\nTITLE: Implementing a Pattern and Type Matcher for DeepDiff in Python\nDESCRIPTION: This class provides methods to initialize pattern and type matching criteria, and determine if a level in the object hierarchy matches these criteria. Dependencies include 're' for regex operations and Optional, List, type for type annotations. The match method returns True if the level's path matches any regex pattern or if the types of objects being compared belong to specified types. The give_up_diffing method is a placeholder for subclasses to implement custom diff logic.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/custom.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef __init__(self, regex_paths:Optional[List[str]]=None, types:Optional[List[type]]=None):\n            if regex_paths:\n                self.regex_paths = convert_item_or_items_into_compiled_regexes_else_none(regex_paths)\n            else:\n                self.regex_paths = None\n            self.types = types\n\n        def match(self, level) -> bool:\n            if self.regex_paths:\n                for pattern in self.regex_paths:\n                    matched = re.search(pattern, level.path()) is not None\n                    if matched:\n                        return True\n            if self.types:\n                for type_ in self.types:\n                    if isinstance(level.t1, type_) and isinstance(level.t2, type_):\n                        return True\n            return False\n\n        def give_up_diffing(self, level, diff_instance) -> bool:\n            raise NotImplementedError('Please implement the diff function.')\n```\n\n----------------------------------------\n\nTITLE: Numeric Type Handling in DeepHash\nDESCRIPTION: Shows how numeric types like int and float are handled the same by default, producing identical hashes for equivalent values.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> t1 = {1: 1, 2: 2.22}\n>>> t2 = {1: 1.0, 2: 2.22}\n>>> DeepHash(t1)[1]\n231678797214551245419120414857003063149\n>>> DeepHash(t1)[1.0]\n231678797214551245419120414857003063149\n```\n\n----------------------------------------\n\nTITLE: Comparing CSV Files with deep diff Command Line\nDESCRIPTION: Shows how to compare two CSV files (`t1.csv` and `t2.csv`) using the `deep diff` command. The examples demonstrate ignoring item order (`--ignore-order`) and grouping items by a specific column (`--group-by last_name`) for clearer output paths.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ deep diff t1.csv t2.csv --ignore-order\n{'values_changed': {\"root[2]['zip']\": {'new_value': 90002, 'old_value': 90001}}}\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ deep diff t1.csv t2.csv --ignore-order --group-by last_name\n{ 'values_changed': { \"root['Molotov']['zip']\": { 'new_value': 90002,\n                                                      'old_value': 90001}}}\n```\n\n----------------------------------------\n\nTITLE: Specifying Sphinx Documentation Dependencies for DeepDiff\nDESCRIPTION: Lists the required Python packages for building DeepDiff documentation. It specifies Sphinx 6.2.1 (with a note about HTML style compatibility), sphinx-sitemap 2.6.0, and sphinxemoji 0.3.1.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/requirements-docs.txt#_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\nSphinx==6.2.1 # We use the html style that is not supported in Sphinx 7 anymore.\nsphinx-sitemap==2.6.0\nsphinxemoji==0.3.1\n```\n\n----------------------------------------\n\nTITLE: Example YAML File After Patching\nDESCRIPTION: Displays the content of the sample YAML file (`another.yaml`) after the patch has been applied by the `deep patch` command. Shows the updated 'zip' value and notes potential reformatting.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- first_name: Joe\n  last_name: Nobody\n  zip: 90011\n- first_name: Jack\n  last_name: Doit\n  zip: 22222\n- first_name: Sara\n  last_name: Stanley\n  zip: 90002\n```\n\n----------------------------------------\n\nTITLE: String Type Handling with ignore_string_type_changes\nDESCRIPTION: Demonstrates that string and bytes representations of the same content can produce the same hash when ignore_string_type_changes is enabled.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> DeepHash(b'hello', ignore_string_type_changes=True)\n{b'hello': 221860156526691709602818861774599422448}\n>>> DeepHash('hello', ignore_string_type_changes=True)\n{'hello': 221860156526691709602818861774599422448}\n```\n\n----------------------------------------\n\nTITLE: Getting Help for deep diff Command Line\nDESCRIPTION: Demonstrates how to access the help documentation and list available options for the `deep diff` command using the command line.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ deep diff\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ deep diff --help\nUsage: deep diff [OPTIONS] T1 T2\n\n  Deep Diff Commandline\n\n  Deep Difference of content in files.\n  It can read csv, tsv, json, yaml, and toml files.\n\n  T1 and T2 are the path to the files to be compared with each other.\n\nOptions:\n  --cutoff-distance-for-pairs FLOAT\n                                  [default: 0.3]\n  --cutoff-intersection-for-pairs FLOAT\n                                  [default: 0.7]\n  --cache-size INTEGER            [default: 0]\n  --cache-tuning-sample-size INTEGER\n                                  [default: 0]\n  --cache-purge-level INTEGER RANGE\n                                  [default: 1]\n  --create-patch                  [default: False]\n  --exclude-paths TEXT\n  --exclude-regex-paths TEXT\n  --math-epsilon DECIMAL\n  --get-deep-distance             [default: False]\n  --group-by TEXT\n  --ignore-order                  [default: False]\n  --ignore-string-type-changes    [default: False]\n  --ignore-numeric-type-changes   [default: False]\n  --ignore-type-subclasses        [default: False]\n  --ignore-string-case            [default: False]\n  --ignore-nan-inequality         [default: False]\n  --include-private-variables     [default: False]\n  log-frequency-in-sec INTEGER  [default: 0]\n  --max-passes INTEGER            [default: 10000000]\n  --max_diffs INTEGER\n  --number-format-notation [f|e]  [default: f]\n  --progress-logger [info|error]  [default: info]\n  --report-repetition             [default: False]\n  --significant-digits INTEGER\n  --truncate-datetime [second|minute|hour|day]\n  --verbose-level INTEGER RANGE   [default: 1]\n  --help                          Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Parsing DeepDiff Result Paths with parse_path Python\nDESCRIPTION: This snippet demonstrates how to use the `parse_path` function to convert the string representation of a DeepDiff path into a Python list of elements. It also shows how to include action types (`GET`, `GETATTR`) in the parsed output.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/faq.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom deepdiff import parse_path\nparse_path(\"root[1][2]['age']\")\nparse_path(\"root[1][2]['age']\", include_actions=True)\n\nparse_path(\"root['joe'].age\")\nparse_path(\"root['joe'].age\", include_actions=True)\n```\n\n----------------------------------------\n\nTITLE: Datetime Comparison - Python\nDESCRIPTION: This snippet illustrates how `DeepDiff` handles datetime objects. It emphasizes that `DeepDiff` converts all datetimes to UTC and it does not assume a timezone-naive datetime is in the local timezone.  It shows comparison of two datetime objects, one naive and one with UTC timezone.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> from datetime import datetime, timezone\n>>> d1 = datetime(2020, 8, 31, 13, 14, 1)\n>>> d2 = datetime(2020, 8, 31, 13, 14, 1, tzinfo=timezone.utc)\n>>> d1 == d2\nFalse\n>>> DeepDiff(d1, d2)\n{}\n```\n\n----------------------------------------\n\nTITLE: Ignoring String Type Changes in DeepHash\nDESCRIPTION: Shows how to ignore differences between string types (str vs bytes) when calculating hashes by setting the ignore_string_type_changes parameter.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/deephash_doc.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> obj3 = {1: 2, b'a': b'b'}\n>>> DeepHash(obj3)[obj3]\n64067525765846024488103933101621212760\n\n>>> DeepHash(obj3, ignore_string_type_changes=True)[obj3]\n34150898645750099477987229399128149852\n```\n\n----------------------------------------\n\nTITLE: Achieving Accuracy with DeepDiff encodings on Similar Bytes (Python)\nDESCRIPTION: Contrasts the effect of `ignore_encoding_errors=True` by showing that providing the correct `encodings` list allows DeepDiff to accurately detect differences between byte strings, even when the difference is a character that might otherwise cause a decoding error and be ignored.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/other.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom deepdiff import DeepDiff\n```\n\nLANGUAGE: Python\nCODE:\n```\nDeepDiff([b\" cup of flour\"], [b\"\\xbc cup of flour\"], encodings=['latin-1'], ignore_order=True)\n```\n\n----------------------------------------\n\nTITLE: DeepDiff Command Line Help\nDESCRIPTION: This demonstrates using the `deep diff` command-line tool to display help information. It utilizes the `--help` flag. This functionality is part of the 'deepdiff[cli]' installation, described earlier.  No specific input is needed; output is the help information.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ deep diff --help\n```\n\n----------------------------------------\n\nTITLE: Max Passes Parameter for Performance Control\nDESCRIPTION: Demonstrates how the max_passes parameter affects the granularity of difference detection when using ignore_order=True, with higher values providing more precise results at the cost of performance.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/ignore_order.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\nfrom deepdiff import DeepDiff\n\nt1 = [\n    {\n        'key3': [[[[[1, 2, 4, 5]]]]],\n        'key4': [7, 8],\n    },\n    {\n        'key5': 'val5',\n        'key6': 'val6',\n    },\n]\n\nt2 = [\n    {\n        'key5': 'CHANGE',\n        'key6': 'val6',\n    },\n    {\n        'key3': [[[[[1, 3, 5, 4]]]]],\n        'key4': [7, 8],\n    },\n]\n\nfor max_passes in (1, 2, 62, 65):\n    diff = DeepDiff(t1, t2, ignore_order=True, max_passes=max_passes, verbose_level=2)\n    print('-\\n----- Max Passes = {} -----'.format(max_passes))\n    pprint(diff)\n```\n\n----------------------------------------\n\nTITLE: Controlling Type Sensitivity in DeepDiff Grep Searches in Python\nDESCRIPTION: Shows how to alter strict type checking for matching using the 'strict_checking' parameter. When False, numeric values can match substrings in strings and vice versa. The example compares default behavior (strict_checking=True), which returns no matches when searching for substring '1234' in number 1123456, versus when strict_checking is disabled, which finds the match.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/search_doc.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> obj = {\"long\": \"somewhere\", \"num\": 1123456, 0: 0, \"somewhere\": \"around\"}\n>>> item = \"1234\"\n>>> result = {\"matched_values\": {\"root['num']\"}}\n>>> ds = obj | grep(item, verbose_level=1, use_regexp=True)\n>>> pprint(ds)\n{}\n>>>\n>>> ds = obj | grep(item, verbose_level=1, use_regexp=True, strict_checking=False)\n>>> pprint(ds)\n{'matched_values': [\"root['num']\"]}\n```\n\n----------------------------------------\n\nTITLE: Install DeepDiff CLI with pip\nDESCRIPTION: This snippet describes installing DeepDiff with the command-line interface using pip. It adds the '[cli]' extra to the install command, enabling access to DeepDiff's command-line tools such as 'deep diff', 'deep patch', 'deep grep', and 'deep extract'. Requires the basic DeepDiff installation and pip.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install \"deepdiff[cli]\"\n```\n\n----------------------------------------\n\nTITLE: Install DeepDiff Optimization Dependencies\nDESCRIPTION: This snippet outlines installing extra dependencies with pip to optimize DeepDiff's performance, such as for json serialization. It specifies the '[optimize]' extra. This is optional and requires pip.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install \"deepdiff[optimize]\"\n```\n\n----------------------------------------\n\nTITLE: Getting Help for deep patch Command Line\nDESCRIPTION: Demonstrates how to access the help documentation and list available options for the `deep patch` command using the command line.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ deep patch --help\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ deep patch --help\nUsage: deep patch [OPTIONS] PATH DELTA_PATH\n\n  Deep Patch Commandline\n\n  Patches a file based on the information in a delta file. The delta file\n  can be created by the deep diff command and passing the --create-patch\n  argument.\n\n  Deep Patch is similar to Linux's patch command. The difference is that it\n  is made for patching data. It can read csv, tsv, json, yaml, and toml\n  files.\n\nOptions:\n  -b, --backup    [default: False]\n  --raise-errors  [default: False]\n  --help          Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Delta Command Line Help\nDESCRIPTION: This demonstrates the command-line help functionality for the `deep patch` tool. It uses the `--help` flag. This command becomes available upon installing 'deepdiff[cli]'.  No input required; output is the help information.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/index.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ deep patch --help\n```\n\n----------------------------------------\n\nTITLE: Ignoring NaN Inequality in DeepDiff (Python)\nDESCRIPTION: Illustrates the effect of the 'ignore_nan_inequality' parameter in DeepDiff. By default, comparing float('nan') to itself results in a difference because nan != nan in standard Python (cPython). Setting 'ignore_nan_inequality=True' makes DeepDiff treat NaN values as equal.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/numbers.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from deepdiff import DeepDiff\n>>> float('nan') == float('nan')\nFalse\n>>> DeepDiff(float('nan'), float('nan'))\n{'values_changed': {'root': {'new_value': nan, 'old_value': nan}}}\n>>> DeepDiff(float('nan'), float('nan'), ignore_nan_inequality=True)\n{}\n```\n\n----------------------------------------\n\nTITLE: Getting Help for deep grep Command Line\nDESCRIPTION: Demonstrates how to access the help documentation and list available options for the `deep grep` command using the command line.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/commandline.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ deep grep\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ deep grep --help\nUsage: deep grep [OPTIONS] ITEM PATH\n\n  Deep Grep Commandline\n\n  Grep through the contents of a file and find the path to the item.\n  It can read csv, tsv, json, yaml, and toml files.\n\nOptions:\n  -i, --ignore-case              [default: False]\n  --exact-match                  [default: False]\n  --exclude-paths TEXT\n  --exclude-regex-paths TEXT\n  --verbose-level INTEGER RANGE  [default: 1]\n  --help                         Show this message and exit.\n```\n\n----------------------------------------\n\nTITLE: Output of Grouping a List of Dictionaries by Key (Python)\nDESCRIPTION: Shows the expected output dictionary format after grouping a list of input dictionaries based on the value of the 'id' key. Each key in the output dictionary corresponds to a unique 'id' value, and its value is a list of the original dictionaries sharing that 'id'.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/docs/basics.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> {'AA': [{'int_id': 2, 'last_name': 'Nobody', 'name': 'Joe'}],\n...  'BB': [{'int_id': 20, 'last_name': 'Blue', 'name': 'James'},\n...         {'int_id': 3, 'last_name': 'Red', 'name': 'Jimmy'}],\n...  'CC': [{'int_id': 4, 'last_name': 'Apple', 'name': 'Mike'}]}\n```\n\n----------------------------------------\n\nTITLE: Listing Python Dependencies\nDESCRIPTION: This snippet defines a project's dependencies using pip format, specifying package names and versions. The `click` and `pyyaml` libraries are required for the project.  The `==` operator indicates the exact version required for each package. The output lists the package and version, which will be used by a package manager, like pip, to resolve and install the specified dependencies.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/requirements-cli.txt#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclick==8.1.8\npyyaml==6.0.2\n```\n\n----------------------------------------\n\nTITLE: Specifying Version Constraint for orderly-set Package\nDESCRIPTION: Defines a version requirement for the orderly-set package, specifying that it must be at least version 5.3.0 but less than version 6.0.0. This ensures compatibility with the DeepDiff package.\nSOURCE: https://github.com/seperman/deepdiff/blob/master/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\norderly-set>=5.3.0,<6\n```"
  }
]