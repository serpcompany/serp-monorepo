[
  {
    "owner": "anza-xyz",
    "repo": "kit",
    "content": "TITLE: Airdropping SOL using airdropFactory in TypeScript\nDESCRIPTION: Demonstrates how to use the airdropFactory function to create an airdrop function for sending SOL to a Solana address on a test network.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, airdropFactory, createSolanaRpc, createSolanaRpcSubscriptions, devnet, lamports } from '@solana/kit';\n\nconst rpc = createSolanaRpc(devnet('http://127.0.0.1:8899'));\nconst rpcSubscriptions = createSolanaRpcSubscriptions(devnet('ws://127.0.0.1:8900'));\n\nconst airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\nawait airdrop({\n    commitment: 'confirmed',\n    recipientAddress: address('FnHyam9w4NZoWR6mKN1CuGBritdsEWZQa4Z4oawLZGxa'),\n    lamports: lamports(10_000_000n),\n});\n```\n\n----------------------------------------\n\nTITLE: Fully Signing Transactions with Embedded Signers\nDESCRIPTION: Demonstrates how to sign a transaction message with its embedded signers and ensure it's fully signed before returning, throwing an error if not all signatures are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n\n// With additional config.\nconst mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n    abortSignal: myAbortController.signal,\n});\n\n// We now know the transaction is fully signed.\nmySignedTransaction satisfies IFullySignedTransaction;\n```\n\n----------------------------------------\n\nTITLE: Fetching, Asserting, and Decoding Solana Accounts in TypeScript\nDESCRIPTION: Demonstrates how to fetch an encoded account, assert its existence, and decode it using a custom decoder. It showcases the usage of MaybeEncodedAccount, EncodedAccount, and Account types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch.\nconst myAddress = address('1234..5678');\nconst myAccount = await fetchEncodedAccount(rpc, myAddress);\nmyAccount satisfies MaybeEncodedAccount<'1234..5678'>;\n\n// Assert.\nassertAccountExists(myAccount);\nmyAccount satisfies EncodedAccount<'1234..5678'>;\n\n// Decode.\ntype MyAccountData = { name: string; age: number };\nconst myDecoder: Decoder<MyAccountData> = getStructDecoder([\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['age', getU32Decoder()],\n]);\nconst myDecodedAccount = decodeAccount(myAccount, myDecoder);\nmyDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n```\n\n----------------------------------------\n\nTITLE: Creating Separate Encoders and Decoders for Custom Types in TypeScript\nDESCRIPTION: This snippet shows how to create separate encoder and decoder functions for a custom type using Solana's codec libraries. It demonstrates how to create encoder, decoder, and combined codec functions for a custom token type with amount, decimals, and name fields.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Codec, combineCodec, Decoder, Encoder, addDecoderSizePrefix, addEncoderSizePrefix } from '@solana/codecs-core';\nimport { getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport {\n    getU8Decoder,\n    getU8Encoder,\n    getU32Decoder,\n    getU32Encoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs-numbers';\nimport { getUtf8Decoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport type MyToken = {\n    amount: bigint;\n    decimals: number;\n    name: string;\n};\n\nexport type MyTokenArgs = {\n    amount: number | bigint;\n    decimals: number;\n    name: string;\n};\n\nexport const getMyTokenEncoder = (): Encoder<MyTokenArgs> =>\n    getStructEncoder([\n        ['amount', getU64Encoder()],\n        ['decimals', getU8Encoder()],\n        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]);\n\nexport const getMyTokenDecoder = (): Decoder<MyToken> =>\n    getStructDecoder([\n        ['amount', getU64Decoder()],\n        ['decimals', getU8Decoder()],\n        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ]);\n\nexport const getMyTokenCodec = (): Codec<MyTokenArgs, MyToken> =>\n    combineCodec(getMyTokenEncoder(), getMyTokenDecoder());\n```\n\n----------------------------------------\n\nTITLE: Creating NoopSigner with createNoopSigner() Function\nDESCRIPTION: Shows how to create a Noop signer from an address and use it to sign messages and transactions, resulting in empty signature dictionaries.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNoopSigner } from '@solana/signers';\n\nconst myNoopSigner = createNoopSigner(address('1234..5678'));\nconst [myMessageSignatures] = await myNoopSigner.signMessages([myMessage]); // <- Empty signature dictionary.\nconst [myTransactionSignatures] = await myNoopSigner.signTransactions([myTransaction]); // <- Empty signature dictionary.\n```\n\n----------------------------------------\n\nTITLE: Defining KeyPairSigner Interface in TypeScript\nDESCRIPTION: This code snippet defines the `KeyPairSigner` and demonstrates how to generate and use one. It implements both the `MessagePartialSigner` and `TransactionPartialSigner` interfaces and keeps track of the `CryptoKeyPair` instance used to sign messages and transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPairSigner } from '@solana/signers';\n\nconst myKeyPairSigner = generateKeyPairSigner();\nmyKeyPairSigner.address; // Address;\nmyKeyPairSigner.keyPair; // CryptoKeyPair;\nconst [myMessageSignatures] = await myKeyPairSigner.signMessages([myMessage]);\nconst [myTransactionSignatures] = await myKeyPairSigner.signTransactions([myTransaction]);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Compute Unit Limit Estimation in createClient Function\nDESCRIPTION: This snippet shows the implementation of the estimateAndSetComputeUnitLimit function in the createClient method. It uses functions from @solana/kit and @solana-program/compute-budget to estimate and set the compute unit limit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getComputeUnitEstimateForTransactionMessageFactory, // [!code ++]\n  prependTransactionMessageInstruction, // [!code ++]\n  // ...\n} from \"@solana/kit\";\nimport { getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\"; // [!code ++]\n\nlet client: Client | undefined;\nexport async function createClient(): Promise<Client> {\n  if (!client) {\n    // ...\n\n    // Create a function to estimate and set the compute unit limit. // [!code ++]\n    const estimateComputeUnitLimit = getComputeUnitEstimateForTransactionMessageFactory({ rpc }); // [!code ++]\n    const estimateAndSetComputeUnitLimit = async <T extends CompilableTransactionMessage>(transactionMessage: T) => {\n      // [!code ++]\n      const computeUnitsEstimate = await estimateComputeUnitLimit(transactionMessage); // [!code ++]\n      return prependTransactionMessageInstruction(\n        // [!code ++]\n        getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }), // [!code ++]\n        transactionMessage, // [!code ++]\n      ); // [!code ++]\n    }; // [!code ++]\n\n    // Store the client.\n    client = { estimateAndSetComputeUnitLimit, rpc, rpcSubscriptions, wallet };\n  }\n  return client;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Mint Transaction with Solana SDK in TypeScript\nDESCRIPTION: This code snippet defines the `createMint` function, which is responsible for creating a new mint transaction on the Solana blockchain. The function utilizes multiple Solana SDK functions to generate key pairs, build transaction messages, and compile signed transactions. Dependencies include the Solana SDK components like `Rpc`, `TransactionSigner`, `MessageSigner`, and custom instruction builders from `@solana-program/system` and `@solana-program/token`. Key parameters include `client` for accessing RPC methods and `options` for specifying mint attributes, while the main output is a signed transaction ready to be sent for confirmation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n\nimport {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  generateKeyPairSigner,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getInitializeMintInstruction, getMintSize, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(client: Client, options: { decimals?: number } = {}) {\n  // Prepare inputs.\n  const mintSize = getMintSize();\n  const [mint, mintRent, { value: latestBlockhash }] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n    client.rpc.getLatestBlockhash().send(),\n  ]);\n\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n  const initializeMintIx = getInitializeMintInstruction({\n    mint: mint.address,\n    decimals: options.decimals ?? 0,\n    mintAuthority: client.wallet.address,\n    freezeAuthority: client.wallet.address,\n  });\n\n  // Build the transaction message.\n  const transactionMessage = await pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n    (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    (tx) => appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n    (tx) => client.estimateAndSetComputeUnitLimit(tx),\n  );\n\n  // Compile the transaction message and sign it.\n  const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n\n  // Send the transaction and wait for confirmation.\n  // TODO: Next article!\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Compute Unit Limit and Price in Solana Transactions using TypeScript\nDESCRIPTION: This snippet demonstrates how to use the @solana-program/compute-budget library to set the compute unit limit and price for a Solana transaction. It uses getSetComputeUnitLimitInstruction to set a limit of 50,000 CUs and getSetComputeUnitPriceInstruction to set a price of 10,000 micro-lamports per CU as priority fees.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/instructions.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\n\nconst setComputeLimitIx = getSetComputeUnitLimitInstruction({\n  units: 50_000, // 50k CUs per transaction.\n});\nconst setComputePriceIx = getSetComputeUnitPriceInstruction({\n  microLamports: 10_000, // 10k micro-lamports per CU, as priority fees.\n});\n```\n\n----------------------------------------\n\nTITLE: Generating and Using Solana Key Pair Signer\nDESCRIPTION: Demonstrates creating a key pair signer and using it to sign messages and transactions in Solana\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from '@solana/functional';\nimport { generateKeyPairSigner } from '@solana/signers';\nimport { createTransactionMessage } from '@solana/transaction-messages';\nimport { compileTransaction } from '@solana/transactions';\n\n// Generate a key pair signer.\nconst mySigner = await generateKeyPairSigner();\nmySigner.address; // Address;\n\n// Sign one or multiple messages.\nconst myMessage = createSignableMessage('Hello world!');\nconst [messageSignatures] = await mySigner.signMessages([myMessage]);\n\n// Sign one or multiple transaction messages.\nconst myTransactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    // Add instructions, fee payer, lifetime, etc.\n);\nconst myTransaction = compileTransaction(myTransactionMessage);\nconst [transactionSignatures] = await mySigner.signTransactions([myTransaction]);\n```\n\n----------------------------------------\n\nTITLE: Configuring Array Size Strategies with getArrayCodec\nDESCRIPTION: Demonstrates the three different strategies for handling array sizes in getArrayCodec: using a custom number codec, using a fixed size, or inferring size from remaining bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_66\n\nLANGUAGE: typescript\nCODE:\n```\ngetArrayCodec(getU8Codec(), { size: getU16Codec() }).encode([1, 2, 3]);\n// 0x0300010203\n//   |   └-- 3 items of 1 byte each.\n//   └-- 2-byte prefix telling us to read 3 items.\n\ngetArrayCodec(getU8Codec(), { size: 3 }).encode([1, 2, 3]);\n// 0x010203\n//   └-- 3 items of 1 byte each. There must always be 3 items in the array.\n\ngetArrayCodec(getU8Codec(), { size: \"remainder\" }).encode([1, 2, 3]);\n// 0x010203\n//   └-- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n```\n\n----------------------------------------\n\nTITLE: Managing Solana RPC Subscriptions TypeScript\nDESCRIPTION: This snippet introduces setting up and managing Solana RPC subscriptions using WebSockets in TypeScript. It uses the createSolanaRpcSubscriptions function to establish a client that handles RPC notifications via a WebSocket connection. Dependencies include configuring WebSocket URLs and handling JSON RPC notifications specific to Solana.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\nimport { createSolanaRpcSubscriptions } from '@solana/kit';\n\n// Create an RPC Subscriptions client.\nconst rpcSubscriptions = createSolanaRpcSubscriptions('ws://127.0.0.1:8900');\n//    ^? RpcSubscriptions<SolanaRpcSubscriptionsApi>\n```\n\n----------------------------------------\n\nTITLE: Defining Option Type in TypeScript\nDESCRIPTION: Defines the Option<T> union type, which consists of Some<T> and None types, similar to Rust's Option<T>.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Option<T> = Some<T> | None;\ntype Some<T> = { __option: 'Some'; value: T };\ntype None = { __option: 'None' };\n```\n\n----------------------------------------\n\nTITLE: Getting Address from Public Key with getAddressFromPublicKey() in TypeScript\nDESCRIPTION: Illustrates how to obtain the associated Address from a given public CryptoKey using the getAddressFromPublicKey() function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAddressFromPublicKey } from '@solana/addresses';\n\nconst address = await getAddressFromPublicKey(publicKey);\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding a Person Object with Composable Codecs in TypeScript\nDESCRIPTION: Demonstrates how to use composable codecs to build, encode, and decode a Person type with name and age fields. Shows the basic pattern of defining a type, creating a codec for it, and using the encode/decode methods.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Use composable codecs to build complex data structures.\ntype Person = { name: string; age: number };\nconst getPersonCodec = (): Codec<Person> =>\n  getStructCodec([\n    [\"name\", addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n    [\"age\", getU32Codec()],\n  ]);\n\n// Use your own codecs to encode and decode data.\nconst personCodec = getPersonCodec();\nconst encodedPerson = personCodec.encode({ name: \"John\", age: 42 });\nconst decodedPerson = personCodec.decode(encodedPerson);\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions in TypeScript\nDESCRIPTION: Demonstrates how to use sendAndConfirmTransactionFactory to send a blockhash-based transaction and wait for confirmation, including error handling for expired blockhashes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSolanaError, sendAndConfirmTransactionFactory, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED } from '@solana/kit';\n\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n\ntry {\n    await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n        console.error('This transaction depends on a blockhash that has expired');\n    } else {\n        throw e;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Encoded Accounts using Kit Helpers in TypeScript\nDESCRIPTION: Shows how to use fetchEncodedAccount and fetchEncodedAccounts helpers from @solana/kit to fetch Solana accounts in a unified format.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, fetchEncodedAccount, fetchEncodedAccounts, MaybeEncodedAccount } from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nconst accounts = await fetchEncodedAccounts(rpc, [address(\"1234..5678\")]);\n\naccount satisfies MaybeEncodedAccount;\naccounts satisfies MaybeEncodedAccount[];\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Fee Payer\nDESCRIPTION: Shows how to set a fee payer for a transaction using a base58-encoded address\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from '@solana/addresses';\nimport { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n\nconst myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\nconst txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n```\n\n----------------------------------------\n\nTITLE: Using Cluster-Specific RPC Types in TypeScript\nDESCRIPTION: Example demonstrating how to create functions that enforce specific RPC cluster types at compile time. This prevents calling methods that may not be available on certain clusters, like using a mainnet-specific address with devnet.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getSpecialAccountInfo(\n    address: Address<'ReAL1111111111111111111111111111'>,\n    rpc: RpcMainnet<unknown>,\n): Promise<SpecialAccountInfo>;\nasync function getSpecialAccountInfo(\n    address: Address<'TeST1111111111111111111111111111'>,\n    rpc: RpcDevnet<unknown> | RpcTestnet<unknown>,\n): Promise<SpecialAccountInfo>;\nasync function getSpecialAccountInfo(address: Address, rpc: Rpc<unknown>): Promise<SpecialAccountInfo> {\n    /* ... */\n}\nconst rpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\nawait getSpecialAccountInfo(address('ReAL1111111111111111111111111111'), rpc); // ERROR\n```\n\n----------------------------------------\n\nTITLE: Encoding Addresses to Bytes with getAddressEncoder() in TypeScript\nDESCRIPTION: Demonstrates the use of getAddressEncoder() to convert a base58-encoded Solana address string into its byte array representation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAddressEncoder } from '@solana/addresses';\n\nconst address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\nconst addressEncoder = getAddressEncoder();\nconst addressBytes = addressEncoder.encode(address);\n// Uint8Array(32) [\n//   150, 183, 190,  48, 171,   8, 39, 156,\n//   122, 213, 172, 108, 193,  95, 26, 158,\n//   149, 243, 115, 254,  20, 200, 36,  30,\n//   248, 179, 178, 232, 220,  89, 53, 127\n// ]\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding a Person Object using Composable Codecs in TypeScript\nDESCRIPTION: This snippet demonstrates how to use composable codecs to define a Person type, create a codec for it, and then encode and decode a Person object.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Use composable codecs to build complex data structures.\ntype Person = { name: string; age: number };\nconst getPersonCodec = (): Codec<Person> =>\n    getStructCodec([\n        ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n        ['age', getU32Codec()],\n    ]);\n\n// Use your own codecs to encode and decode data.\nconst person = { name: 'John', age: 42 };\nconst personCodec = getPersonCodec();\nconst encodedPerson: Uint8Array = personCodec.encode(person);\nconst decodedPerson: Person = personCodec.decode(encodedPerson);\n```\n\n----------------------------------------\n\nTITLE: Using isProgramError() to Identify Custom Program Errors in Solana\nDESCRIPTION: Example demonstrating how to use the isProgramError() function to catch and handle custom program errors from a Solana program. The function allows checking for specific error codes or any error from a particular program address.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/programs/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n    // Send and confirm your transaction.\n} catch (error) {\n    if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n        // Handle custom program error 42 from this program.\n    } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n        // Handle all other custom program errors from this program.\n    } else {\n        throw error;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a tutorial function to fetch Solana account balance\nDESCRIPTION: TypeScript code demonstrating how to use the Client object to fetch the balance of a specific Solana account using @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/setup.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from \"@solana/kit\";\nimport { createClient } from \"./client\";\n\n// Run the tutorial.\ntutorial();\n\nasync function tutorial() {\n  const client = createClient();\n  const account = address(\"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\");\n  const { value: balance } = await client.rpc.getBalance(account).send();\n  console.log(`Balance: ${balance} lamports.`);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Transaction with Kit\nDESCRIPTION: In this snippet, the Kit framework is used to build a transaction. It demonstrates how to utilize various helper functions to set up the transaction, efficiently chaining them with the pipe function for enhanced maintainability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getInitializeMintInstruction } from \"@solana-program/token\";\n// ---cut-start---\nimport { createSolanaRpc, TransactionSigner } from \"@solana/kit\";\nconst rpc = createSolanaRpc(\"https://api.devnet.solana.com\");\nconst payer = null as unknown as TransactionSigner;\nconst createAccountInput = null as unknown as Parameters<typeof getCreateAccountInstruction>[0];\nconst initializeMintInput = null as unknown as Parameters<typeof getInitializeMintInstruction>[0];\n// ---cut-end---\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\nconst createAccount = getCreateAccountInstruction(createAccountInput);\nconst initializeMint = getInitializeMintInstruction(initializeMintInput);\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(payer, tx),\n  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) => appendTransactionMessageInstructions([createAccount, initializeMint], tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Durable Nonce Transactions in TypeScript\nDESCRIPTION: Shows how to use sendAndConfirmDurableNonceTransactionFactory to send a nonce-based transaction and wait for confirmation, with error handling for invalid nonces and non-existent nonce accounts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    isSolanaError,\n    sendAndConfirmDurableNonceTransactionFactory,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n} from '@solana/kit';\n\nconst sendAndConfirmNonceTransaction = sendAndConfirmDurableNonceTransactionFactory({ rpc, rpcSubscriptions });\n\ntry {\n    await sendAndConfirmNonceTransaction(transaction, { commitment: 'confirmed' });\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n        console.error(\n            'The lifetime specified by this transaction refers to a nonce account ' +\n                `\\`${e.context.nonceAccountAddress}\\` that does not exist`,\n        );\n    } else if (isSolanaError(e, SOLANA_ERROR__INVALID_NONCE)) {\n        console.error('This transaction depends on a nonce that is no longer valid');\n    } else {\n        throw e;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Transaction Signature and Confirming the Transaction\nDESCRIPTION: Shows how to get a transaction signature using getSignatureFromTransaction before sending the transaction, then sending and confirming it.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSignatureFromTransaction, sendAndConfirmTransactionFactory } from \"@solana/kit\";\n\n// Access the transaction signature.\nconst signature = getSignatureFromTransaction(signedTransaction);\n\n// Send and confirm the transaction.\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\nawait sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n```\n\n----------------------------------------\n\nTITLE: Creating Version-Aware Transaction Messages in Solana\nDESCRIPTION: Shows how to create and configure a transaction message with progressive type refinement. Each modification to the transaction message results in a more specific type, helping catch errors at compile time.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    address,\n    createTransactionMessage,\n    setTransactionMessageFeePayer,\n    setTransactionMessageLifetimeUsingBlockhash,\n    Blockhash,\n} from '@solana/kit';\n\nconst recentBlockhash = {\n    blockhash: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY' as Blockhash,\n    lastValidBlockHeight: 196055492n,\n};\nconst feePayer = address('AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3');\n\n// Create a new transaction message\nconst transactionMessage = createTransactionMessage({ version: 0 });\n//    ^? V0TransactionMessage\n\n// Set the fee payer\nconst transactionMessageWithFeePayer = setTransactionMessageFeePayer(feePayer, transactionMessage);\n//    ^? V0TransactionMessage & ITransactionMessageWithFeePayer\n\nconst transactionMessageWithFeePayerAndLifetime = setTransactionMessageLifetimeUsingBlockhash(\n    // ^? V0TransactionMessage & ITransactionMessageWithFeePayer & TransactionMessageWithBlockhashLifetime\n    recentBlockhash,\n    transactionMessageWithFeePayer,\n);\n```\n\n----------------------------------------\n\nTITLE: Basic RPC Client Setup in TypeScript\nDESCRIPTION: Demonstrates how to create and use a basic Solana RPC client using the createSolanaRpc function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSolanaRpc } from '@solana/kit';\n\n// Create an RPC client.\nconst rpc = createSolanaRpc('http://127.0.0.1:8899');\n//    ^? Rpc<SolanaRpcApi>\n\n// Send a request.\nconst slot = await rpc.getSlot().send();\n```\n\n----------------------------------------\n\nTITLE: Working with Solana Addresses as JavaScript Strings\nDESCRIPTION: Demonstrates different ways to work with Solana addresses, which are now represented as JavaScript strings with the opaque Address type. Shows coercion, typecasting, and deriving addresses from public keys.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Address, address, getAddressFromPublicKey, generateKeyPair } from '@solana/kit';\n\n// Coerce a string to an `Address`\nconst myOtherAddress = address('AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3');\n\n// Typecast it instead\nconst myAddress =\n    'AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3' as Address<'AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3'>;\n\n// From CryptoKey\nconst keyPair = await generateKeyPair();\nconst myPublicKeyAsAddress = await getAddressFromPublicKey(keyPair.publicKey);\n```\n\n----------------------------------------\n\nTITLE: Using a Person Codec to Encode and Decode Data\nDESCRIPTION: Demonstrates how to instantiate a person codec and use it to encode a person object into bytes and decode bytes back into a person object. Shows the practical usage of a codec for data transformation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst personCodec = getPersonCodec();\nconst bytes = personCodec.encode({ name: \"John\", age: 42, verified: true });\nconst person = personCodec.decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Creating Mint Account in Solana\nDESCRIPTION: Implements a function to create a new mint account with configurable decimals, generating keypair, preparing instructions, and sending the transaction\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function createMint(client: Client, options: { decimals?: number } = {}) {\n  const mintSize = getMintSize();\n  const [mint, mintRent, { value: latestBlockhash }] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n    client.rpc.getLatestBlockhash().send(),\n  ]);\n\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n  const initializeMintIx = getInitializeMintInstruction({\n    mint: mint.address,\n    decimals: options.decimals ?? 0,\n    mintAuthority: client.wallet.address,\n    freezeAuthority: client.wallet.address,\n  });\n\n  const transactionMessage = await pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n    (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    (tx) => appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n    (tx) => client.estimateAndSetComputeUnitLimit(tx),\n  );\n\n  const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n\n  await client.sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n\n  return mint.address;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type-Safe RPC Responses in TypeScript\nDESCRIPTION: This snippet illustrates the type-safety features of the Solana Kit library when working with RPC methods. It shows how the return types of RPC calls change based on the input parameters, providing accurate typing for block responses with different levels of detail.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n// Provide one set of parameters, get a certain type\n// These parameters resolve to return type:\n// {\n//     blockhash: Blockhash;\n//     blockHeight: bigint;\n//     blockTime: UnixTimestamp;\n//     parentSlot: bigint;\n//     previousBlockhash: Blockhash;\n// }\nconst blockResponse = await rpc\n    .getBlock(0n, {\n        rewards: false,\n        transactionDetails: 'none',\n    })\n    .send();\n\n// Switch `rewards` to `true`, get `rewards` in the return type\n// {\n//     /* ... Previous response */\n//     rewards: Reward[];\n// }\nconst blockWithRewardsResponse = await rpc\n    .getBlock(0n, {\n        rewards: true,\n        transactionDetails: 'none',\n    })\n    .send();\n\n// Switch `transactionDetails` to `full`, get `transactions` in the return type\n// {\n//     /* ... Previous response */\n//     transactions: TransactionResponse[];\n// }\nconst blockWithRewardsAndTransactionsResponse = await rpc\n    .getBlock(0n, {\n        rewards: true,\n        transactionDetails: 'full',\n    })\n    .send();\n```\n\n----------------------------------------\n\nTITLE: Creating Key Pair from Bytes\nDESCRIPTION: Demonstrates creating a CryptoKeyPair from a keypair file's bytes using createKeyPairFromBytes function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport fs from 'fs';\nimport { createKeyPairFromBytes } from '@solana/keys';\n\n// Get bytes from local keypair file.\nconst keypairFile = fs.readFileSync('~/.config/solana/id.json');\nconst keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n\n// Create a CryptoKeyPair from the bytes.\nconst { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n```\n\n----------------------------------------\n\nTITLE: Using Sign Message Hook in React\nDESCRIPTION: Demonstrates how to use the useSignMessage hook to sign a byte array with a wallet account. This hook provides a simpler interface compared to useWalletAccountMessageSigner for basic message signing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSignMessage } from '@solana/react';\n\nfunction SignMessageButton({ account, messageBytes }) {\n    const signMessage = useSignMessage(account);\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { signature } = await signMessage({\n                        message: messageBytes,\n                    });\n                    window.alert(`Signature bytes: ${signature.toString()}`);\n                } catch (e) {\n                    console.error('Failed to sign message', e);\n                }\n            }}\n        >\n            Sign Message\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Using address() Function for Address Validation in TypeScript\nDESCRIPTION: Demonstrates how to use the address() function to validate and coerce string inputs to the Address type, which is useful for handling untrusted input in Solana transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from '@solana/addresses';\n\nawait transfer(address(fromAddress), address(toAddress), lamports(100000n));\n```\n\n----------------------------------------\n\nTITLE: Separate Discriminated Union Encoder/Decoder\nDESCRIPTION: This snippet demonstrates using separate encoder and decoder functions for discriminated unions with `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder`. The `variantEncoders` and `variantDecoders` variables are presumed to be defined and passed to the respective functions. The example depends on `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\nconst message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Implementing Failover in Solana RPC Transport TypeScript\nDESCRIPTION: This code snippet demonstrates how to set up failover logic for Solana RPC transports using TypeScript. It initializes an array of RPC endpoints and creates a failover transport that switches endpoints when a request fails. Essential dependencies include creating default RPC transports and creating Solana RPCs from these transports. The snippet handles failures by attempting requests with subsequent transports and throws an error if all attempts fail.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { createDefaultRpcTransport, createSolanaRpcFromTransport, type RpcTransport } from '@solana/kit';\n\n// List of RPC endpoints for failover.\nconst rpcEndpoints = [\n    'https://mainnet-beta.my-server-1.com',\n    'https://mainnet-beta.my-server-2.com',\n    'https://mainnet-beta.my-server-3.com',\n    'https://mainnet-beta.my-server-3.com',\n];\n\n// Create an array of transports from the endpoints.\nconst transports = rpcEndpoints.map(url => createDefaultRpcTransport({ url }));\n\n// A failover transport that switches to the next transport on failure.\nasync function failoverTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<TResponse> {\n    let lastError;\n    for (const transport of transports) {\n        try {\n            return await transport(...args);\n        } catch (err) {\n            lastError = err;\n            console.warn(`Transport failed: ${err}. Trying next transport...`);\n        }\n    }\n    // If all transports fail, throw the last error.\n    throw lastError;\n}\n\n// Create the RPC client using the failover transport.\nconst rpc = createSolanaRpcFromTransport(failoverTransport);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Client with Transaction Sending Capabilities\nDESCRIPTION: Shows how to update a Client object to include sendAndConfirmTransaction functionality using the factory pattern, enhancing the client's capabilities for transaction management.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  sendAndConfirmTransactionFactory, // [!code ++]\n  // ...\n} from \"@solana/kit\";\n\nexport type Client = {\n  estimateAndSetComputeUnitLimit: <T extends CompilableTransactionMessage>(transactionMessage: T) => Promise<T>;\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n  sendAndConfirmTransaction: ReturnType<typeof sendAndConfirmTransactionFactory>; // [!code ++]\n  wallet: TransactionSigner & MessageSigner;\n};\n\nlet client: Client | undefined;\nexport async function createClient(): Promise<Client> {\n  if (!client) {\n    // ...\n\n    // Create a function to send and confirm transactions. // [!code ++]\n    const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions }); // [!code ++]\n\n    // Store the client.\n    client = {\n      estimateAndSetComputeUnitLimit,\n      rpc,\n      rpcSubscriptions,\n      sendAndConfirmTransaction, // [!code ++]\n      wallet,\n    };\n  }\n  return client;\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Transaction Message in Solana\nDESCRIPTION: This snippet shows how to sign a fully configured transaction message in Solana. It uses the signTransactionMessageWithSigners function from @solana/kit to extract and deduplicate all signers, sign the message, and compile it into a new Transaction type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signTransactionMessageWithSigners } from \"@solana/kit\";\n\nconst signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n```\n\n----------------------------------------\n\nTITLE: Estimating and Setting Compute Unit Limit in Solana Transactions\nDESCRIPTION: This snippet demonstrates how to estimate the compute unit limit for a Solana transaction and set it dynamically. It uses functions from @solana/kit and @solana-program/compute-budget to estimate the limit and prepend it to the transaction message.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getComputeUnitEstimateForTransactionMessageFactory, prependTransactionMessageInstruction } from \"@solana/kit\";\nimport { getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\n\n// Build the function to estimate compute units.\nconst estimateComputeUnitLimit = getComputeUnitEstimateForTransactionMessageFactory({ rpc: client.rpc });\n\n// Estimate compute units.\nconst computeUnitsEstimate = await estimateComputeUnitLimit(transactionMessage);\n\n// Prepend the compute unit limit instruction to the transaction message.\nconst transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n  getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n  transactionMessage,\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Core Kit Package\nDESCRIPTION: Command to install the main Solana Kit package which includes all sub-packages like @solana/rpc and @solana/transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/index.mdx#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n@solana/kit\n```\n\n----------------------------------------\n\nTITLE: Querying Solana Account Data with GraphQL\nDESCRIPTION: Example of using the @solana/rpc-graphql package to query account data with different encoding options. This demonstrates how GraphQL allows developers to specify exactly which fields they need in the response.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_44\n\nLANGUAGE: ts\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            dataBase58: data(encoding: BASE_58)\n            dataBase64: data(encoding: BASE_64)\n            lamports\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n\nexpect(result).toMatchObject({\n    data: {\n        account: {\n            dataBase58: '2Uw1bpnsXxu3e',\n            dataBase64: 'dGVzdCBkYXRh',\n            lamports: 10290815n,\n        },\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Recovering from Message Gaps in Solana RPC Subscriptions\nDESCRIPTION: This example implements recovery logic for message gaps in Solana RPC subscriptions. It catches up any missed account balance changes by re-establishing the subscription and performing a one-time request after an unexpected subscription failure. Requires '@solana/kit' and an established RPC connection.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\ntry {\n    for await (const notif of accountNotifications) {\n        updateAccountBalance(notif.lamports);\n    }\n} catch (e) {\n    // The subscription failed.\n    // First, re-establish the subscription.\n    await setupAccountBalanceSubscription(address);\n    // Then make a one-shot request to 'catch up' on any missed balance changes.\n    const { value: lamports } = await rpc.getBalance(address).send();\n    updateAccountBalance(lamports);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Public Key from Private Key\nDESCRIPTION: Shows how to derive a public key from an extractable private key using getPublicKeyFromPrivateKey function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n\nconst privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n\nconst publicKey = await getPublicKeyFromPrivateKey(privateKey);\nconst extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n```\n\n----------------------------------------\n\nTITLE: Initializing RPC-GraphQL client\nDESCRIPTION: This code snippet demonstrates how to initialize the RPC-GraphQL client using `createSolanaRpcGraphQL`. It first creates an RPC client using `createSolanaRpc` with a specified endpoint, then passes this client to `createSolanaRpcGraphQL` to create the RPC-GraphQL client.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSolanaRpc } from '@solana/rpc';\n\n// Create the RPC client\nconst rpc = createSolanaRpc('https://api.devnet.solana.com');\n\n// Create the RPC-GraphQL client\nconst rpcGraphQL = createSolanaRpcGraphQL(rpc);\n```\n\n----------------------------------------\n\nTITLE: Using MaybeAccount Type for Existing and Missing Accounts in TypeScript\nDESCRIPTION: Shows how to use the MaybeAccount type to represent accounts that may or may not exist on-chain, handling both existing and missing account scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Account exists.\nconst myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n    exists: true,\n    address: address('1234..5678'),\n    data: { name: 'Alice', age: 30 },\n    // ...\n};\n\n// Account does not exist.\nconst myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n    exists: false,\n    address: address('8765..4321'),\n};\n```\n\n----------------------------------------\n\nTITLE: Using Type Guards for Transaction Signers in TypeScript\nDESCRIPTION: This code demonstrates how to use type guards (`isTransactionPartialSigner`, `isTransactionModifyingSigner`, `isTransactionSendingSigner`, and `isTransactionSigner`) to check the type of a transaction signer. It shows both the boolean-returning and assertion-throwing versions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddress = address('1234..5678');\n\nisTransactionPartialSigner({ address: myAddress, signTransactions: async () => {} }); // ✅ true\nisTransactionPartialSigner({ address: myAddress }); // ❌ false\nassertIsTransactionPartialSigner({ address: myAddress, signTransactions: async () => {} }); // ✅ void\nassertIsTransactionPartialSigner({ address: myAddress }); // ❌ Throws an error.\n\nisTransactionModifyingSigner({ address: myAddress, modifyAndSignTransactions: async () => {} }); // ✅ true\nisTransactionModifyingSigner({ address: myAddress }); // ❌ false\nassertIsTransactionModifyingSigner({ address: myAddress, modifyAndSignTransactions: async () => {} }); // ✅ void\nassertIsTransactionModifyingSigner({ address: myAddress }); // ❌ Throws an error.\n\nisTransactionSendingSigner({ address: myAddress, signAndSignTransaction: async () => {} }); // ✅ true\nisTransactionSendingSigner({ address: myAddress }); // ❌ false\nassertIsTransactionSendingSigner({ address: myAddress, signAndSignTransaction: async () => {} }); // ✅ void\nassertIsTransactionSendingSigner({ address: myAddress }); // ❌ Throws an error.\n\nisTransactionSigner({ address: myAddress, signTransactions: async () => {} }); // ✅ true\nisTransactionSigner({ address: myAddress, modifyAndSignTransactions: async () => {} }); // ✅ true\nisTransactionSigner({ address: myAddress, signAndSignTransaction: async () => {} }); // ✅ true\nassertIsTransactionSigner({ address: myAddress, signTransactions: async () => {} }); // ✅ void\nassertIsTransactionSigner({ address: myAddress, modifyAndSignTransactions: async () => {} }); // ✅ void\nassertIsTransactionSigner({ address: myAddress, signAndSignTransaction: async () => {} }); // ✅ void\n\n```\n\n----------------------------------------\n\nTITLE: Working with Variable Size Codecs in TypeScript @solana/kit\nDESCRIPTION: Shows how to define a codec without a fixed data size by using size prefixing techniques, suitable for dynamically sized input data. It uses a combination of getUtf8Codec and getU32Codec. Access to @solana/kit library necessary.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { VariableSizeCodec, getUtf8Codec, getU32Codec, addCodecSizePrefix } from \"@solana/kit\";\nconst myCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\nmyCodec satisfies VariableSizeCodec<string>;\nmyCodec.getSizeFromValue(\"hello world\"); // 4 + 11 bytes.\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Custom Structs with Solana Codecs in TypeScript\nDESCRIPTION: This snippet demonstrates how to use Solana's codec libraries to create a custom struct codec for encoding and decoding data. It includes a struct with u64, u8, and string fields, showing how to encode and decode the struct.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCodecSizePrefix } from '@solana/codecs-core';\nimport { getStructCodec } from '@solana/codecs-data-structures';\nimport { getU32Codec, getU64Codec, getU8Codec } from '@solana/codecs-numbers';\nimport { getUtf8Codec } from '@solana/codecs-strings';\n\n// Equivalent in Rust:\n// struct {\n//     amount: u64,\n//     decimals: u8,\n//     name: String,\n// }\nconst structCodec = getStructCodec([\n    ['amount', getU64Codec()],\n    ['decimals', getU8Codec()],\n    ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n]);\n\nconst myToken = {\n    amount: 1000000000000000n, // `bigint` or `number` is supported\n    decimals: 2,\n    name: 'My Token',\n};\n\nconst myEncodedToken: Uint8Array = structCodec.encode(myToken);\nconst myDecodedToken = structCodec.decode(myEncodedToken);\n\nmyDecodedToken satisfies {\n    amount: bigint;\n    decimals: number;\n    name: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Converting VersionedTransaction to Transaction in Solana\nDESCRIPTION: This code demonstrates how to convert a legacy VersionedTransaction object to the newer Transaction object using the fromVersionedTransaction function from the @solana/compat package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/compat/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromVersionedTransaction } from '@solana/compat';\n\n// imagine a function that returns a legacy `VersionedTransaction`\nconst legacyVersionedTransaction = getMyLegacyVersionedTransaction();\nconst transaction = fromVersionedTransaction(legacyVersionedTransaction);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Solana API Methods TypeScript\nDESCRIPTION: This code snippet demonstrates how to create custom Solana RPC methods in TypeScript. The example defines a custom RPC type specification for a method such as 'getAsset' from the Metaplex Digital Asset Standard, and shows how to integrate it into a Solana RPC client using a transport to the appropriate server. Dependencies include creating default RPC transports and setting up custom API types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\n// Define the method's response payload.\ntype GetAssetApiResponse = Readonly<{\n    interface: DasApiAssetInterface;\n    id: Address;\n    content: Readonly<{\n        files?: readonly {\n            mime?: string;\n            uri?: string;\n            [key: string]: unknown;\n        }[];\n        json_uri: string;\n        links?: readonly {\n            [key: string]: unknown;\n        }[];\n        metadata: DasApiMetadata;\n    };\n    /* ...etc... */\n}>;\n\n// Set up a type spec for the request method.\ntype GetAssetApi = {\n    // Define the method's name, parameters and response type\n    getAsset(args: { id: Address }): GetAssetApiResponse;\n};\n\n// Export the type spec for downstream users.\nexport type MetaplexDASApi = GetAssetApi;\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { createDefaultRpcTransport, createRpc, createJsonRpcApi } from '@solana/kit';\n\n// Create the custom API.\nconst api = createJsonRpcApi<MetaplexDASApi>();\n\n// Set up an HTTP transport to a server that supports the custom API.\nconst transport = createDefaultRpcTransport({\n    url: 'https://mainnet.helius-rpc.com/?api-key=<api_key>',\n});\n\n// Create the RPC client.\nconst metaplexDASRpc = createRpc({ api, transport });\n//    ^? Rpc<MetaplexDASApi>\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming a Transaction with Blockhash Strategy\nDESCRIPTION: Demonstrates using the sendAndConfirmTransactionFactory helper to both send and wait for confirmation of a transaction that uses the blockhash lifetime strategy.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sendAndConfirmTransactionFactory } from \"@solana/kit\";\n\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\nawait sendAndConfirmTransaction(signedTransaction, { commitment: \"confirmed\" });\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions with Kit\nDESCRIPTION: Shows how to send and confirm a transaction using Kit's approach which separates signature generation from transaction sending. It creates a sendAndConfirm function from RPC objects and uses it with a pre-signed transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { sendAndConfirmTransactionFactory, getSignatureFromTransaction } from \"@solana/kit\";\n\n// Create a send and confirm function from your RPC and RPC Subscriptions objects.\nconst sendAndConfirm = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n\n// Use it to send and confirm any signed transaction.\nconst transactionSignature = getSignatureFromTransaction(signedTransaction);\nawait sendAndConfirm(signedTransaction, { commitment: \"confirmed\" });\n```\n\n----------------------------------------\n\nTITLE: Custom Discriminator Property Name\nDESCRIPTION: This snippet customizes the name of the discriminator property by providing the `discriminator` option to the `getDiscriminatedUnionCodec` function. This allows using a property other than `__kind` to identify the variant. Depends on `getDiscriminatedUnionCodec`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst messageCodec = getDiscriminatedUnionCodec([...], {\n    discriminator: 'message',\n});\n\nmessageCodec.encode({ message: 'Quit' });\nmessageCodec.encode({ message: 'Write', fields: ['Hi'] });\nmessageCodec.encode({ message: 'Move', x: 5, y: 6 });\n```\n\n----------------------------------------\n\nTITLE: Partially Signing Transactions with Embedded Signers\nDESCRIPTION: Demonstrates how to extract signers from a transaction message and use them to sign it, processing modifying signers sequentially before using partial signers in parallel.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = await partiallySignTransactionMessageWithSigners(myTransactionMessage);\n```\n\n----------------------------------------\n\nTITLE: Using useSignAndSendTransaction to Sign and Send a Transaction in React\nDESCRIPTION: This code snippet illustrates the implementation of a React component that utilizes the `useSignAndSendTransaction` hook to sign and send a serialized transaction when a button is clicked. It implements error handling and displays the transaction signature URL upon success.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport { useSignAndSendTransaction } from '@solana/react';\n\nfunction SignAndSendTransactionButton({ account, transactionBytes }) {\n    const signAndSendTransaction = useSignAndSendTransaction(account, 'solana:devnet');\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { signature } = await signAndSendTransaction({\n                        transaction: transactionBytes,\n                    });\n                    const base58TransactionSignature = getBase58Decoder().decode(signature);\n                    window.alert(\n                        `View transaction: https://explorer.solana.com/tx/${base58TransactionSignature}?cluster=devnet`,\n                    );\n                } catch (e) {\n                    console.error('Failed to send transaction', e);\n                }\n            }}\n        >\n            Sign and Send Transaction\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Encoded Sysvar Account Data in Typescript\nDESCRIPTION: This snippet demonstrates how to decode an encoded sysvar account to access the sysvar data. It first fetches the encoded clock account, asserts that the account exists, and then decodes the account data using the `decodeAccount` function with the `getSysvarClockDecoder` codec. The decoded data is then type-checked to ensure it satisfies `Account<SysvarClock>`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch.\nconst clock = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS);\nclock satisfies MaybeEncodedAccount<'SysvarC1ock11111111111111111111111111111111'>;\n\n// Assert.\nassertAccountExists(clock);\nclock satisfies EncodedAccount<'SysvarC1ock11111111111111111111111111111111'>;\n\n// Decode.\nconst decodedClock = decodeAccount(clock, getSysvarClockDecoder());\ndecodedClock satisfies Account<SysvarClock, 'SysvarC1ock11111111111111111111111111111111'>;\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions with CryptoKey in TypeScript\nDESCRIPTION: Signs a transaction using an array of `CryptoKey` objects. This function returns a `FullySignedTransaction`. The transaction must be signed by all required signers for network submission. It requires `@solana/keys` and `@solana/transactions` packages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPair } from '@solana/keys';\nimport { signTransaction } from '@solana/transactions';\n\nconst signedTransaction = await signTransaction([myPrivateKey], tx);\n```\n\n----------------------------------------\n\nTITLE: Sending Transactions Without Confirmation in TypeScript\nDESCRIPTION: Illustrates the use of sendTransactionWithoutConfirmingFactory to send a transaction without waiting for confirmation, including error handling for simulation failures.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    sendTransactionWithoutConfirmingFactory,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n} from '@solana/kit';\n\nconst sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\n\ntry {\n    await sendTransaction(transaction, { commitment: 'confirmed' });\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE)) {\n        console.error('The transaction failed in simulation', e.cause);\n    } else {\n        throw e;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPairSigner from CryptoKeyPair in TypeScript\nDESCRIPTION: This code shows how to create a `KeyPairSigner` from an existing `CryptoKeyPair` using `createSignerFromKeyPair`. The signer will use the private key of the provided key pair for signing messages and transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPair } from '@solana/keys';\nimport { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n\nconst myKeyPair: CryptoKeyPair = await generateKeyPair();\nconst myKeyPairSigner: KeyPairSigner = await createSignerFromKeyPair(myKeyPair);\n\n```\n\n----------------------------------------\n\nTITLE: Using Base58 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBase58Codec function to encode and decode Base58 strings. It shows both basic usage and examples of applying size constraints with utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBase58Codec();\nconst bytes = codec.encode(\"heLLo\"); // 0x1b6a3070\nconst value = codec.decode(bytes); // \"heLLo\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfixCodecSize(getBase58Codec(), 2).encode(\"heLLo\");\n// 0x1b6a (truncated to 2 bytes)\n\naddCodecSizePrefix(getBase58Codec(), getU32Codec()).encode(\"heLLo\");\n// 0x040000001b6a3070\n//   |       └-- The 4 bytes of content.\n//   └-- 4-byte prefix telling us to read 4 bytes.\n\naddCodecSentinel(getBase58Codec(), new Uint8Array([0xff, 0xff])).encode(\"heLLo\");\n// 0x1b6a3070ffff\n//   |       └-- The sentinel signaling the end of the content.\n//   └-- The 4 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Using Sign In With Solana Hook in React\nDESCRIPTION: Demonstrates how to use the useSignIn hook to implement a Sign In With Solana feature in a React component. The hook takes a wallet object and returns a function that can be called to trigger the sign-in process.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSignIn } from '@solana/react';\n\nfunction SignInButton({ wallet }) {\n    const csrfToken = useCsrfToken();\n    const signIn = useSignIn(wallet);\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { account, signedMessage, signature } = await signIn({\n                        requestId: csrfToken,\n                    });\n                    // Authenticate the user, typically on the server, by verifying that\n                    // `signedMessage` was signed by the person who holds the private key for\n                    // `account.publicKey`.\n                    //\n                    // Authorize the user, also on the server, by decoding `signedMessage` as the\n                    // text of a Sign In With Solana message, verifying that it was not modified\n                    // from the values your application expects, and that its content is sufficient\n                    // to grant them access.\n                    window.alert(`You are now signed in with the address ${account.address}`);\n                } catch (e) {\n                    console.error('Failed to sign in', e);\n                }\n            }}\n        >\n            Sign In\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Default Commitment Request Transformer - TypeScript\nDESCRIPTION: Creates a transformer that adds a default commitment to the request configuration object when applicable. It takes a config object that specifies the commitment and a positional mapping for methods.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n\nconst requestTransformer = getDefaultCommitmentRequestTransformer({\n    defaultCommitment: 'confirmed',\n    optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n});\n```\n\n----------------------------------------\n\nTITLE: Aborting Solana RPC Requests TypeScript\nDESCRIPTION: The snippet demonstrates how to utilize AbortControllers to manage Solana RPC requests more effectively. It involves creating an RPC client instance with potential request abort capabilities using AbortSignal. Use cases include handling user navigation events and applying request timeouts to ensure prompt aborts when necessary.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nimport { createSolanaRpc } from '@solana/kit';\n\nconst rpc = createSolanaRpc('http://127.0.0.1:8900');\n\n// Create a new AbortController.\nconst abortController = new AbortController();\n\n// Abort the request when the user navigates away from the current page.\nfunction onUserNavigateAway() {\n    abortController.abort();\n}\n\n// The request will be aborted if and only if the user navigates away from the page.\nconst slot = await rpc.getSlot().send({ abortSignal: abortController.signal });\n```\n\n----------------------------------------\n\nTITLE: Implementing MessageModifyingSigner Interface\nDESCRIPTION: Demonstrates creating a custom MessageModifyingSigner that can modify message content before signing\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMessageModifyingSigner: MessageModifyingSigner<'1234..5678'> = {\n    address: address('1234..5678'),\n    modifyAndSignMessages: async (messages: SignableMessage[]): Promise<SignableMessage[]> => {\n        // My custom signing logic.\n    },\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Mint Creation Implementation\nDESCRIPTION: Full implementation of the createMint helper function combining both CreateAccount and InitializeMint instructions with all necessary parameters and configurations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/instructions.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPairSigner } from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getInitializeMintInstruction, getMintSize, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(client: Client, options: { decimals?: number } = {}) {\n  // Prepare inputs.\n  const mintSize = getMintSize();\n  const [mint, mintRent] = await Promise.all([\n    generateKeyPairSigner(),\n    client.rpc.getMinimumBalanceForRentExemption(BigInt(mintSize)).send(),\n  ]);\n\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer: client.wallet,\n    newAccount: mint,\n    space: mintSize,\n    lamports: mintRent,\n    programAddress: TOKEN_PROGRAM_ADDRESS,\n  });\n  const initializeMintIx = getInitializeMintInstruction({\n    mint: mint.address,\n    decimals: options.decimals ?? 0,\n    mintAuthority: client.wallet.address,\n    freezeAuthority: client.wallet.address,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining createMint Function Structure\nDESCRIPTION: Basic structure of the createMint helper function that accepts a Client object and options for customizing the mint decimals.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/instructions.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Client } from \"./client\";\n\nexport async function createMint(client: Client, options: { decimals?: number } = {}) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Transaction using Base64 Encoding in Solana\nDESCRIPTION: Demonstrates how to encode a signed transaction using getBase64EncodedWireTransaction and send it to the blockchain via the sendTransaction RPC method.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBase64EncodedWireTransaction } from \"@solana/kit\";\n\nconst encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\nawait rpc.sendTransaction(encodedTransaction, { preflightCommitment: \"confirmed\", encoding: \"base64\" }).send();\n```\n\n----------------------------------------\n\nTITLE: Manually Decoding Mint Account Data using Codecs in TypeScript\nDESCRIPTION: Demonstrates how to create a Codec object to manually decode the data of a Mint account using various Codec functions from @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  address,\n  Address,\n  assertAccountExists,\n  fetchEncodedAccount,\n  getAddressCodec,\n  getBooleanCodec,\n  getOptionCodec,\n  getStructCodec,\n  getU64Codec,\n  getU8Codec,\n  Option,\n} from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\nconst mintCodec = getStructCodec([\n  [\"mintAuthority\", getOptionCodec(getAddressCodec())], // [simplified]\n  [\"supply\", getU64Codec()],\n  [\"decimals\", getU8Codec()],\n  [\"isInitialized\", getBooleanCodec()],\n  [\"freezeAuthority\", getOptionCodec(getAddressCodec())], // [simplified]\n]);\n\nconst decodedData = mintCodec.decode(account.data);\ndecodedData satisfies {\n  mintAuthority: Option<Address>;\n  supply: bigint;\n  decimals: number;\n  isInitialized: boolean;\n  freezeAuthority: Option<Address>;\n};\n```\n\n----------------------------------------\n\nTITLE: Obtaining Transaction Signature in TypeScript\nDESCRIPTION: Retrieves a unique signature from a transaction using the `getSignatureFromTransaction()` function. The signature can help trace the transaction on the Solana network. Depends on the @solana/transactions package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSignatureFromTransaction } from '@solana/transactions';\n\nconst signature = getSignatureFromTransaction(tx);\nconsole.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n```\n\n----------------------------------------\n\nTITLE: Deriving Program Derived Address with getProgramDerivedAddress() in TypeScript\nDESCRIPTION: Shows how to use getProgramDerivedAddress() to obtain a program derived address (PDA) given a program's Address and up to 16 Seeds.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n\nconst addressEncoder = getAddressEncoder();\nconst [pda, bumpSeed] = await getProgramDerivedAddress({\n    programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n    seeds: [\n        // Owner\n        addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n        // Token program\n        addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n        // Mint\n        addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n    ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a KeyPair from Private Key Bytes in TypeScript\nDESCRIPTION: Example of using the new createKeyPairFromPrivateKeyBytes helper function to create a keypair from 32-byte private key bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n\nconst { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n```\n\n----------------------------------------\n\nTITLE: Generating KeyPairSigner in TypeScript\nDESCRIPTION: This code snippet demonstrates how to generate a new `CryptoKeyPair` and create a `KeyPairSigner` from it using the `generateKeyPairSigner` function. This is a convenient way to quickly create a signer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPairSigner } from '@solana/signers';\n\nconst myKeyPairSigner = await generateKeyPairSigner();\n\n```\n\n----------------------------------------\n\nTITLE: Custom RPC Transport Configuration\nDESCRIPTION: Shows how to create and use a custom RPC transport with the createSolanaRpcFromTransport function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSolanaRpcFromTransport, createDefaultRpcTransport } from '@solana/kit';\n\n// Create an HTTP transport or any custom transport of your choice.\nconst transport = createDefaultRpcTransport({ url: 'https://api.devnet.solana.com' });\n\n// Create an RPC client using that transport.\nconst rpc = createSolanaRpcFromTransport(transport);\n//    ^? Rpc<SolanaRpcApi>\n\n// Send a request.\nconst slot = await rpc.getSlot().send();\n```\n\n----------------------------------------\n\nTITLE: Getting Default Request Transformer for Solana RPC - TypeScript\nDESCRIPTION: Returns the default request transformer for the Solana RPC API, which combines multiple transformers such as the commitment and overflow transformers. The function takes a configuration object with commitment settings and error handling logic.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n\nconst requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow: (request, keyPath, value) => {\n        throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Solana RPC Subscriptions API\nDESCRIPTION: This code demonstrates the basic usage of the Solana RPC Subscriptions API. It shows how to create an `RpcSubscriptions` instance, request slot notifications with a specific commitment level, subscribe to the notifications with a timeout, and iterate over the results to process each notification. The subscription is handled within a try-catch-finally block to manage potential errors and ensure proper closure.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst rpcSubscriptions =\n    // Step 1 - Create a `RpcSubscriptions` instance. This may be stateful.\n    createSolanaRpcSubscriptions(mainnet('wss://api.mainnet-beta.solana.com'));\nconst response = await rpcSubscriptions\n    // Step 2 - Call supported methods on it to produce `PendingRpcSubscriptionsRequest` objects.\n    .slotNotifications({ commitment: 'confirmed' })\n    // Step 3 - Call the `subscribe()` method on those pending requests to trigger them.\n    .subscribe({ abortSignal: AbortSignal.timeout(10_000) });\n// Step 4 - Iterate over the result.\ntry {\n    for await (const slotNotification of slotNotifications) {\n        console.log('Got a slot notification', slotNotification);\n    }\n} catch (e) {\n    console.error('The subscription closed unexpectedly', e);\n} finally {\n    console.log('We have stopped listening for notifications');\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Request Coalescing in GraphQL for Solana Account Queries\nDESCRIPTION: This GraphQL query demonstrates how multiple queries for the same account with different fields can be coalesced into a single RPC request. It queries the lamports and space of an account, as well as specific fields of a NonceAccount.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_29\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        lamports\n        space\n    }\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        ... on NonceAccount {\n            authority {\n                address\n            }\n            blockhash\n            feeCalculator {\n                lamportsPerSignature\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Transaction Query for Token Transfers in TypeScript\nDESCRIPTION: Complex nested query example for SPL token transfers that retrieves detailed information about the transaction including token accounts, mint details, and account owners, demonstrating the power of GraphQL's nested query capability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($signature: String!, $commitment: Commitment) {\n        transaction(signature: $signature, commitment: $commitment) {\n            message {\n                instructions {\n                    ... on SplTokenTransferInstruction {\n                        amount\n                        authority {\n                            # Account\n                            address\n                            lamports\n                        }\n                        destination {\n                            # Account\n                            ... on TokenAccount {\n                                address\n                                mint {\n                                    ... on MintAccount {\n                                        # Account\n                                        address\n                                        decimals\n                                    }\n                                }\n                                owner {\n                                    # Account\n                                    address\n                                    lamports\n                                }\n                            }\n                        }\n                        source {\n                            # Account\n                            ... on TokenAccount {\n                                address\n                                mint {\n                                    ... on MintAccount {\n                                        # Account\n                                        address\n                                        decimals\n                                    }\n                                }\n                                owner {\n                                    # Account\n                                    address\n                                    lamports\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    signature: '63zkpxATgAwXRGFQZPDESTw2m4uZQ99sX338ibgKtTcgG6v34E3MSS3zckCwJHrimS71cvei6h1Bn1K1De53BNWC',\n    commitment: 'confirmed',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Creating Transaction Messages with Embedded Signers\nDESCRIPTION: Shows how to compose a transaction message that can include instructions with embedded signers, allowing for automatic transaction signing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTransactionMessageWithSigners: BaseTransactionMessage & ITransactionMessageWithSigners = {\n    instructions: [\n        myInstructionA as IInstruction & IInstructionWithSigners,\n        myInstructionB as IInstruction & IInstructionWithSigners,\n        myInstructionC as IInstruction,\n    ],\n    version: 0,\n};\n```\n\n----------------------------------------\n\nTITLE: Using estimateAndSetComputeUnitLimit in Transaction Message Creation\nDESCRIPTION: This code demonstrates how to use the newly created estimateAndSetComputeUnitLimit helper function when creating a transaction message. It's added as the final step in the pipe function to set the compute unit limit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nconst { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\n// [!code word:await]\nconst transactionMessage = await pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) => appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n  (tx) => client.estimateAndSetComputeUnitLimit(tx), // [!code ++]\n);\n```\n\n----------------------------------------\n\nTITLE: Transport with Custom JSON Serialization\nDESCRIPTION: This function configures a transport that leverages custom serialization for JSON requests in the context of Solana RPC, ensuring proper handling of bigint values during transmission.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function createHttpTransportForSolanaRpc() {\n    return createHttpTransport({\n        // Custom JSON serialization functions\n        url: 'https://api.mainnet-beta.solana.com',\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Base58 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBase58Codec function to encode and decode Base58 strings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBase58Codec().encode('heLLo'); // 0x1b6a3070\nconst value = getBase58Codec().decode(bytes); // \"heLLo\"\n```\n\n----------------------------------------\n\nTITLE: Using getArrayCodec in TypeScript\nDESCRIPTION: Demonstrates how to use the getArrayCodec function to encode and decode arrays of values. By default, it stores the array size as a u32 prefix before encoding the items.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getArrayCodec(getU8Codec());\nconst bytes = codec.encode([1, 2, 3]); // 0x03000000010203\nconst array = codec.decode(bytes); // [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Customizing RPC Subscriptions Transport in Solana\nDESCRIPTION: Illustrates creating a custom transport for Solana RPC subscriptions by defining a custom WebSocket channel creator. This allows for control over communication with RPC servers beyond the default setup. Includes necessary methods from the '@solana/kit' library and custom WebSocket settings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createDefaultRpcSubscriptionsTransport, createSolanaRpcSubscriptionsFromTransport } from '@solana/kit';\n\n// Create a transport with a custom channel creator of your choice.\nconst transport = createDefaultRpcSubscriptionsTransport({\n    createChannel({ abortSignal }) {\n        return createWebSocketChannel({\n            maxSubscriptionsPerChannel: 100,\n            minChannels: 25,\n            sendBufferHighWatermark: 32_768,\n            signal: abortSignal,\n            url: 'ws://127.0.0.1:8900',\n        });\n    },\n});\n\n// Create an RPC client using that transport.\nconst rpcSubscriptions = createSolanaRpcSubscriptionsFromTransport(transport);\n//    ^? RpcSubscriptions<SolanaRpcSubscriptionsApi>\n```\n\n----------------------------------------\n\nTITLE: Adding Signers to Transaction Messages\nDESCRIPTION: Shows how to add signers to all applicable account metas in a transaction message, including updating the fee payer if necessary.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTransactionMessageWithSigners = addSignersToTransactionMessage(mySigners, myTransactionMessage);\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPair from Private Key Bytes in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the new createKeyPairFromPrivateKeyBytes helper function to create a keypair from 32-byte private key bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n\nconst { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n```\n\n----------------------------------------\n\nTITLE: Using getBooleanCodec for Boolean Values\nDESCRIPTION: Demonstrates how to use getBooleanCodec which stores boolean values as 0 or 1, using a u8 number codec by default.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_68\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBooleanCodec();\nconst bytes = codec.encode(true); // 0x01\nconst value = codec.decode(bytes); // true\n```\n\n----------------------------------------\n\nTITLE: Batch Loading RPC Call in TypeScript for Multiple Solana Accounts\nDESCRIPTION: This TypeScript code snippet shows how the resolver would make a single RPC call to getMultipleAccounts for fetching data from multiple accounts, optimizing network requests.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nrpc.getMultipleAccounts([\n    'J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ',\n    'EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b',\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Discriminated Union Codec for Different Variant Types\nDESCRIPTION: Demonstrates how to create a discriminated union codec for empty, tuple, and struct variants using getDiscriminatedUnionCodec and other codec utilities from @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nconst messageCodec = getDiscriminatedUnionCodec([\n  // Empty variant.\n  [\"quit\", getUnitCodec()],\n\n  // Tuple variant.\n  [\"write\", getStructCodec([[\"fields\", getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n\n  // Struct variant.\n  [\n    \"move\",\n    getStructCodec([\n      [\"x\", getI32Codec()],\n      [\"y\", getI32Codec()],\n    ]),\n  ],\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPairSigner from PrivateKey Bytes in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a `KeyPairSigner` from a 32-byte `Uint8Array` private key using `createKeyPairSignerFromPrivateKeyBytes`. It also shows how to derive a seed from a message.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUtf8Encoder } from '@solana/codecs-strings';\nimport { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n\nconst message = getUtf8Encoder().encode('Hello, World!');\nconst seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n\nconst derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Solana RPC Connection\nDESCRIPTION: TypeScript code to set up RPC connections and transaction confirmation functionality using the Solana Kit SDK. Creates RPC client, WebSocket subscriptions, and transaction confirmation handler.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/index.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSolanaRpc, createSolanaRpcSubscriptions, sendAndConfirmTransactionFactory } from \"@solana/kit\";\n\nconst rpc = createSolanaRpc(\"https://api.devnet.solana.com\");\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\"wss://api.devnet.solana.com\");\nconst sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Account Type with Nested Ownership in TypeScript\nDESCRIPTION: This snippet queries a specific account type (MintAccount) while also retrieving nested owner information and pertaining data like mintAuthority and lamports, demonstrating flexibility in the data structure obtained.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            ... on MintAccount {\n                address\n                data {\n                    mintAuthority {\n                        address\n                        lamports\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Signing Transaction Message with Signers in Kit\nDESCRIPTION: This snippet demonstrates how to sign a transaction message using the signers created in Kit. It highlights the benefits of using signers directly when creating instructions and how it streamlines the signing process.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signTransactionMessageWithSigners } from \"@solana/kit\";\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\nimport { getInitializeMintInstruction, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\n// ---cut-start---\nimport {\n  address,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  generateKeyPairSigner,\n  pipe,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nconst latestBlockhash = null as unknown as Parameters<typeof setTransactionMessageLifetimeUsingBlockhash>[0];\nconst space = null as unknown as Parameters<typeof getCreateAccountInstruction>[0][\"space\"]; \nconst lamports = null as unknown as Parameters<typeof getCreateAccountInstruction>[0][\"lamports\"]; \n// ---cut-end---\n\n// Create signers.\nconst [payer, mint] = await Promise.all([generateKeyPairSigner(), generateKeyPairSigner()]);\n\n// Create the instructions.\nconst createAccount = getCreateAccountInstruction({\n  payer, // <- TransactionSigner // [!code highlight]\n  newAccount: mint, // <- TransactionSigner // [!code highlight]\n  space,\n  lamports,\n  programAddress: TOKEN_PROGRAM_ADDRESS,\n});\nconst initializeMint = getInitializeMintInstruction({\n  mint: mint.address,\n  mintAuthority: address(\"1234..5678\"),\n  decimals: 2,\n});\n\n// Create the transaction.\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(payer, tx), // <- TransactionSigner // [!code highlight]\n  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) => appendTransactionMessageInstructions([createAccount, initializeMint], tx),\n);\n\n// Sign the transaction.\nconst signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n```\n\n----------------------------------------\n\nTITLE: Fetching and Decoding Mint Account in One Step using TypeScript\nDESCRIPTION: Demonstrates how to use the fetchMint helper from @solana-program/token to fetch and decode a Mint account in a single operation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Account, address } from \"@solana/kit\";\nimport { fetchMint, Mint } from \"@solana-program/token\";\n\nconst account = await fetchMint(rpc, address(\"1234..5678\"));\naccount satisfies Account<Mint>;\n```\n\n----------------------------------------\n\nTITLE: Tutorial Function for Mint Account Creation\nDESCRIPTION: A tutorial function demonstrating the process of creating a client and initializing a mint account with specific decimal configuration\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nasync function tutorial() {\n  const client = await createClient();\n  const mintAddress = await createMint(client, { decimals: 2 });\n  console.log(`Mint created: ${mintAddress}.`);\n}\n```\n\n----------------------------------------\n\nTITLE: Using RpcRequest and RpcResponse in RPC Subscriptions - JavaScript\nDESCRIPTION: This change enforces consistency in the RPC and RPC Subscriptions architecture by standardizing the use of RpcRequest and RpcResponse types. The implementation ensures uniformity in handling user requests and returning responses, enhancing maintainability and readability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Tuples with getTupleCodec in TypeScript\nDESCRIPTION: Shows how to use getTupleCodec to encode and decode tuples with multiple elements of different types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getTupleCodec, getU8Codec, getU64Codec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from \"@solana/kit\";\n\nconst tupleCodec = getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec()), getU8Codec(), getU64Codec()]);\n\nconst bytes = tupleCodec.encode([\"alice\", 42, 123]);\n// 0x05000000616c6963652a7b00000000000000\n//   |                 | └-- 3rd item (123).\n//   |                 └-- 2nd item (42).\n//   └-- 1st item (\"alice\").\n\nconst value = tupleCodec.decode(bytes);\n// [\"alice\", 42, 123]\n```\n\n----------------------------------------\n\nTITLE: Using Constant Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getConstantCodec function to create a codec that encodes and decodes a specific Uint8Array. It also shows error handling for mismatched decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Using I64Codec to Encode/Decode Signed 64-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding signed 64-bit integers using both little-endian (default) and big-endian representations. The codec supports values from -2^63 to 2^63 - 1 and returns BigInt values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getI64Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getI64Codec();\nconst bytes = codec.encode(-42); // 0xd6ffffffffffffff\nconst value = codec.decode(bytes); // BigInt(-42)\n\n// Big-endian.\nconst beCodec = getI64Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-42); // 0xffffffffffffffd6\nconst beValue = beCodec.decode(bytes); // BigInt(-42)\n```\n\n----------------------------------------\n\nTITLE: Creating Recent Signature Confirmation Promise in TypeScript\nDESCRIPTION: Utility for tracking transaction status and confirmation commitment levels by signature, resolving when target commitment is achieved\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRecentSignatureConfirmationPromiseFactory } from '@solana/transaction-confirmation';\n\nconst getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n});\ntry {\n    await getRecentSignatureConfirmationPromise({\n        commitment,\n        signature,\n    });\n    console.log(`The transaction with signature \\`${signature}\\` has achieved a commitment level of \\`${commitment}\\`);\n} catch (e) {\n    console.error(`The transaction with signature \\`${signature}\\` failed`, e.cause);\n    throw e;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TransactionPartialSigner Interface in TypeScript\nDESCRIPTION: This code snippet defines the `TransactionPartialSigner` interface, which is used to sign transactions without modifying them. It includes an example of how to implement a custom signing logic within the `signTransactions` function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTransactionPartialSigner: TransactionPartialSigner<'1234..5678'> = {\n    address: address('1234..5678'),\n    signTransactions: async (transactions: Transaction[]): Promise<SignatureDictionary[]> => {\n        // My custom signing logic.\n    },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Bit Array Codec in TypeScript\nDESCRIPTION: Defines a bit array codec that encodes and decodes an array of booleans, representing each boolean using a single bit. It allows for customization of the codec's byte size and ordering of the bits.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst booleans = [true, false, true, false, true, false, true, false];\n\ngetBitArrayCodec(1).encode(booleans);\n// 0xaa or 0b10101010\n\ngetBitArrayCodec(1, { backward: true }).encode(booleans);\n// 0x55 or 0b01010101\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBitArrayEncoder(1).encode(booleans);\nconst decodedBooleans = getBitArrayDecoder(1).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Fetching JSON Parsed Account in TypeScript\nDESCRIPTION: Demonstrates the usage of fetchJsonParsedAccount function to fetch a MaybeAccount or MaybeEncodedAccount with custom data type from an RPC client, with optional custom configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ntype TokenData = { mint: Address; owner: Address };\nconst myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\nmyAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n\n// With custom configuration.\nconst myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n    abortSignal: myAbortController.signal,\n    commitment: 'confirmed',\n});\n```\n\n----------------------------------------\n\nTITLE: Appending Instruction to Transaction Message\nDESCRIPTION: Demonstrates adding an instruction to a transaction message, such as a memo instruction\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from '@solana/addresses';\nimport { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n\nconst memoTransaction = appendTransactionMessageInstruction(\n    {\n        data: new TextEncoder().encode('Hello world!'),\n        programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n    },\n    tx\n);\n```\n\n----------------------------------------\n\nTITLE: Cherry-Picking Solana RPC API Methods TypeScript\nDESCRIPTION: This snippet explains how to restrict the Solana RPC client's access to only the required API methods by using TypeScript casting. It defines custom type specifications and binds them to specific transports and APIs. Dependencies include the creation of default RPC transports and the construction of a custom RPC that integrates selected API methods.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport { createSolanaRpc, type Rpc, type GetAccountInfoApi, type GetMultipleAccountsApi } from '@solana/kit';\n\nconst rpc = createSolanaRpc('http://127.0.0.1:8899') as Rpc<GetAccountInfoApi & GetMultipleAccountsApi>;\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n    createDefaultRpcTransport,\n    createRpc,\n    createSolanaRpcApi,\n    DEFAULT_RPC_CONFIG,\n    type GetAccountInfoApi,\n    type GetMultipleAccountsApi,\n} from '@solana/kit';\n\nconst api = createSolanaRpcApi<GetAccountInfoApi & GetMultipleAccountsApi>(DEFAULT_RPC_CONFIG);\nconst transport = createDefaultRpcTransport({ url: 'http://127.0.0.1:8899' });\n\nconst rpc = createRpc({ api, transport });\n```\n\n----------------------------------------\n\nTITLE: Defining Client Type for Solana Interactions\nDESCRIPTION: Defines the structure and type of a Solana client with methods for transaction handling, RPC interactions, and wallet operations\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Client = {\n  estimateAndSetComputeUnitLimit: <T extends CompilableTransactionMessage>(transactionMessage: T) => Promise<T>;\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n  sendAndConfirmTransaction: ReturnType<typeof sendAndConfirmTransactionFactory>;\n  wallet: TransactionSigner & MessageSigner;\n};\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding U64 Number in TypeScript\nDESCRIPTION: This snippet shows encoding a number using a u64 codec and decoding it back to a bigint. Input for encoding can be a number type, and the output from decoding is a bigint. This requires @solana/kit with getU64Codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getU64Codec } from \"@solana/kit\";\nconst u64Codec = getU64Codec();\nconst bytes = u64Codec.encode(42);\nconst value = u64Codec.decode(bytes); // BigInt(42)\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Transaction Message with pipe() in TypeScript\nDESCRIPTION: Illustrates how to use the pipe() function to build a Solana transaction message by chaining multiple transaction-related functions. Each function in the pipeline modifies the transaction message and passes it to the next function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/functional/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst transferTransactionMessage = pipe(\n    // The result of the first expression...\n    createTransactionMessage({ version: 0 }),\n    // ...gets passed as the sole argument to the next function in the pipeline.\n    tx => setTransactionMessageFeePayer(myAddress, tx),\n    // The return value of that function gets passed to the next...\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    // ...and so on.\n    tx => appendTransactionMessageInstruction(getTransferSolInstruction({ source, destination, amount }), tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Connection Handling Comparison - Web3.js vs Kit\nDESCRIPTION: Demonstrates the difference between creating connections and making RPC requests in Web3.js versus Kit. Shows how Kit uses functional approach with createSolanaRpc instead of Connection class.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Create a `Connection` object.\nconst connection = new Connection(\"https://api.devnet.solana.com\", {\n  commitment: \"confirmed\",\n});\n\n// Send RPC requests.\nconst wallet = new PublicKey(\"1234..5678\");\nconst balance = await connection.getBalance(wallet);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, createSolanaRpc } from \"@solana/kit\";\n\n// Create an RPC proxy object.\nconst rpc = createSolanaRpc(\"https://api.devnet.solana.com\");\n\n// Send RPC requests.\nconst wallet = address(\"1234..5678\");\nconst { value: balance } = await rpc.getBalance(wallet).send();\n```\n\n----------------------------------------\n\nTITLE: Creating a cached Client object for Solana interactions\nDESCRIPTION: TypeScript function to create and cache a Client object for reuse in the application, initializing RPC and RPC Subscriptions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/setup.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nlet client: Client | undefined;\nexport function createClient(): Client {\n  if (!client) {\n    client = {\n      rpc: createSolanaRpc(\"http://127.0.0.1:8899\"),\n      rpcSubscriptions: createSolanaRpcSubscriptions(\"ws://127.0.0.1:8900\"),\n    };\n  }\n  return client;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Addresses with createAddressWithSeed() in TypeScript\nDESCRIPTION: Demonstrates the usage of createAddressWithSeed() function to derive a new Solana address based on a base address, program address, and a seed string.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAddressWithSeed } from '@solana/addresses';\n\nconst derivedAddress = await createAddressWithSeed({\n    baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n    programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n    seed: 'data-account',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Signers in Kit\nDESCRIPTION: This snippet shows different ways to create signer objects in the Kit framework, allowing the use of CryptoKeyPairs, wallet adapters, or nop signers for transaction signing. It emphasizes the flexibility of the signing mechanism by showcasing various examples.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, createNoopSigner, generateKeyPairSigner } from \"@solana/kit\";\nimport { useWalletAccountTransactionSendingSigner } from \"@solana/react\";\n// ---cut-start---\nconst account = null as unknown as Parameters<typeof useWalletAccountTransactionSendingSigner>[0];\nconst currentChain = null as unknown as Parameters<typeof useWalletAccountTransactionSendingSigner>[1];\n// ---cut-end---\n\n// Using CryptoKeyPairs.\nconst myKeypairSigner = await generateKeyPairSigner();\n\n// Using the wallet standard.\nconst myWalletSigner = useWalletAccountTransactionSendingSigner(account, currentChain);\n\n// Using a Noop signer.\nconst myNoopSigner = createNoopSigner(address(\"1234..5678\"));\n```\n\n----------------------------------------\n\nTITLE: Using U64Codec to Encode/Decode Unsigned 64-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding unsigned 64-bit integers (from 0 to 2^64 - 1) using both little-endian (default) and big-endian representations. Returns BigInt values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU64Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getU64Codec();\nconst bytes = codec.encode(42); // 0x2a00000000000000\nconst value = codec.decode(bytes); // 42\n\n// Big-endian.\nconst beCodec = getU64Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(42); // 0x000000000000002a\nconst beValue = beCodec.decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Creating a Codec for a Complex Person Type with Multiple Fields\nDESCRIPTION: Shows how to build a codec for a Person type with name, age, and verified fields by composing various codecs together. Demonstrates the pattern of creating a function that returns a codec for a specific type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = {\n  name: string;\n  age: number;\n  verified: boolean;\n};\n\nconst getPersonCodec = (): Codec<Person> =>\n  getStructCodec([\n    [\"name\", addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n    [\"age\", getU32Codec()],\n    [\"verified\", getBooleanCodec()],\n  ]);\n```\n\n----------------------------------------\n\nTITLE: Using getConstantCodec for Fixed Byte Sequences\nDESCRIPTION: Demonstrates getConstantCodec which creates a codec that always encodes to a specific byte sequence and verifies the same sequence when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_72\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Type Guarding Lamports in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `isLamports` type guard to validate and refine a `bigint` to the `Lamports` type. It imports the `isLamports` function from `@solana/rpc-types`, checks if a given `bigint` is a valid `Lamports` value, and, if so, proceeds to use it in a transfer function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isLamports } from '@solana/rpc-types';\n\nif (isLamports(lamports)) {\n    // At this point, `lamports` has been refined to a\n    // `Lamports` that can be used anywhere Lamports are expected.\n    await transfer(fromAddress, toAddress, lamports);\n} else {\n    setError(`${ownerAddress} is not an address`);\n}\n```\n\n----------------------------------------\n\nTITLE: Using UTF-8 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getUtf8Codec function to encode and decode UTF-8 strings. It shows both basic usage and examples of applying size constraints with utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getUtf8Codec();\nconst bytes = codec.encode(\"hello\"); // 0x68656c6c6f\nconst value = codec.decode(bytes); // \"hello\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfixCodecSize(getUtf8Codec(), 4).encode(\"hello\");\n// 0x68656c6c (truncated to 4 bytes)\n\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()).encode(\"hello\");\n// 0x0500000068656c6c6f\n//   |       └-- The 5 bytes of content.\n//   └-- 4-byte prefix telling us to read 5 bytes.\n\naddCodecSentinel(getUtf8Codec(), new Uint8Array([0xff, 0xff])).encode(\"hello\");\n// 0x68656c6c6fffff\n//   |         └-- The sentinel signaling the end of the content.\n//   └-- The 5 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Discriminated Union Codec\nDESCRIPTION: This snippet creates a discriminated union codec using `getDiscriminatedUnionCodec`. It defines a union of three types: `Quit`, `Write`, and `Move`. Each variant has a discriminator (`__kind`) and a corresponding codec. It depends on `getDiscriminatedUnionCodec`, `getUnitCodec`, `getStructCodec`, `getTupleCodec`, `addCodecSizePrefix`, and `getUtf8Codec`, `getU32Codec`, `getI32Codec`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype Message =\n    | { __kind: 'Quit' } // Empty variant.\n    | { __kind: 'Write'; fields: [string] } // Tuple variant.\n    | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n\nconst messageCodec = getDiscriminatedUnionCodec([\n    // Empty variant.\n    ['Quit', getUnitCodec()],\n\n    // Tuple variant.\n    ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n\n    // Struct variant.\n    [\n        'Move',\n        getStructCodec([\n            ['x', getI32Codec()],\n            ['y', getI32Codec()],\n        ]),\n    ],\n]);\n```\n\n----------------------------------------\n\nTITLE: Adding Sentinels to Codecs in TypeScript\nDESCRIPTION: Demonstrates how to add sentinel values to mark the end of encoded data. The sentinel must not appear in the encoded data but must be present when decoding. This example shows encoding a string with a custom sentinel.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\ncodec.encode('hello');\n// 0x68656c6c6fffff\n//   |        └-- Our sentinel.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Using Web Crypto API for Cryptographic Operations in Solana\nDESCRIPTION: Shows how to generate a CryptoKeyPair using the Web Crypto API and perform signing and verification operations. This demonstrates the new asynchronous approach to key management in @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPair, signBytes, verifySignature } from '@solana/kit';\n\nconst keyPair: CryptoKeyPair = await generateKeyPair();\n\nconst message = new Uint8Array(8).fill(0);\n\nconst signedMessage = await signBytes(keyPair.privateKey, message);\n//    ^? Signature\n\nconst verified = await verifySignature(keyPair.publicKey, signedMessage, message);\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON RPC Account in TypeScript\nDESCRIPTION: Shows how to use parseJsonRpcAccount function to parse a jsonParsed account from RPC into an Account or MaybeAccount type with a custom data structure.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Fee Payer\nDESCRIPTION: Adds fee payer configuration to the transaction message using client wallet.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Transaction Message with Multiple Program Instructions\nDESCRIPTION: Demonstrates the creation of a transaction message composed of instructions from three different core programs using generated clients.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { appendTransactionMessageInstructions, createTransactionMessage, pipe } from '@solana/kit';\nimport { getAddMemoInstruction } from '@solana-program/memo';\nimport { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\nimport { getTransferSolInstruction } from '@solana-program/system';\n\nconst instructions = [\n    getSetComputeUnitLimitInstruction({ units: 600_000 }),\n    getTransferSolInstruction({ source, destination, amount: 1_000_000_000 }),\n    getAddMemoInstruction({ memo: \"I'm transferring some SOL!\" }),\n];\n\n// Creates a V0 transaction message with 3 instructions inside.\nconst transactionMessage = pipe(createTransactionMessage({ version: 0 }), tx =>\n    appendTransactionMessageInstructions(instructions, tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Key Pairs\nDESCRIPTION: Shows how to generate an Ed25519 public/private key pair using the generateKeyPair function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPair } from '@solana/keys';\n\nconst { privateKey, publicKey } = await generateKeyPair();\n```\n\n----------------------------------------\n\nTITLE: Serializing Transactions in TypeScript\nDESCRIPTION: Converts a signed transaction into a base64-encoded wire format using the `getBase64EncodedWireTransaction()` function. This serialized format is suitable for network transit. Requires `@solana/transactions` package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n\nconst serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\nconst signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n```\n\n----------------------------------------\n\nTITLE: Get Literal Union Codec in Typescript\nDESCRIPTION: This snippet demonstrates how to use `getLiteralUnionCodec` to create a codec for a union of literal strings. The codec provides fixed-size encoding and decoding for the specified literal values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec = getLiteralUnionCodec(['left', 'right', 'up', 'down']);\n    // ^? FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">\n\n    const bytes = codec.encode('left'); // 0x00\n    const value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Options in TypeScript\nDESCRIPTION: Shows how to use unwrapOption and unwrapOptionRecursively functions to access values in Option types, including nested options and complex objects.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nunwrapOption(some('Hello World')); // \"Hello World\"\nunwrapOption(none()); // null\n\nunwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\nunwrapOption(none(), () => 'Default'); // \"Default\"\n\nunwrapOptionRecursively(some(some(some('Hello World')))); // \"Hello World\"\nunwrapOptionRecursively(some(some(none<string>()))); // null\n\nunwrapOptionRecursively({\n    a: 'hello',\n    b: none(),\n    c: [{ c1: some(42) }, { c2: none() }],\n});\n// { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n\nunwrapOptionRecursively(\n    {\n        a: 'hello',\n        b: none(),\n        c: [{ c1: some(42) }, { c2: none() }],\n    },\n    () => 'Default',\n);\n// { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n```\n\n----------------------------------------\n\nTITLE: Using AsyncIterator for Solana RPC Subscriptions in TypeScript\nDESCRIPTION: This snippet demonstrates how to create and manage Solana RPC subscriptions using AsyncIterator, allowing developers to consume account notifications and manage connection lifecycle with AbortController. Dependencies include the '@solana/kit' library, an address to subscribe to, and an AbortController for managing the subscription lifecycle.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { address, createSolanaRpcSubscriptions, createDefaultRpcSubscriptionsTransport } from '@solana/kit';\n\n// Create the RPC Subscriptions client.\nconst rpcSubscriptions = createSolanaRpcSubscriptions('ws://127.0.0.1:8900');\n\n// Set up an abort controller.\nconst abortController = new AbortController();\n\n// Subscribe to account notifications.\nconst accountNotifications = await rpcSubscriptions\n    .accountNotifications(address('AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3'), { commitment: 'confirmed' })\n    .subscribe({ abortSignal: abortController.signal });\n\ntry {\n    // Consume messages.\n    for await (const notification of accountNotifications) {\n        console.log('New balance', notification.value.lamports);\n    }\n} catch (e) {\n    // The subscription went down.\n    // Retry it and then recover from potentially having missed\n    // a balance update, here (eg. by making a `getBalance()` call).\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy Keypair to CryptoKeyPair in Solana\nDESCRIPTION: This code shows how to convert a legacy Keypair object to a native Ed25519 CryptoKeyPair object using the fromLegacyKeypair function from the @solana/compat package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/compat/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromLegacyKeypair } from '@solana/compat';\nconst { privateKey, publicKey } = await fromLegacyKeypair(Keypair.generate());\n```\n\n----------------------------------------\n\nTITLE: Creating Instructions with Embedded Signers\nDESCRIPTION: Shows how to compose an instruction that includes account signer metas, allowing signers to be tracked at the instruction level.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst myInstructionWithSigners: IInstruction & IInstructionWithSigners = {\n    programAddress: address('1234..5678'),\n    accounts: [\n        {\n            address: myTransactionSigner.address,\n            role: AccountRole.READONLY_SIGNER,\n            signer: myTransactionSigner,\n        },\n    ],\n};\n```\n\n----------------------------------------\n\nTITLE: Refactoring Transaction Handling - JavaScript\nDESCRIPTION: This snippet captures a significant refactoring of how transactions are constructed, separating the processes of constructing transaction messages from signing and sending them, leading to better code organization and functionality.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Refactor transactions, to separate constructing transaction messages from signing/sending compiled transactions\n```\n\n----------------------------------------\n\nTITLE: Using getI16Codec for Signed 16-bit Integers with Endianness Control in TypeScript\nDESCRIPTION: Shows how to use getI16Codec to encode and decode signed 16-bit integers with control over endianness. The codec supports values from -32,768 to 32,767 and can use either little-endian or big-endian format.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getI16Codec, Endian } from \"@solana/kit\";\n// Little-endian.\nconst codec = getI16Codec();\nconst bytes = codec.encode(-42); // 0xd6ff\nconst value = codec.decode(bytes); // -42\n\n// Big-endian.\nconst beCodec = getI16Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-42); // 0xffd6\nconst beValue = beCodec.decode(bytes); // -42\n```\n\n----------------------------------------\n\nTITLE: Creating a Person Decoder using Composable Decoders in TypeScript\nDESCRIPTION: This example shows how to create a decoder for the Person type using only the decoding functionality, which allows for tree-shaking of unused encoding logic.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonDecoder = (): Decoder<Person> =>\n    getStructDecoder([\n        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n        ['age', getU32Decoder()],\n    ]);\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPairSigner Instance\nDESCRIPTION: Generates a KeyPairSigner that implements TransactionSigner and MessageSigner interfaces for flexible transaction signing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPairSigner } from \"@solana/kit\";\n\nconst wallet = await generateKeyPairSigner();\n```\n\n----------------------------------------\n\nTITLE: Cancelling Account Notifications in Solana RPC using AbortController\nDESCRIPTION: Illustrating the use of AbortController to cancel an account notification subscription based on a dynamic condition within the 'for await...of' loop. This example checks if the account owner changes and aborts the subscription if it does. Prerequisites include the setup of an RPC instance and an active subscription.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Subscribe to account notifications.\nconst accountNotifications = await rpc\n    .accountNotifications(address('AxZfZWeqztBCL37Mkjkd4b8Hf6J13WCcfozrBY6vZzv3'), { commitment: 'confirmed' })\n    .subscribe({ abortSignal });\n\n// Consume messages.\nlet previousOwner = null;\nfor await (const notification of accountNotifications) {\n    const {\n        value: { owner },\n    } = notification;\n    // Check the owner to see if it has changed\n    if (previousOwner && owner !== previousOwner) {\n        // If so, abort the subscription\n        abortController.abort();\n    } else {\n        console.log(notification);\n    }\n    previousOwner = owner;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Wallet Account Transaction Signer in React\nDESCRIPTION: Demonstrates how to use the useWalletAccountTransactionSigner hook to sign transactions with a wallet account. The hook returns a TransactionModifyingSigner object that can be used to sign Solana transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useWalletAccountTransactionSigner } from '@solana/react';\n\nfunction SignTransactionButton({ account, transaction }) {\n    const transactionSigner = useWalletAccountTransactionSigner(account, 'solana:devnet');\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const [{ signatures }] = await transactionSigner.modifyAndSignTransactions([transaction]);\n                    const signatureBytes = signatures[transactionSigner.address];\n                    window.alert(`Signature bytes: ${signatureBytes.toString()}`);\n                } catch (e) {\n                    console.error('Failed to sign transaction', e);\n                }\n            }}\n        >\n            Sign Transaction\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Block Height Exceedence Promise in TypeScript\nDESCRIPTION: Utility function to monitor and handle transaction blockhash expiration, throwing an error when the network block height exceeds the transaction's last valid block height\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSolanaError, SolanaError } from '@solana/errors';\nimport { createBlockHeightExceedencePromiseFactory } from '@solana/transaction-confirmation';\n\nconst getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n});\ntry {\n    await getBlockHeightExceedencePromise({ lastValidBlockHeight });\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n        console.error(\n            `The block height of the network has exceeded ${e.context.lastValidBlockHeight}. ` +\n                `It is now ${e.context.currentBlockHeight}`,\n        );\n        // Re-sign and retry the transaction.\n        return;\n    }\n    throw e;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TransactionSigner Union Type in TypeScript\nDESCRIPTION: This code snippet defines the `TransactionSigner` type as a union of the three transaction signer interfaces: `TransactionPartialSigner`, `TransactionModifyingSigner`, and `TransactionSendingSigner`. This allows for flexibility in using different types of signers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntype TransactionSigner<TAddress extends string = string> =\n    | TransactionPartialSigner<TAddress>\n    | TransactionModifyingSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n```\n\n----------------------------------------\n\nTITLE: Using signAndSendTransactionMessageWithSigners for Basic Transaction Handling in TypeScript\nDESCRIPTION: Demonstrates how to use the signAndSendTransactionMessageWithSigners function to sign and send a transaction in a single operation. The function extracts all signers from the transaction message, signs it, and immediately sends it to the blockchain, returning the transaction signature.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n\n// With additional config.\nconst transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n    abortSignal: myAbortController.signal,\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Encoded Accounts in TypeScript\nDESCRIPTION: Shows how to use fetchEncodedAccounts function to fetch multiple MaybeEncodedAccounts from an RPC client, with optional custom configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddressA = address('1234..5678');\nconst myAddressB = address('8765..4321');\nconst [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\nmyAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\nmyAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n\n// With custom configuration.\nconst [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n    abortSignal: myAbortController.signal,\n    commitment: 'confirmed',\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Tutorial Function with Mint Account Fetching in TypeScript\nDESCRIPTION: This code snippet updates the main tutorial function to fetch the Mint account created earlier, decode its data, and display various fields including optional ones. It uses the unwrapOption helper to handle Option<T> types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapOption } from \"@solana/kit\"; // [!code ++]\nimport { fetchMint } from \"@solana-program/token\"; // [!code ++]\n\nimport { createClient } from \"./client\";\nimport { createMint } from \"./create-mint\";\n\nasync function tutorial() {\n  const client = await createClient();\n  const mintAddress = await createMint(client, { decimals: 2 });\n  const mintAccount = await fetchMint(client.rpc, mintAddress); // [!code ++]\n  console.log(`Mint created: ${mintAddress}.`);\n  console.log(`Mint lamports: ${mintAccount.lamports}.`); // [!code ++]\n  console.log(`Mint authority: ${unwrapOption(mintAccount.data.mintAuthority)}.`); // [!code ++]\n  console.log(`Mint decimals: ${mintAccount.data.decimals}.`); // [!code ++]\n  console.log(`Mint supply: ${mintAccount.data.supply}.`); // [!code ++]\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching AddressLookupTable PDA from Seeds\nDESCRIPTION: Illustrates how to fetch an AddressLookupTable PDA from its seeds using generated client helpers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst account = await fetchAddressLookupTableFromSeeds(rpc, {\n    authority: authority.address,\n    recentSlot,\n});\n\naccount.address; // Address\naccount.lamports; // Lamports\naccount.data.addresses; // Address[]\naccount.data.authority; // Some<Address>\naccount.data.deactivationSlot; // Slot\naccount.data.lastExtendedSlot; // Slot\naccount.data.lastExtendedSlotStartIndex; // number\n```\n\n----------------------------------------\n\nTITLE: Creating BigInt Upcast Response Transformer - TypeScript\nDESCRIPTION: Returns a transformer that upcasts Number values to BigInt unless they match specific allowed numeric key paths. This ensures that certain numeric data remains in a smaller format while handling larger values appropriately.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n\nconst responseTransformer = getBigIntUpcastResponseTransformer([\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n]);\n```\n\n----------------------------------------\n\nTITLE: Composing Person Codec in TypeScript\nDESCRIPTION: Example showing how to create a codec for a Person type with name and age fields using struct and primitive codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = { name: string; age: number };\nconst getPersonCodec = (): Codec<Person> =>\n    getStructCodec([\n        ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n        ['age', getU32Codec()],\n    ]);\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Lifetime\nDESCRIPTION: Sets transaction lifetime using blockhash strategy with latest blockhash from network.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Account Decoding Using Codecs\nDESCRIPTION: Shows how to decode account data using defined codecs in Kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst wallet = address(\"1234..5678\");\nconst account = await fetchEncodedAccount(rpc, wallet);\nconst decodedAccount = decodeAccount(account, personCodec);\n\nif (decodedAccount.exists) {\n  decodedAccount.data satisfies Person;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Endianness with Codec Options\nDESCRIPTION: Shows how to set endianness directly through codec options, as an alternative to using reverseCodec. This approach uses the built-in endian option of number codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nconst getBigEndianU64Codec = () => getU64Codec({ endian: Endian.Big });\n```\n\n----------------------------------------\n\nTITLE: Pre-validating Transactions with assertIsTransactionMessageWithSingleSendingSigner in TypeScript\nDESCRIPTION: Shows how to validate that a transaction has exactly one TransactionSendingSigner before attempting to sign and send it. The assertIsTransactionMessageWithSingleSendingSigner function throws an error if the transaction doesn't meet this requirement.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nassertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\nconst transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n```\n\n----------------------------------------\n\nTITLE: Cherry-Picking RPC Subscription Methods in TypeScript using @solana/kit\nDESCRIPTION: Creates a constrained RPC client by casting to a type that includes only specific needed methods. This allows limiting the scope of Subscription API to only necessary functionalities.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    createSolanaRpcSubscriptions,\n    type RpcSubscriptions,\n    type AccountNotificationsApi,\n    type SlotNotificationsApi,\n} from '@solana/kit';\n\nconst rpc = createSolanaRpcSubscriptions('ws://127.0.0.1:8900') as RpcSubscriptions<\n    AccountNotificationsApi & SlotNotificationsApi\n>;\n```\n\n----------------------------------------\n\nTITLE: Custom Modulo U8 Codec in TypeScript @solana/kit\nDESCRIPTION: This snippet creates a custom codec to encode unsigned integers within a single byte, using modulo 256 for integers beyond the byte limit. It adopts a fixed size attribute, showcasing the flexibility of @solana/kit's codec functionalities.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createCodec } from \"@solana/kit\";\n\nconst getModuloU8Codec = () =>\n  createCodec<number>({\n    fixedSize: 1,\n    read(bytes, offset) {\n      const value = bytes[offset];\n      return [value, offset + 1];\n    },\n    write(value, bytes, offset) {\n      bytes.set([value % 256], offset);\n      return offset + 1;\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Enum Encoding and Decoding\nDESCRIPTION: This snippet demonstrates basic enum encoding and decoding using `getEnumCodec`.  It defines a simple `Direction` enum and shows how to encode and decode its values. It relies on the `getEnumCodec` function which is assumed to be defined elsewhere.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction {\n    Left,\n    Right,\n}\n\nconst bytes = getEnumCodec(Direction).encode(Direction.Left);\nconst direction = getEnumCodec(Direction).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Verifying Signatures\nDESCRIPTION: Demonstrates how to verify a signature against data and a public key using verifySignature function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { verifySignature } from '@solana/keys';\n\nconst data = new Uint8Array([1, 2, 3]);\nif (!(await verifySignature(publicKey, signature, data))) {\n    throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n}\n```\n\n----------------------------------------\n\nTITLE: Adding BigInt JSON Serialization to RPC Subscriptions Channel\nDESCRIPTION: Function to wrap an RPC subscriptions channel with JSON serialization and parsing, handling BigInt values for large integers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\ngetRpcSubscriptionsChannelWithBigIntJSONSerialization(channel)\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Structs with getStructCodec in TypeScript\nDESCRIPTION: Demonstrates how to use getStructCodec to encode and decode structured objects with named fields.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getStructCodec, getU8Codec, getUtf8Codec, addCodecSizePrefix, Codec, getU32Codec } from \"@solana/kit\";\n\ntype Person = { name: string; age: number };\nconst personCodec: Codec<Person> = getStructCodec([\n  [\"name\", addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n  [\"age\", getU8Codec()],\n]);\n\nconst bytes = personCodec.encode({ name: \"alice\", age: 42 });\n// 0x05000000616c6963652a\n//   |                 └-- Age field.\n//   └-- Name field.\n\nconst person = personCodec.decode(bytes);\n// { name: \"alice\", age: 42 }\n```\n\n----------------------------------------\n\nTITLE: Fetching JSON Parsed Accounts in TypeScript\nDESCRIPTION: The `fetchJsonParsedAccounts` function retrieves an array of `MaybeAccount` from an RPC client for given addresses, using the `getMultipleAccounts` RPC method with `jsonParsed` encoding. This method may return `MaybeEncodedAccount` if parsing fails. It requires the expected array of data types as the first type parameter and accepts an RPC client and an array of addresses as parameters, returning a Promise of accounts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntype TokenData = { mint: Address; owner: Address };\ntype MintData = { supply: bigint };\nconst [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\nmyAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\nmyAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n```\n\n----------------------------------------\n\nTITLE: Fetching Accounts using RPC Methods in TypeScript\nDESCRIPTION: Demonstrates how to fetch Solana accounts using RPC methods getAccountInfo and getMultipleAccounts from @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from \"@solana/kit\";\n\nconst { value: account } = await rpc.getAccountInfo(address(\"1234..5678\")).send();\nconst { value: accounts } = await rpc.getMultipleAccounts([address(\"1234..5678\")]).send();\n```\n\n----------------------------------------\n\nTITLE: Creating Transfer Instruction using Web3.js\nDESCRIPTION: This snippet demonstrates how to create a transfer instruction using the SystemProgram class from Web3.js. It initializes a transfer from one public key to another, specifying the amount of lamports to transfer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nconst transferSol = SystemProgram.transfer({\n  fromPubkey: new PublicKey(\"2222..2222\"),\n  toPubkey: new PublicKey(\"3333..3333\"),\n  lamports: 1_000_000_000, // 1 SOL.\n});\n```\n\n----------------------------------------\n\nTITLE: Using BaseX Reslice Codec with Custom Alphabet in TypeScript\nDESCRIPTION: Demonstrates how to use the getBaseXResliceCodec function to create a custom base-X codec using bits reslicing. This approach is best for alphabets whose length is a power of 2. It shows both basic usage and examples with size constraints.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBaseXResliceCodec(\"elho\", 2);\nconst bytes = codec.encode(\"hellolol\"); // 0x4aee\nconst value = codec.decode(bytes); // \"hellolol\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBaseXResliceCodec(\"elho\", 2);\n\nfixCodecSize(codec, 4).encode(\"hellolol\");\n// 0x4aee0000 (padded to 4 bytes)\n\naddCodecSizePrefix(codec, getU32Codec()).encode(\"hellolol\");\n// 0x020000004aee\n//   |       └-- The 2 bytes of content.\n//   └-- 4-byte prefix telling us to read 2 bytes.\n\naddCodecSentinel(codec, new Uint8Array([0xff, 0xff])).encode(\"hellolol\");\n// 0x4aeeffff\n//   |   └-- The sentinel signaling the end of the content.\n//   └-- The 2 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Implementing Failover Logic for RPC Transport - TypeScript\nDESCRIPTION: This code snippet provides an implementation of a failover mechanism for RPC transports in TypeScript. It attempts to call each transport in sequence until one succeeds, handling potential request errors along the way. Key parameters involve the use of Multiple `createHttpTransport` invocations with server URLs and handling `RpcTransport` arguments. Expected output is the `RpcResponse` of a successful transport or throws an error if all transports fail.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RpcTransport } from '@solana/rpc-spec';\nimport { RpcResponse } from '@solana/rpc-spec-types';\nimport { createHttpTransport } from '@solana/rpc-transport-http';\n\n// Create a transport for each RPC server\nconst transports = [\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-1.com' }),\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-2.com' }),\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-2.com' }),\n];\n\n// A failover transport that will try each transport in order until one succeeds before failing\nasync function failoverTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<RpcResponse<TResponse>> {\n    let requestError;\n\n    for (const transport of transports) {\n        try {\n            return await transport(...args);\n        } catch (err) {\n            requestError = err;\n            console.error(err);\n        }\n    }\n    throw requestError;\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Bytes with Private Key\nDESCRIPTION: Shows how to sign data bytes using a private key with the signBytes function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { signBytes } from '@solana/keys';\n\nconst data = new Uint8Array([1, 2, 3]);\nconst signature = await signBytes(privateKey, data);\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Large Integers in TypeScript\nDESCRIPTION: Illustrates how to encode and decode large integers (u64, u128, i64, i128) which return bigint values when decoded.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bytesFromNumber = getU64Codec().encode(42);\ngetU64Codec().decode(bytesFromNumber); // BigInt(42)\n\n// OR\nconst bytesFromBigInt = getU64Codec().encode(BigInt(42));\ngetU64Codec().decode(bytesFromBigInt); // BigInt(42)\n```\n\n----------------------------------------\n\nTITLE: Adding Signers to Instructions\nDESCRIPTION: Demonstrates how to add transaction signers to matching account metas in an instruction that has signer roles but no attached signers yet.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst myInstruction: IInstruction = {\n    accounts: [\n        { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n        { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n    ],\n    // ...\n};\n\nconst mySignerA: TransactionSigner<'1111'>;\nconst mySignerB: TransactionSigner<'2222'>;\nconst myInstructionWithSigners = addSignersToInstruction([mySignerA, mySignerB], myInstruction);\n\n// myInstructionWithSigners.accounts[0].signer === mySignerA\n// myInstructionWithSigners.accounts[1].signer === mySignerB\n```\n\n----------------------------------------\n\nTITLE: Resizing Variable-Size Codec in TypeScript\nDESCRIPTION: Shows how to resize a variable-size codec using resizeCodec. This adds additional buffer space to the encoded output without modifying the actual encoded bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// Variable-size codec.\nconst getBiggerUtf8Codec = () => resizeCodec(getUtf8Codec(), size => size + 4);\ngetBiggerUtf8Codec().encode('ABC');\n// 0x41424300000000\n//   |     └-- Empty buffer space caused by the resizeCodec function.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Defining a Discriminated Union Type in TypeScript\nDESCRIPTION: Example of how to define a discriminated union type in TypeScript with empty, tuple, and struct variants using the __kind property as discriminator.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_73\n\nLANGUAGE: typescript\nCODE:\n```\ntype Message =\n  | { __kind: \"quit\" } // Empty variant.\n  | { __kind: \"write\"; fields: [string] } // Tuple variant.\n  | { __kind: \"move\"; x: number; y: number }; // Struct variant.\n```\n\n----------------------------------------\n\nTITLE: Parsing Base64 RPC Account in TypeScript\nDESCRIPTION: Shows how to use parseBase64RpcAccount function to parse a base64-encoded account from RPC into a MaybeEncodedAccount type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddress = address('1234..5678');\nconst myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\nconst myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n```\n\n----------------------------------------\n\nTITLE: Parsing Base58 RPC Account in TypeScript\nDESCRIPTION: Demonstrates the usage of parseBase58RpcAccount function to parse a base58-encoded account from RPC into a MaybeEncodedAccount type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddress = address('1234..5678');\nconst myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\nconst myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Message Lifetime with Blockhash\nDESCRIPTION: Demonstrates setting a transaction message's lifetime using a blockhash and last valid block height\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n\nconst { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\nconst txWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);\n```\n\n----------------------------------------\n\nTITLE: Creating Tree Walker Response Transformer - TypeScript\nDESCRIPTION: Creates a transformer for traversing the JSON response and executing provided visitor functions at each node. It allows for a customized traversal of the structure, enabling developers to manipulate the response data flexibly.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getTreeWalkerResponseTransformer } from '@solana/rpc-transformers';\n\nconst responseTransformer = getTreeWalkerResponseTransformer(\n    [\n        // Replaces foo.bar with \"baz\".\n        (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n        // Increments all numbers by 1.\n        node => (typeof node === number ? node + 1 : node),\n    ],\n    { keyPath: [] },\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Transfer Instruction using Kit\nDESCRIPTION: This snippet illustrates how to create a transfer instruction using the Kit framework. It utilizes the getTransferSolInstruction function to create the instruction while making use of the createNoopSigner function to handle the source account.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, createNoopSigner } from \"@solana/kit\";\nimport { getTransferSolInstruction } from \"@solana-program/system\";\n\nconst transferSol = getTransferSolInstruction({\n  source: createNoopSigner(address(\"2222..2222\")),\n  destination: address(\"3333..3333\"),\n  amount: 1_000_000_000, // 1 SOL.\n});\n```\n\n----------------------------------------\n\nTITLE: Error Handling in TypeScript with Context Refinement\nDESCRIPTION: Shows how to catch and handle Solana errors with TypeScript, demonstrating error code checking and context type refinement for specific error scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    isSolanaError,\n} from '@solana/errors';\nimport { assertTransactionIsFullySigned, getSignatureFromTransaction } from '@solana/transactions';\n\ntry {\n    const transactionSignature = getSignatureFromTransaction(tx);\n    assertTransactionIsFullySigned(tx);\n    /* ... */\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n        displayError(\n            \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n            e.context.addresses.join('\\n- '),\n        );\n        return;\n    } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n        if (!tx.feePayer) {\n            displayError('Choose a fee payer for this transaction before sending it');\n        } else {\n            displayError('The fee payer still needs to sign for this transaction');\n        }\n        return;\n    }\n    throw e;\n}\n```\n\n----------------------------------------\n\nTITLE: Using assertIsKeyPairSigner Type Guard in TypeScript\nDESCRIPTION: This code demonstrates how to use the `assertIsKeyPairSigner` type guard, which throws an error if the provided value is not a `KeyPairSigner`. It's useful for ensuring a value is of the correct type at runtime.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst myKeyPairSigner = await generateKeyPairSigner();\nassertIsKeyPairSigner(myKeyPairSigner); // ✅ void\nassertIsKeyPairSigner({ address: address('1234..5678') }); // ❌ Throws an error.\n\n```\n\n----------------------------------------\n\nTITLE: Combined Optimization Techniques in GraphQL for Solana Accounts\nDESCRIPTION: This GraphQL query demonstrates the combination of batch loading and minimized network payloads. It requests specific data slices from two different accounts, which the resolver optimizes into a single RPC call.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_33\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        data(encoding: BASE_64, dataSlice: { length: 32, offset: 0 })\n    }\n    account(address: \"EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b\") {\n        authorityData: data(encoding: BASE_64, dataSlice: { length: 32, offset: 0 })\n        u64Data: data(encoding: BASE_64, dataSlice: { length: 8, offset: 32 })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Round Robin Transport\nDESCRIPTION: This snippet illustrates how to implement a round-robin transport mechanism to distribute requests among multiple RPC servers sequentially, improving response management.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RpcTransport } from '@solana/rpc-spec';\nimport { RpcResponse } from '@solana/rpc-spec-types';\nimport { createHttpTransport } from '@solana/rpc-transport-http';\n\nconst transports = [\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-1.com' }),\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-2.com' }),\n    createHttpTransport({ url: 'https://mainnet-beta.my-server-3.com' }),\n];\n\nlet nextTransport = 0;\nasync function roundRobinTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<RpcResponse<TResponse>> {\n    const transport = transports[nextTransport];\n    nextTransport = (nextTransport + 1) % transports.length;\n    return await transport(...args);\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy PublicKey to Address in Solana\nDESCRIPTION: This code demonstrates how to convert a legacy PublicKey object to the newer Address type using the fromLegacyPublicKey function from the @solana/compat package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/compat/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromLegacyPublicKey } from '@solana/compat';\nconst address = fromLegacyPublicKey(new PublicKey('49XBVQsvSW44ULKL9qufS9YqQPbdcps1TQRijx4FQ9sH'));\n```\n\n----------------------------------------\n\nTITLE: Defining BaseAccount Type in TypeScript\nDESCRIPTION: Shows how to create a BaseAccount object with common attributes for Solana accounts, such as executable status, lamports, program address, and space.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst BaseAccount: BaseAccount = {\n    executable: false,\n    lamports: lamports(1_000_000_000n),\n    programAddress: address('1111..1111'),\n    space: 42n,\n};\n```\n\n----------------------------------------\n\nTITLE: Using BaseX Codec with Custom Alphabet in TypeScript\nDESCRIPTION: Demonstrates how to use the getBaseXCodec function to create a custom base-X codec using a specified alphabet. It shows both basic usage and examples of applying size constraints with utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBaseXCodec(\"0ehlo\");\nconst bytes = codec.encode(\"hello\"); // 0x05bd\nconst value = codec.decode(bytes); // \"hello\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBaseXCodec(\"0ehlo\");\n\nfixCodecSize(codec, 4).encode(\"hello\");\n// 0x05bd0000 (padded to 4 bytes)\n\naddCodecSizePrefix(codec, getU32Codec()).encode(\"hello\");\n// 0x0200000005bd\n//   |       └-- The 2 bytes of content.\n//   └-- 4-byte prefix telling us to read 2 bytes.\n\naddCodecSentinel(codec, new Uint8Array([0xff, 0xff])).encode(\"hello\");\n// 0x05bdffff\n//   |   └-- The sentinel signaling the end of the content.\n//   └-- The 2 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a WebSocket Channel for Solana RPC in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a WebSocket channel using the createWebSocketChannel function, customize message handling, send a request, and handle responses and errors. It includes setting up an AbortController for managing the channel lifecycle.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\n\nconst abortController = new AbortController();\nconst webSocketChannel = await createWebSocketChannel({\n    sendBufferHighWatermark: Number.POSITIVE_INFINITY,\n    signal: abortController.signal,\n    url: 'wss://api.mainnet-beta.solana.com',\n});\nconst channel = {\n    ...webSocketChannel,\n    on(type, listener, options) {\n        if (type !== 'message') {\n            return webSocketChannel.on(type, listener, options);\n        }\n        return webSocketChannel.on(\n            'message',\n            function deserializingListener(message: string) {\n                const deserializedMessage = JSON.parse(message);\n                listener(deserializedMessage);\n            },\n            options,\n        );\n    },\n    send(message) {\n        const serializedMessage = JSON.stringify(message);\n        return webSocketChannel.send(serializedMessage);\n    },\n} as RpcSubscriptionsChannel<unknown, unknown>;\nchannel.on(\n    'error',\n    e => {\n        console.log('Received error', e);\n        abortController.abort();\n    },\n    { signal: abortController.signal },\n);\nchannel.on(\n    'message',\n    m => {\n        console.log('Received message', m);\n        abortController.abort();\n    },\n    { signal: abortController.signal },\n);\nawait channel.send({ id: 1, jsonrpc: '2.0', method: 'getSlot' });\n```\n\n----------------------------------------\n\nTITLE: Using Abort Signal with Transaction Signing\nDESCRIPTION: Shows how to provide an AbortSignal when signing transactions to allow cancellation of the signing process.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = await partiallySignTransactionMessageWithSigners(myTransactionMessage, {\n    abortSignal: myAbortController.signal,\n});\n```\n\n----------------------------------------\n\nTITLE: Combining resizeCodec with offsetCodec for Struct with Padding in TypeScript\nDESCRIPTION: Demonstrates how to combine resizeCodec and offsetCodec to create a struct codec with padding between fields. This example creates a person struct with a fixed-size name field and a 4-byte padding before the age field.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst personCodec = getStructCodec([\n    ['name', fixCodecSize(getUtf8Codec(), 8)],\n    // There is a 4-byte padding between name and age.\n    [\n        'age',\n        offsetCodec(\n            resizeCodec(getU32Codec(), size => size + 4),\n            { preOffset: ({ preOffset }) => preOffset + 4 },\n        ),\n    ],\n]);\n\npersonCodec.encode({ name: 'Alice', age: 42 });\n// 0x416c696365000000000000002a000000\n//   |               |       └-- Our encoded u32 (42).\n//   |               └-- The 4-bytes of padding we are skipping.\n//   └-- Our 8-byte encoded string (\"Alice\").\n```\n\n----------------------------------------\n\nTITLE: Implementing Padding with Encoders and Decoders\nDESCRIPTION: Shows how to use encoder-only and decoder-only padding helpers to create a combined codec. This demonstrates the use of padLeftEncoder, padLeftDecoder, and combineCodec to create a customized padded codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst getMyPaddedEncoder = () => padLeftEncoder(getU16Encoder());\nconst getMyPaddedDecoder = () => padLeftDecoder(getU16Decoder());\nconst getMyPaddedCodec = () => combineCodec(getMyPaddedEncoder(), getMyPaddedDecoder());\n```\n\n----------------------------------------\n\nTITLE: Using RPC Subscriptions API in TypeScript\nDESCRIPTION: Demonstrates how to use a RpcSubscriptions instance to subscribe to notifications. The example shows creating a subscription, handling the stream of notifications, and error handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-api/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcSubscriptions: RpcSubscriptions<ExampleApi> = createExampleRpcSubscriptions(/* ... */);\nconst thingNotifications = await rpc\n    .thingNotifications(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN'))\n    .subscribe({ abortSignal: AbortSignal.timeout(5_000) });\ntry {\n    for await (const thing of thingNotifications) {\n        console.log('Got a thing', thing);\n    }\n} catch (e) {\n    console.error('Our subscription to `Thing` notifications has failed', e);\n} finally {\n    console.log('We are done listening for `Thing` notifications');\n}\n```\n\n----------------------------------------\n\nTITLE: Commitment Comparator in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `commitmentComparator` function to sort transactions by their confirmation status. It imports the `commitmentComparator` from `@solana/rpc-types` and uses it as the comparison function in the `sort` method of an array of transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { commitmentComparator } from '@solana/rpc-types';\n\ntransactions.sort((a, b) => commitmentComparator(a.confirmationStatus, b.confirmationStatus));\n```\n\n----------------------------------------\n\nTITLE: Checking Wallet Balance\nDESCRIPTION: Demonstrates how to retrieve and display the balance of a newly created wallet using the client configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nasync function tutorial() {\n  const client = await createClient();\n  const { value: balance } = await client.rpc.getBalance(client.wallet.address).send();\n  console.log(`Balance: ${balance} lamports.`);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Instructions with GraphQL\nDESCRIPTION: Example of using GraphQL to query transaction data with specific commitment level. This demonstrates how to extract detailed instruction data from transactions using GraphQL's type system.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_46\n\nLANGUAGE: ts\nCODE:\n```\nconst source = `\n    query myQuery($signature: String!, $commitment: Commitment) {\n        transaction(signature: $signature, commitment: $commitment) {\n            message {\n                instructions {\n                    ... on CreateAccountInstruction {\n                        lamports\n                        programId\n                        space\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    signature: '63zkpxATgAwXRGFQZPDESTw2m4uZQ99sX338ibgKtTcgG6v34E3MSS3zckCwJHrimS71cvei6h1Bn1K1De53BNWC',\n    commitment: 'confirmed',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n\nexpect(result).toMatchObject({\n    data: {\n        transaction: {\n            message: {\n                instructions: expect.arrayContaining([\n                    {\n                        lamports: expect.any(BigInt),\n                        programId: '11111111111111111111111111111111',\n                        space: expect.any(BigInt),\n                    },\n                ]),\n            },\n        },\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback Logic for Transactions Without a SendingSigner in TypeScript\nDESCRIPTION: Demonstrates how to handle cases where a transaction might not have a designated sending signer. It uses isTransactionWithSingleSendingSigner to check if the direct method can be used, otherwise falls back to manually signing and sending the transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nlet transactionSignature: SignatureBytes;\nif (isTransactionWithSingleSendingSigner(transactionMessage)) {\n    transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n} else {\n    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n    const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n    transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n}\n```\n\n----------------------------------------\n\nTITLE: Using U16Codec to Encode/Decode Unsigned 16-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding unsigned 16-bit integers (from 0 to 65,535) using both little-endian (default) and big-endian representations. Returns number values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU16Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getU16Codec();\nconst bytes = codec.encode(42); // 0x2a00\nconst value = codec.decode(bytes); // 42\n\n// Big-endian.\nconst beCodec = getU16Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(42); // 0x002a\nconst beValue = beCodec.decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Encoding Discriminated Unions with Default u8 Size Prefix\nDESCRIPTION: Shows how to encode different variants of a discriminated union (empty, tuple, and struct) with the default u8 discriminator size prefix, including byte-by-byte explanation of the encoded output.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nmessageCodec.encode({ __kind: \"quit\" });\n// 0x00\n//   └-- 1-byte discriminator (Index 0 — the \"quit\" variant).\n\nmessageCodec.encode({ __kind: \"write\", fields: [\"Hi\"] });\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte discriminator (Index 1 — the \"write\" variant).\n\nmessageCodec.encode({ __kind: \"move\", x: 5, y: 6 });\n// 0x020500000006000000\n//   | |       └-- Field y (6).\n//   | └-- Field x (5).\n//   └-- 1-byte discriminator (Index 2 — the \"move\" variant).\n```\n\n----------------------------------------\n\nTITLE: Using Compatibility Utilities for Migrating from Web3.js to Kit\nDESCRIPTION: Demonstrates how to use the @solana/compat package to convert core types between Web3.js and Kit, enabling incremental migration of projects. Shows conversions for PublicKeys, Keypairs, TransactionInstructions, and VersionedTransactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport { Keypair, PublicKey } from \"@solana/web3.js\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\nimport {\n  fromLegacyKeypair,\n  fromLegacyPublicKey,\n  fromLegacyTransactionInstruction,\n  fromVersionedTransaction,\n} from \"@solana/compat\";\n\n// Convert `PublicKeys`.\nconst address = fromLegacyPublicKey(new PublicKey(\"1234..5678\"));\n\n// Convert `Keypairs`.\nconst cryptoKeypair = await fromLegacyKeypair(Keypair.generate());\nconst signer = await createSignerFromKeyPair(cryptoKeypair);\n\n// Convert `TransactionInstruction`.\nconst instruction = fromLegacyTransactionInstruction(transactionInstruction);\n\n// Convert `VersionedTransaction`.\nconst transaction = fromVersionedTransaction(versionedTransaction);\n```\n\n----------------------------------------\n\nTITLE: Batch Loading in GraphQL for Multiple Solana Accounts\nDESCRIPTION: This GraphQL query demonstrates batch loading by requesting information from two different accounts. The resolver optimizes this by using a single call to getMultipleAccounts RPC method instead of separate calls for each account.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_31\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        lamports\n        space\n    }\n    account(address: \"EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b\") {\n        ... on NonceAccount {\n            authority {\n                address\n            }\n            blockhash\n            feeCalculator {\n                lamportsPerSignature\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Signatures with assertIsSignature\nDESCRIPTION: Demonstrates how to validate a user-supplied signature string using assertIsSignature function, with error handling and RPC integration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertIsSignature } from '@solana/keys';\n\n// Imagine a function that asserts whether a user-supplied signature is valid or not.\nfunction handleSubmit() {\n    // We know only that what the user typed conforms to the `string` type.\n    const signature: string = signatureInput.value;\n    try {\n        // If this type assertion function doesn't throw, then\n        // Typescript will upcast `signature` to `Signature`.\n        assertIsSignature(signature);\n        // At this point, `signature` is a `Signature` that can be used with the RPC.\n        const {\n            value: [status],\n        } = await rpc.getSignatureStatuses([signature]).send();\n    } catch (e) {\n        // `signature` turned out not to be a base58-encoded signature\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPairSigner from Bytes in TypeScript\nDESCRIPTION: This code shows how to create a `KeyPairSigner` from a 64-byte `Uint8Array` secret key using `createKeyPairSignerFromBytes`. This is useful when loading key pairs from files.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport fs from 'fs';\nimport { createKeyPairFromBytes } from '@solana/keys';\n\n// Get bytes from local keypair file.\nconst keypairFile = fs.readFileSync('~/.config/solana/id.json');\nconst keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n\n// Create a KeyPairSigner from the bytes.\nconst signer = await createKeyPairSignerFromBytes(keypairBytes);\n\n```\n\n----------------------------------------\n\nTITLE: Using Base16 Codec in TypeScript\nDESCRIPTION: Shows how to use the getBase16Codec function to encode and decode Base16 (hexadecimal) strings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBase16Codec().encode('deadface'); // 0xdeadface\nconst value = getBase16Codec().decode(bytes); // \"deadface\"\n```\n\n----------------------------------------\n\nTITLE: Querying MintAccount and TokenAccount Types\nDESCRIPTION: This code snippet shows how to query for both `MintAccount` and `TokenAccount` types using GraphQL fragments and the `__typename` field. It iterates through a list of addresses, queries each address, and pushes the parsed account info to either the `mintAccounts` or `tokenAccounts` array based on the `__typename` returned in the query result.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst mintOrTokenAccountAddresses = [\n    'J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ',\n    'JAbWqZ7S2c6jomQr8ofAYBo257bE1QJtHwbX1yWc2osZ',\n    '2AQ4CSNu6zNUZsUq4aLNUSjyrLv4qFFXQuKs5RTHbg2Y',\n    'EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b',\n];\n\nconst mintAccounts = [];\nconst tokenAccounts = [];\n\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            ... on MintAccount {\n                __typename\n                decimals\n                isInitialized\n                supply\n            }\n            ... on TokenAccount {\n                __typename\n                isNative\n                mint\n                state\n            }\n        }\n    }\n`;\n\nfor (const address of mintOrTokenAccountAddresses) {\n    const result = await rpcGraphQL.query(source, { address });\n    if (result != null) {\n        const {\n            data: { account: accountParsedData },\n        } = result;\n        if (accountParsedData.__typename === 'MintAccount') {\n            mintAccounts.push(accountParsedInfo);\n        } else {\n            tokenAccounts.push(accountParsedInfo);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Sets with getSetCodec in TypeScript\nDESCRIPTION: Shows how to use getSetCodec to encode and decode sets, including examples with different size configurations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_97\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetCodec, getU8Codec } from \"@solana/kit\";\n\nconst codec = getSetCodec(getU8Codec());\nconst bytes = codec.encode(new Set([1, 2, 3])); // 0x03000000010203\nconst value = codec.decode(bytes); // new Set([1, 2, 3])\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetCodec, getU8Codec } from \"@solana/kit\";\n\ngetSetCodec(getU8Codec()).encode(new Set([1, 2, 3]));\n// 0x03000000010203\n//   |       └-- 3 items of 1 byte each.\n//   └-- 4-byte prefix telling us to read 3 items.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetCodec, getU8Codec, getU16Codec } from \"@solana/kit\";\n\ngetSetCodec(getU8Codec(), { size: getU16Codec() }).encode(new Set([1, 2, 3]));\n// 0x0300010203\n//   |   └-- 3 items of 1 byte each.\n//   └-- 2-byte prefix telling us to read 3 items.\n\ngetSetCodec(getU8Codec(), { size: 3 }).encode(new Set([1, 2, 3]));\n// 0x010203\n//   └-- 3 items of 1 byte each. There must always be 3 items in the set.\n\ngetSetCodec(getU8Codec(), { size: \"remainder\" }).encode(new Set([1, 2, 3]));\n// 0x010203\n//   └-- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n```\n\n----------------------------------------\n\nTITLE: Bypassing resizeCodec with write Function in TypeScript\nDESCRIPTION: Illustrates how the resizeCodec behavior is bypassed when using lower-level write functions. This shows the difference between using encode and write methods on a resized codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst getBiggerU32Codec = () => resizeCodec(getU32Codec(), size => size + 4);\n\n// Using the encode function.\ngetBiggerU32Codec().encode(42);\n// 0x2a00000000000000\n\n// Using the lower-level write function.\nconst myCustomBytes = new Uint8Array(4);\ngetBiggerU32Codec().write(42, myCustomBytes, 0);\n// 0x2a000000\n```\n\n----------------------------------------\n\nTITLE: Base58 Codec with Size Prefix\nDESCRIPTION: Implementation of a Base58 codec that includes its size as a U32 prefix.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ngetU32Base58Codec().encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Response Headers in Solana RPC Errors\nDESCRIPTION: This snippet demonstrates how to access HTTP response headers when catching a Solana RPC error, specifically for handling rate limit errors and retrieving the 'Retry-After' header value.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR)) {\n        if (e.context.code === 429 /* rate limit error */) {\n            const retryAfterHeaderValue = e.context.headers.get('Retry-After');\n            if (retryAfterHeaderValue != null) {\n                // ...\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Separate Encoder and Decoder Sentinels in TypeScript\nDESCRIPTION: Shows how to use the separate addEncoderSentinel and addDecoderSentinel functions for more fine-grained control over sentinel handling during encoding and decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\nconst value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Creating Transaction Messages in TypeScript\nDESCRIPTION: Demonstrates creating a transaction message using functional programming with pipe and various transform functions for building complex transactions\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from '@solana/functional';\nimport {\n    appendTransactionMessageInstruction,\n    createTransactionMessage,\n    setTransactionMessageFeePayer,\n    setTransactionMessageLifetimeUsingBlockhash,\n} from '@solana/transaction-messages';\n\nconst transferTransaction = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(myAddress, tx),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    tx => appendTransactionMessageInstruction(getTransferSolInstruction({ source, destination, amount }), tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Transaction Instructions in TypeScript\nDESCRIPTION: Example of querying for specific transaction instruction types within a Transaction response. This snippet demonstrates how to query for CreateAccountInstruction details using a transaction signature.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($signature: String!, $commitment: Commitment) {\n        transaction(signature: $signature, commitment: $commitment) {\n            message {\n                instructions {\n                    ... on CreateAccountInstruction {\n                        lamports\n                        programId\n                        space\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    signature: '63zkpxATgAwXRGFQZPDESTw2m4uZQ99sX338ibgKtTcgG6v34E3MSS3zckCwJHrimS71cvei6h1Bn1K1De53BNWC',\n    commitment: 'confirmed',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Building Transaction Messages with Functional Programming in TypeScript\nDESCRIPTION: This snippet shows how to use the @solana/functional library to build Solana transaction messages using a pipeline approach. It demonstrates creating a transaction message, setting the fee payer, and setting the lifetime using a recent blockhash.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pipe } from '@solana/functional';\nimport {\n    address,\n    createTransactionMessage,\n    setTransactionMessageFeePayer,\n    setTransactionMessageLifetimeUsingBlockhash,\n    Blockhash,\n} from '@solana/kit';\n\n// Use `pipe(..)` to create a pipeline of transaction message transformation operations\nconst transactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => setTransactionMessageLifetimeUsingBlockhash(recentBlockhash, tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Using U128Codec to Encode/Decode Unsigned 128-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding unsigned 128-bit integers (from 0 to 2^128 - 1) using both little-endian (default) and big-endian representations. Returns BigInt values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU128Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getU128Codec();\nconst bytes = codec.encode(42); // 0x2a000000000000000000000000000000\nconst value = codec.decode(bytes); // 42\n\n// Big-endian.\nconst beCodec = getU128Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(42); // 0x0000000000000000000000000000002a\nconst beValue = beCodec.decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Custom Codec Write Function in TypeScript @solana/kit\nDESCRIPTION: This snippet implements a custom write function for a codec, demonstrating writing encoded data into a byte array using createCodec from @solana/kit. It's essential for custom codec operations where encoding logic is distinct.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createCodec } from \"@solana/kit\";\nconst read = null as unknown as Parameters<typeof createCodec<number>>[0][\"read\"];\nconst fixedSize = null as unknown as 1;\ncreateCodec({\n  write(value: number, bytes, offset) {\n    bytes.set([value], offset);\n    return offset + 1;\n  },\n  read,\n  fixedSize,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for Solana development\nDESCRIPTION: JSON configuration for package.json, including scripts for starting the project and running a local Solana validator.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/setup.mdx#2025-04-18_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"kit-tutorial\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"tsx src/index.ts\",\n    \"validator\": \"solana-test-validator\"\n  },\n  \"dependencies\": {\n    \"@solana/kit\": \"^2.1.0\",\n    \"tsx\": \"^4.19.3\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Account Fetching Comparison - Web3.js vs Kit\nDESCRIPTION: Demonstrates how to fetch account information using both Web3.js and Kit approaches.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from \"@solana/web3.js\";\n\nconst wallet = new PublicKey(\"1234..5678\");\nconst account = await connection.getAccountInfo(wallet);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address } from \"@solana/kit\";\n\nconst wallet = address(\"1234..5678\");\nconst { value: account } = await rpc.getAccountInfo(wallet).send();\n```\n\n----------------------------------------\n\nTITLE: Using MaybeEncodedAccount Type for Encoded Accounts in TypeScript\nDESCRIPTION: Demonstrates the usage of MaybeEncodedAccount type for representing encoded accounts that may or may not exist on-chain.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Encoded account exists.\nconst myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n    exists: true,\n    address: address('1234..5678'),\n    data: new Uint8Array([1, 2, 3]),\n    // ...\n};\n\n// Encoded account does not exist.\nconst myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n    exists: false,\n    address: address('8765..4321'),\n};\n```\n\n----------------------------------------\n\nTITLE: Checking Account Existence in TypeScript\nDESCRIPTION: Demonstrates how to check if a fetched account exists and access its fields using TypeScript type narrowing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EncodedAccount, address, Address, fetchEncodedAccount, fetchEncodedAccounts } from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\n\nif (account.exists) {\n  // If it exists, we have access to all its fields.\n  account satisfies EncodedAccount<\"1234..5678\">;\n} else {\n  // Otherwise, we just know its address.\n  account satisfies { address: Address<\"1234..5678\">; exists: false };\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Failed vs. Aborted Subscriptions in Solana RPC\nDESCRIPTION: This demonstrates the difference between subscription failures and aborts in Solana RPC. A try/catch block is used to distinguish between a failure, which throws an error, and a graceful abort that exits the loop. The finally block allows running cleanup code for both scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\ntry {\n    for await (const notification of notifications) {\n        // Consume messages.\n    }\n    // [ABORTED] Reaching this line means the subscription was aborted — i.e. unsubscribed.\n} catch (e) {\n    // [FAILED] Reaching this line means the subscription went down.\n    // Retry it, then recover from potential missed messages.\n} finally {\n    // [ABORTED or FAILED] Whether the subscription failed or was aborted, you can run cleanup code here.\n}\n```\n\n----------------------------------------\n\nTITLE: Adding minContextSlot Option - Solana\nDESCRIPTION: Transaction signers' methods now take `minContextSlot` as an option in version 2.0.0. This allows signers, especially wallets that simulate transactions, to be aware of the slot at which the transaction was prepared. This ensures accurate simulation results by preventing simulations from running at an earlier-than-expected slot.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: N/A\nCODE:\n```\n``22a34aa`](https://github.com/solana-labs/solana-web3.js/commit/22a34aa08d1be7e9b43ccfea94a99eaa2694e491) Thanks [@steveluscher](https://github.com/steveluscher)! - Transaction signers' methods now take `minContextSlot` as an option. This is important for signers that simulate transactions, like wallets. They might be interested in knowing the slot at which the transaction was prepared, lest they run simulation at too early a slot.``\n```\n\n----------------------------------------\n\nTITLE: Creating Transaction with Web3.js\nDESCRIPTION: This code snippet demonstrates how to create a transaction using Web3.js. It fetches the latest blockhash and uses it along with the createAccount instruction and the initializeMint instruction to construct a complete transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey, SystemProgram, Transaction } from \"@solana/web3.js\";\nimport { createInitializeMintInstruction } from \"@solana/spl-token\";\n\nconst latestBlockhash = await connection.getLatestBlockhash();\nconst createAccount = SystemProgram.createAccount(createAccountInput);\nconst initializeMint = createInitializeMintInstruction(initializeMintInput);\n\nconst transaction = new Transaction({ feePayer, ...latestBlockhash }).add(createAccount).add(initializeMint);\n```\n\n----------------------------------------\n\nTITLE: Using Separate Offset Functions in TypeScript\nDESCRIPTION: Demonstrates how to use the separate offsetEncoder and offsetDecoder functions for tree-shaking. These functions provide the same functionality as offsetCodec but can be imported separately.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst getU32InTheMiddleEncoder = () => offsetEncoder(biggerU32Encoder, { preOffset: ({ preOffset }) => preOffset + 2 });\nconst getU32InTheMiddleDecoder = () => offsetDecoder(biggerU32Decoder, { preOffset: ({ preOffset }) => preOffset + 2 });\nconst getU32InTheMiddleCodec = () => combineCodec(getU32InTheMiddleEncoder(), getU32InTheMiddleDecoder());\n```\n\n----------------------------------------\n\nTITLE: Using Unit Codec in TypeScript\nDESCRIPTION: Demonstrates the use of getUnitCodec function to create a codec that encodes undefined into an empty Uint8Array and decodes any bytes to undefined.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ngetUnitCodec().encode(undefined); // Empty Uint8Array\ngetUnitCodec().decode(anyBytes); // undefined\n```\n\n----------------------------------------\n\nTITLE: Using Padding Codecs in TypeScript\nDESCRIPTION: Demonstrates how to use padLeftCodec and padRightCodec functions to add padding to encoded data. The example shows padding a U16 codec with 4 bytes on either the left or right side.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst getLeftPaddedCodec = () => padLeftCodec(getU16Codec(), 4);\ngetLeftPaddedCodec().encode(0xffff);\n// 0x00000000ffff\n//   |       └-- Our encoded u16 number.\n//   └-- Our 4-byte padding.\n\nconst getRightPaddedCodec = () => padRightCodec(getU16Codec(), 4);\ngetRightPaddedCodec().encode(0xffff);\n// 0xffff00000000\n//   |   └-- Our 4-byte padding.\n//   └-- Our encoded u16 number.\n```\n\n----------------------------------------\n\nTITLE: Declaring RpcRequestTransformer Type in TypeScript\nDESCRIPTION: Declares the RpcRequestTransformer type, a function that transforms an RpcRequest into another RpcRequest before sending to the RPC server.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec-types/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype RpcRequestTransformer = (request: RpcRequest) => RpcRequest;\n```\n\n----------------------------------------\n\nTITLE: Implementing Solana Airdrop\nDESCRIPTION: Sets up an airdrop function to fund a wallet with SOL tokens in test environments using RPC connections.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  airdropFactory,\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  generateKeyPairSigner,\n  lamports,\n} from \"@solana/kit\";\n\nconst rpc = createSolanaRpc(\"http://127.0.0.1:8899\");\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\"ws://127.0.0.1:8900\");\nconst airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\nconst wallet = await generateKeyPairSigner();\nawait airdrop({\n  recipientAddress: wallet.address,\n  lamports: lamports(1_000_000_000n),\n  commitment: \"confirmed\",\n});\n```\n\n----------------------------------------\n\nTITLE: Using Abortable Promise with Fetch Request\nDESCRIPTION: Demonstrates how to create an abortable promise that will automatically reject if an abort signal is triggered. The example shows fetching JSON data with a 5-second timeout.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/promises/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await getAbortablePromise(\n    // Resolves or rejects when `fetch` settles.\n    fetch('https://example.com/json').then(r => r.json()),\n    // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n    AbortSignal.timeout(5000),\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Nested Account Owners Recursively with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet demonstrates a recursive query structure to navigate multiple levels of ownership in account data, showcasing how to access deeply nested properties through continuous querying.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            address\n            owner {\n                address\n                owner {\n                    address\n                    owner {\n                        address\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Estimating Compute Units for Transaction Messages in TypeScript\nDESCRIPTION: Shows how to use the getComputeUnitEstimateForTransactionMessageFactory to estimate and set the compute unit limit for a transaction message, which can improve transaction acceptance probability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\nimport { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n\n// Create an estimator function.\nconst rpc = createSolanaRpc('http://127.0.0.1:8899');\nconst getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({\n    rpc,\n});\n\n// Create your transaction message.\nconst transactionMessage = pipe(\n    createTransactionMessage({ version: 'legacy' }),\n    /* ... */\n);\n\n// Request an estimate of the actual compute units this message will consume. This is done by\n// simulating the transaction and grabbing the estimated compute units from the result.\nconst computeUnitsEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n\n// Set the transaction message's compute unit budget.\nconst transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n    getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n    transactionMessage\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data with Transaction Details in TypeScript\nDESCRIPTION: Example of querying block data including block metadata and transaction details. This demonstrates how to query for block information and specific instruction types within transactions in that block.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($slot: BigInt!, $commitment: Commitment) {\n        block(slot: $slot, commitment: $commitment) {\n            blockHeight\n            blockhash\n            parentSlot\n            rewards {\n                commission\n                lamports\n                rewardType\n            }\n            transactions {\n                message {\n                    instructions {\n                        ... on CreateAccountInstruction {\n                            lamports\n                            programId\n                            space\n                        }\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    slot: 43596n,\n    commitment: 'confirmed',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Adding Transaction Instructions\nDESCRIPTION: Appends multiple instructions to the transaction message using the appendTransactionMessageInstructions function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { value: latestBlockhash } = await client.rpc.getLatestBlockhash().send();\n\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n  (tx) => setTransactionMessageFeePayerSigner(client.wallet, tx),\n  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  (tx) => appendTransactionMessageInstructions([createAccountIx, initializeMintIx], tx),\n);\n```\n\n----------------------------------------\n\nTITLE: Using resizeCodec with Fixed and Variable-size Codecs in TypeScript\nDESCRIPTION: Demonstrates how to use the resizeCodec helper to modify the size of both fixed-size and variable-size codecs. The function accepts the original codec and a function that takes the current size and returns a new size.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { resizeCodec, getU32Codec, getUtf8Codec } from \"@solana/kit\";\n// Fixed-size codec.\nconst getBiggerU32Codec = () => resizeCodec(getU32Codec(), (size) => size + 4);\ngetBiggerU32Codec().encode(42);\n// 0x2a00000000000000\n//   |       └-- Empty buffer space caused by the resizeCodec function.\n//   └-- Our encoded u32 number.\n\n// Variable-size codec.\nconst getBiggerUtf8Codec = () => resizeCodec(getUtf8Codec(), (size) => size + 4);\ngetBiggerUtf8Codec().encode(\"ABC\");\n// 0x41424300000000\n//   |     └-- Empty buffer space caused by the resizeCodec function.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Calibrating Transaction Message Compute Unit Budget in TypeScript\nDESCRIPTION: This snippet demonstrates how to estimate and set the compute unit limit for a Solana transaction message. It uses the createSolanaRpc and getComputeUnitEstimateForTransactionMessageFactory functions to create an estimator, then applies the estimate to the transaction message.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\nimport { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n\n// Create an estimator function.\nconst rpc = createSolanaRpc('http://127.0.0.1:8899');\nconst getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({\n    rpc,\n});\n\n// Create your transaction message.\nconst transactionMessage = pipe(\n    createTransactionMessage({ version: 'legacy' }),\n    /* ... */\n);\n\n// Request an estimate of the actual compute units this message will consume.\nconst computeUnitsEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n\n// Set the transaction message's compute unit budget.\nconst transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n    getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n    transactionMessage,\n);\n```\n\n----------------------------------------\n\nTITLE: Adding a Codec Size Prefix Using TypeScript\nDESCRIPTION: The `addCodecSizePrefix` function is designed to prep an encoded codec with a size prefix, crucial for variable-length codecs. It helps to manage the size of the actual encoded data distinctly.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCodecSizePrefix, getBase58Codec, getU32Codec } from \"@solana/kit\";\n// ---cut-before---\nconst getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ngetU32Base58Codec().encode(\"hello world\");\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addEncoderSizePrefix,\n  addDecoderSizePrefix,\n  getBase58Encoder,\n  getBase58Decoder,\n  getU32Encoder,\n  getU32Decoder,\n  combineCodec,\n} from \"@solana/kit\";\n// ---cut-before---\nconst getU32Base58Encoder = () => addEncoderSizePrefix(getBase58Encoder(), getU32Encoder());\nconst getU32Base58Decoder = () => addDecoderSizePrefix(getBase58Decoder(), getU32Decoder());\nconst getU32Base58Codec = () => combineCodec(getU32Base58Encoder(), getU32Base58Decoder());\n```\n\n----------------------------------------\n\nTITLE: Merging Account Roles Example in TypeScript\nDESCRIPTION: Example demonstrating how to merge two account roles to get the highest privileges of both\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Returns `AccountRole.WRITABLE_SIGNER`\nmergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Codec Write Function\nDESCRIPTION: Example of implementing the write function for a custom codec that writes a single byte value.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ncreateCodec({\n    write(value, bytes, offset) {\n        bytes.set(value, offset);\n        return offset + 1;\n    },\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Using Size-Prefixed UTF-8 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the addCodecSizePrefix function with a UTF-8 codec to create a size-prefixed string codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n\ncodec.encode('hello');\n// 0x0500000068656c6c6f\n//   |       └-- The 5 bytes of content.\n//   └-- 4-byte prefix telling us to read 5 bytes.\n\ncodec.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0xff, 0xff, 0xff, 0xff]));\n// \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping Nullable Values as Options in TypeScript\nDESCRIPTION: Demonstrates the use of wrapNullable helper function to transform T | null into Option<T>.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nwrapNullable('Hello world'); // Some<string>\nwrapNullable(null); // None\n```\n\n----------------------------------------\n\nTITLE: Using Separate Hidden Prefix/Suffix Encoder and Decoder in TypeScript\nDESCRIPTION: Shows how to use separate functions for hidden prefix and suffix encoders and decoders.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ngetHiddenPrefixEncoder(encoder, prefixedEncoders);\ngetHiddenPrefixEncoder(decoder, prefixedDecoders);\ngetHiddenSuffixEncoder(encoder, suffixedEncoders);\ngetHiddenSuffixEncoder(decoder, suffixedDecoders);\n```\n\n----------------------------------------\n\nTITLE: Asserting Lamports Type in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `assertIsLamports` function to validate and upcast a number to the `Lamports` type. It takes a number obtained from user input, validates it using `assertIsLamports`, and then uses the validated value in a transfer function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertIsLamports } from '@solana/rpc-types';\n\n// Imagine a function that creates a transfer instruction when a user submits a form.\nfunction handleSubmit() {\n    // We know only that what the user typed conforms to the `number` type.\n    const lamports: number = parseInt(quantityInput.value, 10);\n    try {\n        // If this type assertion function doesn't throw, then\n        // Typescript will upcast `lamports` to `Lamports`.\n        assertIsLamports(lamports);\n        // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n        await transfer(fromAddress, toAddress, lamports);\n    } catch (e) {\n        // `lamports` turned out not to validate as a quantity of Lamports.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Data via Signature with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet demonstrates how to retrieve transaction data using its signature, focusing on block time, metadata, and the slot at which the transaction occurred. The result format shows detailed transaction logs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($signature: String!) {\n        transaction(signature: $signature) {\n            blockTime\n            meta {\n                computeUnitsConsumed\n                logMessages\n            }\n            slot\n        }\n    }\n`;\n\nconst variableValues = {\n    signature: '63zkpxATgAwXRGFQZPDESTw2m4uZQ99sX338ibgKtTcgG6v34E3MSS3zckCwJHrimS71cvei6h1Bn1K1De53BNWC',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Example of Caching Benefits in GraphQL Queries\nDESCRIPTION: GraphQL query example demonstrating how caching works when querying the same resource multiple times, ensuring no duplicate RPC requests are made when accessing the same account data at different query paths.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_28\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        lamports\n        data(encoding: BASE_64)\n        ... on MintAccount {\n            mintAuthority {\n                lamports\n                data(encoding: BASE_64)\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Options with getOptionCodec in TypeScript\nDESCRIPTION: Demonstrates how to use getOptionCodec to encode and decode optional values, including examples with different prefix and noneValue configurations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, getU32Codec, addCodecSizePrefix, getUtf8Codec, some, none } from \"@solana/kit\";\nconst stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n\ngetOptionCodec(stringCodec).encode(\"Hi\");\ngetOptionCodec(stringCodec).encode(some(\"Hi\"));\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte prefix (Some).\n\ngetOptionCodec(stringCodec).encode(null);\ngetOptionCodec(stringCodec).encode(none());\n// 0x00\n//   └-- 1-byte prefix (None).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, getU32Codec, addCodecSizePrefix, getUtf8Codec, some, none } from \"@solana/kit\";\nconst stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n\nconst u32OptionStringCodec = getOptionCodec(stringCodec, {\n  prefix: getU32Codec(),\n});\n\nu32OptionStringCodec.encode(some(\"Hi\"));\n// 0x01000000020000004869\n//   └------┘ 4-byte prefix (Some).\n\nu32OptionStringCodec.encode(none());\n// 0x00000000\n//   └------┘ 4-byte prefix (None).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, fixCodecSize, getUtf8Codec, some, none } from \"@solana/kit\";\n\nconst codec = getOptionCodec(\n  fixCodecSize(getUtf8Codec(), 8), // Only works with fixed-size items.\n  { noneValue: \"zeroes\" },\n);\n\ncodec.encode(some(\"Hi\"));\n// 0x014869000000000000\n//   | └-- 8-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (Some).\n\ncodec.encode(none());\n// 0x000000000000000000\n//   | └-- 8-byte of padding to make a fixed-size codec.\n//   └-- 1-byte prefix (None).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, getUtf8Codec, some, none } from \"@solana/kit\";\n\nconst codec = getOptionCodec(getUtf8Codec(), {\n  noneValue: new Uint8Array([255]), // 0xff means None.\n});\n\ncodec.encode(some(\"Hi\"));\n// 0x014869\n//   | └-- 2-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (Some).\n\ncodec.encode(none());\n// 0x00ff\n//   | └-- 1-byte representing None (0xff).\n//   └-- 1-byte prefix (None).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, getU16Codec, some, none } from \"@solana/kit\";\n\nconst codecWithZeroNoneValue = getOptionCodec(getU16Codec(), {\n  noneValue: \"zeroes\", // 0x0000 means None.\n  prefix: null,\n});\ncodecWithZeroNoneValue.encode(some(42)); // 0x2a00\ncodecWithZeroNoneValue.encode(none()); // 0x0000\n\nconst codecWithCustomNoneValue = getOptionCodec(getU16Codec(), {\n  noneValue: new Uint8Array([255]), // 0xff means None.\n  prefix: null,\n});\ncodecWithCustomNoneValue.encode(some(42)); // 0x2a00\ncodecWithCustomNoneValue.encode(none()); // 0xff\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getOptionCodec, getU16Codec, some, none } from \"@solana/kit\";\n\nconst codec = getOptionCodec(getU16Codec(), { prefix: null });\ncodec.encode(some(42)); // 0x2a00\ncodec.encode(none()); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // some(42)\ncodec.decode(new Uint8Array([])); // none()\n```\n\n----------------------------------------\n\nTITLE: Using transformCodec for Default Values in Struct Codecs in TypeScript\nDESCRIPTION: Shows how to use transformCodec to provide default values for struct fields. This example creates a Person codec that makes the age field optional by providing a default value of 42.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transformCodec, getStructCodec, Codec } from \"@solana/kit\";\ntype Person = { name: string; age: number };\ntype PersonInput = { name: string; age?: number };\nconst getPersonWithDefaultValueCodec = (): Codec<PersonInput, Person> =>\n  transformCodec(getPersonCodec(), (person: PersonInput): Person => ({ ...person, age: person.age ?? 42 }));\n```\n\n----------------------------------------\n\nTITLE: Querying Account Data with Variable Address\nDESCRIPTION: This code snippet shows how to query account data using the `query` method of the `RpcGraphQL` client, passing an account address as a variable. The GraphQL query uses the `$address` variable, and the `variableValues` object is passed to `rpcGraphQL.query(source, variableValues)`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            lamports\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Fetching and Decoding Sysvar Data in Typescript\nDESCRIPTION: This snippet shows how to directly fetch and decode sysvar data using a convenience function. It uses the `fetchSysvarClock` function with an RPC client to retrieve the decoded `SysvarClock` data. This simplifies the process of accessing sysvar data by combining fetching and decoding into a single step.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst clock: SysvarClock = await fetchSysvarClock(rpc);\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: This shell command installs the second Technology Preview version of the @solana/web3.js 2.0 library. The npm package manager is required as a prerequisite. This specific version integrates new features, bug fixes, and updates to improve the client-side JavaScript interaction with Solana on-chain programs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec-types/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Tree-shakeable Type Transformation with transformEncoder and transformDecoder in TypeScript\nDESCRIPTION: Demonstrates how to create tree-shakeable transform functions using transformEncoder and transformDecoder. This separates the mapping logic for encoding and decoding, allowing better optimization.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transformEncoder, transformDecoder, getU32Encoder, getU32Decoder, combineCodec } from \"@solana/kit\";\nconst getStringU32Encoder = () =>\n  transformEncoder(getU32Encoder(), (integerAsString: string): number => parseInt(integerAsString));\nconst getStringU32Decoder = () => transformDecoder(getU32Decoder(), (integer: number): string => integer.toString());\nconst getStringU32Codec = () => combineCodec(getStringU32Encoder(), getStringU32Decoder());\n```\n\n----------------------------------------\n\nTITLE: Decoding Mint Account using Program Client in TypeScript\nDESCRIPTION: Shows how to use the getMintCodec helper from @solana-program/token to decode a Mint account.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, assertAccountExists, fetchEncodedAccount } from \"@solana/kit\";\nimport { getMintCodec, Mint } from \"@solana-program/token\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\nconst mintCodec = getMintCodec();\nconst decodedData = mintCodec.decode(account.data);\ndecodedData satisfies Mint;\n```\n\n----------------------------------------\n\nTITLE: Encoding Signed Integers in TypeScript\nDESCRIPTION: Shows how to use signed integer codecs to encode negative values of different byte sizes. The default endianness is little-endian.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Signed integers.\ngetI8Codec().encode(-42); // 0xd6\ngetI16Codec().encode(-42); // 0xd6ff\ngetI32Codec().encode(-42); // 0xd6ffffff\ngetI64Codec().encode(-42); // 0xd6ffffffffffffff\ngetI128Codec().encode(-42); // 0xd6ffffffffffffffffffffffffffffff\n```\n\n----------------------------------------\n\nTITLE: Separate Literal Union Encoder/Decoder\nDESCRIPTION: This snippet shows how to use separate encoder and decoder functions for literal unions using `getLiteralUnionEncoder` and `getLiteralUnionDecoder`. It encodes and decodes the 'left' value. It depends on `getLiteralUnionEncoder` and `getLiteralUnionDecoder`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getLiteralUnionEncoder(['left', 'right']).encode('left'); // 0x00\nconst value = getLiteralUnionDecoder(['left', 'right']).decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Enum Encoding with Different Input Types\nDESCRIPTION: Shows how getEnumCodec can encode enums using both enum values and string keys, producing identical binary output for equivalent inputs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\ngetEnumCodec(Direction).encode(Direction.Left); // 0x00\ngetEnumCodec(Direction).encode(Direction.Right); // 0x01\ngetEnumCodec(Direction).encode(\"Left\"); // 0x00\ngetEnumCodec(Direction).encode(\"Right\"); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Using Fast Stable Stringify in JavaScript\nDESCRIPTION: Example showing how to import and use the fast-stable-stringify library to create a deterministic JSON string with keys sorted alphabetically. This example demonstrates stringifying an object with keys in random order.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/fast-stable-stringify/README.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport stringify from '@solana/fast-stable-stringify';\nstringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n```\n\n----------------------------------------\n\nTITLE: Enforcing SOL to Lamports Conversion in TypeScript\nDESCRIPTION: Shows how TypeScript enforces the use of lamports() for SOL to lamport conversion in transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst airdropAmount = 1n; // SOL\nconst signature = rpc.requestAirdrop(myAddress, airdropAmount).send();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst airdropAmount = lamports(1000000000n);\nconst signature = rpc.requestAirdrop(myAddress, airdropAmount).send();\n```\n\n----------------------------------------\n\nTITLE: Creating SignableMessage with Different Options\nDESCRIPTION: Shows various ways to create a SignableMessage with content and optional signatures\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMessage = createSignableMessage(new Uint8Array([1, 2, 3]));\nconst myMessageFromText = createSignableMessage('Hello world!');\nconst myMessageWithSignatures = createSignableMessage('Hello world!', {\n    '1234..5678': new Uint8Array([1, 2, 3]),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Codec in TypeScript @solana/kit\nDESCRIPTION: Explores creating a custom codec by implementing custom read and write functions determining how to read from and write to byte arrays, showcasing the usage of createCodec functionality. Requires @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createCodec, Offset } from \"@solana/kit\";\nconst write = null as unknown as Parameters<typeof createCodec<number>>[0][\"write\"];\nconst fixedSize = null as unknown as 1;\ncreateCodec({\n  read(bytes, offset) {\n    const value = bytes[offset];\n    return [value, offset + 1];\n  },\n  write,\n  fixedSize,\n});\n```\n\n----------------------------------------\n\nTITLE: Basic nullable codec usage in TypeScript\nDESCRIPTION: Demonstrates the getNullableCodec function which creates a codec that can handle null values. By default, it uses a u8 boolean prefix to indicate if the value exists.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n\ngetNullableCodec(stringCodec).encode(\"Hi\");\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte prefix (true — The item exists).\n\ngetNullableCodec(stringCodec).encode(null);\n// 0x00\n//   └-- 1-byte prefix (false — The item is null).\n```\n\n----------------------------------------\n\nTITLE: Creating BigInt Downcast Request Transformer - TypeScript\nDESCRIPTION: Creates a transformer that downcasts all BigInt values to Number types. This is useful for handling numbers that exceed JavaScript's safe integer limit during RPC interactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n\nconst requestTransformer = getBigIntDowncastRequestTransformer();\n```\n\n----------------------------------------\n\nTITLE: Querying Program Accounts with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet shows how to query program accounts from the blockchain using RPC-GraphQL, specifying the program's address and returning account details such as executable, lamports, and rentEpoch. The query is built using a GraphQL template string.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($programAddress: String!) {\n        programAccounts(programAddress: $address) {\n            executable\n            lamports\n            rentEpoch\n        }\n    }\n`;\n\nconst variableValues = {\n    programAddress: 'AmtpVzo6H6qQCP9dH9wfu5hfa8kKaAFpTJ4aamPYR6V6',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Validating Signatures with Type Guard\nDESCRIPTION: Demonstrates using the isSignature type guard to validate and refine signature types with RPC integration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSignature } from '@solana/keys';\n\nif (isSignature(signature)) {\n    // At this point, `signature` has been refined to a\n    // `Signature` that can be used with the RPC.\n    const {\n        value: [status],\n    } = await rpc.getSignatureStatuses([signature]).send();\n    setSignatureStatus(status);\n} else {\n    setError(`${signature} is not a transaction signature`);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic TypeScript Variable Declaration\nDESCRIPTION: Demonstrates basic mutable variable declaration in TypeScript to introduce immutability concepts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet person = { name: \"Alice\" };\n```\n\n----------------------------------------\n\nTITLE: Upgrading Fee Payer in Transaction Message - Solana\nDESCRIPTION: This patch change in version 2.1.0 ensures that the `addSignersToTransactionMessage` function upgrades the `feePayer` to a signer when applicable. This resolves a potential issue where the fee payer was not correctly recognized as a signer in certain scenarios. The change improves the robustness of transaction construction and signing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n``a1e45a1`](https://github.com/anza-xyz/kit/commit/a1e45a1d91ba1ac530eea0986b2ffeafb9713aec) Thanks [@lorisleiva](https://github.com/lorisleiva)! - `addSignersToTransactionMessage` now upgrades `feePayer` to a signer when applicable``\n```\n\n----------------------------------------\n\nTITLE: Asserting Account Existence in TypeScript\nDESCRIPTION: Shows how to use the assertAccountExists function to assert that a MaybeAccount exists and narrow its type to Account.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAccount: MaybeEncodedAccount<'1234..5678'>;\nassertAccountExists(myAccount);\n\n// Now we can use myAccount as an Account.\nmyAccount satisfies EncodedAccount<'1234..5678'>;\n```\n\n----------------------------------------\n\nTITLE: Enforcing matching clusters for signature confirmation in Solana web3.js\nDESCRIPTION: This patch modifies `createRecentSignatureConfirmationPromiseFactory` to ensure that `rpc` and `rpcSubscriptions` have matching clusters within Solana web3.js. The function signature is changed to accept an object instead of two separate parameters.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Data Enum Codec with Number Discriminators\nDESCRIPTION: Demonstrates creating a data enum codec using numbers or enum values as discriminators\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getDataEnumCodec([[1, getStructCodec([[['one', u32]]])][(2, getStructCodec([[['two', u32]]]))]]);\\n\\ncodec.encode({ __kind: 1, one: 42 });\\ncodec.encode({ __kind: 2, two: 42 });\n```\n\n----------------------------------------\n\nTITLE: Hidden Prefix Codec Implementation\nDESCRIPTION: Shows how to use getHiddenPrefixCodec to prepend hidden data before the main codec data during encoding while maintaining clean types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getHiddenPrefixCodec(getU16Codec(), [\n  getConstantCodec(new Uint8Array([1, 2, 3])),\n  getConstantCodec(new Uint8Array([4, 5, 6])),\n]);\n\ncodec.encode(42);\ncodec.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 42, 0]));\n```\n\n----------------------------------------\n\nTITLE: Defining Instruction with Multiple Accounts in TypeScript\nDESCRIPTION: Example showing how to type an instruction that requires two specific account types\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype InstructionWithTwoAccounts = IInstructionWithAccounts<\n    [\n        WritableAccount, // First account\n        RentSysvar, // Second account\n    ]\n>;\n```\n\n----------------------------------------\n\nTITLE: Configuring getBooleanCodec with Different Number Codecs\nDESCRIPTION: Shows how to configure getBooleanCodec with different number codecs to control how the boolean values are encoded and decoded.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_69\n\nLANGUAGE: typescript\nCODE:\n```\ngetBooleanCodec({ size: getU16Codec() }).encode(false); // 0x0000\ngetBooleanCodec({ size: getU16Codec() }).encode(true); // 0x0100\n\ngetBooleanCodec({ size: getU32Codec() }).encode(false); // 0x00000000\ngetBooleanCodec({ size: getU32Codec() }).encode(true); // 0x01000000\n```\n\n----------------------------------------\n\nTITLE: Type Transformation with transformCodec in TypeScript\nDESCRIPTION: Shows how to transform a codec from one type to another using transformCodec. This example converts between a U32 number and its string representation by providing mapping functions in both directions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transformCodec, getU32Codec } from \"@solana/kit\";\nconst getStringU32Codec = () =>\n  transformCodec(\n    getU32Codec(),\n    (integerAsString: string): number => parseInt(integerAsString),\n    (integer: number): string => integer.toString(),\n  );\n\ngetStringU32Codec().encode(\"42\"); // new Uint8Array([42])\ngetStringU32Codec().decode(new Uint8Array([42])); // \"42\"\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Transaction Signing with Compile-Time Validation\nDESCRIPTION: Demonstrates how the signTransaction function uses TypeScript to enforce that a transaction message has both a fee payer and a lifetime before signing. This helps catch errors at author-time rather than runtime.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst feePayer = await generateKeyPair();\nconst feePayerAddress = await getAddressFromPublicKey(feePayer.publicKey);\n\nconst transactionMessage = createTransactionMessage({ version: 'legacy' });\nconst transactionMessageWithFeePayer = setTransactionMessageFeePayer(feePayerAddress, transactionMessage);\n\n// Attempting to sign the transaction message without a lifetime will throw a type error\nconst signedTransaction = await signTransaction([signer], transactionMessageWithFeePayer);\n// => \"Property 'lifetimeConstraint' is missing in type\"\n```\n\n----------------------------------------\n\nTITLE: Aborting Solana RPC Subscriptions with AbortController in TypeScript\nDESCRIPTION: This snippet shows how to abort Solana RPC subscriptions using AbortController by setting a timeout for the subscription lifecycle. An AbortSignal is used to terminate the subscription after 5 seconds, demonstrating how to properly clean up unused subscriptions. This requires the '@solana/kit' package and a connection to a Solana RPC server.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createSolanaRpcSubscriptions } from '@solana/kit';\n\nconst rpcSubscriptions = createSolanaRpcSubscriptions('ws://127.0.0.1:8900');\n\n// Subscribe for slot notifications using an AbortSignal that times out after 5 seconds.\nconst slotNotifications = await rpcSubscriptions\n    .slotNotifications()\n    .subscribe({ abortSignal: AbortSignal.timeout(5000) });\n\n// Log slot notifications.\nfor await (const notification of slotNotifications) {\n    console.log('Slot notification', notification);\n}\n\nconsole.log('Done.');\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy TransactionInstruction to IInstruction in Solana\nDESCRIPTION: This code shows how to convert a legacy TransactionInstruction object to an IInstruction object using the fromLegacyTransactionInstruction function from the @solana/compat package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/compat/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromLegacyTransactionInstruction } from '@solana/compat';\n\n// imagine a function that returns a legacy `TransactionInstruction`\nconst legacyInstruction = getMyLegacyInstruction();\nconst instruction = fromLegacyTransactionInstruction(legacyInstruction);\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions with Web3.js\nDESCRIPTION: Demonstrates how to create keypairs, and send a signed transaction to the Solana network using Web3.js' sendAndConfirmTransaction method which handles both sending and waiting for confirmation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\nimport { Keypair, sendAndConfirmTransaction } from \"@solana/web3.js\";\n\n// Create keypairs.\nconst payer = Keypair.generate();\nconst mint = Keypair.generate();\n\n// Sign, send and confirm the transaction.\nconst transactionSignature = await sendAndConfirmTransaction(connection, transaction, [feePayer, mint]);\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Account Types with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet queries for specific account types within a program's accounts using inline fragments for multiple account types like MintAccount and TokenAccount, collecting the parsed information into distinct arrays.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($programAddress: String!) {\n        programAccounts(programAddress: $address) {\n            ... on MintAccount {\n                __typename\n                decimals\n                isInitialized\n                mintAuthority\n                supply\n            }\n            ... on TokenAccount {\n                __typename\n                isNative\n                mint\n                owner\n                state\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    programAddress: 'AmtpVzo6H6qQCP9dH9wfu5hfa8kKaAFpTJ4aamPYR6V6',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n\nconst { mints, tokenAccounts } = result.data.programAccounts.reduce(\n    (acc: { mints: any[]; tokenAccounts: any[] }, account) => {\n        if (account.__typename === 'MintAccount') {\n            acc.mints.push(accountParsedInfo);\n        } else {\n            acc.tokenAccounts.push(accountParsedInfo);\n        }\n        return acc;\n    },\n    { mints: [], tokenAccounts: [] },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing MessagePartialSigner Interface\nDESCRIPTION: Shows how to create a custom MessagePartialSigner with a specific address and signing logic\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMessagePartialSigner: MessagePartialSigner<'1234..5678'> = {\n    address: address('1234..5678'),\n    signMessages: async (messages: SignableMessage[]): Promise<SignatureDictionary[]> => {\n        // My custom signing logic.\n    },\n};\n```\n\n----------------------------------------\n\nTITLE: Catching Missing Fee Payer Error in TypeScript\nDESCRIPTION: Demonstrates how TypeScript catches a missing fee payer in a transaction message at compile time.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionMessage = pipe(createTransactionMessage({ version: 0 }), tx =>\n    setTransactionMessageLifetimeUsingBlockhash(recentBlockhash, tx),\n);\nconst signedTransaction = await signTransaction([keyPair], transactionMessage); // ERROR: Property 'feePayer' is missing in type\n```\n\n----------------------------------------\n\nTITLE: Using Literal Union Codec in TypeScript\nDESCRIPTION: Shows how to use getLiteralUnionCodec for encoding and decoding string literal unions\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec(['left', 'right', 'up', 'down']);\n// ^? FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">\n\nconst bytes = codec.encode('left'); // 0x00\nconst value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Fetching Encoded Account in TypeScript\nDESCRIPTION: Demonstrates how to use fetchEncodedAccount function to fetch a MaybeEncodedAccount from an RPC client, with optional custom configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddress = address('1234..5678');\nconst myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n\n// With custom configuration.\nconst myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n    abortSignal: myAbortController.signal,\n    commitment: 'confirmed',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Transport\nDESCRIPTION: This snippet demonstrates how to create an HTTP transport that conforms to the RpcTransport interface, enabling POST requests to a specified URL for JSON data submission.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHttpTransport } from '@solana/rpc-transport-http';\n\nconst transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\nconst response = await transport({\n    payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n});\nconst data = await response.json();\n```\n\n----------------------------------------\n\nTITLE: Tree-shakeable Encoder/Decoder with resizeEncoder and resizeDecoder in TypeScript\nDESCRIPTION: Demonstrates how to split codec logic into tree-shakeable functions using resizeEncoder and resizeDecoder. This approach allows bundlers to only include the encoding or decoding functionality as needed.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { resizeEncoder, resizeDecoder, getU32Encoder, getU32Decoder, combineCodec } from \"@solana/kit\";\nconst getBiggerU32Encoder = () => resizeEncoder(getU32Encoder(), (size) => size + 4);\nconst getBiggerU32Decoder = () => resizeDecoder(getU32Decoder(), (size) => size + 4);\nconst getBiggerU32Codec = () => combineCodec(getBiggerU32Encoder(), getBiggerU32Decoder());\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Transport for Solana RPC API - JavaScript\nDESCRIPTION: This code snippet introduces a new function `createHttpTransportForSolanaRpc`, tailored for creating an HTTP transport in line with the Solana RPC API requirements. It ensures precision during JSON parsing and stringifying for large integers, crucial for effective API interaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Add new `createHttpTransportForSolanaRpc` function\n// This function creates a new HTTP transport for Solana RPC API.\n// It uses custom JSON parsing to prevent loss of precision for large integers.\n```\n\n----------------------------------------\n\nTITLE: Using getBitArrayCodec for Boolean Arrays\nDESCRIPTION: Shows how to use getBitArrayCodec to encode arrays of booleans where each boolean is represented by a single bit, with an optional direction parameter.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_67\n\nLANGUAGE: typescript\nCODE:\n```\nconst booleans = [true, false, true, false, true, false, true, false];\n\ngetBitArrayCodec(1).encode(booleans);\n// 0xaa or 0b10101010\n\ngetBitArrayCodec(1, { backward: true }).encode(booleans);\n// 0x55 or 0b01010101\n```\n\n----------------------------------------\n\nTITLE: Enum Value as Discriminator\nDESCRIPTION: This snippet configures the `getEnumCodec` to use the enum value itself as the discriminator when encoding, instead of the index. This is achieved using the `useValuesAsDiscriminators` option. It implicitly depends on `getEnumCodec`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nenum Numbers {\n    One,\n    Five = 5,\n    Six,\n    Nine = 9,\n}\n\nconst codec = getEnumCodec(Numbers, { useValuesAsDiscriminators: true });\ncodec.encode(Direction.One); // 0x00\ncodec.encode(Direction.Five); // 0x05\ncodec.encode(Direction.Six); // 0x06\ncodec.encode(Direction.Nine); // 0x09\ncodec.encode('One'); // 0x00\ncodec.encode('Five'); // 0x05\ncodec.encode('Six'); // 0x06\ncodec.encode('Nine'); // 0x09\n```\n\n----------------------------------------\n\nTITLE: Using assertDigestCapabilityIsAvailable for WebCrypto digest checking\nDESCRIPTION: Function that throws an exception unless crypto.subtle.digest() is available in the current JavaScript environment. Used to ensure hashing capabilities are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/README.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`assertDigestCapabilityIsAvailable()`\n```\n\n----------------------------------------\n\nTITLE: Decoding Accounts Using TypeScript\nDESCRIPTION: The `decodeAccount` function transforms an `EncodedAccount` to an `Account` by decoding data with a provided `Decoder` instance. It requires an `EncodedAccount` and a `Decoder` set up with structures for the expected data. The output is a decoded `Account` that satisfies the provided type constraints.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntype MyAccountData = { name: string; age: number };\n\nconst myAccount: EncodedAccount<'1234..5678'>;\nconst myDecoder: Decoder<MyAccountData> = getStructDecoder([\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['age', getU32Decoder()],\n]);\n\nconst myDecodedAccount = decodeAccount(myAccount, myDecoder);\nmyDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n```\n\n----------------------------------------\n\nTITLE: Using Literal Union Codec in TypeScript\nDESCRIPTION: Demonstrates the new getLiteralUnionCodec function which creates a fixed-size codec for union literal types. The example shows how to create and use a direction codec with 'left', 'right', 'up', and 'down' values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec(['left', 'right', 'up', 'down']);\n// ^? FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">\n\nconst bytes = codec.encode('left'); // 0x00\nconst value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Defining TransactionSendingSigner Interface in TypeScript\nDESCRIPTION: This code snippet defines the `TransactionSendingSigner` interface, which signs and immediately sends transactions to the blockchain.  The `signAndSendTransactions` function returns the transaction signature for each provided `CompilableTransaction`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n    address: address('1234..5678'),\n    signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n        // My custom signing logic.\n    },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Person Codec with Optional Age\nDESCRIPTION: Advanced example showing how to create a codec with different input/output types and default values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = { name: string, age: number };\ntype PersonInput = { name: string, age?: number };\n\nconst getPersonEncoder = (): Encoder<PersonInput> =>\n    transformEncoder(\n        getStructEncoder([\n            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['age', getU32Encoder()],\n        ]),\n        input => { ...input, age: input.age ?? 42 }\n    );\n\nconst getPersonDecoder = (): Decoder<Person> =>\n    getStructDecoder([\n        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n        ['age', getU32Decoder()],\n    ]);\n\nconst getPersonCodec = (): Codec<PersonInput, Person> =>\n  combineCodec(getPersonEncoder(), getPersonDecoder())\n```\n\n----------------------------------------\n\nTITLE: Reusing GraphQL Queries with Different Variables\nDESCRIPTION: This code snippet shows how to reuse a GraphQL query with different variable values.  The `source` contains a query that takes an address.  It is used to query lamports for two different addresses `AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca` and `CcYNb7WqpjaMrNr7B1mapaNfWctZRH7LyAjWRLBGt1Fk`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            lamports\n        }\n    }\n`;\n\nconst lamportsAccountA = await rpcGraphQL.query(source, {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n});\n\nconst lamportsAccountB = await rpcGraphQL.query(source, {\n    address: 'CcYNb7WqpjaMrNr7B1mapaNfWctZRH7LyAjWRLBGt1Fk',\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Sharding for Requests\nDESCRIPTION: This code demonstrates a transport setup that shards requests deterministically based on the method being called. Each method is routed to the appropriate transport server, optimizing load handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RpcTransport } from '@solana/rpc-spec';\nimport { RpcResponse } from '@solana/rpc-spec-types';\nimport { createHttpTransport } from '@solana/rpc-transport-http';\n\nconst transportA = createHttpTransport({ url: 'https://mainnet-beta.my-server-1.com' });\nconst transportB = createHttpTransport({ url: 'https://mainnet-beta.my-server-2.com' });\n// More transports...\n\nfunction selectShard(method: string): RpcTransport {\n    switch (method) {\n        case 'getAccountInfo':\n        case 'getBalance':\n            return transportA;\n        // More cases...\n        default:\n            return transportD;\n    }\n}\n\nasync function shardingTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<RpcResponse<TResponse>> {\n    const payload = args[0].payload as { method: string };\n    const selectedTransport = selectShard(payload.method);\n    return await selectedTransport(...args);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rent Sysvar Account Type in TypeScript\nDESCRIPTION: Example showing how to type a rent sysvar account using ReadonlyAccount type\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RentSysvar = ReadonlyAccount<'SysvarRent111111111111111111111111111111111'>;\n```\n\n----------------------------------------\n\nTITLE: Adding Size Prefix to Codec\nDESCRIPTION: This snippet demonstrates how to create a codec that adds a size prefix to base-58 encoded strings. It utilizes the 'addCodecSizePrefix' function along with 'getBase58Codec' and 'getU32Codec' to encode a string with a size prefix.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ncodec.encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Using Base64 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBase64Codec function to encode and decode Base64 strings. It shows both basic usage and examples of applying size constraints with utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBase64Codec();\nconst bytes = codec.encode(\"hello+world\"); // 0x85e965a3ec28ae57\nconst value = codec.decode(bytes); // \"hello+world\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfixCodecSize(getBase64Codec(), 4).encode(\"hello+world\");\n// 0x85e965a3 (truncated to 4 bytes)\n\naddCodecSizePrefix(getBase64Codec(), getU32Codec()).encode(\"hello+world\");\n// 0x0400000085e965a3ec28ae57\n//   |       └-- The 8 bytes of content.\n//   └-- 4-byte prefix telling us to read 8 bytes.\n\naddCodecSentinel(getBase64Codec(), new Uint8Array([0xff, 0xff])).encode(\"hello+world\");\n// 0x85e965a3ec28ae57ffff\n//   |               └-- The sentinel signaling the end of the content.\n//   └-- The 8 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Map encoding with multiple entries in TypeScript\nDESCRIPTION: Shows how multiple entries in a map are encoded sequentially, with each key followed by its value. By default, the map size is stored as a u32 prefix before the entries.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getMapCodec(fixCodecSize(getUtf8Codec(), 8), getU8Codec());\nconst myMap = new Map<string, number>();\nmyMap.set(\"alice\", 42);\nmyMap.set(\"bob\", 5);\n\ncodec.encode(myMap);\n// 0x02000000616c6963650000002a626f62000000000005\n//   |       |               | |               └-- 2nd entry value (5).\n//   |       |               | └-- 2nd entry key (\"bob\").\n//   |       |               └-- 1st entry value (42).\n//   |       └-- 1st entry key (\"alice\").\n//   └-- 4-byte prefix telling us to read 2 map entries.\n```\n\n----------------------------------------\n\nTITLE: Using Base64 Codec in TypeScript\nDESCRIPTION: Shows how to use the getBase64Codec function to encode and decode Base64 strings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBase64Codec().encode('hello+world'); // 0x85e965a3ec28ae57\nconst value = getBase64Codec().decode(bytes); // \"hello+world\"\n```\n\n----------------------------------------\n\nTITLE: Union Codec in TypeScript\nDESCRIPTION: Demonstrates creating a union codec that can encode/decode multiple types with custom discrimination logic\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number | boolean> = getUnionCodec(\n    [getU16Codec(), getBooleanCodec()],\n    value => (typeof value === 'number' ? 0 : 1),\n    (bytes, offset) => (bytes.slice(offset).length > 1 ? 0 : 1)\n);\n\ncodec.encode(42); // 0x2a00\ncodec.encode(true); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Getting Public Key from Private Key in TypeScript\nDESCRIPTION: Example of using the new getPublicKeyFromPrivateKey helper to obtain a public key from an extractable CryptoKey private key.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n\nconst privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n\nconst publicKey = await getPublicKeyFromPrivateKey(privateKey);\nconst extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n```\n\n----------------------------------------\n\nTITLE: Minimized Network Payloads in GraphQL for Solana Account Data\nDESCRIPTION: This GraphQL query showcases how to request multiple slices of base64 encoded data from a single account. The resolver optimizes this by fetching only the required data range and slicing it locally, minimizing network overhead.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_30\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    account(address: \"J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ\") {\n        firstEightBytes: data(encoding: BASE_64, dataSlice: { length: 8, offset: 0 })\n        nextEightBytes: data(encoding: BASE_64, dataSlice: { length: 8, offset: 8 })\n        anotherEightBytes: data(encoding: BASE_64, dataSlice: { length: 8, offset: 16 })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a RpcApi Implementation with Rpc\nDESCRIPTION: Shows how to create and use an RPC client that implements the previously defined ExampleApi interface. The code demonstrates creating the RPC client and calling its getSomething method with an address parameter.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpc: Rpc<ExampleApi> = createExampleRpc(/* ... */);\nconst something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n```\n\n----------------------------------------\n\nTITLE: Defining Codec Size Specifications\nDESCRIPTION: Examples showing how to specify fixed and variable size codecs using fixedSize and getSizeFromValue.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// FixedSizeCodec.\ncreateCodec({\n    fixedSize: 1,\n    // ...\n});\n\n// VariableSizeCodec.\ncreateCodec({\n    getSizeFromValue: (value: string) => value.length,\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Lamports Helper in Typescript\nDESCRIPTION: This code snippet demonstrates the usage of the `lamports` helper function for asserting and coercing a number to the `Lamports` type. It shows how to import the `lamports` function from `@solana/rpc-types` and use it to convert a number to the `Lamports` type before using it in a transfer function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lamports } from '@solana/rpc-types';\n\nawait transfer(address(fromAddress), address(toAddress), lamports(100000n));\n```\n\n----------------------------------------\n\nTITLE: Using getMapCodec for Map encoding and decoding in TypeScript\nDESCRIPTION: Demonstrates how to create and use a map codec to encode/decode Map objects. This example encodes a simple key-value pair from \"alice\" to 42 and shows the resulting byte representation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nconst keyCodec = fixCodecSize(getUtf8Codec(), 8);\nconst valueCodec = getU8Codec();\nconst codec = getMapCodec(keyCodec, valueCodec);\n\nconst bytes = codec.encode(new Map([[\"alice\", 42]])); // 0x01000000616c6963650000002a\nconst map = codec.decode(bytes); // new Map([[\"alice\", 42]])\n```\n\n----------------------------------------\n\nTITLE: Configuring Solana Client\nDESCRIPTION: Creates a reusable client configuration that includes RPC connections and a funded wallet signer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Client = {\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n  wallet: TransactionSigner & MessageSigner;\n};\n\nlet client: Client | undefined;\nexport async function createClient(): Promise<Client> {\n  if (!client) {\n    const rpc = createSolanaRpc(\"http://127.0.0.1:8899\");\n    const rpcSubscriptions = createSolanaRpcSubscriptions(\"ws://127.0.0.1:8900\");\n    const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n    const wallet = await generateKeyPairSigner();\n    await airdrop({\n      recipientAddress: wallet.address,\n      lamports: lamports(1_000_000_000n),\n      commitment: \"confirmed\",\n    });\n\n    client = { rpc, rpcSubscriptions, wallet };\n  }\n  return client;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Overflow Request Transformer - TypeScript\nDESCRIPTION: Creates a transformer that traverses request parameters and executes a handler when an integer overflow is detected. This transformation helps in handling potential errors gracefully during RPC calls.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n\nconst requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n    throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Node-Only Dispatcher with Round-Robin Pool\nDESCRIPTION: This snippet showcases how to configure a Node-only dispatcher using the undici library, implementing a round-robin approach to manage multiple RPC endpoints for improved load distribution.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHttpTransport } from '@solana/rpc-transport-http';\nimport { Agent, BalancedPool } from 'undici';\n\nconst dispatcher = new Agent({\n    factory(origin, opts) {\n        if (origin === 'https://mypool') {\n            const upstreams = [\n                'https://api.mainnet-beta.solana.com',\n                'https://mainnet.helius-rpc.com',\n                'https://several-neat-iguana.quiknode.pro',\n            ];\n            return new BalancedPool(upstreams, {\n                ...opts,\n                bodyTimeout: 60e3,\n                headersTimeout: 5e3,\n                keepAliveTimeout: 19e3,\n            });\n        } else {\n            return new Pool(origin, opts);\n        }\n    },\n});\nconst transport = createHttpTransport({\n    dispatcher_NODE_ONLY: dispatcher,\n    url: 'https://mypool',\n});\nlet id = 0;\nconst balances = await Promise.allSettled(\n    accounts.map(async account => {\n        const response = await transport({\n            payload: {\n                id: ++id,\n                jsonrpc: '2.0',\n                method: 'getBalance',\n                params: [account],\n            },\n        });\n        return await response.json();\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Account Types - MintAccount\nDESCRIPTION: This code snippet demonstrates how to query specifically for `MintAccount` types using GraphQL fragments (`... on MintAccount`). It iterates through a list of potential mint addresses, queries each address, and pushes mint information to the `mintAccounts` array if the account is a `MintAccount`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst maybeMintAddresses = [\n    'J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ',\n    'JAbWqZ7S2c6jomQr8ofAYBo257bE1QJtHwbX1yWc2osZ',\n    '2AQ4CSNu6zNUZsUq4aLNUSjyrLv4qFFXQuKs5RTHbg2Y',\n    'EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b',\n];\n\nconst mintAccounts = [];\n\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            ... on MintAccount {\n                data {\n                    decimals\n                    isInitialized\n                    mintAuthority\n                    supply\n                }\n            }\n        }\n    }\n`;\n\nfor (const address of maybeMintAddresses) {\n    const result = await rpcGraphQL.query(source, { address });\n    if (result != null) {\n        const {\n            data: {\n                account: { data: mintInfo },\n            },\n        } = result;\n        mintAccounts.push(mintInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RpcResponse Type in TypeScript\nDESCRIPTION: Defines the RpcResponse type, representing the response from an RPC server. It uses a generic type parameter to specify the shape of the response.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec-types/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype RpcResponse<T = unknown> = T;\n```\n\n----------------------------------------\n\nTITLE: Combining offsetCodec and resizeCodec for Padded Struct in TypeScript\nDESCRIPTION: Shows how to use resizeCodec and offsetCodec together to create a struct codec with padding between fields. This example creates a person struct with a fixed-size name field and a padded age field.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getStructCodec, getUtf8Codec, getU32Codec, offsetCodec, resizeCodec, fixCodecSize } from \"@solana/kit\";\nconst personCodec = getStructCodec([\n  [\"name\", fixCodecSize(getUtf8Codec(), 8)],\n  // There is a 4-byte padding between name and age.\n  [\n    \"age\",\n    offsetCodec(\n      resizeCodec(getU32Codec(), (size) => size + 4),\n      { preOffset: ({ preOffset }) => preOffset + 4 },\n    ),\n  ],\n]);\n\npersonCodec.encode({ name: \"Alice\", age: 42 });\n// 0x416c696365000000000000002a000000\n//   |               |       └-- Our encoded u32 (42).\n//   |               └-- The 4-bytes of padding we are skipping.\n//   └-- Our 8-byte encoded string (\"Alice\").\n```\n\n----------------------------------------\n\nTITLE: Fetching JSON-Parsed Sysvar Account using RPC in Typescript\nDESCRIPTION: This snippet shows how to fetch a JSON-parsed sysvar account using an RPC client. It uses the `fetchJsonParsedSysvarAccount` function with the RPC client and the `SYSVAR_CLOCK_ADDRESS` to retrieve the JSON-parsed clock sysvar. The result is type-checked to ensure it satisfies either `MaybeAccount` with `JsonParsedSysvarAccount` or `MaybeEncodedAccount`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst maybeJsonParsedClock = await fetchJsonParsedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS);\nmaybeJsonParsedClock satisfies\n    | MaybeAccount<JsonParsedSysvarAccount, 'SysvarC1ock11111111111111111111111111111111'>\n    | MaybeEncodedAccount<'SysvarC1ock11111111111111111111111111111111'>;\n```\n\n----------------------------------------\n\nTITLE: Using Prefix-less Nullable Codec in TypeScript\nDESCRIPTION: Example showing how to create and use a nullable codec without a prefix, where the existence of the nullable item is indicated by remaining bytes to decode.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Using Nullable Codec with Zeroable Option in TypeScript\nDESCRIPTION: Example demonstrating the migration from the deprecated getZeroableNullableCodec to the new consolidated getNullableCodec with configuration options for handling null values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetZeroableNullableCodec(getU16Codec());\n\n// After.\ngetNullableCodec(getU16Codec(), { noneValue: 'zeroes', prefix: null });\n```\n\n----------------------------------------\n\nTITLE: String U32 Codec with Separate Components\nDESCRIPTION: Implementation of StringU32 codec split into separate encoder and decoder components.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst getStringU32Encoder = () =>\n    transformEncoder(getU32Encoder(), (integerAsString: string): number => parseInt(integerAsString));\nconst getStringU32Decoder = () => transformDecoder(getU32Decoder(), (integer: number): string => integer.toString());\nconst getStringU32Codec = () => combineCodec(getStringU32Encoder(), getStringU32Decoder());\n```\n\n----------------------------------------\n\nTITLE: Fixed-Size Base58 Codec\nDESCRIPTION: Example of creating a fixed-size Base58 codec that uses exactly 32 bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst get32BytesBase58Codec = () => fixCodecSize(getBase58Codec(), 32);\n```\n\n----------------------------------------\n\nTITLE: Defining Data Publisher Type - TypeScript\nDESCRIPTION: This snippet defines the DataPublisher type, which represents an object that can subscribe to data over a specified channel, with error handling functionality.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nlet dataPublisher: DataPublisher<{ error: SolanaError }>;\\ndataPublisher.on('data', handleData); // ERROR. `data` is not a known channel name.\\ndataPublisher.on('error', e => {\\n    console.error(e);\\n}); // OK.\n```\n\n----------------------------------------\n\nTITLE: Using Variable and Fixed Size Codecs\nDESCRIPTION: This snippet shows how to transition from using the outdated 'getStringCodec' to the new methods 'fixCodecSize' and 'addCodecSizePrefix'. It illustrates before and after scenarios to showcase the new variable and fixed codec behavior.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetStringCodec({ size: 'variable' }); // Variable.\ngetStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\ngetStringCodec({ size: 5 }); // Fixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\ngetStringCodec(); // Prefixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\n\n// After.\ngetUtf8Codec(); // Variable.\nfixCodecSize(getUtf8Codec(), 5); // Fixed.\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Defining TransactionModifyingSigner Interface in TypeScript\nDESCRIPTION: This code snippet defines the `TransactionModifyingSigner` interface, which allows for modifying transactions before signing. The `modifyAndSignTransactions` function returns an updated `Transaction` with potentially modified instructions and signature dictionary.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTransactionModifyingSigner: TransactionModifyingSigner<'1234..5678'> = {\n    address: address('1234..5678'),\n    modifyAndSignTransactions: async <T extends Transaction>(transactions: T[]): Promise<T[]> => {\n        // My custom signing logic.\n    },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Using Base10Codec to Encode/Decode Base 10 Strings in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding Base 10 numeric strings, along with options for constraining size using fixCodecSize, addCodecSizePrefix, or addCodecSentinel utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBase10Codec } from \"@solana/kit\";\n\nconst codec = getBase10Codec();\nconst bytes = codec.encode(\"1024\"); // 0x0400\nconst value = codec.decode(bytes); // \"1024\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getBase10Codec, fixCodecSize, addCodecSizePrefix, getU32Codec, addCodecSentinel } from \"@solana/kit\";\n\nfixCodecSize(getBase10Codec(), 4).encode(\"1024\");\n// 0x04000000 (padded to 4 bytes)\n\naddCodecSizePrefix(getBase10Codec(), getU32Codec()).encode(\"1024\");\n// 0x020000000400\n//   |       └-- The 2 bytes of content.\n//   └-- 4-byte prefix telling us to read 2 bytes.\n\naddCodecSentinel(getBase10Codec(), new Uint8Array([0xff, 0xff])).encode(\"1024\");\n// 0x0400ffff\n//   |   └-- The sentinel signaling the end of the content.\n//   └-- The 2 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Using pipe() for Simple Function Composition in TypeScript\nDESCRIPTION: Demonstrates how to use the pipe() function to compose multiple functions together in a sequential chain. The example shows adding values through a pipeline where each function's output becomes the input to the next function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/functional/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst add = (a, b) => a + b;\nconst add10 = x => add(x, 10);\nconst add100 = x => add(x, 100);\nconst sum = pipe(1, add10, add100);\nsum === 111; // true\n```\n\n----------------------------------------\n\nTITLE: RpcTransport Output Type Update - JavaScript\nDESCRIPTION: This snippet demonstrates the update to the `RpcTransport` functionality where it now returns a new `RpcResponse` type instead of plain parsed JSON data, improving the data structure and clarity of responses received from the RPC layer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Make `RpcTransport` return new `RpcResponse` type\n// Instead of parsed JSON data.\n```\n\n----------------------------------------\n\nTITLE: Asserting Account Existence in TypeScript\nDESCRIPTION: Shows how to use the assertAccountExists helper to assert the existence of an account and narrow its type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/fetch-account.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertAccountExists, EncodedAccount, address, fetchEncodedAccount, fetchEncodedAccounts } from \"@solana/kit\";\n\nconst account = await fetchEncodedAccount(rpc, address(\"1234..5678\"));\nassertAccountExists(account);\n\naccount satisfies EncodedAccount;\n```\n\n----------------------------------------\n\nTITLE: Setting Up Local Solana Test Validator\nDESCRIPTION: This command sets up a local Solana test validator for use with the examples. It should be run in the root directory of the monorepo.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/README.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm test:live-with-test-validator:setup\n```\n\n----------------------------------------\n\nTITLE: Adding addCodecSizePrefix Function in TypeScript\nDESCRIPTION: A new function 'addCodecSizePrefix' was added to allow prefixing codecs with size information. It uses getBase58Codec and getU32Codec to encode strings with a size prefix.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ncodec.encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Compressing Transaction Messages using Address Lookup Tables in TypeScript\nDESCRIPTION: This snippet demonstrates the `compressTransactionMessageUsingAddressLookupTables` function which takes a transaction message and a mapping of lookup table addresses to reduce the size of accounts within the message. The output replaces non-signer accounts with smaller representations, enhancing efficiency in transaction messages containing multiple accounts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { address } from '@solana/addresses';\nimport { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n\nconst lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\nconst accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\nconst lookupTableAddresses: AddressesByLookupTableAddress = {\n    [lookupTableAddress]: [accountAddress],\n};\n\nconst compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n    transactionMessage,\n    lookupTableAddresses,\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Throw Solana Error Response Transformer - TypeScript\nDESCRIPTION: Returns a transformer that throws a SolanaError when the response body contains an error code. This is useful for managing errors returned by the Solana RPC.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n\nconst responseTransformer = getThrowSolanaErrorResponseTransformer();\n```\n\n----------------------------------------\n\nTITLE: Querying Account Data with Encoding\nDESCRIPTION: This code snippet demonstrates how to query account data with a specified encoding (BASE_64). The GraphQL query retrieves the `data` field with the specified encoding for a given account address, enabling access to encoded account data.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            data(encoding: BASE_64)\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'CcYNb7WqpjaMrNr7B1mapaNfWctZRH7LyAjWRLBGt1Fk',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Removing feePayerSigner Attribute - Solana\nDESCRIPTION: The `feePayerSigner` attribute has been removed from transaction messages, and the existing `feePayer` attribute is now used instead. This ensures a single source of truth for the fee payer, whether or not they are using signers. This simplification reduces complexity and avoids potential inconsistencies in defining the fee payer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: N/A\nCODE:\n```\n``4decebb`](https://github.com/solana-labs/solana-web3.js/commit/4decebb9b619972f49c740323b59cf470696e105) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Remove the `feePayerSigner` attribute of transaction messages in favour of the existing `feePayer` attribute. This ensures fee payers are defined in a single place — whether they are using signers or not.``\n```\n\n----------------------------------------\n\nTITLE: Demultiplexing Data Publisher - TypeScript\nDESCRIPTION: This function demultiplexes a data publisher, allowing one channel to split its messages into multiple channels based on a transformer function, improving subscriber targeting.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst demuxedDataPublisher = demultiplexDataPublisher(channel, 'message', message => {\\n    const destinationChannelName = `notification-for:${message.subscriberId}`;\\n    return [destinationChannelName, message];\\n});\\ndemuxedDataPublisher.on(\\n    'notification-for:123',\\n    message => {\\n        console.log('Got a message for subscriber 123', message);\\n    },\\n    { signal: AbortSignal.timeout(5_000) },\\n);\n```\n\n----------------------------------------\n\nTITLE: Custom Discriminated Union Size\nDESCRIPTION: This snippet customizes the size of the discriminator for the discriminated union by providing a `u32` codec as the `size` option to `getDiscriminatedUnionCodec`. The ellipsis `[...]` is used to signify that the variants are defined elsewhere. The example depends on  `getDiscriminatedUnionCodec` and `getU32Codec`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32MessageCodec = getDiscriminatedUnionCodec([...], {\n    size: getU32Codec(),\n});\n\nu32MessageCodec.encode({ __kind: 'Quit' });\n// 0x00000000\n//   └------┘ 4-byte discriminator (Index 0).\n\nu32MessageCodec.encode({ __kind: 'Write', fields: ['Hi'] });\n// 0x01000000020000004869\n//   └------┘ 4-byte discriminator (Index 1).\n\nu32MessageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n// 0x020000000500000006000000\n//   └------┘ 4-byte discriminator (Index 2).\n```\n\n----------------------------------------\n\nTITLE: Specifying Codec Size in TypeScript @solana/kit\nDESCRIPTION: Shows how to specify codec size attributes based on whether it's fixed or variable. This snippet includes both FixedSizeCodec and VariableSizeCodec examples using createCodec from @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createCodec } from \"@solana/kit\";\ntype Config = Parameters<typeof createCodec<string>>[0];\nconst read = null as unknown as Config[\"read\"];\nconst write = null as unknown as Config[\"write\"];\n// FixedSizeCodec.\ncreateCodec({\n  fixedSize: 1,\n  read,\n  write,\n});\n// VariableSizeCodec.\ncreateCodec({\n  getSizeFromValue: (value: string) => value.length,\n  read,\n  write,\n});\n```\n\n----------------------------------------\n\nTITLE: Custom None Value Handling in Nullable Codecs - TypeScript\nDESCRIPTION: This snippet outlines the new capabilities to customize the handling of null values in codecs with examples for encoding and decoding different scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Querying Nested Token Account Data with GraphQL\nDESCRIPTION: Example showing how to use GraphQL to make nested queries that extract specific data from token accounts. This demonstrates combining traversal of account relationships with data filtering capabilities.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_45\n\nLANGUAGE: ts\nCODE:\n```\nconst source = `\n    query getLamportsOfOwnersOfOwnersOfTokenAccounts {\n        programAccounts(programAddress: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\") {\n            ... on TokenAccount {\n                owner {\n                    ownerProgram {\n                        lamports\n                    }\n                }\n            }\n        }\n    }\n`;\n\nconst result = await rpcGraphQL.query(source);\n\nconst sumOfAllLamportsOfOwnersOfOwnersOfTokenAccounts = result\n    .map(o => o.account.owner.ownerProgram.lamports)\n    .reduce((acc, lamports) => acc + lamports, 0);\n```\n\n----------------------------------------\n\nTITLE: Using isKeyPairSigner Type Guard in TypeScript\nDESCRIPTION: This code shows how to use the `isKeyPairSigner` type guard to check if a given value is a `KeyPairSigner`. It returns `true` if it is, and `false` otherwise.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst myKeyPairSigner = await generateKeyPairSigner();\nisKeyPairSigner(myKeyPairSigner); // ✅ true\nisKeyPairSigner({ address: address('1234..5678') }); // ❌ false\n\n```\n\n----------------------------------------\n\nTITLE: Defining Advance Nonce Account Instruction Type in TypeScript\nDESCRIPTION: Complex example showing how to type an instruction that combines program address, accounts, and instruction data\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\n```\n\n----------------------------------------\n\nTITLE: Catching Unsigned Transaction Error in TypeScript\nDESCRIPTION: Shows how TypeScript detects an attempt to send an unsigned transaction at compile time.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(feePayerAddress, tx),\n    tx => setTransactionMessageLifetimeUsingBlockhash(recentBlockhash, tx),\n);\n\nconst signedTransaction = await signTransaction([], transactionMessage);\n\n// Asserts the transaction is a `FullySignedTransaction`\n// Throws an error if any signatures are missing!\nassertTransactionIsFullySigned(signedTransaction);\n\nawait sendAndConfirmTransaction(signedTransaction);\n```\n\n----------------------------------------\n\nTITLE: Using Asynchronous Instruction Builder for CreateLookupTable\nDESCRIPTION: Shows how to use an asynchronous instruction builder that resolves inputs like PDA derivation for the CreateLookupTable instruction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpc = createSolanaRpc('http://127.0.0.1:8899');\nconst [authority, recentSlot] = await Promise.all([\n    generateKeyPairSigner(),\n    rpc.getSlot({ commitment: 'finalized' }).send(),\n]);\n\nconst instruction = await getCreateLookupTableInstructionAsync({\n    authority,\n    recentSlot,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Options in TypeScript\nDESCRIPTION: Demonstrates how to create Some and None options using helper functions, with type inference or explicit type annotations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Create an option with a value.\nsome('Hello World');\nsome<number | string>(123);\n\n// Create an empty option.\nnone();\nnone<number | string>();\n```\n\n----------------------------------------\n\nTITLE: Asserting Address Validity with assertIsAddress() in TypeScript\nDESCRIPTION: Illustrates the use of assertIsAddress() function to validate an arbitrary string as a base58-encoded Solana address, useful for handling user input or untrusted data sources.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertIsAddress } from '@solana/addresses';\n\nfunction handleSubmit() {\n    const address: string = accountAddressInput.value;\n    try {\n        assertIsAddress(address);\n        const balanceInLamports = await rpc.getBalance(address).send();\n    } catch (e) {\n        // `address` turned out not to be a base58-encoded address\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running Development Server for Solana React App\nDESCRIPTION: Commands to install dependencies, compile the JavaScript and TypeScript definitions, and start a development server for the Solana example React app.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/react-app/README.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\npnpm turbo compile:js compile:typedefs\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Event Emitter Type - TypeScript\nDESCRIPTION: This snippet introduces the TypedEventEmitter type that constraints the calls to addEventListener and removeEventListener, ensuring the listener's function matches the event type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst emitter: TypedEventEmitter<{ message: MessageEvent }> = new WebSocket('wss://api.devnet.solana.com');\\nemitter.addEventListener('data', handleData); // ERROR. `data` is not a known event type.\\nemitter.addEventListener('message', message => {\\n    console.log(message.origin); // OK. `message` is a `MessageEvent` so it has an `origin` property.\\n});\n```\n\n----------------------------------------\n\nTITLE: Get Zeroable Nullable Codec in Typescript\nDESCRIPTION: This snippet demonstrates the usage of `getZeroableNullableCodec` for representing `null` or `None` values with a zero value instead of a boolean prefix. A custom zero value can also be specified.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec = getZeroableNullableCodec(getU16Codec());\n    codec.encode(42); // 0x2a00\n    codec.encode(null); // 0x0000\n    codec.decode(new Uint8Array([42, 0])); // 42\n    codec.encode(new Uint8Array([0, 0])); // null\n```\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec = getZeroableNullableCodec(getU16Codec(), {\n        zeroValue: new Uint8Array([255, 255]),\n    });\n    codec.encode(42); // 0x2a00\n    codec.encode(null); // 0xfffff\n    codec.encode(new Uint8Array([0, 0])); // 0\n    codec.decode(new Uint8Array([42, 0])); // 42\n    codec.decode(new Uint8Array([255, 255])); // null\n```\n\n----------------------------------------\n\nTITLE: Overriding feePayer Signer - Solana\nDESCRIPTION: The `feePayer` signer is now overridden when the address matches an existing one. This allows users to provide a different wallet from the same address as the original fee payer. This enhancement accommodates scenarios where users want to switch wallets while retaining the same account address.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: N/A\nCODE:\n```\n``d4965ec`](https://github.com/solana-labs/solana-web3.js/commit/d4965ece9abaf81e3006442db15f3f77d89a622c) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Override `feePayer` signer when the address matches the existing one. This is because users may want to provide a different wallet from the same address.``\n```\n\n----------------------------------------\n\nTITLE: Understanding Pre and Post Offsets in TypeScript\nDESCRIPTION: Explains how pre-offset and post-offset work together in offsetCodec. Pre-offset determines where encoding starts, while post-offset determines where the next codec would begin encoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n    preOffset: ({ preOffset }) => preOffset + 2,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n// 0x0000ffffffff0000\n//   |   |       └-- Post-offset.\n//   |   └-- New pre-offset: The original pre-offset + 2.\n//   └-- Pre-offset: The original pre-offset before we adjusted it.\n```\n\n----------------------------------------\n\nTITLE: GraphQL Account Interface\nDESCRIPTION: This code snippet defines the `Account` interface in GraphQL, which includes common fields such as `address`, `data`, `executable`, `lamports`, `ownerProgram`, `space`, and `rentEpoch`. This interface represents the structure of accounts that can be queried from the Solana ledger.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\ninterface Account {\n    address: Address\n    data(encoding: AccountEncoding!, dataSlice: DataSlice): String\n    executable: Boolean\n    lamports: BigInt\n    ownerProgram: Account\n    space: BigInt\n    rentEpoch: BigInt\n}\n```\n\n----------------------------------------\n\nTITLE: Get Union Codec in Typescript\nDESCRIPTION: This snippet showcases the `getUnionCodec` function for encoding and decoding TypeScript unions.  It requires an array of codecs for each union type and functions to determine the codec to use for encoding and decoding based on the value and bytes respectively.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec: Codec<number | boolean> = getUnionCodec(\n        [getU16Codec(), getBooleanCodec()],\n        value => (typeof value === 'number' ? 0 : 1),\n        (bytes, offset) => (bytes.slice(offset).length > 1 ? 0 : 1),\n    );\n\n    codec.encode(42); // 0x2a00\n    codec.encode(true); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Encoding Big-Endian Signed Integers in TypeScript\nDESCRIPTION: Shows how to use signed integer codecs with big-endian encoding by specifying the endian option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Big-endian signed integers.\ngetI16Codec({ endian: Endian.Big }).encode(-42); // 0xffd6\ngetI32Codec({ endian: Endian.Big }).encode(-42); // 0xffffffd6\ngetI64Codec({ endian: Endian.Big }).encode(-42); // 0xffffffffffffffd6\ngetI128Codec({ endian: Endian.Big }).encode(-42); // 0xffffffffffffffffffffffffffffffd6\n```\n\n----------------------------------------\n\nTITLE: Including Solana Kit in Browser via CDN\nDESCRIPTION: HTML script tags to include the Solana Kit library directly in a browser without a build system. Provides options for both development (unminified) and production (minified) versions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!-- Development (debug mode, unminified) -->\n<script src=\"https://unpkg.com/@solana/kit/dist/index.development.js\"></script>\n\n<!-- Production (minified) -->\n<script src=\"https://unpkg.com/@solana/kit/dist/index.production.min.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Transforming Channel Outbound Messages with JSON Stringification\nDESCRIPTION: This code shows how to transform outbound messages of a channel using the `transformChannelOutboundMessages` function to stringify JSON messages before sending them. It takes an existing channel and applies `JSON.stringify` as the transformation function, creating a new channel that automatically stringifies messages. This is useful for preparing data to be sent over the wire in JSON format.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst transformedChannel = transformChannelOutboundMessages(channel, JSON.stringify);\n```\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding UTF-8 Strings in TypeScript\nDESCRIPTION: Demonstrates how to use the getUtf8Codec function to encode and decode UTF-8 strings without size boundaries.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getUtf8Codec();\n\ncodec.encode('hello');\n// 0x68656c6c6f\n//   └-- Any bytes necessary to encode our content.\n\ncodec.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]));\n// 'hello'\n```\n\n----------------------------------------\n\nTITLE: Switching Between Signer Types\nDESCRIPTION: Demonstrates how to switch between different signer implementations while maintaining the same interface.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPairSigner, KeyPairSigner, TransactionSigner } from \"@solana/kit\";\nimport { useWalletAccountTransactionSendingSigner } from \"@solana/react\";\n\nlet wallet: TransactionSigner;\nwallet = useWalletAccountTransactionSendingSigner(account, currentChain);\n```\n\n----------------------------------------\n\nTITLE: Combining getBytesCodec with Size Controls\nDESCRIPTION: Shows how to combine getBytesCodec with utilities like fixCodecSize, addCodecSizePrefix, and addCodecSentinel to control the byte size behavior.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_71\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = new Uint8Array([42, 43]); // 0x2a2b\n\nfixCodecSize(getBytesCodec(), 4).encode(value);\n// 0x2a2b0000 (padded to 4 bytes)\n\naddCodecSizePrefix(getBytesCodec(), getU32Codec()).encode(value);\n// 0x020000002a2b\n//   |       └-- The 2 bytes of content.\n//   └-- 4-byte prefix telling us to read 2 bytes.\n\naddCodecSentinel(getBytesCodec(), new Uint8Array([0xff, 0xff])).encode(value);\n// 0x2a2bffff\n//   |   └-- The sentinel signaling the end of the content.\n//   └-- The 2 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Defining Block Schema in GraphQL\nDESCRIPTION: GraphQL schema definition for the Block type which contains common fields across all blocks including blockhash, blockHeight, blockTime, and references to transactions and rewards.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_25\n\nLANGUAGE: graphql\nCODE:\n```\ntype Block {\n    blockhash: String\n    blockHeight: BigInt\n    blockTime: BigInt\n    parentSlot: Slot\n    previousBlockhash: String\n    rewards: [Reward]\n    signatures: [Signature]\n    transactions: [Transaction]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Account Decoded in TypeScript\nDESCRIPTION: The `assertAccountDecoded` function ensures that an account's data is not a Uint8Array, though it doesn't verify data shape. This is useful for validating that decoded data can be safely used. It accepts an `Account` or `MaybeAccount` as an input and outputs an assertion that data is not in a Uint8Array format.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntype MyAccountData = { name: string; age: number };\n\nconst myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\nassertAccountDecoded(myAccount);\n\n// now the account data can be used as MyAccountData\naccount.data satisfies MyAccountData;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n    rpc,\n    '1234..5678' as Address,\n);\n\nassertAccountDecoded(account);\n// now we have a MaybeAccount<MockData>\naccount satisfies MaybeAccount<MockData>;\n```\n\n----------------------------------------\n\nTITLE: Custom null value representation in nullable codec\nDESCRIPTION: Shows how to use a custom byte array as the representation for null values by setting the noneValue option to a specific Uint8Array.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getUtf8Codec(), {\n  noneValue: new Uint8Array([255]), // 0xff means null.\n});\n\ncodec.encode(\"Hi\");\n// 0x014869\n//   | └-- 2-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (true — The item exists).\n\ncodec.encode(null);\n// 0x00ff\n//   | └-- 1-byte representing null (0xff).\n//   └-- 1-byte prefix (false — The item is null).\n```\n\n----------------------------------------\n\nTITLE: Type Guard Examples for Message Signers\nDESCRIPTION: Demonstrates using type guards to validate message signer interfaces\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAddress = address('1234..5678');\n\nisMessagePartialSigner({ address: myAddress, signMessages: async () => {} }); // ✅ true\nisMessagePartialSigner({ address: myAddress }); // ❌ false\nassertIsMessagePartialSigner({ address: myAddress, signMessages: async () => {} }); // ✅ void\nassertIsMessagePartialSigner({ address: myAddress }); // ❌ Throws an error.\n\nisMessageModifyingSigner({ address: myAddress, modifyAndSignMessages: async () => {} }); // ✅ true\nisMessageModifyingSigner({ address: myAddress }); // ❌ false\nassertIsMessageModifyingSigner({ address: myAddress, modifyAndSignMessages: async () => {} }); // ✅ void\nassertIsMessageModifyingSigner({ address: myAddress }); // ❌ Throws an error.\n\nisMessageSigner({ address: myAddress, signMessages: async () => {} }); // ✅ true\nisMessageSigner({ address: myAddress, modifyAndSignMessages: async () => {} }); // ✅ true\nassertIsMessageSigner({ address: myAddress, signMessages: async () => {} }); // ✅ void\nassertIsMessageSigner({ address: myAddress, modifyAndSignMessages: async () => {} }); // ✅ void\n```\n\n----------------------------------------\n\nTITLE: Using assertSigningCapabilityIsAvailable for WebCrypto signing checking\nDESCRIPTION: Function that throws an exception unless crypto.subtle.sign() is available in the current JavaScript environment. Used to ensure digital signature capabilities are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/README.md#2025-04-18_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n`assertSigningCapabilityIsAvailable()`\n```\n\n----------------------------------------\n\nTITLE: Prepending Transaction Message Instructions in TypeScript\nDESCRIPTION: The `prependTransactionMessageInstruction()` function allows users to add a single instruction at the beginning of an existing transaction message's instruction list. For multiple instructions, `prependTransactionMessageInstructions` should be utilized, accepting an array of instructions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Edge Runtime and Cloudflare Workers Compatibility - JavaScript\nDESCRIPTION: This update marks the compatibility of the build with the Vercel Edge runtime and Cloudflare Workers by adjusting the package exports, allowing developers to run the Solana Web3.js library in these environments seamlessly.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// The build is now compatible with Vercel Edge runtime and Cloudflare Workers\n// Added `edge-light` and `workerd` to package exports.\n```\n\n----------------------------------------\n\nTITLE: Creating Nonce Invalidation Promise in TypeScript\nDESCRIPTION: Function to monitor and handle nonce account value changes, throwing an error when the nonce value is no longer valid for a transaction\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isSolanaError, SolanaError } from '@solana/errors';\nimport { createNonceInvalidationPromiseFactory } from '@solana/transaction-confirmation';\n\nconst getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n});\ntry {\n    await getNonceInvalidationPromise({\n        currentNonceValue,\n        nonceAccountAddress,\n    });\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__NONCE_INVALID)) {\n        console.error(`The nonce has advanced to ${e.context.actualNonceValue}`);\n        // Re-sign and retry the transaction.\n        return;\n    } else if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n        console.error(`No nonce account was found at ${nonceAccountAddress}`);\n    }\n    throw e;\n}\n```\n\n----------------------------------------\n\nTITLE: Using BASE_ACCOUNT_SIZE Constant in TypeScript\nDESCRIPTION: Demonstrates the usage of the BASE_ACCOUNT_SIZE constant to calculate the total size of an account including its data.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Error with Lexical Discriminator\nDESCRIPTION: This snippet shows that using the `useValuesAsDiscriminators` option with an enum that contains a lexical value will throw an error. It relies on the `getEnumCodec` function and demonstrates a limitation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nenum Lexical {\n    One,\n    Two = 'two',\n}\ngetEnumCodec(Lexical, { useValuesAsDiscriminators: true }); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Querying Program Accounts with Data Encoding in TypeScript\nDESCRIPTION: This snippet extends the previous query to include data encoding options, specifically querying account data in BASE_64 format while also specifying a data slice that limits the length of the response data.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($programAddress: String!) {\n        programAccounts(programAddress: $programAddress) {\n            data(encoding: BASE_64, dataSlice: { length: 5, offset: 0 })\n        }\n    }\n`;\n\nconst variableValues = {\n    programAddress: 'DXngmJfjurhnAwbMPgpUGPH6qNvetCKRJ6PiD4ag4PTj',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Using Updated Nullable Codec in TypeScript\nDESCRIPTION: Example of using the updated getNullableCodec function with new options for zeroable codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Before.\ngetZeroableNullableCodec(getU16Codec());\n\n// After.\ngetNullableCodec(getU16Codec(), { noneValue: 'zeroes', prefix: null });\n```\n\n----------------------------------------\n\nTITLE: Using Fixed-Size UTF-8 Codec in TypeScript\nDESCRIPTION: Shows how to use the fixCodecSize function with a UTF-8 codec to create a fixed-size string codec that truncates or pads strings as needed.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = fixCodecSize(getUtf8Codec(), 5);\n\ncodec.encode('hello');\n// 0x68656c6c6f\n//   └-- The exact 5 bytes of content.\n\ncodec.encode('hello world');\n// 0x68656c6c6f\n//   └-- The truncated 5 bytes of content.\n\ncodec.encode('hell');\n// 0x68656c6c00\n//   └-- The padded 5 bytes of content.\n\ncodec.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f, 0xff, 0xff, 0xff, 0xff]));\n// 'hello'\n```\n\n----------------------------------------\n\nTITLE: Querying Nested Account Information with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet shows how to query nested account data by querying the owner field, which is also an account interface, allowing for more complex data retrieval in the response structure.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            address\n            owner {\n                address\n                executable\n                lamports\n            }\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Using getI32Codec for Signed 32-bit Integers with Endianness Control in TypeScript\nDESCRIPTION: Demonstrates how to use getI32Codec to encode and decode signed 32-bit integers with configurable endianness. The codec supports values from -2,147,483,648 to 2,147,483,647 in either little-endian or big-endian format.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getI32Codec, Endian } from \"@solana/kit\";\n// Little-endian.\nconst codec = getI32Codec();\nconst bytes = codec.encode(-42); // 0xd6ffffff\nconst value = codec.decode(bytes); // -42\n\n// Big-endian.\nconst beCodec = getI32Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-42); // 0xffffffd6\nconst beValue = beCodec.decode(bytes); // -42\n```\n\n----------------------------------------\n\nTITLE: Defining Stake Program Instruction Type in TypeScript\nDESCRIPTION: Example showing how to type an instruction for the stake program\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype StakeProgramInstruction = IInstruction<'StakeConfig11111111111111111111111111111111'>;\n```\n\n----------------------------------------\n\nTITLE: Creating Base Transaction Message\nDESCRIPTION: Initializes an empty transaction message with version specification using Kit library.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionMessage = pipe(\n  createTransactionMessage({ version: 0 }),\n);\n```\n\n----------------------------------------\n\nTITLE: Renaming Codec Functionality in TypeScript\nDESCRIPTION: This snippet showcases the renaming of the `mapCodec` to `transformCodec` along with other related changes in the codec functionality. The renaming improves clarity and matches the tool's operation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetStringCodec({ size: 'variable' }); // Variable.\ngetStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\ngetStringCodec({ size: 5 }); // Fixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\ngetStringCodec(); // Prefixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\n\n// After.\ngetUtf8Codec(); // Variable.\nfixCodecSize(getUtf8Codec(), 5); // Fixed.\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Transforming U32 to String Codec\nDESCRIPTION: Example of transforming a U32 codec to handle string representations of numbers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst getStringU32Codec = () =>\n    transformCodec(\n        getU32Codec(),\n        (integerAsString: string): number => parseInt(integerAsString),\n        (integer: number): string => integer.toString(),\n    );\n\ngetStringU32Codec().encode('42'); // new Uint8Array([42])\ngetStringU32Codec().decode(new Uint8Array([42])); // \"42\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Decoder-Only Implementation for a Person Type\nDESCRIPTION: Shows how to create a decoder-only implementation for a Person type, allowing for tree-shaking of encoder logic when only decoding is needed. Demonstrates the decoder-focused pattern for performance optimization.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonDecoder = (): Decoder<Person> =>\n  getStructDecoder([\n    [\"name\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\"age\", getU32Decoder()],\n    [\"verified\", getBooleanDecoder()],\n  ]);\n\nconst person = getPersonDecoder().decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Get Constant Codec in Typescript\nDESCRIPTION: This snippet demonstrates the usage of `getConstantCodec` function, which creates a Codec that always encodes to a predefined `Uint8Array`. Decoding verifies that the input matches the constant array.  The codec returned is `Codec<void>`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\n    codec.encode(undefined); // 0x010203\n    codec.decode(new Uint8Array([1, 2, 3])); // undefined\n    codec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js Technology Preview 4\nDESCRIPTION: Command to install the fourth Technology Preview of the Solana JavaScript SDK using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp4\n```\n\n----------------------------------------\n\nTITLE: Creating Result Response Transformer - TypeScript\nDESCRIPTION: Returns a transformer that extracts the result field from an RPC response, simplifying the response data structure from a JSON object to a raw value, which is crucial for efficient data handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getResultResponseTransformer } from '@solana/rpc-transformers';\n\nconst responseTransformer = getResultResponseTransformer();\n```\n\n----------------------------------------\n\nTITLE: Updating simulateTransaction RPC Method in Solana Web3.js\nDESCRIPTION: Enhances the `simulateTransaction` RPC method to include an optional `innerInstructions` parameter, which returns an array of inner instructions when set to true\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: NPM Patch Command Reference\nDESCRIPTION: Command-line tools referenced for creating and applying security patches across different package managers (pnpm, yarn, and patch-package for npm users).\nSOURCE: https://github.com/anza-xyz/kit/blob/main/SECURITY.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\npnpm patch\nyarn patch\npatch-package\n```\n\n----------------------------------------\n\nTITLE: Codec Definition for Account Data\nDESCRIPTION: Demonstrates how to define a codec for encoding and decoding account data using Kit's codec system.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  address,\n  Address,\n  addCodecSizePrefix,\n  Codec,\n  getAddressCodec,\n  getStructCodec,\n  getU32Codec,\n  getU8Codec,\n  getUtf8Codec,\n} from \"@solana/kit\";\n\ntype Person = {\n  age: number;\n  discriminator: number;\n  name: string;\n  wallet: Address;\n};\n\nconst personCodec: Codec<Person> = getStructCodec([\n  [\"discriminator\", getU8Codec()], // A single-byte account discriminator.\n  [\"wallet\", getAddressCodec()], // A 32-byte account address.\n  [\"age\", getU8Codec()], // An 8-bit unsigned integer.\n  [\"name\", addCodecSizePrefix(getUtf8Codec(), getU32Codec())], // A UTF-8 string with a 32-bit length prefix.\n]);\n\nconst bytes = personCodec.encode({\n  age: 42,\n  discriminator: 0,\n  name: \"Alice\",\n  wallet: address(\"1234..5678\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Enums with getEnumCodec\nDESCRIPTION: Demonstrates how to use getEnumCodec to encode and decode enum values. Shows basic usage with numeric enums and supports both enum values and string keys as input.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction {\n  Left,\n  Right,\n}\n\nconst codec = getEnumCodec(Direction);\nconst bytes = codec.encode(Direction.Left); // 0x00\nconst direction = codec.decode(bytes); // Direction.Left\n```\n\n----------------------------------------\n\nTITLE: Defining RPC client methods\nDESCRIPTION: This code snippet defines the type for an RPC client that contains required API methods to execute queries using RPC-GraphQL. The API methods include `GetAccountInfoApi`, `GetBlockApi`, `GetMultipleAccountsApi`, `GetProgramAccountsApi`, and `GetTransactionApi`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nRpc<GetAccountInfoApi & GetBlockApi & GetMultipleAccountsApi & GetProgramAccountsApi & GetTransactionApi>;\n```\n\n----------------------------------------\n\nTITLE: Updating Client Type with Compute Unit Limit Estimation Function\nDESCRIPTION: This code updates the Client type to include an estimateAndSetComputeUnitLimit function. This function will be used to estimate and set compute unit limits for transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CompilableTransactionMessage, // [!code ++]\n  // ...\n} from \"@solana/kit\";\n\nexport type Client = {\n  estimateAndSetComputeUnitLimit: <T extends CompilableTransactionMessage>(transactionMessage: T) => Promise<T>; // [!code ++]\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n  wallet: TransactionSigner & MessageSigner;\n};\n```\n\n----------------------------------------\n\nTITLE: Using I128Codec to Encode/Decode Signed 128-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding signed 128-bit integers using both little-endian (default) and big-endian representations. The codec supports values from -2^127 to 2^127 - 1 and returns BigInt values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getI128Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getI128Codec();\nconst bytes = codec.encode(-42); // 0xd6ffffffffffffffffffffffffffffff\nconst value = codec.decode(bytes); // BigInt(-42)\n\n// Big-endian.\nconst beCodec = getI128Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-42); // 0xffffffffffffffffffffffffffffffd6\nconst beValue = beCodec.decode(bytes); // BigInt(-42)\n```\n\n----------------------------------------\n\nTITLE: Refactoring Transactions in Solana\nDESCRIPTION: This change separates the construction of transaction messages from the signing and sending of compiled transactions. Functionality for creating/modifying transaction messages was moved to `@solana/transaction-messages`. Transactions now represent a compiled transaction message and a map of signatures for each required signer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Dropping Release Candidate Label - Solana\nDESCRIPTION: This patch change signifies the official release of `@solana/web3.js` at version 2.0.0, marking the end of the Release Candidate phase. This indicates that the package is considered stable and ready for production use. It reflects a high level of confidence in the library's quality and reliability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: N/A\nCODE:\n```\n``135dc5a`](https://github.com/solana-labs/solana-web3.js/commit/135dc5ad43f286380a4c3a689668016f0d7945f4) Thanks [@steveluscher](https://github.com/steveluscher)! - Drop the Release Candidate label and publish `@solana/web3.js` at version 2.0.0``\n```\n\n----------------------------------------\n\nTITLE: Using RpcRequest and RpcResponse in RPC Subscriptions\nDESCRIPTION: This change implements the use of RpcRequest, RpcResponse, and their transformers in the RPC Subscriptions packages for consistency with the RPC architecture.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- [#3407](https://github.com/solana-labs/solana-web3.js/pull/3407) [`10b08ac`](https://github.com/solana-labs/solana-web3.js/commit/10b08ac8cdb61aa1412475426cfcaf0eefe32722) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Use `RpcRequest`, `RpcResponse` and their transformers in RPC Subscriptions packages\n```\n\n----------------------------------------\n\nTITLE: Using Wallet Account Transaction Sending Signer in React\nDESCRIPTION: Shows how to use the useWalletAccountTransactionSendingSigner hook to both sign and send transactions. The component creates a transaction to record a memo on the Solana blockchain and sends it using the wallet.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useWalletAccountTransactionSendingSigner } from '@solana/react';\nimport {\n    appendTransactionMessageInstruction,\n    createSolanaRpc,\n    getBase58Decoder,\n    pipe,\n    setTransactionMessageFeePayerSigner,\n    setTransactionMessageLifetimeUsingBlockhash,\n    signAndSendTransactionMessageWithSigners,\n} from '@solana/kit';\n\nfunction RecordMemoButton({ account, rpc, text }) {\n    const signer = useWalletAccountTransactionSendingSigner(account, 'solana:devnet');\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { value: latestBlockhash } = await createSolanaRpc('https://api.devnet.solana.com')\n                        .getLatestBlockhash()\n                        .send();\n                    const message = pipe(\n                        createTransactionMessage({ version: 'legacy' }),\n                        m => setTransactionMessageFeePayerSigner(signer, m),\n                        m => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),\n                        m => appendTransactionMessageInstruction(getAddMemoInstruction({ memo: text }), m),\n                    );\n                    const signatureBytes = await signAndSendTransactionMessageWithSigners(message);\n                    const base58Signature = getBase58Decoder().decode(signature);\n                    window.alert(`View transaction: https://explorer.solana.com/tx/${base58Signature}?cluster=devnet`);\n                } catch (e) {\n                    console.error('Failed to record memo', e);\n                }\n            }}\n        >\n            Record Memo\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Floating-Point Numbers in TypeScript\nDESCRIPTION: Shows how to use f32 and f64 codecs to encode floating-point numbers with little-endian encoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetF32Codec().encode(-1.5); // 0x0000c0bf\ngetF64Codec().encode(-1.5); // 0x000000000000f8bf\n```\n\n----------------------------------------\n\nTITLE: Custom Enum Size with u32 Codec\nDESCRIPTION: This snippet configures the `getEnumCodec` to use a `u32` number codec for storing the enum value instead of the default `u8`. It relies on the `getEnumCodec` and `getU32Codec` functions. It demonstrates customizing the size option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32DirectionCodec = getEnumCodec(Direction, { size: getU32Codec() });\nu32DirectionCodec.encode(Direction.Left); // 0x00000000\nu32DirectionCodec.encode(Direction.Right); // 0x01000000\n```\n\n----------------------------------------\n\nTITLE: Using Separate Unit Encoder and Decoder in TypeScript\nDESCRIPTION: Shows how to use the separate getUnitEncoder and getUnitDecoder functions for encoding and decoding unit values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ngetUnitEncoder().encode(undefined);\ngetUnitDecoder().decode(anyBytes);\n```\n\n----------------------------------------\n\nTITLE: Defining an RPC API Interface in TypeScript\nDESCRIPTION: Demonstrates how to define a TypeScript interface for a Solana RPC method. The example shows a simple API definition for a method called 'getSomething' that takes an Address parameter and returns a Something object.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ExampleApi = {\n    getSomething(address: Address): Something;\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Common Account Fields\nDESCRIPTION: This code snippet shows how to query common fields from the `Account` interface using a GraphQL query. The query retrieves `executable`, `lamports`, and `rentEpoch` for a specified account address, showcasing how to access generic account properties.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($address: String!) {\n        account(address: $address) {\n            executable\n            lamports\n            rentEpoch\n        }\n    }\n`;\n\nconst variableValues = {\n    address: 'AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Transforming U64 to String Codec\nDESCRIPTION: Implementation of a codec that transforms between string/number and bigint representations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst getStringU64Codec = () =>\n    transformCodec(\n        getU64Codec(),\n        (integerInput: number | string): number | bigint =>\n            typeof integerInput === 'string' ? BigInt(integerAsString) : integerInput,\n        (integer: bigint): string => integer.toString(),\n    );\n```\n\n----------------------------------------\n\nTITLE: Resizing Fixed-Size Codec in TypeScript\nDESCRIPTION: Demonstrates how to use resizeCodec to adjust the size of a fixed-size codec. The function accepts the original codec and a function that calculates the new size based on the current size.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// Fixed-size codec.\nconst getBiggerU32Codec = () => resizeCodec(getU32Codec(), size => size + 4);\ngetBiggerU32Codec().encode(42);\n// 0x2a00000000000000\n//   |       └-- Empty buffer space caused by the resizeCodec function.\n//   └-- Our encoded u32 number.\n```\n\n----------------------------------------\n\nTITLE: Using ShortU16Codec for Compact Unsigned Integer Encoding in TypeScript\nDESCRIPTION: Demonstrates the space-efficient ShortU16Codec that uses 1 to 3 bytes based on the value being encoded. Supports values from 0 to 4,194,303 (2^22 - 1) with variable-length encoding based on value size.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getShortU16Codec } from \"@solana/kit\";\n\nconst codec = getShortU16Codec();\nconst bytes1 = codec.encode(42); // 0x2a\nconst bytes2 = codec.encode(128); // 0x8001\nconst bytes3 = codec.encode(16384); // 0x808001\n\ncodec.decode(bytes1); // 42\ncodec.decode(bytes2); // 128\ncodec.decode(bytes3); // 16384\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Transaction Message\nDESCRIPTION: Demonstrates creating a basic transaction message with a specific version using the createTransactionMessage function\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTransactionMessage } from '@solana/transaction-messages';\n\nconst tx = createTransactionMessage({ version: 0 });\n```\n\n----------------------------------------\n\nTITLE: Separate Enum Encoder/Decoder\nDESCRIPTION: This snippet demonstrates using separate `getEnumEncoder` and `getEnumDecoder` functions for encoding and decoding enum values. It shows an alternative to using the combined `getEnumCodec` function. It implicitly depends on `getEnumEncoder` and `getEnumDecoder`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getEnumEncoder(Direction).encode(Direction.Left);\nconst direction = getEnumDecoder(Direction).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Creating Default Solana RPC Subscriptions Channel Creator\nDESCRIPTION: Function to create a Solana-specific RPC subscriptions channel creator. It handles BigInt values in JSON messages for Solana RPC servers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ncreateDefaultSolanaRpcSubscriptionsChannelCreator(config)\n```\n\n----------------------------------------\n\nTITLE: Nullable codec without prefix in TypeScript\nDESCRIPTION: Demonstrates how to create nullable codecs without a boolean prefix by setting the prefix option to null. In this case, the codec relies on the noneValue option to determine whether the item is null.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nconst codecWithZeroNoneValue = getNullableCodec(getU16Codec(), {\n  noneValue: \"zeroes\", // 0x0000 means null.\n  prefix: null,\n});\ncodecWithZeroNoneValue.encode(42); // 0x2a00\ncodecWithZeroNoneValue.encode(null); // 0x0000\n\nconst codecWithCustomNoneValue = getNullableCodec(getU16Codec(), {\n  noneValue: new Uint8Array([255]), // 0xff means null.\n  prefix: null,\n});\ncodecWithCustomNoneValue.encode(42); // 0x2a00\ncodecWithCustomNoneValue.encode(null); // 0xff\n```\n\n----------------------------------------\n\nTITLE: Implementing U32 Codec with Offset Control\nDESCRIPTION: Shows how to move the offset of a codec 2 bytes forward using offsetCodec helper.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n  preOffset: ({ preOffset }) => preOffset + 2,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n```\n\n----------------------------------------\n\nTITLE: Using Synchronous Instruction Builder for CreateLookupTable\nDESCRIPTION: Demonstrates the use of a synchronous instruction builder for CreateLookupTable when all required inputs are available.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst [address, bump] = await findAddressLookupTablePda({\n    authority: authority.address,\n    recentSlot,\n});\n\nconst instruction = getCreateLookupTableInstruction({\n    address,\n    authority,\n    bump,\n    recentSlot,\n});\n```\n\n----------------------------------------\n\nTITLE: Working with Custom RPC Subscriptions API in Solana\nDESCRIPTION: The snippet details setting up custom RPC subscription APIs for specific Solana clusters and using unstable subscriptions, expanding the capabilities of the default API. Requires '@solana/kit' and an understanding of the various transport and subscription configuration methods.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    createDefaultRpcSubscriptionsTransport,\n    createSolanaRpcSubscriptions_UNSTABLE,\n    createSolanaRpcSubscriptionsFromTransport_UNSTABLE,\n} from '@solana/kit';\n\n// Using the default WebSocket channel.\nconst rpcSubscriptions = createSolanaRpcSubscriptions_UNSTABLE('ws://127.0.0.1:8900');\n//    ^? RpcSubscriptions<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n\n// Using a custom transport.\nconst transport = createDefaultRpcSubscriptionsTransport({\n    createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({\n        url: 'ws://127.0.0.1:8900',\n    }),\n});\nconst rpcSubscriptions = createSolanaRpcSubscriptionsFromTransport_UNSTABLE(transport);\n//    ^? RpcSubscriptions<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n```\n\n----------------------------------------\n\nTITLE: Using Bytes Codec Functions in TypeScript\nDESCRIPTION: Shows improved bytes codec functions including variable, fixed, and prefixed size variants. Includes both the old way with options and the new cleaner approach.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ngetBytesCodec({ size: getU16Codec() }); // Prefixed.\n\n// After.\ngetBytesCodec(); // Variable.\nfixCodecSize(getBytesCodec(), 5); // Fixed.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Adding Subscription Coalescing to RPC Subscriptions Transport\nDESCRIPTION: Function to wrap an RPC subscriptions transport with subscription coalescing, combining identical subscriptions into a single request.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\ngetRpcSubscriptionsTransportWithSubscriptionCoalescing(transport)\n```\n\n----------------------------------------\n\nTITLE: Using Zeroable Nullable/Option Codecs in TypeScript\nDESCRIPTION: Introduces getZeroableNullableCodec and getZeroableOptionCodec functions that use zero values to represent null or None, as opposed to using boolean prefixes. Shows both basic usage and custom zero value configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec());\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0x0000\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.encode(new Uint8Array([0, 0])); // null\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec(), {\n    zeroValue: new Uint8Array([255, 255]),\n});\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0xfffff\ncodec.encode(new Uint8Array([0, 0])); // 0\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([255, 255])); // null\n```\n\n----------------------------------------\n\nTITLE: Encoding Discriminated Unions\nDESCRIPTION: This snippet demonstrates how to encode different variants of the discriminated union defined in the previous example. It encodes a `Quit`, `Write`, and `Move` message.  It depends on the `messageCodec` defined above.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nmessageCodec.encode({ __kind: 'Quit' });\n// 0x00\n//   └-- 1-byte discriminator (Index 0 — the \"Quit\" variant).\n\nmessageCodec.encode({ __kind: 'Write', fields: ['Hi'] });\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte discriminator (Index 1 — the \"Write\" variant).\n\nmessageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n// 0x020500000006000000\n//   | |       └-- Field y (6).\n//   | └-- Field x (5).\n//   └-- 1-byte discriminator (Index 2 — the \"Move\" variant).\n```\n\n----------------------------------------\n\nTITLE: Customizing Discriminated Union Size Codec\nDESCRIPTION: Demonstrates how to customize the discriminator size codec by using u32 instead of the default u8, with examples showing the resulting encoded bytes for different variant types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32MessageCodec = getDiscriminatedUnionCodec(\n  [\n    [\"quit\", quitCodec],\n    [\"write\", writeCodec],\n    [\"move\", moveCodec],\n  ],\n  { size: getU32Codec() },\n);\n\nu32MessageCodec.encode({ __kind: \"quit\" });\n// 0x00000000\n//   └------┘ 4-byte discriminator (Index 0).\n\nu32MessageCodec.encode({ __kind: \"write\", fields: [\"Hi\"] });\n// 0x01000000020000004869\n//   └------┘ 4-byte discriminator (Index 1).\n\nu32MessageCodec.encode({ __kind: \"move\", x: 5, y: 6 });\n// 0x020000000500000006000000\n//   └------┘ 4-byte discriminator (Index 2).\n```\n\n----------------------------------------\n\nTITLE: Encoding Unsigned Integers in TypeScript\nDESCRIPTION: Demonstrates how to use unsigned integer codecs to encode values of different byte sizes. The default endianness is little-endian.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Unsigned integers.\ngetU8Codec().encode(42); // 0x2a\ngetU16Codec().encode(42); // 0x2a00\ngetU32Codec().encode(42); // 0x2a000000\ngetU64Codec().encode(42); // 0x2a00000000000000\ngetU128Codec().encode(42); // 0x2a000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Fetching Encoded Sysvar Account using RPC in Typescript\nDESCRIPTION: This snippet demonstrates how to fetch an encoded sysvar account using an RPC client in Typescript. It uses the `fetchEncodedSysvarAccount` function with the RPC client and the `SYSVAR_CLOCK_ADDRESS` to retrieve the encoded clock sysvar. The result is type-checked to ensure it satisfies `MaybeEncodedAccount`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst maybeEncodedClock = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS);\nmaybeEncodedClock satisfies MaybeEncodedAccount<'SysvarC1ock11111111111111111111111111111111'>;\n```\n\n----------------------------------------\n\nTITLE: Enum Value vs Key Encoding\nDESCRIPTION: This snippet shows that the `getEnumCodec` can encode either the enum value itself (e.g., `Direction.Left`) or its key (e.g., `'Left'`). The result is the same in both cases. It implicitly relies on the `getEnumCodec` function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction {\n    Left,\n    Right,\n}\n\ngetEnumCodec(Direction).encode(Direction.Left); // 0x00\ngetEnumCodec(Direction).encode(Direction.Right); // 0x01\ngetEnumCodec(Direction).encode('Left'); // 0x00\ngetEnumCodec(Direction).encode('Right'); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Using useSignIn Hook in React\nDESCRIPTION: Example of how to use the useSignIn hook to implement a Sign In With Solana feature in a React component. It shows how to handle the sign-in process, including error handling and user authentication.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSignIn } from '@solana/react';\n\nfunction SignInButton({ wallet }) {\n    const csrfToken = useCsrfToken();\n    const signIn = useSignIn(wallet);\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { account, signedMessage, signature } = await signIn({\n                        requestId: csrfToken,\n                    });\n                    // Authenticate the user, typically on the server, by verifying that\n                    // `signedMessage` was signed by the person who holds the private key for\n                    // `account.publicKey`.\n                    //\n                    // Authorize the user, also on the server, by decoding `signedMessage` as the\n                    // text of a Sign In With Solana message, verifying that it was not modified\n                    // from the values your application expects, and that its content is sufficient\n                    // to grant them access.\n                    window.alert(`You are now signed in with the address ${account.address}`);\n                } catch (e) {\n                    console.error('Failed to sign in', e);\n                }\n            }}\n        >\n            Sign In\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Separate Encoder and Decoder into a Complete Codec\nDESCRIPTION: Demonstrates how to combine separate encoder and decoder implementations into a complete codec for convenience while maintaining tree-shakeability. Shows the pattern recommended for library maintainers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonCodec = (): Codec<Person> => combineCodec(getPersonEncoder(), getPersonDecoder());\n```\n\n----------------------------------------\n\nTITLE: Enforcing matching clusters for nonce invalidation in Solana web3.js\nDESCRIPTION: This patch modifies `createNonceInvalidationPromiseFactory` within Solana web3.js to enforce that `rpc` and `rpcSubscriptions` have matching clusters. Similar to the signature confirmation change, the function signature is updated to accept an object.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Implementing Complete ModuloU8 Codec\nDESCRIPTION: Complete implementation of a custom codec that handles unsigned 8-bit integers with modulo operation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst getModuloU8Codec = () =>\n    createCodec<number>({\n        fixedSize: 1,\n        read(bytes, offset) {\n            const value = bytes[offset];\n            return [value, offset + 1];\n        },\n        write(value, bytes, offset) {\n            bytes.set(value % 256, offset);\n            return offset + 1;\n        },\n    });\n```\n\n----------------------------------------\n\nTITLE: Defining GenericInstruction Schema in GraphQL\nDESCRIPTION: GraphQL schema definition for the GenericInstruction type which implements the TransactionInstruction interface. This is the base parsed instruction type that contains accounts, data, and programId fields.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_20\n\nLANGUAGE: graphql\nCODE:\n```\ntype GenericInstruction implements TransactionInstruction {\n    accounts: [Address]\n    data: Base64EncodedBytes\n    programId: Address\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Account Data with Hardcoded Address\nDESCRIPTION: This code snippet shows how to query account data using the `query` method of the `RpcGraphQL` client with a hardcoded account address. The GraphQL query is defined in the `source` variable, and the result is awaited from `rpcGraphQL.query(source)`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery {\n        account(address: \\\"AyGCwnwxQMCqaU4ixReHt8h5W4dwmxU7eM3BEQBdWVca\\\") {\n            lamports\n        }\n    }\n`;\n\nconst result = await rpcGraphQL.query(source);\n```\n\n----------------------------------------\n\nTITLE: Creating Default RPC Subscriptions Channel Creator\nDESCRIPTION: Function to create a default RPC subscriptions channel creator. It takes a configuration object as an argument.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ncreateDefaultRpcSubscriptionsChannelCreator(config)\n```\n\n----------------------------------------\n\nTITLE: Creating Async Iterable from Data Publisher - TypeScript\nDESCRIPTION: This function creates an AsyncIterable from a data publisher, allowing for efficient data consumption with error handling and an abort signal.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst iterable = createAsyncIterableFromDataPublisher({\\n    abortSignal: AbortSignal.timeout(10_000),\\n    dataChannelName: 'message',\\n    dataPublisher,\\n    errorChannelName: 'error',\\n});\\ntry {\\n    for await (const message of iterable) {\\n        console.log('Got message', message);\\n    }\\n} catch (e) {\\n    console.error('An error was published to the error channel', e);\\n} finally {\\n    console.log(\"It's been 10 seconds; that's enough for now.\");\\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Transaction with Web3.js\nDESCRIPTION: This snippet illustrates how to sign a transaction using keypairs in Web3.js. It generates keypairs for the payer and authority, then signs the transaction with those keypairs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Keypair, Transaction } from \"@solana/web3.js\";\n\nconst payer = Keypair.generate();\nconst authority = Keypair.generate();\n\ntransaction.sign([payer, authority]);\n```\n\n----------------------------------------\n\nTITLE: Variable Size String to Buffer Codec in TypeScript\nDESCRIPTION: Defines a variable size codec to transform alphabetic strings to numeric buffers, demonstrating the codec’s flexibility in handling and translating variable-sized data efficiently. Requires utilities from @solana/kit with the ability to transition string inputs to numeric buffer outputs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEncoder, createDecoder, combineCodec } from \"@solana/kit\";\n\nconst alphabet = \" abcdefghijklmnopqrstuvwxyz\";\n\nconst getCipherEncoder = () =>\n  createEncoder<string>({\n    getSizeFromValue: (value) => value.length,\n    write(value, bytes, offset) {\n      const bytesToAdd = [...value].map((char) => alphabet.indexOf(char));\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    },\n  });\n\nconst getCipherDecoder = () =>\n  createDecoder<string>({\n    read(bytes, offset) {\n      const value = [...bytes.slice(offset)].map((byte) => alphabet.charAt(byte)).join(\"\");\n      return [value, bytes.length];\n    },\n  });\n\nconst getCipherCodec = () => combineCodec(getCipherEncoder(), getCipherDecoder());\n```\n\n----------------------------------------\n\nTITLE: Boolean Codec Implementation in TypeScript\nDESCRIPTION: Implements a boolean codec that encodes booleans as 0 or 1 using a u8 number. This codec can also be customized with different number codecs to change the encoding of the boolean values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBooleanCodec().encode(true); // 0x01\nconst value = getBooleanCodec().decode(bytes); // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ngetBooleanCodec({ size: getU16Codec() }).encode(false); // 0x0000\ngetBooleanCodec({ size: getU16Codec() }).encode(true); // 0x0100\n\ngetBooleanCodec({ size: getU32Codec() }).encode(false); // 0x00000000\ngetBooleanCodec({ size: getU32Codec() }).encode(true); // 0x01000000\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBooleanEncoder().encode(true); // 0x01\nconst value = getBooleanDecoder().decode(bytes); // true\n```\n\n----------------------------------------\n\nTITLE: JSON RPC API Creation Example\nDESCRIPTION: Demonstrates creating a JSON RPC API with request and response transformers using createJsonRpcApi function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// For example, given this `RpcApi`:\nconst rpcApi = createJsonRpcApi({\n    requestTransformer: (...rawParams) => rawParams.reverse(),\n    responseTransformer: response => response.result,\n});\n\n// ...the following function call:\nrpcApi.foo('bar', { baz: 'bat' });\n\n// ...will produce an `RpcPlan` that:\n// -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n// -   Returns the \"result\" property of the RPC response.\n```\n\n----------------------------------------\n\nTITLE: Value-Based Enum Encoding\nDESCRIPTION: Demonstrates using useValuesAsDiscriminators option to encode actual enum values instead of indices for numerical enums.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getEnumCodec(Numbers, { useValuesAsDiscriminators: true });\ncodec.encode(Numbers.One); // 0x00\ncodec.encode(Numbers.Five); // 0x05\ncodec.encode(Numbers.Six); // 0x06\ncodec.encode(Numbers.Nine); // 0x09\n```\n\n----------------------------------------\n\nTITLE: Getting Default Response Transformer for Solana RPC - TypeScript\nDESCRIPTION: Returns the default response transformer for the Solana RPC API. It composes multiple response transformers to handle potential errors and to extract results from responses, ensuring consistent processing of response data.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n\nconst responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n    allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Zeroable Nullable Codec in TypeScript\nDESCRIPTION: Example of using the new getZeroableNullableCodec function in TypeScript.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec());\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0x0000\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.encode(new Uint8Array([0, 0])); // null\n```\n\n----------------------------------------\n\nTITLE: Modification of getBytesCodec in TypeScript\nDESCRIPTION: This snippet highlights the changes to the `getBytesCodec` function, which now consistently returns a `VariableSizeCodec`. It outlines how to fix or prefix the size of byte arrays using new utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetBytesCodec(); // Variable.\ngetBytesCodec({ size: 5 }); // Fixed.\ngetBytesCodec({ size: getU16Codec() }); // Prefixed.\n\n// After.\ngetBytesCodec(); // Variable.\nfixCodecSize(getBytesCodec(), 5); // Fixed.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Defining IAccountSignerMeta for Transactions\nDESCRIPTION: Demonstrates how to create an account meta that includes a transaction signer, allowing instructions to track their own signers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignerMeta: IAccountSignerMeta = {\n    address: myTransactionSigner.address,\n    role: AccountRole.READONLY_SIGNER,\n    signer: myTransactionSigner,\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Tree Walker Request Transformer - TypeScript\nDESCRIPTION: Creates a transformer that traverses request parameters and executes provided visitors at each node. An initial state object is required for starting the traversal, which must have a keyPath attribute.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n\nconst requestTransformer = getTreeWalkerRequestTransformer(\n    [\n        // Replaces foo.bar with \"baz\".\n        (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n        // Increments all numbers by 1.\n        node => (typeof node === number ? node + 1 : node),\n    ],\n    { keyPath: [] },\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Person Decoder\nDESCRIPTION: Shows how to create a standalone decoder for the Person type, useful when only decoding functionality is needed.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonDecoder = (): Decoder<Person> =>\n    getStructDecoder([\n        ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n        ['age', getU32Decoder()],\n    ]);\n\nconst person = getPersonDecoder().decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Using preOffset with offsetCodec in TypeScript\nDESCRIPTION: Shows how to use the preOffset function to adjust where encoding/decoding begins. This positions a u32 number 2 bytes into an 8-byte buffer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n    preOffset: ({ preOffset }) => preOffset + 2,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n// 0x0000ffffffff0000\n//       └-- Our encoded u32 number is now in the middle of the buffer.\n```\n\n----------------------------------------\n\nTITLE: Using Person Codec for Encoding/Decoding\nDESCRIPTION: Demonstrates how to use the Person codec to encode and decode data between Person objects and byte arrays.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst personCodec = getPersonCodec();\nconst bytes = personCodec.encode({ name: 'John', age: 42 });\nconst person = personCodec.decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy VersionedTransaction using @solana/compat\nDESCRIPTION: Illustrates the conversion of a legacy VersionedTransaction to a modern transaction type using @solana/compat.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\n// Note that you can only convert `VersionedTransaction` objects\nconst modernTransaction = fromVersionedTransaction(classicTransaction);\n```\n\n----------------------------------------\n\nTITLE: Using addCodecSentinel in TypeScript for Delimited Data Encoding\nDESCRIPTION: An example demonstrating the addCodecSentinel function which adds a sentinel marker at the end of encoded data. This allows for reading until that sentinel is found when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\ncodec.encode('hello');\n// 0x68656c6c6fffff\n//   |        └-- Our sentinel.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Creating and Using an Encoder-Only Implementation for a Person Type\nDESCRIPTION: Shows how to create an encoder-only implementation for a Person type, allowing for tree-shaking of decoder logic when only encoding is needed. Demonstrates the encoder-focused pattern for performance optimization.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonEncoder = (): Encoder<Person> =>\n  getStructEncoder([\n    [\"name\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    [\"age\", getU32Encoder()],\n    [\"verified\", getBooleanEncoder()],\n  ]);\n\nconst bytes = getPersonEncoder().encode({ name: \"John\", age: 42, verified: true });\n```\n\n----------------------------------------\n\nTITLE: Using Sign Transaction Hook in React\nDESCRIPTION: Shows how to use the useSignTransaction hook to sign a serialized transaction with a wallet account. This hook provides a simpler interface than useWalletAccountTransactionSigner for basic transaction signing.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSignTransaction } from '@solana/react';\n\nfunction SignTransactionButton({ account, transactionBytes }) {\n    const signTransaction = useSignTransaction(account, 'solana:devnet');\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const { signedTransaction } = await signTransaction({\n                        transaction: transactionBytes,\n                    });\n                    window.alert(`Signed transaction bytes: ${signedTransaction.toString()}`);\n                } catch (e) {\n                    console.error('Failed to sign transaction', e);\n                }\n            }}\n        >\n            Sign Transaction\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Mixed Enum Type Encoding\nDESCRIPTION: Shows encoding of hybrid enums containing both numeric and string values, demonstrating how indices are used for encoding regardless of actual enum values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nenum Numbers {\n  One,\n  Five = 5,\n  Six,\n  Nine = \"nine\",\n}\n\ngetEnumCodec(Numbers).encode(Numbers.One); // 0x00\ngetEnumCodec(Numbers).encode(Numbers.Five); // 0x01\ngetEnumCodec(Numbers).encode(Numbers.Six); // 0x02\ngetEnumCodec(Numbers).encode(Numbers.Nine); // 0x03\n```\n\n----------------------------------------\n\nTITLE: Creating a Union Codec in TypeScript\nDESCRIPTION: Defines a union codec that can encode/decode types from a provided array of codecs. It utilizes helper functions to determine the appropriate codec based on the value or byte array provided.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number | boolean> = getUnionCodec(\n    [getU16Codec(), getBooleanCodec()],\n    value => (typeof value === 'number' ? 0 : 1),\n    (bytes, offset) => (bytes.slice(offset).length > 1 ? 0 : 1),\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\ncodec.encode(42); // 0x2a00\ncodec.encode(true); // 0x01\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getUnionEncoder(encoders, getIndexFromValue).encode(42);\nconst value = getUnionDecoder(decoders, getIndexFromBytes).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Using RpcTransportFromClusterUrl Type in TypeScript\nDESCRIPTION: Example showing how to create a custom transport function that returns a strongly-typed RPC transport based on the cluster URL. This demonstrates TypeScript's type system ensuring the returned transport matches the expected cluster type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createCustomTransport<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    /* ... */\n}\nconst transport = createCustomTransport(testnet('http://api.testnet.solana.com'));\ntransport satisfies RpcTransportTestnet; // OK\n```\n\n----------------------------------------\n\nTITLE: Using Program Libraries in Kit\nDESCRIPTION: Demonstrates how to use Kit's program libraries for fetching and decoding program-specific accounts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Account, address } from \"@solana/kit\";\nimport { fetchNonce, Nonce } from \"@solana-program/system\";\n\nconst account: Account<Nonce> = await fetchNonce(rpc, address(\"1234..5678\"));\n```\n\n----------------------------------------\n\nTITLE: Basic offsetCodec Usage in TypeScript\nDESCRIPTION: Demonstrates how to use offsetCodec to move the position of encoded data within a buffer. This example shows how to place a u32 number in the middle of an 8-byte buffer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst biggerU32Codec = resizeCodec(getU32Codec(), size => size + 4);\nbiggerU32Codec.encode(0xffffffff);\n// 0xffffffff00000000\n//   |       └-- Empty buffer space caused by the resizeCodec function.\n//   └-- Our encoded u32 number.\n```\n\n----------------------------------------\n\nTITLE: Adding Sentinel to UTF-8 Codec in TypeScript\nDESCRIPTION: Shows how to use the new addCodecSentinel function to add a sentinel at the end of UTF-8 encoded data for delimiting purposes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\ncodec.encode('hello');\n// 0x68656c6c6fffff\n//   |        └-- Our sentinel.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Transport Errors in Solana\nDESCRIPTION: This TypeScript snippet demonstrates how to handle errors thrown by the HTTP transport in Solana's RPC API. It specifically shows how to access HTTP response headers if an error occurs, such as a 429 Rate Limit error. The snippet requires @solana/rpc-transport-http package and its associated dependencies like @solana/errors for error handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntry {\n    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n} catch (e) {\n    if (isSolanaError(e, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR)) {\n        if (e.context.code === 429 /* rate limit error */) {\n            const retryAfterHeaderValue = e.context.headers.get('Retry-After');\n            if (retryAfterHeaderValue != null) {\n                // ...\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Literal Union Codec in TypeScript\nDESCRIPTION: A utility for creating a fixed-size codec that can encode and decode a specific set of literal values\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec(['left', 'right', 'up', 'down']);\n// ^? FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">\n\nconst bytes = codec.encode('left'); // 0x00\nconst value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Type Casting Known-Good Addresses in TypeScript\nDESCRIPTION: Shows how to efficiently typecast a known-good address string to the Address type without using the address() helper, which is more performant for trusted inputs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Address } from '@solana/addresses';\n\nconst MEMO_PROGRAM_ADDRESS =\n    'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n```\n\n----------------------------------------\n\nTITLE: Creating Explicit RPC Subscriptions API with Customized Transport in TypeScript\nDESCRIPTION: Demonstrates an alternative way to constrain the RPC Subscriptions API by explicitly creating it with createSolanaRpcSubscriptionsApi and binding it to a transport. This approach offers more control over the configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    createDefaultRpcSubscriptionsTransport,\n    createSubscriptionRpc,\n    createSolanaRpcSubscriptionsApi,\n    DEFAULT_RPC_CONFIG,\n    type AccountNotificationsApi,\n    type SlotNotificationsApi,\n} from '@solana/kit';\n\nconst api = createSolanaRpcSubscriptionsApi<AccountNotificationsApi & SlotNotificationsApi>(DEFAULT_RPC_CONFIG);\nconst transport = createDefaultRpcSubscriptionsTransport({\n    createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({\n        url: 'ws://127.0.0.1:8900',\n    }),\n});\nconst rpcSubscriptions = createSubscriptionRpc({ api, transport });\n```\n\n----------------------------------------\n\nTITLE: Using Short U16 Codec in TypeScript\nDESCRIPTION: Demonstrates the usage of the short u16 codec, which stores unsigned integers using 1 to 3 bytes depending on the value.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bytes = getShortU16Codec().encode(42); // 0x2a\nconst value = getShortU16Codec().decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Adding a Codec Sentinel Using TypeScript\nDESCRIPTION: The `addCodecSentinel` function is used to append a sentinel value to the end of encoded data, allowing for proper delimitation during decoding. The function requires a codec and a `Uint8Array` sentinel.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCodecSentinel, getUtf8Codec } from \"@solana/kit\";\n// ---cut-before---\nconst codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\ncodec.encode(\"hello\");\n// 0x68656c6c6fffff\n//   |        └-- Our sentinel.\n//   └-- Our encoded string.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCodecSentinel, getUtf8Codec } from \"@solana/kit\";\n// ---cut-before---\nconst sentinel = new Uint8Array([108, 108]); // 'll'\nconst codec = addCodecSentinel(getUtf8Codec(), sentinel);\n\ncodec.encode(\"hello\"); // Throws: sentinel is in encoded data.\ncodec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addEncoderSentinel, addDecoderSentinel, getUtf8Encoder, getUtf8Decoder } from \"@solana/kit\";\nconst sentinel = null as unknown as Uint8Array;\n// ---cut-before---\nconst bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode(\"hello\");\nconst value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Complex Type Transformation with Different From/To Types in TypeScript\nDESCRIPTION: Demonstrates more complex type transformation with codecs that have different input and output types. This example transforms a U64 codec to work with string representations while maintaining compatibility with number inputs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transformCodec, getU64Codec } from \"@solana/kit\";\nconst getStringU64Codec = () =>\n  transformCodec(\n    getU64Codec(),\n    (integerInput: number | string): number | bigint =>\n      typeof integerInput === \"string\" ? BigInt(integerInput) : integerInput,\n    (integer: bigint): string => integer.toString(),\n  );\n```\n\n----------------------------------------\n\nTITLE: Using Wallet Account Message Signer in React\nDESCRIPTION: Shows how to use the useWalletAccountMessageSigner hook to create a component that can sign messages with a wallet account. The hook returns an object that conforms to the MessageModifyingSigner interface from @solana/signers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/react/README.md#2025-04-18_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useWalletAccountMessageSigner } from '@solana/react';\nimport { createSignableMessage } from '@solana/signers';\n\nfunction SignMessageButton({ account, text }) {\n    const messageSigner = useWalletAccountMessageSigner(account);\n    return (\n        <button\n            onClick={async () => {\n                try {\n                    const signableMessage = createSignableMessage(text);\n                    const [signedMessage] = await messageSigner.modifyAndSignMessages([signableMessage]);\n                    const messageWasModified = signableMessage.content !== signedMessage.content;\n                    const signatureBytes = signedMessage.signatures[messageSigner.address];\n                    window.alert(\n                        `Signature bytes: ${signatureBytes.toString()}${\n                            messageWasModified ? ' (message was modified)' : ''\n                        }`,\n                    );\n                } catch (e) {\n                    console.error('Failed to sign message', e);\n                }\n            }}\n        >\n            Sign Message: {text}\n        </button>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reversed Endianness Codecs\nDESCRIPTION: Demonstrates how to reverse the byte order of a codec using the reverseCodec helper. This is useful for handling different endianness in data encoding and decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst getBigEndianU64Codec = () => reverseCodec(getU64Codec());\n```\n\n----------------------------------------\n\nTITLE: Refactoring Transactions in TypeScript\nDESCRIPTION: This snippet describes the refactoring of the transaction handling within the Solana library. It separates the construction of transaction messages from the signing and sending processes, enhancing maintainability and clarity.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nA transaction message contains a transaction version and an array of transaction instructions. It may also have a fee payer and a lifetime. Transaction messages can be built up incrementally, for example by adding instructions or a fee payer.\n\nTransactions represent a compiled transaction message (serialized to an immutable byte array) and a map of signatures for each required signer of the transaction message. These signatures are only valid for the byte array stored in the transaction. Transactions can be signed by updating this map of signatures, and when they have a valid signature for all required signers they can be landed on the network.\n```\n\n----------------------------------------\n\nTITLE: Documenting Version Changes in Markdown\nDESCRIPTION: This snippet shows the structure of documenting version changes in a markdown changelog. It includes version numbers, pull request references, commit hashes, and descriptions of changes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/promises/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @solana/promises\n\n## 2.1.0\n\n## 2.0.0\n\n### Patch Changes\n\n- [#3541](https://github.com/solana-labs/solana-web3.js/pull/3541) [`135dc5a`](https://github.com/solana-labs/solana-web3.js/commit/135dc5ad43f286380a4c3a689668016f0d7945f4) Thanks [@steveluscher](https://github.com/steveluscher)! - Drop the Release Candidate label and publish `@solana/web3.js` at version 2.0.0\n\n- [#3071](https://github.com/solana-labs/solana-web3.js/pull/3071) [`b4bf318`](https://github.com/solana-labs/solana-web3.js/commit/b4bf318d7d4bdd639e4c126c70350993a8540fe8) Thanks [@steveluscher](https://github.com/steveluscher)! - Created a helper that you can use to race two or more promises without having to worry about them leaking memory\n\n- [#3070](https://github.com/solana-labs/solana-web3.js/pull/3070) [`f2bb4e8`](https://github.com/solana-labs/solana-web3.js/commit/f2bb4e8c7f7efd049cb1c3810291c99e9293c25d) Thanks [@steveluscher](https://github.com/steveluscher)! - Created a package for dealing with JavaScript Promises, and copied the implementation of `getAbortablePromise` into it\n\n- [#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n\n## 2.0.0-rc.4\n\n## 2.0.0-rc.3\n\n## 2.0.0-rc.2\n\n### Patch Changes\n\n- [#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n\n## 2.0.0-rc.1\n\n### Patch Changes\n\n- [#3071](https://github.com/solana-labs/solana-web3.js/pull/3071) [`b4bf318`](https://github.com/solana-labs/solana-web3.js/commit/b4bf318d7d4bdd639e4c126c70350993a8540fe8) Thanks [@steveluscher](https://github.com/steveluscher)! - Created a helper that you can use to race two or more promises without having to worry about them leaking memory\n\n- [#3070](https://github.com/solana-labs/solana-web3.js/pull/3070) [`f2bb4e8`](https://github.com/solana-labs/solana-web3.js/commit/f2bb4e8c7f7efd049cb1c3810291c99e9293c25d) Thanks [@steveluscher](https://github.com/steveluscher)! - Created a package for dealing with JavaScript Promises, and copied the implementation of `getAbortablePromise` into it\n```\n\n----------------------------------------\n\nTITLE: Custom Size Enum Encoding\nDESCRIPTION: Demonstrates using custom number codec for enum encoding, allowing for different size representations of enum values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32DirectionCodec = getEnumCodec(Direction, { size: getU32Codec() });\nu32DirectionCodec.encode(Direction.Left); // 0x00000000\nu32DirectionCodec.encode(Direction.Right); // 0x01000000\n```\n\n----------------------------------------\n\nTITLE: Transform Encoding with Default Values in TypeScript @solana/kit\nDESCRIPTION: This snippet demonstrates using transformEncoder and a combination of other encoder utilities to manage default values for an optional property within an object. It ensures all coded objects have default values if not provided. Dependencies include @solana/kit utilities like transformEncoder, getStructEncoder, and others.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  Codec,\n  Encoder,\n  Decoder,\n  transformEncoder,\n  getStructEncoder,\n  getStructDecoder,\n  addEncoderSizePrefix,\n  addDecoderSizePrefix,\n  getUtf8Encoder,\n  getUtf8Decoder,\n  getU32Encoder,\n  getU32Decoder,\n  combineCodec,\n} from \"@solana/kit\";\ntype Person = { name: string; age: number };\ntype PersonInput = { name: string; age?: number };\n\nconst getPersonEncoder = (): Encoder<PersonInput> =>\n  transformEncoder(\n    getStructEncoder([\n      [\"name\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      [\"age\", getU32Encoder()],\n    ]),\n    (input) => ({ ...input, age: input.age ?? 42 }),\n  );\n\nconst getPersonDecoder = (): Decoder<Person> =>\n  getStructDecoder([\n    [\"name\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\"age\", getU32Decoder()],\n  ]);\n\nconst getPersonCodec = (): Codec<PersonInput, Person> => combineCodec(getPersonEncoder(), getPersonDecoder());\n```\n\n----------------------------------------\n\nTITLE: Get RPC Subscriptions Channel with BigInt JSON Serialization in JavaScript\nDESCRIPTION: The function getRpcSubscriptionsChannelWithBigIntJSONSerialization is introduced which supports parsing and stringifying JSON messages to accommodate BigInt values, crucial for exceeding JavaScript's maximum safe integer limit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Add a `getRpcSubscriptionsChannelWithBigIntJSONSerialization` helper function\n// Parses and stringifies JSON messages with support for `BigInt` values\n\n```\n\n----------------------------------------\n\nTITLE: Removing U64 and I64 types in favour of bigint - JavaScript\nDESCRIPTION: This snippet addresses the removal of outdated type definitions U64 and I64, opting for the modern bigint type instead. This change enhances the library’s type handling by standardizing numeric types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Patch Change for Type Removal\n// #3467\nRemove `U64` and `I64` types in favour of `bigint`.\n```\n\n----------------------------------------\n\nTITLE: Enum as Discriminator Value\nDESCRIPTION: This snippet shows that the discriminator value can be a JavaScript enum. It encodes the discriminated union using enum values as discriminators. Relies on `getDiscriminatedUnionCodec` and assumes that `getUnitCodec`, `getStructCodec` are defined elsewhere.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nenum Message {\n    Quit,\n    Write,\n    Move,\n}\nconst messageCodec = getDiscriminatedUnionCodec([\n    [Message.Quit, getUnitCodec()],\n    [Message.Write, getStructCodec([...])],\n    [Message.Move, getStructCodec([...])],\n]);\n\ncodec.encode({ __kind: Message.Quit });\ncodec.encode({ __kind: Message.Write, fields: ['Hi'] });\ncodec.encode({ __kind: Message.Move, x: 5, y: 6 });\n```\n\n----------------------------------------\n\nTITLE: Using DataEnum Codecs with Custom Discriminators in TypeScript\nDESCRIPTION: Shows how DataEnum codecs now support custom discriminator properties, allowing for more flexible encoding of variant data structures. The example demonstrates encoding mouse click and key press events.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getDataEnumCodec(\n    [\n        [\n            'click',\n            getStructCodec([\n                [\n                    ['x', u32],\n                    ['y', u32],\n                ],\n            ]),\n        ],\n        ['keyPress', getStructCodec([[['key', u32]]])],\n    ],\n    { discriminator: 'event' },\n);\n\ncodec.encode({ event: 'click', x: 1, y: 2 });\ncodec.encode({ event: 'keyPress', key: 3 });\n```\n\n----------------------------------------\n\nTITLE: Configuring Nullable Codec in TypeScript\nDESCRIPTION: Example showing how to configure a nullable codec with the getNullableCodec function. Demonstrates different configuration options including prefix and noneValue settings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetZeroableNullableCodec(getU16Codec());\n\n// After.\ngetNullableCodec(getU16Codec(), { noneValue: 'zeroes', prefix: null });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Using DEFAULT_RPC_CONFIG Constant in TypeScript\nDESCRIPTION: Example showing how to create a custom RPC instance with default Solana RPC API behaviors. This constant provides standard configuration that can be used when creating custom RPC implementations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myCustomRpc = createRpc({\n    api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n    transport: myCustomTransport,\n});\n```\n\n----------------------------------------\n\nTITLE: Using Separate Resize Functions in TypeScript\nDESCRIPTION: Shows how to use the separate resizeEncoder and resizeDecoder functions to enable tree-shaking. These functions can be combined with combineCodec to recreate the full codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst getBiggerU32Encoder = () => resizeEncoder(getU32Codec(), size => size + 4);\nconst getBiggerU32Decoder = () => resizeDecoder(getU32Codec(), size => size + 4);\nconst getBiggerU32Codec = () => combineCodec(getBiggerU32Encoder(), getBiggerU32Decoder());\n```\n\n----------------------------------------\n\nTITLE: Supporting BigInt Serialization in JSON - TypeScript\nDESCRIPTION: This snippet includes a helper function for parsing and stringifying JSON messages that may contain BigInt values, allowing safe handling of large integers beyond the regular JavaScript number limits.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getRpcSubscriptionsChannelWithBigIntJSONSerialization() {\n    // Logic to parse and stringify BigInt values\n}\n```\n\n----------------------------------------\n\nTITLE: Zeroable Nullable Codec Usage - TypeScript\nDESCRIPTION: Demonstrates the usage of new zeroable nullable codec function with custom zero value definition and encoding/decoding behavior\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec());\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0x0000\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([0, 0])); // null\n\n// With custom zero value\nconst customCodec = getZeroableNullableCodec(getU16Codec(), {\n    zeroValue: new Uint8Array([255, 255]),\n});\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0xfffff\ncodec.encode(new Uint8Array([0, 0])); // 0\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([255, 255])); // null\n```\n\n----------------------------------------\n\nTITLE: Compatibility Update for Vercel Edge Runtime and Cloudflare Workers in JavaScript\nDESCRIPTION: This update ensures that the build of the library is compatible with the Vercel Edge runtime and Cloudflare Workers, enhancing deployment options for developers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// The build is now compatible with the Vercel Edge runtime and Cloudflare Workers\n\n```\n\n----------------------------------------\n\nTITLE: Using fixed-size nullable codec with zero padding in TypeScript\nDESCRIPTION: Demonstrates creating a fixed-size nullable codec by setting the noneValue option to 'zeroes', which pads null values with zeroes to match the length of non-null values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_93\n\nLANGUAGE: typescript\nCODE:\n```\nconst fixedNullableStringCodec = getNullableCodec(\n  fixCodecSize(getUtf8Codec(), 8), // Only works with fixed-size items.\n  { noneValue: \"zeroes\" },\n);\n\nfixedNullableStringCodec.encode(\"Hi\");\n// 0x014869000000000000\n//   | └-- 8-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (true — The item exists).\n\nfixedNullableStringCodec.encode(null);\n// 0x000000000000000000\n//   | └-- 8-byte of padding to make a fixed-size codec.\n//   └-- 1-byte prefix (false — The item is null).\n```\n\n----------------------------------------\n\nTITLE: Using containsBytes Helper in TypeScript\nDESCRIPTION: Demonstrates the usage of the new containsBytes helper function to check if a Uint8Array contains another Uint8Array at a given offset.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Using SolanaRpcApiFromTransport Type in TypeScript\nDESCRIPTION: Example demonstrating a function that creates a Solana RPC instance with methods specific to the transport's cluster. This utility type ensures that only methods available on a specific cluster can be called.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createSolanaRpcFromTransport<TTransport extends RpcTransport>(\n    transport: TTransport,\n): RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport> {\n    /* ... */\n}\nconst transport = createDefaultRpcTransport({ url: mainnet('http://rpc.company') });\ntransport satisfies RpcTransportMainnet; // OK\nconst rpc = createSolanaRpcFromTransport(transport);\nrpc satisfies RpcMainnet<SolanaRpcApiMainnet>; // OK\n```\n\n----------------------------------------\n\nTITLE: Implementing Hidden Prefix and Suffix Codecs in TypeScript\nDESCRIPTION: A utility for prepending or appending hidden codecs to a main codec, allowing encoding and decoding of constant values without including them in the final type\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number> = getHiddenPrefixCodec(getU16Codec(), [\n    getConstantCodec(new Uint8Array([1, 2, 3])),\n    getConstantCodec(new Uint8Array([4, 5, 6])),\n]);\n\ncodec.encode(42);\n// 0x0102030405062a00\n//   |     |     └-- Our main u16 codec (value = 42).\n//   |     └-- Our second hidden prefix codec.\n//   └-- Our first hidden prefix codec.\n\ncodec.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 42, 0])); // 42\n```\n\n----------------------------------------\n\nTITLE: Defining Rent Sysvar Lookup Account Type in TypeScript\nDESCRIPTION: Example demonstrating how to type a rent sysvar account that is looked up in a lookup table\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype RentSysvar = ReadonlyLookupAccount<\n    'SysvarRent111111111111111111111111111111111',\n    'MyLookupTable111111111111111111111111111111'\n>;\n```\n\n----------------------------------------\n\nTITLE: Nullable Codec Creation in TypeScript\nDESCRIPTION: Creates a nullable codec that extends a given codec to handle null values, distinguishing between existing items and null with a boolean prefix. Customization options for the prefix and handling fixed sizes are supported.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\ngetNullableCodec(stringCodec).encode('Hi');\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte prefix (true — The item exists).\n```\n\nLANGUAGE: typescript\nCODE:\n```\ngetNullableCodec(stringCodec).encode(null);\n// 0x00\n//   └-- 1-byte prefix (false — The item is null).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32NullableStringCodec = getNullableCodec(stringCodec, {\n    prefix: getU32Codec(),\n});\nu32NullableStringCodec.encode('Hi');\n// 0x01000000020000004869\n//   └------┘ 4-byte prefix (true).\nu32NullableStringCodec.encode(null);\n// 0x00000000\n//   └------┘ 4-byte prefix (false).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst fixedNullableStringCodec = getNullableCodec(\n    fixCodecSize(getUtf8Codec(), 8), // Only works with fixed-size items.\n    { noneValue: 'zeroes' },\n);\nfixedNullableStringCodec.encode('Hi');\n// 0x014869000000000000\n//   | └-- 8-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (true — The item exists).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfixedNullableStringCodec.encode(null);\n// 0x000000000000000000\n//   | └-- 8-byte of padding to make a fixed-size codec.\n//   └-- 1-byte prefix (false — The item is null).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getUtf8Codec(), {\n    noneValue: new Uint8Array([255]), // 0xff means null.\n});\ncodec.encode('Hi');\n// 0x014869\n//   | └-- 2-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (true — The item exists).\n\ncodec.encode(null);\n// 0x00ff\n//   | └-- 1-byte representing null (0xff).\n//   └-- 1-byte prefix (false — The item is null).\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codecWithZeroNoneValue = getNullableCodec(getU16Codec(), {\n    noneValue: 'zeroes', // 0x0000 means null.\n    prefix: null,\n});\ncodecWithZeroNoneValue.encode(42); // 0x2a00\ncodecWithZeroNoneValue.encode(null); // 0x0000\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codecWithCustomNoneValue = getNullableCodec(getU16Codec(), {\n    noneValue: new Uint8Array([255]), // 0xff means null.\n    prefix: null,\n});\ncodecWithCustomNoneValue.encode(42); // 0x2a00\ncodecWithCustomNoneValue.encode(null); // 0xff\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Getting Public Key from Private Key in TypeScript\nDESCRIPTION: This snippet shows how to use the new getPublicKeyFromPrivateKey helper function to obtain a public key from an extractable CryptoKey private key.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n\nconst privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n\nconst publicKey = await getPublicKeyFromPrivateKey(privateKey);\nconst extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n```\n\n----------------------------------------\n\nTITLE: Querying Encoded Transaction Data with RPC-GraphQL in TypeScript\nDESCRIPTION: This snippet illustrates how to query and encode certain transaction data attributes using different encoding formats, enabling specific data retrieval needs from the blockchain transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst source = `\n    query myQuery($signature: String!, $commitment: Commitment) {\n        transaction(signature: $signature, commitment: $commitment) {\n            data(encoding: BASE_64)\n        }\n    }\n`;\n\nconst variableValues = {\n    signature: '63zkpxATgAwXRGFQZPDESTw2m4uZQ99sX338ibgKtTcgG6v34E3MSS3zckCwJHrimS71cvei6h1Bn1K1De53BNWC',\n    commitment: 'confirmed',\n};\n\nconst result = await rpcGraphQL.query(source, variableValues);\n```\n\n----------------------------------------\n\nTITLE: Asserting Multiple Accounts Existence in TypeScript\nDESCRIPTION: Demonstrates the usage of assertAccountsExist function to assert that all accounts in an array exist and narrow their types to Account.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAccounts: MaybeEncodedAccount<Address>[];\nassertAccountsExist(myAccounts);\n\n// Now we can use them as an array of accounts\nfor (const a of myAccounts) {\n    a satisfies EncodedAccount<Address>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Codec in TypeScript\nDESCRIPTION: Shows how to use the new getConstantCodec function to create a codec that encodes and decodes a constant Uint8Array.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Using Hidden Prefix Codec in TypeScript\nDESCRIPTION: Demonstrates the use of getHiddenPrefixCodec to prepend hidden codecs to a main codec. It shows how to encode a number with hidden prefixes and decode it back.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number> = getHiddenPrefixCodec(getU16Codec(), [\n    getConstantCodec(new Uint8Array([1, 2, 3])),\n    getConstantCodec(new Uint8Array([4, 5, 6])),\n]);\n\ncodec.encode(42);\n// 0x0102030405062a00\n//   |     |     └-- Our main u16 codec (value = 42).\n//   |     └-- Our second hidden prefix codec.\n//   └-- Our first hidden prefix codec.\n\ncodec.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 42, 0])); // 42\n```\n\n----------------------------------------\n\nTITLE: Validating Addresses with isAddress() Type Guard in TypeScript\nDESCRIPTION: Demonstrates the usage of isAddress() as a type guard to validate and refine a string input to the Address type, useful for conditional logic based on address validity.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isAddress } from '@solana/addresses';\n\nif (isAddress(ownerAddress)) {\n    // At this point, `ownerAddress` has been refined to a\n    // `Address` that can be used with the RPC.\n    const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n    setBalanceLamports(lamports);\n} else {\n    setError(`${ownerAddress} is not an address`);\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Subscriptions API\nDESCRIPTION: Major refactoring of the subscriptions API to use event-based subscriptions internally, improving memory management and performance.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n- [`c8e6e71`](https://github.com/solana-labs/solana-web3.js/commit/c8e6e71529f219caf83ed444e53f5a1e757129dc) Thanks [@steveluscher](https://github.com/steveluscher)! - We refactored the lower levels of the subscriptions API entirely.\n\n    Previously, all layers of the subscriptions implementation, from the `WebSocket` transport to the API that developers use, dealt in `AsyncIterables`. These are notoriously difficult to code in such a way that expresses all of the ways in which a subscription might be cancelled or error out. Very slight omissions of care could open memory leaks that would bring down the simplest of apps. The new subscriptions infra in Release Candidate 2 deals with event-based subscriptions all the way up to the highest level API, at which point the subscription is vended to the application as an `AsyncIterable`.\n\n    This has eliminated several classes of memory leak and has made it easier to implement higher-level transports (like the autopinger and the subscription coalescer). Additionally, this update introduces a new channel pool implementation that opens new `WebSocket` connections when existing ones become 'full.' Lastly, performance in the new implementation has been improved through a new demultiplexing utility that can separate `message` events into several channels based on arbitrary criteria, meaning you can apply transforms to the message right at the source, and vend subscriptions to downstream consumers that care only about one particular kind of message.\n```\n\n----------------------------------------\n\nTITLE: Tree-shakeable Byte Order with reverseEncoder and reverseDecoder in TypeScript\nDESCRIPTION: Demonstrates using reverseEncoder and reverseDecoder to create tree-shakeable functions for handling byte order reversal. This approach separates encoding and decoding logic for better bundle optimization.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reverseEncoder, reverseDecoder, getU64Encoder, getU64Decoder, combineCodec } from \"@solana/kit\";\nconst getBigEndianU64Encoder = () => reverseEncoder(getU64Encoder());\nconst getBigEndianU64Decoder = () => reverseDecoder(getU64Decoder());\nconst getBigEndianU64Codec = () => combineCodec(getBigEndianU64Encoder(), getBigEndianU64Decoder());\n```\n\n----------------------------------------\n\nTITLE: Adding Integer Overflow Request Transformer Helpers - JavaScript\nDESCRIPTION: Includes helper functions getIntegerOverflowRequestTransformer, getBigIntDowncastRequestTransformer, and getTreeWalkerRequestTransformer, which provide essential functionality for handling requests that may lead to integer overflows, ensuring robust error handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Customizing Discriminator Property Name\nDESCRIPTION: Shows how to customize the discriminator property name from the default '__kind' to a custom name like 'message' using the discriminator option of getDiscriminatedUnionCodec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nconst messageCodec = getDiscriminatedUnionCodec(\n  [\n    [\"quit\", quitCodec],\n    [\"write\", writeCodec],\n    [\"move\", moveCodec],\n  ],\n  { discriminator: \"message\" },\n);\n\nmessageCodec.encode({ message: \"quit\" });\nmessageCodec.encode({ message: \"write\", fields: [\"Hi\"] });\nmessageCodec.encode({ message: \"move\", x: 5, y: 6 });\n```\n\n----------------------------------------\n\nTITLE: Using containsBytes Helper in TypeScript\nDESCRIPTION: Shows how to use the containsBytes helper to check if a Uint8Array contains another Uint8Array at a specific offset\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Solana RPC Instance\nDESCRIPTION: Example showing how to create and use a Solana RPC instance to get the latest blockhash with timeout configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpc =\n    // Step 1 - Create a `Rpc` instance. This may be stateful.\n    createSolanaRpc(mainnet('https://api.mainnet-beta.solana.com'));\nconst response = await rpc\n    // Step 2 - Call supported methods on it to produce `PendingRpcRequest` objects.\n    .getLatestBlockhash({ commitment: 'confirmed' })\n    // Step 3 - Call the `send()` method on those pending requests to trigger them.\n    .send({ abortSignal: AbortSignal.timeout(10_000) });\n```\n\n----------------------------------------\n\nTITLE: Using Endian Option for Number Codecs in TypeScript\nDESCRIPTION: Demonstrates how to specify endianness directly using the endian option in number codecs, which is an alternative to using reverseCodec. The example creates a big-endian U64 codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU64Codec, Endian } from \"@solana/kit\";\nconst getBigEndianU64Codec = () => getU64Codec({ endian: Endian.Big });\n```\n\n----------------------------------------\n\nTITLE: Updating Nullable Codec Implementation in TypeScript\nDESCRIPTION: Example showing the transition from previous to new nullable codec implementation with configurable prefix and none value options. The codec can encode/decode nullable U16 values with different prefix and none value configurations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetZeroableNullableCodec(getU16Codec());\n\n// After.\ngetNullableCodec(getU16Codec(), { noneValue: 'zeroes', prefix: null });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Helper Functions for Object Manipulation\nDESCRIPTION: Defines helper functions for adding properties to objects in a functional way using TypeScript generics.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst setAge = <T extends object>(age: number, p: T) => ({ ...p, age });\nconst setWallet = <T extends object>(wallet: Address, p: T) => ({ ...p, wallet });\n```\n\n----------------------------------------\n\nTITLE: Creating Private Key from Bytes\nDESCRIPTION: Demonstrates creating an Ed25519 private key from bytes using createPrivateKeyFromBytes function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createPrivateKeyFromBytes } from '@solana/keys';\n\nconst privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\nconst extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n```\n\n----------------------------------------\n\nTITLE: Map codec configuration options in TypeScript\nDESCRIPTION: Demonstrates different size configuration strategies for the getMapCodec function. Options include using a custom number codec for the size prefix, specifying a fixed size, or using 'remainder' to infer the size from the buffer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nconst keyCodec = fixCodecSize(getUtf8Codec(), 8);\nconst valueCodec = getU8Codec();\n\nconst myMap = new Map<string, number>();\nmyMap.set(\"alice\", 42);\nmyMap.set(\"bob\", 5);\n\ngetMapCodec(keyCodec, valueCodec, { size: getU16Codec() }).encode(myMap);\n// 0x0200616c6963650000002a626f62000000000005\n//   |   |                 └-- Second entry.\n//   |   └-- First entry.\n//   └-- 2-byte prefix telling us to read 2 entries.\n\ngetMapCodec(keyCodec, valueCodec, { size: 3 }).encode(myMap);\n// 0x616c6963650000002a626f62000000000005\n//   |                 └-- Second entry.\n//   └-- First entry.\n// There must always be 2 entries in the map.\n\ngetMapCodec(keyCodec, valueCodec, { size: \"remainder\" }).encode(myMap);\n// 0x616c6963650000002a626f62000000000005\n//   |                 └-- Second entry.\n//   └-- First entry.\n// The size is inferred from the remainder of the bytes.\n```\n\n----------------------------------------\n\nTITLE: Retry RPC Transport Implementation\nDESCRIPTION: Implementation of a retry transport pattern with exponential backoff for handling failed RPC requests.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDefaultRpcTransport, createSolanaRpcFromTransport, type RpcTransport } from '@solana/kit';\n\n// Set the maximum number of attempts to retry a request.\nconst MAX_ATTEMPTS = 4;\n\n// Create the default transport.\nconst defaultTransport = createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-1.com' });\n\n// Sleep function to wait for a given number of milliseconds.\nfunction sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Calculate the delay for a given attempt.\nfunction calculateRetryDelay(attempt: number): number {\n    // Exponential backoff with a maximum of 1.5 seconds.\n    return Math.min(100 * Math.pow(2, attempt), 1500);\n}\n\n// A retrying transport that will retry up to MAX_ATTEMPTS times before failing.\nasync function retryingTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<TResponse> {\n    let requestError;\n    for (let attempts = 0; attempts < MAX_ATTEMPTS; attempts++) {\n        try {\n            return await defaultTransport(...args);\n        } catch (err) {\n            requestError = err;\n            // Only sleep if we have more attempts remaining.\n            if (attempts < MAX_ATTEMPTS - 1) {\n                const retryDelay = calculateRetryDelay(attempts);\n                await sleep(retryDelay);\n            }\n        }\n    }\n    throw requestError;\n}\n\n// Create the RPC client using the retrying transport.\nconst rpc = createSolanaRpcFromTransport(retryingTransport);\n```\n\n----------------------------------------\n\nTITLE: Compatibility Updates for Vercel Edge and Cloudflare Workers - JavaScript\nDESCRIPTION: Updates the build configuration to ensure compatibility with Vercel Edge runtime and Cloudflare Workers by integrating edge-light and workerd into the package exports, enhancing deployment flexibility.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Separate Encoder and Decoder Composing Codec in TypeScript\nDESCRIPTION: Highlights composing a codec using distinct encoder and decoder instances. This approach favors library maintenance and optimizing usage with tree-shaking unnecessary customer decoder or encoder parts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEncoder, createDecoder, combineCodec } from \"@solana/kit\";\n\nconst getModuloU8Encoder = () =>\n  createEncoder<number>({\n    fixedSize: 1,\n    write(value, bytes, offset) {\n      bytes.set([value % 256], offset);\n      return offset + 1;\n    },\n  });\n\nconst getModuloU8Decoder = () =>\n  createDecoder<number>({\n    fixedSize: 1,\n    read(bytes, offset) {\n      const value = bytes[offset];\n      return [value, offset + 1];\n    },\n  });\n\nconst getModuloU8Codec = () => combineCodec(getModuloU8Encoder(), getModuloU8Decoder());\n```\n\n----------------------------------------\n\nTITLE: Freezing Instructions and Lifetime Constraints in Transaction Messages - JavaScript\nDESCRIPTION: This update restricts modifications to the `instructions` and `lifetimeConstraint` fields within transaction messages, stabilizing these elements during transactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Freeze the instructions and lifetimeConstraint fields within transaction messages\n```\n\n----------------------------------------\n\nTITLE: Using JavaScript Enums as Discriminators\nDESCRIPTION: Demonstrates how to use JavaScript enum values as discriminators for variant types instead of string literals, providing more type safety and integration with existing enum-based systems.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\nenum Message {\n  Quit,\n  Write,\n  Move,\n}\nconst messageCodec = getDiscriminatedUnionCodec([\n  [Message.Quit, quitCodec],\n  [Message.Write, writeCodec],\n  [Message.Move, moveCodec],\n]);\n\nmessageCodec.encode({ __kind: Message.Quit });\nmessageCodec.encode({ __kind: Message.Write, fields: [\"Hi\"] });\nmessageCodec.encode({ __kind: Message.Move, x: 5, y: 6 });\n```\n\n----------------------------------------\n\nTITLE: Using wrapBytes for Safe Offset Wrapping in TypeScript\nDESCRIPTION: Shows how to use the wrapBytes helper function to safely wrap offsets around the buffer length. This enables positioning data relative to the end of the buffer.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheEndCodec = offsetCodec(biggerU32Codec, {\n    preOffset: ({ wrapBytes }) => wrapBytes(-4),\n});\nu32InTheEndCodec.encode(0xffffffff);\n// 0x00000000ffffffff\n```\n\n----------------------------------------\n\nTITLE: Using U32Codec to Encode/Decode Unsigned 32-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding unsigned 32-bit integers (from 0 to 4,294,967,295) using both little-endian (default) and big-endian representations. Returns number values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU32Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getU32Codec();\nconst bytes = codec.encode(42); // 0x2a000000\nconst value = codec.decode(bytes); // 42\n\n// Big-endian.\nconst beCodec = getU32Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(42); // 0x0000002a\nconst beValue = beCodec.decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Low-level Write vs Encode Functions with resizeCodec in TypeScript\nDESCRIPTION: Explains the difference between using encode and the lower-level write function with resizeCodec. The resize behavior only applies when using encode, while write operates on the buffer you provide regardless of resize settings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { resizeCodec, getU32Codec } from \"@solana/kit\";\nconst getBiggerU32Codec = () => resizeCodec(getU32Codec(), (size) => size + 4);\n\n// Using the encode function.\ngetBiggerU32Codec().encode(42);\n// 0x2a00000000000000\n\n// Using the lower-level write function.\nconst myCustomBytes = new Uint8Array(4);\ngetBiggerU32Codec().write(42, myCustomBytes, 0);\n// 0x2a000000\n```\n\n----------------------------------------\n\nTITLE: Using Byte Helper Functions\nDESCRIPTION: Demonstrates various utility functions for byte array manipulation, including mergeBytes for concatenation, padBytes for adding zeros, fixBytes for ensuring a specific length, and containsBytes for subarray detection.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\n// Merge multiple Uint8Array buffers into one.\nmergeBytes([new Uint8Array([1, 2]), new Uint8Array([3, 4])]); // Uint8Array([1, 2, 3, 4])\n\n// Pad a Uint8Array buffer to the given size.\npadBytes(new Uint8Array([1, 2]), 4); // Uint8Array([1, 2, 0, 0])\npadBytes(new Uint8Array([1, 2, 3, 4]), 2); // Uint8Array([1, 2, 3, 4])\n\n// Pad and truncate a Uint8Array buffer to the given size.\nfixBytes(new Uint8Array([1, 2]), 4); // Uint8Array([1, 2, 0, 0])\nfixBytes(new Uint8Array([1, 2, 3, 4]), 2); // Uint8Array([1, 2])\n\n// Check if a Uint8Array contains another Uint8Array at a given offset.\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Implementing BiggerU32Codec with Resize Operation\nDESCRIPTION: Demonstrates how to encode a u32 number inside an 8-byte buffer using resizeCodec helper.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst biggerU32Codec = resizeCodec(getU32Codec(), (size) => size + 4);\nbiggerU32Codec.encode(0xffffffff);\n```\n\n----------------------------------------\n\nTITLE: Implementing Reversed Codecs with Separate Encoders and Decoders\nDESCRIPTION: Shows how to implement reversed byte order using separate encoder and decoder functions. This demonstrates using reverseEncoder, reverseDecoder, and combineCodec to create a customized codec with big-endian encoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst getBigEndianU64Encoder = () => reverseEncoder(getU64Encoder());\nconst getBigEndianU64Decoder = () => reverseDecoder(getU64Decoder());\nconst getBigEndianU64Codec = () => combineCodec(getBigEndianU64Encoder(), getBigEndianU64Decoder());\n```\n\n----------------------------------------\n\nTITLE: Using Separate Constant Encoder and Decoder in TypeScript\nDESCRIPTION: Shows how to use the separate getConstantEncoder and getConstantDecoder functions for encoding and decoding constant values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ngetConstantEncoder(new Uint8Array([1, 2, 3])).encode(undefined);\ngetConstantDecoder(new Uint8Array([1, 2, 3])).decode(new Uint8Array([1, 2, 3]));\n```\n\n----------------------------------------\n\nTITLE: Creating a Union Codec in TypeScript using getUnionCodec\nDESCRIPTION: Demonstrates how to create a codec for a union type (number | boolean) using the getUnionCodec function. It shows how to define the codec array, getIndexFromValue function, and getIndexFromBytes function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number | boolean> = getUnionCodec(\n  [getU16Codec(), getBooleanCodec()],\n  (value) => (typeof value === \"number\" ? 0 : 1),\n  (bytes, offset) => (bytes.slice(offset).length > 1 ? 0 : 1),\n);\n\ncodec.encode(42); // 0x2a00\ncodec.encode(true); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Using Base16 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBase16Codec function to encode and decode hexadecimal strings. It shows both basic usage and examples of applying size constraints with utility functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBase16Codec();\nconst bytes = codec.encode(\"deadface\"); // 0xdeadface\nconst value = codec.decode(bytes); // \"deadface\"\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfixCodecSize(getBase16Codec(), 2).encode(\"deadface\");\n// 0xdead (truncated to 2 bytes)\n\naddCodecSizePrefix(getBase16Codec(), getU32Codec()).encode(\"deadface\");\n// 0x04000000deadface\n//   |       └-- The 4 bytes of content.\n//   └-- 4-byte prefix telling us to read 4 bytes.\n\naddCodecSentinel(getBase16Codec(), new Uint8Array([0xff, 0xff])).encode(\"deadface\");\n// 0xdeadfaceffff\n//   |       └-- The sentinel signaling the end of the content.\n//   └-- The 4 bytes of content.\n```\n\n----------------------------------------\n\nTITLE: Timeout Promise with Transaction Confirmation in TypeScript\nDESCRIPTION: A timeout mechanism for transaction confirmation with customizable commitment levels, useful for preventing indefinite waiting\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { safeRace } from '@solana/promises';\nimport { getTimeoutPromise } from '@solana/transaction-confirmation';\n\ntry {\n    await safeRace([getCustomTransactionConfirmationPromise(/* ... */), getTimeoutPromise({ commitment })]);  \n} catch (e) {\n    if (e instanceof DOMException && e.name === 'TimeoutError') {\n        console.log('Could not confirm transaction after a timeout');\n    }\n    throw e;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Data Publisher from Event Emitter - TypeScript\nDESCRIPTION: This function converts an EventEmitter to a DataPublisher, with an 'on' function that enables subscription and returns an unsubscribe function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst socketDataPublisher = getDataPublisherFromEventEmitter(new WebSocket('wss://api.devnet.solana.com'));\\nconst unsubscribe = socketDataPublisher.on('message', message => {\\n    if (JSON.parse(message.data).id === 42) {\\n        console.log('Got response 42');\\n        unsubscribe();\\n    }\\n});\n```\n\n----------------------------------------\n\nTITLE: Refactoring Subscriptions API Implementation in JavaScript\nDESCRIPTION: The subscription API implementation is refactored to a more efficient architecture that reduces memory leak risks and simplifies the subscription cancellation process with AsyncIterables at the API level.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Refactored lower levels of the subscriptions API entirely\n// Improved handling of subscriptions and performance optimization\n\n```\n\n----------------------------------------\n\nTITLE: Adding JSON Serialization to RPC Subscriptions Channel\nDESCRIPTION: Function to wrap an RPC subscriptions channel with JSON serialization and parsing for messages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\ngetRpcSubscriptionsChannelWithJSONSerialization(channel)\n```\n\n----------------------------------------\n\nTITLE: Creating Person Encoder\nDESCRIPTION: Shows how to create a standalone encoder for the Person type, useful when only encoding functionality is needed.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst getPersonEncoder = (): Encoder<Person> =>\n    getStructEncoder([\n        ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n        ['age', getU32Encoder()],\n    ]);\n\nconst bytes = getPersonEncoder().encode({ name: 'John', age: 42 });\n```\n\n----------------------------------------\n\nTITLE: Adding Auto-ping to RPC Subscriptions Channel\nDESCRIPTION: Function to wrap an RPC subscriptions channel with automatic ping functionality to keep the connection alive.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\ngetRpcSubscriptionsChannelWithAutoping(channel)\n```\n\n----------------------------------------\n\nTITLE: Using assertKeyGenerationIsAvailable for WebCrypto key generation checking\nDESCRIPTION: Function that throws an exception unless crypto.subtle.generateKey() with Ed25519 curve support is available in the current JavaScript environment. Used to ensure key generation capabilities are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/README.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n`assertKeyGenerationIsAvailable()`\n```\n\n----------------------------------------\n\nTITLE: U64 Codec Example\nDESCRIPTION: Demonstrates creating and using a u64 codec that handles both number and bigint types for encoding but only bigint for decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst u64Codec: Codec<number | bigint, bigint> = getU64Codec();\n\nconst bytes = u64Codec.encode(42);\nconst value = u64Codec.decode(bytes); // BigInt(42)\n```\n\n----------------------------------------\n\nTITLE: Running the create-solana-program installer\nDESCRIPTION: Command to create a new Solana program repository with generated clients. This installer sets up program files, client libraries, build scripts, and testing infrastructure.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_43\n\nLANGUAGE: sh\nCODE:\n```\npnpm create solana-program\n```\n\n----------------------------------------\n\nTITLE: Immutable Object Update Pattern\nDESCRIPTION: Demonstrates immutable object updates using separate variables for each transformation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = { name: \"Alice\" };\nconst personWithAge = setAge(30, person);\nconst personWithAgeAndWallet = setWallet(address(\"1234..5678\"), personWithAge);\n\npersonWithAgeAndWallet satisfies { name: string; age: number; wallet: Address };\n```\n\n----------------------------------------\n\nTITLE: Using getUnitCodec for void Encoding/Decoding in TypeScript\nDESCRIPTION: Shows how to use the getUnitCodec function to create a Codec<void> that encodes undefined to an empty Uint8Array and decodes any bytes to undefined without consuming them.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\ngetUnitCodec().encode(undefined); // Empty Uint8Array\ngetUnitCodec().decode(anyBytes); // undefined\n```\n\n----------------------------------------\n\nTITLE: Using U8Codec to Encode/Decode Unsigned 8-bit Integers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding unsigned 8-bit integers (from 0 to 255) using the U8Codec. The codec accepts number or bigint as input but always returns a number when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getU8Codec } from \"@solana/kit\";\n\nconst codec = getU8Codec();\nconst bytes = codec.encode(42); // 0x2a\nconst value = codec.decode(bytes); // 42\n```\n\n----------------------------------------\n\nTITLE: Creating Default Solana RPC Subscriptions Channel Creator in JavaScript\nDESCRIPTION: This function, createDefaultSolanaRpcSubscriptionsChannelCreator, is added to handle Solana RPC subscription specifics, such as managing BigInt values in JSON messages, maintaining compatibility with the RPC server requirements.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Adds a channel creator function called `createDefaultSolanaRpcSubscriptionsChannelCreator`\n// This function works with Solana-specific defaults to handle BigInt safely\n\n```\n\n----------------------------------------\n\nTITLE: Adding Codec Sentinel in Typescript\nDESCRIPTION: This snippet demonstrates how to use the `addCodecSentinel` function to delimit the size of a codec by adding a sentinel value to the end of the encoded data.  The sentinel is a `Uint8Array` that signals the end of the encoded data. It accepts a codec and a sentinel.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n    const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n    codec.encode('hello');\n    // 0x68656c6c6fffff\n    //   |        └-- Our sentinel.\n    //   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Using Fixed Size Codecs in TypeScript @solana/kit\nDESCRIPTION: Illustrates the use of a codec with fixed size attributes, where it uses getU32Codec to encode numbers into a fixed byte length. Encoded data size is fixed at 4 bytes. The snippet requires @solana/kit.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { FixedSizeCodec, getU32Codec } from \"@solana/kit\";\nconst myCodec = getU32Codec();\nmyCodec satisfies FixedSizeCodec<number>;\nmyCodec.fixedSize; // 4 bytes.\n```\n\n----------------------------------------\n\nTITLE: Creating Nullable Codec in TypeScript\nDESCRIPTION: Example of creating a nullable codec using the updated getNullableCodec function with new options.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Creating Prefix-less Nullable Codec in TypeScript\nDESCRIPTION: Example of creating a nullable codec without prefix or noneValue in TypeScript.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Deriving Key Pair from Message\nDESCRIPTION: Shows how to derive a key pair from a message hash using createKeyPairFromPrivateKeyBytes function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getUtf8Encoder } from '@solana/codecs-strings';\nimport { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n\nconst message = getUtf8Encoder().encode('Hello, World!');\nconst seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n\nconst derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n```\n\n----------------------------------------\n\nTITLE: Extracting Signers from Instructions\nDESCRIPTION: Demonstrates how to extract and deduplicate signers from an instruction's account metas using the getSignersFromInstruction function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignerA = { address: address('1111..1111'), signTransactions: async () => {} };\nconst mySignerB = { address: address('2222..2222'), signTransactions: async () => {} };\nconst myInstructionWithSigners: IInstructionWithSigners = {\n    programAddress: address('1234..5678'),\n    accounts: [\n        { address: mySignerA.address, role: AccountRole.READONLY_SIGNER, signer: mySignerA },\n        { address: mySignerB.address, role: AccountRole.WRITABLE_SIGNER, signer: mySignerB },\n        { address: mySignerA.address, role: AccountRole.WRITABLE_SIGNER, signer: mySignerA },\n    ],\n};\n\nconst instructionSigners = getSignersFromInstruction(myInstructionWithSigners);\n// ^ [mySignerA, mySignerB]\n```\n\n----------------------------------------\n\nTITLE: Validating Blockhash Input\nDESCRIPTION: Shows how to validate an arbitrary string as a blockhash using type assertion\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertIsBlockhash } from '@solana/transaction-messages';\n\nfunction handleSubmit() {\n    const blockhash: string = blockhashInput.value;\n    try {\n        assertIsBlockhash(blockhash);\n        const blockhashIsValid = await rpc.isBlockhashValid(blockhash).send();\n    } catch (e) {\n        // blockhash is invalid\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Array Encoding with getArrayCodec\nDESCRIPTION: Shows how the default getArrayCodec implementation encodes array lengths as a 4-byte u32 prefix before the array items themselves.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\ngetArrayCodec(getU8Codec()).encode([1, 2, 3]);\n// 0x03000000010203\n//   |       └-- 3 items of 1 byte each.\n//   └-- 4-byte prefix telling us to read 3 items.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Program Clients\nDESCRIPTION: Installation commands for various Solana program clients including system, memo, token, and compute budget packages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/index.mdx#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @solana-program/system \\\n  @solana-program/memo \\\n  @solana-program/token \\\n  @solana-program/compute-budget\n```\n\n----------------------------------------\n\nTITLE: Adjusting Post-Offset with offsetCodec in TypeScript\nDESCRIPTION: Demonstrates how to adjust both pre-offset and post-offset to control where encoding starts and where any subsequent codec would continue. This example pushes both offsets by 2 bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n    preOffset: ({ preOffset }) => preOffset + 2,\n    postOffset: ({ postOffset }) => postOffset + 2,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n// 0x0000ffffffff0000\n//   |   |       |   └-- New post-offset: The original post-offset + 2.\n//   |   |       └-- Post-offset: The original post-offset before we adjusted it.\n//   |   └-- New pre-offset: The original pre-offset + 2.\n//   └-- Pre-offset: The original pre-offset before we adjusted it.\n```\n\n----------------------------------------\n\nTITLE: Fixing Codec Size Using TypeScript\nDESCRIPTION: The `fixCodecSize` function binds a codec's output size to a predefined number, ensuring consistency in data representation. It is designed for application with fixed-size data requirements.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fixCodecSize, getBase58Codec } from \"@solana/kit\";\n// ---cut-before---\nconst get32BytesBase58Codec = () => fixCodecSize(getBase58Codec(), 32);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fixEncoderSize, fixDecoderSize, getBase58Encoder, getBase58Decoder, combineCodec } from \"@solana/kit\";\n// ---cut-before---\nconst get32BytesBase58Encoder = () => fixEncoderSize(getBase58Encoder(), 32);\nconst get32BytesBase58Decoder = () => fixDecoderSize(getBase58Decoder(), 32);\nconst get32BytesBase58Codec = () => combineCodec(get32BytesBase58Encoder(), get32BytesBase58Decoder());\n```\n\n----------------------------------------\n\nTITLE: Creating System Program CreateAccount Instruction\nDESCRIPTION: Implementation of CreateAccount instruction using the System Program to allocate a new account on Solana blockchain.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/instructions.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getCreateAccountInstruction } from \"@solana-program/system\";\n\nimport type { Client } from \"./client\";\n\nexport async function createMint(client: Client, options: { decimals?: number } = {}) {\n  // Build instructions.\n  const createAccountIx = getCreateAccountInstruction({\n    payer,\n    newAccount,\n    space,\n    lamports,\n    programAddress,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Union Codec in TypeScript\nDESCRIPTION: Demonstrates the usage of getUnionCodec for encoding and decoding TypeScript unions\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec: Codec<number | boolean> = getUnionCodec(\n    [getU16Codec(), getBooleanCodec()],\n    value => (typeof value === 'number' ? 0 : 1),\n    (bytes, offset) => (bytes.slice(offset).length > 1 ? 0 : 1),\n);\n\ncodec.encode(42); // 0x2a00\ncodec.encode(true); // 0x01\n```\n\n----------------------------------------\n\nTITLE: Creating Keypairs from ReadonlyUint8Array - Solana\nDESCRIPTION: Keypairs and keys can now be created from `ReadonlyUint8Array`. This enhancement allows greater flexibility in how key data is handled and used within the library. It provides improved compatibility with various data sources and formats.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n``cb49bfa`](https://github.com/solana-labs/solana-web3.js/commit/cb49bfa28f412376a41e758eeda59e7e90983147) Thanks [@mcintyre94](https://github.com/mcintyre94)! - Allow creating keypairs and keys from ReadonlyUint8Array``\n```\n\n----------------------------------------\n\nTITLE: Using RpcRequest and RpcResponse in RPC Subscriptions - JavaScript\nDESCRIPTION: This snippet outlines the introduction of `RpcRequest` and `RpcResponse` types in the RPC Subscriptions architecture, ensuring consistent handling of requests and responses within the Solana Web3.js framework. This change aims to improve the architecture's reliability by utilizing standardized types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Use `RpcRequest`, `RpcResponse` and their transformers in RPC Subscriptions packages\n// This change makes the RPC architecture more consistent.\n```\n\n----------------------------------------\n\nTITLE: Address-to-PublicKey Conversion in TypeScript\nDESCRIPTION: Code examples showing how to use the getStringCodec function and its alternatives for variable, fixed, and prefixed size string encoding in TypeScript.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetStringCodec({ size: 'variable' }); // Variable.\ngetStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\ngetStringCodec({ size: 5 }); // Fixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\ngetStringCodec(); // Prefixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\n\n// After.\ngetUtf8Codec(); // Variable.\nfixCodecSize(getUtf8Codec(), 5); // Fixed.\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Signing Transaction with Kit\nDESCRIPTION: This code snippet showcases how to sign a transaction in the Kit framework. It generates keypairs using the generateKeyPair function, compiles the transaction message, and then signs the transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { compileTransaction, generateKeyPair, signTransaction } from \"@solana/kit\";\n// ---cut-start---\nimport { CompilableTransactionMessage, TransactionMessageWithBlockhashLifetime } from \"@solana/kit\";\nconst transactionMessage = null as unknown as CompilableTransactionMessage & TransactionMessageWithBlockhashLifetime;\n// ---cut-end---\n\nconst [payer, authority] = await Promise.all([generateKeyPair(), generateKeyPair()]);\n\nconst transaction = compileTransaction(transactionMessage);\nconst signedTransaction = await signTransaction([payer, authority], transaction);\n```\n\n----------------------------------------\n\nTITLE: Creating Tree-Shakeable Padded Codec\nDESCRIPTION: Shows how to create separate encoder and decoder functions for left-padded codec operations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst getMyPaddedEncoder = () => padLeftEncoder(getU16Encoder(), 6);\nconst getMyPaddedDecoder = () => padLeftDecoder(getU16Decoder(), 6);\nconst getMyPaddedCodec = () => combineCodec(getMyPaddedEncoder(), getMyPaddedDecoder());\n```\n\n----------------------------------------\n\nTITLE: Custom Literal Union Size\nDESCRIPTION: This snippet customizes the size of the literal union codec by providing a number codec as the `size` option to the `getLiteralUnionCodec` function. It relies on the `getU32Codec` function to define a 32-bit unsigned integer codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec(['left', 'right', 'up', 'down'], {\n    size: getU32Codec(),\n});\n\ncodec.encode('left'); // 0x00000000\ncodec.encode('right'); // 0x01000000\ncodec.encode('up'); // 0x02000000\ncodec.encode('down'); // 0x03000000\n```\n\n----------------------------------------\n\nTITLE: Implementing Codec Sentinel in TypeScript\nDESCRIPTION: Demonstrates the usage of addCodecSentinel function to delimit codec size using a sentinel at the end of encoded data\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\ncodec.encode('hello');\n// 0x68656c6c6fffff\n//   |        └-- Our sentinel.\n//   └-- Our encoded string.\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Codec Read Function\nDESCRIPTION: Example of implementing the read function for a custom codec that reads a single byte value.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ncreateCodec({\n    read(bytes, offset) {\n        const value = bytes[offset];\n        return [value, offset + 1];\n    },\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: DataEnum Codecs with Custom Discriminator in TypeScript\nDESCRIPTION: Support for creating DataEnum codecs with custom discriminator properties for more flexible enum-like encoding\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getDataEnumCodec(\n    [\n        [\n            'click',\n            getStructCodec([\n                [\n                    ['x', u32],\n                    ['y', u32],\n                ],\n            ]),\n        ],\n        ['keyPress', getStructCodec([[['key', u32]]])],\n    ],\n    { discriminator: 'event' },\n);\n\ncodec.encode({ event: 'click', x: 1, y: 2 });\ncodec.encode({ event: 'keyPress', key: 3 });\n```\n\n----------------------------------------\n\nTITLE: Literal Union Codec Basic Usage\nDESCRIPTION: Shows how to use getLiteralUnionCodec to encode and decode union types using array indices.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec([\"left\", \"right\", \"up\", \"down\"]);\ncodec satisfies FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">;\n\nconst bytes = codec.encode(\"left\"); // 0x00\nconst value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Creating Encoded and Decoded Account Objects in TypeScript\nDESCRIPTION: Illustrates how to create Account objects for both encoded (Uint8Array) and decoded (custom type) account data, showcasing the flexibility of the Account type.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Encoded.\nconst myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n    address: address('1234..5678'),\n    data: new Uint8Array([1, 2, 3]),\n    executable: false,\n    lamports: lamports(1_000_000_000n),\n    programAddress: address('1111..1111'),\n    space: 42n,\n};\n\n// Decoded.\ntype MyAccountData = { name: string; age: number };\nconst myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n    address: address('1234..5678'),\n    data: { name: 'Alice', age: 30 },\n    executable: false,\n    lamports: lamports(1_000_000_000n),\n    programAddress: address('1111..1111'),\n    space: 42n,\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Constant Codec in TypeScript\nDESCRIPTION: Demonstrates the getConstantCodec function usage for encoding and decoding fixed Uint8Array values\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Response for Nested Token Transfer Query\nDESCRIPTION: Example JSON response structure for a nested token transfer query, showing detailed information about tokens, accounts, and their relationships within a transaction.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_24\n\nLANGUAGE: json\nCODE:\n```\ndata: {\n    transaction: {\n        message: {\n            instructions: [\n                {\n                    amount: '50',\n                    authority: {\n                        address: 'AHPPMhzDQix9sKULBqeaQ5BUZgrKdz8tg6DzPxsofB12',\n                        lamports: 890880n,\n                    },\n                    destination: {\n                        address: '2W8mUY75zxqwAcpirn75r3Cc7TStMirFyHwKqo13fmB1',\n                        mint: {\n                            address: '8poKMotB2cEYVv5sbjrdyssASZj1vwYCe7GJFeXo2QP7',\n                            decimals: 6,\n                        },\n                        owner: {\n                            address: '7tRxJ2znbTFpwW9XaMMiDsXDudoPEUXRcpDpm8qjWgAZ',\n                            lamports: 890880n,\n                        }\n                    },\n                    source: {\n                        address: 'BqFCPqXUm4cq6jaZZx1TDTvUR1wdEuNNwAHBEVR6mJhM',\n                        mint: {\n                            address: '8poKMotB2cEYVv5sbjrdyssASZj1vwYCe7GJFeXo2QP7',\n                            decimals: 6,\n                        },\n                        owner: {\n                            address: '3dPmVLMD7PC5faZNyJUH9WFrUxAsbjydJfoozwmR1wDG',\n                            lamports: e890880n,\n                        }\n                    }\n                },\n                /* .. */\n            ]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Contains Bytes Helper in TypeScript\nDESCRIPTION: Illustrates the usage of the `containsBytes` helper to check for byte sequence presence in a Uint8Array\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeroable Nullable Codec in TypeScript\nDESCRIPTION: Demonstrates the usage of getZeroableNullableCodec for handling nullable values using zero values\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec());\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0x0000\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.encode(new Uint8Array([0, 0])); // null\n```\n\n----------------------------------------\n\nTITLE: Extracting Signers from Transaction Messages\nDESCRIPTION: Shows how to extract and deduplicate all signers stored in the instructions of a transaction message.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst transactionSigners = getSignersFromTransactionMessage(myTransactionMessageWithSigners);\n```\n\n----------------------------------------\n\nTITLE: Optimized RPC Call in TypeScript for Multiple Solana Accounts with Data Slices\nDESCRIPTION: This TypeScript code snippet shows how the resolver optimizes the combined batch loading and minimized payload request into a single getMultipleAccounts RPC call with specific data slice parameters.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nrpc.getMultipleAccounts(\n    ['J7iup799j5BVjKXACZycYef7WQ4x1wfzhUsc5v357yWQ', 'EVW3CoyogapBfQxBFFEKGMM1bn3JyoFiqkAJdw3FHX1b'],\n    {\n        encoding: 'base64',\n        dataSlice: { length: 40, offset: 0 },\n    },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeroable Nullable Codec in TypeScript\nDESCRIPTION: A codec that uses a zero value to represent null or None, with optional custom zero value configuration\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec());\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0x0000\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.encode(new Uint8Array([0, 0])); // null\n\n// Custom zero value\nconst codec = getZeroableNullableCodec(getU16Codec(), {\n    zeroValue: new Uint8Array([255, 255]),\n});\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0xfffff\ncodec.encode(new Uint8Array([0, 0])); // 0\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([255, 255])); // null\n```\n\n----------------------------------------\n\nTITLE: Using addCodecSizePrefix in TypeScript for Data Serialization\nDESCRIPTION: An example showing how to use the addCodecSizePrefix function to prefix encoded data with its size. This appends a u32 size prefix before the encoded base-58 string.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ncodec.encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Using F32Codec to Encode/Decode 32-bit Floating-Point Numbers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding 32-bit floating-point numbers using both little-endian (default) and big-endian representations. Due to the IEEE 754 format, some precision loss may occur. Returns number values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getF32Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getF32Codec();\nconst bytes = codec.encode(-1.5); // 0x0000c0bf\nconst value = codec.decode(bytes); // -1.5\n\n// Big-endian.\nconst beCodec = getF32Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-1.5); // 0xbfc00000\nconst beValue = beCodec.decode(bytes); // -1.5\n```\n\n----------------------------------------\n\nTITLE: Hidden Suffix Codec Implementation\nDESCRIPTION: Demonstrates using getHiddenSuffixCodec to append hidden data after the main codec data during encoding while maintaining clean types.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getHiddenSuffixCodec(getU16Codec(), [\n  getConstantCodec(new Uint8Array([1, 2, 3])),\n  getConstantCodec(new Uint8Array([4, 5, 6])),\n]);\n\ncodec.encode(42);\ncodec.decode(new Uint8Array([42, 0, 1, 2, 3, 4, 5, 6]));\n```\n\n----------------------------------------\n\nTITLE: Customizing nullable codec prefix in TypeScript\nDESCRIPTION: Shows how to configure the boolean prefix in a nullable codec by providing a custom number codec for the prefix option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_92\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32NullableStringCodec = getNullableCodec(stringCodec, {\n  prefix: getU32Codec(),\n});\n\nu32NullableStringCodec.encode(\"Hi\");\n// 0x01000000020000004869\n//   └------┘ 4-byte prefix (true).\n\nu32NullableStringCodec.encode(null);\n// 0x00000000\n//   └------┘ 4-byte prefix (false).\n```\n\n----------------------------------------\n\nTITLE: JSON RPC Payload Validation\nDESCRIPTION: Example showing how to validate if a payload follows JSON RPC v2 format using isJsonRpcPayload helper function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nif (isJsonRpcPayload(payload)) {\n    const payloadMethod: string = payload.method;\n    const payloadParams: unknown = payload.params;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Event Target Type - TypeScript\nDESCRIPTION: This snippet defines the TypedEventTarget type, a superset of TypedEventEmitter which allows stricter controls over the dispatchEvent method to enforce event type safety.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst target: TypedEventTarget<{ candyVended: CustomEvent<{ flavour: string }> }> = new EventTarget();\\ntarget.dispatchEvent(new CustomEvent('candyVended', { detail: { flavour: 'raspberry' } })); // OK.\\ntarget.dispatchEvent(new CustomEvent('candyVended', { detail: { flavor: 'raspberry' } })); // ERROR. Misspelling in detail.\n```\n\n----------------------------------------\n\nTITLE: Adding Default Commitment Request Transformer Helper - JavaScript\nDESCRIPTION: Introduces the getDefaultCommitmentRequestTransformer helper function, allowing for standardized handling of commitment levels in RPC requests, contributing to improved client-server interactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Installing @solana/kit and tsx dependencies\nDESCRIPTION: Command to install the required npm packages for the project.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/setup.mdx#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n@solana/kit tsx\n```\n\n----------------------------------------\n\nTITLE: Cleaning up SolanaRpcSubscriptionsApi\nDESCRIPTION: This change removes the extension of RpcApiSubscriptionsMethods from SolanaRpcSubscriptionsApi.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- [#3218](https://github.com/solana-labs/solana-web3.js/pull/3218) [`1d87b3c`](https://github.com/solana-labs/solana-web3.js/commit/1d87b3c9fb5637cdceb31c5675e876d8fe088677) Thanks [@mcintyre94](https://github.com/mcintyre94)! - Clean up SolanaRpcSubscriptionsApi: no longer extend RpcApiSubscriptionsMethods\n```\n\n----------------------------------------\n\nTITLE: Merging Bytes Arrays Using TypeScript\nDESCRIPTION: The `mergeBytes` function concatenates multiple `Uint8Arrays` into a single unified `Uint8Array`. This utility is useful for combining separate byte sequences into one.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mergeBytes } from \"@solana/kit\";\n// ---cut-before---\nconst bytes1 = new Uint8Array([0x01, 0x02]);\nconst bytes2 = new Uint8Array([]);\nconst bytes3 = new Uint8Array([0x03, 0x04]);\nconst bytes = mergeBytes([bytes1, bytes2, bytes3]);\n//    ^ [0x01, 0x02, 0x03, 0x04]\n```\n\n----------------------------------------\n\nTITLE: Using getBytesCodec for Raw Byte Handling\nDESCRIPTION: Demonstrates the use of getBytesCodec which passes Uint8Arrays through without transformation, useful when composed with other codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_70\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getBytesCodec();\nconst bytes = codec.encode(new Uint8Array([42])); // 0x2a\nconst value = codec.decode(bytes); // 0x2a\n```\n\n----------------------------------------\n\nTITLE: Declaring RpcResponseTransformer Type in TypeScript\nDESCRIPTION: Declares the RpcResponseTransformer type, a function that transforms an RpcResponse before returning it to the caller.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec-types/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype RpcResponseTransformer<T = unknown> = (response: RpcResponse<T>) => RpcResponse<T>;\n```\n\n----------------------------------------\n\nTITLE: Defining SignableMessage Type in TypeScript\nDESCRIPTION: Illustrates the structure of a SignableMessage with content and signature dictionary\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype SignableMessage = {\n    content: Uint8Array;\n    signatures: SignatureDictionary; // Record<Address, SignatureBytes>\n};\n```\n\n----------------------------------------\n\nTITLE: Using Custom Base-X Codec in TypeScript\nDESCRIPTION: Shows how to use the getBaseXCodec function to create and use a custom Base-X codec with a specified alphabet.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst alphabet = '0ehlo';\nconst bytes = getBaseXCodec(alphabet).encode('hello'); // 0x05bd\nconst value = getBaseXCodec(alphabet).decode(bytes); // \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Using F64Codec to Encode/Decode 64-bit Floating-Point Numbers in TypeScript\nDESCRIPTION: Demonstrates encoding and decoding 64-bit floating-point numbers using both little-endian (default) and big-endian representations. Due to the IEEE 754 format, some precision loss may occur. Returns number values when decoding.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getF64Codec, Endian } from \"@solana/kit\";\n\n// Little-endian.\nconst codec = getF64Codec();\nconst bytes = codec.encode(-1.5); // 0x000000000000f8bf\nconst value = codec.decode(bytes); // -1.5\n\n// Big-endian.\nconst beCodec = getF64Codec({ endian: Endian.Big });\nconst beBytes = beCodec.encode(-1.5); // 0xbff8000000000000\nconst beValue = beCodec.decode(bytes); // -1.5\n```\n\n----------------------------------------\n\nTITLE: Using RpcRequest and RpcResponse for RPC Subscriptions in JavaScript\nDESCRIPTION: This snippet utilizes the RpcRequest and RpcResponse types to create a consistent architecture for handling requests and responses in RPC subscriptions, enhancing reliability and maintainability of the code.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Use `RpcRequest`, `RpcResponse` and their transformers in RPC Subscriptions packages\n// This change makes the RPC and RPC Subscriptions architecture more consistent\n\n```\n\n----------------------------------------\n\nTITLE: Adding Response Transformer Helpers - JavaScript\nDESCRIPTION: Introduces helper functions getThrowSolanaErrorResponseTransformer, getResultResponseTransformer, getBigIntUpcastResponseTransformer, and getTreeWalkerResponseTransformer. These functions aid in transforming responses to follow new standards and improve code organization.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Using Updated Bytes Codec in TypeScript\nDESCRIPTION: Examples of using the updated getBytesCodec function with fixed and prefixed sizes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Before.\ngetBytesCodec(); // Variable.\ngetBytesCodec({ size: 5 }); // Fixed.\ngetBytesCodec({ size: getU16Codec() }); // Prefixed.\n\n// After.\ngetBytesCodec(); // Variable.\nfixCodecSize(getBytesCodec(), 5); // Fixed.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Installing Ed25519 Polyfill with TypeScript\nDESCRIPTION: This snippet demonstrates how to install the Ed25519 polyfill in a TypeScript environment. It imports the `install` function from the `@solana/webcrypto-ed25519-polyfill` package and calls it to shim methods on `SubtleCrypto`, adding Ed25519 support.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/webcrypto-ed25519-polyfill/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { install } from '@solana/webcrypto-ed25519-polyfill';\n\n// Calling this will shim methods on `SubtleCrypto`, adding Ed25519 support.\ninstall();\n\n// Now you can do this, in environments that do not otherwise support Ed25519.\nconst keyPair = await crypto.subtle.generateKey('Ed25519', false, ['sign']);\nconst publicKeyBytes = await crypto.subtle.exportKey('raw', keyPair.publicKey);\nconst data = new Uint8Array([1, 2, 3]);\nconst signature = await crypto.subtle.sign('Ed25519', keyPair.privateKey, data);\nif (await crypto.subtle.verify('Ed25519', keyPair.publicKey, signature, data)) {\n    console.log('Data was signed using the private key associated with this public key');\n} else {\n    throw new Error('Signature verification error');\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Functionality to Replace Accounts in Transaction Messages - JavaScript\nDESCRIPTION: This update introduces a function that allows replacing accounts in a transaction message using lookup tables, thereby improving transaction management.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Add a function to replace accounts in a transaction message using lookup tables\n```\n\n----------------------------------------\n\nTITLE: Round Robin RPC Transport Implementation\nDESCRIPTION: Implementation of a round-robin transport pattern that distributes requests across multiple RPC endpoints sequentially.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDefaultRpcTransport, createSolanaRpcFromTransport, type RpcTransport } from '@solana/kit';\n\n// Create an HTTP transport for each RPC server.\nconst transports = [\n    createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-1.com' }),\n    createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-2.com' }),\n    createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-3.com' }),\n];\n\n// Set up the round-robin transport.\nlet nextTransport = 0;\nasync function roundRobinTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<TResponse> {\n    const transport = transports[nextTransport];\n    nextTransport = (nextTransport + 1) % transports.length;\n    return await transport(...args);\n}\n\n// Create an RPC client using the round-robin transport.\nconst rpc = createSolanaRpcFromTransport(roundRobinTransport);\n```\n\n----------------------------------------\n\nTITLE: Bytes Codec in TypeScript\nDESCRIPTION: Implements a bytes codec that encodes and decodes `Uint8Arrays`. It supports optional restrictions on the number of bytes used, which can be applied through combination with other size-related codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBytesCodec().encode(new Uint8Array([42])); // 0x2a\nconst value = getBytesCodec().decode(bytes); // 0x2a\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Variable size.\ngetBytesCodec().encode(new Uint8Array([42]));\n// 0x2a\n//   └-- Uint8Array content using any bytes available.\n\n// Prefixing the size with a 2-byte u16.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()).encode(new Uint8Array([42]));\n// 0x01002a\n//   |   └-- Uint8Array content.\n//   └-- 2-byte prefix telling us to read 1 bytes\n\n// Fixing the size to 5 bytes.\nfixCodecSize(getBytesCodec(), 5).encode(new Uint8Array([42]));\n// 0x2a00000000\n//   └-- Uint8Array content padded to use exactly 5 bytes.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBytesEncoder().encode(new Uint8Array([42]));\nconst value = getBytesDecoder().decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Configuring Bytes Codec with Fixed or Prefixed Size in TypeScript\nDESCRIPTION: Demonstrates how to create byte codecs with variable, fixed, or prefixed sizes using new utility functions\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetBytesCodec(); // Variable.\ngetBytesCodec({ size: 5 }); // Fixed.\ngetBytesCodec({ size: getU16Codec() }); // Prefixed.\n\n// After.\ngetBytesCodec(); // Variable.\nfixCodecSize(getBytesCodec(), 5); // Fixed.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Encoding Big-Endian Floating-Point Numbers in TypeScript\nDESCRIPTION: Demonstrates how to use f32 and f64 codecs with big-endian encoding by specifying the endian option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\ngetF32Codec({ endian: Endian.Big }).encode(-1.5); // 0xbfc00000\ngetF64Codec({ endian: Endian.Big }).encode(-1.5); // 0xbff8000000000000\n```\n\n----------------------------------------\n\nTITLE: Using Re-slicing Base-X Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBaseXResliceCodec function to create and use a custom Base-X codec that re-slices bytes into custom bit chunks.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBaseXResliceCodec('elho', 2).encode('hellolol'); // 0x4aee\nconst value = getBaseXResliceCodec('elho', 2).decode(bytes); // \"hellolol\"\n```\n\n----------------------------------------\n\nTITLE: Edge Runtime and Cloudflare Workers Compatibility - JavaScript\nDESCRIPTION: This snippet describes the integration of `edge-light` and `workerd` into the package exports to ensure compatibility with Vercel Edge runtime and Cloudflare Workers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// The build is now compatible with the Vercel Edge runtime and Cloudflare Workers\n```\n\n----------------------------------------\n\nTITLE: Encoding Big-Endian Unsigned Integers in TypeScript\nDESCRIPTION: Demonstrates how to use unsigned integer codecs with big-endian encoding by specifying the endian option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Big-endian unsigned integers.\ngetU16Codec({ endian: Endian.Big }).encode(42); // 0x002a\ngetU32Codec({ endian: Endian.Big }).encode(42); // 0x0000002a\ngetU64Codec({ endian: Endian.Big }).encode(42); // 0x000000000000002a\ngetU128Codec({ endian: Endian.Big }).encode(42); // 0x0000000000000000000000000000002a\n```\n\n----------------------------------------\n\nTITLE: Enhancements for Vercel Edge runtime and Cloudflare Workers\nDESCRIPTION: This change improves compatibility with edge computing environments by updating package exports, thus broadening the library's usability in various deployment scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Patch Change for Environment Compatibility\n// #3137\nThe build is now compatible with the Vercel Edge runtime and Cloudflare Workers.\n```\n\n----------------------------------------\n\nTITLE: Implementing Right-Padded Codec\nDESCRIPTION: Shows how to add padding to the right of a codec using padRightCodec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst rightPaddedCodec = padRightCodec(getU16Codec(), 4);\nrightPaddedCodec.encode(0xffff);\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` library using npm.  It adds the library to your project's dependencies.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Renaming mapCodec to transformCodec in TypeScript\nDESCRIPTION: The 'mapCodec' function was renamed to 'transformCodec' in a pull request to improve clarity.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- [#2434](https://github.com/solana-labs/solana-web3.js/pull/2434) [`31916ae`](https://github.com/solana-labs/solana-web3.js/commit/31916ae5d4fb29f239c63252a59745e33a6979ea) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Renamed `mapCodec` to `transformCodec`\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy PublicKey to Address using @solana/compat\nDESCRIPTION: Demonstrates the conversion of a legacy PublicKey to an Address using the @solana/compat library.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromLegacyPublicKey } from '@solana/compat';\n\nconst publicKey = new PublicKey('B3piXWBQLLRuk56XG5VihxR4oe2PSsDM8nTF6s1DeVF5');\nconst address: Address = fromLegacyPublicKey(publicKey);\n```\n\n----------------------------------------\n\nTITLE: Checking for Bytes Containment Using TypeScript\nDESCRIPTION: The `containsBytes` function checks whether one `Uint8Array` is present within another starting from a specified offset. It returns a boolean indicating the presence of the bytes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { containsBytes } from \"@solana/kit\";\n// ---cut-before---\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Encoding Hybrid Enums\nDESCRIPTION: This snippet demonstrates encoding a hybrid enum that contains both numerical and lexical values. The default behavior is to encode the index of the enum variant.  It implicitly uses the `getEnumCodec` function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nenum Numbers {\n    One,\n    Five = 5,\n    Six,\n    Nine = 'nine',\n}\n\ngetEnumCodec(Numbers).encode(Direction.One); // 0x00\ngetEnumCodec(Numbers).encode(Direction.Five); // 0x01\ngetEnumCodec(Numbers).encode(Direction.Six); // 0x02\ngetEnumCodec(Numbers).encode(Direction.Nine); // 0x03\ngetEnumCodec(Numbers).encode('One'); // 0x00\ngetEnumCodec(Numbers).encode('Five'); // 0x01\ngetEnumCodec(Numbers).encode('Six'); // 0x02\ngetEnumCodec(Numbers).encode('Nine'); // 0x03\n```\n\n----------------------------------------\n\nTITLE: Pipe Function for Object Transformation\nDESCRIPTION: Shows using the pipe function for cleaner functional composition of object transformations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst person = pipe(\n  { name: \"Alice\" },\n  (p) => setAge(30, p),\n  (p) => setWallet(address(\"1234..5678\"), p),\n);\n\nperson satisfies { name: string; age: number; wallet: Address };\n```\n\n----------------------------------------\n\nTITLE: Updating RpcApi with Transformers - JavaScript\nDESCRIPTION: Enhances the RpcApi by integrating new RpcRequestTransformer and RpcResponseTransformer, ensuring that all API requests and responses conform to the updated specifications and improving overall API reliability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Using Base10 Codec in TypeScript\nDESCRIPTION: Demonstrates how to use the getBase10Codec function to encode and decode Base10 (decimal) strings.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst bytes = getBase10Codec().encode('1024'); // 0x0400\nconst value = getBase10Codec().decode(bytes); // \"1024\"\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies for Compatibility with Vercel Edge and Cloudflare Workers - TypeScript\nDESCRIPTION: This snippet details how compatibility is achieved with Vercel Edge runtime and Cloudflare Workers through new package exports. It demonstrates a change in the API that enables a more flexible configuration of codecs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetZeroableNullableCodec(getU16Codec());\n\n// After.\ngetNullableCodec(getU16Codec(), { noneValue: 'zeroes', prefix: null });\n\nconst codec = getNullableCodec(getU16Codec(), { prefix: null });\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([])); // null\n```\n\n----------------------------------------\n\nTITLE: Generating CryptoKeypair with Kit\nDESCRIPTION: Creates a new CryptoKeyPair instance using the native Crypto API through Kit's helper function.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/signers.mdx#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateKeyPair } from \"@solana/kit\";\n\nconst wallet: CryptoKeyPair = await generateKeyPair();\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview\nDESCRIPTION: Installs the second Technology Preview of the @solana/web3.js using npm. This command is intended for developers who wish to integrate the latest Solana Web3.js functionalities and improvements, such as autogenerated instruction creators for on-chain programs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Adding Vercel Edge and Cloudflare Workers compatibility in Solana web3.js\nDESCRIPTION: This patch adds compatibility with the Vercel Edge runtime and Cloudflare Workers to Solana web3.js. This is achieved by adding `edge-light` and `workerd` to the package exports.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Refactoring String Codec Management in TypeScript\nDESCRIPTION: Demonstrates the refactoring of string codec management functions by removing the size option and providing alternative methods for fixed and prefixed sizes using fixCodecSize and addCodecSizePrefix functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n    // Before.\\n    getStringCodec({ size: 'variable' }); // Variable.\\n    getStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\\n    getStringCodec({ size: 5 }); // Fixed.\\n    getStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\\n    getStringCodec(); // Prefixed.\\n    getStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\\n\\n    // After.\\n    getUtf8Codec(); // Variable.\\n    fixCodecSize(getUtf8Codec(), 5); // Fixed.\\n    addCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\\n\n```\n\n----------------------------------------\n\nTITLE: Changing onIntegerOverflow Handler Parameter in JavaScript\nDESCRIPTION: The first argument of the onIntegerOverflow handler is modified from a string representing the method name to an RpcRequest object, providing more context for handling integer overflow scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Change first argument of `onIntegerOverflow` handler from `methodName: string` to `request: RpcRequest`\n\n```\n\n----------------------------------------\n\nTITLE: Removing Temporary Fix for Agave Issue - JavaScript\nDESCRIPTION: Documents the removal of a temporary fix related to Agave issue 479, confirming that the issue is resolved and deployed, thus cleaning up the codebase and reducing technical debt.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Using Option Codec in TypeScript\nDESCRIPTION: Demonstrates how to use getOptionCodec function to create a codec for Option<T> types, with various configurations for prefixes and none values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n\ngetOptionCodec(stringCodec).encode('Hi');\ngetOptionCodec(stringCodec).encode(some('Hi'));\n// 0x01020000004869\n//   | |       └-- utf8 string content (\"Hi\").\n//   | └-- u32 string prefix (2 characters).\n//   └-- 1-byte prefix (Some).\n\ngetOptionCodec(stringCodec).encode(null);\ngetOptionCodec(stringCodec).encode(none());\n// 0x00\n//   └-- 1-byte prefix (None).\n\nconst u32OptionStringCodec = getOptionCodec(stringCodec, {\n    prefix: getU32Codec(),\n});\n\nu32OptionStringCodec.encode(some('Hi'));\n// 0x01000000020000004869\n//   └------┘ 4-byte prefix (Some).\n\nu32OptionStringCodec.encode(none());\n// 0x00000000\n//   └------┘ 4-byte prefix (None).\n\nconst codec = getOptionCodec(\n    fixCodecSize(getUtf8Codec(), 8), // Only works with fixed-size items.\n    { noneValue: 'zeroes' },\n);\n\ncodec.encode(some('Hi'));\n// 0x014869000000000000\n//   | └-- 8-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (Some).\n\ncodec.encode(none());\n// 0x000000000000000000\n//   | └-- 8-byte of padding to make a fixed-size codec.\n//   └-- 1-byte prefix (None).\n\nconst codec = getOptionCodec(getUtf8Codec(), {\n    noneValue: new Uint8Array([255]), // 0xff means None.\n});\n\ncodec.encode(some('Hi'));\n// 0x014869\n//   | └-- 2-byte utf8 string content (\"Hi\").\n//   └-- 1-byte prefix (Some).\n\ncodec.encode(none());\n// 0x00ff\n//   | └-- 1-byte representing None (0xff).\n//   └-- 1-byte prefix (None).\n\nconst codecWithZeroNoneValue = getOptionCodec(getU16Codec(), {\n    noneValue: 'zeroes', // 0x0000 means None.\n    prefix: null,\n});\ncodecWithZeroNoneValue.encode(some(42)); // 0x2a00\ncodecWithZeroNoneValue.encode(none()); // 0x0000\n\nconst codecWithCustomNoneValue = getOptionCodec(getU16Codec(), {\n    noneValue: new Uint8Array([255]), // 0xff means None.\n    prefix: null,\n});\ncodecWithCustomNoneValue.encode(some(42)); // 0x2a00\ncodecWithCustomNoneValue.encode(none()); // 0xff\n\nconst codec = getOptionCodec(getU16Codec(), { prefix: null });\ncodec.encode(some(42)); // 0x2a00\ncodec.encode(none()); // Encodes nothing.\ncodec.decode(new Uint8Array([42, 0])); // some(42)\ncodec.decode(new Uint8Array([])); // none()\n\nconst bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\nconst value = getOptionDecoder(getU32Decoder()).decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Codec Size Modification Example - TypeScript\nDESCRIPTION: Demonstrates changes in byte codec size handling, showing the transition from size option to explicit size fixing methods\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetBytesCodec(); // Variable.\ngetBytesCodec({ size: 5 }); // Fixed.\ngetBytesCodec({ size: getU16Codec() }); // Prefixed.\n\n// After.\ngetBytesCodec(); // Variable.\nfixCodecSize(getBytesCodec(), 5); // Fixed.\naddCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Handling Offset Range Errors in TypeScript\nDESCRIPTION: Demonstrates error handling when offsets go out of range. Using an offset that is negative or exceeds the buffer size will throw a SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE error.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheEndCodec = offsetCodec(biggerU32Codec, { preOffset: () => -4 });\nu32InTheEndCodec.encode(0xffffffff);\n// throws new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE)\n```\n\n----------------------------------------\n\nTITLE: Creating Channel Pooling Channel Creator\nDESCRIPTION: Function to create a channel creator with pooling behavior. It manages channel creation, reuse, and destruction based on subscriber count and configuration.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/README.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ngetChannelPoolingChannelCreator(createChannel, { maxSubscriptionsPerChannel, minChannels })\n```\n\n----------------------------------------\n\nTITLE: Sentinel Error Handling in TypeScript\nDESCRIPTION: Demonstrates error cases when using sentinels in codecs. If the sentinel appears in the encoded data or is missing in the decoded data, dedicated errors will be thrown.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst sentinel = new Uint8Array([108, 108]); // 'll'\nconst codec = addCodecSentinel(getUtf8Codec(), sentinel);\n\ncodec.encode('hello'); // Throws: sentinel is in encoded data.\ncodec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n```\n\n----------------------------------------\n\nTITLE: Person Codec with Default Values\nDESCRIPTION: Example of transforming a Person codec to provide default values for optional fields.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = { name: string; age: number; }\nconst getPersonCodec = (): Codec<Person> => { /*...*/ }\n\ntype PersonInput = { name: string; age?: number; }\nconst getPersonWithDefaultValueCodec = (): Codec<PersonInput, Person> =>\n    transformCodec(\n        getPersonCodec(),\n        (person: PersonInput): Person => { ...person, age: person.age ?? 42 }\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting Default __DEV__ Mode\nDESCRIPTION: Sets __DEV__ mode as the default when process.env.NODE_ENV is not set, to prevent accidental production mode with minified error messages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- [#2907](https://github.com/solana-labs/solana-web3.js/pull/2907) [`677a9c4`](https://github.com/solana-labs/solana-web3.js/commit/677a9c4eb88a8ac6a9ede8d82f367c5ac8d69ff4) Thanks [@steveluscher](https://github.com/steveluscher)! - `__DEV__` mode will now be the default if you don't set `process.env.NODE_ENV` at all. This means fewer people 'accidentally' finding themselves in production mode with minified error messages.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 with NPM\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` package using npm. This allows developers to test the latest features and bug fixes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 with NPM\nDESCRIPTION: This command installs the second technology preview version (tp2) of the `@solana/web3.js` package using npm. It ensures the specific version is installed, allowing developers to test and utilize the new features and bug fixes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Defining RPC client type\nDESCRIPTION: This code snippet defines the type for an RPC client with a generic type `TRpcMethods`. This defines the basic structure for RPC methods that will be used later.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nRpc<TRpcMethods>;\n```\n\n----------------------------------------\n\nTITLE: Listing Dependency Updates for @solana/rpc-subscriptions-api v2.1.0\nDESCRIPTION: This code block lists the updated dependencies for version 2.1.0 of the @solana/rpc-subscriptions-api package. It includes commit hashes and links to the changes in the GitHub repository.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-api/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Updated dependencies [[`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d), [`d1c787c`](https://github.com/anza-xyz/kit/commit/d1c787c447bd134e6a6da8be059c8353f92b2f9a), [`0c577eb`](https://github.com/anza-xyz/kit/commit/0c577eb03fa5db8b817f209d52a19a36976c7c12), [`9b179dc`](https://github.com/anza-xyz/kit/commit/9b179dc6b7c7e6e4d51481a396567f17665abbc3), [`29d1e28`](https://github.com/anza-xyz/kit/commit/29d1e282f7ae53db008515980f13d54c40760065), [`400f4d5`](https://github.com/anza-xyz/kit/commit/400f4d5673286a197561033bba63bac9a433cc6a), [`704d8a2`](https://github.com/anza-xyz/kit/commit/704d8a220592a5a472bd7726013814b50c991f5b)]:\n    - @solana/addresses@2.1.0\n    - @solana/keys@2.1.0\n    - @solana/rpc-types@2.1.0\n    - @solana/rpc-subscriptions-spec@2.1.0\n    - @solana/transaction-messages@2.1.0\n    - @solana/transactions@2.1.0\n    - @solana/rpc-transformers@2.1.0\n```\n\n----------------------------------------\n\nTITLE: Adding Vercel Edge and Cloudflare Workers compatibility\nDESCRIPTION: Adds compatibility with Vercel Edge runtime and Cloudflare Workers by including 'edge-light' and 'workerd' in the package exports.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nThe build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm. This version contains bug fixes, new features, and improved integration with JavaScript client generators for on-chain programs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/programs/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Checking Feature Status in Solana\nDESCRIPTION: This code snippet checks the status of a specific feature in Solana, detailing its activation slot and current status. It is essential for developers monitoring features in Solana versions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/sysvars/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n% solana feature status JAN1trEUEtZjgXYzNBYHU9DYd7GnThhXfFP7SzPXkPsG\nFeature                                      | Status                  | Activation Slot | Description\nJAN1trEUEtZjgXYzNBYHU9DYd7GnThhXfFP7SzPXkPsG | active since epoch 483  | 208656004       | disable fees sysvar\n```\n\n----------------------------------------\n\nTITLE: Creating Tree-Shakeable Codec Functions\nDESCRIPTION: Shows how to split codec logic into tree-shakeable encoder and decoder functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst getU32InTheMiddleEncoder = () => offsetEncoder(biggerU32Encoder, { preOffset: ({ preOffset }) => preOffset + 2 });\nconst getU32InTheMiddleDecoder = () => offsetDecoder(biggerU32Decoder, { preOffset: ({ preOffset }) => preOffset + 2 });\nconst getU32InTheMiddleCodec = () => combineCodec(getU32InTheMiddleEncoder(), getU32InTheMiddleDecoder());\n```\n\n----------------------------------------\n\nTITLE: Vercel Edge and Cloudflare Workers Compatibility - Solana\nDESCRIPTION: The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports. This enables the use of `@solana/signers` in edge computing environments. This significantly expands the deployment options for applications using the library.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: N/A\nCODE:\n```\n``fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.``\n```\n\n----------------------------------------\n\nTITLE: Using containsBytes and getConstantCodec Helpers in TypeScript\nDESCRIPTION: Examples of using the containsBytes helper to check if a Uint8Array contains another at a given offset, and the getConstantCodec function that creates a codec for fixed byte sequences.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\ncontainsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing Cipher Codec for Alphabet\nDESCRIPTION: Variable-size codec implementation for encoding/decoding alphabet characters to numbers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst alphabet = ' abcdefghijklmnopqrstuvwxyz';\n\nconst getCipherEncoder = () =>\n    createEncoder<string>({\n        getSizeFromValue: value => value.length,\n        write(value, bytes, offset) {\n            const bytesToAdd = [...value].map(char => alphabet.indexOf(char));\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n\nconst getCipherDecoder = () =>\n    createDecoder<string>({\n        read(bytes, offset) {\n            const value = [...bytes.slice(offset)].map(byte => alphabet.charAt(byte)).join('');\n            return [value, bytes.length];\n        },\n    });\n\nconst getCipherCodec = () => combineCodec(getCipherEncoder(), getCipherDecoder());\n```\n\n----------------------------------------\n\nTITLE: Mutable Object Update Pattern\nDESCRIPTION: Shows a mutable approach to updating object properties, highlighting type inference limitations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/build-transaction.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nlet person = { name: \"Alice\" };\nperson = setAge(30, person);\nperson = setWallet(address(\"1234..5678\"), person);\n\nperson satisfies { name: string; age: number; wallet: Address };\n```\n\n----------------------------------------\n\nTITLE: Using Option Type Guards in TypeScript\nDESCRIPTION: Shows how to use isSome and isNone type guards to check the type of an Option.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nisSome(some('Hello World')); // true\nisSome(none()); // false\n\nisNone(some('Hello World')); // false\nisNone(none()); // true\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` library using npm.  This allows developers to test the latest features and provide feedback before the official release. It adds the specified version to the project's dependencies.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n\"npm install --save @solana/web3.js@tp2\"\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview version of @solana/web3.js using npm package manager.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/functional/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Refactoring Byte Codec Management in TypeScript\nDESCRIPTION: Shows changes in byte codec management, eliminating the size option and introducing methods to handle fixed and prefixed sizes using fixCodecSize and addCodecSizePrefix functions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n    // Before.\\n    getBytesCodec(); // Variable.\\n    getBytesCodec({ size: 5 }); // Fixed.\\n    getBytesCodec({ size: getU16Codec() }); // Prefixed.\\n\\n    // After.\\n    getBytesCodec(); // Variable.\\n    fixCodecSize(getBytesCodec(), 5); // Fixed.\\n    addCodecSizePrefix(getBytesCodec(), getU16Codec()); // Prefixed.\\n\n```\n\n----------------------------------------\n\nTITLE: Custom Size Literal Union Codec\nDESCRIPTION: Demonstrates using custom number codec with getLiteralUnionCodec for different size representations of union values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec([\"left\", \"right\", \"up\", \"down\"], {\n  size: getU32Codec(),\n});\n\ncodec.encode(\"left\"); // 0x00000000\ncodec.encode(\"right\"); // 0x01000000\ncodec.encode(\"up\"); // 0x02000000\ncodec.encode(\"down\"); // 0x03000000\n```\n\n----------------------------------------\n\nTITLE: Using Enum Codec with Values in TypeScript\nDESCRIPTION: Shows how to use getEnumCodec with the useValuesAsDiscriminators option for numerical enums\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nenum Numbers {\n    One,\n    Five = 5,\n    Six,\n    Nine = 9,\n}\n\nconst codec = getEnumCodec(Numbers, { useValuesAsDiscriminators: true });\ncodec.encode(Direction.One); // 0x00\ncodec.encode(Direction.Five); // 0x05\ncodec.encode(Direction.Six); // 0x06\ncodec.encode(Direction.Nine); // 0x09\n```\n\n----------------------------------------\n\nTITLE: Creating and Using NoopSigner in TypeScript\nDESCRIPTION: Demonstrates how to create a Noop signer that implements MessagePartialSigner and TransactionPartialSigner interfaces but returns empty signature dictionaries.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/README.md#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst myNoopSigner: NoopSigner;\nmyNoopSigner satisfies MessagePartialSigner;\nmyNoopSigner satisfies TransactionPartialSigner;\n```\n\n----------------------------------------\n\nTITLE: HTTP Transport Json Options - JavaScript\nDESCRIPTION: This snippet details the addition of `fromJson` and `toJson` options for the HTTP transport setup, enhancing configurability for JSON data handling during API requests and responses within the Solana Web3.js framework.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Add `fromJson` and `toJson` options to the HTTP transport\n```\n\n----------------------------------------\n\nTITLE: Splitting ModuloU8 into Separate Encoder/Decoder\nDESCRIPTION: Implementation of ModuloU8 codec split into separate encoder and decoder components for tree-shaking.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst getModuloU8Encoder = () =>\n    createEncoder<number>({\n        fixedSize: 1,\n        write(value, bytes, offset) {\n            bytes.set(value % 256, offset);\n            return offset + 1;\n        },\n    });\n\nconst getModuloU8Decoder = () =>\n    createDecoder<number>({\n        fixedSize: 1,\n        read(bytes, offset) {\n            const value = bytes[offset];\n            return [value, offset + 1];\n        },\n    });\n\nconst getModuloU8Codec = () => combineCodec(getModuloU8Encoder(), getModuloU8Decoder());\n```\n\n----------------------------------------\n\nTITLE: Precision Loss Example with f32 Codec in TypeScript\nDESCRIPTION: Illustrates potential precision loss when encoding and decoding floating-point numbers with f32 codec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bytes = getF32Codec().encode(3.1415); // 0x560e4940\nconst value = getF32Codec().decode(bytes); // 3.1414999961853027 !== 3.1415\n```\n\n----------------------------------------\n\nTITLE: Using assertKeyExporterIsAvailable for WebCrypto key export checking\nDESCRIPTION: Function that throws an exception unless crypto.subtle.exportKey() is available in the current JavaScript environment. Used to ensure key exporting capabilities are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/README.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`assertKeyExporterIsAvailable()`\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: This shell command installs the second Technology Preview of the @solana/web3.js package using npm. The installation ensures that developers can use the latest features and improvements provided in the upgrade. A prerequisite is having npm installed on your machine.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Retry Logic for Transport Requests\nDESCRIPTION: This snippet demonstrates a transport function with built-in retry logic, allowing failed requests to be retried a specified number of times before giving up, using exponential backoff to manage delays between attempts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst MAX_ATTEMPTS = 4;\n\nconst defaultTransport = createHttpTransport({ url: 'https://mainnet-beta.my-server-1.com' });\n\nfunction sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction calculateRetryDelay(attempt: number): number {\n    return Math.min(100 * Math.pow(2, attempt), 1500);\n}\n\nasync function retryingTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<RpcResponse<TResponse>> {\n    let requestError;\n    for (let attempts = 0; attempts < MAX_ATTEMPTS; attempts++) {\n        try {\n            return await defaultTransport(...args);\n        } catch (err) {\n            requestError = err;\n            if (attempts < MAX_ATTEMPTS - 1) {\n                const retryDelay = calculateRetryDelay(attempts);\n                await sleep(retryDelay);\n            }\n        }\n    }\n    throw requestError;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 with npm\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` package using npm. It saves the package as a project dependency.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transport-http/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n\"npm install --save @solana/web3.js@tp2\"\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies in the Package - JavaScript\nDESCRIPTION: This snippet demonstrates the routine update of multiple dependencies within the Solana Web3.js package, ensuring users have access to the latest features and bug fixes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Patch Change for Dependency Updates\nUpdated dependencies: @solana/addresses@2.0.0-rc.2, @solana/errors@2.0.0-rc.2, etc.\n```\n\n----------------------------------------\n\nTITLE: Adding Edge Runtime Compatibility\nDESCRIPTION: Adds compatibility with Vercel Edge runtime and Cloudflare Workers by including edge-light and workerd in package exports.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n- [#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n```\n\n----------------------------------------\n\nTITLE: Using commonjs package type in Solana web3.js\nDESCRIPTION: This patch modifies the package type to use commonjs. This allows Solana web3.js to be used in a wider range of environments.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js Technology Preview 2 with npm\nDESCRIPTION: This snippet provides the command necessary to install the second Technology Preview version of @solana/web3.js using npm. The command includes the package name and version specification.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 4\nDESCRIPTION: Command to install the fourth Technology Preview version of the Solana Web3.js SDK using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/kit/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp4\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Response for Block Query\nDESCRIPTION: Example JSON response structure for a block query that retrieves block metadata, rewards information, and transaction details within the block.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_27\n\nLANGUAGE: json\nCODE:\n```\ndata: {\n    block: {\n        blockHeight: 196758578n,\n        blockhash: 'BqFCPqXUm4cq6jaZZx1TDTvUR1wdEuNNwAHBEVR6mJhM',\n        parentSlot: 230862408n,\n        rewards: [\n            {\n                commission: 0.05,\n                lamports: 58578n,\n                rewardType: 'Staking',\n            },\n            {\n                commission: 0.05,\n                lamports: 58578n,\n                rewardType: 'Staking',\n            }\n        ],\n        transactions: [\n            {\n                message: {\n                    instructions: [\n                        {\n                            lamports: 890880n,\n                            programId: '11111111111111111111111111111111',\n                            space: 0n,\n                        },\n                        /* .. */\n                    ]\n                },\n            }\n        ],\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing transaction confirmer bug in Solana web3.js\nDESCRIPTION: This patch fixes a bug in the transaction confirmer within Solana web3.js.  The bug could incorrectly claim that the blockheight had been exceeded due to an aborted confirmation by an `AbortSignal`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Adding Size Prefix to Base58 Codec in TypeScript\nDESCRIPTION: Demonstrates the usage of the new addCodecSizePrefix primitive to add a u32 size prefix to a base58-encoded string.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ncodec.encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Using assertVerificationCapabilityIsAvailable for WebCrypto verification checking\nDESCRIPTION: Function that throws an exception unless crypto.subtle.sign() is available in the current JavaScript environment. Used to ensure signature verification capabilities are present.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/README.md#2025-04-18_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n`assertVerificationCapabilityIsAvailable()`\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 via NPM\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` package using npm. This specific version includes new features, bug fixes, and changes as outlined in the release notes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Constraining Solana RPC API TypeScript\nDESCRIPTION: This snippet demonstrates how to constrain the Solana RPC API by specifying the RPC cluster (mainnet or devnet) in TypeScript. It uses cluster-specific helper functions to wrap RPC URLs and integrate them into the RPC type system. The process enforces cluster-specific APIs by limiting accessible methods depending on the cluster context.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { createSolanaRpc, mainnet, devnet } from '@solana/kit';\n\nconst mainnetRpc = createSolanaRpc(mainnet('https://api.mainnet-beta.solana.com'));\n//    ^? RpcMainnet<SolanaRpcApiMainnet>\n\nconst devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n//    ^? RpcDevnet<SolanaRpcApiDevnet>\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js Technology Preview 2 using npm\nDESCRIPTION: This shell command installs the second Technology Preview of the @solana/web3.js library. The `--save` flag is used to add the package to the dependencies in the package.json file.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 with npm\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js. This version includes significant improvements over the first preview and integrates with the new JavaScript client generator for on-chain programs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Adding Vercel Edge and Cloudflare Workers Compatibility\nDESCRIPTION: The build was made compatible with Vercel Edge runtime and Cloudflare Workers by adding 'edge-light' and 'workerd' to the package exports.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n- [#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n```\n\n----------------------------------------\n\nTITLE: Using getI8Codec for Signed 8-bit Integers in TypeScript\nDESCRIPTION: Demonstrates how to use the getI8Codec function to encode and decode signed 8-bit integers. This codec supports values from -127 to 128 and returns decoded values as numbers.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getI8Codec } from \"@solana/kit\";\nconst codec = getI8Codec();\nconst bytes = codec.encode(-42); // 0xd6\nconst value = codec.decode(bytes); // -42\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 with npm\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` package using npm. It saves the specified version as a project dependency.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Account Fetching and Validation in Kit\nDESCRIPTION: Shows how to use Kit's helper functions for fetching and validating encoded accounts.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, assertAccountExists, fetchEncodedAccount } from \"@solana/kit\";\n\nconst wallet = address(\"1234..5678\");\nconst account = await fetchEncodedAccount(rpc, wallet);\nassertAccountExists(account);\naccount.data satisfies Uint8Array;\n```\n\n----------------------------------------\n\nTITLE: Renaming fixCodec to fixCodecSize\nDESCRIPTION: Refactors a utility function name from `fixCodec` to `fixCodecSize`, likely improving clarity and specificity of the codec utility\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Asserting Single Sending Signer - Solana\nDESCRIPTION: The `signAndSendTransactionMessageWithSigners` function now asserts that the provided transaction message contains only one sending signer. This patch change ensures that the function operates correctly and prevents potential issues when multiple signers are present for a single transaction message. This enhances the function's reliability and predictability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n``cec9048`](https://github.com/solana-labs/solana-web3.js/commit/cec9048b2f83535df7e499db5488c336981dfb5a) Thanks [@lorisleiva](https://github.com/lorisleiva)! - The `signAndSendTransactionMessageWithSigners` function now automatically asserts that the provided transaction message contains a single sending signer and fails otherwise.``\n```\n\n----------------------------------------\n\nTITLE: Decoding Error Messages with Shell Command\nDESCRIPTION: Demonstrates how to decode error codes back to human-readable messages using the CLI tool.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/README.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx @solana/errors decode -- 123\n```\n\n----------------------------------------\n\nTITLE: Adding Codec Size Prefix in TypeScript\nDESCRIPTION: Demonstrates how to add a size prefix to a codec, enabling encoding of strings with their length prepended\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n\ncodec.encode('hello world');\n// 0x0b00000068656c6c6f20776f726c64\n//   |       └-- Our encoded base-58 string.\n//   └-- Our encoded u32 size prefix.\n```\n\n----------------------------------------\n\nTITLE: Refactoring Codec Utilities in Solana Web3.js\nDESCRIPTION: This snippet demonstrates the refactoring of codec utility functions in Solana Web3.js. It replaces the `getStringCodec` function with `fixCodecSize` and `addCodecSizePrefix` for handling variable and fixed sizes of encoded strings. Dependencies required include utf8Codec and u32Codec. The input involves specifying the codec and size, with the output being the appropriately modified codec. The main constraints involve ensuring that bytes allocated match the encoding size expectations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\\ngetStringCodec({ size: 'variable' }); // Variable.\\ngetStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\\ngetStringCodec({ size: 5 }); // Fixed.\\ngetStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\\ngetStringCodec(); // Prefixed.\\ngetStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\\n\\n// After.\\ngetUtf8Codec(); // Variable.\\nfixCodecSize(getUtf8Codec(), 5); // Fixed.\\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Using reverseCodec with U64 in TypeScript\nDESCRIPTION: Shows how to reverse the byte order of a fixed-size codec using the reverseCodec helper. This example creates a big-endian U64 codec by reversing the default little-endian implementation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reverseCodec, getU64Codec } from \"@solana/kit\";\nconst getBigEndianU64Codec = () => reverseCodec(getU64Codec());\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: This command installs the second Technology Preview (tp2) version of the `@solana/web3.js` package using npm. This allows developers to test the latest features and bug fixes before they are officially released.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Web Crypto Ed25519 Polyfill for Environments without Native Support\nDESCRIPTION: Demonstrates how to install a polyfill for Web Crypto's Ed25519 API in environments that don't natively support it. This ensures compatibility across different platforms.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { install } from '@solana/webcrypto-ed25519-polyfill';\nimport { generateKeyPair, signBytes, verifySignature } from '@solana/kit';\n\ninstall();\nconst keyPair: CryptoKeyPair = await generateKeyPair();\n\n/* Remaining logic */\n```\n\n----------------------------------------\n\nTITLE: Renaming fixCodec to fixCodecSize in TypeScript\nDESCRIPTION: The 'fixCodec' function was renamed to 'fixCodecSize' to improve clarity.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n- [#2411](https://github.com/solana-labs/solana-web3.js/pull/2411) [`2e5af9f`](https://github.com/solana-labs/solana-web3.js/commit/2e5af9f1a9410f15108863342b48225fdf9a0c83) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Renamed `fixCodec` to `fixCodecSize`\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Replacing Subscription Configuration with RpcRequest in JavaScript\nDESCRIPTION: This change involves replacing subscriptionConfigurationHash with RpcRequest in RpcSubscriptionPlan, streamlining the handling of subscription configurations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Replace subscriptionConfigurationHash with RpcRequest in RpcSubscriptionPlan\n\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 - Shell\nDESCRIPTION: This snippet provides the command to install the second Technology Preview of the Solana Web3.js library using npm, ensuring users can access the latest features and bug fixes introduced in this release.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Implementing Absolute Offsets in Codec\nDESCRIPTION: Shows how to use absolute offsets instead of relative ones in codec operations.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n  preOffset: () => 2,\n  postOffset: () => 8,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n```\n\n----------------------------------------\n\nTITLE: Creating Solana RPC Subscriptions Channel - TypeScript\nDESCRIPTION: This snippet defines a function to create a channel for Solana RPC subscriptions, managing large integer values safely within JSON messages. It ensures compatibility with Solana's requirements for numeric value handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createDefaultSolanaRpcSubscriptionsChannelCreator() {\n    // Logic to create channel with BigInt support\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Base16 String to Byte Buffer Conversion\nDESCRIPTION: The conversion of base16 strings to byte buffers was optimized, resulting in a 2-3x speed improvement. Credit is given to @tibi77 for this performance enhancement.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n- [`3bf31e7`](https://github.com/solana-labs/solana-web3.js/commit/3bf31e7b7918cb60cd9f5f4476909d81257cdfd7) Thanks [@steveluscher](https://github.com/steveluscher)! - Converting a base16 string to a byte buffer is now between 2-3x faster (Thanks @tibi77!)\n```\n\n----------------------------------------\n\nTITLE: Check Bytes with containsBytes in Typescript\nDESCRIPTION: This snippet shows how to use the `containsBytes` helper function to check if a `Uint8Array` contains another `Uint8Array` at a specific offset. This is useful for validating data structures.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n    containsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 1); // true\n    containsBytes(new Uint8Array([1, 2, 3, 4]), new Uint8Array([2, 3]), 2); // false\n```\n\n----------------------------------------\n\nTITLE: Building Solana React App for Production Deployment\nDESCRIPTION: Commands to install dependencies and build a static bundle with HTML for deploying the Solana example React app to a webserver.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/react-app/README.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\npnpm turbo build\n```\n\n----------------------------------------\n\nTITLE: Literal Union Encoding/Decoding\nDESCRIPTION: This snippet demonstrates the use of `getLiteralUnionCodec` to encode and decode literal union types. It creates a codec for a union of string literals and shows how to encode and decode values from that union. It implicitly uses `getLiteralUnionCodec`.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getLiteralUnionCodec(['left', 'right', 'up', 'down']);\n// ^? FixedSizeCodec<\"left\" | \"right\" | \"up\" | \"down\">\n\nconst bytes = codec.encode('left'); // 0x00\nconst value = codec.decode(bytes); // 'left'\n```\n\n----------------------------------------\n\nTITLE: Using CommonJS Package Type\nDESCRIPTION: Changes the package type to CommonJS for improved compatibility.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- [#2606](https://github.com/solana-labs/solana-web3.js/pull/2606) [`367b8ad`](https://github.com/solana-labs/solana-web3.js/commit/367b8ad0cce55a916abfb0125f36b6e844333b2b) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Use commonjs package type\n```\n\n----------------------------------------\n\nTITLE: Running an Individual Example\nDESCRIPTION: This command starts a specific example. It should be executed in the directory of the chosen example.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/README.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm start\n```\n\n----------------------------------------\n\nTITLE: Listing Updated Dependencies in Markdown\nDESCRIPTION: This code block lists the updated dependencies for the package, including their versions and associated commit hashes. It's formatted as a Markdown list with links to the commits.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- @solana/codecs-core@2.1.0\n- @solana/codecs-numbers@2.1.0\n- @solana/errors@2.1.0\n```\n\n----------------------------------------\n\nTITLE: Fixing Bytes Length Using TypeScript\nDESCRIPTION: The `fixBytes` function pads or truncates a `Uint8Array` to achieve the specified length. The implementation adjusts the byte array accordingly based on the target size.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fixBytes } from \"@solana/kit\";\n// ---cut-before---\nfixBytes(new Uint8Array([1, 2]), 4); // Uint8Array([1, 2, 0, 0])\nfixBytes(new Uint8Array([1, 2, 3, 4]), 2); // Uint8Array([1, 2])\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Kit Project Examples\nDESCRIPTION: This command installs all required dependencies for the kit project examples using pnpm package manager.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/README.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Implementing Wrapped Byte Offsets\nDESCRIPTION: Demonstrates using wrapBytes function to handle negative offsets safely.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheEndCodec = offsetCodec(biggerU32Codec, {\n  preOffset: ({ wrapBytes }) => wrapBytes(-4),\n});\nu32InTheEndCodec.encode(0xffffffff);\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Kit via NPM\nDESCRIPTION: Command to install the @solana/kit package as a dependency for Node.js or web applications.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/kit\n```\n\n----------------------------------------\n\nTITLE: Specifying Node LTS version - Solana\nDESCRIPTION: This change specifies a two-versions-old version of Node LTS across the project using the `engines` field. Engine-strictness is delegated to the `.npmrc` files. This ensures consistency and compatibility across different development environments. By enforcing a specific Node version, the risk of runtime errors and unexpected behavior is reduced.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\n``1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d) Thanks [@leantOnSol](https://github.com/leantOnSol)! - A two-versions-old version of Node LTS is now specified everywhere via the `engines` field, including the one in the root of the `pnpm` workspace, and engine-strictness is delegated to the `.npmrc` files.``\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3 JS Library\nDESCRIPTION: This code snippet provides the command to install the second Technology Preview of the Solana Web3 JS Library using npm. Ensure that you have Node.js and npm installed on your system before running this command.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-parsed-types/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Fixing TypeScript Return Type for simulateTransaction\nDESCRIPTION: Corrects TypeScript type definition to accurately reflect that transaction simulation results have accounts under the `value.accounts` property instead of the top-level\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Updating Node engine specification in package.json\nDESCRIPTION: Specifies a two-versions-old version of Node LTS in the 'engines' field of package.json files, including the root of the pnpm workspace. Engine strictness is delegated to .npmrc files.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d) Thanks [@leantOnSol](https://github.com/leantOnSol)! - A two-versions-old version of Node LTS is now specified everywhere via the `engines` field, including the one in the root of the `pnpm` workspace, and engine-strictness is delegated to the `.npmrc` files.\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js Technology Preview 2 via npm\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm. The package can be installed with the 'tp2' tag.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transactions/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing the second Technology Preview of @solana/web3.js\nDESCRIPTION: This snippet demonstrates the command to install the second Technology Preview version of the @solana/web3.js library. Ensure that you are using a compatible version of Node.js.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/webcrypto-ed25519-polyfill/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Disabling MaxListenersExceededWarning in Node\nDESCRIPTION: This code snippet disables the MaxListenersExceededWarning in Node when creating event targets for internal use.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [`29d1e28`](https://github.com/anza-xyz/kit/commit/29d1e282f7ae53db008515980f13d54c40760065) Thanks [@steveluscher](https://github.com/steveluscher)! - Disabled the `MaxListenersExceededWarning` in Node when creating event targets for internal use\n```\n\n----------------------------------------\n\nTITLE: Changing Transaction Message Data Field\nDESCRIPTION: This patch changes the `data` field of transaction message instructions to use `ReadonlyUint8Array`. This ensures that the instruction data is treated as immutable, improving data integrity and security within transaction messages. This change was introduced in version 2.1.0 of the package.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Using Absolute Offsets in TypeScript\nDESCRIPTION: Shows how to use absolute offset values instead of relative ones. This approach is less flexible when composing codecs, but can be useful in specific scenarios.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/README.md#2025-04-18_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n    preOffset: () => 2,\n    postOffset: () => 8,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n// 0x0000ffffffff0000\n```\n\n----------------------------------------\n\nTITLE: Updating Node Version Specification in Package.json\nDESCRIPTION: A change was made to specify a two-versions-old Node LTS version in the 'engines' field of package.json files, including the root of the pnpm workspace. Engine strictness is now delegated to .npmrc files.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d) Thanks [@leantOnSol](https://github.com/leantOnSol)! - A two-versions-old version of Node LTS is now specified everywhere via the `engines` field, including the one in the root of the `pnpm` workspace, and engine-strictness is delegated to the `.npmrc` files.\n```\n\n----------------------------------------\n\nTITLE: Changing Package Type to CommonJS\nDESCRIPTION: Updates the package configuration to use CommonJS module system, affecting how the library is imported and used in projects\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Installing the Second Technology Preview of @solana/web3.js using npm\nDESCRIPTION: This code snippet demonstrates how to install the second Technology Preview of the @solana/web3.js library using npm. It requires Node.js and npm to be installed on your machine. The command installs the 'tp2' version of the package and is essential for developers looking to utilize the latest features and bug fixes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-core/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Initializing U64 Codec in TypeScript @solana/kit\nDESCRIPTION: This snippet demonstrates the initialization of a u64 codec that allows encoding a number or bigint type and always decodes it into bigint. The purpose is to handle u64 numbers where the encoder accepts a broader type for convenience, while the decoder returns a consistent bigint type. Importing @solana/kit’s getU64Codec is required.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Codec, getU64Codec } from \"@solana/kit\";\nconst u64Codec: Codec<number | bigint, bigint> = getU64Codec();\n```\n\n----------------------------------------\n\nTITLE: Switching to CommonJS Package Type\nDESCRIPTION: The package type was changed to CommonJS for improved compatibility.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n- [#2606](https://github.com/solana-labs/solana-web3.js/pull/2606) [`367b8ad`](https://github.com/solana-labs/solana-web3.js/commit/367b8ad0cce55a916abfb0125f36b6e844333b2b) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Use commonjs package type\n```\n\n----------------------------------------\n\nTITLE: Disabling MaxListenersExceededWarning in Node\nDESCRIPTION: This change disables the 'MaxListenersExceededWarning' warning in Node.js when creating event targets, enhancing internal event management without unnecessary warning messages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Disabled the MaxListenersExceededWarning in Node when creating event targets for internal use\n```\n\n----------------------------------------\n\nTITLE: Publishing @solana/web3.js at Version 2.0.0\nDESCRIPTION: The Release Candidate label was dropped and @solana/web3.js was published at version 2.0.0.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n- [#3541](https://github.com/solana-labs/solana-web3.js/pull/3541) [`135dc5a`](https://github.com/solana-labs/solana-web3.js/commit/135dc5ad43f286380a4c3a689668016f0d7945f4) Thanks [@steveluscher](https://github.com/steveluscher)! - Drop the Release Candidate label and publish `@solana/web3.js` at version 2.0.0\n```\n\n----------------------------------------\n\nTITLE: Enum Codec with Value Discriminators\nDESCRIPTION: Shows how to use the `useValuesAsDiscriminators` option in `getEnumCodec` to encode enum values directly\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nenum Numbers {\n    One,\n    Five = 5,\n    Six,\n    Nine = 9,\n}\n\nconst codec = getEnumCodec(Numbers, { useValuesAsDiscriminators: true });\ncodec.encode(Direction.One); // 0x00\ncodec.encode(Direction.Five); // 0x05\ncodec.encode(Direction.Six); // 0x06\ncodec.encode(Direction.Nine); // 0x09\n```\n\n----------------------------------------\n\nTITLE: Using RpcRequest and RpcResponse in RPC Subscriptions - TypeScript\nDESCRIPTION: This snippet introduces the `RpcRequest` and `RpcResponse` types, updating the RPC architecture to ensure user requests and responses are handled consistently. It is intended to improve the clarity and maintainability of the code related to RPC subscriptions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Use the RpcRequest and RpcResponse types\nimport { RpcRequest, RpcResponse } from './rpc-types';\n\n// Example function handling a request\nfunction handleRequest(request: RpcRequest): RpcResponse {\n    // Logic to process the request and return a response\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/assertions/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js Technology Preview 2 via npm\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm package manager.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Disabling MaxListenersExceededWarning in Node\nDESCRIPTION: Disables the MaxListenersExceededWarning in Node when creating event targets for internal use.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-channel-websocket/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [`29d1e28`](https://github.com/anza-xyz/kit/commit/29d1e282f7ae53db008515980f13d54c40760065) Thanks [@steveluscher](https://github.com/steveluscher)! - Disabled the `MaxListenersExceededWarning` in Node when creating event targets for internal use\n```\n\n----------------------------------------\n\nTITLE: Asserting Multiple Accounts Decoded in TypeScript\nDESCRIPTION: The `assertAccountsDecoded` function validates that a list of accounts is decoded, i.e., not containing any Uint8Array data. Similar to `assertAccountDecoded`, it only confirms data format, not structure. The function requires an array of `Account` objects and ensures each one is evaluated as decoded.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/accounts/README.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ntype MyAccountData = { name: string; age: number };\n\nconst myAccounts: Account<MyAccountData | Uint8Array, Address>[];\nassertAccountsDecoded(myAccounts);\n\n// now the account data can be used as MyAccountData\nfor (const a of account) {\n    account.data satisfies MyAccountData;\n}\n```\n\n----------------------------------------\n\nTITLE: Solana RPC Types Changelog Entries\nDESCRIPTION: Version history entries documenting changes to the @solana/rpc-parsed-types package, including timestamps, commit links, and changelogs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-parsed-types/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @solana/rpc-parsed-types\n\n## 2.1.0\n\n## 2.0.0\n\n### Patch Changes\n\n- [#3541](https://github.com/solana-labs/solana-web3.js/pull/3541) [`135dc5a`](https://github.com/solana-labs/solana-web3.js/commit/135dc5ad43f286380a4c3a689668016f0d7945f4) Thanks [@steveluscher](https://github.com/steveluscher)! - Drop the Release Candidate label and publish `@solana/web3.js` at version 2.0.0\n\n- [#3134](https://github.com/solana-labs/solana-web3.js/pull/3134) [`38faba0`](https://github.com/solana-labs/solana-web3.js/commit/38faba05fab479ddbd95d0e211744d203f8aa823) Thanks [@buffalojoec](https://github.com/buffalojoec)! - Change unix timestamp type to bigint with an unsafe label\n\n- [#2606](https://github.com/solana-labs/solana-web3.js/pull/2606) [`367b8ad`](https://github.com/solana-labs/solana-web3.js/commit/367b8ad0cce55a916abfb0125f36b6e844333b2b) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Use commonjs package type\n\n- [#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a) Thanks [@mcintyre94](https://github.com/mcintyre94)! - The build is now compatible with the Vercel Edge runtime and Cloudflare Workers through the addition of `edge-light` and `workerd` to the package exports.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview version of @solana/web3.js via npm package manager.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server\nDESCRIPTION: Launches the local development server using PNPM to serve the documentation website.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/README.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Changing Parameter Type for onIntegerOverflow Handler - JavaScript\nDESCRIPTION: Modifies the onIntegerOverflow handler's first argument from methodName of type string to request of type RpcRequest, improving type safety and clarity in the handling of integer overflows during RPC calls.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Sample JSON Response for Transaction Query\nDESCRIPTION: Example JSON response structure for a transaction query that retrieves CreateAccountInstruction details, showing the lamports, programId, and space values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_22\n\nLANGUAGE: json\nCODE:\n```\ndata: {\n    transaction: {\n        message: {\n            instructions: [\n                {\n                    lamports: 890880n,\n                    programId: '11111111111111111111111111111111',\n                    space: 0n,\n                },\n                /* .. */\n            ]\n        },\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Version Control Commit Reference\nDESCRIPTION: Git commit hash references and pull request links documenting package changes including TypeScript type additions, package type changes, and runtime compatibility updates.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/fast-stable-stringify/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[#2502](https://github.com/solana-labs/solana-web3.js/pull/2502) [`5ed19c6`](https://github.com/solana-labs/solana-web3.js/commit/5ed19c6c3c6e7a1bacde8c23c438ecb85454b126)\n[#3541](https://github.com/solana-labs/solana-web3.js/pull/3541) [`135dc5a`](https://github.com/solana-labs/solana-web3.js/commit/135dc5ad43f286380a4c3a689668016f0d7945f4)\n[#2606](https://github.com/solana-labs/solana-web3.js/pull/2606) [`367b8ad`](https://github.com/solana-labs/solana-web3.js/commit/367b8ad0cce55a916abfb0125f36b6e844333b2b)\n[#3137](https://github.com/solana-labs/solana-web3.js/pull/3137) [`fd72c2e`](https://github.com/solana-labs/solana-web3.js/commit/fd72c2ed1edad488318fa5d3e285f04852f4210a)\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Data Structure with GraphQL in TypeScript\nDESCRIPTION: This snippet defines a GraphQL type structure for a transaction, outlining its fields and the necessary information returned when querying transaction details, revealing insights from transaction logs and metadata.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/README.md#2025-04-18_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\ntype Transaction {\n    blockTime: BigInt\n    data(encoding: TransactionEncoding!): String\n    message: TransactionMessage\n    meta: TransactionMeta\n    signatures: [Signature]\n    slot: Slot\n    version: String\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Git Commit in Markdown\nDESCRIPTION: This code snippet shows how to reference a Git commit hash in a Markdown changelog entry. It includes a link to the commit on GitHub.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Post-Offset in U32 Codec\nDESCRIPTION: Demonstrates how to adjust both pre and post offsets for more complex codec positioning.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst u32InTheMiddleCodec = offsetCodec(biggerU32Codec, {\n  preOffset: ({ preOffset }) => preOffset + 2,\n  postOffset: ({ postOffset }) => postOffset + 2,\n});\nu32InTheMiddleCodec.encode(0xffffffff);\n```\n\n----------------------------------------\n\nTITLE: Adding stackHeight to TransactionInstruction RPC Type\nDESCRIPTION: Extends the TransactionInstruction RPC type to include a `stackHeight` property, providing more detailed transaction instruction information\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-api/CHANGELOG.md#2025-04-18_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Decoding Address Bytes with getAddressDecoder() in TypeScript\nDESCRIPTION: Shows how to use getAddressDecoder() to convert a byte array representing a Solana address into its base58-encoded string representation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/addresses/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAddressDecoder } from '@solana/addresses';\n\nconst addressBytes = new Uint8Array([\n    150, 183, 190, 48, 171, 8, 39, 156, 122, 213, 172, 108, 193, 95, 26, 158, 149, 243, 115, 254, 20, 200, 36, 30, 248,\n    179, 178, 232, 220, 89, 53, 127,\n]);\nconst addressDecoder = getAddressDecoder();\nconst address = addressDecoder.decode(address); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n```\n\n----------------------------------------\n\nTITLE: Updating dependencies in Solana web3.js\nDESCRIPTION: This patch updates multiple dependencies of the `@solana/web3.js` package. The dependencies are updated to version 2.0.0.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Using CommonJS Package Type - Solana\nDESCRIPTION: The package type is now commonjs. This change helps to improve compatibility between different module systems. This ensures the `@solana/signers` package can be used seamlessly in a wider range of environments.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: N/A\nCODE:\n```\n``367b8ad`](https://github.com/solana-labs/solana-web3.js/commit/367b8ad0cce55a916abfb0125f36b6e844333b2b) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Use commonjs package type``\n```\n\n----------------------------------------\n\nTITLE: Transforming Channel Inbound Messages with JSON Parsing\nDESCRIPTION: This code snippet illustrates how to transform inbound messages of a channel using the `transformChannelInboundMessages` function to parse incoming JSON messages. It takes an existing channel and applies `JSON.parse` as the transformation function, creating a new channel with inbound messages of the parsed type. This is useful when receiving JSON-formatted data over the channel.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-spec/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst transformedChannel = transformChannelInboundMessages(channel, JSON.parse);\n```\n```\n\n----------------------------------------\n\nTITLE: Using RpcFromTransport Type in TypeScript\nDESCRIPTION: Example showing how to create a custom RPC interface with specific methods while preserving cluster type information. This ensures type safety when creating custom RPC implementations for different Solana clusters.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createCustomRpc<TRpcTransport extends RpcTransport>(\n    transport: TRpcTransport,\n): RpcFromTransport<MyCustomRpcMethods, TRpcTransport> {\n    /* ... */\n}\nconst transport = createDefaultRpcTransport({ url: mainnet('http://rpc.company') });\ntransport satisfies RpcTransportMainnet; // OK\nconst rpc = createCustomRpc(transport);\nrpc satisfies RpcMainnet<MyCustomRpcMethods>; // OK\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/keys/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: Command to install the second Technology Preview of @solana/web3.js using npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Switching to CommonJS package type\nDESCRIPTION: Changes the package type to CommonJS for improved compatibility.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nUse commonjs package type\n```\n\n----------------------------------------\n\nTITLE: Creating a Package for Subscribable Data Sources\nDESCRIPTION: This snippet illustrates the creation of a package that works with subscribable data sources like event targets. It facilitates the creation of a `DataPublisher` and an abortable `AsyncIterable`, improving the ergonomics of event handling.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/subscribable/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Creates a package for working with subscribable data sources like event targets.\n// From an EventTarget or object which conforms to the EventEmitter interface you can now create a more ergonomic DataPublisher (object with an on method that vends an unsubscribe function) or an abortable AsyncIterable.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 - Shell\nDESCRIPTION: This snippet provides the command to install the second Technology Preview of the Solana Web3.js library, which includes bug fixes and new features for developers working with Solana's on-chain programs.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-api/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Dropping Release Candidate label in Solana web3.js\nDESCRIPTION: This patch signifies the release of `@solana/web3.js` at version 2.0.0. It removes the Release Candidate label, indicating the final release of the version.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Installing Dependencies with PNPM\nDESCRIPTION: Installs project dependencies using PNPM with the --ignore-workspace flag to keep documentation dependencies separate from library dependencies.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/README.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install --ignore-workspace\n```\n\n----------------------------------------\n\nTITLE: Detecting Invalid Nonce Transaction in TypeScript\nDESCRIPTION: Illustrates how TypeScript identifies an invalid nonce transaction structure at compile time.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nconst feePayer = await generateKeyPair();\nconst feePayerAddress = await getAddressFromPublicKey(feePayer.publicKey);\n\nconst notNonceTransactionMessage = pipe(createTransactionMessage({ version: 0 }), tx =>\n    setTransactionMessageFeePayer(feePayerAddress, tx),\n);\n\nnotNonceTransactionMessage satisfies TransactionMessageWithDurableNonceLifetime;\n// => Property 'lifetimeConstraint' is missing in type\n\nconst nonceConfig = {\n    nonce: 'nonce' as Nonce,\n    nonceAccountAddress: address('5tLU66bxQ35so2bReGcyf3GfMMAAauZdNA1N4uRnKQu4'),\n    nonceAuthorityAddress: address('GDhj8paPg8woUzp9n8fj7eAMocN5P7Ej3A7T9F5gotTX'),\n};\n\nconst stillNotNonceTransactionMessage = {\n    lifetimeConstraint: nonceConfig,\n    ...notNonceTransactionMessage,\n};\n\nstillNotNonceTransactionMessage satisfies TransactionMessageWithDurableNonceLifetime;\n// => 'readonly IInstruction<string>[]' is not assignable to type 'readonly [AdvanceNonceAccountInstruction<string, string>, ...IInstruction<string>[]]'\n\nconst validNonceTransactionMessage = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(feePayerAddress, tx),\n    tx => setTransactionMessageLifetimeUsingDurableNonce(nonceConfig, tx), // Adds the instruction!\n);\n\nvalidNonceTransactionMessage satisfies TransactionMessageWithDurableNonceLifetime; // OK\n```\n\n----------------------------------------\n\nTITLE: Renaming Codec Functions in JavaScript\nDESCRIPTION: This snippet showcases renaming of codec functions to better convey their functionality, enhancing code clarity and maintainability.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-types/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Update in Codec Functionality\n// #2413\nRenamed `mapCodec` to `transformCodec`.\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// Update in Codec Functionality\n// #2411\nRenamed `fixCodec` to `fixCodecSize`.\n```\n\n----------------------------------------\n\nTITLE: Dependency Version Update in Package.json\nDESCRIPTION: Version update reference showing dependencies on @solana/codecs-core and @solana/errors packages being updated to version 2.1.0\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- @solana/codecs-core@2.1.0\n- @solana/errors@2.1.0\n```\n\n----------------------------------------\n\nTITLE: Fixing memory leak with transaction confirmation in Solana web3.js\nDESCRIPTION: This patch addresses a memory leak issue related to transaction confirmation and subscriptions within Solana web3.js. It improves resource management during transaction confirmation processes.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Enum Codec with Values as Discriminators in Typescript\nDESCRIPTION: This snippet shows how to use the `useValuesAsDiscriminators` option when creating an enum codec. This option encodes the actual enum value instead of its index, useful for enums with explicit values. It will throw an error if used on an enum with lexical values.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/errors/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n    enum Numbers {\n        One,\n        Five = 5,\n        Six,\n        Nine = 9,\n    }\n\n    const codec = getEnumCodec(Numbers, { useValuesAsDiscriminators: true });\n    codec.encode(Direction.One); // 0x00\n    codec.encode(Direction.Five); // 0x05\n    codec.encode(Direction.Six); // 0x06\n    codec.encode(Direction.Nine); // 0x09\n```\n\nLANGUAGE: typescript\nCODE:\n```\n    enum Lexical {\n        One,\n        Two = 'two',\n    }\n    getEnumCodec(Lexical, { useValuesAsDiscriminators: true }); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js\nDESCRIPTION: This snippet provides the command to install the Technology Preview 2 of the Solana Web3.js library using npm. Ensure you have npm installed to execute this command.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Using Separate Encoder and Decoder Functions in TypeScript\nDESCRIPTION: Demonstrates how to use separate encoder and decoder functions for more focused functionality and potential tree-shaking.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/README.md#2025-04-18_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst bytes = getU8Encoder().encode(42);\nconst value = getU8Decoder().decode(bytes);\n```\n\n----------------------------------------\n\nTITLE: Refactoring getStringCodec Function in TypeScript\nDESCRIPTION: The 'getStringCodec' function was modified to always return a VariableSizeCodec. New functions 'fixCodecSize' and 'addCodecSizePrefix' were introduced to replace previous functionality.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-strings/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\ngetStringCodec({ size: 'variable' }); // Variable.\ngetStringCodec({ encoding: getUtf8Codec(), size: 'variable' }); // Variable (equivalent).\ngetStringCodec({ size: 5 }); // Fixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: 5 }); // Fixed (equivalent).\ngetStringCodec(); // Prefixed.\ngetStringCodec({ encoding: getUtf8Codec(), size: getU32Codec() }); // Prefixed (equivalent).\n\n// After.\ngetUtf8Codec(); // Variable.\nfixCodecSize(getUtf8Codec(), 5); // Fixed.\naddCodecSizePrefix(getUtf8Codec(), getU32Codec()); // Prefixed.\n```\n\n----------------------------------------\n\nTITLE: Updating dependencies to rc.3 in Solana web3.js\nDESCRIPTION: This patch updates multiple dependencies of the `@solana/web3.js` package to release candidate 3. These updates synchronize the related Solana packages to the same pre-release version.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Defining Client type for Solana interactions\nDESCRIPTION: TypeScript code defining a Client type with RPC and RPC Subscriptions for Solana interactions.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/setup.mdx#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Rpc, RpcSubscriptions, SolanaRpcApi, SolanaRpcSubscriptionsApi } from \"@solana/kit\";\n\nexport type Client = {\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n};\n```\n\n----------------------------------------\n\nTITLE: Updating dependencies to rc.4 in Solana web3.js\nDESCRIPTION: This patch updates multiple dependencies of the `@solana/web3.js` package to release candidate 4.  These updates synchronize the related Solana packages to the same pre-release version.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-confirmation/CHANGELOG.md#2025-04-18_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Changing feePayer Type in Transaction Messages - JavaScript\nDESCRIPTION: This snippet updates the type of `feePayer` in transaction messages from `Address` to an object containing `address`. This change enhances the structure of transaction messages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/transaction-messages/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Change `feePayer` type of transaction messages from `Address` to `{ address: Address }`\n```\n\n----------------------------------------\n\nTITLE: Updating Endian enum capitalization in TypeScript\nDESCRIPTION: Changes the capitalization of the Endian enum variants from BIG and LITTLE to Big and Little for consistency with other enums in the library.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-numbers/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Before.\nEndian.BIG;\nEndian.LITTLE;\n\n// After.\nEndian.Big;\nEndian.Little;\n```\n\n----------------------------------------\n\nTITLE: Commit Reference Links\nDESCRIPTION: Git commit references with links to specific changes in the repository\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/instructions/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[`704d8a2`](https://github.com/anza-xyz/kit/commit/704d8a220592a5a472bd7726013814b50c991f5b)\n[`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d)\n[`c7b7dd9`](https://github.com/anza-xyz/kit/commit/c7b7dd99aca878d2450760c214dbea593ddbadc0)\n[`5af7f20`](https://github.com/anza-xyz/kit/commit/5af7f2013135a79893a0f190a905c6dd077ac38c)\n```\n\n----------------------------------------\n\nTITLE: Sharding RPC Transport Implementation\nDESCRIPTION: Implementation of a sharding transport pattern that routes requests to specific endpoints based on the RPC method name.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createDefaultRpcTransport, createSolanaRpcFromTransport, type RpcTransport } from '@solana/kit';\n\n// Create multiple transports.\nconst transportA = createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-1.com' });\nconst transportB = createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-2.com' });\nconst transportC = createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-3.com' });\nconst transportD = createDefaultRpcTransport({ url: 'https://mainnet-beta.my-server-4.com' });\n\n// Function to determine which shard to use based on the request method.\nfunction selectShard(method: string): RpcTransport {\n    switch (method) {\n        case 'getAccountInfo':\n        case 'getBalance':\n            return transportA;\n        case 'getLatestBlockhash':\n        case 'getTransaction':\n            return transportB;\n        case 'sendTransaction':\n            return transportC;\n        default:\n            return transportD;\n    }\n}\n\n// Create a transport that selects the correct transport given the request method name.\nasync function shardingTransport<TResponse>(...args: Parameters<RpcTransport>): Promise<TResponse> {\n    const payload = args[0].payload as { method: string };\n    const selectedTransport = selectShard(payload.method);\n    return (await selectedTransport(...args)) as TResponse;\n}\n\n// Create an RPC client using the sharding transport.\nconst rpc = createSolanaRpcFromTransport(shardingTransport);\n```\n\n----------------------------------------\n\nTITLE: Sending a Transaction without Confirmation using Factory Pattern\nDESCRIPTION: Shows how to use the sendTransactionWithoutConfirmingFactory helper function that provides a simplified way to send transactions without waiting for confirmation.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/getting-started/send-transaction.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sendTransactionWithoutConfirmingFactory } from \"@solana/kit\";\n\nconst sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\nawait sendTransaction(signedTransaction, { commitment: \"confirmed\" });\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry\nDESCRIPTION: Changelog entry showing version updates and dependency changes for the @solana/rpc-spec package, including commits and version bumps for related packages.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @solana/rpc-spec\n\n## 2.1.0\n\n### Patch Changes\n\n- Updated dependencies [[`1adf435`](https://github.com/anza-xyz/kit/commit/1adf435cfc724303f64e509a6fda144ec8f5019d), [`c7b7dd9`](https://github.com/anza-xyz/kit/commit/c7b7dd99aca878d2450760c214dbea593ddbadc0), [`5af7f20`](https://github.com/anza-xyz/kit/commit/5af7f2013135a79893a0f190a905c6dd077ac38c), [`704d8a2`](https://github.com/anza-xyz/kit/commit/704d8a220592a5a472bd7726013814b50c991f5b)]:\n    - @solana/errors@2.1.0\n    - @solana/rpc-spec-types@2.1.0\n\n## 2.0.0\n```\n\n----------------------------------------\n\nTITLE: Implementing Left-Padded Codec\nDESCRIPTION: Demonstrates how to add padding to the left of a codec using padLeftCodec.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst leftPaddedCodec = padLeftCodec(getU16Codec(), 4);\nleftPaddedCodec.encode(0xffff);\n```\n\n----------------------------------------\n\nTITLE: Constant Codec in TypeScript\nDESCRIPTION: Shows how to use `getConstantCodec` to create a codec that ensures specific byte sequences during encoding and decoding\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs-data-structures/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n\ncodec.encode(undefined); // 0x010203\ncodec.decode(new Uint8Array([1, 2, 3])); // undefined\ncodec.decode(new Uint8Array([1, 2, 4])); // Throws an error.\n```\n\n----------------------------------------\n\nTITLE: Version Control Links in Markdown\nDESCRIPTION: Git commit links and changelog entries for version 2.1.0 updates, including bug fixes for event targets and browser extension compatibility.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @solana/rpc-subscriptions\n\n## 2.1.0\n\n### Patch Changes\n\n- [`29d1e28`](https://github.com/anza-xyz/kit/commit/29d1e282f7ae53db008515980f13d54c40760065) Thanks [@steveluscher](https://github.com/steveluscher)! - Disabled the `MaxListenersExceededWarning` in Node when creating event targets for internal use\n\n- [`70eb596`](https://github.com/anza-xyz/kit/commit/70eb596bdff9d95d607a937615190a0d8111ad3c) Thanks [@steveluscher](https://github.com/steveluscher)! - The online/offline checker in the subscriptions implementation no longer throws an error when hosted in the Content Scripts environment of a browser extension\n```\n\n----------------------------------------\n\nTITLE: Custom Zero Value for Zeroable Nullable Codec in TypeScript\nDESCRIPTION: Example of using a custom zero value with getZeroableNullableCodec in TypeScript.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/options/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst codec = getZeroableNullableCodec(getU16Codec(), {\n    zeroValue: new Uint8Array([255, 255]),\n});\ncodec.encode(42); // 0x2a00\ncodec.encode(null); // 0xfffff\ncodec.encode(new Uint8Array([0, 0])); // 0\ncodec.decode(new Uint8Array([42, 0])); // 42\ncodec.decode(new Uint8Array([255, 255])); // null\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Subscriptions API Method in TypeScript\nDESCRIPTION: Example of how an RPC subscriptions method is defined using TypeScript types. This snippet shows a simple 'ExampleApi' type with a 'thingNotifications' method.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-subscriptions-api/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ExampleApi = {\n    thingNotifications(address: Address): Thing;\n};\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy Keypair to CryptoKeyPair using @solana/compat\nDESCRIPTION: Shows how to convert a legacy Keypair to a CryptoKeyPair using the @solana/compat library.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/README.md#2025-04-18_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fromLegacyKeypair } from '@solana/compat';\n\nconst keypairLegacy = Keypair.generate();\nconst cryptoKeyPair: CryptoKeyPair = fromLegacyKeypair(keypair);\n```\n\n----------------------------------------\n\nTITLE: Defining RpcRequest Type in TypeScript\nDESCRIPTION: Defines the RpcRequest type, which describes the elements of a RPC or RPC Subscriptions request. It includes methodName and params properties.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-spec-types/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RpcRequest = {\n  methodName: string;\n  params: any[];\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing padBytes Function\nDESCRIPTION: Shows how to pad a Uint8Array with zeros to a specified length.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/concepts/codecs.mdx#2025-04-18_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\npadBytes(new Uint8Array([1, 2]), 4); // Uint8Array([1, 2, 0, 0])\npadBytes(new Uint8Array([1, 2, 3, 4]), 2); // Uint8Array([1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: RPC Subscriptions Comparison - Web3.js vs Kit\nDESCRIPTION: Shows how to handle WebSocket subscriptions and event notifications in both Web3.js and Kit, highlighting Kit's use of AbortController for subscription management.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/docs/content/docs/upgrade-guide.mdx#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Connection, PublicKey } from \"@solana/web3.js\";\n\n// Create a `Connection` object with a WebSocket endpoint.\nconst connection = new Connection(\"https://api.devnet.solana.com\", {\n  wsEndpoint: \"wss://api.devnet.solana.com\",\n  commitment: \"confirmed\",\n});\n\n// Subscribe to RPC events and listen to notifications.\nconst wallet = new PublicKey(\"1234..5678\");\nconnection.onAccountChange(wallet, (accountInfo) => {\n  console.log(accountInfo);\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { address, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\n// Create an RPC subscriptions proxy object.\nconst rpcSubscriptions = createSolanaRpcSubscriptions(\"wss://api.devnet.solana.com\");\n\n// Use an `AbortController` to cancel the subscriptions.\nconst abortController = new AbortController();\n\n// Subscribe to RPC events.\nconst wallet = address(\"1234..5678\");\nconst accountNotifications = await rpcSubscriptions\n  .accountNotifications(wallet, { commitment: \"confirmed\" })\n  .subscribe({ abortSignal: abortController.signal });\n\ntry {\n  // Listen to event notifications.\n  for await (const accountInfo of accountNotifications) {\n    console.log(accountInfo);\n  }\n} catch (e) {\n  // Gracefully handle subscription disconnects.\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Fast Stable Stringify\nDESCRIPTION: Commands for running the unit tests for the fast-stable-stringify library in both browser and Node.js environments.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/fast-stable-stringify/README.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:unit:browser\nnpm run test:unit:node\n```\n\n----------------------------------------\n\nTITLE: Creating KeyPair Signer from Private Key Bytes - Solana\nDESCRIPTION: This patch introduces a helper function `createKeyPairSignerFromPrivateKeyBytes` that combines `createKeyPairFromPrivateKeyBytes` and `createSignerFromKeyPair`. This simplifies the process of creating a signer from raw private key bytes. It enhances convenience for developers working with private keys.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n``1ad523d`](https://github.com/solana-labs/solana-web3.js/commit/1ad523dc5792d9152a66e9dc2b83294e3eba4db0) Thanks [@lorisleiva](https://github.com/lorisleiva)! - Add a `createKeyPairSignerFromPrivateKeyBytes` helper that compose `createKeyPairFromPrivateKeyBytes` and `createSignerFromKeyPair`.``\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js 2.0 Technology Preview via npm\nDESCRIPTION: This snippet provides the command to install the second Technology Preview release of the Solana Web3.js library. It allows users to incorporate the latest features and fixes into their projects.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-graphql/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2\nDESCRIPTION: This command installs the second Technology Preview of the `@solana/web3.js` library using npm. The `--save` flag ensures that the package is added to the project's `package.json` file as a dependency.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/codecs/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing the Second Technology Preview of @solana/web3.js\nDESCRIPTION: This snippet provides the command to install the second Technology Preview version of @solana/web3.js, a JavaScript library for interacting with Solana blockchain programs. The command uses npm to save the specified package version.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/signers/CHANGELOG.md#2025-04-18_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview 2 - Shell\nDESCRIPTION: This snippet provides the shell command required to install the second Technology Preview version of @solana/web3.js. This version is intended to integrate with the new JavaScript client generator for on-chain programs. It allows for autogenerated instruction creators and account decoders for any program. Prior to running this command, ensure npm is installed on your system. The command requires internet access to fetch the library from npm.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/compat/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```\n\n----------------------------------------\n\nTITLE: Enabling Mainnet-Beta Access for Solana React App\nDESCRIPTION: Commands to enable Mainnet-Beta access by setting the required environment variable during development or build. This bypasses the CORS restrictions normally blocking access to this cluster.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/examples/react-app/README.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nREACT_EXAMPLE_APP_ENABLE_MAINNET=true pnpm dev\nREACT_EXAMPLE_APP_ENABLE_MAINNET=true pnpm build\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Web3.js Technology Preview\nDESCRIPTION: This shell command installs the second Technology Preview version of @solana/web3.js. It is required to access the latest updates and features introduced in this preview release. The installation should be executed in an environment with Node.js and npm configured.\nSOURCE: https://github.com/anza-xyz/kit/blob/main/packages/rpc-transformers/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nnpm install --save @solana/web3.js@tp2\n```"
  }
]