[
  {
    "owner": "spf13",
    "repo": "cobra",
    "content": "TITLE: Complete CLI Application Example using Cobra in Go\nDESCRIPTION: A comprehensive example showing how to create a CLI application with multiple nested commands, argument validation, and flag handling using the Cobra library.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_18\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  \"fmt\"\n  \"strings\"\n\n  \"github.com/spf13/cobra\"\n)\n\nfunc main() {\n  var echoTimes int\n\n  var cmdPrint = &cobra.Command{\n    Use:   \"print [string to print]\",\n    Short: \"Print anything to the screen\",\n    Long: `print is for printing anything back to the screen.\nFor many years people have printed back to the screen.`,\n    Args: cobra.MinimumNArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n      fmt.Println(\"Print: \" + strings.Join(args, \" \"))\n    },\n  }\n\n  var cmdEcho = &cobra.Command{\n    Use:   \"echo [string to echo]\",\n    Short: \"Echo anything to the screen\",\n    Long: `echo is for echoing anything back.\nEcho works a lot like print, except it has a child command.`,\n    Args: cobra.MinimumNArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n      fmt.Println(\"Echo: \" + strings.Join(args, \" \"))\n    },\n  }\n\n  var cmdTimes = &cobra.Command{\n    Use:   \"times [string to echo]\",\n    Short: \"Echo anything to the screen more times\",\n    Long: `echo things multiple times back to the user by providing\na count and a string.`,\n    Args: cobra.MinimumNArgs(1),\n    Run: func(cmd *cobra.Command, args []string) {\n      for i := 0; i < echoTimes; i++ {\n        fmt.Println(\"Echo: \" + strings.Join(args, \" \"))\n      }\n    },\n  }\n\n  cmdTimes.Flags().IntVarP(&echoTimes, \"times\", \"t\", 1, \"times to echo the input\")\n\n  var rootCmd = &cobra.Command{Use: \"app\"}\n  rootCmd.AddCommand(cmdPrint, cmdEcho)\n  cmdEcho.AddCommand(cmdTimes)\n  rootCmd.Execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Command with Flags and Viper (Go)\nDESCRIPTION: A more complete example of a `root.go` file. It defines the root command, imports necessary libraries (`fmt`, `os`, `cobra`, `viper`), declares package-level variables for flag binding, uses the `init` function to define persistent flags, bind flags to Viper, set default config values, add subcommands, and sets up Viper configuration loading via the `initConfig` function.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\nvar (\n\t// Used for flags.\n\tcfgFile     string\n\tuserLicense string\n\n\trootCmd = &cobra.Command{\n\t\tUse:   \"cobra-cli\",\n\t\tShort: \"A generator for Cobra based Applications\",\n\t\tLong: `Cobra is a CLI library for Go that empowers applications.\nThis application is a tool to generate the needed files\nto quickly create a Cobra application.`,\n\t}\n)\n\n// Execute executes the root command.\nfunc Execute() error {\n\treturn rootCmd.Execute()\n}\n\nfunc init() {\n\tcobra.OnInitialize(initConfig)\n\n\trootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobra.yaml)\")\n\trootCmd.PersistentFlags().StringP(\"author\", \"a\", \"YOUR NAME\", \"author name for copyright attribution\")\n\trootCmd.PersistentFlags().StringVarP(&userLicense, \"license\", \"l\", \"\", \"name of license for the project\")\n\trootCmd.PersistentFlags().Bool(\"viper\", true, \"use Viper for configuration\")\n\tviper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\"))\n\tviper.BindPFlag(\"useViper\", rootCmd.PersistentFlags().Lookup(\"viper\"))\n\tviper.SetDefault(\"author\", \"NAME HERE <EMAIL ADDRESS>\")\n\tviper.SetDefault(\"license\", \"apache\")\n\n\trootCmd.AddCommand(addCmd)\n\trootCmd.AddCommand(initCmd)\n}\n\nfunc initConfig() {\n\tif cfgFile != \"\" {\n\t\t// Use config file from the flag.\n\t\tviper.SetConfigFile(cfgFile)\n\t} else {\n\t\t// Find home directory.\n\t\thome, err := os.UserHomeDir()\n\t\tcobra.CheckErr(err)\n\n\t\t// Search config in home directory with name \".cobra\" (without extension).\n\t\tviper.AddConfigPath(home)\n\t\tvaiper.SetConfigType(\"yaml\")\n\t\tviper.SetConfigName(\".cobra\")\n\t}\n\n\tviper.AutomaticEnv()\n\n\tif err := viper.ReadInConfig(); err == nil {\n\t\tfmt.Println(\"Using config file:\", viper.ConfigFileUsed())\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Cobra Application (Go)\nDESCRIPTION: Shows the minimal structure of a `main.go` file in a Cobra application. Its sole purpose is to import the `cmd` package (which should contain the root command) and call the `cmd.Execute()` function to start the application and parse commands.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"{pathToYourApp}/cmd\"\n\nfunc main() {\n  cmd.Execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Subcommand (Go)\nDESCRIPTION: Shows how to define a new `cobra.Command` intended to be a subcommand. It includes the command's definition (`Use`, `Short`, `Long`, `Run`) and uses the `init()` function to add itself to its parent command (typically the `rootCmd`) using `AddCommand`.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage cmd\n\nimport (\n  \"fmt\"\n\n  \"github.com/spf13/cobra\"\n)\n\nfunc init() {\n  rootCmd.AddCommand(versionCmd)\n}\n\nvar versionCmd = &cobra.Command{\n  Use:   \"version\",\n  Short: \"Print the version number of Hugo\",\n  Long:  `All software has versions. This is Hugo's`,\n  Run: func(cmd *cobra.Command, args []string) {\n    fmt.Println(\"Hugo Static Site Generator v0.9 -- HEAD\")\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with RunE (Go)\nDESCRIPTION: Demonstrates how to use the `RunE` field of a `cobra.Command` instead of `Run`. `RunE` allows the command's execution function to return an error, which can then be caught and handled by the function that calls `Execute` (e.g., in `main.go`). This centralizes error handling.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage cmd\n\nimport (\n  \"fmt\"\n\n  \"github.com/spf13/cobra\"\n)\n\nfunc init() {\n  rootCmd.AddCommand(tryCmd)\n}\n\nvar tryCmd = &cobra.Command{\n  Use:   \"try\",\n  Short: \"Try and possibly fail at something\",\n  RunE: func(cmd *cobra.Command, args []string) error {\n    if err := someFunc(); err != nil {\n\treturn err\n    }\n    return nil\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables for Flags (Go)\nDESCRIPTION: Shows how to declare package-level variables that will be used to store the values parsed from command-line flags. These variables serve as the binding points for flag values defined using `BoolVarP`, `StringVarP`, etc.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nvar Verbose bool\nvar Source string\n```\n\n----------------------------------------\n\nTITLE: Defining Persistent Flag (Go)\nDESCRIPTION: Illustrates how to define a persistent flag (`verbose`) on a command using `PersistentFlags()`. Persistent flags are available not only to the command they are defined on but also to all of its subcommands. The flag is bound to the `Verbose` variable.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.PersistentFlags().BoolVarP(&Verbose, \"verbose\", \"v\", false, \"verbose output\")\n```\n\n----------------------------------------\n\nTITLE: Defining Local Flag (Go)\nDESCRIPTION: Demonstrates how to define a local flag (`source`) on a command using `Flags()`. Local flags are only available to the specific command they are defined on and are not inherited by subcommands. The flag is bound to the `Source` variable.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nlocalCmd.Flags().StringVarP(&Source, \"source\", \"s\", \"\", \"Source directory to read from\")\n```\n\n----------------------------------------\n\nTITLE: Marking Persistent Flag as Required (Go)\nDESCRIPTION: Demonstrates how to make a persistent flag (`region`) mandatory using `MarkPersistentFlagRequired`. Similar to local required flags, Cobra enforces the presence of this flag for the command and its subcommands.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.PersistentFlags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\")\nrootCmd.MarkPersistentFlagRequired(\"region\")\n```\n\n----------------------------------------\n\nTITLE: Requiring Exactly One Flag from a Group (Go)\nDESCRIPTION: Combines `MarkFlagsOneRequired` and `MarkFlagsMutuallyExclusive` on the same group of flags (`json`, `yaml`) to enforce that exactly one flag from the group must be provided. This ensures that the user specifies one, and only one, option from the defined set.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_15\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.Flags().BoolVar(&ofJson, \"json\", false, \"Output in JSON\")\nrootCmd.Flags().BoolVar(&ofYaml, \"yaml\", false, \"Output in YAML\")\nrootCmd.MarkFlagsOneRequired(\"json\", \"yaml\")\nrootCmd.MarkFlagsMutuallyExclusive(\"json\", \"yaml\")\n```\n\n----------------------------------------\n\nTITLE: Combining Argument Validators in Go using Cobra\nDESCRIPTION: Example of combining multiple validators using the MatchAll function to enforce both exact argument count and valid argument values in a Cobra command.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nvar cmd = &cobra.Command{\n  Short: \"hello\",\n  Args: cobra.MatchAll(cobra.ExactArgs(2), cobra.OnlyValidArgs),\n  Run: func(cmd *cobra.Command, args []string) {\n    fmt.Println(\"Hello, World!\")\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Argument Validation in Go using Cobra\nDESCRIPTION: Implementation of a custom validator function that combines Cobra's built-in validation with application-specific logic to validate command arguments.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nvar cmd = &cobra.Command{\n  Short: \"hello\",\n  Args: func(cmd *cobra.Command, args []string) error {\n    // Optionally run one of the validators provided by cobra\n    if err := cobra.MinimumNArgs(1)(cmd, args); err != nil {\n        return err\n    }\n    // Run the custom validation logic\n    if myapp.IsValidColor(args[0]) {\n      return nil\n    }\n    return fmt.Errorf(\"invalid color specified: %s\", args[0])\n  },\n  Run: func(cmd *cobra.Command, args []string) {\n    fmt.Println(\"Hello, World!\")\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Flag with Viper (Go)\nDESCRIPTION: Illustrates how to bind a Cobra flag (`author`) to a Viper configuration key (`\"author\"`) using `viper.BindPFlag`. This allows the flag's value to be read from Viper, enabling configuration layering where flags can override values from configuration files or environment variables. Note that this binds the Cobra flag *setting* to Viper, not necessarily updating the original Go variable.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nvar author string\n\nfunc init() {\n  rootCmd.PersistentFlags().StringVar(&author, \"author\", \"YOUR NAME\", \"Author name for copyright attribution\")\n  viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"author\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a custom completion command in Go using Cobra\nDESCRIPTION: A Go code snippet demonstrating how to create a custom completion command that generates completion scripts for bash, zsh, fish, and PowerShell shells. The command outputs the appropriate completion script to stdout based on the shell specified as an argument.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvar completionCmd = &cobra.Command{\n\tUse:   \"completion [bash|zsh|fish|powershell]\",\n\tShort: \"Generate completion script\",\n\tLong: fmt.Sprintf(`To load completions:\n\nBash:\n\n  $ source <(%[1]s completion bash)\n\n  # To load completions for each session, execute once:\n  # Linux:\n  $ %[1]s completion bash > /etc/bash_completion.d/%[1]s\n  # macOS:\n  $ %[1]s completion bash > $(brew --prefix)/etc/bash_completion.d/%[1]s\n\nZsh:\n\n  # If shell completion is not already enabled in your environment,\n  # you will need to enable it.  You can execute the following once:\n\n  $ echo \"autoload -U compinit; compinit\" >> ~/.zshrc\n\n  # To load completions for each session, execute once:\n  $ %[1]s completion zsh > \"${fpath[1]}/_%[1]s\"\n\n  # You will need to start a new shell for this setup to take effect.\n\nfish:\n\n  $ %[1]s completion fish | source\n\n  # To load completions for each session, execute once:\n  $ %[1]s completion fish > ~/.config/fish/completions/%[1]s.fish\n\nPowerShell:\n\n  PS> %[1]s completion powershell | Out-String | Invoke-Expression\n\n  # To load completions for every new session, run:\n  PS> %[1]s completion powershell > %[1]s.ps1\n  # and source this file from your PowerShell profile.\n`,cmd.Root().Name()),\n\tDisableFlagsInUseLine: true,\n\tValidArgs:             []string{\"bash\", \"zsh\", \"fish\", \"powershell\"},\n\tArgs:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tswitch args[0] {\n\t\tcase \"bash\":\n\t\t\tcmd.Root().GenBashCompletion(os.Stdout)\n\t\tcase \"zsh\":\n\t\t\tcmd.Root().GenZshCompletion(os.Stdout)\n\t\tcase \"fish\":\n\t\t\tcmd.Root().GenFishCompletion(os.Stdout, true)\n\t\tcase \"powershell\":\n\t\t\tcmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)\n\t\t}\n\t},\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing dynamic completion of command arguments in Cobra\nDESCRIPTION: Example using ValidArgsFunction to dynamically generate completion options at runtime. This example from Helm's status command shows how to return a list of current Helm releases when the user presses tab for completion.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ncmd := &cobra.Command{\n\tUse:   \"status RELEASE_NAME\",\n\tShort: \"Display the status of the named release\",\n\tLong:  status_long,\n\tRunE: func(cmd *cobra.Command, args []string) {\n\t\tRunGet(args[0])\n\t},\n\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\t\tif len(args) != 0 {\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn getReleasesFromCluster(toComplete), cobra.ShellCompDirectiveNoFileComp\n\t},\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing static completion of command arguments in Cobra\nDESCRIPTION: Example of using ValidArgs to define a static list of completion options for command arguments in Cobra. This snippet shows how to add valid arguments to the kubectl get command for shell tab completion.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvalidArgs = []string{ \"pod\", \"node\", \"service\", \"replicationcontroller\" }\n\ncmd := &cobra.Command{\n\tUse:     \"get [(-o|--output=)json|yaml|template|...] (RESOURCE [NAME] | RESOURCE/NAME ...)\",\n\tShort:   \"Display one or many resources\",\n\tLong:    get_long,\n\tExample: get_example,\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tcobra.CheckErr(RunGet(f, out, cmd, args))\n\t},\n\tValidArgs: validArgs,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Flag Completion in Go\nDESCRIPTION: Example of registering a function for dynamic flag completion that returns custom completion options.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\treturn []cobra.Completion{\"json\", \"table\", \"yaml\"}, cobra.ShellCompDirectiveDefault\n})\n```\n\n----------------------------------------\n\nTITLE: Limiting Flag Completions to Directories\nDESCRIPTION: Methods to restrict flag value completions to directory names using MarkFlagDirname or RegisterFlagCompletionFunc with ShellCompDirectiveFilterDirs.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.MarkFlagDirname(flagName)\n```\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\treturn nil, cobra.ShellCompDirectiveFilterDirs\n})\n```\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\treturn []cobra.Completion{\"themes\"}, cobra.ShellCompDirectiveFilterDirs\n})\n```\n\n----------------------------------------\n\nTITLE: Specifying Filename Extensions for Flag Completions\nDESCRIPTION: Two different approaches to limit flag completions to specific file extensions using either MarkFlagFilename or RegisterFlagCompletionFunc.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.MarkFlagFilename(flagName, \"yaml\", \"json\")\n```\n\nLANGUAGE: go\nCODE:\n```\nflagName := \"output\"\ncmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\treturn []cobra.Completion{\"yaml\", \"json\"}, cobra.ShellCompDirectiveFilterFileExt\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Descriptions to Completions\nDESCRIPTION: Examples of adding descriptive text to completions using ValidArgsFunction, ValidArgs, and CompletionWithDesc helper.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\treturn []cobra.Completion{\n\t\tcobra.CompletionWithDesc(\"harbor\", \"An image registry\"),\n\t\tcobra.CompletionWithDesc(\"thanos\", \"Long-term metrics\")\n\t\t}, cobra.ShellCompDirectiveNoFileComp\n}}\n```\n\nLANGUAGE: go\nCODE:\n```\nValidArgs: []cobra.Completion{\n\tcobra.CompletionWithDesc(\"bash\", \"Completions for bash\"),\n\tcobra.CompletionWithDesc(\"zsh\", \"Completions for zsh\")\n\t}\n```\n\n----------------------------------------\n\nTITLE: Adding aliases for command arguments in Cobra\nDESCRIPTION: Code showing how to add argument aliases in Cobra using the ArgAliases field. This allows users to use alternative names for arguments that will be shown in tab completion if no matches are found in commands or ValidArgs.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nargAliases = []string { \"pods\", \"nodes\", \"services\", \"svc\", \"replicationcontrollers\", \"rc\" }\n\ncmd := &cobra.Command{\n    ...\n\tValidArgs:  validArgs,\n\tArgAliases: argAliases\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Flags as Required for Completion\nDESCRIPTION: Code showing how to mark flags as required, which makes them appear in command completion suggestions.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ncmd.MarkFlagRequired(\"pod\")\ncmd.MarkFlagRequired(\"container\")\n```\n\n----------------------------------------\n\nTITLE: Creating a completion command using cobra-cli\nDESCRIPTION: Command to generate a completion command file using the cobra-cli generator tool, which can then be modified to implement custom completion behavior.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncobra-cli add completion\n```\n\n----------------------------------------\n\nTITLE: Adapting default completion command configuration in Cobra\nDESCRIPTION: Code examples showing how to configure options for the default completion command provided by Cobra, including disabling it, hiding it, and controlling description behavior for completions.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nrootCmd.CompletionOptions.DisableDefaultCmd = true\n```\n\nLANGUAGE: go\nCODE:\n```\nrootCmd.CompletionOptions.HiddenDefaultCmd = true\n```\n\nLANGUAGE: go\nCODE:\n```\nrootCmd.CompletionOptions.DisableNoDescFlag = true\n```\n\nLANGUAGE: go\nCODE:\n```\nrootCmd.CompletionOptions.DisableDescriptions = true\n```\n\n----------------------------------------\n\nTITLE: Generating Cobra Bash Completion Examples\nDESCRIPTION: Shows examples of Cobra CLI command completions using bash shell tab completions. The snippet highlights how default bash completions include or exclude descriptions depending on commands used. It notes that Cobra's default `completion` command utilizes bash completion V2 and that users can implement custom completion commands to use bash completion V1 if necessary. The snippet requires no additional dependencies aside from Bash shell and Cobra framework.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# Without descriptions\n$ helm s[tab][tab]\nsearch  show  status\n```\n\n----------------------------------------\n\nTITLE: Generating Cobra Zsh Completion Scripts with Optional Descriptions\nDESCRIPTION: Explains how Cobra supports native zsh completion generated directly from the root `cobra.Command` with automatic usage-based descriptions. Completion scripts should be placed in the user's `$fpath` directory and named using the pattern `_<yourProgram>`. Users need to restart their zsh shell for changes to take effect. The API allows disabling descriptions completely with `GenZshCompletionNoDesc()` or `GenZshCompletionFileNoDesc()`. Limitations include ignoring legacy bash script completions and certain flag APIs. The snippet contains example completion outputs with and without descriptions.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_15\n\nLANGUAGE: zsh\nCODE:\n```\n# With descriptions\n$ helm s[tab]\nsearch  -- search for a keyword in charts\nshow    -- show information of a chart\nstatus  -- displays the status of the named release\n\n# Without descriptions\n$ helm s[tab]\nsearch  show  status\n```\n\n----------------------------------------\n\nTITLE: Generating Cobra PowerShell Completions with Multiple Modes and Descriptions\nDESCRIPTION: Details Cobra's native PowerShell completion support through `command.GenPowerShellCompletion()` and variants that include descriptions. The script supports three PowerShell completion modes: TabCompleteNext (default), Complete (bash-like), and MenuComplete (zsh-like). Users configure the mode with `Set-PSReadLineKeyHandler`. Descriptions appear only in Complete or MenuComplete modes. Example outputs show completions with descriptions, without descriptions, and with MenuComplete displaying description below selections. It also describes configuring aliases with argument completers. Required prerequisites include PowerShell version 5.0 or newer.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_17\n\nLANGUAGE: powershell\nCODE:\n```\n# With descriptions and Mode 'Complete'\n$ helm s[tab]\nsearch  (search for a keyword in charts)  show  (show information of a chart)  status  (displays the status of the named release)\n\n# With descriptions and Mode 'MenuComplete' The description of the current selected value will be displayed below the suggestions.\n$ helm s[tab]\nsearch    show     status\n\nsearch for a keyword in charts\n\n# Without descriptions\n$ helm s[tab]\nsearch  show  status\n```\n\nLANGUAGE: powershell\nCODE:\n```\n$ sal aliasname origcommand\n$ Register-ArgumentCompleter -CommandName 'aliasname' -ScriptBlock $__origcommandCompleterBlock\n\n# and now when you run `aliasname` completion will make\n# suggestions as it did for `origcommand`.\n\n$ aliasname <tab>\ncompletion     firstcommand   secondcommand\n```\n\n----------------------------------------\n\nTITLE: Debugging Command Completions with Bash\nDESCRIPTION: Examples showing how to directly call the hidden __complete command to debug Go completion code, with examples for both populated and empty completion strings.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ helm __complete status har<ENTER>\nharbor\n:4\nCompletion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ helm __complete status \"\"<ENTER>\nharbor\nnotary\nrook\nthanos\n:4\nCompletion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr\n```\n\n----------------------------------------\n\nTITLE: Using Debugging Functions in Go Completion Code\nDESCRIPTION: Go functions provided by Cobra for debugging completion code, allowing safe printing without interfering with completion output.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Prints to the completion script debug file (if BASH_COMP_DEBUG_FILE\n// is set to a file path) and optionally prints to stderr.\ncobra.CompDebug(msg string, printToStdErr bool)\ncobra.CompDebugln(msg string, printToStdErr bool)\n\n// Prints to the completion script debug file (if BASH_COMP_DEBUG_FILE\n// is set to a file path) and to stderr.\ncobra.CompError(msg string)\ncobra.CompErrorln(msg string)\n```\n\n----------------------------------------\n\nTITLE: Debugging Flag Completion in Bash\nDESCRIPTION: Example of testing flag completion by directly calling the __complete command with a flag and empty completion string.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ helm __complete status --output \"\"\njson\ntable\nyaml\n:4\nCompletion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr\n```\n\n----------------------------------------\n\nTITLE: Implementing Active Help for Command Arguments in Go\nDESCRIPTION: Example of implementing Active Help messages in a command's ValidArgsFunction for providing hints when users are completing command arguments.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/active_help.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ncmd := &cobra.Command{\n\tUse:   \"add [NAME] [URL]\",\n\tShort: \"add a chart repository\",\n\tArgs:  require.ExactArgs(2),\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\treturn addRepo(args)\n\t},\n\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\t\tvar comps []cobra.Completion\n\t\tif len(args) == 0 {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"You must choose a name for the repo you are adding\")\n\t\t} else if len(args) == 1 {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"You must specify the URL for the repo you are adding\")\n\t\t} else {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"This command does not take any more arguments\")\n\t\t}\n\t\treturn comps, cobra.ShellCompDirectiveNoFileComp\n\t},\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Active Help for Command Flags in Go\nDESCRIPTION: Example demonstrating how to implement Active Help messages for flag completion functions to guide users when completing flag values.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/active_help.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n_ = cmd.RegisterFlagCompletionFunc(\"version\", func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\t\tif len(args) != 2 {\n\t\t\treturn cobra.AppendActiveHelp(nil, \"You must first specify the chart to install before the --version flag can be completed\"), cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn compVersionFlag(args[1], toComplete)\n\t})\n```\n\n----------------------------------------\n\nTITLE: Configuring Active Help Based on User Preferences in Go\nDESCRIPTION: Example of implementing configurable Active Help that can be turned on/off or set to different levels based on environment variables.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/active_help.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]cobra.Completion, cobra.ShellCompDirective) {\n\tactiveHelpLevel := cobra.GetActiveHelpConfig(cmd)\n\n\tvar comps []cobra.Completion\n\tif len(args) == 0 {\n\t\tif activeHelpLevel != \"off\"  {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"You must choose a name for the repo you are adding\")\n\t\t}\n\t} else if len(args) == 1 {\n\t\tif activeHelpLevel != \"off\" {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"You must specify the URL for the repo you are adding\")\n\t\t}\n\t} else {\n\t\tif activeHelpLevel == \"local\" {\n\t\t\tcomps = cobra.AppendActiveHelp(comps, \"This command does not take any more arguments\")\n\t\t}\n\t}\n\treturn comps, cobra.ShellCompDirectiveNoFileComp\n},\n```\n\n----------------------------------------\n\nTITLE: Annotating a Flag for Custom Bash Completion in Cobra - Go\nDESCRIPTION: This Go snippet demonstrates how to annotate a pflag.Flag so that Cobra generates a call to a custom bash completion function (__kubectl_get_namespaces) for the --namespace flag. The annotation informs Cobra's completion script generation that this flag has a special handler. Dependencies include the pflag package and a correctly initialized command. The annotation must be set on the flag before adding it to the command; ensure that the named completion function is defined in the BashCompletionFunction string.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/bash.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n\tannotation := make(map[string][]string)\n\tannotation[cobra.BashCompCustom] = []string{\"__kubectl_get_namespaces\"}\n\n\tflag := &pflag.Flag{\n\t\tName:        \"namespace\",\n\t\tUsage:       usage,\n\t\tAnnotations: annotation,\n\t}\n\tcmd.Flags().AddFlag(flag)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Legacy Dynamic Completion Functions for kubectl - Bash\nDESCRIPTION: This Bash snippet defines multiple functions for use in legacy dynamic completion with Cobra, including __kubectl_parse_get (to fetch and parse kubectl resources), __kubectl_get_resource (to extract nouns and invoke parsing), and __kubectl_custom_func (a dispatcher based on the subcommand context). These functions are designed to be injected as a string into the Cobra BashCompletionFunction property, allowing them to be invoked during tab completion. Requires kubectl and awk on PATH, and expects a compatible bash environment; functions rely on the surrounding Cobra integration to provide necessary context variables such as $cur, $last_command, and $nouns.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/bash.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nconst (\n        bash_completion_func = `__kubectl_parse_get()\n{\n    local kubectl_output out\n    if kubectl_output=$(kubectl get --no-headers \"$1\" 2>/dev/null); then\n        out=($(echo \"${kubectl_output}\" | awk '{print $1}'))\n        COMPREPLY=( $( compgen -W \"${out[*]}\" -- \"$cur\" ) )\n    fi\n}\n\n__kubectl_get_resource()\n{\n    if [[ ${#nouns[@]} -eq 0 ]]; then\n        return 1\n    fi\n    __kubectl_parse_get ${nouns[${#nouns[@]} -1]}\n    if [[ $? -eq 0 ]]; then\n        return 0\n    fi\n}\n\n__kubectl_custom_func() {\n    case ${last_command} in\n        kubectl_get | kubectl_describe | kubectl_delete | kubectl_stop)\n            __kubectl_get_resource\n            return\n            ;;\n        *)\n            ;;\n    esac\n}\n`)\n\n```\n\n----------------------------------------\n\nTITLE: Assigning BashCompletionFunction in Cobra Command Definition - Go\nDESCRIPTION: This Go snippet shows how to assign the previously defined bash_completion_func to the BashCompletionFunction field of a Cobra Command struct representing kubectl. The BashCompletionFunction injects custom bash code into the generated completion script for the root command, enabling advanced and dynamic completions not covered by static argument definitions. Dependencies include the spf13/cobra package, and the command structure expects runHelp as the main execution function; BashCompletionFunction should be set only on the root command for best effect.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/bash.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ncmds := &cobra.Command{\n\tUse:   \"kubectl\",\n\tShort: \"kubectl controls the Kubernetes cluster manager\",\n\tLong: `kubectl controls the Kubernetes cluster manager.\n\nFind more information at https://github.com/GoogleCloudPlatform/kubernetes.`,\n\tRun: runHelp,\n\tBashCompletionFunction: bash_completion_func,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Namespace Completion Function for kubectl - Bash\nDESCRIPTION: This Bash function returns available namespaces by calling kubectl with a template output and populates the COMPREPLY variable used in bash completion. The function should be included in the BashCompletionFunction string assigned to the Cobra command's root. It expects the $cur variable to be set by the completion context, and requires kubectl and appropriate Kubernetes permissions. The output is used for tab completion of flag values, especially for the --namespace flag annotated in Cobra.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/bash.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n__kubectl_get_namespaces()\n{\n    local template\n    template=\"{{ range .items  }}{{ .metadata.name }} {{ end }}\"\n    local kubectl_out\n    if kubectl_out=$(kubectl get -o template --template=\"${template}\" namespace 2>/dev/null); then\n        COMPREPLY=( $( compgen -W \"${kubectl_out}[*]\" -- \"$cur\" ) )\n    fi\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Markdown Tree for Entire Cobra Command Tree in Go\nDESCRIPTION: This example shows how to generate documentation for every subcommand in a command tree, such as kubectl from Kubernetes, using doc.GenMarkdownTree. It builds the command tree via cmd.NewKubectlCommand and outputs one .md file per command in the specified directory. Dependencies include k8s.io/kubernetes/pkg/kubectl/cmd, k8s.io/kubernetes/pkg/kubectl/cmd/util, and github.com/spf13/cobra/doc. Key parameters are the root command and output directory. The approach logs fatal errors on failure.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"io\"\n\t\"os\"\n\n\t\"k8s.io/kubernetes/pkg/kubectl/cmd\"\n\tcmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\"\n\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tkubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, io.Discard, io.Discard)\n\terr := doc.GenMarkdownTree(kubectl, \"./\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating YAML Documentation for a Full Command Tree (kubectl) in Go\nDESCRIPTION: This snippet illustrates generating YAML documentation for an entire command tree, specifically the kubectl CLI, using the GenYamlTree function. It initializes kubectl commands with necessary factories, redirects input/output streams appropriately, and generates separate YAML files for each command under the specified directory. Dependencies include kubernetes kubectl packages alongside cobra/doc. The output contains a series of YAML files representing the complete command hierarchy. Errors during generation are logged and terminate execution.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\n\t\"k8s.io/kubernetes/pkg/kubectl/cmd\"\n\tcmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\"\n\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tkubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, io.Discard, io.Discard)\n\terr := doc.GenYamlTree(kubectl, \"./\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating YAML Documentation for a Single Cobra Command in Go\nDESCRIPTION: This snippet shows how to create a YAML documentation file for a single cobra.Command instance by using the GenYamlTree function from the cobra/doc package. It defines a simple cobra command and generates a YAML file in the specified directory. Dependencies include the cobra and cobra/doc packages. The output is a YAML file representing the command's metadata and usage. Error handling is demonstrated for file generation issues.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tcmd := &cobra.Command{\n\t\tUse:   \"test\",\n\t\tShort: \"my test program\",\n\t}\n\terr := doc.GenYamlTree(cmd, \"/tmp\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating ReST Documentation with Cobra in Go\nDESCRIPTION: This code initializes a basic Cobra command named \"test\" and generates ReStructuredText documentation for it using doc.GenReSTTree, saving the resulting file to the /tmp directory. Dependencies include the github.com/spf13/cobra and github.com/spf13/cobra/doc packages. Provide a *cobra.Command instance to GenReSTTree along with a target directory; output is a .rst file for the command. The process logs errors via log.Fatal, terminating execution on failure.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tcmd := &cobra.Command{\n\t\tUse:   \"test\",\n\t\tShort: \"my test program\",\n\t}\n\terr := doc.GenReSTTree(cmd, \"/tmp\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Man Pages for cobra.Command in Go\nDESCRIPTION: This snippet shows how to generate man pages for a CLI command defined with the spf13/cobra package in Go. It imports the cobra and cobra/doc packages, creates a basic command with usage and short description, specifies man page header metadata like title and section, and calls doc.GenManTree to generate man page files in the /tmp directory. The code checks for errors returned and logs fatally upon failure. Dependencies include the cobra and cobra/doc libraries. The snippet outputs man page files (e.g., /tmp/test.3) based on the command metadata. There are no special limitations beyond providing write access to the output directory.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/man.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tcmd := &cobra.Command{\n\t\tUse:   \"test\",\n\t\tShort: \"my test program\",\n\t}\n\theader := &doc.GenManHeader{\n\t\tTitle: \"MINE\",\n\t\tSection: \"3\",\n\t}\n\terr := doc.GenManTree(cmd, header, \"/tmp\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example Front Matter Prepending Callback for Hugo in Go YAML Docs Generation\nDESCRIPTION: This example shows how to define a filePrepender callback function that adds Hugo-compatible front matter metadata to YAML files generated by cobra commands. The callback constructs a YAML front matter block containing date, title, slug, and URL fields based on the filename. It uses standard Go packages like time, filepath, strings, path, and fmt to dynamically generate values. This can be passed to GenYamlTreeCustom to produce documentation files ready for static site generators.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nconst fmTemplate = `---\ndate: %s\ntitle: \"%s\"\nslug: %s\nurl: %s\n---\n`\n\nfilePrepender := func(filename string) string {\n\tnow := time.Now().Format(time.RFC3339)\n\tname := filepath.Base(filename)\n\tbase := strings.TrimSuffix(name, path.Ext(name))\n\turl := \"/commands/\" + strings.ToLower(base) + \"/\"\n\treturn fmt.Sprintf(fmTemplate, now, strings.Replace(base, \"_\", \" \", -1), base, url)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating ReST for Single Command with Cobra in Go\nDESCRIPTION: This code generates ReST documentation for a single cobra.Command, writing directly into a bytes.Buffer using doc.GenReST. The buffer allows further programmatic processing instead of writing to disk. Requires github.com/spf13/cobra/doc and a prepared cobra.Command instance. Errors halt execution using log.Fatal. Designed for granular output and custom handling rather than tree-wide generation.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n\tout := new(bytes.Buffer)\n\terr := doc.GenReST(cmd, out)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing filePrepender Callback for ReST Docs in Go\nDESCRIPTION: This snippet defines a filePrepender function for use with GenReSTTreeCustom, prepending front-matter metadata for static site generators such as Hugo. It provides date, title, slug, and URL fields to be injected at the top of each output file. Requires standard library packages (time, filepath, strings, path, fmt). File and command names are processed for formatting and metadata replacement. The fmTemplate is a Go raw string containing Hugo-compatible front-matter.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nconst fmTemplate = `---\ndate: %s\ntitle: \"%s\"\nslug: %s\nurl: %s\n---\n`\nfilePrepender := func(filename string) string {\n\tnow := time.Now().Format(time.RFC3339)\n\tname := filepath.Base(filename)\n\tbase := strings.TrimSuffix(name, path.Ext(name))\n\turl := \"/commands/\" + strings.ToLower(base) + \"/\"\n\treturn fmt.Sprintf(fmTemplate, now, strings.Replace(base, \"_\", \" \", -1), base, url)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing ReST Output with GenReSTCustom in Go\nDESCRIPTION: This function defines the GenReSTCustom signature for generating single-command ReST with a custom linkHandler, allowing control of cross-reference formats in output. Accepts a *Command, output writer (bytes.Buffer), and a custom link handler function. Intended for programmatic documentation output where links require format overrides. Dependencies match doc.GenReSTCustom usage.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc GenReSTCustom(cmd *Command, out *bytes.Buffer, linkHandler func(string, string) string) error {\n\t//...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Link Formatting for Sphinx with linkHandler in Go\nDESCRIPTION: This Go snippet implements a linkHandler callback to customize cross-reference links for generated ReST documentation, outputting them in Sphinx's :ref: format. Designed for use with GenReSTTreeCustom or GenReSTCustom, the handler receives name and ref arguments and returns a formatted string. Useful for generating ReST docs intended for use with Sphinx and other tools that utilize specific reference formats.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\n// Sphinx cross-referencing format\nlinkHandler := func(name, ref string) string {\n    return fmt.Sprintf(\":ref:`%s <%s>`\", name, ref)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Internal Link Rendering with linkHandler Callback in Go\nDESCRIPTION: This example implements a linkHandler function that customizes how internal command links are rendered in Markdown by transforming filenames into site-relative URLs. This callback is especially useful when Markdown is integrated into static site generators. Required dependencies are the path and strings standard libraries. The parameter is a command's filename. Output is a string representing the desired link path.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nlinkHandler := func(name string) string {\n\tbase := strings.TrimSuffix(name, path.Ext(name))\n\treturn \"/commands/\" + strings.ToLower(base) + \"/\"\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Markdown Output for Cobra Commands in Go\nDESCRIPTION: These function signatures enable advanced users to customize Markdown generation using callbacks in doc.GenMarkdownTreeCustom and doc.GenMarkdownCustom. Callbacks allow direct control over file prepending (such as adding front matter) and link formatting. Dependencies are github.com/spf13/cobra/doc and the Command object. Key parameters include the command tree, output directory or buffer, and user-defined callback functions. The output may be tuned for different site generators like Hugo.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc GenMarkdownTreeCustom(cmd *Command, dir string, filePrepender, linkHandler func(string) string) error {\n\t//...\n}\n```\n\nLANGUAGE: Go\nCODE:\n```\nfunc GenMarkdownCustom(cmd *Command, out *bytes.Buffer, linkHandler func(string) string) error {\n\t//...\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing YAML Documentation Generation Callbacks in Go for Cobra Commands\nDESCRIPTION: This snippet outlines the function signatures for custom YAML documentation generation functions in cobra. GenYamlTreeCustom allows callers to specify callbacks for prepending content to the generated YAML files and for handling internal command links. GenYamlCustom similarly supports a link handler callback for customizing links in a single YAML output buffer. These functions provide hooks to insert custom front matter (e.g., for Hugo static site generator) or modify internal references dynamically. The primary dependencies are the cobra.Command definition and the callbacks must return strings that influence the resulting YAML content.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc GenYamlTreeCustom(cmd *Command, dir string, filePrepender, linkHandler func(string) string) error {\n\t//...\n}\n\nfunc GenYamlCustom(cmd *Command, out *bytes.Buffer, linkHandler func(string) string) error {\n\t//...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Markdown Tree from a Cobra Command in Go\nDESCRIPTION: This snippet demonstrates how to use the doc.GenMarkdownTree function from the spf13/cobra/doc package to generate a Markdown document for a single cobra.Command object. The snippet sets up a simple command, then writes documentation for it into the /tmp directory. Required dependencies include the github.com/spf13/cobra and github.com/spf13/cobra/doc packages. The main parameter is the command object, and output is a .md file in the given directory. The function will log and terminate on error.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tcmd := &cobra.Command{\n\t\tUse:   \"test\",\n\t\tShort: \"my test program\",\n\t}\n\terr := doc.GenMarkdownTree(cmd, \"/tmp\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing ReST Output with GenReSTTreeCustom in Go\nDESCRIPTION: This function signature demonstrates the use of doc.GenReSTTreeCustom, which enables customization of output by accepting filePrepender and linkHandler callback parameters. filePrepender allows custom pre-content (such as front-matter) for every file, and linkHandler customizes link formatting for command references. Requires a *Command instance, output directory, and two function callbacks. Designed for advanced documentation workflows such as static site generation.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc GenReSTTreeCustom(cmd *Command, dir string, filePrepender func(string) string, linkHandler func(string, string) string) error {\n\t//...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Help Command Output in Cobra CLI\nDESCRIPTION: Example of the automatically generated help output for a Cobra CLI application, showing command structure, available subcommands, and flag options.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_19\n\nLANGUAGE: console\nCODE:\n```\n$ cobra-cli help\n\nCobra is a CLI library for Go that empowers applications.\nThis application is a tool to generate the needed files\nto quickly create a Cobra application.\n\nUsage:\n  cobra-cli [command]\n\nAvailable Commands:\n  add         Add a command to a Cobra Application\n  completion  Generate the autocompletion script for the specified shell\n  help        Help about any command\n  init        Initialize a Cobra Application\n\nFlags:\n  -a, --author string    author name for copyright attribution (default \"YOUR NAME\")\n      --config string    config file (default is $HOME/.cobra.yaml)\n  -h, --help             help for cobra-cli\n  -l, --license string   name of license for the project\n      --viper            use Viper for configuration\n\nUse \"cobra-cli [command] --help\" for more information about a command.\n```\n\n----------------------------------------\n\nTITLE: Generating ReST Docs for Entire Cobra Command Tree in Go\nDESCRIPTION: This snippet shows generating ReStructuredText documentation for an entire CLI command tree, specifically for the kubectl command from the Kubernetes project. It instantiates the root command, then generates .rst files for all commands using doc.GenReSTTree and outputs them to the current directory. Dependencies include k8s.io/kubernetes/pkg/kubectl/cmd, cmdutil, and github.com/spf13/cobra/doc. Errors are logged and halt execution. All subcommands are recursively documented.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/rest.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"io\"\n\t\"os\"\n\n\t\"k8s.io/kubernetes/pkg/kubectl/cmd\"\n\tcmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\"\n\n\t\"github.com/spf13/cobra/doc\"\n)\n\nfunc main() {\n\tkubectl := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, io.Discard, io.Discard)\n\terr := doc.GenReSTTree(kubectl, \"./\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Front Matter with filePrepender Callback for Hugo in Go\nDESCRIPTION: This snippet shows how to define a filePrepender function to inject front matter into Hugo documentation, using data such as the current date, title, and slug. It outputs a string formatted with template values, designed to be used as a callback in doc.GenMarkdownTreeCustom. Dependencies include standard library packages time, filepath, strings, path, and fmt. Main parameters are file path strings. The output is prepended to each generated Markdown file.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nconst fmTemplate = `---\ndate: %s\ntitle: \"%s\"\nslug: %s\nurl: %s\n---\n`\n\nfilePrepender := func(filename string) string {\n\tnow := time.Now().Format(time.RFC3339)\n\tname := filepath.Base(filename)\n\tbase := strings.TrimSuffix(name, path.Ext(name))\n\turl := \"/commands/\" + strings.ToLower(base) + \"/\"\n\treturn fmt.Sprintf(fmTemplate, now, strings.Replace(base, \"_\", \" \", -1), base, url)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating YAML Documentation for a Single Command Output Buffer in Go\nDESCRIPTION: This snippet demonstrates generating YAML documentation for a single cobra.Command and writing the output to an in-memory buffer rather than a file system location. It invokes GenYaml with the command and a bytes.Buffer instance to capture the YAML output. This approach is useful for further processing or customization of the YAML content before saving or displaying. Required dependencies include the bytes package and cobra/doc. No error handling is shown here since GenYaml returns an error that can be handled as needed.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n\tout := new(bytes.Buffer)\ndoc.GenYaml(cmd, out)\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal Root Command (Go)\nDESCRIPTION: Defines a basic `cobra.Command` intended to serve as the root command of the application. It includes essential fields like `Use`, `Short`, `Long`, and a `Run` function for execution logic. The `Execute` function wraps the root command's execution, providing basic error printing.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nvar rootCmd = &cobra.Command{\n  Use:   \"hugo\",\n  Short: \"Hugo is a very fast static site generator\",\n  Long: `A Fast and Flexible Static Site Generator built with\n                love by spf13 and friends in Go.\n                Complete documentation is available at https://gohugo.io/documentation/`,\n  Run: func(cmd *cobra.Command, args []string) {\n    // Do Stuff Here\n  },\n}\n\nfunc Execute() {\n  if err := rootCmd.Execute(); err != nil {\n    fmt.Fprintln(os.Stderr, err)\n    os.Exit(1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Markdown for a Single Cobra Command in Go\nDESCRIPTION: This code writes Markdown documentation for a single Command object into an in-memory buffer, using doc.GenMarkdown. It is useful when you need granular control or documentation for only a specific command. Dependencies include github.com/spf13/cobra/doc and the Command object. The main parameters are the Command to document and an output buffer. The resulting Markdown is available in the buffer. Errors are handled via log.Fatal.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/md.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n\tout := new(bytes.Buffer)\n\terr := doc.GenMarkdown(cmd, out)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Marking Local Flag as Required (Go)\nDESCRIPTION: Shows how to make a local flag (`region`) mandatory using `MarkFlagRequired`. If the user fails to provide a value for this flag when running the command, Cobra will automatically print a usage error and exit.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.Flags().StringVarP(&Region, \"region\", \"r\", \"\", \"AWS region (required)\")\nrootCmd.MarkFlagRequired(\"region\")\n```\n\n----------------------------------------\n\nTITLE: Marking Flags Mutually Exclusive (Go)\nDESCRIPTION: Illustrates how to use `MarkFlagsMutuallyExclusive` to define a group of flags (`json`, `yaml`) where only one flag from the group can be provided at a time. If multiple flags from the group are used, Cobra will report an error.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.Flags().BoolVar(&ofJson, \"json\", false, \"Output in JSON\")\nrootCmd.Flags().BoolVar(&ofYaml, \"yaml\", false, \"Output in YAML\")\nrootCmd.MarkFlagsMutuallyExclusive(\"json\", \"yaml\")\n```\n\n----------------------------------------\n\nTITLE: Example Link Handler Callback Customizing Internal Links in Go YAML Docs Generation\nDESCRIPTION: This snippet defines a linkHandler callback function that customizes the internal links in generated YAML documentation files by converting filenames to lowercase URLs prefixed with \"/commands/\". This callback can be used with GenYamlCustom or GenYamlTreeCustom to control how links to other command docs are rendered in the YAML output. It depends on standard Go string manipulation and path extensions.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/docgen/yaml.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nlinkHandler := func(name string) string {\n\tbase := strings.TrimSuffix(name, path.Ext(name))\n\treturn \"/commands/\" + strings.ToLower(base) + \"/\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Cobra Fish Shell Completions with Optional Descriptions\nDESCRIPTION: Demonstrates Cobra's functionality to generate native completions for the fish shell via `command.GenFishCompletion()` or `command.GenFishCompletionFile()`. Users decide whether to include usage descriptions which Cobra auto-populates. Example completion outputs reflect descriptive and non-descriptive modes. Notes explain incompatibilities with legacy bash-scripted completions and certain unsupported flag annotations and completion directives in fish. The snippet aids users in configuring fish shell completions consistent with Cobra usage.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/completions/_index.md#_snippet_16\n\nLANGUAGE: fish\nCODE:\n```\n# With descriptions\n$ helm s[tab]\nsearch  (search for a keyword in charts)  show  (show information of a chart)  status  (displays the status of the named release)\n\n# Without descriptions\n$ helm s[tab]\nsearch  show  status\n```\n\n----------------------------------------\n\nTITLE: Requiring Flags Together (Go)\nDESCRIPTION: Shows how to group flags that must be provided together using `MarkFlagsRequiredTogether`. If any flag within the specified group (`username`, `password`) is present on the command line, all flags in that group must also be present; otherwise, Cobra reports an error.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\nrootCmd.Flags().StringVarP(&u, \"username\", \"u\", \"\", \"Username (required if password is set)\")\nrootCmd.Flags().StringVarP(&pw, \"password\", \"p\", \"\", \"Password (required if username is set)\")\nrootCmd.MarkFlagsRequiredTogether(\"username\", \"password\")\n```\n\n----------------------------------------\n\nTITLE: Enabling Parent Local Flag Parsing (Go)\nDESCRIPTION: Shows how to enable `TraverseChildren` on a command. Setting this to `true` instructs Cobra to parse local flags defined on parent commands before executing the target command, allowing for hierarchical flag usage.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\ncommand := cobra.Command{\n  Use: \"print [OPTIONS] [COMMANDS]\",\n  TraverseChildren: true,\n}\n```\n\n----------------------------------------\n\nTITLE: Cobra Project Structure (Console)\nDESCRIPTION: Illustrates the recommended directory layout for a Cobra-based application, showing where the main application file (`main.go`) and command definitions (`cmd/`) are typically placed.\nSOURCE: https://github.com/spf13/cobra/blob/main/site/content/user_guide.md#_snippet_0\n\nLANGUAGE: Console\nCODE:\n```\n appName/\n   cmd/\n      add.go\n      your.go\n      commands.go\n      here.go\n  main.go\n```"
  }
]