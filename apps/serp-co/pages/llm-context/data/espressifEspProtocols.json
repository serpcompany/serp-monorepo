[
  {
    "owner": "espressif",
    "repo": "esp-protocols",
    "content": "TITLE: Embedding Certificate Files into ESP-IDF Binary CMake\nDESCRIPTION: This snippet uses the `target_add_binary_data` function, provided by the ESP-IDF CMake build system, to embed specified certificate and key files directly into the project's ELF binary. This makes the certificate data available to the application code at runtime without needing external files, commonly used for SSL/TLS client authentication and server verification. The `TEXT` argument specifies that the files are treated as text.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_add_binary_data(${CMAKE_PROJECT_NAME}.elf \"certs/client.crt\" TEXT)\ntarget_add_binary_data(${CMAKE_PROJECT_NAME}.elf \"certs/client.key\" TEXT)\ntarget_add_binary_data(${CMAKE_PROJECT_NAME}.elf \"certs/mosquitto.org.pem\" TEXT)\n```\n\n----------------------------------------\n\nTITLE: Registering Mosquitto Component with ESP-IDF and Setting Build Properties in CMake\nDESCRIPTION: This snippet uses ESP-IDF's idf_component_register function to register the Mosquitto MQTT sources along with port-specific implementation files. It sets private and public include directories, defines component dependencies, and specifies compile-time definitions such as WITH_BROKER to enable broker features. Conditional compilation enables system tree support if configured. It also applies compile options to suppress format warnings and handles source file-specific compiler flags to undefine the _GNU_SOURCE macro to avoid build conflicts caused by redundant definitions in some Mosquitto sources.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS ${m_srcs}\\n                            port/callbacks.c\\n                            port/config.c\\n                            port/signals.c\\n                            port/broker.c\\n                            port/mosq_time.c\\n                            port/files.c\\n                            port/net__esp_tls.c\\n                            port/sysconf.c\\n                    PRIV_INCLUDE_DIRS port/priv_include port/priv_include/sys ${m_dir} ${m_src_dir}\\n                                      ${m_incl_dir} ${m_lib_dir} ${m_deps_dir}\\n                    INCLUDE_DIRS ${m_incl_dir} port/include\\n                    REQUIRES esp-tls\\n                    PRIV_REQUIRES newlib sock_utils esp_timer)\\n\\ntarget_compile_definitions(${COMPONENT_LIB} PRIVATE \"WITH_BROKER\")\\nif (CONFIG_MOSQ_ENABLE_SYS)\\n    target_compile_definitions(${COMPONENT_LIB} PRIVATE \"WITH_SYS_TREE\")\\nendif()\\ntarget_compile_options(${COMPONENT_LIB} PRIVATE \"-Wno-format\")\\n\\n# Some mosquitto source unconditionally define `_GNU_SOURCE` which collides with IDF build system\\n# producing warning: \"_GNU_SOURCE\" redefined\\n# This workarounds this issue by undefining the macro for the selected files\\nset(sources_that_define_gnu_source ${m_src_dir}/loop.c ${m_src_dir}/mux_poll.c)\\nforeach(offending_src ${sources_that_define_gnu_source})\\n    set_source_files_properties(${offending_src} PROPERTIES COMPILE_OPTIONS \"-U_GNU_SOURCE\")\\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: ESP-IDF Component Registration with Multiple Network Interfaces\nDESCRIPTION: Registers an ESP-IDF component with multiple source files for different network interfaces (WiFi, Ethernet, PPP) and connection checking. Includes the dynamically determined PPP connection sources based on the configuration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/multiple_netifs/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS multi_netif_main.c\n                            check_connection.c\n                            wifi_connect.c\n                            ethernet_connect.c\n                            ${ppp_connect_srcs}\n                       INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Build and Flash ESP-IDF Project\nDESCRIPTION: This snippet shows the command to build, flash, and monitor an ESP-IDF project.  Replace `PORT` with the correct serial port.  Requires ESP-IDF environment to be set up.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/examples/esp_dns_basic/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py -p PORT flash monitor\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with tls_transport.cpp and Dependencies\nDESCRIPTION: This code snippet registers a new component in the ESP-IDF build system by specifying source files (tls_transport.cpp), include directories, and dependencies required for TLS transport functionality. It declares dependencies on 'tcp_transport' and 'mbedtls_cxx' libraries, and uses the 'idf_component_register' macro for configuration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/components/extra_tcp_transports/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS tls_transport.cpp\n                       INCLUDE_DIRS include\n                       REQUIRES tcp_transport\n                       PRIV_REQUIRES mbedtls_cxx)\n```\n\n----------------------------------------\n\nTITLE: Executing MQTT-related Console Commands on ESP32 Shell\nDESCRIPTION: These command examples show typical CLI usage for interacting with the MQTT client. 'help' prints registered commands, while 'mqtt', 'mqtt_pub', and 'mqtt_sub' perform connection, message publication, and topic subscription actions. Commands support arguments such as host URI, credentials, certificate files, and flags for advanced scenarios such as SSL mutual authentication or internal certificate bundle usage. Expected inputs differ per command, and the output reflects execution success or MQTT event results.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nesp> help\nmqtt  [-CsD] [-h <host>] [-u <username>] [-P <password>] [--cert] [--key] [--cafile]\nmqtt_pub  [-t <topic>] [-m <message>]\nmqtt_sub  [-U] [-t <topic>]\n\n```\n\n----------------------------------------\n\nTITLE: Initializing NVS Flash and Event Loop in ESP-IDF (C)\nDESCRIPTION: Initializes the non-volatile storage (NVS) and creates the default event loop as prerequisites for the ESP console. Handles error cases where NVS pages are full or need erasure. Dependencies: ESP-IDF libraries for NVS and event loop. Call this code at the start of app_main(). Expects no input. Outputs initialization status via error checks; will abort on failure.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nESP_ERROR_CHECK(esp_event_loop_create_default());\nesp_err_t ret = nvs_flash_init();   //Initialize NVS\nif (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n    ESP_ERROR_CHECK(nvs_flash_erase());\n    ret = nvs_flash_init();\n}\nESP_ERROR_CHECK(ret);\n```\n\n----------------------------------------\n\nTITLE: Handling Network Events and Button Monitoring in ESP-IDF\nDESCRIPTION: This code snippet manages network event handling, including Wi-Fi connection status and IP address assignment, and sets up GPIO input for button monitoring. It ensures the system responds appropriately to network state changes and can trigger mDNS queries based on button presses. Dependencies include event loop registration and GPIO configuration mechanisms.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {\\n    if (event_base == WIFI_event_base && event_id == WIFI_EVENT_STA_GOT_IP) {\\n        wifi_event_sta_got_ip_t* event = (wifi_event_sta_got_ip_t*) event_data;\\n        ESP_LOGI(\"wifi\", \"Got IP: %s\", ip4addr_ntoa(&event->ip_info.ip));\\n        // Trigger mDNS queries or other network tasks\\n    } else if (event_base == WIFI_event_base && event_id == WIFI_EVENT_STA_DISCONNECTED) {\\n        ESP_LOGW(\"wifi\", \"Disconnected, retrying...\");\\n        esp_wifi_connect();\\n    }\\n}\\n// GPIO button initialization\\nvoid init_button() {\\n    gpio_config_t io_conf = {\\n        .pin_bit_mask = BIT(0),\\n        .mode = GPIO_MODE_INPUT,\\n        .pull_up_en = 1,\\n        .pull_down_en = 0,\\n        .intr_type = GPIO_INTR_DISABLE,\\n    };\\n    gpio_config(&io_conf);\\n}\\n// Example task to monitor button press\\nvoid check_button_task(void* pvParameters) {\\n    while (1) {\\n        if (gpio_get_level(GPIO_NUM_0) == 0) {\\n            // Button pressed, perform mDNS query or other action\\n        }\\n        vTaskDelay(pdMS_TO_TICKS(500));\\n    }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Resolving mDNS Host IP Address - C\nDESCRIPTION: This snippet resolves the IP address of a host using its mDNS hostname. It takes the host name as input and uses `mdns_query_a` to perform the resolution. The function then prints the resolved IP address. It handles potential errors during the query process, such as the host not being found or a general query failure. The output is the IP address in a human-readable format.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid resolve_mdns_host(const char * host_name)\n{\n    printf(\"Query A: %s.local\", host_name);\n\n    struct ip4_addr addr;\n    addr.addr = 0;\n\n    esp_err_t err = mdns_query_a(host_name, 2000,  &addr);\n    if(err){\n        if(err == ESP_ERR_NOT_FOUND){\n            printf(\"Host was not found!\");\n            return;\n        }\n        printf(\"Query Failed\");\n        return;\n    }\n\n    printf(IPSTR, IP2STR(&addr));\n}\n```\n\n----------------------------------------\n\nTITLE: Using getaddrinfo() for Domain Name Resolution\nDESCRIPTION: This code snippet demonstrates how to resolve a domain name using the standard getaddrinfo() function after DNS initialization. It sets up hints for socket family and type, performs the lookup, handles errors, and frees resources once resolution is complete.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstruct addrinfo hints = {\n    .ai_family = AF_UNSPEC,\n    .ai_socktype = SOCK_STREAM,\n};\nstruct addrinfo *res;\nint err = getaddrinfo(\"www.example.com\", \"80\", &hints, &res);\nif (err != 0) {\n    ESP_LOGE(TAG, \"DNS lookup failed: %d\", err);\n    return;\n}\n/* Use the resolved addresses */\n/* ... */\nfreeaddrinfo(res);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Mutual TLS Certificates for MQTT in ESP-IDF\nDESCRIPTION: These functions allow users to configure client certificates, client keys, and broker CA certificates for secure MQTT connections using mutual TLS. Each function requires pointers to the start and end of the respective PEM-encoded data. Proper security setup involves calling all three functions and passing the certificates during connection establishment with appropriate command-line parameters, ensuring encrypted and authenticated MQTT communication.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nset_mqtt_client_cert(client_cert_pem_start, client_cert_pem_end);\n\nset_mqtt_client_key(client_key_pem_start, client_key_pem_end);\n\nset_mqtt_broker_certs(broker_cert_pem_start, broker_cert_pem_end);\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for ESP-IDF ASIO TCP Echo Server Project\nDESCRIPTION: The standard boilerplate CMake configuration for ESP-IDF projects. It sets the minimum CMake version to 3.16, includes the ESP-IDF project cmake file, and defines the project name as 'asio_tcp_echo_server'.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/tcp_echo_server/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(asio_tcp_echo_server)\n```\n\n----------------------------------------\n\nTITLE: Configuring ESP-IDF ASIO UDP Echo Server with CMake\nDESCRIPTION: Standard CMake configuration for an ESP-IDF project. It sets the minimum CMake version to 3.16, includes the ESP-IDF project.cmake file to import the ESP-IDF build system, and defines the project name as 'asio_udp_echo_server'.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/udp_echo_server/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(asio_udp_echo_server)\n```\n\n----------------------------------------\n\nTITLE: Adding and Configuring mDNS Services - Espressif C\nDESCRIPTION: This function demonstrates how to register multiple network services for advertisement via mDNS on an Espressif device. It adds HTTP, Arduino, and a custom UDP service, sets a custom instance name for the HTTP service, assigns TXT records for descriptive device information, and updates a service port. Dependencies include the Espressif mDNS API. Services and their properties must be added in the specified order for correct association, and the hostname must be set before advertising services.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid add_mdns_services()\n{\n    //add our services\n    mdns_service_add(NULL, \"_http\", \"_tcp\", 80, NULL, 0);\n    mdns_service_add(NULL, \"_arduino\", \"_tcp\", 3232, NULL, 0);\n    mdns_service_add(NULL, \"_myservice\", \"_udp\", 1234, NULL, 0);\n\n    //NOTE: services must be added before their properties can be set\n    //use custom instance for the web server\n    mdns_service_instance_name_set(\"_http\", \"_tcp\", \"Jhon's {IDF_TARGET_NAME} Web Server\");\n\n    mdns_txt_item_t serviceTxtData[3] = {\n        {\"board\",\"{{IDF_TARGET_PATH_NAME}}\"},\n        {\"u\",\"user\"},\n        {\"p\",\"password\"}\n    };\n    //set txt data for service (will free and replace current data)\n    mdns_service_txt_set(\"_http\", \"_tcp\", serviceTxtData, 3);\n\n    //change service port\n    mdns_service_port_set(\"_myservice\", \"_udp\", 4321);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Supported MQTT CLI Commands for ESP-IDF Console\nDESCRIPTION: This section details the syntax and options for MQTT-related commands available via the ESP-IDF console, including connecting, disconnecting, publishing, and subscribing. The commands support parameters for specifying host, username, password, topics, messages, and security certificates, enabling flexible MQTT client control directly from the CLI for debugging or scripting. Flags are provided for TLS setup and client authentication options.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/README.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Example mDNS Query Usage - C\nDESCRIPTION: This snippet provides example usage of the `resolve_mdns_host` and `find_mdns_service` functions. It demonstrates how to query for a specific host by its hostname and how to find different network services like HTTP, SMB, AFP, NFS, and FTP servers and printers by their service types. The code utilizes functions defined previously to query and display results from mDNS services.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nvoid my_app_some_method(){\n    // 搜索 {IDF_TARGET_PATH_NAME}-mdns.local\n    resolve_mdns_host(\"{IDF_TARGET_PATH_NAME}-mdns\");\n\n    // 搜索 HTTP 服务器\n    find_mdns_service(\"_http\", \"_tcp\");\n    // 或者搜索文件服务器\n    find_mdns_service(\"_smb\", \"_tcp\"); // Windows 系统的共享服务\n    find_mdns_service(\"_afpovertcp\", \"_tcp\"); // Apple AFP 文件共享服务\n    find_mdns_service(\"_nfs\", \"_tcp\"); // NFS 服务器\n    find_mdns_service(\"_ftp\", \"_tcp\"); // FTP 服务器\n    // 或者网络打印机\n    find_mdns_service(\"_printer\", \"_tcp\");\n    find_mdns_service(\"_ipp\", \"_tcp\");\n}\n```\n\n----------------------------------------\n\nTITLE: Printing mDNS Query Results - Espressif C\nDESCRIPTION: This function traverses and prints detailed information for each result in a linked list of mDNS query results, including interface, protocol, PTR records, SRV targets, TXT data, and IP addresses. It depends on the Espressif mDNS structures and assumes valid, non-null input. Key parameters are a pointer to the head of a linked list of mdns_result_t objects as returned by mDNS queries. Outputs go to standard output.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstatic const char * if_str[] = {\"STA\", \"AP\", \"ETH\", \"MAX\"};\nstatic const char * ip_protocol_str[] = {\"V4\", \"V6\", \"MAX\"};\n\nvoid mdns_print_results(mdns_result_t * results){\n    mdns_result_t * r = results;\n    mdns_ip_addr_t * a = NULL;\n    int i = 1, t;\n    while(r){\n        printf(\"%d: Interface: %s, Type: %s\\n\", i++, if_str[r->tcpip_if], ip_protocol_str[r->ip_protocol]);\n        if(r->instance_name){\n            printf(\"  PTR : %s\\n\", r->instance_name);\n        }\n        if(r->hostname){\n            printf(\"  SRV : %s.local:%u\\n\", r->hostname, r->port);\n        }\n        if(r->txt_count){\n            printf(\"  TXT : [%u] \", r->txt_count);\n            for(t=0; t<r->txt_count; t++){\n                printf(\"%s=%s; \", r->txt[t].key, r->txt[t].value);\n            }\n            printf(\"\\n\");\n        }\n        a = r->addr;\n        while(a){\n            if(a->addr.type == IPADDR_TYPE_V6){\n                printf(\"  AAAA: \" IPV6STR \"\\n\", IPV62STR(a->addr.u_addr.ip6));\n            } else {\n                printf(\"  A   : \" IPSTR \"\\n\", IP2STR(&(a->addr.u_addr.ip4)));\n            }\n            a = a->next;\n        }\n        r = r->next;\n    }\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting and Configuring mDNS Service - Espressif C\nDESCRIPTION: This function initializes the mDNS service for Espressif devices, sets the device hostname, and assigns a human-friendly instance name for the local network. It depends on the Espressif mDNS library and requires that mDNS is enabled. The function takes no parameters and does not return a value; instead, it handles errors by printing them to standard output. Inputs such as the desired hostname and instance name must conform to network naming requirements.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid start_mdns_service()\n{\n    //initialize mDNS service\n    esp_err_t err = mdns_init();\n    if (err) {\n        printf(\"MDNS Init failed: %d\\n\", err);\n        return;\n    }\n\n    //set hostname\n    mdns_hostname_set(\"my-{IDF_TARGET_PATH_NAME}\");\n    //set default instance\n    mdns_instance_name_set(\"Jhon's {IDF_TARGET_NAME} Thing\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using the 'ping' Console Command\nDESCRIPTION: Illustrates the usage of the `ping` command within the ESP-IDF console. Shows a simple ping to a host and a more complex example specifying various options like timeout (`-W`), interval (`-i`), packet size (`-s`), count (`-c`), Type of Service (`-Q`), and Time to Live (`-T`).\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nping www.example.com\n```\n\nLANGUAGE: Shell\nCODE:\n```\nping -W 5 -i 1 -s 64 -c 4 -Q 0x10 -T 64 www.example.com\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Infrastructure (CMake)\nDESCRIPTION: This command includes the main ESP-IDF project configuration script. It pulls in the necessary build system functions, variables, and logic required for an ESP-IDF project to be built correctly by CMake. This relies on the `IDF_PATH` environment variable being set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project CMake Module\nDESCRIPTION: This code includes the ESP-IDF project CMake module using 'include' with an environment variable for the IDF path, enabling the use of ESP-IDF build tools. It sets up necessary build functions and variables for ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Configuration in CMake\nDESCRIPTION: This snippet includes the ESP-IDF project configuration file. This file provides the necessary settings and tools for building an ESP32 project using the Espressif IoT Development Framework (ESP-IDF). It sets up the environment and imports other modules required for building the project. This relies on the IDF_PATH environment variable being set correctly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project Configuration - CMake\nDESCRIPTION: This code block represents the standard boilerplate required at the beginning of an ESP-IDF project's CMakeLists.txt file. It specifies the minimum required CMake version (3.16 or higher), includes the core ESP-IDF build system definitions via the IDF_PATH environment variable, and declares the project name 'esp_dns_example'. These steps are crucial for integrating the project with the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/examples/esp_dns_basic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(esp_dns_example)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This CMake configuration initializes an ESP-IDF project. It specifies the minimum CMake version required (3.16), includes the ESP-IDF project CMake module from the IDF_PATH environment variable, and then sets the project name to 'async_http_request'.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/async_request/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(async_http_request)\n```\n\n----------------------------------------\n\nTITLE: Setting up CMake Configuration for ESP32 (wifi-basic)\nDESCRIPTION: This snippet configures the minimum CMake version required, includes the ESP-IDF project configuration file, and defines the project name as 'wifi-basic'. This is the standard initialization for an ESP-IDF project and is essential for building the application correctly. The project name will be used throughout the build process. No dependencies are listed explicitly, as they are implicitly handled by the IDF.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/examples/wifi-basic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(wifi-basic)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Initializing Wi-Fi and mDNS Services in ESP-IDF\nDESCRIPTION: This code snippet outlines the steps to initialize Wi-Fi connection, set up mDNS hostname and service advertisement, and handle network events. It involves configuring Wi-Fi parameters, starting Wi-Fi, and registering event handlers for network state changes. The code is essential for establishing network connectivity and advertising services within an ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"esp_wifi.h\"\\n#include \"esp_event.h\"\\n#include \"nvs_flash.h\"\\n#include \"mdns.h\"\\n#include \"esp_log.h\"\\n\\n// Initialize Wi-Fi, mDNS, and event handlers\\nvoid app_main() {\\n    // Initialize NVS\\n    esp_err_t ret = nvs_flash_init();\\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\\n        ESP_ERROR_CHECK(nvs_flash_erase());\\n        ret = nvs_flash_init();\\n    }\\n    ESP_ERROR_CHECK(ret);\\n\\n    // Initialize TCP/IP stack\\n    ESP_ERROR_CHECK(esp_netif_init());\\n    // Create default event loop\\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\\n\\n    // Initialize Wi-Fi with default configuration\\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg));\\n\\n    // Configure Wi-Fi as station and connect to network\\n    // (Details omitted for brevity)\\n\\n    // Register event handler for Wi-Fi events\\n    // (Implementation of event handler to handle connection events)\\n\\n    // Start Wi-Fi\\n    ESP_ERROR_CHECK(esp_wifi_start());\\n\\n    // Initialize mDNS with hostname\\n    ESP_ERROR_CHECK(mdns_init());\\n    ESP_ERROR_CHECK(mdns_set_hostname(\"esp32-mdns\"));\\n    ESP_ERROR_CHECK(mdns_service_add(\"ESP32 HTTP\", \"_http\", \"_tcp\", 80, NULL, 0));\\n\\n    // Additional setup like GPIO and other tasks\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Console Commands in ESP-IDF C\nDESCRIPTION: Initializes the console subsystem (`console_cmd_init`), registers either all available plugin commands (`console_cmd_all_register`) or specifically the `ifconfig` command (`console_cmd_ifconfig_register`), and finally starts the console task (`console_cmd_start`). This sequence should typically be placed at the end of the `app_main` function after other initializations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nESP_ERROR_CHECK(console_cmd_init());     // Initialize console\n\n// Register all plugin command added to your project\nESP_ERROR_CHECK(console_cmd_all_register());\n\n// To register only ifconfig command skip calling console_cmd_all_register()\nESP_ERROR_CHECK(console_cmd_ifconfig_register());\n\nESP_ERROR_CHECK(console_cmd_start());    // Start console\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS over HTTPS in ESP-IDF using esp_dns_config_t\nDESCRIPTION: This snippet demonstrates how to initialize a DNS over HTTPS (DoH) configuration structure with server details, port, timeout, and TLS settings. It sets up necessary parameters such as certificate validation and URL path for secure DNS queries, preparing for the DNS resolution process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"esp_dns.h\"\n\n/* Configure DNS over HTTPS */\nesp_dns_config_t dns_config = {\n    .dns_server = \"dns.google\",            /* DNS server hostname or IP address */\n    .port = ESP_DNS_DEFAULT_DOH_PORT,      /* Default port 443 for HTTPS */\n    .timeout_ms = ESP_DNS_DEFAULT_TIMEOUT_MS, /* Request timeout in milliseconds */\n    .tls_config = {\n        /* Attach ESP-IDF certificate bundle for trusted DNS providers */\n        .crt_bundle_attach = esp_crt_bundle_attach,\n\n        /* Or provide a custom PEM certificate string for your DNS server */\n        /* .cert_pem = server_root_cert_pem_start, */\n\n        /* Note: Prefer crt_bundle_attach if available */\n    },\n    .protocol_config.doh_config = {\n        .url_path = \"/dns-query\" /* Optional DoH endpoint path */\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Subscribing and Unsubscribing to MQTT Topics via Console\nDESCRIPTION: These commands manage topic subscriptions by sending subscribe ('mqtt_sub -t <topic>') and unsubscribe ('mqtt_sub -U -t <topic>') requests to the broker. Successful operations emit logs (e.g., MQTT_EVENT_SUBSCRIBED, MQTT_EVENT_UNSUBSCRIBED) including topic name and message ID. Inputs are mandatory topic names.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nesp> mqtt_sub -t test0\nI (897289) console_mqtt: Subscribe successful, msg_id=57425, topic=test0\nesp> I (897799) console_mqtt: MQTT_EVENT_SUBSCRIBED, msg_id=57425\nesp>\nesp> mqtt_sub -U -t test0\nI (902009) console_mqtt: Unsubscribe successful, msg_id=27663, topic=test0\nesp> I (902509) console_mqtt: MQTT_EVENT_UNSUBSCRIBED, msg_id=27663\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with URI and Path - C\nDESCRIPTION: This snippet demonstrates how to initialize an ESP WebSocket client with a URI that includes both a path and a query string. The `esp_websocket_client_config_t` struct is configured with the URI set to `ws://echo.websocket.org/connectionhandler?id=104`.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nconst esp_websocket_client_config_t ws_cfg = {\n    .uri = \"ws://echo.websocket.org/connectionhandler?id=104\",\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing DNS over HTTPS with esp_dns_init_doh\nDESCRIPTION: This snippet shows how to initialize the DNS subsystem with DNS over HTTPS protocol, returning a handle used for further resolution or cleanup. It ensures secure DNS resolution using the provided configuration, integrating with the LWIP hooks for custom DNS handling.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nesp_dns_handle_t dns_handle = esp_dns_init_doh(&dns_config);\nif (dns_handle == NULL) {\n    ESP_LOGE(TAG, \"Failed to initialize DNS\");\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering C++ Source Files and Include Directory for ESP-IDF Component\nDESCRIPTION: This CMake command employs the ESP-IDF specific function `idf_component_register`. It registers `simple_cmux_client_main.cpp` and `simple_mqtt_client.cpp` as the source files (`SRCS`) for the component being built. Additionally, it adds the component's current directory (`.`) to the list of directories (`INCLUDE_DIRS`) that the compiler will search for header files.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/simple_cmux_client/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"simple_cmux_client_main.cpp\"  \"simple_mqtt_client.cpp\"\n                       INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Setting Up WiFi Soft Access Point and NAT Forwarding\nDESCRIPTION: This code configures the ESP device to operate as a WiFi soft access point, establishing network connectivity for client devices. It sets up NAT to forward packets between WiFi clients and the PPP interface, enabling seamless network bridging. This setup is critical for creating a transparent gateway between local WiFi clients and cellular or PPP networks.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/README.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// Configure WiFi soft AP and enable NAT forwarding\nvoid setup_wifi_ap() {\n    // Initialize WiFi configuration\n    // Set SSID, security, and channel\n    // Start WLAN in AP mode\n    // Enable NAT and ip forwarding\n}\n// Note: This function calls underlying ESP-IDF WiFi APIs and NAT setup functions.\n```\n\n----------------------------------------\n\nTITLE: Initializing mDNS Service - C\nDESCRIPTION: This snippet initializes the mDNS service within an ESP-IDF application. It checks for errors during initialization and returns if there's an issue. This is a prerequisite for other mDNS operations, such as setting the hostname and instance name, or adding services.  The `mdns_init()` function performs the setup of the mDNS service, which is required before any other mDNS operations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid start_mdns_service()\n{\n    // 初始化 mDNS 服务\n    esp_err_t err = mdns_init();\n    if (err) {\n        printf(\"MDNS Init failed: %d\\n\", err);\n        return;\n    }\n\n    // 设置 hostname\n    mdns_hostname_set(\"my-{IDF_TARGET_PATH_NAME}\");\n    // 设置默认实例\n    mdns_instance_name_set(\"Jhon's {IDF_TARGET_NAME} Thing\");\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing MQTT Messages via Console\nDESCRIPTION: This command publishes a given message to a specified MQTT topic using 'mqtt_pub'. It requires the topic ('-t') and message ('-m') arguments. Output includes publish success log (with message ID, topic, and message details) and a confirmation event. Used for typical MQTT publish workflows.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nesp> mqtt_pub -t test0 -m \"Hello, Testing 123\"\nI (999469) console_mqtt: Publish successful, msg_id=55776, topic=test0, data=Hello, Testing 123\nI (1000009) console_mqtt: MQTT_EVENT_PUBLISHED, msg_id=55776\nesp>\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with URI - C\nDESCRIPTION: This snippet shows the minimal configuration required to initialize an ESP WebSocket client using a URI. It defines a `esp_websocket_client_config_t` struct with the URI set to `ws://echo.websocket.org`.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nconst esp_websocket_client_config_t ws_cfg = {\n    .uri = \"ws://echo.websocket.org\",\n};\n```\n\n----------------------------------------\n\nTITLE: Build and Flash the Project\nDESCRIPTION: This command builds the project, flashes it to the ESP32 board, and then starts the serial monitor to view the output. Replace PORT with the serial port the ESP32 is connected to.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_apps/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py -p PORT flash monitor\n```\n\n----------------------------------------\n\nTITLE: Initializing Network Interface and NVS in ESP-IDF C\nDESCRIPTION: Initializes the ESP network interface (`esp_netif_init`), creates the default event loop (`esp_event_loop_create_default`), and initializes the Non-Volatile Storage (NVS) flash memory (`nvs_flash_init`). It includes error checking and logic to erase NVS if its format is invalid or incompatible. This setup is a prerequisite for using networking features and the console ifconfig component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nESP_ERROR_CHECK(esp_netif_init());\nESP_ERROR_CHECK(esp_event_loop_create_default());\nesp_err_t ret = nvs_flash_init();   //Initialize NVS\nif (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n    ESP_ERROR_CHECK(nvs_flash_erase());\n    ret = nvs_flash_init();\n}\nESP_ERROR_CHECK(ret);\n```\n\n----------------------------------------\n\nTITLE: Initializing Network Interface and NVS in C (ESP-IDF)\nDESCRIPTION: Initializes the ESP network interface (`esp_netif_init`), creates the default event loop (`esp_event_loop_create_default`), and initializes Non-Volatile Storage (NVS) flash (`nvs_flash_init`), handling potential errors. These steps are essential prerequisites before using network-dependent console commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nESP_ERROR_CHECK(esp_netif_init());\nESP_ERROR_CHECK(esp_event_loop_create_default());\nesp_err_t ret = nvs_flash_init();   //Initialize NVS\nif (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n    ESP_ERROR_CHECK(nvs_flash_erase());\n    ret = nvs_flash_init();\n}\nESP_ERROR_CHECK(ret);\n```\n\n----------------------------------------\n\nTITLE: Syntax for Console Ping, GetAddrInfo, and DNS Commands\nDESCRIPTION: Defines the command-line syntax and available options for the `ping`, `getaddrinfo`, `setdnsserver`, and `getdnsserver` commands provided by the `console_ping` component in the ESP-IDF console. These commands facilitate network diagnostics and DNS configuration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nping  [-W <t>] [-i <t>] [-s <n>] [-c <n>] [-Q <n>] [-T <n>] <host>\n  send ICMP ECHO_REQUEST to network hosts\n  -W, --timeout=<t>  Time to wait for a response, in seconds\n  -i, --interval=<t>  Wait interval seconds between sending each packet\n  -s, --size=<n>  Specify the number of data bytes to be sent\n  -c, --count=<n>  Stop after sending count packets\n  -Q, --tos=<n>  Set Type of Service related bits in IP datagrams\n  -T, --ttl=<n>  Set Time to Live related bits in IP datagrams\n        <host>  Host address\n\ngetaddrinfo  [-f <AF>] [-F <FLAGS>]... [-p <port>] <hostname>\n  Usage: getaddrinfo [options] <hostname> [service]\n  -f, --family=<AF>  Address family (AF_INET, AF_INET6, AF_UNSPEC).\n  -F, --flags=<FLAGS>  Special flags (AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_V4MAPPED, AI_ALL).\n  -p, --port=<port>  String containing a numeric port number.\n    <hostname>  Host address\n\nsetdnsserver  <main> [backup] [fallback]\n  Usage: setdnsserver <main> [backup] [fallback]\n        <main>  The main DNS server IP address.\n        backup  The secondary DNS server IP address (optional).\n      fallback  The fallback DNS server IP address (optional).\n\ngetdnsserver\n  Usage: getdnsserver\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component Sources in CMake\nDESCRIPTION: Registers the current directory as an ESP-IDF component within the build system. It specifies the C and C++ source files to be compiled and the directories to search for include files. This is the fundamental step for integrating a component into the ESP-IDF build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/common_components/linux_compat/freertos/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS freertos_linux.c\n                            osal/queue.cpp osal/event_group.cpp osal/mutex.cpp\n                       INCLUDE_DIRS include)\n```\n\n----------------------------------------\n\nTITLE: Resolving Host IPs via mDNS - Espressif C\nDESCRIPTION: This function performs an mDNS A-record query to resolve the IPv4 address of a given hostname on the local network. It uses the Espressif mDNS library and requires the mDNS subsystem to be initialized. The function accepts a pointer to a null-terminated host name string, prints the query result or errors to standard output, and requires the host name (without the .local suffix) as input.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid resolve_mdns_host(const char * host_name)\n{\n    printf(\"Query A: %s.local\", host_name);\n\n    struct ip4_addr addr;\n    addr.addr = 0;\n\n    esp_err_t err = mdns_query_a(host_name, 2000,  &addr);\n    if(err){\n        if(err == ESP_ERR_NOT_FOUND){\n            printf(\"Host was not found!\");\n            return;\n        }\n        printf(\"Query Failed\");\n        return;\n    }\n\n    printf(IPSTR, IP2STR(&addr));\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Source and Dependencies in CMake\nDESCRIPTION: Registers an ESP-IDF component with the build system by specifying its source files, include directories, and required components. The snippet depends on having the ESP-IDF build environment configured and relies on the tcp_transport component to be available. It expects the source file mbedtls_wrap.cpp to contain the component's code, with include files located in the 'include' directory. The output integrates this component into the overall firmware build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS mbedtls_wrap.cpp\n                       INCLUDE_DIRS include\n                       REQUIRES tcp_transport)\n```\n\n----------------------------------------\n\nTITLE: Using the 'setdnsserver' Console Command\nDESCRIPTION: Provides examples for using the `setdnsserver` command in the ESP-IDF console. Demonstrates setting only the main DNS server, setting main and backup servers (IPv4 and IPv6 shown), and setting main, backup, and fallback servers (using IP addresses and a hostname).\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nsetdnsserver 8.8.8.8\n```\n\nLANGUAGE: Shell\nCODE:\n```\nsetdnsserver 8.8.8.8 fe80::b0be:83ff:fe77:dd64\n```\n\nLANGUAGE: Shell\nCODE:\n```\nsetdnsserver 8.8.8.8 fe80::b0be:83ff:fe77:dd64 www.xyz.com\n```\n\n----------------------------------------\n\nTITLE: Initialize ESP-IDF Core Components in C\nDESCRIPTION: This C snippet demonstrates the necessary initialization steps for core ESP-IDF components required for networking and persistent storage within the `app_main` function. It initializes the network interface layer (`esp_netif`), creates the default event loop (`esp_event`), and initializes the NVS flash partition, including handling potential initialization errors for NVS. These are prerequisites for the WiFi stack and configuration storage.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/README.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nESP_ERROR_CHECK(esp_netif_init());\nESP_ERROR_CHECK(esp_event_loop_create_default());\nesp_err_t ret = nvs_flash_init();   //Initialize NVS\nif (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n    ESP_ERROR_CHECK(nvs_flash_erase());\n    ret = nvs_flash_init();\n}\nESP_ERROR_CHECK(ret);\n```\n\n----------------------------------------\n\nTITLE: Enabling DHCP Client on an Interface via Console (Shell)\nDESCRIPTION: Shows how to enable the DHCP client for automatic IP configuration on a specific network interface (e.g., `en1`) using the `ifconfig <iface> dhcp client enable` command in the ESP-IDF console. The interface will attempt to obtain an IP address, subnet mask, and gateway from a DHCP server.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig en1 dhcp client enable\n```\n\n----------------------------------------\n\nTITLE: Registering Wi-Fi Component - ESP-IDF (C)\nDESCRIPTION: This snippet registers a component in the ESP-IDF build system. The `idf_component_register` function is used to register a component. It takes a list of source files (`SRCS`) and include directories (`INCLUDE_DIRS`) as arguments. The source file `wifi-basic.c` is included and the include directories are set to the current directory (`.`). This registration is essential for the ESP-IDF build system to include and compile the source code.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/examples/wifi-basic/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS \"wifi-basic.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Source and Include Directories in CMake\nDESCRIPTION: Uses the ESP-IDF CMake function idf_component_register to define a component's source files and include directories for building an ESP32 application. Requires ESP-IDF build environment and CMake. The SRCS parameter lists the source files main.c and mdns_test.c to compile and link as part of the component. The INCLUDE_DIRS parameter specifies the directories to search for header files, here the current directory '.' is included.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_apps/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"main.c\" \"mdns_test.c\"\n                        INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component\nDESCRIPTION: Registers the 'udp_echo_server' component within the ESP-IDF build system.  It specifies 'udp_echo_server.cpp' as the source file and the current directory '.' as the include directory. This allows the component to be built and linked into the final application.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/udp_echo_server/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"udp_echo_server.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component (CMake)\nDESCRIPTION: This CMake command registers a component for the ESP-IDF build system. It defines the source files (`uart_mutual.cpp`) and include directories (`.`) required to build this specific component. This is a fundamental part of structuring an ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/tests/uart_mutual_auth/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"uart_mutual.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering MQTT SSL Component in ESP-IDF (CMake)\nDESCRIPTION: This snippet registers an MQTT SSL example component within the ESP-IDF build system using the `idf_component_register` function. It specifies the source file ('mqtt_ssl_example.cpp') and the include directory ('.').  This allows the build system to compile the source file and include headers from the specified directory. The `idf_component_register` function is part of the ESP-IDF CMake build system and must be placed inside a CMakeLists.txt file within the component's directory.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/ssl/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"mqtt_ssl_example.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Source Files and Include Directories in C\nDESCRIPTION: This code snippet registers an ESP-IDF component by specifying source files and include directories. It uses the 'idf_component_register' macro to include 'socks4.cpp' and set the current directory as an include path, facilitating compilation and integration of the Socks4 protocol module within the ESP-IDF environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/socks4/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS \"socks4.cpp\"\\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering source files and include directories in ESP-IDF component\nDESCRIPTION: This code registers the source files 'app_main.c' and 'register_iperf.c' as part of an ESP-IDF component and specifies the current directory as an include directory. It is used to include necessary source code and headers during build. Dependencies include the ESP-IDF build system and related project files.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/examples/host/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS app_main.c register_iperf.c\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name in CMake for ESP32\nDESCRIPTION: This snippet defines the name of the project. It sets the project name to \"client_example\". The project name is used for generating build artifacts and managing the project. This ensures that the generated executables and libraries are named according to the project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(client_example)\n```\n\n----------------------------------------\n\nTITLE: Defining the Project Name - CMake\nDESCRIPTION: This line defines the project name, which is used by CMake during the build process.  The project name is a string, in this case \"asio_sock4\", which should be a unique identifier for this project. The output is the name of the built project file and can be referenced by other parts of the CMake configuration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/socks4/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(asio_sock4)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name\nDESCRIPTION: Defines the name of the project, which is used by ESP-IDF's build system for generating build artifacts and managing dependencies. In this case, the project is named 'mqtt_ssl_cxx'.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/ssl/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nproject(mqtt_ssl_cxx)\n```\n\n----------------------------------------\n\nTITLE: mDNS A Record Representation (Text)\nDESCRIPTION: Represents an IPv4 Address (A) record in mDNS packet analysis output. A records map a hostname to one or more IPv4 addresses. The output shows both query (Q) and answer (A) formats, with answers including TTL, data length, and the IPv4 address.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nQ: minifritz.local. A IN FLUSH\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: minifritz.local. A IN FLUSH 120 [4] 192.168.254.16\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristos-Time-Capsule.local. A IN FLUSH 120 [4] 169.254.23.40\n```\n\n----------------------------------------\n\nTITLE: Implementing a new module using GenericModule in C++\nDESCRIPTION: To support a new module, developers need to implement a class derived from `esp_modem::GenericModule`. This involves creating a new class and its associated factory extension within the esp_modem code base, following the guidelines provided in the Advanced User Manual for creating custom modules.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/internal_docs.rst#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nesp_modem::GenericModule\n```\n\n----------------------------------------\n\nTITLE: Enabling Static IP Configuration via Console (Shell)\nDESCRIPTION: Demonstrates how to prepare an interface for static IP configuration by disabling the DHCP client using the `ifconfig <iface> dhcp client disable` command in the ESP-IDF console. This is a necessary step before manually setting the IP address, subnet mask, and gateway.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig en1 dhcp client disable\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimal Network DCE Module in C++\nDESCRIPTION: This snippet defines a minimal Network DCE module class inheriting from ModuleIf, used to manage cellular network communication with minimal command set. It overrides necessary methods to facilitate DCE creation and initialization, providing essential interface functions required for establishing cellular connectivity without relying on extensive AT command scripts.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/README.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Minimal Network DCE Module implementation\nclass MinimalNetDCE : public ModuleIf {\npublic:\n    MinimalNetDCE();\n    virtual ~MinimalNetDCE();\n    // Override methods for DCE functionality\n    bool initialize() override;\n    // Additional methods and members for DCE management\n};\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Sources and Dependencies in CMake\nDESCRIPTION: Defines an ESP-IDF component using the idf_component_register macro, specifying the source file ('esp_err_to_name.c'), the include directory ('include'), and required dependencies ('esp_netif_linux' and 'esp_event_mock'). This macro is essential for integrating the component into the ESP-IDF build system, managing compilation units and linking dependencies. The specified dependencies are necessary for proper compilation and functionality of the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_system_protocols_linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"esp_err_to_name.c\"\n                        INCLUDE_DIRS include\n                        REQUIRES esp_netif_linux esp_event_mock)\n```\n\n----------------------------------------\n\nTITLE: Composite Example of mDNS Host and Service Discovery - Espressif C\nDESCRIPTION: This function demonstrates a combined approach to mDNS querying: it first resolves a host IP and then searches for commonly used network services (such as HTTP server, SMB, AFP, NFS, FTP, and printers) via mDNS PTR queries. Dependencies are the previous resolve_mdns_host and find_mdns_service functions, and it expects the mDNS service to be configured and running. Inputs are hardcoded and do not accept function parameters.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nvoid my_app_some_method(){\n    //search for {IDF_TARGET_PATH_NAME}-mdns.local\n    resolve_mdns_host(\"{IDF_TARGET_PATH_NAME}-mdns\");\n\n    //search for HTTP servers\n    find_mdns_service(\"_http\", \"_tcp\");\n    //or file servers\n    find_mdns_service(\"_smb\", \"_tcp\"); //windows sharing\n    find_mdns_service(\"_afpovertcp\", \"_tcp\"); //apple sharing\n    find_mdns_service(\"_nfs\", \"_tcp\"); //NFS server\n    find_mdns_service(\"_ftp\", \"_tcp\"); //FTP server\n    //or networked printer\n    find_mdns_service(\"_printer\", \"_tcp\");\n    find_mdns_service(\"_ipp\", \"_tcp\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling NAPT on an Interface via Console (Shell)\nDESCRIPTION: Demonstrates enabling Network Address Port Translation (NAPT) on a specific network interface (e.g., `en1`) using the `ifconfig <iface> napt enable` command in the ESP-IDF console. This allows devices on a private network behind this interface to share its public IP address.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig en1 napt enable\nI (8467116) console_ifconfig: Setting napt enable on en1\n```\n\n----------------------------------------\n\nTITLE: Embedding Binary Data\nDESCRIPTION: Embeds the specified binary file ('main/mqtt_eclipseprojects_io.pem') into the project's executable. This is useful for including data such as SSL certificates directly within the firmware. The 'TEXT' option indicates that the file should be treated as a text file.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/ssl/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_add_binary_data(mqtt_ssl_cxx.elf \"main/mqtt_eclipseprojects_io.pem\" TEXT)\n```\n\n----------------------------------------\n\nTITLE: Include ESP-IDF Project Module (CMake)\nDESCRIPTION: Includes the main CMake module provided by the ESP-IDF framework. This module defines functions and variables necessary for configuring and building ESP-IDF applications. It depends on the IDF_PATH environment variable being correctly set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Definition - CMake\nDESCRIPTION: This line includes the ESP-IDF project definition file. This is a prerequisite for any ESP-IDF project. It provides essential definitions and functions to properly build an ESP32 project using the ESP-IDF framework. The include path is obtained from the IDF_PATH environment variable.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/socks4/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF project configuration\nDESCRIPTION: This line includes ESP-IDF's project CMake script from the environment path, setting up necessary build variables and functions for the project, facilitating the integration with the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Performing mDNS Queries Using Dig with Bash\nDESCRIPTION: Examples of using the dig utility to perform multicast DNS (mDNS) queries bound to a specific source IP address and port. The commands demonstrate both standard forward DNS queries and reverse DNS lookups on an mDNS multicast group (224.0.0.251) over port 5353. Dependencies include the dig tool and network connectivity to the specified interfaces. Inputs include source IP binding and target hostnames or IP addresses, and the output is the resolved name or address string.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/host_test/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndig +short -b 192.168.1.200 -p 5353 @224.0.0.251 myesp.local\n```\n\nLANGUAGE: bash\nCODE:\n```\ndig +short -b 192.168.2.200 -p 5353 @224.0.0.251 -x 192.168.1.200\n```\n\n----------------------------------------\n\nTITLE: Registering the asio component with IDF\nDESCRIPTION: This snippet registers the asio component with the ESP-IDF build system. It specifies the source files, include directories, and private include directories for the component, along with private requirements. The `idf_component_register` function registers the component with the specified properties.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS ${asio_sources}\n                    INCLUDE_DIRS \"port/include\" \"asio/asio/include\"\n                    PRIV_INCLUDE_DIRS ${asio_priv_includes}\n                    PRIV_REQUIRES ${asio_requires})\n```\n\n----------------------------------------\n\nTITLE: Using the 'getaddrinfo' Console Command\nDESCRIPTION: Demonstrates how to use the `getaddrinfo` command in the ESP-IDF console. Includes a basic example to resolve a hostname and another example specifying the address family (IPv4) and flags (passive).\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\ngetaddrinfo www.example.com\n```\n\nLANGUAGE: Shell\nCODE:\n```\ngetaddrinfo -f AF_INET -F AI_PASSIVE www.example.com\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component for Async HTTP Request in CMake\nDESCRIPTION: This snippet registers an ESP-IDF component with a single source file and configures include paths. It uses the idf_component_register function to define the component structure for the build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/async_request/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"async_http_request.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project with CMake for PPPoS Client in CMake\nDESCRIPTION: This snippet initializes the ESP-IDF project build system by specifying the minimum CMake version required and including the ESP-IDF build macros via the IDF_PATH environment variable. It also declares the project name as 'pppos_client'. Dependencies include the ESP-IDF framework and its build system extensions. The commands must appear in this exact order in the CMakeLists.txt to successfully configure the build. The input consists of CMake build scripts and environment setup, and the output is a configured build environment ready for component compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/pppos_client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\\n\\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\\nproject(pppos_client)\n```\n\n----------------------------------------\n\nTITLE: Registering console_ifconfig Component in ESP-IDF\nDESCRIPTION: This CMake code registers an ESP-IDF component using `idf_component_register`. It defines the source file (`console_ifconfig.c`), sets the include directory (`.`), and specifies private component dependencies (`esp_netif`, `console`, `esp_eth`). The `WHOLE_ARCHIVE` flag instructs the build system on how to link this component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"console_ifconfig.c\"\n                    INCLUDE_DIRS \".\"\n                    PRIV_REQUIRES esp_netif console esp_eth\n                    WHOLE_ARCHIVE)\n```\n\n----------------------------------------\n\nTITLE: Starting Console and Registering User Command in ESP-IDF (C)\nDESCRIPTION: Demonstrates initialization and setup of the ESP console, including user command registration and starting the console. Declares a user-defined command handler (do_user_cmd) and registers it with the console under the command name 'user'. Also registers all plugin commands and starts the console. Must be called from app_main() after hardware and system initialization. Dependencies: ESP-IDF, console_simple_init. Key parameters include the command name and handler function. Outputs error check status; aborts on initialization failure.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nESP_ERROR_CHECK(console_cmd_init());     // Initialize console\n\n// Define the function prototype for do_user_cmd\n// It's a function that takes an integer (argc) and a pointer to a pointer to char (argv)\nint do_user_cmd(int argc, char **argv);\n\n// Register the do_user_cmd function as a command callback function for \"user\" command\n// This allows you to execute the do_user_cmd function when the \"user\" command is invoked\nESP_ERROR_CHECK(console_cmd_user_register(\"user\", do_user_cmd));\n\n// Register any other plugin command added to your project\nESP_ERROR_CHECK(console_cmd_all_register());\n\nESP_ERROR_CHECK(console_cmd_start());    // Start console\n```\n\n----------------------------------------\n\nTITLE: Connecting to MQTT Broker Without Certificate Validation\nDESCRIPTION: This command connects the ESP32 MQTT client to a remote broker using SSL/TLS without validating the broker's certificate, which is insecure. The 'mqtt' command expects the '-h' option for broker URI and '-C' to initiate the connection. The broker URI should begin with 'mqtts://'. Output will indicate connection result or errors.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nmqtt -h mqtts://test.mosquitto.org -C\nmqtt -h mqtts://mqtt.eclipseprojects.io -C\n\n```\n\n----------------------------------------\n\nTITLE: Initializing and Registering Console Commands in C (ESP-IDF)\nDESCRIPTION: Initializes the console system (`console_cmd_init`), registers either all available plugin commands (`console_cmd_all_register`) or specific network commands individually (`console_cmd_ping_register`, `console_cmd_getaddrinfo_register`, etc.), and starts the console (`console_cmd_start`). This enables the use of configured commands via the serial console interface.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nESP_ERROR_CHECK(console_cmd_init());     // Initialize console\n\n// Register all plugin command added to your project\nESP_ERROR_CHECK(console_cmd_all_register());\n\n// To register only ping/dns command skip calling console_cmd_all_register()\nESP_ERROR_CHECK(console_cmd_ping_register());\nESP_ERROR_CHECK(console_cmd_getaddrinfo_register());\nESP_ERROR_CHECK(console_cmd_setdnsserver_register());\nESP_ERROR_CHECK(console_cmd_getdnsserver_register());\n\nESP_ERROR_CHECK(console_cmd_start());    // Start console\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used to build the project is compatible with the CMake commands and features used in the project's CMake files. It is important for compatibility.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version - CMake\nDESCRIPTION: Specifies the minimum version of CMake required to build the project. This command ensures that the build environment supports the necessary features and commands used in the project's CMake scripts. It takes the required version number as a parameter.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for ESP-IDF Project\nDESCRIPTION: This snippet defines the minimum required version of CMake for the project. It's a crucial step in setting up the build environment for an ESP-IDF project and ensuring compatibility with the build system. It specifies the minimum CMake version required to build the project successfully. The build process will fail if the installed CMake version is less than the one specified in this line.  This sets the foundation for the build process, guaranteeing it uses a CMake version compatible with the project's requirements.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/examples/console_basic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.16. This ensures that the CMake version used to build the project is compatible with the CMake commands and features used in the file.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Defining Minimum CMake Version for ESP-IDF Project\nDESCRIPTION: This snippet specifies the minimum required version of CMake (3.16) to ensure compatibility with ESP-IDF build requirements. It prevents build failures due to outdated CMake versions.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/examples/ifconfig-basic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Setting Up CMake Build Environment with ESP-IDF for WebSocket Unit Test in CMake\nDESCRIPTION: This snippet initializes the CMake build system by specifying the minimum required version (3.16), setting extra component directories which include a local esp_websocket_client directory and the unit-test-app components from the ESP-IDF environment variable IDF_PATH. Finally, it includes the ESP-IDF project configuration script and defines the project name as websocket_unit_test. Dependencies rely on a correct ESP-IDF setup and environment variables. This setup ensures building components and unit tests related to websocket functionality within the ESP framework.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nset(EXTRA_COMPONENT_DIRS    ../../esp_websocket_client\n                            \"$ENV{IDF_PATH}/tools/unit-test-app/components\")\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(websocket_unit_test)\n```\n\n----------------------------------------\n\nTITLE: Setting the Default Network Interface via Console (Shell)\nDESCRIPTION: Example command to set a specific network interface (e.g., `en1`) as the default routing interface using the `ifconfig <iface> default` command in the ESP-IDF console. Network traffic without a specific route will use this interface.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig en1 default\n```\n\n----------------------------------------\n\nTITLE: Defining Mosquitto MQTT Source Files and Directories with CMake\nDESCRIPTION: This snippet declares variables representing the Mosquitto source, include, library, and dependency directories. It collects all relevant C source files under these directories into a single list variable ${m_srcs}. This list includes both library sources and core MQTT protocol implementation files. The sources are organized to distinguish low-level utilities, protocol handling, persistence, security, websockets, and broker-specific functions.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(m_dir mosquitto)\\nset(m_src_dir ${m_dir}/src)\\nset(m_incl_dir ${m_dir}/include)\\nset(m_lib_dir ${m_dir}/lib)\\nset(m_deps_dir ${m_dir}/deps)\\n\\nset(m_srcs\\n        ${m_lib_dir}/memory_mosq.c\\n        ${m_lib_dir}/util_mosq.c\\n        ${m_lib_dir}/will_mosq.c\\n        ${m_lib_dir}/alias_mosq.c\\n        ${m_lib_dir}/send_mosq.c\\n        ${m_lib_dir}/strings_mosq.c\\n        ${m_lib_dir}/packet_mosq.c\\n        ${m_lib_dir}/packet_datatypes.c\\n        ${m_lib_dir}/property_mosq.c\\n        ${m_lib_dir}/util_topic.c\\n        ${m_lib_dir}/send_publish.c\\n        ${m_lib_dir}/send_disconnect.c\\n        ${m_lib_dir}/handle_pubackcomp.c\\n        ${m_lib_dir}/handle_pubrec.c\\n        ${m_lib_dir}/handle_pubrel.c\\n        ${m_lib_dir}/handle_ping.c\\n        ${m_lib_dir}/utf8_mosq.c\\n\\n        ${m_src_dir}/bridge.c\\n        ${m_src_dir}/bridge_topic.c\\n        ${m_src_dir}/conf_includedir.c\\n        ${m_src_dir}/context.c\\n        ${m_src_dir}/control.c\\n        ${m_src_dir}/database.c\\n        ${m_src_dir}/handle_auth.c\\n        ${m_src_dir}/handle_connack.c\\n        ${m_src_dir}/handle_connect.c\\n        ${m_src_dir}/handle_disconnect.c\\n        ${m_src_dir}/handle_publish.c\\n        ${m_src_dir}/handle_subscribe.c\\n        ${m_src_dir}/handle_unsubscribe.c\\n        ${m_src_dir}/keepalive.c\\n        ${m_src_dir}/logging.c\\n        ${m_src_dir}/loop.c\\n        ${m_src_dir}/memory_public.c\\n        ${m_src_dir}/mosquitto.c\\n        ${m_src_dir}/mux.c\\n        ${m_src_dir}/mux_epoll.c\\n        ${m_src_dir}/mux_poll.c\\n        ${m_src_dir}/password_mosq.c\\n        ${m_src_dir}/persist_read.c\\n        ${m_src_dir}/persist_read_v234.c\\n        ${m_src_dir}/persist_read_v5.c\\n        ${m_src_dir}/persist_write.c\\n        ${m_src_dir}/persist_write_v5.c\\n        ${m_src_dir}/property_broker.c\\n        ${m_src_dir}/read_handle.c\\n        ${m_src_dir}/retain.c\\n        ${m_src_dir}/security.c\\n        ${m_src_dir}/security_default.c\\n        ${m_src_dir}/send_auth.c\\n        ${m_src_dir}/send_connack.c\\n        ${m_src_dir}/send_suback.c\\n        ${m_src_dir}/send_unsuback.c\\n        ${m_src_dir}/service.c\\n        ${m_src_dir}/session_expiry.c\\n        ${m_src_dir}/signals.c\\n        ${m_src_dir}/subs.c\\n        ${m_src_dir}/sys_tree.c\\n        ${m_src_dir}/topic_tok.c\\n        ${m_src_dir}/websockets.c\\n        ${m_src_dir}/will_delay.c\\n        ${m_src_dir}/xtreport.c)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name for ESP-IDF\nDESCRIPTION: This snippet defines the project name using the `project()` command.  The name 'tls_client' is assigned to the project. This name is used for build artifacts and other project-related configurations. No dependencies are required. The output is the setting of the project name within the CMake build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/tls_client/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nproject(tls_client)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name with CMake\nDESCRIPTION: This snippet sets the name of the ESP-IDF project. It's used to identify the project during the build process and when creating the output binaries. The project name, \"console_basic\" in this example, can be customized to represent a project. This declaration is fundamental to the project's build, defining how it's recognized by the build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/examples/console_basic/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(console_basic)\n```\n\n----------------------------------------\n\nTITLE: Defining ESP32 Project Name in CMake\nDESCRIPTION: This snippet sets the project name to 'mdns_test'. This name is used throughout the build process to identify the project and is important for things like the generated output files. The name should be descriptive of the project. There are no specific dependencies.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/unit_test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nproject(mdns_test)\n```\n\n----------------------------------------\n\nTITLE: Registering MQTT Component with CMake in ESP-IDF\nDESCRIPTION: This code registers a component named 'esp_mqtt_cxx' with source files and include directories, and declares its dependency on the 'mqtt' component. It specifies the source file 'esp_mqtt_cxx.cpp' and includes headers from the 'include' directory. This setup ensures proper compilation and linkage within an ESP-IDF environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"esp_mqtt_cxx.cpp\"\\n                    INCLUDE_DIRS \"include\"\\n                    REQUIRES mqtt\\n                    )\n```\n\n----------------------------------------\n\nTITLE: Creating an Ethernet Interface via Console (Shell)\nDESCRIPTION: Demonstrates how to initialize an Ethernet PHY using `ifconfig eth init` (which discovers available Ethernet handles, here ID 0 using pins 23, 18) and then create a network interface associated with that handle using `ifconfig netif create 0` via the ESP-IDF console.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig eth init\nInternal(IP101): pins: 23,18, Id: 0\nesp> ifconfig netif create 0\n```\n\n----------------------------------------\n\nTITLE: Starting Mosquitto Broker in C\nDESCRIPTION: Function to start the Mosquitto broker. It runs in the calling thread and blocks until the broker exits. Takes a pointer to the configuration structure and returns an exit code.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/api.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint mosq_broker_run (\n    struct mosq_broker_config *config\n)\n```\n\n----------------------------------------\n\nTITLE: Registering IDF Component - CMake\nDESCRIPTION: This snippet uses the `idf_component_register` function to register an ESP-IDF component. It specifies the source files (`manual_ota.cpp` and `transport_batch_tls.cpp`), include directories (`.`), and private dependencies (`mbedtls_cxx`, `esp_http_client`, and `app_update`).  The `PRIV_REQUIRES` keyword indicates dependencies only needed internally by the component. This is a CMake function call that is essential for building an ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/components/manual_ota/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS manual_ota.cpp transport_batch_tls.cpp\n                       INCLUDE_DIRS \".\"\n                       PRIV_REQUIRES mbedtls_cxx esp_http_client app_update)\n```\n\n----------------------------------------\n\nTITLE: Removing Interface and Deinitializing Ethernet via Console (Shell)\nDESCRIPTION: Shows how to destroy a specific network interface (e.g., `en1` using `ifconfig netif destroy en1`), which triggers link down and stop events, and then deinitialize the underlying Ethernet PHY using `ifconfig eth deinit` through the ESP-IDF console.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig netif destroy en1\nI (8351266) ethernet_init: Ethernet(IP101[23,18]) Link Down\nI (8351266) ethernet_init: Ethernet(IP101[23,18]) Stopped\nesp> ifconfig eth deinit\n```\n\n----------------------------------------\n\nTITLE: Initialize and Start Console Commands in C\nDESCRIPTION: This C snippet initializes the console command component and registers the available commands within the `app_main` function. It shows the calls to initialize the console framework (`console_cmd_init`), register all linked plugin commands (`console_cmd_all_register`), or optionally register only the WiFi command (`console_cmd_wifi_register`), and finally starts the console task (`console_cmd_start`) to begin processing commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/README.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nESP_ERROR_CHECK(console_cmd_init());     // Initialize console\n\n// Register all plugin command added to your project\nESP_ERROR_CHECK(console_cmd_all_register());\n\n// To register only wifi command skip calling console_cmd_all_register()\nESP_ERROR_CHECK(console_cmd_wifi_register());\n\nESP_ERROR_CHECK(console_cmd_start());    // Start console\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with CMake\nDESCRIPTION: Registers an ESP-IDF component.  It specifies that `console_basic.c` is a source file and `.` is an include directory for the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/examples/console_basic/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"console_basic.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Specifying minimum CMake version\nDESCRIPTION: This line ensures that the CMake version used is at least 3.5, which is required for the build system and syntax compatibility.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n```\n\n----------------------------------------\n\nTITLE: Specify Minimum CMake Version (CMake)\nDESCRIPTION: Sets the minimum required version of CMake to build the project. This ensures compatibility with the build system and its features. Version 3.5 is typically required for ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version (CMake)\nDESCRIPTION: This line specifies the minimum version of CMake required to build the project. It ensures that the build system has the necessary features and commands available for the project configuration. A version of 3.16 or higher is required for modern ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/asio_chat/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Registering Component with IDF Build System in CMake - CMake\nDESCRIPTION: This snippet uses 'idf_component_register' to include 'asio_chat.cpp' as a source in the component and to define its include directory as the current folder. It requires ESP-IDF's build system and CMake. Parameters: 'SRCS' specifies the C++ source file; 'INCLUDE_DIRS' points to the header search path. The output is an ESP-IDF component ready for integration and compilation. Requires CMakeLists.txt structure and ESP-IDF environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/asio_chat/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"asio_chat.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering an ESP-IDF Component with C++ Source\nDESCRIPTION: This CMake command uses the `idf_component_register` function, specific to the ESP-IDF build system, to define a software component. It lists 'udp_mutual.cpp' under the SRCS argument, indicating it as the source file to be compiled for this component. The INCLUDE_DIRS argument adds the current directory ('.') to the include path, allowing source files within the component to find header files located in the same directory.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/udp_mutual_auth/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"udp_mutual.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component - CMake\nDESCRIPTION: This snippet registers an ESP-IDF component using the `idf_component_register` function. It specifies the source file `app_main.cpp` and includes the current directory (`.`) for header files. This ensures that the build system knows about the component and can compile it correctly. The main component file and include directories are essential parts of this process. There are no limitations on the size or content of the source files. This is a basic configuration and should be part of the project's CMakeLists.txt.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"app_main.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Source Files and Dependencies in CMake for ESP Protocols\nDESCRIPTION: This snippet determines the target platform (Linux or other), assigns appropriate source files, and dependencies for the ESP Protocols based on the build target. It ensures the correct platform-specific implementation is included during compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_build_get_property(target IDF_TARGET)\n\nif(${target} STREQUAL \"linux\")\n    set(platform_srcs src/esp_modem_primitives_linux.cpp\n        src/esp_modem_uart_linux.cpp\n        src/esp_modem_netif_linux.cpp)\n    set(dependencies esp_system_protocols_linux)\nelse()\n    set(platform_srcs src/esp_modem_primitives_freertos.cpp\n                      src/esp_modem_api_target.cpp\n                      src/esp_modem_uart.cpp\n                      src/esp_modem_term_uart.cpp\n                      src/esp_modem_netif.cpp)\n    set(dependencies driver esp_event esp_netif)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Wi-Fi Console Component Using CMake - CMake\nDESCRIPTION: This CMake snippet uses idf_component_register to define the Wi-Fi console component for ESP-IDF, specifying main source files, public include directories, and dependencies on lwip (public), and esp_netif, console, esp_wifi, and esp_timer (private). If CONFIG_WIFI_CMD_AUTO_REGISTRATION is set, it instructs the linker to force inclusion of the console_cmd_wifi_register symbol at link time. Requires ESP-IDF build environment and assumes corresponding source/header files and linked components are available.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"console_wifi.c\"\n                    INCLUDE_DIRS \"include\"\n                    REQUIRES lwip\n                    PRIV_REQUIRES esp_netif console esp_wifi esp_timer)\n\nif(CONFIG_WIFI_CMD_AUTO_REGISTRATION)\n    target_link_libraries(${COMPONENT_LIB} \"-u console_cmd_wifi_register\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Aggregating Source Files and Registering ESP Protocols Component in CMake\nDESCRIPTION: This snippet compiles all source files, including platform-specific and common sources, and registers the ESP Protocols component with include directories and dependencies. It also sets C++ standards and optional requirements based on build configurations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(srcs ${platform_srcs}\n        \"src/esp_modem_dte.cpp\"\n        \"src/esp_modem_dce.cpp\"\n        \"src/esp_modem_api.cpp\"\n        \"src/esp_modem_c_api.cpp\"\n        \"src/esp_modem_factory.cpp\"\n        \"src/esp_modem_cmux.cpp\"\n        \"src/esp_modem_command_library.cpp\"\n        \"src/esp_modem_term_fs.cpp\"\n        \"src/esp_modem_vfs_uart_creator.cpp\"\n        \"src/esp_modem_vfs_socket_creator.cpp\"\n        \"${command_dir}/src/esp_modem_modules.cpp\")\n\nidf_component_register(SRCS \"${srcs}\"\n                    INCLUDE_DIRS include ${command_dir}/include\n                    PRIV_INCLUDE_DIRS private_include\n                    REQUIRES ${dependencies})\n\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n\nif(CONFIG_ESP_MODEM_ADD_CUSTOM_MODULE)\n    idf_component_optional_requires(PUBLIC main)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Validating MQTT Broker Using a Provided CA Certificate\nDESCRIPTION: This command connects to a broker using SSL/TLS and verifies the broker's certificate with a user-provided CA certificate file. The '--cafile' flag should refer to a PEM-formatted CA certificate configured in the project. The broker URI must use 'mqtts://'. Output includes authentication and connection results.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nmqtt -h mqtts://test.mosquitto.org -C --cafile\n\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with SSL Files (CMake)\nDESCRIPTION: This CMake command registers an ESP-IDF component.  It specifies the source files, include directories, and files to embed within the component. The `SRCS` argument lists the source files, `INCLUDE_DIRS` specifies include directories, and `EMBED_TXTFILES` lists files to be embedded, which includes SSL related files (ca.crt, server.key, srv.crt). This is crucial for incorporating SSL functionality using asio library within the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"asio_ssl_main.cpp\"\n                    INCLUDE_DIRS \".\"\n        EMBED_TXTFILES ca.crt server.key srv.crt)\n```\n\n----------------------------------------\n\nTITLE: Conditional compile definitions based on exceptions and RTTI\nDESCRIPTION: This snippet conditionally defines compile definitions based on whether C++ exceptions and RTTI (Run-Time Type Identification) are enabled. If exceptions are disabled, `ASIO_NO_EXCEPTIONS` is defined. If RTTI is disabled, `ASIO_NO_TYPEID` is defined. These definitions prevent the compiler from generating code related to exceptions and RTTI.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT CONFIG_COMPILER_CXX_EXCEPTIONS)\n    target_compile_definitions(${COMPONENT_LIB} PUBLIC ASIO_NO_EXCEPTIONS)\nendif()\n\nif(NOT CONFIG_COMPILER_RTTI)\n    target_compile_definitions(${COMPONENT_LIB} PUBLIC ASIO_NO_TYPEID)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Code Coverage Build Options for ESP-IDF Components - CMake\nDESCRIPTION: This snippet configures compilation and linking options to enable code coverage using gcov if CONFIG_GCOV_ENABLED is defined. It applies the `--coverage`, `-fprofile-arcs`, and `-ftest-coverage` flags to both the current component and the esp_websocket_client dependency. ESP-IDF, CMake, and gcov support are required. This setup collects test coverage data to aid in quality assurance and prevents omission if code coverage is not needed.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_GCOV_ENABLED)\n    target_compile_options(${COMPONENT_LIB} PUBLIC --coverage -fprofile-arcs -ftest-coverage)\n    target_link_options(${COMPONENT_LIB} PUBLIC  --coverage -fprofile-arcs -ftest-coverage)\n\n    idf_component_get_property(esp_websocket_client esp_websocket_client COMPONENT_LIB)\n\n    target_compile_options(${esp_websocket_client} PUBLIC --coverage -fprofile-arcs -ftest-coverage)\n    target_link_options(${esp_websocket_client} PUBLIC  --coverage -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Command Directory and Registering ESP-IDF Component in CMake - CMake\nDESCRIPTION: This CMake snippet conditionally sets the 'command_dir' variable depending on whether the development mode flag is enabled, using the CMake 'if' statement and configuration variable. It registers an ESP-IDF component using 'idf_component_register' with 'SIM7070_gnss.cpp' as the source file, sets include directories, and marks 'esp_modem' as a required dependency. The 'set_target_properties' command applies C++17 standards to the component library, ensuring the use of modern C++ features. Inputs include project configuration flags and C++ source files; outputs are properly configured ESP-IDF build targets for further compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/simple_cmux_client/components/SIM7070_gnss/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_ESP_MODEM_ENABLE_DEVELOPMENT_MODE)\n    set(command_dir \"generate\")\nelse()\n    set(command_dir \"command\")\nendif()\n\nidf_component_register(SRCS \"SIM7070_gnss.cpp\"\n                    INCLUDE_DIRS \".\" \"${command_dir}\"\n                    PRIV_REQUIRES esp_modem)\n\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Client Handle in Event Handler - C\nDESCRIPTION: This example shows how to access the WebSocket client handle within an event handler. The client handle is passed as `handler_args` and cast to `esp_websocket_client_handle_t`.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nesp_websocket_client_handle_t client = (esp_websocket_client_handle_t)handler_args;\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from MQTT Broker using Console Command\nDESCRIPTION: This command disconnects the MQTT client from its currently connected broker using the '-D' flag. It is a simple flag-based command producing a log indicating successful client disconnection. The output will also reflect this in the application console log.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nesp> mqtt -D\nI (1189949) console_mqtt: mqtt client disconnected\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with Mutual TLS and DS Peripheral - C\nDESCRIPTION: This example demonstrates configuring the ESP WebSocket client for mutual TLS using the Digital Signature (DS) peripheral. It retrieves a client certificate and DS context using `esp_secure_cert_mgr` and sets `client_cert` and `client_ds_data` in the config struct.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nchar *client_cert = NULL;\nuint32_t client_cert_len = 0;\nesp_err_t err = esp_secure_cert_get_device_cert(&client_cert, &client_cert_len);\nassert(err == ESP_OK);\n\nesp_ds_data_ctx_t *ds_data = esp_secure_cert_get_ds_ctx();\nassert(ds_data != NULL);\n\nesp_websocket_client_config_t config = {\n    .uri = \"wss://echo.websocket.org\",\n    .cert_pem = (const char *)websocket_org_pem_start,\n    .client_cert = client_cert,\n    .client_ds_data = ds_data,\n};\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Source Files and Dependencies\nDESCRIPTION: This code registers a component within the ESP-IDF build system, specifying source files, required components, include directories, and private requirements. It sets up the build environment for the mDNS protocol implementation, ensuring dependencies like 'test_utils', 'unity', and 'mdns' are linked appropriately.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/unit_test/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS \"test_mdns.c\"\\n                       REQUIRES test_utils\\n                       INCLUDE_DIRS \".\"\\n                       PRIV_REQUIRES unity mdns)\n```\n\n----------------------------------------\n\nTITLE: Component Registration with Target Check (CMake)\nDESCRIPTION: This CMake snippet conditionally registers an ESP-IDF component based on the IDF_TARGET property. If the target is \"linux\", it registers esp_netif_linux.c as a source file, sets include directories, and specifies esp_event as a required component. Otherwise, it performs a default component registration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/host_test/components/esp_netif_linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_build_get_property(idf_target IDF_TARGET)\nif(${IDF_TARGET} STREQUAL \"linux\")\n    idf_component_register(SRCS esp_netif_linux.c\n                           INCLUDE_DIRS include $ENV{IDF_PATH}/components/esp_netif/include\n                           REQUIRES esp_event)\nelse()\n    idf_component_register()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining ESP-IDF Component Sources CMake\nDESCRIPTION: This snippet registers an ESP-IDF component using the `idf_component_register` CMake function. It includes several source files and sets one source directory (`${command_dir}`) conditionally based on the `CONFIG_ESP_MODEM_ENABLE_DEVELOPMENT_MODE` build configuration flag. If development mode is enabled, the directory is 'generate'; otherwise, it's 'command'. The component declares dependencies on 'console', 'esp_http_client', and 'nvs_flash' components using the `REQUIRES` keyword and specifies include directories.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_console/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_ESP_MODEM_ENABLE_DEVELOPMENT_MODE)\n    set(command_dir \"generate\")\nelse()\n    set(command_dir \"command\")\nendif()\n\nidf_component_register(SRCS \"modem_console_main.cpp\"\n                            \"console_helper.cpp\"\n                            \"${command_dir}/my_module_dce.cpp\"\n                            \"httpget_handle.c\"\n                            \"ping_handle.c\"\n                       REQUIRES console esp_http_client nvs_flash\n                       INCLUDE_DIRS \".\" \"${command_dir}\")\n```\n\n----------------------------------------\n\nTITLE: Example Serial Output from ESP32 WebSocket Client\nDESCRIPTION: Displays typical log output from the ESP32 WebSocket example application when run. It shows network connection establishment (Ethernet in this case), WebSocket connection success (`WEBSOCKET_EVENT_CONNECTED`), periodic sending of messages ('hello xxxx'), and receiving echoed data (`WEBSOCKET_EVENT_DATA`).\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/README.md#_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\nI (482) system_api: Base MAC address is not set, read default base MAC address from BLK0 of EFUSE\nI (2492) example_connect: Ethernet Link Up\nI (4472) tcpip_adapter: eth ip: 192.168.2.137, mask: 255.255.255.0, gw: 192.168.2.2\nI (4472) example_connect: Connected to Ethernet\nI (4472) example_connect: IPv4 address: 192.168.2.137\nI (4472) example_connect: IPv6 address: fe80:0000:0000:0000:bedd:c2ff:fed4:a92b\nI (4482) WEBSOCKET: Connecting to ws://echo.websocket.events...\nI (5012) WEBSOCKET: WEBSOCKET_EVENT_CONNECTED\nI (5492) WEBSOCKET: Sending hello 0000\nI (6052) WEBSOCKET: WEBSOCKET_EVENT_DATA\nW (6052) WEBSOCKET: Received=hello 0000\n\nI (6492) WEBSOCKET: Sending hello 0001\nI (7052) WEBSOCKET: WEBSOCKET_EVENT_DATA\nW (7052) WEBSOCKET: Received=hello 0001\n\nI (7492) WEBSOCKET: Sending hello 0002\nI (8082) WEBSOCKET: WEBSOCKET_EVENT_DATA\nW (8082) WEBSOCKET: Received=hello 0002\n\nI (8492) WEBSOCKET: Sending hello 0003\nI (9152) WEBSOCKET: WEBSOCKET_EVENT_DATA\nW (9162) WEBSOCKET: Received=hello 0003\n```\n\n----------------------------------------\n\nTITLE: Register ESP-IDF component with source files and dependencies in C\nDESCRIPTION: This code registers an ESP-IDF component called 'esp-protocols', specifying its source files, include directories, and dependencies, particularly requiring the 'unity' testing framework. It configures the build system to include these files and dependencies during compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/test_app/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS \"test_app_main.c\"\\n                       INCLUDE_DIRS \"\"\\n                       REQUIRES unity)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Dependencies (CMake)\nDESCRIPTION: This CMake snippet registers an ESP-IDF component. It specifies the source file `app_main.c`, the include directory '.', and declares `test_utils` as a required component.  Additionally, it declares `unity`, `nvs_flash`, `esp_netif`, `driver`, and `esp_event` as private required components, which are only needed during the compilation of this specific component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/test/test_app/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS app_main.c\n                    INCLUDE_DIRS \".\"\n                    REQUIRES test_utils\n                    PRIV_REQUIRES unity nvs_flash esp_netif driver esp_event)\n```\n\n----------------------------------------\n\nTITLE: Testing UDP Communication over SLIP with Netcat (Shell)\nDESCRIPTION: Uses the `nc` (netcat) utility to send UDP packets (`-u`) to the ESP device's IP address (`10.0.0.2`) on port `5678`. This tests the functionality of the SLIP connection and the UDP echo server implemented in the ESP-IDF example. Data typed into netcat will be sent, and echoed data received from the ESP will be displayed.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnc -u 10.0.0.2 5678\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Sources and Dependencies\nDESCRIPTION: This code registers an IDF component named (implicitly) with source files 'eppp_link.c', 'eppp_sdio_slave.c', and 'eppp_sdio_host.c'. It sets include directories and specifies private dependencies on other components such as 'esp_netif', 'esp_driver_spi', 'esp_driver_gpio', 'esp_timer', and 'driver'. It prepares the project to include these source files and dependencies during build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nidf_component_register(SRCS eppp_link.c eppp_sdio_slave.c eppp_sdio_host.c\n                    INCLUDE_DIRS \"include\"\n                    PRIV_REQUIRES esp_netif esp_driver_spi esp_driver_gpio esp_timer driver)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project CMake File\nDESCRIPTION: This snippet includes the project.cmake file from the ESP-IDF tools directory. This file provides the necessary build infrastructure for ESP-IDF projects.  The environment variable IDF_PATH must be set to the root directory of the ESP-IDF installation. The output is the incorporation of the ESP-IDF build system into the project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/tls_client/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Building the ESP-IDF ASIO Example\nDESCRIPTION: Command to build the ESP-IDF example project using the idf.py build tool. This command compiles the source code and links the necessary components for the target ESP32 device. No specific configuration is required before running this command.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/async_request/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py build\n```\n\n----------------------------------------\n\nTITLE: Setting SLIP Component Log Level in ESP-IDF (C)\nDESCRIPTION: Calls the ESP-IDF logging function `esp_log_level_set` to change the runtime log verbosity for the SLIP network interface component (`esp-netif_lwip-slip`). Setting the level to `ESP_LOG_DEBUG` enables detailed debug messages, which is useful for troubleshooting packet reception issues over the serial SLIP connection.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nesp_log_level_set(\"esp-netif_lwip-slip\", ESP_LOG_DEBUG);\n```\n\n----------------------------------------\n\nTITLE: Registering PPP Client Component with IDF\nDESCRIPTION: Uses the idf_component_register function to register a component with source files for Network DCE implementation, PPP client commands, and PPP IPERF main functionality.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"NetworkDCE.cpp\"\n                            \"cmd_pppclient.c\"\n                            \"pppd_iperf_main.c\")\n```\n\n----------------------------------------\n\nTITLE: Registering MQTT TCP Example Component with ESP-IDF\nDESCRIPTION: Registers a component in the ESP-IDF build system using idf_component_register. Specifies the C++ source file 'mqtt_tcp_example.cpp' and includes the current directory for header files.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/tcp/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"mqtt_tcp_example.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering Slip Client Component using ESP-IDF CMake build configuration\nDESCRIPTION: This snippet uses the idf_component_register CMake macro provided by ESP-IDF to register the slip_client component. It specifies the source file 'slip_client_main.c', the include directories as the current directory, and declares dependencies on esp_netif, slip_modem, and driver components. This declaration ensures the correct compilation and linking order in the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(\n    SRCS \"slip_client_main.c\"\n    INCLUDE_DIRS \".\"\n    REQUIRES esp_netif slip_modem driver\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional inclusion of SSL support files\nDESCRIPTION: This snippet conditionally includes SSL support files into the asio component based on the `CONFIG_ASIO_SSL_SUPPORT` configuration option. If SSL support is enabled, it appends additional source files and include directories related to mbedtls.  The `asio_priv_includes` variable is set to include the mbedtls headers.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_ASIO_SSL_SUPPORT)\n    list(APPEND asio_sources\n            \"port/src/asio_ssl_impl.cpp\"\n            \"port/mbedtls/src/mbedtls_context.cpp\"\n            \"port/mbedtls/src/mbedtls_engine.cpp\")\n    set(asio_priv_includes \"port/mbedtls/include\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Embedded Certificates (CMake)\nDESCRIPTION: This CMake script defines the source file (`lws-client.c`), include directory (`.`), and lists certificate/key files (`client_cert.pem`, `ca_cert.pem`, `client_key.pem`) to be embedded into the firmware. The `idf_component_register` function is used to register this component with the ESP-IDF build system, making these files available at runtime.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(SRC_FILES \"lws-client.c\") # Define source files\nset(INCLUDE_DIRS \".\") # Define include directories\nset(EMBED_FILES \"\") # Initialize an empty list for files to embed\n\nlist(APPEND EMBED_FILES\n    \"certs/client_cert.pem\"\n    \"certs/ca_cert.pem\"\n    \"certs/client_key.pem\")\n\nidf_component_register(SRCS \"${SRC_FILES}\"\n                       INCLUDE_DIRS \"${INCLUDE_DIRS}\"\n                       EMBED_TXTFILES \"${EMBED_FILES}\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component - CMake\nDESCRIPTION: This snippet registers an ESP-IDF component named `COMPONENT_LIB`. It specifies the source files (`esp_timer_linux.c`, `timer_task.cpp`), and include directories (`include`). The `idf_component_register` function is used to define the component's build details.  This action is necessary for the ESP-IDF build system to correctly compile and link the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/common_components/linux_compat/esp_timer/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS esp_timer_linux.c timer_task.cpp\n                       INCLUDE_DIRS include)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Project Component with MQTT and TLS Dependencies in CMake\nDESCRIPTION: Registers an ESP-IDF project component using the idf_component_register macro. It specifies the source file example_broker.c, private required components such as newlib, nvs_flash, esp_netif, esp_event, and mqtt. Additionally, it embeds TLS-related PEM certificate files (servercert.pem, serverkey.pem, cacert.pem) into the build. This registration facilitates building a secure MQTT broker example with required dependencies and embedded security credentials.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/broker/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"example_broker.c\"\\n                       PRIV_REQUIRES newlib nvs_flash esp_netif esp_event mqtt\\n                       EMBED_TXTFILES servercert.pem serverkey.pem cacert.pem)\n```\n\n----------------------------------------\n\nTITLE: Mutual SSL Authentication with Certificate and Key on MQTT Broker\nDESCRIPTION: These commands perform SSL/TLS connections requiring client-side certificate and private key along with broker validation, ensuring mutual authentication. It uses '--cert', '--key', and either '--cafile' or '--use-internal-bundle' flags. Prerequisites are correctly configured certificate/key files accessible per the project configuration. The broker should accept mutual authentication (for instance, test.mosquitto.org:8884). Input URIs should specify port 8884 for SSL mutual auth. Output logs indicate the success or failure of authentication steps.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nmqtt -h mqtts://test.mosquitto.org:8884 -C --cert --key --cafile\nmqtt -h mqtts://test.mosquitto.org:8884 -C --cert --key --use-internal-bundle\n\n```\n\n----------------------------------------\n\nTITLE: Conditional PPP Source Selection in CMake\nDESCRIPTION: Sets up PPP connection source files with conditional inclusion based on the CONFIG_EXAMPLE_PPP_CONNECT_ESP_MODEM configuration flag. If the flag is enabled, it includes the ESP-Modem implementation; otherwise, it includes a simpler implementation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/multiple_netifs/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(ppp_connect_srcs ppp_connect.c)\nif(CONFIG_EXAMPLE_PPP_CONNECT_ESP_MODEM)\n    list(APPEND ppp_connect_srcs ppp_connect_esp_modem.c)\nelse()\n    list(APPEND ppp_connect_srcs ppp_connect_simple.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditionally Setting Network DCE Source File (CMake)\nDESCRIPTION: This snippet conditionally sets the NETWORK_DCE variable to either \"network_dce.cpp\" or \"network_dce.c\" depending on the value of CONFIG_EXAMPLE_USE_MINIMAL_DCE. This determines which source file will be included in the component's compilation. The output is the definition of a variable that determines which source file to use.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_EXAMPLE_USE_MINIMAL_DCE)\n    set(NETWORK_DCE \"network_dce.cpp\")\nelse()\n    set(NETWORK_DCE \"network_dce.c\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with idf_component_register in CMake\nDESCRIPTION: Registers an ESP-IDF component for the build system using idf_component_register, specifying the C++ source file \"echo_server.cpp\" and the current directory as the include directory. This setup enables the build system to compile and link the component correctly. There are no additional dependencies specified in this snippet.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/tcp_echo_server/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"echo_server.cpp\"\\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering Socket Utility Component in ESP-IDF\nDESCRIPTION: Registers socket utility source files with the ESP-IDF build system and configures include paths and dependencies. The component implements network functions like getnameinfo, ifaddrs, gai_strerror, socketpair, and gethostname.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"src/getnameinfo.c\"\n                            \"src/ifaddrs.c\"\n                            \"src/gai_strerror.c\"\n                            \"src/socketpair.c\"\n                            \"src/gethostname.c\"\n                       INCLUDE_DIRS \"include\"\n                       PRIV_REQUIRES lwip esp_netif)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Configuration with CMake\nDESCRIPTION: This line includes the project configuration file from the ESP-IDF installation. It imports the necessary CMake scripts and settings to configure the project correctly. The `IDF_PATH` environment variable points to the ESP-IDF installation directory. This step makes available the ESP-IDF specific features, such as the device configuration and build targets.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/examples/console_basic/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Registering Component Source Files and Includes (CMake)\nDESCRIPTION: This code registers the source files for the component, including \"ap_to_pppos.c\" and the file determined by the NETWORK_DCE variable. It also specifies the include directories. The output is registration of a component for the project's compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"ap_to_pppos.c\"\n                            ${NETWORK_DCE}\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Defining Extra Component Directories in ESP32 Project\nDESCRIPTION: This snippet sets the `EXTRA_COMPONENT_DIRS` variable to include the parent directory and a component directory from the IDF path. This is used by the project to find additional components that are used by the test project. The dependencies are the IDF path and the directory structure of the ESP32 project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/unit_test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EXTRA_COMPONENT_DIRS ../.. \"$ENV{IDF_PATH}/tools/unit-test-app/components\")\n```\n\n----------------------------------------\n\nTITLE: Installing Homebrew and LLVM on macOS for AFL (Bash)\nDESCRIPTION: Provides commands to install the Homebrew package manager, install a specific version of LLVM (<= 4.0 recommended) with Clang/LLD support, and update the system PATH environment variable on macOS. These steps are prerequisites for compiling AFL.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nbrew install --with-clang --with-lld --HEAD llvm\nexport PATH=\"/usr/local/opt/llvm/bin:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component Sources and Dependencies (CMake)\nDESCRIPTION: This CMake command registers the source files ('pppd_test.cpp', 'NetworkDCE.cpp') that make up the ESP-IDF component. It also specifies that this component requires the 'esp_modem' and 'catch2' components to be available during the build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"pppd_test.cpp\"\n                            \"NetworkDCE.cpp\"\n                       REQUIRES esp_modem catch2)\n```\n\n----------------------------------------\n\nTITLE: Registering libwebsockets Component with mbedTLS Dependency in CMake\nDESCRIPTION: This snippet registers the current component to require 'mbedtls' as a dependency using the ESP-IDF 'idf_component_register' macro. It ensures that the mbedtls component is built and linked properly with the current component, essential for enabling secure socket communications.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(REQUIRES mbedtls)\n```\n\n----------------------------------------\n\nTITLE: Registering Component with Embedded Certificates - ESP-IDF - CMake\nDESCRIPTION: This snippet registers an ESP-IDF component using the 'idf_component_register' macro in CMake, embedding several certificate and key files (srv.crt, srv.key, ca.crt, client.crt, client.key) and specifying the current directory as the include path. It lists 'mbedtls_cxx' as a required dependency, indicating dependence on the Mbed TLS C++ wrapper. The included certificates are pre-requisites for applications involving TLS communications. Inputs are the specified certificate files, and outputs are the embedded resources in the compiled binary. Requires ESP-IDF CMake build environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/test_certs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(\n        EMBED_TXTFILES srv.crt\n        EMBED_TXTFILES srv.key\n        EMBED_TXTFILES ca.crt\n        EMBED_TXTFILES client.crt\n        EMBED_TXTFILES client.key\n        INCLUDE_DIRS \".\"\n        REQUIRES mbedtls_cxx)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component Sources and Includes with CMake\nDESCRIPTION: This CMake command utilizes the ESP-IDF helper function `idf_component_register` to specify the source files (SRCS) and include directories (INCLUDE_DIRS) required for building the current component. It registers `mdns_example_main.c` as the source file and adds the component's root directory (`.`) to the include paths.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"mdns_example_main.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Including Project CMake File\nDESCRIPTION: Includes the project.cmake file from the ESP-IDF tools directory. This file contains essential functions and configurations for building ESP-IDF projects, such as component registration and dependency management. IDF_PATH environment variable is used to locate the path.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Setting source files and dependencies for asio\nDESCRIPTION: This snippet defines the source files and dependencies for the asio component. It specifies the core asio source files and the lwip and sock_utils dependencies. The `asio_requires` variable defines the component's dependencies.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(asio_sources \"asio/asio/src/asio.cpp\" \"port/src/asio_stub.cpp\")\nset(asio_requires lwip sock_utils)\n```\n\n----------------------------------------\n\nTITLE: Querying mDNS Service by Type - C\nDESCRIPTION: This code queries for an mDNS service using `mdns_query_ptr`. It takes the service name and protocol as input. The function prints query results using the `mdns_print_results` helper function and frees the allocated memory using `mdns_query_results_free`. Error handling includes checking for query failures and if no results are found. The output is the service's information, including its hostname, port, and any associated TXT records.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nvoid find_mdns_service(const char * service_name, const char * proto)\n{\n    ESP_LOGI(TAG, \"Query PTR: %s.%s.local\", service_name, proto);\n\n    mdns_result_t * results = NULL;\n    esp_err_t err = mdns_query_ptr(service_name, proto, 3000, 20,  &results);\n    if(err){\n        ESP_LOGE(TAG, \"Query Failed\");\n        return;\n    }\n    if(!results){\n        ESP_LOGW(TAG, \"No results found!\");\n        return;\n    }\n\n    mdns_print_results(results);\n    mdns_query_results_free(results);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required CMake version for the project. Ensures that the CMake version used to build the project is at least 3.16, which is necessary for compatibility with ESP-IDF.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/ssl/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project CMake Module\nDESCRIPTION: Includes the main ESP-IDF CMake module from the environment's IDF_PATH, which provides necessary build functions and configurations for ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version - ESP-IDF\nDESCRIPTION: This line specifies the minimum CMake version required to build the project. It ensures that the CMake version used is at least 3.16, which is necessary for ESP-IDF compatibility.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/examples/ping-basic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Building and Flashing ESP-IDF Project Using Shell Command\nDESCRIPTION: This snippet shows the shell command for building, flashing, and monitoring the ESP-IDF project on an ESP platform board. The command uses `idf.py` with parameters for specifying the serial port (`-p PORT`) and executes the `flash` and `monitor` targets. It is typically run after configuring the project and connecting the device for deploying the example application.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -p PORT flash monitor\n```\n\n----------------------------------------\n\nTITLE: Building mDNS Tests without AFL Instrumentation (GCC) (Bash)\nDESCRIPTION: Navigates to the mDNS AFL test directory and builds the tests using the standard GCC compiler by passing `INSTR=off` to make. This configuration is useful for checking compilation or reproducing specific issues found during fuzzing without running AFL.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ncd $IDF_PATH/components/mdns/test_afl_host\nmake INSTR=off\n```\n\n----------------------------------------\n\nTITLE: Run MQTT Project with idf.py monitor\nDESCRIPTION: This command executes the compiled MQTT project and starts a monitor session using the ESP-IDF build system.  It enables real-time logging and debugging by capturing standard output from the application. This avoids needing to flash anything.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nidf.py monitor\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component\nDESCRIPTION: This snippet registers the ESP-IDF component, specifying source files, include directories, private include directories, and required components. It lists the source files for the component, including `esp_netif_linux.cpp`, `tun_io.c`, `ip4_stub.c`, `ip6_stub.c`, files from `lwipnoapps_SRCS` and `lwipcontribportunix_SRCS`. It defines include directories and specifies that the component requires `esp_system_protocols_linux`.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_netif_linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS esp_netif_linux.cpp tun_io.c ip4_stub.c ip6_stub.c ${lwipnoapps_SRCS} ${lwipcontribportunix_SRCS}\n                       INCLUDE_DIRS include ${LWIP_INCLUDE_DIRS}\n                       PRIV_INCLUDE_DIRS .\n                       REQUIRES esp_system_protocols_linux)\n```\n\n----------------------------------------\n\nTITLE: Receiving MQTT Data Events via Console Output\nDESCRIPTION: This output example shows the serial console log produced when the device receives a message on a subscribed MQTT topic. The log contains event type (MQTT_EVENT_DATA), topic name, and the payload. No parameters or command inputs; shown for demonstration of message reception in the console.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nesp> I (999999) console_mqtt: MQTT_EVENT_DATA\nI (999999) console_mqtt: TOPIC=test0\n\nI (999999) console_mqtt: DATA=Hello, Testing 123\n\n```\n\n----------------------------------------\n\nTITLE: Using `ifconfig` Console Commands (Shell)\nDESCRIPTION: Provides a reference list of supported `ifconfig` commands available through the ESP-IDF console. These commands allow runtime configuration and monitoring of network interfaces, including creating/destroying interfaces, managing Ethernet handles, setting IP addresses (IPv4/IPv6), enabling/disabling DHCP, NAPT, link status, and setting the default interface. Use `ifconfig help` for details on specific commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n ifconfig help: Prints the help text for all ifconfig commands\n ifconfig netif create/destroy <ethernet handle id>/<iface>: Create or destroy a network interface with the specified ethernet handle or interface name\n ifconfig eth init/deinit/show: Initialize, deinitialize and display a list of available ethernet handle\n ifconfig: Display a list of all esp_netif interfaces along with their information\n ifconfig <iface>: Provide the details of the named interface\n ifconfig <iface> default: Set the specified interface as the default interface\n ifconfig <iface> ip6: Enable IPv6 on the specified interface\n ifconfig <iface> up: Enable the specified interface\n ifconfig <iface> down: Disable the specified interface\n ifconfig <iface> link <up/down>: Enable or disable the link of the specified interface\n ifconfig <iface> napt <enable/disable>: Enable or disable NAPT on the specified interface.\n ifconfig <iface> ip <ipv4 addr>: Set the IPv4 address of the specified interface\n ifconfig <iface> mask <ipv4 addr>: Set the subnet mask of the specified interface\n ifconfig <iface> gw <ipv4 addr>: Set the default gateway of the specified interface\n ifconfig <iface> staticip: Enables static ip\n ifconfig <iface> dhcp server <enable/disable>: Enable or disable the DHCP server.(Note: DHCP server is not supported yet)\n ifconfig <iface> dhcp client <enable/disable>: Enable or disable the DHCP client.\nNote: Disabling the DHCP server and client enables the use of static IP configuration.\n```\n\n----------------------------------------\n\nTITLE: Disabling macOS Crash Reporter for AFL (Bash)\nDESCRIPTION: Provides `launchctl` commands to disable the default macOS crash reporting services (user and system levels). This is recommended as the crash reporter can interfere with AFL's process monitoring and fuzzing operation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nlaunchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist\nsudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist\n```\n\n----------------------------------------\n\nTITLE: Printing mDNS Query Results - C\nDESCRIPTION: This code defines a function `mdns_print_results` that iterates through a linked list of `mdns_result_t` structures to print the results of an mDNS query. It displays interface information, PTR records, SRV records, TXT records, and IP addresses (A and AAAA records).  It handles both IPv4 and IPv6 addresses. This function is designed to format and display the query results obtained from mDNS queries. It's a helper function for displaying results from queries.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstatic const char * if_str[] = {\"STA\", \"AP\", \"ETH\", \"MAX\"};\nstatic const char * ip_protocol_str[] = {\"V4\", \"V6\", \"MAX\"};\n\nvoid mdns_print_results(mdns_result_t * results){\n    mdns_result_t * r = results;\n    mdns_ip_addr_t * a = NULL;\n    int i = 1, t;\n    while(r){\n        printf(\"%d: Interface: %s, Type: %s\\n\", i++, if_str[r->tcpip_if], ip_protocol_str[r->ip_protocol]);\n        if(r->instance_name){\n            printf(\"  PTR : %s\\n\", r->instance_name);\n        }\n        if(r->hostname){\n            printf(\"  SRV : %s.local:%u\\n\", r->hostname, r->port);\n        }\n        if(r->txt_count){\n            printf(\"  TXT : [%u] \", r->txt_count);\n            for(t=0; t<r->txt_count; t++){\n                printf(\"%s=%s; \", r->txt[t].key, r->txt[t].value);\n            }\n            printf(\"\\n\");\n        }\n        a = r->addr;\n        while(a){\n            if(a->addr.type == IPADDR_TYPE_V6){\n                printf(\"  AAAA: \" IPV6STR \"\\n\", IPV62STR(a->addr.u_addr.ip6));\n            } else {\n                printf(\"  A   : \" IPSTR \"\\n\", IP2STR(&(a->addr.u_addr.ip4)));\n            }\n            a = a->next;\n        }\n        r = r->next;\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Using the 'getdnsserver' Console Command\nDESCRIPTION: Shows the usage of the `getdnsserver` command in the ESP-IDF console. Executing this command retrieves and displays the currently configured DNS server settings on the device.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\ngetdnsserver\n```\n\n----------------------------------------\n\nTITLE: Starting Mosquitto Broker Instance using ESP32 C SDK\nDESCRIPTION: This C snippet demonstrates invoking the mosq_broker_run() function in the ESP32 Mosquitto port to launch the MQTT broker within the context of the calling task. The function requires a pointer to a configuration structure specifying options such as transport type and listener configuration. The broker does not spawn a separate task, so adequate stack size should be allocated, typically at least 4kB. Dependencies include the ESP32 C development environment and the relevant ESP-TLS library if TLS transport is desired. Inputs: a properly initialized config structure; Output: the broker runs and processes network events.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nmosq_broker_run(&config);\n```\n\n----------------------------------------\n\nTITLE: Conditional Linking of External Resolve Hook for LwIP in CMake\nDESCRIPTION: This CMake snippet conditionally links the 'lwip_hook_netconn_external_resolve' library to the component if the configuration option 'CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM' is enabled. It uses the 'target_link_libraries' command with the '-u' flag to ensure the symbol is included in the final build, enabling a custom external DNS resolve hook in LwIP networking stack.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM)\n    target_link_libraries(${COMPONENT_LIB} \"-u lwip_hook_netconn_external_resolve\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Sending Text Data - C++\nDESCRIPTION: This snippet demonstrates how to send text data over a WebSocket connection using the `esp_websocket_client_send_text` function. It takes the client handle, data pointer, data length, and FreeRTOS tick timeout as parameters.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nesp_websocket_client_send_text(client, data, len, portMAX_DELAY);\n```\n\n----------------------------------------\n\nTITLE: Configuring ESP-IDF Project for Linux Modem using CMake (CMake)\nDESCRIPTION: This CMake configuration snippet sets up an ESP-IDF project for the 'linux_modem' target. It specifies the minimum CMake version, includes ESP-IDF project tooling via an environment variable, appends an extra component directory for Linux porting, and defines the project's main component. Importantly, it retrieves the 'esp_modem' component and applies two compile-time definitions to enable C++ exception support and specify the Linux IDF target. Required dependencies include ESP-IDF (with its CMake toolchain) and the appropriate environment variables (IDF_PATH) set. Inputs include component lists and environment configurations; outputs are build targets prepared for subsequent compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/linux_modem/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n\nset(EXTRA_COMPONENT_DIRS ../../port/linux)\n\nset(COMPONENTS main)\nproject(linux_modem)\n\n\nidf_component_get_property(esp_modem esp_modem COMPONENT_LIB)\ntarget_compile_definitions(${esp_modem} PRIVATE \"-DCONFIG_COMPILER_CXX_EXCEPTIONS\")\ntarget_compile_definitions(${esp_modem} PRIVATE \"-DCONFIG_IDF_TARGET_LINUX\")\n```\n\n----------------------------------------\n\nTITLE: Example Console Output of Asio SSL Server and Client via Loopback (Log)\nDESCRIPTION: This snippet provides an example log output showing the ESP device running both Asio SSL server and client simultaneously using the loopback interface. It illustrates system initialization messages, heap memory allocation, scheduler startup, as well as server receiving and replying to the client's HTTP request. This demonstrates local communications without external network connectivity.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/README.md#_snippet_2\n\nLANGUAGE: Log\nCODE:\n```\nI (0) cpu_start: App cpu up.\nI (495) heap_init: Initializing. RAM available for dynamic allocation:\nI (502) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM\nI (508) heap_init: At 3FFB5400 len 0002AC00 (171 KiB): DRAM\nI (515) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM\nI (521) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM\nI (527) heap_init: At 4008BB80 len 00014480 (81 KiB): IRAM\nI (534) cpu_start: Pro cpu start user code\nI (556) spi_flash: detected chip: gd\nI (556) spi_flash: flash io: dio\nW (556) spi_flash: Detected size(4096k) larger than the size in the binary image header(2048k). Using the size in the binary image header.\nI (566) cpu_start: Starting scheduler on PRO CPU.\nI (0) cpu_start: Starting scheduler on APP CPU.\nI (600) example_connect: Waiting for IP(s)\nW (600) esp32_asio_pthread: pthread_condattr_setclock: not yet supported!\nW (1610) esp32_asio_pthread: pthread_condattr_setclock: not yet supported!\nW (1610) esp32_asio_pthread: pthread_condattr_setclock: not yet supported!\nServer received: GET / HTTP/1.1\n\n\nReply: GET / HTTP/1.1\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for ESP-IDF CMUX Client Project\nDESCRIPTION: Minimal CMake configuration required for an ESP-IDF project, specifically for a simple CMUX client. It sets the minimum CMake version to 3.8, specifies C++17 as the standard, includes the ESP-IDF project cmake file, and names the project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/simple_cmux_client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The following lines of boilerplate have to be in your project's CMakeLists\n# in this exact order for cmake to work correctly\ncmake_minimum_required(VERSION 3.8)\nset(CMAKE_CXX_STANDARD 17)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(simple_cmux_client)\n```\n\n----------------------------------------\n\nTITLE: Creating a NetDCE Factory for Custom Network Module\nDESCRIPTION: This snippet showcases the implementation of a factory class for creating network DCE modules, supporting modular and flexible network interface instantiation. The factory can generate instances of the minimal or supported DCE modules, enabling plug-and-play configurability aligned with the network setup required for the ESP protocol example.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/README.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Factory class for creating network DCE instances\nclass NetDCE_Factory {\npublic:\n    static std::shared_ptr<ModuleIf> create(net_interface_type type);\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring lwip Component for Socket Extensions in ESP-IDF\nDESCRIPTION: Enables socketpair and gai_strerror functionality in the lwip component by setting compile definitions and establishing a dependency link. This ensures that standard socket header declarations work properly with the socket utility implementations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_get_property(lwip lwip COMPONENT_LIB)\ntarget_compile_definitions(${lwip} PUBLIC LWIP_SOCKET_HAS_SOCKETPAIR=1)\ntarget_compile_definitions(${lwip} PUBLIC LWIP_NETDB_HAS_GAI_STRERROR=1)\ntarget_link_libraries(${lwip} PUBLIC ${COMPONENT_LIB})\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Configuration\nDESCRIPTION: This snippet includes the project.cmake file from the ESP-IDF framework. This file contains the necessary configurations and functions for building an ESP32 project using ESP-IDF. It relies on the IDF_PATH environment variable being set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component Source and Includes (CMake)\nDESCRIPTION: Registers the `test_sock_utils.cpp` source file and adds the IDF tools directory (`$ENV{IDF_PATH}/tools`) to the include paths for the current ESP-IDF component using the `idf_component_register` function. The `WHOLE_ARCHIVE` flag ensures all symbols from the object file are included in the final static library, which can be necessary for linker features like AddressSanitizer.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/test/host/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"test_sock_utils.cpp\"\n                        INCLUDE_DIRS \"$ENV{IDF_PATH}/tools\"\n                        WHOLE_ARCHIVE)\n```\n\n----------------------------------------\n\nTITLE: Define ESP-IDF Project Name (CMake)\nDESCRIPTION: Sets the name of the CMake project. This is a fundamental step in any CMake project and is used by the build system to identify the project and influence the naming of build artifacts. The provided name 'uart_mutual' is specific to this example project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/tests/uart_mutual_auth/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(uart_mutual)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project with ESP-IDF (CMake)\nDESCRIPTION: This snippet sets the minimum required CMake version (3.16), defines the components to be built (only \"main\" in this case), includes the standard ESP-IDF project infrastructure provided by `project.cmake`, and finally names the project `sock_utils_host_test`. It is the standard entry point for an ESP-IDF application's build definition.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/test/host/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nset(COMPONENTS main)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n\nproject(sock_utils_host_test)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Initializing MQTT Console Commands in ESP-IDF\nDESCRIPTION: This snippet explains how to include and initialize the MQTT console component within an ESP-IDF project. It guides on dependency addition, including the header file, initializing network interfaces, and starting the console command interface to enable MQTT command execution through the ESP-IDF console. The process ensures that MQTT commands can be issued via the serial or telnet interface for debugging or control purposes.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"console_mqtt.h\"\n\n// Initialize network interfaces and event loop\nESP_ERROR_CHECK(esp_netif_init());\nESP_ERROR_CHECK(esp_event_loop_create_default());\n\n// Initialize console commands for MQTT\nESP_ERROR_CHECK(console_cmd_init());\nESP_ERROR_CHECK(console_cmd_all_register()); // or console_cmd_mqtt_register();\nESP_ERROR_CHECK(console_cmd_start());\n```\n\n----------------------------------------\n\nTITLE: Build and Flash ESP32 Project: IDF Command\nDESCRIPTION: This snippet provides the IDF command to build, flash, and monitor the ESP32 project. It uses the `-B` flag to specify a separate build directory, and `-D` flag to specify the SDK configuration for different device roles (PEER1 and PEER2). The `menuconfig` target allows configuration of the project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nidf.py -B build1 -DSDKCONFIG=build1/sdkconfig menuconfig build flash monitor\n```\n\n----------------------------------------\n\nTITLE: Configuring libwebsockets Build Options in CMake\nDESCRIPTION: This snippet configures libwebsockets CMake cache options including disabling export of CMake targets to avoid conflicts, enabling mbedTLS support instead of OpenSSL, and disabling the JPEG decoder. These settings control optional features and dependencies to customize the build behavior of libwebsockets within the ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(LWS_WITH_EXPORT_LWSTARGETS OFF CACHE BOOL \"Export libwebsockets CMake targets.  Disable if they conflict with an outer cmake project.\")\nset(LWS_WITH_MBEDTLS ON CACHE BOOL \"Use mbedTLS (>=2.0) replacement for OpenSSL.\")\nset(LWS_WITH_JPEG OFF CACHE BOOL \"Enable stateful JPEG stream decoder\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component using CMake\nDESCRIPTION: This snippet uses the `idf_component_register` macro to register an ESP-IDF component. It defines the source files (`SRCS`), include directories (`INCLUDE_DIRS`), and required components (`REQUIRES`) for the component to build correctly. This ensures that the necessary dependencies are linked and available during compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/host_test/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"main.c\"\n                    INCLUDE_DIRS\n                    \".\"\n                    REQUIRES mdns console nvs_flash)\n```\n\n----------------------------------------\n\nTITLE: Performing mDNS Queries and Parsing Responses in ESP-IDF\nDESCRIPTION: This code demonstrates how to perform DNS-SD mDNS queries for services and hosts, and interpret the response data, including Service PTR, SRV, and A records. It allows discovering network services and hosts dynamically, integrating with the mDNS responder. Dependencies include the mDNS API functions and response parsing utilities.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nvoid perform_mdns_query(const char* service_name) {\\n    mdns_query_t query;\\n    memset(&query, 0, sizeof(query));\\n    query.type = MDNS_TYPE_PTR;\\n    strcpy(query.name, service_name);\\n    esp_err_t err = mdns_query(&query);\\n    if (err != ESP_OK) {\\n        ESP_LOGW(\"mdns\", \"Query failed: %d\", err);\\n        return;\\n    }\\n    // Parse and handle the received response records\\n    // (Implementation depends on mdns_response parsing methods)\\n}\\n// Example usage: discover '_http._tcp' services\\nperform_mdns_query(\"_http._tcp.local\");\n```\n\n----------------------------------------\n\nTITLE: Configuring IP Addresses for SLIP Interface on Linux (Shell)\nDESCRIPTION: Uses the `ifconfig` command to assign an IP address (`10.0.0.1`) to the SLIP interface (`sl0`) created by `slattach`. It also sets the destination (peer) IP address (`10.0.0.2`), which should correspond to the IP address configured on the ESP device running the SLIP client example. This establishes the point-to-point link configuration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nifconfig sl0 10.0.0.1 dstaddr 10.0.0.2\n```\n\n----------------------------------------\n\nTITLE: Configuring Threading Support and C++17 Standard in ESP-IDF Component - CMake\nDESCRIPTION: This block configures the CMake build to prefer the pthread threading model, locates the system Threads package, and links it privately to the component library. It also enforces C++17 compliance by setting compiler properties and ensures Linux-targeted compilation using the CONFIG_IDF_TARGET_LINUX definition. The snippet is essential for cross-platform compatibility and leveraging advanced C++ features; dependencies are CMake 3.13+, Threads package, and an environment supporting pthreads and C++17 compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/linux_modem/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(THREADS_PREFER_PTHREAD_FLAG ON)\nfind_package(Threads REQUIRED)\ntarget_link_libraries(${COMPONENT_LIB}  PRIVATE Threads::Threads)\n\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\ntarget_compile_definitions(${COMPONENT_LIB} PRIVATE \"-DCONFIG_IDF_TARGET_LINUX\")\n```\n\n----------------------------------------\n\nTITLE: Registering libjuice as an ESP-IDF Component in CMake\nDESCRIPTION: This snippet collects relevant source files for 'libjuice', adds them (with native replacements for crypto and randomness), and registers the component for build integration in ESP-IDF using 'idf_component_register'. It specifies include directories and required dependencies ('esp_netif', 'sock_utils'), sets component-specific compiler options, and suppresses certain warnings on UDP sources. Inputs include previously defined 'JUICE_SOURCES'; outputs are the compiled component, with dependencies enforced and sources adjusted for ESP platform constraints.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/components/libjuice/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(JUICE_SOURCES   ${libjuice_dir}/src/addr.c\n                    ${libjuice_dir}/src/agent.c\n                    ${libjuice_dir}/src/base64.c\n                    ${libjuice_dir}/src/conn.c\n                    ${libjuice_dir}/src/conn_mux.c\n                    ${libjuice_dir}/src/conn_poll.c\n                    ${libjuice_dir}/src/conn_thread.c\n                    ${libjuice_dir}/src/const_time.c\n                    ${libjuice_dir}/src/crc32.c\n                    ${libjuice_dir}/src/hash.c\n                    ${libjuice_dir}/src/ice.c\n                    ${libjuice_dir}/src/juice.c\n                    ${libjuice_dir}/src/log.c\n                    ${libjuice_dir}/src/server.c\n                    ${libjuice_dir}/src/stun.c\n                    ${libjuice_dir}/src/timestamp.c\n                    ${libjuice_dir}/src/turn.c\n                    ${libjuice_dir}/src/udp.c\n# Use hmac from mbedtls and random numbers from esp_random:\n#                    ${libjuice_dir}/src/hmac.c\n#                    ${libjuice_dir}/src/random.c\n        )\n\nidf_component_register(SRCS     port/juice_random.c\n                                ${JUICE_SOURCES}\n                       INCLUDE_DIRS \"include\"  \"${libjuice_dir}/include\" \"${libjuice_dir}/include/juice\"\n                       REQUIRES esp_netif\n                       PRIV_REQUIRES sock_utils)\n\ntarget_compile_options(${COMPONENT_LIB} PRIVATE \"-Wno-format\")\nset_source_files_properties(${libjuice_dir}/src/udp.c PROPERTIES COMPILE_FLAGS -Wno-unused-variable)\n```\n\n----------------------------------------\n\nTITLE: Linking against mbedtls library\nDESCRIPTION: This snippet conditionally links the asio component against the mbedtls library if SSL support is enabled. It retrieves the mbedtls component library using `idf_component_get_property` and then links it to the asio component using `target_link_libraries`. This ensures that the asio component can use the mbedtls library for SSL/TLS functionality.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_ASIO_SSL_SUPPORT)\n        idf_component_get_property(mbedtls mbedtls COMPONENT_LIB)\n        target_link_libraries(${COMPONENT_LIB} PUBLIC ${mbedtls})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Plugin Command Registration Section Descriptor in ESP-IDF (C)\nDESCRIPTION: Registers a new console command plugin by placing its descriptor into the .console_cmd_desc linker section for automatic discovery. The PLUGIN struct includes the command name and a pointer to the registration function. Must be added to each new component's main file. Requires that the component's CMakeLists.txt uses WHOLE_ARCHIVE to include the required section. Inputs: command name and registration function pointer. Outputs: command available for automatic registration. Limitation: correct section and flag placement required for successful plugin registration.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstatic const console_cmd_plugin_desc_t __attribute__((section(\".console_cmd_desc\"), used)) PLUGIN = {\n    .name = \"cmd_name_string\",\n    .plugin_regd_fn = &cmd_registration_function\n};\n```\n\n----------------------------------------\n\nTITLE: Example Output (Console)\nDESCRIPTION: This snippet provides example console output from the MQTT broker application. It displays informational messages, including the broker version, connection details, and MQTT events such as connection, subscription, publishing, and data reception. This allows users to understand the flow of execution and verify the correctness of the broker's operations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/broker/README.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nI (477) main_task: Calling app_main()\n0: mosquitto version 0.1.0 starting\n0: Using default config.\n0: Opening ipv4 listen socket on port 1883.\n0: mosquitto version 0.1.0 running\nI (1507) test: Other event id:7\n1: New connection from 127.0.0.1:56424 on port 1883.\n1: New client connected from 127.0.0.1:56424 as ESP32_d58788 (p2, c1, k120).\nI (1528) mqtt_broker: MQTT_EVENT_CONNECTED\nI (1528) mqtt_broker: sent subscribe successful, msg_id=54859\nI (1538) mqtt_broker: MQTT_EVENT_SUBSCRIBED, msg_id=54859\nI (1538) mqtt_broker: sent publish successful, msg_id=0\nI (1548) mqtt_broker: MQTT_EVENT_DATA\nI (1548) mqtt_broker: TOPIC=/topic/qos0\nI (1548) mqtt_broker: DATA=data\n```\n\n----------------------------------------\n\nTITLE: Setting Static IP, Mask, and Gateway via Console (Shell)\nDESCRIPTION: Shows the sequence of commands to configure a static IPv4 address (192.168.5.2), subnet mask (255.255.255.0), and default gateway (192.168.5.1) for a network interface (`en1`) using the `ifconfig <iface> ip <addr>`, `ifconfig <iface> mask <addr>`, and `ifconfig <iface> gw <addr>` commands. This requires the DHCP client to be disabled first.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nesp> ifconfig en1 ip 192.168.5.2\nI (111466) console_ifconfig: Setting ip: 192.168.5.2\nesp> ifconfig en1 mask 255.255.255.0\nI (130946) console_ifconfig: Setting mask: 255.255.255.0\nesp> ifconfig en1 gw 192.168.5.1\nI (143576) console_ifconfig: Setting gw: 192.168.5.1\nI (143576) esp_netif_handlers: eth ip: 192.168.5.2, mask: 255.255.255.0, gw: 192.168.5.1\n```\n\n----------------------------------------\n\nTITLE: Include ESP-MODEM Command Declarations\nDESCRIPTION: This line includes the \"esp_modem_command_declare.inc\" file, which is expected to contain the concrete definitions of the commands declared using the `ESP_MODEM_DECLARE_DCE_COMMAND` macro.  The included file is crucial for providing the actual implementations of the DCE commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/generate/dce.rst#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include \"esp_modem_command_declare.inc\"\n```\n\n----------------------------------------\n\nTITLE: Conditional registration of esp_websocket_client based on build configuration in CMake\nDESCRIPTION: This snippet checks whether WebSocket transport is enabled and whether early expansion is active. If WebSocket transport is disabled, it outputs a status message, registers the component minimally without sources or headers, and exits. Otherwise, it proceeds with full registration tailored to the target platform, specifying source files, include directories, and dependencies. For Linux targets, additional dependencies are included.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_build_get_property(target IDF_TARGET)\n\nif(NOT CONFIG_WS_TRANSPORT AND NOT CMAKE_BUILD_EARLY_EXPANSION)\n    message(STATUS \"Websocket transport is disabled so the esp_websocket_client component will not be built\")\n    # note: the component is still included in the build so it can become visible again in config\n    # without needing to re-run CMake. However no source or header files are built.\n    idf_component_register()\n    return()\nendif()\n\nif(${IDF_TARGET} STREQUAL \"linux\")\n\tidf_component_register(SRCS \"esp_websocket_client.c\"\n                    INCLUDE_DIRS \"include\"\n                    REQUIRES esp-tls tcp_transport http_parser esp_event nvs_flash esp_stubs json\n                    PRIV_REQUIRES esp_timer)\nelse()\n    idf_component_register(SRCS \"esp_websocket_client.c\"\n                    INCLUDE_DIRS \"include\"\n                    REQUIRES lwip esp-tls tcp_transport http_parser esp_event\n                    PRIV_REQUIRES esp_timer)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting and Downloading libjuice Library with CMake\nDESCRIPTION: This snippet defines version and URL variables for the 'libjuice' library, checks if the desired source directory exists, and if not, downloads and unpacks the specified version from GitHub. It requires CMake's 'file' and 'execute_process' commands, assumes internet access and 'unzip' availability, and operates within the project's build directory. Inputs include the version SHA and a dynamic URL; output is the extracted library for use in subsequent compilation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/components/libjuice/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(LIBJUICE_VERSION \"73785387eafe15c02b6a210edb10f722474e8e14\")\nset(LIBJUICE_URL \"https://github.com/paullouisageneau/libjuice/archive/${LIBJUICE_VERSION}.zip\")\n\nset(libjuice_dir ${CMAKE_BINARY_DIR}/libjuice/libjuice-${LIBJUICE_VERSION})\n\n# Fetch the library\nif(NOT EXISTS ${libjuice_dir})\n        message(STATUS \"Downloading libjuice ${LIBJUICE_VERSION}...\")\n        file(DOWNLOAD ${LIBJUICE_URL} ${CMAKE_BINARY_DIR}/libjuice.zip SHOW_PROGRESS)\n        execute_process(COMMAND unzip -o ${CMAKE_BINARY_DIR}/libjuice.zip -d ${CMAKE_BINARY_DIR}/libjuice\n                WORKING_DIRECTORY ${CMAKE_BINARY_DIR})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Component Registration with Source Files and Include Directories in C++ with IDF\nDESCRIPTION: This code registers a component in the ESP-IDF build system with specified source files and include directories, some of which depend on earlier conditions. It enables modular compilation of modem client and TCP transport functionalities.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nidf_component_register(SRCS \"modem_client.cpp\"\n                            \"${command_dir}/sock_dce.cpp\"\n                            \"tcp_transport_at.cpp\"\n                            \"${device_srcs}\"\n                       INCLUDE_DIRS \".\" \"${command_dir}\")\n```\n\n----------------------------------------\n\nTITLE: Linking Wrapped Functions and Libraries in libwebsockets ESP-IDF Component (CMake)\nDESCRIPTION: This snippet declares a list of functions to be wrapped at link time and adds link directives for these using GCC's -Wl,--wrap option in an INTERFACE library target. It further links the 'websockets' library and adds 'port/lws_port.c' as an interface source, ensuring the necessary sources and symbol wrappers are included when building the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(WRAP_FUNCTIONS mbedtls_ssl_handshake_step\n                   lws_adopt_descriptor_vhost)\n\nforeach(wrap ${WRAP_FUNCTIONS})\n    target_link_libraries(${COMPONENT_LIB} INTERFACE \"-Wl,--wrap=${wrap}\")\nendforeach()\n\ntarget_link_libraries(${COMPONENT_LIB} INTERFACE websockets)\n\ntarget_sources(${COMPONENT_LIB} INTERFACE \"port/lws_port.c\")\n```\n\n----------------------------------------\n\nTITLE: Sample ESP32 WebSocket Client Runtime Output (plaintext)\nDESCRIPTION: This example shows typical debug output from the ESP32 WebSocket client using LWS. It covers client context creation, connection attempts, TLS self-signed acceptance, Wi-Fi association, connection status events, and sent/received WebSocket messages. The output demonstrates interaction with a sample echo server, indicating successful handshake and message exchange. It serves as a reference for expected runtime behavior and verifying correct operation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/README.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nI (18208) lws-client: LWS minimal ws client echo\n\n219868: lws_create_context: LWS: 4.3.99-v4.3.0-424-ga74362ff, MbedTLS-3.6.2 NET CLI SRV H1 H2 WS SS-JSON-POL ConMon IPv6-absent\n219576:  mem: platform fd map:    20 bytes\n217880: __lws_lc_tag:  ++ [wsi|0|pipe] (1)\n216516: __lws_lc_tag:  ++ [vh|0|default||-1] (1)\nI (18248) lws-client: connect_cb: connecting\n\n210112: __lws_lc_tag:  ++ [wsicli|0|WS/h1/default/echo.websocket.events] (1)\n204800: [wsicli|0|WS/h1/default/echo.websocket.events]: lws_client_connect_3_connect: trying 13.248.241.119\n180776: lws_ssl_client_bio_create: allowing selfsigned\nI (19998) wifi:<ba-add>idx:0 (ifx:0, b4:89:01:63:9d:08), tid:0, ssn:321, winSize:64\nI (20768) lws-client: WEBSOCKET_EVENT_CONNECTED\nI (20768) lws-client: Sending hello 0000\nI (20778) lws-client: WEBSOCKET_EVENT_DATA\nW (20778) lws-client: Received=echo.websocket.events sponsored by Lob.com\n\n\nI (20968) lws-client: WEBSOCKET_EVENT_DATA\nW (20968) lws-client: Received=hello 0000\n\n\nI (22978) lws-client: Sending hello 0001\nI (23118) lws-client: WEBSOCKET_EVENT_DATA\nW (23118) lws-client: Received=hello 0001\n\n\nI (23778) lws-client: Sending hello 0002\nI (23938) lws-client: WEBSOCKET_EVENT_DATA\nW (23938) lws-client: Received=hello 0002\n\n\nI (25948) lws-client: Sending hello 0003\nI (26088) lws-client: WEBSOCKET_EVENT_DATA\nW (26088) lws-client: Received=hello 0003\n\n\nI (26948) lws-client: Sending hello 0004\nI (27118) lws-client: WEBSOCKET_EVENT_DATA\nW (27118) lws-client: Received=hello 0004\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Properties for Component - CMake\nDESCRIPTION: This snippet sets properties for the component library (${COMPONENT_LIB}). It configures the C++ standard to C++17 using `CXX_STANDARD 17`, enforces its use with `CXX_STANDARD_REQUIRED ON`, and enables C++ extensions with `CXX_EXTENSIONS ON`. These settings dictate how the C++ compiler interprets the source code and affects the compiler flags used during the build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/common_components/linux_compat/esp_timer/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component with Dependencies in CMake - CMake\nDESCRIPTION: This CMake snippet registers the modem_main.cpp source as an ESP-IDF component dependency on esp_modem using the idf_component_register function. It ensures the target is aware of required source files and build dependencies for successful integration within the ESP-IDF build system. The 'REQUIRES' keyword specifies that esp_modem must be available. No special input parameters are required by the snippet, but the project must include the ESP-IDF build system and esp_modem library.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/linux_modem/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"modem_main.cpp\"\n                       REQUIRES esp_modem)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Registering WebSocket Component in ESP-IDF\nDESCRIPTION: Sets up component variables and registers a WebSocket example component with the ESP-IDF build system. It defines source files and include directories, and conditionally embeds TLS certificate files for secure connections when mutual authentication is enabled.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SRC_FILES \"websocket_example.c\") # Define source files\nset(INCLUDE_DIRS \".\") # Define include directories\nset(EMBED_FILES \"\") # Initialize an empty list for files to embed\n\n# Conditionally append files to the list based on configuration\n#if(CONFIG_WS_OVER_TLS_MUTAL_AUTH)\n    list(APPEND EMBED_FILES\n        \"certs/client_cert.pem\"\n        \"certs/ca_cert.pem\"\n        \"certs/client_key.pem\")\n#endif()\n\n# Register the component with source files, include dirs, and any conditionally added embedded files\nidf_component_register(SRCS \"${SRC_FILES}\"\n                       INCLUDE_DIRS \"${INCLUDE_DIRS}\"\n                       EMBED_TXTFILES \"${EMBED_FILES}\")\n```\n\n----------------------------------------\n\nTITLE: Defining ESP-IDF project name\nDESCRIPTION: This command sets the name of the ESP-IDF project to 'websocket_example', which will be used for build outputs and configurations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(websocket_example)\n```\n\n----------------------------------------\n\nTITLE: Specifying Minimum CMake Version (CMake)\nDESCRIPTION: This snippet specifies the minimum required version of CMake for the project build. It ensures that the build environment has a CMake version compatible with the syntax and features used in the project's build scripts.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Conditional Inclusion and Directory Setup\nDESCRIPTION: This snippet conditionally includes the `Filelists.cmake` file from the LWIP source directory and defines include directories.  It removes specific source files (slipif.c, ip4.c, ip6.c) from the `lwipnoapps_SRCS` list if the `CMAKE_BUILD_EARLY_EXPANSION` variable is not set. The inclusion is skipped if CMAKE_BUILD_EARLY_EXPANSION is set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_netif_linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_BUILD_EARLY_EXPANSION)\n\n    include(${LWIP_DIR}/src/Filelists.cmake)\n\n    set (LWIP_INCLUDE_DIRS\n        \"${LWIP_DIR}/src/include\"\n        \"${LWIP_CONTRIB_DIR}/ports/unix/port/include\")\n\n    list(REMOVE_ITEM lwipnoapps_SRCS \"${LWIP_DIR}/src/netif/slipif.c\")\n    list(REMOVE_ITEM lwipnoapps_SRCS \"${LWIP_DIR}/src/core/ipv4/ip4.c\")\n    list(REMOVE_ITEM lwipnoapps_SRCS \"${LWIP_DIR}/src/core/ipv6/ip6.c\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering OTA Test Component with ESP-IDF Build System in CMake\nDESCRIPTION: This snippet uses the ESP-IDF CMake macro idf_component_register to register a component that includes the OTA test source file (ota_test.cpp) and specifies the current directory as the include path for headers. It configures the build environment to properly compile and link this component within the ESP-IDF framework. The snippet requires the ESP-IDF build system and is typically found in the component's CMakeLists.txt file.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS ota_test.cpp\n                       INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Using ESP-Modem C API Workflow\nDESCRIPTION: Pseudocode demonstrating the typical workflow of using the ESP-Modem C API, including creating a DCE instance, issuing commands, and switching modes. The workflow includes proper resource management with initialization and cleanup.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/api_docs.rst#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// Create a DCE instance\nesp_modem_dce_t *dce = esp_modem_new(/* config parameters */);\n\n// Issue AT commands to configure the modem\n// Example: Check signal quality, configure network settings, etc.\n\n// Switch to data mode for network operations\nesp_modem_set_mode(dce, ESP_MODEM_MODE_DATA);\n\n// Perform network operations using standard networking APIs\n// (not part of ESP-MODEM)\n\n// Switch back to command mode if needed\nesp_modem_set_mode(dce, ESP_MODEM_MODE_COMMAND);\n\n// Clean up when done\nesp_modem_destroy(dce);\n```\n\n----------------------------------------\n\nTITLE: Registering WebSocket Client Test Component in ESP-IDF\nDESCRIPTION: Configures the ESP-IDF component for WebSocket client testing. It specifies the source file, required components, include directories, and private dependencies needed for the test implementation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/test/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"test_websocket_client.c\"\n                       REQUIRES test_utils\n                       INCLUDE_DIRS \".\"\n                       PRIV_REQUIRES unity esp_websocket_client esp_event)\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project using CMake - CMake\nDESCRIPTION: This snippet initializes a new ESP-IDF project using CMake. It requires CMake version 3.16 or newer, and includes the ESP-IDF build tools by referencing the IDF_PATH environment variable. The snippet must be placed at the beginning of the project\\'s CMakeLists.txt file and requires a correctly set IDF_PATH pointing to the ESP-IDF SDK. The project() directive defines the project name as 'modem_psm'. Inputs are the CMake version and the project name, while outputs are a properly configured build environment for ESP-IDF components. It is important to maintain the prescribed order to avoid build issues.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_psm/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(modem_psm)\n```\n\n----------------------------------------\n\nTITLE: Running iperf Server and Client Commands\nDESCRIPTION: Commands for manually running iperf tests with UDP between an ESP32 device and a host computer. This shows both the server command for the ESP32 side and the client command for the host side.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\niperf -u -s -i 3\niperf -u -c SERVER_IP -t 60 -i 3\n```\n\n----------------------------------------\n\nTITLE: Performance Test Results Example\nDESCRIPTION: Sample output from the pytest showing the measured network throughput values for TCP and UDP in both transmit and receive directions.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n2023-11-29 18:28:25 INFO [Performance][tcp_tx_throughput]: 0.75 Mbps\n2023-11-29 18:28:25 INFO [Performance][tcp_rx_throughput]: 0.70 Mbps\n2023-11-29 18:28:25 INFO [Performance][udp_tx_throughput]: 0.73 Mbps\n2023-11-29 18:28:25 INFO [Performance][udp_rx_throughput]: 0.70 Mbps\n```\n\n----------------------------------------\n\nTITLE: Defining compile definitions for asio component\nDESCRIPTION: This snippet defines compile definitions for the asio component, including flags for POSIX compatibility, disabling serial port support, separate compilation, standalone mode, pthreads support, disabling OpenSSL engine, and replacing the asio posix_event constructor. These definitions are used during the compilation of the asio library.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_definitions(${COMPONENT_LIB} PUBLIC SA_RESTART=0x01\n                                                   SA_NOCLDSTOP=0x2\n                                                   SA_NOCLDWAIT=0x4\n                                                   ASIO_DISABLE_SERIAL_PORT\n                                                   ASIO_SEPARATE_COMPILATION\n                                                   ASIO_STANDALONE\n                                                   ASIO_HAS_PTHREADS\n                                                   OPENSSL_NO_ENGINE\n                                                   ASIO_DETAIL_IMPL_POSIX_EVENT_IPP  # this replaces asio's posix_event constructor\n)\n```\n\n----------------------------------------\n\nTITLE: Adding and Configuring mDNS Services - C\nDESCRIPTION: This code adds and configures mDNS services, including adding services, setting instance names, and setting text records. It demonstrates how to add various service types and set instance names and text records for the services. Before setting service attributes, you must first add the service using the `mdns_service_add` function. The example shows how to configure an HTTP server and other services.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/zh_CN/index.rst#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid add_mdns_services()\n{\n    // 添加服务\n    mdns_service_add(NULL, \"_http\", \"_tcp\", 80, NULL, 0);\n    mdns_service_add(NULL, \"_arduino\", \"_tcp\", 3232, NULL, 0);\n    mdns_service_add(NULL, \"_myservice\", \"_udp\", 1234, NULL, 0);\n\n    // 注意：必须先添加服务，然后才能设置其属性\n    // web 服务器使用自定义的实例名\n    mdns_service_instance_name_set(\"_http\", \"_tcp\", \"Jhon's {IDF_TARGET_NAME} Web Server\");\n\n    mdns_txt_item_t serviceTxtData[3] = {\n        {\"board\",\"{IDF_TARGET_PATH_NAME}\"},\n        {\"u\",\"user\"},\n        {\"p\",\"password\"}\n    };\n    // 设置服务的文本数据（会释放并替换当前数据）\n    mdns_service_txt_set(\"_http\", \"_tcp\", serviceTxtData, 3);\n\n    // 修改服务端口号\n    mdns_service_port_set(\"_myservice\", \"_udp\", 4321);\n}\n```\n\n----------------------------------------\n\nTITLE: Register ESP-IDF Component with CMake\nDESCRIPTION: This CMake command registers a new component in the ESP-IDF build system. It specifies the source files to be compiled and the include directories to be used during compilation. `SRCS` defines the source file(s) and `INCLUDE_DIRS` specifies the directories containing header files.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/pppos_client/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"pppos_client_main.c\"\n                       INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Configure Linux Target with idf.py\nDESCRIPTION: This command configures the build target to Linux using the ESP-IDF build system. It sets the target architecture for the subsequent build process, allowing the application to be compiled and executed on a Linux environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py --preview set-target linux\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF CMake Project in CMake\nDESCRIPTION: This snippet configures the core CMake environment to build an ESP-IDF project named pppos_host. It requires CMake version 3.16 or higher, includes ESP-IDF's project toolchain using an environment variable for IDF_PATH, and defines the project name. These steps form prerequisites for successful compilation and linking of ESP protocol components.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/examples/host/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\\n\\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\\nproject(pppos_host)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build System for ESP-IDF\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.16 for the project.  It is essential for compatibility with the ESP-IDF build system. This is a prerequisite for any CMake-based ESP-IDF project. The output of this is the ability to build and configure an ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/tls_client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Support for ESP-Modem Tests\nDESCRIPTION: Sets up threading support using pthreads and links the thread library to the component. This is required for any concurrent operations in the tests.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(THREADS_PREFER_PTHREAD_FLAG ON)\nfind_package(Threads REQUIRED)\ntarget_link_libraries(${COMPONENT_LIB}  PRIVATE Threads::Threads)\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF DNS Protocol Component in CMake\nDESCRIPTION: This snippet registers the source files implementing DNS protocols within an ESP-IDF component using the 'idf_component_register' macro in CMakeLists.txt. It declares the source files for different DNS transports, sets include directories, and lists required components for successful compilation and linking. The configuration ensures the component builds with correct dependencies and header paths, facilitating integration into the ESP32 firmware build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS\n                    \"esp_dns_udp.c\"\n                    \"esp_dns_tcp.c\"\n                    \"esp_dns_dot.c\"\n                    \"esp_dns_doh.c\"\n                    \"esp_dns.c\"\n                    \"esp_dns_lwip.c\"\n                    \"esp_dns_utils.c\"\n                    INCLUDE_DIRS \"include\"\n                    PRIV_INCLUDE_DIRS \".\"\n                    PRIV_REQUIRES nvs_flash lwip esp_event esp-tls esp_http_client esp-tls tcp_transport)\n```\n\n----------------------------------------\n\nTITLE: Specifying Additional Component Directories\nDESCRIPTION: This code sets extra component directories necessary for the project build, including paths to shared libraries and dependencies such as mbedtls. It ensures that CMake searches these directories when resolving components.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EXTRA_COMPONENT_DIRS \"../..\" \"../../../mbedtls_cxx\")\n```\n\n----------------------------------------\n\nTITLE: ESP PPP Link API Overview\nDESCRIPTION: This section outlines the various API functions available for using the ESP PPP Link component. The API offers simplified functions for connection and listening, as well as manual actions for initialization, deinitialization, network start/stop, and task iteration. The specific functions are provided for both client and server roles. There are no code snippets, only API description.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/README.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: mDNS SRV Record Representation (Text)\nDESCRIPTION: Represents a Service (SRV) record in mDNS packet analysis output. SRV records specify the host and port number where a service instance can be found. The output shows both query (Q) and answer (A) formats, with answers including TTL and the target host/port information.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nQ: Hristo's Time Capsule._afpovertcp._tcp.local. SRV IN FLUSH\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: 9801A7E58FA1@Hristo's AirPort Express._raop._tcp.local. SRV IN FLUSH 120 [32] 5000 Hristos-AirPort-Express.local.\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristo’s Mac mini._smb._tcp.local. SRV IN FLUSH 120 [18] 445 minifritz.local.\n```\n\n----------------------------------------\n\nTITLE: Configuring the Project with idf.py\nDESCRIPTION: This command launches the menuconfig interface to configure the Asio chat example project, allowing users to set parameters like server/client mode, port numbers, and connection addresses.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/asio_chat/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nidf.py menuconfig\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard for ESP-IDF Component (CMake)\nDESCRIPTION: This CMake command sets specific properties for the target component library (${COMPONENT_LIB}). It enforces the use of the C++17 standard, requires that the standard is strictly adhered to, and enables compiler-specific extensions.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n```\n\n----------------------------------------\n\nTITLE: Setting C++17 Standard for ESP-Modem Tests\nDESCRIPTION: Configures the C++ standard to C++17 for the component. This ensures modern C++ features are available for the test implementation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n```\n\n----------------------------------------\n\nTITLE: Registering a Basic Ping Component with ESP-IDF\nDESCRIPTION: Registers a component with ESP-IDF build system by specifying 'ping-basic.c' as the source file and the current directory as an include path. This is essential for ESP-IDF to properly compile and link the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/examples/ping-basic/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"ping-basic.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component and Linking Console Commands (CMake)\nDESCRIPTION: Registers an ESP-IDF component using 'idf_component_register', specifying source files ('console_ping.c', etc.), include directories, and private dependencies ('esp_netif', 'console'). Conditionally links console command registration functions (ping, getaddrinfo, set/get DNS server) using 'target_link_libraries' with the '-u' flag (force symbol reference), which is controlled by the 'CONFIG_PING_CMD_AUTO_REGISTRATION' Kconfig option. This ensures the commands are available in the console if auto-registration is enabled.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"console_ping.c\" \"console_getaddrinfo.c\" \"console_getsetdnsserver.c\"\n                    INCLUDE_DIRS \".\"\n                    PRIV_REQUIRES esp_netif console)\n\nif(CONFIG_PING_CMD_AUTO_REGISTRATION)\n    target_link_libraries(${COMPONENT_LIB} \"-u console_cmd_ping_register\")\n    target_link_libraries(${COMPONENT_LIB} \"-u console_cmd_getaddrinfo_register\")\n    target_link_libraries(${COMPONENT_LIB} \"-u console_cmd_setdnsserver_register\")\n    target_link_libraries(${COMPONENT_LIB} \"-u console_cmd_getdnsserver_register\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with Subprotocol - C\nDESCRIPTION: This snippet shows how to request a specific subprotocol during the WebSocket handshake.  The `subprotocol` field in the `esp_websocket_client_config_t` struct is set to `soap`, indicating the client's preference for the SOAP subprotocol.  The client doesn't validate the server's response regarding the subprotocol.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nconst esp_websocket_client_config_t ws_cfg = {\n    .uri = \"ws://websocket.org\",\n    .subprotocol = \"soap\",\n};\n```\n\n----------------------------------------\n\nTITLE: Disabling Ubuntu Core Dumps for AFL (Bash)\nDESCRIPTION: Shows the command to disable the generation of core dump files on Ubuntu systems by modifying the kernel's `core_pattern` setting via procfs. This prevents interference with AFL's operation and should be run as root.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\necho core >/proc/sys/kernel/core_pattern\n```\n\n----------------------------------------\n\nTITLE: Usage Examples for Console WiFi Command\nDESCRIPTION: This snippet provides examples of how to interact with the registered `wifi` command within the ESP-IDF console interface. It lists various subcommands for displaying help, scanning and showing networks, showing station details, and joining or leaving WiFi networks from the command line.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/README.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n wifi help: Prints the help text for all wifi commands\n wifi show network/sta: Scans and displays all available wifi APs./ Shows the details of wifi station.\n wifi sta join <network ssid> <password>: Station joins the given wifi network.\n wifi sta join <network ssid>: Station joins the given unsecured wifi network.\n wifi sta join: Station joins the pre-configured wifi network.\n wifi sta leave: Station leaves the wifi network.\n```\n\n----------------------------------------\n\nTITLE: Excluding ESP-IDF Component (CMake)\nDESCRIPTION: This line uses the `set` command to define the `EXCLUDE_COMPONENTS` variable. It lists ESP-IDF components that should not be included in the project build, in this case, preventing the `openssl` component from being compiled and linked.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EXCLUDE_COMPONENTS openssl)\n```\n\n----------------------------------------\n\nTITLE: Registering Component Source and Include Directory in CMake (ESP-IDF)\nDESCRIPTION: This CMake command uses the `idf_component_register` function, specific to the ESP-IDF build system, to register the `ifconfig-basic.c` file as a source file (`SRCS`) for the component. It also specifies that the current directory (`.`) should be added to the list of include directories (`INCLUDE_DIRS`) for this component, allowing source files within the component to include headers located in the same directory.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/examples/ifconfig-basic/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"ifconfig-basic.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with Port Override - C\nDESCRIPTION: This example shows how to override the default port specified in the URI. The `esp_websocket_client_config_t` struct is initialized with a URI and a separate port number.  The client will connect using the explicitly specified port (4567) rather than the port implied by the URI (123).\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nconst esp_websocket_client_config_t ws_cfg = {\n    .uri = \"ws://echo.websocket.org:123\",\n    .port = 4567,\n};\n```\n\n----------------------------------------\n\nTITLE: Discovering mDNS Services on the Local Network - Espressif C\nDESCRIPTION: This function issues an mDNS PTR query for a given service type and protocol to discover matching services on the local network, prints results, and handles error and memory management. It relies on the Espressif mDNS library and expects initialized mDNS service. Parameters include null-terminated strings for service_name and proto. The function handles freeing the mdns_result_t linked list after use.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/mdns/en/index.rst#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nvoid find_mdns_service(const char * service_name, const char * proto)\n{\n    ESP_LOGI(TAG, \"Query PTR: %s.%s.local\", service_name, proto);\n\n    mdns_result_t * results = NULL;\n    esp_err_t err = mdns_query_ptr(service_name, proto, 3000, 20,  &results);\n    if(err){\n        ESP_LOGE(TAG, \"Query Failed\");\n        return;\n    }\n    if(!results){\n        ESP_LOGW(TAG, \"No results found!\");\n        return;\n    }\n\n    mdns_print_results(results);\n    mdns_query_results_free(results);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for ESP-IDF broker project\nDESCRIPTION: Standard CMake configuration for ESP-IDF projects that sets the minimum required CMake version, includes the ESP-IDF project.cmake file, and defines the project name as 'broker'.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/broker/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(broker)\n```\n\n----------------------------------------\n\nTITLE: Registering TLS Client Component - CMake\nDESCRIPTION: This CMake snippet registers a component for an ESP-IDF project. It uses `idf_component_register` to define the source files and include directories for the `tls_client` component. The `SRCS` parameter specifies the source file, and `INCLUDE_DIRS` indicates where to find the header files. This registration makes the component available for use in the project. There are no dependencies specified explicitly in the code snippet itself, but there might be dependencies within the source files or in the project structure. The output of this will be a registered component that can be built as part of the overall project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/tls_client/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"tls_client.cpp\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Device Source Assignment in C++\nDESCRIPTION: This snippet assigns source file variables based on the selected modem device during compilation, using preprocessor directives. It supports BG96 and SIM7600 devices by setting 'device_srcs' accordingly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nif (CONFIG_EXAMPLE_MODEM_DEVICE_BG96)\n    set(device_srcs sock_commands_bg96.cpp)\nelseif(CONFIG_EXAMPLE_MODEM_DEVICE_SIM7600)\n    set(device_srcs sock_commands_sim7600.cpp)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Register MQTT SSL Auth Component - CMake\nDESCRIPTION: This CMake command, `idf_component_register`, registers a component for the ESP-IDF build system. It specifies the source file 'mqtt_ssl_auth_console.c' to be included in the component.  Additionally, it includes the current directory (`.`) to provide include paths for the source file, allowing it to access necessary header files and dependencies.  No external dependencies are explicitly listed here, but the component likely relies on the ESP-IDF and related libraries.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"mqtt_ssl_auth_console.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF Component (CMake)\nDESCRIPTION: This CMake command, `idf_component_register`, registers an ESP-IDF component. It specifies the source files (`SRCS`), include directories (`INCLUDE_DIRS`), and required components (`REQUIRES`). The `SRCS` argument lists the C source files that make up the component. `INCLUDE_DIRS` specifies directories where header files are located.  `REQUIRES` lists the dependencies, which are other ESP-IDF components needed by the current component. This ensures proper build order and linking.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"serverless_mqtt.c\"\n                            \"wifi_connect.c\"\n                    INCLUDE_DIRS \".\"\n                    REQUIRES libjuice nvs_flash mqtt json esp_wifi)\n```\n\n----------------------------------------\n\nTITLE: Compiling Socket Helper Application on Linux using GCC\nDESCRIPTION: This snippet demonstrates how to compile the example application on a Linux platform using the GNU Compiler Collection (GCC). It uses `gcc` to compile the `main/app.c` file and links with the `pthread` library for multithreading support.  The resulting executable can then be run to test socket helpers.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/examples/simple/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngcc main/app.c -lpthread\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-IDF WebSocket Component Dependencies - CMake\nDESCRIPTION: This snippet registers the WebSocket Linux source file as part of the ESP-IDF component and declares dependencies on esp_websocket_client and protocol_examples_common. It requires ESP-IDF and CMake as prerequisites and is necessary for proper component integration in the build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"websocket_linux.c\"\n                    REQUIRES esp_websocket_client protocol_examples_common)\n```\n\n----------------------------------------\n\nTITLE: Registering an ESP-IDF Component\nDESCRIPTION: This snippet registers an ESP-IDF component named 'esp-protocols'. It specifies 'eppp_slave.c' as the source file to be compiled and includes the current directory '.' as an include directory. This allows the component to be included in ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/examples/slave/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"eppp_slave.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Build MQTT Project with idf.py (No lwIP)\nDESCRIPTION: This command builds the MQTT project using the ESP-IDF build system, specifically configured to exclude the lwIP component. This results in the application using the host's native networking stack, often referred to as user-side networking, for TCP/IP communication. WITH_LWIP=0 indicates not to include lwIP.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nidf.py -DWITH_LWIP=0 build  # Building without lwip (user networking)\n```\n\n----------------------------------------\n\nTITLE: Building and Flashing ESP-IDF Project Using Terminal Commands (bash)\nDESCRIPTION: This snippet shows how to build the ESP-IDF WebSocket client project, flash it to the ESP32 device, and open a serial monitor to observe runtime debug output. It requires the ESP-IDF environment to be properly set up and connected hardware. The command uses 'idf.py' to customize the port, build firmware, flash, and begin monitoring. To exit the serial monitor, the recommended keyboard shortcut (Ctrl-]) is provided.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py -p PORT flash monitor\n```\n\n----------------------------------------\n\nTITLE: Modifying CMUX Exit Sequence for A7670 in esp-modem\nDESCRIPTION: This patch adapts the exit sequence for CMUX mode on the A7670 modem to address issues with incorrect exiting. It modifies the esp_modem_cmux.cpp file to handle a specific CMUX payload.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/README.rst#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/components/esp_modem/src/esp_modem_cmux.cpp b/components/esp_modem/src/esp_modem_cmux.cpp\nindex 0c480f8..4418c3d 100644\n--- a/components/esp_modem/src/esp_modem_cmux.cpp\n+++ b/components/esp_modem/src/esp_modem_cmux.cpp\n@@ -206,6 +206,15 @@ bool CMux::on_header(CMuxFrame &frame)\n }\n size_t payload_offset = std::min(frame.len, 4 - frame_header_offset);\n memcpy(frame_header + frame_header_offset, frame.ptr, payload_offset);\n+    if (frame_header[1] == 0xEF) {\n+        dlci = 0;\n+        type = frame_header[1];\n+        payload_len = 0;\n+        data_available(&frame.ptr[0], payload_len); // Notify DISC\n+        frame.advance(payload_offset);\n+        state = cmux_state::FOOTER;\n+        return true;\n+    }\n if ((frame_header[3] & 1) == 0) {\n       if (frame_header_offset + frame.len <= 4) {\n            frame_header_offset += frame.len;\n```\n\n----------------------------------------\n\nTITLE: Disabling Strict Prototypes for Component (CMake)\nDESCRIPTION: This snippet sets a compile option to ignore strict prototypes for the component's library. This is useful when the header files can be used in both C and C++ compilation environments, to prevent compatibility errors. The output is a compilation flag affecting source files within the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Ignore strict prototypes, as the network_dce.h can used in both C and C++ compilation\ntarget_compile_options(${COMPONENT_LIB} PRIVATE \"-Wno-strict-prototypes\")\n```\n\n----------------------------------------\n\nTITLE: Registering ESP-Modem Test Component with CMake\nDESCRIPTION: Registers a component for testing ESP-Modem functionality, including required source files and dependencies. The WHOLE_ARCHIVE flag ensures all symbols from esp_modem are included during linking.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS \"test_modem.cpp\" \"LoopbackTerm.cpp\"\n                       REQUIRES esp_modem WHOLE_ARCHIVE)\n```\n\n----------------------------------------\n\nTITLE: Registering 'modem_psm' Component with CMake\nDESCRIPTION: This CMake command uses the ESP-IDF build system function `idf_component_register` to define a component. It specifies the source file `modem_psm.c` using the `SRCS` argument and sets the current directory (`.`) as an include path using `INCLUDE_DIRS`. This integrates the component into the overall ESP-IDF project build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_psm/main/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nidf_component_register(SRCS \"modem_psm.c\"\n                    INCLUDE_DIRS \".\")\n```\n\n----------------------------------------\n\nTITLE: Sanity Check for DLCI in CMux Header\nDESCRIPTION: This code snippet removes unnecessary checks related to frame header bits and frame type when validating the DLCI (Data Link Connection Identifier) in the CMux protocol.  The main check now focuses solely on ensuring the DLCI is within the allowed range defined by MAX_TERMINALS_NUM, simplifying the validation logic and potentially improving performance.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/README.rst#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n      -    if (dlci > MAX_TERMINALS_NUM || (frame_header[1] & 0x01) == 0 ||\n      -            (((type & FT_UIH) != FT_UIH) &&  type != (FT_UA | PF) ) ) {\n      +    if (dlci > MAX_TERMINALS_NUM) {\n            recover_protocol(protocol_mismatch_reason::UNEXPECTED_HEADER);\n            return true;\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for ESP-IDF Project\nDESCRIPTION: This snippet specifies the minimum required CMake version (3.5) for the project to ensure compatibility using 'cmake_minimum_required'. It is critical for ensuring CMake scripts run correctly with the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n```\n\n----------------------------------------\n\nTITLE: Retrieving IDF_TARGET Property in CMake\nDESCRIPTION: This snippet uses the 'idf_build_get_property' function to obtain the 'IDF_TARGET' property during the build process. It helps determine the target platform for conditional configuration or compilation and is dependent on the IDF build system environment.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_build_get_property(target IDF_TARGET)\n```\n\n----------------------------------------\n\nTITLE: Registering the 'esp_event_mock' Component using idf_component_register\nDESCRIPTION: This CMake command registers the `esp_event_mock` component within the ESP-IDF build system. It specifies the source file `esp_event_mock.c` to be compiled, the `include` directory containing header files for this component, and declares a dependency on the `esp_system_protocols_linux` component. This registration is essential for the build system to correctly compile and link the component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_event_mock/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(SRCS esp_event_mock.c\n                       INCLUDE_DIRS include\n                       REQUIRES esp_system_protocols_linux)\n```\n\n----------------------------------------\n\nTITLE: Setting Main Component and Project Name\nDESCRIPTION: Defines the main component of the project and sets the project name. The COMPONENTS variable specifies the main component(s) to build, and the project() command sets the overall project name, which is used for various build-related tasks. Here, the main component is set to \"main\" and the project is named \"websocket\".\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(COMPONENTS main)\nproject(websocket)\n```\n\n----------------------------------------\n\nTITLE: Registering SLIP Modem Component in ESP-IDF using CMake\nDESCRIPTION: This snippet uses the idf_component_register macro to register the SLIP modem component within the ESP-IDF build system. It specifies the source files 'library/slip_modem.c' and 'library/slip_modem_netif.c', includes headers from the 'include' directory, and declares dependencies on 'esp_netif' and 'driver' components. This configuration enables proper compilation and linkage of the SLIP modem module in an ESP-IDF project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/components/slip_modem/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nidf_component_register(\n    SRCS \"library/slip_modem.c\" \"library/slip_modem_netif.c\"\n    INCLUDE_DIRS \"include\"\n    REQUIRES esp_netif driver\n)\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project Name (CMake)\nDESCRIPTION: This snippet defines the name of the CMake project. The `project()` command must be called after including `project.cmake` in an ESP-IDF project. It sets various project-specific variables and configures the build system based on the project name.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nproject(asio_ssl_client_server)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Using IDF.py (ESP HTTPS Server)\nDESCRIPTION: This snippet shows how to generate documentation for the ESP HTTPS server using the idf.py tool.  It utilizes the 'docs' command with the '-sp' option to specify the target documentation file path.  The command will generate or open the appropriate documentation within the specified file. It is used for server-side security configuration. It requires the ESP-IDF environment to be set up correctly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/broker/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nidf.py docs -sp api-reference/protocols/esp_https_server.html\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project with CMake - CMake\nDESCRIPTION: Sets the minimum CMake version, includes the ESP-IDF project CMake scripts using the $ENV{IDF_PATH} system environment variable, and defines the ESP-IDF project name. Requires ESP-IDF to be installed and IDF_PATH environment variable configured. Inputs include the desired project name and expected project structure; outputs generate build files for the specified target. All lines are required, must appear in this order, and suitable for embedded ESP32 firmware projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/multiple_netifs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The following lines of boilerplate have to be in your project's CMakeLists\n# in this exact order for cmake to work correctly\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(multiple_netifs)\n```\n\n----------------------------------------\n\nTITLE: Building, Flashing, and Monitoring ESP-IDF Project (Shell)\nDESCRIPTION: Shows the command to compile the ESP-IDF project, upload the firmware to the connected ESP32 board (specified by `PORT`), and open the serial monitor to view the output. Requires the ESP-IDF environment to be set up and the target board connected.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -p PORT flash monitor\n```\n\n----------------------------------------\n\nTITLE: Adding libwebsockets Subdirectory in ESP-IDF Project CMake\nDESCRIPTION: This snippet adds the 'libwebsockets' subdirectory to the build process, including its own CMakeLists.txt. This allows the libwebsockets library source code and configuration to be compiled and linked as part of the overall ESP-IDF project build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(libwebsockets)\n```\n\n----------------------------------------\n\nTITLE: CMake Configuration for ESP-MQTT Project\nDESCRIPTION: This snippet defines the minimum CMake version required for the project. It then configures the project for the Linux target. If the target is Linux, it checks for the WITH_LWIP flag to determine the networking setup. If WITH_LWIP is enabled, it sets up the project with lwIP and related components for TAP networking. If WITH_LWIP is disabled, it sets up the project with esp_stubs and other components for network access via Linux socket calls. Finally, it includes the project.cmake file and defines the project name.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\nif(\"${IDF_TARGET}\" STREQUAL \"linux\")\n# For linux-target we have two options:\n# - With lwIP (must be defined on command line, e.g. idf.py -DWITH_LWIP=1)\n#     access networking from linux `tap` interface (TAP networking mode)\n# - Without lwIP (must be defined on command line, e.g. idf.py -DWITH_LWIP=0)\n#     no designated interface, accesses user network via linux/socket sys calls\n    if(WITH_LWIP STREQUAL 1)\n        set(EXTRA_COMPONENT_DIRS $ENV{IDF_PATH}/examples/common_components/protocol_examples_tapif_io\n                                 \"../../common_components/linux_compat/esp_timer\")\n        set(COMPONENTS main esp_netif lwip protocol_examples_tapif_io startup esp_hw_support esp_system nvs_flash mqtt esp_timer)\n    else()\n        list(APPEND EXTRA_COMPONENT_DIRS\n                \"../../common_components/linux_compat/esp_timer\"\n                \"$ENV{IDF_PATH}/examples/protocols/linux_stubs/esp_stubs\")\n        set(COMPONENTS main nvs_flash esp-tls esp_stubs mqtt protocol_examples_common esp_timer)\n    endif()\nendif()\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(esp_mqtt_demo)\n```\n\n----------------------------------------\n\nTITLE: Building, Flashing, and Monitoring an ESP32 Project Using ESP-IDF\nDESCRIPTION: This shell command sequence uses the ESP-IDF 'idf.py' tool to compile the MQTT example project, flash it to a connected ESP32 development board, and open a monitor for serial output. 'PORT' should be replaced with the target device's serial port identifier. The output includes build status, flash progress, and serial log monitoring, aiding in troubleshooting and verification.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py -p PORT flash monitor\n\n```\n\n----------------------------------------\n\nTITLE: Starting PPP Server using pppd (Bash)\nDESCRIPTION: This command initiates a PPP server process (`pppd`) on a host machine. It configures the serial port, baud rate, assigns IP addresses for the local host and the remote device, sets a DNS server, and enables various debug and connection options necessary for establishing a PPP link with the ESP device under test.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo pppd /dev/ttyUSB1 115200 192.168.11.1:192.168.11.2 ms-dns 8.8.8.8 modem local noauth debug nocrtscts nodetach +ipv6\n```\n\n----------------------------------------\n\nTITLE: Build MQTT Project with idf.py (with lwIP)\nDESCRIPTION: This command builds the MQTT project using the ESP-IDF build system, including the lwIP component. This configures the application to use a simulated network stack, often involving the TAP interface, for network communication. WITH_LWIP=1 signifies the inclusion of lwIP.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/mqtt/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nidf.py -DWITH_LWIP=1 build  # Building with lwip (TAP networking)\n```\n\n----------------------------------------\n\nTITLE: Setting Component Link Options for AddressSanitizer (CMake)\nDESCRIPTION: Adds the link option `-fsanitize=address` to the component's library target (`${COMPONENT_LIB}`) using `target_link_options`. This ensures the necessary AddressSanitizer runtime libraries are linked during the final linking stage. The option is applied publicly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/test/host/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_options(${COMPONENT_LIB} PUBLIC -fsanitize=address)\n```\n\n----------------------------------------\n\nTITLE: Configuring Component Directories and Test Setup Using CMake\nDESCRIPTION: This snippet sets the minimum required CMake version, includes ESP-IDF-specific CMake scripts, and defines a list of component directories to be included in the build process for the test application. It also dynamically extracts component names for unit testing by processing the directory paths and populating the TEST_COMPONENTS list. The script requires ESP-IDF's build environment and assumes all components to be located in the referenced directories. It expects that any component containing a 'test' subdirectory will be processed for unit tests. The input is a list of directories, and the output is a properly configured build and test environment for the esp-protocols project.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/test_app/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\ninclude($ENV{IDF_PATH}/tools/cmake/version.cmake)\n\nset(EXTRA_COMPONENT_DIRS\n    ../components/eppp_link\n    ../components/esp_modem\n    ../components/esp_mqtt_cxx\n    ../components/esp_websocket_client\n    ../components/console_cmd_ifconfig\n    ../components/console_cmd_ping\n    ../components/console_cmd_wifi\n    ../components/console_simple_init\n    ../components/mbedtls_cxx\n    ../components/sock_utils\n    ../components/libwebsockets\n    ../components/mdns)\n\nset(TEST_COMPONENTS \"\" CACHE STRING \"List of components to test\")\nforeach (CMP_DIR ${EXTRA_COMPONENT_DIRS})\n    string(SUBSTRING ${CMP_DIR} 3 100 STRIPPED_CMP)\n    list(APPEND TEST_COMPONENTS ${STRIPPED_CMP})\nendforeach()\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(esp_protocols_test_app)\n```\n\n----------------------------------------\n\nTITLE: Generating Client Key and CSR using OpenSSL in Shell\nDESCRIPTION: These shell commands utilize OpenSSL to create a new client private key ('client.key') and generate a certificate signing request ('client.csr') essential for SSL mutual authentication with the MQTT broker. The commands must be run in the relevant certificates directory. At a minimum, 'req' will prompt for Country, Organisation, and Common Name fields; user input is necessary and default values should be avoided for compatibility with Mosquitto.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nopenssl genrsa -out client.key\nopenssl req -out client.csr -key client.key -new\n\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Client with TLS - C\nDESCRIPTION: This snippet configures the ESP WebSocket client to use TLS (wss). It sets the URI to `wss://echo.websocket.org` and provides a PEM-formatted certificate for server verification using the `cert_pem` parameter.  The `websocket_org_pem_start` variable is assumed to be defined elsewhere and contain the certificate data.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_websocket_client/en/index.rst#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nconst esp_websocket_client_config_t ws_cfg = {\n    .uri = \"wss://echo.websocket.org\",\n    .cert_pem = (const char *)websocket_org_pem_start,\n};\n```\n\n----------------------------------------\n\nTITLE: ESP-MODEM Command Declaration Macro\nDESCRIPTION: This macro `ESP_MODEM_DECLARE_DCE_COMMAND` is used to declare a command within the ESP-MODEM framework, specifically for the DCE (Data Communication Equipment). It generates a reference to a C++ function `esp_modem::DCE::name`.  It likely expects a command name, return type, and a variable number of arguments.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/generate/dce.rst#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#define ESP_MODEM_DECLARE_DCE_COMMAND(name, return_type, ...) \\\n* :cpp:func:`esp_modem::DCE::name`\n```\n\n----------------------------------------\n\nTITLE: Defining ESP-IDF Project Name - CMake\nDESCRIPTION: Sets the name of the CMake project. In the context of ESP-IDF, this name is typically used for the main build target (e.g., the application executable or library). The project name is passed as a parameter to the command.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(slip_client)\n```\n\n----------------------------------------\n\nTITLE: Example Console Output of Asio SSL Client Connecting to Public Server (Log)\nDESCRIPTION: This snippet is a sample console log showing the sequence of events as the ESP device connects to a Wi-Fi network, obtains IP addresses, and successfully communicates with a public HTTPS server using the Asio SSL client. It includes Wi-Fi event states, IP acquisition, and HTTP response from the remote server.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/ssl_client_server/README.md#_snippet_1\n\nLANGUAGE: Log\nCODE:\n```\nI (1267) example_connect: Waiting for IP(s)\nI (2587) wifi:new:<11,0>, old:<1,0>, ap:<255,255>, sta:<11,0>, prof:1\nI (3367) wifi:state: init -> auth (b0)\nI (3377) wifi:state: auth -> assoc (0)\nI (3387) wifi:state: assoc -> run (10)\nI (3397) wifi:security type: 3, phy: bgn, rssi: -49\nI (3397) wifi:pm start, type: 1\nI (3457) wifi:AP's beacon interval = 102400 us, DTIM period = 1\nI (4747) example_connect: Got IPv6 event: Interface \"example_connect: sta\" address: fe80:0000:0000:0000:260a:xxxx:xxxx:xxxx, type: ESP_IP6_ADDR_IS_LINK_LOCAL\nI (5247) esp_netif_handlers: example_connect: sta ip: 192.168.32.69, mask: 255.255.252.0, gw: 192.168.32.3\nI (5247) example_connect: Got IPv4 event: Interface \"example_connect: sta\" address: 192.168.32.69\nI (5257) example_connect: Connected to example_connect: sta\nI (5257) example_connect: - IPv4 address: 192.168.32.69\nI (5267) example_connect: - IPv6 address: fe80:0000:0000:0000:260a:xxxx:xxxx:xxxx, type: ESP_IP6_ADDR_IS_LINK_LOCAL\nW (5277) esp32_asio_pthread: pthread_condattr_setclock: not yet supported!\nW (5297) esp32_asio_pthread: pthread_condattr_setclock: not yet supported!\nReply: HTTP/1.1 200 OK\nD\n```\n\n----------------------------------------\n\nTITLE: Setting Component Compile Options for AddressSanitizer (CMake)\nDESCRIPTION: Adds compile options `-fsanitize=address` (to enable AddressSanitizer instrumentation) and `-fconcepts` (to enable C++20 concepts support) to the component's library target (`${COMPONENT_LIB}`) using `target_compile_options`. These options are applied publicly, meaning they might affect targets linking against this component.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/test/host/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(${COMPONENT_LIB} PUBLIC -fsanitize=address -fconcepts)\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic ESP-IDF Project with CMake\nDESCRIPTION: This snippet presents the fundamental CMake commands needed at the beginning of an ESP-IDF project's main CMakeLists.txt. It enforces a minimum CMake version (3.5), includes the core IDF project build system located via the IDF_PATH environment variable, and sets the name of the project to 'pppd_test'. These lines are crucial for the IDF build process to function correctly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(pppd_test)\n```\n\n----------------------------------------\n\nTITLE: Include ESP-IDF Project CMake Functions (CMake)\nDESCRIPTION: Includes the main CMake file provided by the ESP-IDF build system. This file contains crucial functions, macros, and variables necessary to configure and build ESP-IDF based projects, handling component discovery and target configuration. It depends on the IDF_PATH environment variable being correctly set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/tests/uart_mutual_auth/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Generating Self-Signed TLS Certificates using OpenSSL (Shell)\nDESCRIPTION: Provides a sequence of OpenSSL commands to generate a Certificate Authority (CA) key and certificate, followed by server and client private keys, Certificate Signing Requests (CSRs), and signed certificates using the CA. This setup is intended for testing WebSocket over TLS (`CONFIG_WS_OVER_TLS_MUTUAL_AUTH` or `CONFIG_WS_OVER_TLS_SERVER_AUTH`) and uses simplified parameters (no CN checks, hardcoded sizes). It is strongly recommended not to use these example certificates in production.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nGenerate the CA's Private Key;\nopenssl genrsa -out ca_key.pem 2048\n\nCreate the CA's Certificate\nopenssl req -new -x509 -days 3650 -key ca_key.pem -out ca_cert.pem\n\nGenerate the Server's Private Key\nopenssl genrsa -out server_key.pem 2048\n\nGenerate a Certificate Signing Request (CSR) for the Server\nopenssl req -new -key server_key.pem -out server_csr.pem\n\nSign the Server's CSR with the CA's Certificate\nopenssl x509 -req -days 3650 -in server_csr.pem -CA ca_cert.pem -CAkey ca_key.pem -CAcreateserial -out server_cert.pem\n\nGenerate the Client's Private Key\nopenssl genrsa -out client_key.pem 2048\n\nGenerate a Certificate Signing Request (CSR) for the Client\nopenssl req -new -key client_key.pem -out client_csr.pem\n\nSign the Client's CSR with the CA's Certificate\nopenssl x509 -req -days 3650 -in client_csr.pem -CA ca_cert.pem -CAkey ca_key.pem -CAcreateserial -out client_cert.pem\n```\n\n----------------------------------------\n\nTITLE: Conditionally Adding Extra Component Directories for Linux Target\nDESCRIPTION: This snippet conditionally adds an extra component directory when the target platform is 'linux'.  It appends the path to a mock FreeRTOS implementation to the EXTRA_COMPONENT_DIRS list if the IDF_TARGET is 'linux'. This is useful for testing or simulating the ESP-IDF environment on a Linux machine. Requires the IDF_TARGET environment variable to be set, and the IDF_PATH variable needs to be set as well. The output enables the use of mock FreeRTOS components for a Linux build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/tls_client/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"${IDF_TARGET}\" STREQUAL \"linux\")\n    list(APPEND EXTRA_COMPONENT_DIRS \"$ENV{IDF_PATH}/tools/mocks/freertos/\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including Project CMake Module and Initializing ESP Project\nDESCRIPTION: This snippet includes an external CMake script from the ESP IDF environment to facilitate project setup and then initializes the project named 'ota_test'. It ties together build configurations and project definition.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(ota_test)\n```\n\n----------------------------------------\n\nTITLE: Including Console Ping Header in C\nDESCRIPTION: Includes the necessary header file `console_ping.h` to enable the use of console ping and DNS command functionalities within an ESP-IDF C application. This is a prerequisite for initializing and registering the commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"console_ping.h\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Minimum Version for ESP32\nDESCRIPTION: This snippet specifies the minimum required CMake version (3.16) for the project. It ensures that the build system uses a compatible version of CMake, allowing for proper compilation and linking of the project. This is a prerequisite step for setting up the project build environment. The output of this command is used internally by cmake.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/libwebsockets/examples/client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Browsing mDNS Services with Avahi in Bash\nDESCRIPTION: Command demonstrating how to use avahi-browse to perform a recursive, all-services scan on an interface configured with multicast enabled. The output shows discovered services on the eth2 interface, including their IP protocol versions, names, hostnames, IP addresses, ports, and TXT records. Dependencies include the avahi-browse tool and properly configured multicast network interfaces. Inputs: none beyond invocation; output: live list of mDNS services on the network.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/host_test/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\navahi-browse -a -r -p\n+;eth2;IPv6;myesp-service2;Web Site;local\n+;eth2;IPv4;myesp-service2;Web Site;local\n=;eth2;IPv6;myesp-service2;Web Site;local;myesp.local;192.168.1.200;80;\"board=esp32\" \"u=user\" \"p=password\"\n=;eth2;IPv4;myesp-service2;Web Site;local;myesp.local;192.168.1.200;80;\"board=esp32\" \"u=user\" \"p=password\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Directory Setting for Development or Production Mode in C++\nDESCRIPTION: This snippet sets the 'command_dir' variable to either 'generate' or 'command' based on whether development mode is enabled, facilitating different build or runtime configurations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/main/CMakeLists.txt#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nif(CONFIG_ESP_MODEM_ENABLE_DEVELOPMENT_MODE)\n    set(command_dir \"generate\")\nelse()\n    set(command_dir \"command\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional asio component registration based on IPv6\nDESCRIPTION: This snippet conditionally registers the asio component based on whether IPv6 support is enabled. If IPv6 is disabled, it registers the component without building any source or header files, preventing it from being actively built while still allowing it to be re-enabled through configuration changes without re-running CMake.  It checks `CONFIG_LWIP_IPV6` and `CMAKE_BUILD_EARLY_EXPANSION`.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT CONFIG_LWIP_IPV6 AND NOT CMAKE_BUILD_EARLY_EXPANSION)\n    # note: the component is still included in the build so it can become visible again in config\n    # without needing to re-run CMake. However no source or header files are built.\n    message(STATUS \"IPV6 support is disabled so the asio component will not be built\")\n    idf_component_register()\n    return()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Validating MQTT Broker Using Internal Certificate Bundle\nDESCRIPTION: These commands connect to a broker using SSL/TLS while validating its certificate against the ESP-IDF internal CA bundle. The '--use-internal-bundle' flag invokes built-in validation logic. Requires broker URI to start with 'mqtts://'. Output includes status or error messages regarding the connection and certificate verification.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nmqtt -h mqtts://mqtt.eclipseprojects.io -C --use-internal-bundle\nmqtt -h mqtts://test.mosquitto.org -C --use-internal-bundle\n\n```\n\n----------------------------------------\n\nTITLE: Compiling AFL and its LLVM Mode (Bash)\nDESCRIPTION: Details the process of compiling the American Fuzzy Lop (AFL) tool and its associated LLVM mode. It involves navigating into the extracted AFL source directory and running `make` in the main directory and then in the `llvm_mode/` subdirectory. Requires build dependencies like make, clang, and llvm to be installed.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ncd [PATH_TO_AFL]\nmake\ncd llvm_mode/\nmake\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dummy Network Interfaces with Bash\nDESCRIPTION: Commands to create a dummy network interface named eth2 on a Linux system, assign two IP addresses, enable the interface, and set multicast capabilities required for mDNS operations. Dependencies include root privileges for network configuration. Expected inputs are static IP addresses and interface names, and the output is a configured network interface ready for use in multicast networking.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/host_test/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo ip link add eth2 type dummy\nsudo ip addr add 192.168.1.200/24 dev eth2\nsudo ip addr add 192.168.1.201/24 dev eth2\nsudo ip link set eth2 up\nsudo ifconfig eth2 multicast\n```\n\n----------------------------------------\n\nTITLE: Define Project Name (CMake)\nDESCRIPTION: Sets the name of the project. This name is used by CMake and the build system to refer to the project and is often used for output binaries or directory structures.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(fuzz_test_update)\n```\n\n----------------------------------------\n\nTITLE: Configuring SSH as Proxy\nDESCRIPTION: This snippet provides a command to configure SSH as a proxy for testing purposes on a Linux system. It uses the ssh command with specific options to create a SOCKS proxy listening on localhost port 1080.  The '-N' option prevents the execution of remote commands, '-v' enables verbose mode for debugging, and '-D 0.0.0.0:1080' specifies the dynamic port forwarding.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/socks4/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nssh -N -v -D 0.0.0.0:1080 localhost\n```\n\n----------------------------------------\n\nTITLE: Define Project Name - ESP-IDF\nDESCRIPTION: This line defines the name of the ESP-IDF project. The project name is used to generate the build artifacts and is referenced in other parts of the build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/examples/ping-basic/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(ping-basic)\n```\n\n----------------------------------------\n\nTITLE: Configuring PPP Server on Linux\nDESCRIPTION: Command to run a PPP server that connects to a modem device for testing. The command specifies connection parameters including device, baud rate, IP addresses, DNS settings, and various PPP options.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo pppd /dev/ttyUSB1 115200 192.168.11.1:192.168.11.2 ms-dns 8.8.8.8 modem local noauth debug nocrtscts nodetach +ipv6\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake (3.8) for the project to ensure compatibility.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.8)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Executing ESP Websocket Client on Linux\nDESCRIPTION: These commands demonstrate how to compile and execute the ESP websocket client example within a Linux environment using the ESP-IDF build system. The first command sets the target to 'linux', the second builds the project, and the third executes the resulting binary.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nidf.py --preview set-target linux\nidf.py build\n./websocket.elf\n```\n\n----------------------------------------\n\nTITLE: Setting up ESP-IDF Project with CMake Boilerplate\nDESCRIPTION: This snippet shows the required CMake boilerplate code for an ESP-IDF project. It sets the minimum CMake version, adds unit test components to the build, includes the ESP-IDF project CMake file, and defines the project name.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/test/test_app/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\nset(EXTRA_COMPONENT_DIRS $ENV{IDF_PATH}/tools/unit-test-app/components)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(test_app)\n```\n\n----------------------------------------\n\nTITLE: ESP PPP Link Throughput Metrics\nDESCRIPTION: This section presents throughput performance metrics for the ESP PPP Link component. It details the maximum TCP and UDP throughput rates achievable over UART, SPI, and SDIO interfaces at specified frequencies. The measured results suggest the throughput performance varies significantly based on the physical interface used.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/README.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Setting LWIP Directories\nDESCRIPTION: This snippet sets the LWIP and LWIP Contrib directories using environment variables. These directories are essential for locating the LWIP source code and associated contributions.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_netif_linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(LWIP_DIR \"$ENV{LWIP_PATH}\")\nset(LWIP_CONTRIB_DIR \"$ENV{LWIP_CONTRIB_PATH}\")\n```\n\n----------------------------------------\n\nTITLE: Cleanup of DNS over HTTPS Protocol Resources\nDESCRIPTION: This snippet illustrates how to properly release resources associated with DNS over HTTPS, calling the cleanup function with the handle returned during initialization. Proper cleanup prevents memory leaks and ensures orderly shutdown of DNS services.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nint ret = esp_dns_cleanup_doh(dns_handle);\nif (ret != 0) {\n    ESP_LOGE(TAG, \"Failed to cleanup DNS\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Mutual Project with ESP-IDF Build System in CMake\nDESCRIPTION: A complete CMakeLists.txt configuration for the UDP Mutual project that sets up the ESP-IDF build system. It handles cross-platform building with special consideration for the Linux target by adding FreeRTOS mocks to the component directories.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/examples/udp_mutual_auth/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nif(\"${IDF_TARGET}\" STREQUAL \"linux\")\n    list(APPEND EXTRA_COMPONENT_DIRS \"$ENV{IDF_PATH}/tools/mocks/freertos/\")\nendif()\nproject(udp_mutual)\n```\n\n----------------------------------------\n\nTITLE: Include Console WiFi Header in C\nDESCRIPTION: This C snippet shows the required `#include` directive to make the functions and definitions of the console WiFi component available in your application's source file. This header provides the API for initializing and registering the WiFi console command.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_wifi/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include \"console_wifi.h\"\n```\n\n----------------------------------------\n\nTITLE: Including the Console Ifconfig Header in C\nDESCRIPTION: Includes the necessary header file `console_ifconfig.h` to use the console ifconfig functionality within an ESP-IDF C application. This line must be added to the main application file where the console will be initialized.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include \"console_ifconfig.h\"\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard and Properties in CMake\nDESCRIPTION: Sets specific compiler properties for the component library target. It requires the C++17 standard for compilation and enables compiler-specific extensions (like GNU extensions). This ensures the component is built using a modern C++ version and can potentially utilize compiler-specific features.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/common_components/linux_compat/freertos/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${COMPONENT_LIB} PROPERTIES\n    CXX_STANDARD 17\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS ON\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Linking Thread Library in CMake\nDESCRIPTION: Configures the build system to prefer POSIX threads, finds the necessary 'Threads' package required for threading support, and links the component library (${COMPONENT_LIB}) against it. This ensures the component has access to threading functions, adapting to the underlying OS thread implementation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/common_components/linux_compat/freertos/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(THREADS_PREFER_PTHREAD_FLAG ON)\nfind_package(Threads REQUIRED)\ntarget_link_libraries(${COMPONENT_LIB} PRIVATE Threads::Threads)\n```\n\n----------------------------------------\n\nTITLE: Defining Message Callback Function Type in C for Mosquitto Broker\nDESCRIPTION: Typedef for the message callback function that is called when the broker processes a message. The callback receives client identifier, topic, message data, message length, QoS level, and retain flag.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/api.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef void(* mosq_message_cb_t) (char *client, char *topic, char *data, int len, int qos, int retain);\n```\n\n----------------------------------------\n\nTITLE: Setting AFL Environment Variables (Bash)\nDESCRIPTION: Demonstrates how to configure the shell environment for AFL by exporting the `AFL_PATH` variable (pointing to the AFL installation directory) and adding the AFL binary directory to the system's `PATH`. This allows AFL commands to be executed from any location.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nexport AFL_PATH=[PATH_TO_AFL]\nexport PATH=\"$AFL_PATH:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: PPP Connection Information Output\nDESCRIPTION: Example output of the 'pppd info' command showing the IP configuration of the PPP connection, including the device IP address, subnet mask, and gateway IP.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_iperf/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\niperf> pppd info\nppp:\n  IP: 192.168.11.2\n  MASK: 255.255.255.255\n  GW: 192.168.11.3\n```\n\n----------------------------------------\n\nTITLE: Configuring ESP-IDF Project with CMakeLists.txt for Host Modem Test in CMake\nDESCRIPTION: Defines the build configuration for the 'host_modem_test' project using ESP-IDF's CMake integration. It sets the minimum required CMake version to 3.5, includes the main ESP-IDF project handling script via the IDF_PATH environment variable, and specifies additional component directories including esp_modem and a Linux-specific port. The 'main' component is registered for building. It accesses the esp_modem component's library property to apply compile-time definitions enabling C++ exceptions and setting the target to Linux, and adds sanitizers (address and undefined behavior) to the link options for enhanced debugging. Requires ESP-IDF development environment and correct IDF_PATH setup. Expected input includes the project directory with components; no runtime outputs are produced but the configuration influences compilation and linking behavior.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\\n\\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\\n\\nset(EXTRA_COMPONENT_DIRS    # Add esp_modem component and linux port components\\n        ../..\\n        ../../port/linux)\\n\\nset(COMPONENTS main)\\nproject(host_modem_test)\\n\\nidf_component_get_property(esp_modem esp_modem COMPONENT_LIB)\\ntarget_compile_definitions(${esp_modem} PRIVATE \"-DCONFIG_COMPILER_CXX_EXCEPTIONS\")\\ntarget_compile_definitions(${esp_modem} PRIVATE \"-DCONFIG_IDF_TARGET_LINUX\")\\ntarget_link_options(${esp_modem} INTERFACE -fsanitize=address -fsanitize=undefined)\n```\n\n----------------------------------------\n\nTITLE: Including console_simple_init Header in C\nDESCRIPTION: Includes the main console_simple_init component header file, providing access to the APIs for initializing and managing the ESP console. Required as the first step after adding the component dependency to your project. There are no input parameters; simply place the include directive at the top of your main application source file.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_simple_init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include \"console_simple_init.h\"\n```\n\n----------------------------------------\n\nTITLE: Setting Command Directory Based on Development Mode in CMake for ESP Protocols\nDESCRIPTION: This snippet sets the directory for AT command generation based on whether development mode is enabled, affecting how commands are integrated into the build system. It switches between in-place macro expansion and pre-generated commands.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_ESP_MODEM_ENABLE_DEVELOPMENT_MODE)\n    set(command_dir \"generate\") # using in-place macro expansion with AT commands\nelse()\n    set(command_dir \"command\") # using pre-generated AT commands\nendif()\n```\n\n----------------------------------------\n\nTITLE: mDNS PTR Record Representation (Text)\nDESCRIPTION: Represents a Pointer (PTR) record in mDNS packet analysis output. PTR records are used for service discovery, mapping a service type (like _http._tcp.local.) to specific instance names. The output shows both query (Q) and answer (A) formats, with answers including TTL and the target instance name.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nQ: _airport._tcp.local. PTR IN\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: _airport._tcp.local. PTR IN 2272 [2] Hristo's AirPort Express._airport._tcp.local.\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: _smb._tcp.local. PTR IN 3061 [29] Sofiya Ivanova’s MacBook._smb._tcp.local.\n```\n\n----------------------------------------\n\nTITLE: ESP-PPP Test Application Output Log\nDESCRIPTION: Example log output showing the startup process of the ESP-PPP test application, connection establishment between server and client interfaces, and ping test results. The log also shows what happens when the connection is disrupted by disconnecting wires.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/test/test_app/README.md#_snippet_0\n\nLANGUAGE: log\nCODE:\n```\nI (393) eppp_test_app: [APP] Startup..\nI (393) eppp_test_app: [APP] Free memory: 296332 bytes\nI (393) eppp_test_app: [APP] IDF version: v5.3-dev-1154-gf14d9e7431-dirty\nI (423) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nI (423) uart: queue free spaces: 16\nI (433) eppp_link: Waiting for IP address\nI (433) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nI (443) uart: queue free spaces: 16\nI (443) eppp_link: Waiting for IP address\nI (6473) esp-netif_lwip-ppp: Connected\nI (6513) eppp_link: Got IPv4 event: Interface \"pppos_client\" address: 192.168.11.2\nI (6523) esp-netif_lwip-ppp: Connected\nI (6513) eppp_link: Connected!\nI (6523) eppp_link: Got IPv4 event: Interface \"pppos_server\" address: 192.168.11.1\nI (6553) main_task: Returned from app_main()\n64bytes from 192.168.11.2 icmp_seq=1 ttl=255 time=18 ms\n64bytes from 192.168.11.2 icmp_seq=2 ttl=255 time=19 ms\n64bytes from 192.168.11.2 icmp_seq=3 ttl=255 time=19 ms\n64bytes from 192.168.11.2 icmp_seq=4 ttl=255 time=20 ms\n64bytes from 192.168.11.2 icmp_seq=5 ttl=255 time=19 ms\n64bytes from 192.168.11.2 icmp_seq=6 ttl=255 time=19 ms\n64bytes from 192.168.11.2 icmp_seq=7 ttl=255 time=19 ms\nFrom 192.168.11.2 icmp_seq=8 timeout        // <-- Disconnected Tx-Rx wires\nFrom 192.168.11.2 icmp_seq=9 timeout\n```\n\n----------------------------------------\n\nTITLE: Attaching a SLIP Interface on Linux (Shell)\nDESCRIPTION: Uses the `slattach` command on a Linux system to attach a serial port (`/dev/ttyAMA0`) as a SLIP network interface. The `-v` flag enables verbose output, `-L` enables 3-wire operation, `-s 115200` sets the baud rate, and `-p slip` specifies the SLIP protocol. This is used to create the host-side interface for communicating with the ESP device running the SLIP client example.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nslattach -v -L -s 115200 -p slip /dev/ttyAMA0\n```\n\n----------------------------------------\n\nTITLE: Declaring a generic AT command for all modules in C/C++\nDESCRIPTION: To add a generic command shared by all modules within the `esp_modem::GenericModule`, it needs to be declared in the `include/generate/esp_modem_command_declare.inc` file. This file serves as the single source of supported command definitions used across the C API, C++ API, generated documentation, and command implementation. Correctly specifying parameters and types is crucial, using macros to ensure compatibility between C and C++.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/internal_docs.rst#_snippet_1\n\nLANGUAGE: c/cpp\nCODE:\n```\nesp_modem::GenericModule\n```\n\n----------------------------------------\n\nTITLE: Defining LWIP Contrib Sources\nDESCRIPTION: This snippet defines the source file for the LWIP contrib port for Unix. It specifies the path to the `sys_arch.c` file, which provides system-specific architecture adaptations for LWIP.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/port/linux/esp_netif_linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(lwipcontribportunix_SRCS  ${LWIP_CONTRIB_DIR}/ports/unix/port/sys_arch.c)\n```\n\n----------------------------------------\n\nTITLE: Example of declaring a command parameter using macros\nDESCRIPTION: This example shows how to declare a parameter for a generic command using macros within the `esp_modem_command_declare.inc` file. The macro `INT_IN(p1, baud)` indicates an input integer parameter with the human-readable name \"baud\". It's the first argument, expanding to `p1` during preprocessor expansion.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/internal_docs.rst#_snippet_2\n\nLANGUAGE: c/cpp\nCODE:\n```\nINT_IN(p1, baud)\n```\n\n----------------------------------------\n\nTITLE: Configuring ESP-IDF Project with CMake\nDESCRIPTION: Standard CMake configuration for an ESP-IDF project. Sets the minimum required CMake version to 3.16, includes the ESP-IDF project.cmake file, and defines the project name as sock_utils_example.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/sock_utils/examples/simple/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(sock_utils_example)\n```\n\n----------------------------------------\n\nTITLE: Setting Linux Target Compilation Definition\nDESCRIPTION: Adds a compile definition to specify Linux as the target platform for the tests. This allows code to adapt to Linux-specific behaviors when necessary.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${COMPONENT_LIB} PRIVATE \"-DCONFIG_IDF_TARGET_LINUX\")\n```\n\n----------------------------------------\n\nTITLE: Stopping Mosquitto Broker in C\nDESCRIPTION: Function to stop the running Mosquitto broker. After calling this function, the mosq_broker_run() function will unblock and return.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/api.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid mosq_broker_stop (\n    void\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Basic ESP-IDF Project CMake\nDESCRIPTION: These lines represent the essential boilerplate required at the very beginning of any ESP-IDF project's `CMakeLists.txt` file. They set the minimum required CMake version, include the main ESP-IDF project configuration scripts, and define the name of your project. The order is crucial for correct build system initialization.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_apps/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n\nproject(mdns_test_app)\n```\n\n----------------------------------------\n\nTITLE: Setting Up ESP-IDF Project with CMake - CMake\nDESCRIPTION: This snippet initializes a CMake project for use with ESP-IDF, specifying CMake version 3.5 or above and setting extra component directories. It includes the ESP-IDF build system via an environment variable and declares the project under the name 'pppd_test'. Dependencies include an installed ESP-IDF environment and correctly set environment variables. Inputs include the ESP-IDF path and component directory; outputs are a properly configured build environment. This boilerplate must be included in the exact order shown for proper operation.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n\nset(EXTRA_COMPONENT_DIRS \"../..\")\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(pppd_test)\n```\n\n----------------------------------------\n\nTITLE: Configuring Espressif IDF Project CMake\nDESCRIPTION: This snippet shows the mandatory boilerplate required at the beginning of an Espressif IDF `CMakeLists.txt` file. It specifies the minimum required CMake version, includes the necessary IDF project setup script, and sets the name of the project. These lines must appear in this exact order.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/ap_to_pppos/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(ap-to-pppos)\n```\n\n----------------------------------------\n\nTITLE: Linking Catch2 Testing Framework to ESP-Modem Component\nDESCRIPTION: Links the Catch2 testing framework main library to the component. Catch2 provides the testing framework used for the ESP-Modem unit tests.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${COMPONENT_LIB} PRIVATE Catch2WithMain)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Minimum Version - CMake\nDESCRIPTION: This snippet configures the minimum required CMake version for the project.  It ensures that the build process uses a compatible CMake version.  It's a fundamental step in any CMake project. There are no specific parameters to configure here; it just sets the minimum version requirement.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/socks4/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Installing Flask-Sock Python Package (Shell)\nDESCRIPTION: Command to install the `flask-sock` Python library using pip, the Python package installer. This package is a required dependency for running the provided Python Flask WebSocket echo server example.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\npip install flask-sock\n```\n\n----------------------------------------\n\nTITLE: Configuring GCOV Code Coverage for ESP-Modem Tests\nDESCRIPTION: Sets up code coverage flags when CONFIG_GCOV_ENABLED is defined. Enables coverage reporting for both the test component and the esp_modem library using GCC's coverage options.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/host_test/main/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(CONFIG_GCOV_ENABLED)\n    target_compile_options(${COMPONENT_LIB} PUBLIC --coverage -fprofile-arcs -ftest-coverage)\n    target_link_options(${COMPONENT_LIB} PUBLIC  --coverage -fprofile-arcs -ftest-coverage)\n\n    idf_component_get_property(esp_modem esp_modem COMPONENT_LIB)\n    target_compile_options(${esp_modem} PUBLIC --coverage -fprofile-arcs -ftest-coverage)\n    target_link_options(${esp_modem} PUBLIC  --coverage -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Example Output: DNS resolution information\nDESCRIPTION: This log output demonstrates the execution of DNS resolution using various protocols (UDP, TCP, DoT, DoH) and certificate validation, along with hostname resolutions and memory usage metrics. It showcases successful resolution of domain names like yahoo.com and www.google.com, and IPv4/IPv6 addresses.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_dns/examples/esp_dns_basic/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI (4583) example_esp_dns: Executing DNS without initializing ESP_DNS module\nI (4603) wifi:<ba-add>idx:1 (ifx:0, a0:36:bc:0e:c4:f0), tid:7, ssn:3, winSize:64\nI (4613) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (4613) example_esp_dns: Hostname: yahoo.com: 74.6.143.26(IPv4)\nI (4613) example_esp_dns: Hostname: yahoo.com: 74.6.231.20(IPv4)\nI (4613) wifi:<ba-del>idx:0, tid:6\nI (4623) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (4623) wifi:<ba-add>idx:0 (ifx:0, a0:36:bc:0e:c4:f0), tid:0, ssn:1, winSize:64\nI (4643) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (4643) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (4643) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (4653) example_esp_dns: Free Heap: 215292 bytes, Min Free Heap: 206008 bytes, Stack High Water Mark: 1220 bytes\n\nI (4663) example_esp_dns: Executing UDP DNS\nI (4673) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (4673) example_esp_dns: Hostname: yahoo.com: 74.6.143.26(IPv4)\nI (4683) example_esp_dns: Hostname: yahoo.com: 74.6.231.20(IPv4)\nI (4683) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (4693) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (4703) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (4703) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (4713) example_esp_dns: Free Heap: 215116 bytes, Min Free Heap: 206008 bytes, Stack High Water Mark: 1220 bytes\n\nI (4723) example_esp_dns: Executing TCP DNS\nI (4763) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (4763) example_esp_dns: Hostname: yahoo.com: 74.6.143.26(IPv4)\nI (4763) example_esp_dns: Hostname: yahoo.com: 98.137.11.164(IPv4)\nI (4763) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (4793) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (4793) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (4793) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (4803) example_esp_dns: Free Heap: 214580 bytes, Min Free Heap: 206008 bytes, Stack High Water Mark: 1220 bytes\n\nI (4813) example_esp_dns: Executing DNS over TLS\nI (5963) example_esp_dns: Hostname: yahoo.com: 74.6.143.25(IPv4)\nI (5963) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (5963) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (5973) example_esp_dns: Hostname: yahoo.com: 74.6.231.20(IPv4)\nI (7083) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (7083) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (7083) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (7093) example_esp_dns: Free Heap: 213504 bytes, Min Free Heap: 165308 bytes, Stack High Water Mark: 1220 bytes\n\nI (7103) example_esp_dns: Executing DNS over TLS\nI (7413) esp-x509-crt-bundle: Certificate validated\nI (8233) example_esp_dns: Hostname: yahoo.com: 98.137.11.164(IPv4)\nI (8233) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (8233) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (8243) example_esp_dns: Hostname: yahoo.com: 74.6.231.20(IPv4)\nI (8553) esp-x509-crt-bundle: Certificate validated\nI (9363) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (9363) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (9363) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (9373) example_esp_dns: Free Heap: 213120 bytes, Min Free Heap: 165308 bytes, Stack High Water Mark: 1220 bytes\n\nI (9383) example_esp_dns: Executing DNS over HTTPS\nI (10563) example_esp_dns: Hostname: yahoo.com: 74.6.143.26(IPv4)\nI (10563) example_esp_dns: Hostname: yahoo.com: 74.6.231.20(IPv4)\nI (10563) example_esp_dns: Hostname: yahoo.com: 74.6.143.25(IPv4)\nI (10573) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (11713) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (11713) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (11723) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (11723) example_esp_dns: Free Heap: 212664 bytes, Min Free Heap: 162780 bytes, Stack High Water Mark: 1220 bytes\n\nI (11733) example_esp_dns: Executing DNS over HTTPS\nI (12033) esp-x509-crt-bundle: Certificate validated\nI (12863) example_esp_dns: Hostname: yahoo.com: 74.6.231.21(IPv4)\nI (12863) example_esp_dns: Hostname: yahoo.com: 98.137.11.163(IPv4)\nI (12863) example_esp_dns: Hostname: yahoo.com: 98.137.11.164(IPv4)\nI (12873) example_esp_dns: Hostname: yahoo.com: 74.6.143.25(IPv4)\nI (13153) esp-x509-crt-bundle: Certificate validated\nI (13993) example_esp_dns: Hostname: www.google.com: 2404:6800:4015:803::2004(IPv6)\nI (13993) example_esp_dns: Hostname: 0.0.0.0: 0.0.0.0(IPv4)\nI (13993) example_esp_dns: Hostname: fe80:0000:0000:0000:5abf:25ff:fee0:4100: FE80::5ABF:25FF:FEE0:4100(IPv6)\nI (14003) example_esp_dns: Free Heap: 212044 bytes, Min Free Heap: 162780 bytes, Stack High Water Mark: 1220 bytes\n\nI (14013) main_task: Returned from app_main()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version in ESP32 Project\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.16. This is crucial for ensuring compatibility with the project's build scripts and dependencies. It must precede other CMake commands that rely on specific version features. There are no dependencies for this snippet.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/unit_test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Set Minimum Required CMake Version (CMake)\nDESCRIPTION: Specifies the minimum required version of CMake needed to successfully process this CMakeLists.txt file. This ensures that the build environment supports the syntax and features used in the script.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mbedtls_cxx/tests/uart_mutual_auth/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Using IDF.py (ESP-TLS)\nDESCRIPTION: This snippet shows how to generate documentation for ESP-TLS using the idf.py tool.  It utilizes the 'docs' command with the '-sp' option to specify the target documentation file path.  The command will generate or open the appropriate documentation within the specified file.  It requires the ESP-IDF environment to be set up correctly.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/broker/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nidf.py docs -sp api-reference/protocols/esp_tls.html\n```\n\n----------------------------------------\n\nTITLE: Defining the ESP-Protocols Project\nDESCRIPTION: This snippet defines the project name as 'query_advertise' with the 'project()' command, indicating the start of the build configuration for this specific ESP-IDF project. It establishes the project scope and build target.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/examples/query_advertise/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(query_advertise)\n```\n\n----------------------------------------\n\nTITLE: Defining ESP-IDF Project Name (CMake)\nDESCRIPTION: This line defines the name of the project. The project name is used by the build system for various purposes, including generating build artifacts and targets. In this specific example, the project is named \"asio_chat\".\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/asio_chat/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(asio_chat)\n```\n\n----------------------------------------\n\nTITLE: Setting Component Directories\nDESCRIPTION: Sets the directories where the project's components are located. EXTRA_COMPONENT_DIRS specifies additional directories containing components that the project depends on, including compatibility layers (linux_compat) and example-related component directories. common_component_dir defines the location of common component directory.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(common_component_dir ../../../../common_components)\nset(EXTRA_COMPONENT_DIRS\n   ../..\n  \"${common_component_dir}/linux_compat/esp_timer\"\n  \"${common_component_dir}/linux_compat/freertos\"\n   $ENV{IDF_PATH}/examples/protocols/linux_stubs/esp_stubs\n   $ENV{IDF_PATH}/examples/common_components/protocol_examples_common)\n```\n\n----------------------------------------\n\nTITLE: Handling Initial SABM Command in CMux\nDESCRIPTION: This code snippet modifies the handling of the initial SABM (Set Asynchronous Balanced Mode) command within the CMux protocol. It adds an alternative type check (0x3f) in addition to the existing (FT_UA | PF) check to correctly identify and acknowledge the SABM command even when data is null and length is 0.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/README.rst#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n      -    } else if (data == nullptr && type == (FT_UA | PF) && len == 0) { // notify the initial SABM command\n      +    } else if (data == nullptr && (type == (FT_UA | PF) || type == 0x3f) && len == 0) { // notify the initial SABM command\n            Scoped<Lock> l(lock);\n            sabm_ack = dlci;\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple WebSocket Echo Server using Python Flask\nDESCRIPTION: Provides Python code for a basic WebSocket echo server using Flask and the Flask-Sock extension. The server listens on all interfaces (0.0.0.0) by default. When a client connects to the '/' route via WebSocket, it enters a loop, receiving any data sent by the client and sending it back immediately. Includes instructions for running in production using Gunicorn.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_websocket_client/examples/target/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom flask import Flask\nfrom flask_sock import Sock\n\napp = Flask(__name__)\nsock = Sock(app)\n\n\n@sock.route('/')\ndef echo(ws):\n    while True:\n        data = ws.receive()\n        ws.send(data)\n\n\nif __name__ == '__main__':\n    # To run your Flask + WebSocket server in production you can use Gunicorn:\n    # gunicorn -b 0.0.0.0:5000 --workers 4 --threads 100 module:app\n    app.run(host=\"0.0.0.0\", debug=True)\n```\n\n----------------------------------------\n\nTITLE: ESP-PPP Manual API Test Case Output Log\nDESCRIPTION: Example log output from the manual API test case (taskless mode) where the user manually drives the Rx task. This shows connection establishment, ping test results, and proper resource cleanup with memory leak detection.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/test/test_app/README.md#_snippet_1\n\nLANGUAGE: log\nCODE:\n```\nTEST(eppp_test, open_close_taskless)I (28562) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nI (28572) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nNote: esp_netif_init() has been called. Until next reset, TCP/IP task will periodicially allocate memory and consume CPU time.\nI (28602) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nI (28612) uart: queue free spaces: 16\nI (28612) uart: ESP_INTR_FLAG_IRAM flag not set while CONFIG_UART_ISR_IN_IRAM is enabled, flag updated\nI (28622) uart: queue free spaces: 16\nI (28642) esp-netif_lwip-ppp: Connected\nI (28642) esp-netif_lwip-ppp: Connected\nI (28642) test: Got IPv4 event: Interface \"pppos_server(EPPP0)\" address: 192.168.11.1\nI (28642) esp-netif_lwip-ppp: Connected\nI (28652) test: Got IPv4 event: Interface \"pppos_client(EPPP1)\" address: 192.168.11.2\nI (28662) esp-netif_lwip-ppp: Connected\n64bytes from 192.168.11.2 icmp_seq=1 ttl=255 time=93 ms\n64bytes from 192.168.11.2 icmp_seq=2 ttl=255 time=98 ms\n64bytes from 192.168.11.2 icmp_seq=3 ttl=255 time=99 ms\n64bytes from 192.168.11.2 icmp_seq=4 ttl=255 time=99 ms\n64bytes from 192.168.11.2 icmp_seq=5 ttl=255 time=99 ms\n5 packets transmitted, 5 received, time 488ms\nI (29162) esp-netif_lwip-ppp: User interrupt\nI (29162) test: Disconnected interface \"pppos_client(EPPP1)\"\nI (29172) esp-netif_lwip-ppp: User interrupt\nI (29172) test: Disconnected interface \"pppos_server(EPPP0)\"\nMALLOC_CAP_8BIT usage: Free memory delta: 0 Leak threshold: -64\nMALLOC_CAP_32BIT usage: Free memory delta: 0 Leak threshold: -64\n PASS\n```\n\n----------------------------------------\n\nTITLE: Navigating to Certificate Directory using Shell\nDESCRIPTION: This shell snippet changes the working directory to 'certs', typically where SSL/TLS certificates are stored or managed for the MQTT connection setup. It is a prerequisite for executing OpenSSL commands for key/certificate generation. No input parameters are required; the output is simply the shell's new working directory.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncd certs\n\n```\n\n----------------------------------------\n\nTITLE: ESP-IDF Project Inclusion and Project Name Definition\nDESCRIPTION: This code includes the project configuration file from the ESP-IDF and sets the project's name to \"modem-console\". The include statement uses the IDF_PATH environment variable to find the necessary CMake configuration files. This is a crucial step for utilizing the ESP-IDF build system. The project name will be used to generate the executable and other build artifacts.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_console/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(modem-console)\n```\n\n----------------------------------------\n\nTITLE: mDNS TXT Record Representation (Text)\nDESCRIPTION: Represents a Text (TXT) record in mDNS packet analysis output. TXT records provide additional descriptive information about a service instance, often in key-value pairs. The output shows the answer (A) format, including the instance name, TTL, data length, and the text data.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristo's AirPort Express._airport._tcp.local. TXT IN FLUSH 4500 [166] waMA=98-01-A7-E5-8F-A1,raMA=98-01-A7-E8-C2-2E,raM2=98-01-A7-E8-C2-2F,raNm=your-ssid,raCh=1,rCh2=52,raSt=0,raNA=1,syFl=0x8A0C,syAP=115,syVs=7.6.8,srcv=76800.1,bjSd=23\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristo’s Mac mini._device-info._tcp.local. TXT IN 4500 [28] model=Macmini6,2; osxvers=16\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristo's Time Capsule._adisk._tcp.local. TXT IN FLUSH 4500 [110] sys=waMA=70:73:CB:B4:C9:B3,adVF=0x1000; dk2=adVF=0x1083,adVN=Capsule,adVU=55fabb8b-a63b-5441-9874-6edb504eb30a\n```\n\n----------------------------------------\n\nTITLE: Installing AFL Dependencies on Ubuntu (Bash)\nDESCRIPTION: Shows the `apt-get` command to install essential packages required for compiling and running AFL on Ubuntu systems. This includes make, clang (version <= 4.0), llvm (version <= 4.0), and libbsd-dev.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nsudo apt-get install make clang-4.0(or <=4.0) llvm-4.0(or <=4.0) libbsd-dev\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project CMake\nDESCRIPTION: This snippet contains the mandatory boilerplate lines for any ESP-IDF project's CMakeLists.txt file. It sets the minimum required CMake version, includes the core ESP-IDF project functions, and defines the name of the project, which is used throughout the build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_mqtt/examples/mqtt_ssl_auth_console/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\nproject(mqtt_ssl_auth_console)\n```\n\n----------------------------------------\n\nTITLE: Initializing ESP-IDF Project with CMake in CMake\nDESCRIPTION: Defines the minimum required CMake version as 3.16, includes the ESP-IDF project configuration from the environmental variable IDF_PATH, and declares a new ESP-IDF project called 'mqtt_tcp_cxx'. These commands must appear in this precise order in the CMakeLists.txt file for the ESP-IDF build system to work correctly. There are no additional parameters or inputs beyond the environment variable setup.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/tcp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)  \ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)  \nproject(mqtt_tcp_cxx)\n```\n\n----------------------------------------\n\nTITLE: mDNS NSEC Record Representation (Text)\nDESCRIPTION: Represents a Next Secure (NSEC) record in mDNS packet analysis output. NSEC records are part of DNSSEC and are used in mDNS to prove that a requested record does not exist and to list the types that do exist for a name. The output shows the answer (A) format, including the name, TTL, data length, the next name in the zone, and a type bitmask.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_5\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristo's AirPort Express.local. NSEC IN FLUSH 4500 [9] Hristo's AirPort Express._airport._tcp.local.  00 05 00 00 80 00 40\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: minifritz.local. NSEC IN FLUSH 120 [8] minifritz...local.  00 04 40 00 00 08\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Hristos-Time-Capsule.local. NSEC IN FLUSH 120 [8] Hristos-Time-Capsule...local.  00 04 40 00 00 08\n```\n\n----------------------------------------\n\nTITLE: Configuring Commitizen for New Component (YAML)\nDESCRIPTION: This YAML snippet provides a template for the .cz.yaml configuration file required for new components. It defines commitizen's behavior for version bumping, tag formatting, pre-bump hooks (like running ci/changelog.py), the initial version, and specifies idf_component.yml as the file to update with the version number. This file is crucial for managing component versions using the project's defined process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ncommitizen:\n  bump_message: 'bump([scope]): $current_version -> $new_version'\n  pre_bump_hooks: python ../../ci/changelog.py [component]\n  tag_format: [component]-v$version\n  version: 0.0.0\n  version_files:\n  - idf_component.yml\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Setup (CMake)\nDESCRIPTION: This line includes the standard ESP-IDF project setup file, which provides necessary functions, macros, and variables for configuring and building ESP-IDF applications. It relies on the IDF_PATH environment variable being set correctly. This step is crucial for integrating the project with the ESP-IDF build system.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/asio/examples/asio_chat/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Building mDNS AFL Tests with AFL Instrumentation (Bash)\nDESCRIPTION: Navigates to the mDNS AFL test directory within the ESP-IDF path and executes the `make fuzz` command. This builds the test executable with AFL instrumentation, enabling fuzz testing of the mDNS parser. Requires AFL and its dependencies to be installed and configured.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ncd $IDF_PATH/components/mdns/test_afl_host\nmake fuzz\n```\n\n----------------------------------------\n\nTITLE: Bumping Component Version using ci/bump Script (Shell)\nDESCRIPTION: This shell command executes the ci/bump script to manage component versions. It uses arguments for the component name, an optional specific version, and an optional custom commit message. This script automates the version update process, interacts with the component's .cz.yaml configuration, and prepares the necessary commit for version bumps during both component creation and release.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nci/bump [component] [version] --bump-message \"bump([scope]): First version [version]\"\n```\n\nLANGUAGE: shell\nCODE:\n```\nci/bump [component] [version]\n```\n\n----------------------------------------\n\nTITLE: Include ESP-IDF Project CMake Utilities\nDESCRIPTION: This line includes the project.cmake file from the ESP-IDF tools directory. This file provides essential functions and macros for building ESP-IDF projects.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ping/examples/ping-basic/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project Configuration - CMake\nDESCRIPTION: Includes the core ESP-IDF CMake project configuration file. This file, located within the IDF_PATH, integrates the ESP-IDF build system into the standard CMake process, providing necessary functions and variables for building ESP-IDF projects. It depends on the IDF_PATH environment variable being set.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/examples/esp_netif/slip_custom_netif/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project CMake Tools\nDESCRIPTION: Includes the necessary CMake tools provided by the ESP-IDF (Espressif IoT Development Framework). This allows access to ESP-IDF's build system functions and configurations. The path to the tools is obtained from the IDF_PATH environment variable.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_mqtt_cxx/examples/ssl/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including IDF Project Configuration in ESP32 Project\nDESCRIPTION: This includes the IDF project configuration file, which provides essential project-level configurations and settings for an ESP32 project using the ESP-IDF framework. The file is located through the IDF_PATH environment variable. It is dependent on the IDF environment being correctly set up. The output of this snippet is the project being configured for build.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/unit_test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including ESP-IDF Project CMake Modules\nDESCRIPTION: This snippet includes the main ESP-IDF project CMake script using the environment variable 'IDF_PATH'. It sets up the necessary build environment and loads project-specific build rules. Dependencies include the ESP-IDF build system and environment setup.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/examples/ifconfig-basic/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude($ENV{IDF_PATH}/tools/cmake/project.cmake)\n```\n\n----------------------------------------\n\nTITLE: Adapting CMUX Entry Sequence for CAVLI C16QS\nDESCRIPTION: This patch modifies the CMUX entry sequence for the CAVLI C16QS modem to handle its specific response. It adapts the esp_modem_cmux.cpp file to accommodate the modem's non-standard response during CMUX mode entry.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/esp_modem/en/README.rst#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/components/esp_modem/src/esp_modem_cmux.cpp b/components/esp_modem/src/esp_modem_cmux.cpp\nindex c47e13b..7afbf73 100644\n--- a/components/esp_modem/src/esp_modem_cmux.cpp\n+++ b/components/esp_modem/src/esp_modem_cmux.cpp\n@@ -137,7 +137,8 @@ bool CMux::data_available(uint8_t *data, size_t len)\n } else {\n       return false;\n```\n\n----------------------------------------\n\nTITLE: ESP PPP Link Component Overview\nDESCRIPTION: This section provides an overview of the ESP PPP Link component and its functionality. It outlines the role of the component in establishing connectivity between microcontrollers using a serial connection and the PPP protocol. The component acts as a bridge, with one microcontroller (SLAVE) providing the network connection and the other (HOST) acting as a client, accessing the network through the PPP server.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/eppp_link/README.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and C++ Standard Setting\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.8 and sets the C++ standard to C++17. These are essential configurations for the CMake build process, ensuring compatibility and enabling modern C++ features for the project. No external dependencies are required. The output of this snippet is used in subsequent CMake commands to configure the build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_console/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.8)\nset(CMAKE_CXX_STANDARD 17)\n```\n\n----------------------------------------\n\nTITLE: Including ASIO Documentation File in RST\nDESCRIPTION: A ReStructuredText include directive that references the main ESP-ASIO documentation file located in the English API reference section. This directive instructs the documentation build system to insert the contents of the referenced file at this location.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/docs/asio/zh_CN/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../../../en/api-reference/protocols/asio.rst\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for ESP Project\nDESCRIPTION: This snippet enforces a minimum required version of CMake (3.8) to ensure compatibility and proper functioning of the build scripts. It is a prerequisite step for all subsequent CMake configurations.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/test/target_ota/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.8)\n```\n\n----------------------------------------\n\nTITLE: Defining the Project Name\nDESCRIPTION: This snippet assigns the project name 'ifconfig-basic' to be used within the build system, establishing the project identity for the ESP-IDF build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/console_cmd_ifconfig/examples/ifconfig-basic/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(ifconfig-basic)\n```\n\n----------------------------------------\n\nTITLE: Defining the Project Name\nDESCRIPTION: Sets the project name to 'modem_tcp_client', which is used by CMake for build targeting and output directory structuring.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/esp_modem/examples/modem_tcp_client/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(modem_tcp_client)\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project Name\nDESCRIPTION: This snippet defines the name of the CMake project as 'serverless_mqtt'. This name is used to identify the project during the build process.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mosquitto/examples/serverless_mqtt/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nproject(serverless_mqtt)\n```\n\n----------------------------------------\n\nTITLE: mDNS AAAA Record Representation (Text)\nDESCRIPTION: Represents an IPv6 Address (AAAA) record in mDNS packet analysis output. AAAA records map a hostname to one or more IPv6 addresses. The output shows both query (Q) and answer (A) formats, with answers including TTL, data length, and the IPv6 address.\nSOURCE: https://github.com/espressif/esp-protocols/blob/master/components/mdns/tests/test_afl_fuzz_host/input_packets.txt#_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\nQ: minifritz.local. AAAA IN FLUSH\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: minifritz.local. AAAA IN FLUSH 120 [16] fe80:0000:0000:0000:142e:54ff:b8c4:fd09\n```\n\nLANGUAGE: Text\nCODE:\n```\nA: Sofiya-Ivanovas-MacBook.local. AAAA IN FLUSH 120 [16] fe80:0000:0000:0000:021c:b3ff:feb2:72a3\n```"
  }
]